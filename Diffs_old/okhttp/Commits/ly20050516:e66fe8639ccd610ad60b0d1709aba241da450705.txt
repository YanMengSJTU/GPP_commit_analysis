diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index 4e141cad64..d9a8e909da 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -3,7 +3,7 @@
 # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
 #
 # Adapted from https://coderwall.com/p/9b_lfq and
-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
 
 SLUG="square/okhttp"
 JDK="oraclejdk8"
@@ -21,6 +21,6 @@ elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -DskipTests
   echo "Snapshot deployed!"
 fi
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 0b26b8467b..7543438302 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -10,6 +10,14 @@ sure your code compiles by running `mvn clean verify`. Checkstyle failures
 during compilation indicate errors in your style and can be viewed in the
 `checkstyle-result.xml` file.
 
+Some general advice
+
+- Don’t change public API lightly, avoid if possible, and include your reasoning in the PR if essential.  It causes pain for developers who use OkHttp and sometimes runtime errors.
+- Favour a working external library if appropriate.  There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.
+- Get working code on a personal branch with tests before you submit a PR.
+- OkHttp is a small and light dependency.  Don't introduce new dependencies or major new functionality.
+- OkHttp targets the intersection of RFC correct *and* widely implemented.  Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.
+
 Before your code can be accepted into the project you must also sign the
 [Individual Contributor License Agreement (CLA)][1].
 
diff --git a/.travis.yml b/.travis.yml
index 3173507916..1ebb5eb306 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,12 +2,15 @@ language: java
 
 jdk:
   - oraclejdk8
+#  - openjdk11
 
 addons:
   apt:
     packages:
       - oracle-java8-installer # Updates JDK 8 to the latest available.
 
+script: mvn test javadoc:jar source:jar -B
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
@@ -28,8 +31,3 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
-
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 86e3bee13f..1f480f2c40 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,281 @@
 Change Log
 ==========
 
+## Version 3.12.0
+
+_2018-11-16_
+
+ *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
+
+ *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
+    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
+    Authenticators should identify preemptive authentications by the presence of a challenge whose
+    scheme is "OkHttp-Preemptive".
+
+ *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
+    take and covers resolving DNS, connecting, writing the request body, server processing, and
+    reading the full response body. If a call requires redirects or retries all must complete within
+    one timeout period.
+
+    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
+    specify the timeout of an individual call.
+
+ *  New: Return values and fields are now non-null unless otherwise annotated.
+ *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
+    This class is in the `logging-interceptor` artifact.
+ *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
+    immediate exception.
+ *  New: Headers can be redacted in `HttpLoggingInterceptor`.
+ *  New: `Headers.Builder` now accepts dates.
+ *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
+ *  New: `Challenge` includes all authentication parameters.
+ *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
+    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
+
+    ```kotlin
+    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
+    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
+    implementation("com.squareup.okio:okio:1.15.0")
+    ```
+
+ *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
+    call its callback now gets a `RejectedExecutionException`.
+ *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
+    original `immutable` proposal!
+ *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
+    could be called with null in some cases.
+ *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
+ *  Fix: Don't crash if the system default authenticator is null.
+ *  Fix: Don't crash generating elliptic curve certificates on Android.
+ *  Fix: Don't crash doing platform detection on RoboVM.
+ *  Fix: Don't leak socket connections when web socket upgrades fail.
+
+
+## Version 3.11.0
+
+_2018-07-12_
+
+ *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
+
+    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
+    builder then use it to sign another certificate or perform a TLS handshake. The
+    `certificatePem()` method encodes the certificate in the familiar PEM format
+    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
+
+    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
+    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
+    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
+    mutual TLS where these roles are reversed.
+
+    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
+    code][https_server_sample].
+
+ *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
+    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
+    only supports `http:` URLs and is best suited in closed environments where HTTPS is
+    inappropriate.
+
+ *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
+    when the URL is malformed instead of returning null. Use this to avoid checking for null in
+    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
+    which is an exception-throwing alternative to `MediaType.parse(String)`.
+ *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
+    interface to track metrics and monitor HTTP requests' size and duration.
+ *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
+    for DNS offers better security and potentially better performance. This feature is a preview:
+    the API is subject to change.
+ *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
+    and is only suitable for experimental use.
+ *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
+    to permit an optional client certificate or `requireClientAuth()` to require one.
+ *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
+    `MockWebServer`.
+ *  Fix: Honor the `MockResponse` header delay in MockWebServer.
+ *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
+    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
+    harmed connection reuse.
+ *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
+    flow control window. We had a few bugs where window size accounting was broken when streams
+    were canceled or reset.
+ *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
+    suite (`SSL_NULL_WITH_NULL_NULL`).
+ *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
+    configuring only OkHttp's TLS sockets.
+ *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
+    to TLSv1.2.
+ *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
+    that `tag()` now returns null if the request has no tag. Previously this would return the
+    request itself.
+ *  New: `Headers.Builder.addAll(Headers)`.
+ *  New: `ResponseBody.create(MediaType, ByteString)`.
+ *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
+ *  Fix: Release the connection if `Authenticator` throws an exception.
+ *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
+    value has always been nullable but it wasn't declared properly.
+ *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
+    throw the initial exception which is most likely to be actionable.
+ *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
+    now be sufficient to break out an in-flight OkHttp call.
+ *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
+    interceptor.
+
+
+## Version 3.10.0
+
+_2018-02-24_
+
+ *  **The pingInterval() feature now aggressively checks connectivity for web
+    sockets and HTTP/2 connections.**
+
+    Previously if you configured a ping interval that would cause OkHttp to send
+    pings, but it did not track whether the reply pongs were received. With this
+    update OkHttp requires that every ping receive a response: if it does not
+    the connection will be closed and the listener's `onFailure()` method will
+    be called.
+
+    Web sockets have always been had pings, but pings on HTTP/2 connections is
+    new in this release. Pings are used for connections that are busy carrying
+    calls and for idle connections in the connection pool. (Pings do not impact
+    when pooled connections are evicted).
+
+    If you have a configured ping interval, you should confirm that it is long
+    enough for a roundtrip from client to server. If your ping interval is too
+    short, slow connections may be misinterpreted as failed connections. A ping
+    interval of 30 seconds is reasonable for most use cases.
+
+ *  **OkHttp now supports [Conscrypt][conscrypt].** Conscrypt is a Java Security
+    Provider that integrates BoringSSL into the Java platform. Conscrypt
+    supports more cipher suites than the JVM’s default provider and may also
+    execute more efficiently.
+
+    To use it, first register a [Conscrypt dependency][conscrypt_dependency] in
+    your build system.
+
+    OkHttp will use Conscrypt if you set the `okhttp.platform` system property
+    to `conscrypt`.
+
+    Alternatively, OkHttp will also use Conscrypt if you install it as your
+    preferred security provider. To do so, add the following code to execute
+    before you create your `OkHttpClient`.
+
+    ```
+    Security.insertProviderAt(
+        new org.conscrypt.OpenSSLProvider(), 1);
+    ```
+
+    Conscrypt is the bundled security provider on Android so it is not necessary
+    to configure it on that platform.
+
+ *  New: `HttpUrl.addQueryParameter()` percent-escapes more characters.
+    Previously several ASCII punctuation characters were not percent-escaped
+    when used with this method. This does not impact already-encoded query
+    parameters in APIs like `HttpUrl.parse()` and
+    `HttpUrl.Builder.addEncodedQueryParameter()`.
+ *  New: CBC-mode ECDSA cipher suites have been removed from OkHttp's default
+    configuration: `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` and
+    `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`. This tracks a [Chromium
+    change][remove_cbc_ecdsa] to remove these cipher suites because they are
+    fragile and rarely-used.
+ *  New: Don't fall back to common name (CN) verification for hostnames. This
+    behavior was deprecated with RFC 2818 in May 2000 and was recently dropped
+    from major web browsers.
+ *  New: Honor the `Retry-After` response header. HTTP 503 (Unavailable)
+    responses are retried automatically if this header is present and its delay
+    is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically
+    if the header is absent or its delay is 0 seconds.
+ *  New: Allow request bodies for all HTTP methods except GET and HEAD.
+ *  New: Automatic module name of `okhttp3` for use with the Java Platform
+    Module System.
+ *  New: Log gzipped bodies when `HttpLoggingInterceptor` is used as a network
+    interceptor.
+ *  New: `Protocol.QUIC` constant. This protocol is not supported but this
+    constant is included for completeness.
+ *  New: Upgrade to Okio 1.14.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.14.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.14.0
+     ```
+
+ *  Fix: Handle `HTTP/1.1 100 Continue` status lines, even on requests that did
+    not send the `Expect: continue` request header.
+ *  Fix: Do not count web sockets toward the dispatcher's per-host connection
+    limit.
+ *  Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing
+    with the error, `Unexpected TLS version: NONE`.
+ *  Fix: Don't corrupt the response cache when a 304 (Not Modified) response
+    overrides the stored "Content-Encoding" header.
+ *  Fix: Gracefully shut down the HTTP/2 connection before it exhausts the
+    namespace of stream IDs (~536 million streams).
+ *  Fix: Never pass a null `Route` to `Authenticator`. There was a bug where
+    routes were omitted for eagerly-closed connections.
+
+## Version 3.9.1
+
+_2017-11-18_
+
+ *  New: Recover gracefully when Android's DNS crashes with an unexpected
+    `NullPointerException`.
+ *  New: Recover gracefully when Android's socket connections crash with an
+    unexpected `ClassCastException`.
+ *  Fix: Don't include the URL's fragment in `encodedQuery()` when the query
+    itself is empty.
+
+## Version 3.9.0
+
+_2017-09-03_
+
+ *  **Interceptors are more capable.** The `Chain` interface now offers access
+    to the call and can adjust all call timeouts. Note that this change is
+    source-incompatible for code that implements the `Chain` interface.
+    We don't expect this to be a problem in practice!
+
+ *  **OkHttp has an experimental new API for tracking metrics.** The new
+    `EventListener` API is designed to help developers monitor HTTP requests'
+    size and duration. This feature is an unstable preview: the API is subject
+    to change, and the implementation is incomplete. This is a big new API we
+    are eager for feedback.
+
+ *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
+    expands HTTP/2 support to older Android devices that have Google Play
+    Services.
+ *  New: Consider all routes when looking for candidate coalesced connections.
+    This increases the likelihood that HTTP/2 connections will be shared.
+ *  New: Authentication challenges and credentials now use a charset. Use this in
+    your authenticator to support user names and passwords with non-ASCII
+    characters.
+ *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
+    always UTF-8.
+ *  New: Support the `immutable` cache-control directive.
+ *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
+    being shut down.
+ *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
+    This bug would cause HTTP/2 streams to occasional hang when the connection
+    was shutting down.
+ *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
+    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
+    once in response to a 408.
+ *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
+    a `Content-Length`.
+ *  Fix: Don't crash if the thread is interrupted while reading the public
+    suffix database.
+ *  Fix: Use relative resource path when loading the public suffix database.
+    Loading the resource using a path relative to the class prevents conflicts
+    when the OkHttp classes are relocated (shaded) by allowing multiple private
+    copies of the database.
+ *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
+ *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
+    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
+    this was confusing.
+ *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
+ *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
+
+
 ## Version 3.8.1
 
 _2017-06-18_
@@ -838,7 +1113,7 @@ _2014-12-30_
     for OkHttp 2.0 and 2.1 will continue to work with this update.
 
  *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
-    [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    [POODLE](https://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
     vulnerability, OkHttp no longer offers SSLv3 when negotiation an
     HTTPS connection. If you continue to need to connect to webservers
     running SSLv3, you must manually configure your own `ConnectionSpec`.
@@ -1318,6 +1593,10 @@ Initial release.
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
  [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
- [junit_5_rules]: http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [junit_5_rules]: https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
  [public_suffix]: https://publicsuffix.org/
  [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
+ [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
+ [conscrypt]: https://github.com/google/conscrypt/
+ [conscrypt_dependency]: https://github.com/google/conscrypt/#download
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
\ No newline at end of file
diff --git a/README.md b/README.md
index 1754c6d0c7..fcecace952 100644
--- a/README.md
+++ b/README.md
@@ -6,17 +6,10 @@ An HTTP & HTTP/2 client for Android and Java applications. For more information
 Download
 --------
 
-Download [the latest JAR][3] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp</artifactId>
-  <version>3.8.1</version>
-</dependency>
-```
-or Gradle:
-```groovy
-compile 'com.squareup.okhttp3:okhttp:3.8.1'
+Download [the latest JAR][3] or configure this dependency:
+
+```kotlin
+implementation("com.squareup.okhttp3:okhttp:3.12.0")
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -31,29 +24,19 @@ MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so
 
 ### Download
 
-Download [the latest JAR][4] or grab via Maven:
+Download [the latest JAR][4] or configure this dependency:
 ```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>3.8.1</version>
-  <scope>test</scope>
-</dependency>
-```
-or Gradle:
-```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.8.1'
+testImplementation("com.squareup.okhttp3:mockwebserver:3.12.0")
 ```
 
-ProGuard
---------
+R8 / ProGuard
+-------------
+
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro).
+
+You might also need rules for Okio which is a dependency of this library.
 
-If you are using ProGuard you might need to add the following options:
-```
--dontwarn okio.**
--dontwarn javax.annotation.Nullable
--dontwarn javax.annotation.ParametersAreNonnullByDefault
-```
 
 License
 -------
@@ -71,7 +54,7 @@ License
     limitations under the License.
 
 
- [1]: http://square.github.io/okhttp
+ [1]: https://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
  [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
  [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 80ed4470a0..2b03eb0062 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -36,12 +36,13 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <artifactId>okhttp-tls</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
@@ -74,6 +75,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>exec-maven-plugin</artifactId>
+        <version>1.5.0</version>
         <executions>
           <execution>
             <goals>
@@ -129,6 +131,7 @@
             <!-- Fails on caliper's ASM on OpenJDK 8. -->
             <groupId>org.codehaus.mojo</groupId>
             <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <version>1.15</version>
             <executions>
               <execution>
                 <phase>none</phase>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index 2fffd7cbf8..e3dbd3084c 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -20,7 +20,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -31,6 +31,8 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.conn.PoolingClientConnectionManager;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /** Benchmark Apache HTTP client. */
 class ApacheHttpClient extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -41,9 +43,9 @@
     super.prepare(benchmark);
     ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
+      HandshakeCertificates handshakeCertificates = localhost();
       connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
+          new Scheme("https", 443, new SSLSocketFactory(handshakeCertificates.sslContext())));
     }
     client = new DefaultHttpClient(connectionManager);
   }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 0ec59a0573..081fcfccb9 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -28,14 +28,16 @@
 import java.util.logging.Logger;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.GzipSink;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
  * connection to a MockWebServer to measure how many identical requests per second can be carried
@@ -160,8 +162,8 @@ private MockWebServer startServer() throws IOException {
     MockWebServer server = new MockWebServer();
 
     if (tls) {
-      SslClient sslClient = SslClient.localhost();
-      server.useHttps(sslClient.socketFactory, false);
+      HandshakeCertificates handshakeCertificates = localhost();
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server.setProtocols(protocols);
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index cd7286d374..35731fa3b1 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -44,7 +44,9 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLEngine;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
@@ -64,12 +66,12 @@
     this.targetBacklog = benchmark.targetBacklog;
 
     ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
-      @Override public void initChannel(SocketChannel channel) throws Exception {
+      @Override public void initChannel(SocketChannel channel) {
         ChannelPipeline pipeline = channel.pipeline();
 
         if (benchmark.tls) {
-          SslClient sslClient = SslClient.localhost();
-          SSLEngine engine = sslClient.sslContext.createSSLEngine();
+          HandshakeCertificates handshakeCertificates = localhost();
+          SSLEngine engine = handshakeCertificates.sslContext().createSSLEngine();
           engine.setUseClientMode(true);
           pipeline.addLast("ssl", new SslHandler(engine));
         }
@@ -152,7 +154,7 @@ private void sendRequest(HttpUrl url) {
     }
 
     @Override protected void channelRead0(
-        ChannelHandlerContext context, HttpObject message) throws Exception {
+        ChannelHandlerContext context, HttpObject message) {
       if (message instanceof HttpResponse) {
         receive((HttpResponse) message);
       }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 7460aa66f6..86b44523a2 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -25,7 +25,9 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -39,15 +41,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index 57cb75cacc..d6d0bc5cb4 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -31,7 +31,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -54,15 +56,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = client.newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index 560534c829..96eb7422cd 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -25,7 +25,9 @@
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -33,8 +35,8 @@
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
diff --git a/bom/pom.xml b/bom/pom.xml
new file mode 100644
index 0000000000..373316262c
--- /dev/null
+++ b/bom/pom.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-bom</artifactId>
+  <version>3.13.0-SNAPSHOT</version>
+  <packaging>pom</packaging>
+  <name>OkHttp (Bill of Materials)</name>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tests</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-android-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-apache</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-sse</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-testing-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tls</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-urlconnection</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-logging-interceptor</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-dnsoverhttps</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okcurl</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>mockwebserver</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+</project>
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 06cf0723f5..73503bb6d2 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -152,7 +152,7 @@ Get MockWebServer via Maven:
 
 or via Gradle 
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+testImplementation 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
 ```
 
 ### License
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 00aae47aa4..92ced6b41d 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -25,8 +25,10 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
@@ -39,6 +41,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -49,6 +52,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -63,6 +67,18 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.mockwebserver</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
new file mode 100644
index 0000000000..d1eea00397
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
+
+/**
+ * Internal access to MockWebServer APIs. Don't use this, don't use internal, these APIs are not
+ * stable.
+ */
+public abstract class MwsDuplexAccess {
+  public static MwsDuplexAccess instance;
+
+  public abstract void setBody(MockResponse mockResponse, DuplexResponseBody duplexResponseBody);
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
deleted file mode 100644
index eedfc2a094..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
- * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
- * held certificates, as done in practice by certificate authorities.
- */
-public final class HeldCertificate {
-  public final X509Certificate certificate;
-  public final KeyPair keyPair;
-
-  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public static final class Builder {
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private final long duration = 1000L * 60 * 60 * 24; // One day.
-    private String hostname;
-    private List<String> altNames = new ArrayList<>();
-    private String serialNumber = "1";
-    private KeyPair keyPair;
-    private HeldCertificate issuedBy;
-    private int maxIntermediateCas;
-
-    public Builder serialNumber(String serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /**
-     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
-     * the CN (common name) in the certificate. Will be a random string if no value is provided.
-     */
-    public Builder commonName(String hostname) {
-      this.hostname = hostname;
-      return this;
-    }
-
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
-     * generated.
-     */
-    public Builder issuedBy(HeldCertificate signedBy) {
-      this.issuedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
-     * intermediate certificate authorities beneath it.
-     */
-    public Builder ca(int maxIntermediateCas) {
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
-     * If no subject alternative names are added that extension will not be used.
-     */
-    public Builder subjectAlternativeName(String altName) {
-      altNames.add(altName);
-      return this;
-    }
-
-    public HeldCertificate build() throws GeneralSecurityException {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-      X500Principal subject = hostname != null
-          ? new X500Principal("CN=" + hostname)
-          : new X500Principal("CN=" + UUID.randomUUID());
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long now = System.currentTimeMillis();
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(new BigInteger(serialNumber));
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(now));
-      generator.setNotAfter(new Date(now + duration));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-
-      if (maxIntermediateCas > 0) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      X509Certificate certificate = generator.generateX509Certificate(
-          signedByKeyPair.getPrivate(), "BC");
-      return new HeldCertificate(certificate, heldKeyPair);
-    }
-
-    public KeyPair generateKeyPair() throws GeneralSecurityException {
-      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-      keyPairGenerator.initialize(1024, new SecureRandom());
-      return keyPairGenerator.generateKeyPair();
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
deleted file mode 100644
index 8fb994394a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
- * create a secure connection.
- */
-public final class SslClient {
-  private static SslClient localhost; // Lazily initialized.
-
-  public final SSLContext sslContext;
-  public final SSLSocketFactory socketFactory;
-  public final X509TrustManager trustManager;
-
-  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
-    this.sslContext = sslContext;
-    this.socketFactory = sslContext.getSocketFactory();
-    this.trustManager = trustManager;
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized SslClient localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getHostName())
-          .build();
-
-      localhost = new Builder()
-          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
-
-      return localhost;
-    } catch (GeneralSecurityException | UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static class Builder {
-    private final List<X509Certificate> chainCertificates = new ArrayList<>();
-    private final List<X509Certificate> certificates = new ArrayList<>();
-    private KeyPair keyPair;
-    private String keyStoreType = KeyStore.getDefaultType();
-
-    /**
-     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
-     * the server's certificate, further certificates are included in the handshake so the client
-     * can build a trusted path to a CA certificate.
-     */
-    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
-      X509Certificate[] certificates = new X509Certificate[chain.length];
-      for (int i = 0; i < chain.length; i++) {
-        certificates[i] = chain[i].certificate;
-      }
-      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
-    }
-
-    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
-        X509Certificate... certificates) {
-      this.keyPair = keyPair;
-      this.chainCertificates.add(keyCert);
-      this.chainCertificates.addAll(Arrays.asList(certificates));
-      this.certificates.addAll(Arrays.asList(certificates));
-      return this;
-    }
-
-    /**
-     * Add a certificate authority that this client trusts. Servers that provide certificate chains
-     * signed by these roots (or their intermediates) will be accepted.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.certificates.add(certificate);
-      return this;
-    }
-
-    public Builder keyStoreType(String keyStoreType) {
-      this.keyStoreType = keyStoreType;
-      return this;
-    }
-
-    public SslClient build() {
-      try {
-        // Put the certificate in a key store.
-        char[] password = "password".toCharArray();
-        KeyStore keyStore = newEmptyKeyStore(password);
-
-        if (keyPair != null) {
-          Certificate[] certificates = chainCertificates.toArray(
-              new Certificate[chainCertificates.size()]);
-          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
-        }
-
-        for (int i = 0; i < certificates.size(); i++) {
-          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
-        }
-
-        // Wrap it up in an SSL context.
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-            KeyManagerFactory.getDefaultAlgorithm());
-        keyManagerFactory.init(keyStore, password);
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-            TrustManagerFactory.getDefaultAlgorithm());
-        trustManagerFactory.init(keyStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-          throw new IllegalStateException("Unexpected default trust managers:"
-              + Arrays.toString(trustManagers));
-        }
-
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom());
-
-        return new SslClient(sslContext, (X509TrustManager) trustManagers[0]);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-
-    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-      try {
-        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-        InputStream in = null; // By convention, 'null' creates an empty key store.
-        keyStore.load(in, password);
-        return keyStore;
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 73691d4b54..65231c8953 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -22,6 +22,7 @@
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http2.Settings;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -43,9 +44,13 @@
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
+  private long headersDelayAmount = 0;
+  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
+
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
+  private DuplexResponseBody duplexResponseBody;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -152,6 +157,14 @@ public MockResponse removeHeader(String name) {
     return this;
   }
 
+  boolean isDuplex() {
+    return duplexResponseBody != null;
+  }
+
+  DuplexResponseBody getDuplexResponseBody() {
+    return duplexResponseBody;
+  }
+
   /** Returns a copy of the raw HTTP payload. */
   public Buffer getBody() {
     return body != null ? body.clone() : null;
@@ -168,6 +181,11 @@ public MockResponse setBody(String body) {
     return setBody(new Buffer().writeUtf8(body));
   }
 
+  MockResponse setBody(DuplexResponseBody duplexResponseBody) {
+    this.duplexResponseBody = duplexResponseBody;
+    return this;
+  }
+
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
@@ -253,6 +271,16 @@ public long getBodyDelay(TimeUnit unit) {
     return unit.convert(bodyDelayAmount, bodyDelayUnit);
   }
 
+  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
+    headersDelayAmount = delay;
+    headersDelayUnit = unit;
+    return this;
+  }
+
+  public long getHeadersDelay(TimeUnit unit) {
+    return unit.convert(headersDelayAmount, headersDelayUnit);
+  }
+
   /**
    * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
    * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index abbd79edb9..28a8963c47 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -19,7 +19,6 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
@@ -60,6 +59,9 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.internal.duplex.MwsDuplexAccess;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Header;
@@ -69,6 +71,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -79,6 +82,7 @@
 import org.junit.rules.ExternalResource;
 
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -90,6 +94,8 @@
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
@@ -99,8 +105,18 @@
 public final class MockWebServer extends ExternalResource implements Closeable {
   static {
     Internal.initializeInstanceForTests();
+    MwsDuplexAccess.instance = new MwsDuplexAccess() {
+      @Override public void setBody(
+          MockResponse mockResponse, DuplexResponseBody duplexResponseBody) {
+        mockResponse.setBody(duplexResponseBody);
+      }
+    };
   }
 
+  private static final int CLIENT_AUTH_NONE = 0;
+  private static final int CLIENT_AUTH_REQUESTED = 1;
+  private static final int CLIENT_AUTH_REQUIRED = 2;
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -131,6 +147,7 @@
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
   private boolean tunnelProxy;
+  private int clientAuth = CLIENT_AUTH_NONE;
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
@@ -156,12 +173,13 @@ public int getPort() {
 
   public String getHostName() {
     before();
-    return inetSocketAddress.getHostName();
+    return inetSocketAddress.getAddress().getCanonicalHostName();
   }
 
   public Proxy toProxyAddress() {
     before();
-    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
+    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
+            .getCanonicalHostName(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
@@ -211,7 +229,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
+    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+      // when using h2_prior_knowledge, no other protocol should be supported.
+      throw new IllegalArgumentException(
+          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        && !protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -220,6 +243,10 @@ public void setProtocols(List<Protocol> protocols) {
     this.protocols = protocols;
   }
 
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    *
@@ -230,6 +257,36 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.tunnelProxy = tunnelProxy;
   }
 
+  /**
+   * Configure the server to not perform SSL authentication of the client. This leaves
+   * authentication to another layer such as in an HTTP cookie or header. This is the default and
+   * most common configuration.
+   */
+  public void noClientAuth() {
+    this.clientAuth = CLIENT_AUTH_NONE;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. The connection will also proceed normally if the client presents no
+   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
+   * and no connection will be established.
+   */
+  public void requestClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUESTED;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
+   * handshake will fail and no connection will be established.
+   */
+  public void requireClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUIRED;
+  }
+
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
    * request was sent as intended. This method will block until the request is available, possibly
@@ -404,13 +461,13 @@ private void serveConnection(final Socket raw) {
       }
 
       public void processConnection() throws Exception {
+        SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
         Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
             createTunnel();
           }
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == FAIL_HANDSHAKE) {
             dispatchBookkeepingRequest(sequenceNumber, raw);
             processHandshakeFailure(raw);
@@ -420,6 +477,11 @@ public void processConnection() throws Exception {
               raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
+          if (clientAuth == CLIENT_AUTH_REQUIRED) {
+            sslSocket.setNeedClientAuth(true);
+          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
+            sslSocket.setWantClientAuth(true);
+          }
           openClientSockets.add(socket);
 
           if (protocolNegotiationEnabled) {
@@ -433,11 +495,18 @@ public void processConnection() throws Exception {
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
+        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+          socket = raw;
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         } else {
           socket = raw;
         }
 
-        if (protocol == Protocol.HTTP_2) {
+        if (socketPolicy == STALL_SOCKET_AT_START) {
+          return; // Ignore the socket until the server is shut down!
+        }
+
+        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
@@ -464,8 +533,6 @@ public void processConnection() throws Exception {
               + " didn't make a request");
         }
 
-        source.close();
-        sink.close();
         socket.close();
         openClientSockets.remove(socket);
       }
@@ -533,6 +600,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
+        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
+          shutdown();
         }
 
         sequenceNumber++;
@@ -580,7 +649,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
-    boolean readBody = true;
+    boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
       Internal.instance.addLenient(headers, header);
@@ -594,25 +663,23 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
       }
       if (lowercaseHeader.startsWith("expect:")
           && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
-        readBody = false;
+        expectContinue = true;
       }
     }
 
-    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+    final SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+    if (expectContinue && socketPolicy == EXPECT_CONTINUE || socketPolicy == CONTINUE_ALWAYS) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
       sink.flush();
-      readBody = true;
     }
 
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
     MockResponse policy = dispatcher.peek();
-    if (!readBody) {
-      // Don't read the body unless we've invited the client to send it.
-    } else if (contentLength != -1) {
+    if (contentLength != -1) {
       hasBody = contentLength > 0;
       throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
@@ -667,29 +734,30 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       }
     };
     RealWebSocket webSocket = new RealWebSocket(fancyRequest,
-        response.getWebSocketListener(), new SecureRandom());
+        response.getWebSocketListener(), new SecureRandom(), 0);
     response.getWebSocketListener().onOpen(webSocket, fancyResponse);
     String name = "MockWebServer WebSocket " + request.getPath();
-    webSocket.initReaderAndWriter(name, 0, streams);
+    webSocket.initReaderAndWriter(name, streams);
     try {
       webSocket.loopReader();
 
       // Even if messages are no longer being read we need to wait for the connection close signal.
       try {
         connectionClose.await();
-      } catch (InterruptedException ignored) {
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
       }
 
     } catch (IOException e) {
       webSocket.failWebSocket(e, null);
     } finally {
-      closeQuietly(sink);
       closeQuietly(source);
     }
   }
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
@@ -705,12 +773,11 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
 
     Buffer body = response.getBody();
     if (body == null) return;
-    sleepIfDelayed(response);
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
     throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
-  private void sleepIfDelayed(MockResponse response) {
-    long delayMs = response.getBodyDelay(TimeUnit.MILLISECONDS);
+  private void sleepIfDelayed(long delayMs) {
     if (delayMs != 0) {
       try {
         Thread.sleep(delayMs);
@@ -767,7 +834,7 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
         try {
           Thread.sleep(periodDelayMs);
         } catch (InterruptedException e) {
-          throw new AssertionError();
+          throw new AssertionError(e);
         }
       }
     }
@@ -849,7 +916,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
           stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
           return;
         } catch (InterruptedException e) {
-          throw new InterruptedIOException();
+          throw new AssertionError(e);
         }
       }
 
@@ -867,7 +934,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
         socket.close();
         return;
       }
-      writeResponse(stream, response);
+      writeResponse(stream, request, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
             + " and responded: " + response + " protocol is " + protocol.toString());
@@ -880,31 +947,35 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
     }
 
     private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      List<Header> streamHeaders = stream.getRequestHeaders();
+      Headers streamHeaders = stream.takeHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        ByteString name = streamHeaders.get(i).name;
-        String value = streamHeaders.get(i).value.utf8();
-        if (name.equals(Header.TARGET_METHOD)) {
+        String name = streamHeaders.name(i);
+        String value = streamHeaders.value(i);
+        if (name.equals(Header.TARGET_METHOD_UTF8)) {
           method = value;
-        } else if (name.equals(Header.TARGET_PATH)) {
+        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
           path = value;
-        } else if (protocol == Protocol.HTTP_2) {
-          httpHeaders.add(name.utf8(), value);
+        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+          httpHeaders.add(name, value);
         } else {
           throw new IllegalStateException();
         }
-        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
           // Don't read the body unless we've invited the client to send it.
           readBody = false;
         }
       }
+      Headers headers = httpHeaders.build();
 
-      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
-        stream.sendResponseHeaders(Collections.singletonList(
+      MockResponse peek = dispatcher.peek();
+      if (peek.isDuplex()) {
+        readBody = false;
+      } else if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+        stream.writeHeaders(Collections.singletonList(
             new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
         stream.getConnection().flush();
         readBody = true;
@@ -912,16 +983,21 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
 
       Buffer body = new Buffer();
       if (readBody) {
-        body.writeAll(stream.getSource());
+        String contentLengthString = headers.get("content-length");
+        long byteCount = contentLengthString != null
+            ? Long.parseLong(contentLengthString)
+            : Long.MAX_VALUE;
+        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
       }
 
       String requestLine = method + ' ' + path + " HTTP/1.1";
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-      return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
+      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
+    private void writeResponse(final Http2Stream stream,
+        final RecordedRequest request, final MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -931,8 +1007,8 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
         return;
       }
       List<Header> http2Headers = new ArrayList<>();
-      String[] statusParts = response.getStatus().split(" ", 2);
-      if (statusParts.length != 2) {
+      String[] statusParts = response.getStatus().split(" ", 3);
+      if (statusParts.length < 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
@@ -942,21 +1018,49 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
         http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
 
+      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
+
       Buffer body = response.getBody();
-      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
-      pushPromises(stream, response.getPushPromises());
+      boolean hasResponseBody = body != null
+          || !response.getPushPromises().isEmpty()
+          || response.isDuplex();
+      stream.writeHeaders(http2Headers, hasResponseBody);
+      pushPromises(stream, request, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
-        sleepIfDelayed(response);
-        throttledTransfer(response, socket, body, sink, bodyLimit, false);
+        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+        throttledTransfer(response, socket, body, sink, body.size(), false);
         sink.close();
-      } else if (closeStreamAfterHeaders) {
+      } else if (response.isDuplex()) {
+        final BufferedSink sink = Okio.buffer(stream.getSink());
+        final BufferedSource source = Okio.buffer(stream.getSource());
+        final DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
+        HeadersListener headersListener =
+            duplexResponseBody.onRequest(request, source, new HttpSink() {
+              @Override public BufferedSink sink() {
+                return sink;
+              }
+
+              @Override public void headers(Headers headers) throws IOException {
+                List<Header> headerList = new ArrayList<>(headers.size() / 2);
+                for (int i = 0, size = headers.size(); i < size; i++) {
+                  headerList.add(new Header(headers.name(i), headers.value(i)));
+                }
+                stream.writeHeaders(headerList, true);
+              }
+
+              @Override public void close() throws IOException {
+                sink.close();
+              }
+            });
+        stream.setHeadersListener(headersListener);
+      } else if (hasResponseBody) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, RecordedRequest request,
+        List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
@@ -973,7 +1077,7 @@ private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws
         boolean hasBody = pushPromise.response().getBody() != null;
         Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.response());
+        writeResponse(pushedStream, request, pushPromise.response());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 672d42bc76..52beb79323 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -16,9 +16,13 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
@@ -30,11 +34,11 @@
   private final String method;
   private final String path;
   private final Headers headers;
+  private final Handshake handshake;
   private final List<Integer> chunkSizes;
   private final long bodySize;
   private final Buffer body;
   private final int sequenceNumber;
-  private final TlsVersion tlsVersion;
   private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
@@ -45,20 +49,38 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
     this.bodySize = bodySize;
     this.body = body;
     this.sequenceNumber = sequenceNumber;
-    this.tlsVersion = socket instanceof SSLSocket
-        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
-        : null;
+    if (socket instanceof SSLSocket) {
+      try {
+        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    } else {
+      this.handshake = null;
+    }
 
     if (requestLine != null) {
       int methodEnd = requestLine.indexOf(' ');
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
-      this.path = requestLine.substring(methodEnd + 1, pathEnd);
+      String path = requestLine.substring(methodEnd + 1, pathEnd);
+      if (!path.startsWith("/")) {
+        path = "/";
+      }
+      this.path = path;
 
       String scheme = socket instanceof SSLSocket ? "https" : "http";
-      String hostname = socket.getInetAddress().getHostName();
-      int port = socket.getLocalPort();
-      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
+      InetAddress inetAddress = socket.getLocalAddress();
+
+      String hostname = inetAddress.getHostName();
+      if (inetAddress instanceof Inet6Address) {
+        hostname = "[" + hostname + "]";
+      }
+
+      int localPort = socket.getLocalPort();
+      // Allow null in failure case to allow for testing bad requests
+      this.requestUrl =
+          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
     } else {
       this.requestUrl = null;
       this.method = null;
@@ -128,7 +150,15 @@ public int getSequenceNumber() {
 
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
-    return tlsVersion;
+    return handshake != null ? handshake.tlsVersion() : null;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this request, or null if the request
+   * was received without TLS.
+   */
+  public Handshake getHandshake() {
+    return handshake;
   }
 
   @Override public String toString() {
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 521c5a0e58..beeb2c9a6d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -31,6 +31,11 @@
  */
 public enum SocketPolicy {
 
+  /**
+   * Shutdown {@link MockWebServer} after writing response.
+   */
+  SHUTDOWN_SERVER_AFTER_RESPONSE,
+
   /**
    * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
    */
@@ -88,8 +93,14 @@
   SHUTDOWN_OUTPUT_AT_END,
 
   /**
-   * Don't respond to the request but keep the socket open. For testing read response header timeout
-   * issue.
+   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
+   * framing. Ignore the socket completely until the server is shut down.
+   */
+  STALL_SOCKET_AT_START,
+
+  /**
+   * Read the request but don't respond to it. Just keep the socket open. For testing read response
+   * header timeout issue.
    */
   NO_RESPONSE,
 
@@ -104,5 +115,11 @@
    * Typically this response is sent when a client makes a request with the header {@code
    * Expect: 100-continue}.
    */
-  EXPECT_CONTINUE
+  EXPECT_CONTINUE,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body even
+   * if the client does not send the header {@code Expect: 100-continue} in its request.
+   */
+  CONTINUE_ALWAYS
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
new file mode 100644
index 0000000000..b903cd6957
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver.internal.duplex;
+
+import java.io.IOException;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.BufferedSource;
+
+public interface DuplexResponseBody {
+  HeadersListener onRequest(
+      RecordedRequest request,
+      BufferedSource requestBodySource,
+      HttpSink responseBodySink) throws IOException;
+}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 5f189dc608..ec8317e95e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -39,7 +39,7 @@
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      public MockResponse dispatch(RecordedRequest request) {
         requestsMade.add(request);
         return new MockResponse();
       }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index 13cefd60f0..eb41f4fbca 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,14 +27,21 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Util;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -43,9 +50,11 @@
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -106,6 +115,17 @@
     assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
   }
 
+  @Test public void mockResponseSetHeaders() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookies: delicious");
+
+    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
+
+    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+  }
+
   @Test public void regularResponse() throws Exception {
     server.enqueue(new MockResponse().setBody("hello world"));
 
@@ -281,7 +301,7 @@
     in.close();
   }
 
-  @Test public void disconnectRequestHalfway() throws IOException {
+  @Test public void disconnectRequestHalfway() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
     // Limit the size of the request body that the server holds in memory to an arbitrary
     // 3.5 MBytes so this test can pass on devices with little memory.
@@ -300,11 +320,15 @@
       try {
         out.write(data);
         out.flush();
+        if (i == 513) {
+          // pause slightly after half way to make result more predictable
+          Thread.sleep(100);
+        }
       } catch (IOException e) {
         break;
       }
     }
-    assertEquals(512f, i, 10f); // Halfway +/- 1%
+    assertEquals(512f, i, 5f); // Halfway +/- 0.5%
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -427,4 +451,140 @@
     assertEquals("/a/deep/path", requestUrl.encodedPath());
     assertEquals("foo bar", requestUrl.queryParameter("key"));
   }
+
+  @Test public void shutdownServerAfterRequest() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+
+    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
+
+    try {
+      refusedConnection.getResponseCode();
+      fail("Second connection should be refused");
+    } catch (ConnectException e ) {
+      assertTrue(e.getMessage().contains("refused"));
+    }
+  }
+
+  @Test public void http100Continue() throws Exception {
+    server.enqueue(new MockResponse().setBody("response"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setDoOutput(true);
+    connection.setRequestProperty("Expect", "100-Continue");
+    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("response", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("request", request.getBody().readUtf8());
+  }
+
+  @Test public void testH2PriorKnowledgeServerFallback() {
+    try {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeServerDuplicates() {
+    try {
+      // Treating this use case as user error
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
+    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+
+    assertEquals(1, server.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, server.protocols().get(0));
+  }
+
+  @Test public void https() throws Exception {
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNull(handshake.peerPrincipal());
+    assertEquals(0, handshake.peerCertificates().size());
+  }
+
+  @Test public void httpsWithClientAuth() throws Exception {
+    HeldCertificate clientCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverCa)
+        .addSubjectAlternativeName(server.getHostName())
+        .build();
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientCa.certificate())
+        .heldCertificate(serverCertificate)
+        .build();
+
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.requestClientAuth();
+
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientCa)
+        .build();
+    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCa.certificate())
+        .heldCertificate(clientCertificate)
+        .build();
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+  }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
new file mode 100644
index 0000000000..e74e3c5275
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.Random;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class RecordedRequestTest {
+  Headers headers = new Headers.Builder().build();
+
+  private class FakeSocket extends Socket {
+    private final InetAddress localAddress;
+    private final int remotePort;
+    private final InetAddress remoteAddress;
+    private final int localPort;
+
+    private FakeSocket(int localPort) {
+      this(Inet4Address.getLoopbackAddress(), localPort);
+    }
+
+    private FakeSocket(InetAddress inetAddress, int localPort) {
+      this(inetAddress, localPort, inetAddress, 1234);
+    }
+
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+      this.localAddress = localAddress;
+      this.localPort = localPort;
+      this.remoteAddress = remoteAddress;
+      this.remotePort = remotePort;
+    }
+
+    @Override public InetAddress getInetAddress() {
+      return remoteAddress;
+    }
+
+    @Override public InetAddress getLocalAddress() {
+      return localAddress;
+    }
+
+    @Override public int getLocalPort() {
+      return localPort;
+    }
+
+    @Override public int getPort() {
+      return remotePort;
+    }
+  }
+
+  @Test public void testIPv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testIPv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
+        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://[::1]/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testUsesLocal() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
similarity index 90%
rename from mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index 643ab1eb4c..7d3b09a2cb 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.http2;
+package okhttp3.mockwebserver.internal.http2;
 
 import java.io.File;
 import java.io.IOException;
@@ -28,15 +28,19 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
 import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** A basic HTTP/2 server that serves the contents of a local directory. */
 public final class Http2Server extends Http2Connection.Listener {
@@ -92,11 +96,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
 
   @Override public void onStream(Http2Stream stream) throws IOException {
     try {
-      List<Header> requestHeaders = stream.getRequestHeaders();
+      Headers requestHeaders = stream.takeHeaders();
       String path = null;
       for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-          path = requestHeaders.get(i).value.utf8();
+        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
+          path = requestHeaders.value(i);
           break;
         }
       }
@@ -126,7 +130,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
@@ -138,7 +142,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -153,7 +157,7 @@ private void serveFile(Http2Stream stream, File file) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     Source source = Okio.source(file);
     try {
       BufferedSink out = Okio.buffer(stream.getSink());
@@ -182,7 +186,7 @@ public static void main(String... args) throws Exception {
     }
 
     Http2Server server = new Http2Server(new File(args[0]),
-        SslClient.localhost().sslContext.getSocketFactory());
+        localhost().sslContext().getSocketFactory());
     server.run();
   }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 85b6b55647..3511624331 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -20,13 +20,14 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
+      <artifactId>logging-interceptor</artifactId>
       <version>${project.version}</version>
-      <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>io.airlift</groupId>
@@ -56,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -91,6 +93,18 @@
           <flags>-Xbootclasspath/p:$0</flags>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.curl</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index ddff8e6790..4b1fd21087 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -47,6 +47,9 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.http2.Http2;
+import okhttp3.internal.platform.Platform;
+import okhttp3.logging.HttpLoggingInterceptor;
+import okhttp3.logging.LoggingEventListener;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -120,6 +123,11 @@ private static String protocols() {
   @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
+  @Option(
+      name = {"-v", "--verbose"},
+      description = "Makes " + NAME + " verbose during the operation")
+  public boolean verbose;
+
   @Arguments(title = "url", description = "Remote resource URL")
   public String url;
 
@@ -183,6 +191,16 @@ private OkHttpClient createClient() {
       builder.sslSocketFactory(sslSocketFactory, trustManager);
       builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
+    if (verbose) {
+      HttpLoggingInterceptor.Logger logger =
+          new HttpLoggingInterceptor.Logger() {
+            @Override
+            public void log(String message) {
+              System.out.println(message);
+            }
+          };
+      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
+    }
     return builder.build();
   }
 
@@ -257,7 +275,7 @@ private static X509TrustManager createInsecureTrustManager() {
 
   private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
     try {
-      SSLContext context = SSLContext.getInstance("TLS");
+      SSLContext context = Platform.get().getSSLContext();
       context.init(null, new TrustManager[] {trustManager}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index ef5f02808f..2b2d2b5e7a 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -27,6 +27,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
@@ -51,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
@@ -58,6 +65,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.androidsupport</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 53470ce87b..09a438807f 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -35,14 +35,15 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -58,7 +59,7 @@
  * </ul>
  */
 public class CacheAdapterTest {
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
   private OkHttpClient client;
@@ -123,7 +124,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -253,7 +255,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -281,7 +284,7 @@ private URL configureServer(MockResponse mockResponse) throws Exception {
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
     return server.url("/").url();
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index c14d6d57f4..ad5d3fdfd3 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -660,7 +660,7 @@ private static Response createArbitraryOkResponse() {
   }
 
   private static RequestBody createRequestBody(String bodyText) {
-    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+    return RequestBody.create(MediaType.get("text/plain"), bodyText);
   }
 
   private static ResponseBody createResponseBody(String bodyText) {
@@ -668,7 +668,7 @@ private static ResponseBody createResponseBody(String bodyText) {
     final long contentLength = source.size();
     return new ResponseBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index 51bf46cc88..eb95e3ea4e 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -26,13 +26,11 @@
 import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.charset.StandardCharsets;
@@ -40,7 +38,6 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.LinkedHashMap;
@@ -63,11 +60,11 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -78,6 +75,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -96,7 +94,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private ResponseCache cache;
   private CookieManager cookieManager;
   private OkUrlFactory urlFactory;
@@ -111,7 +109,7 @@
     cookieManager = new CookieManager();
   }
 
-  @After public void tearDown() throws Exception {
+  @After public void tearDown() {
     ResponseCache.setDefault(null);
   }
 
@@ -272,14 +270,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
 
@@ -291,7 +289,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
 
@@ -350,7 +348,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -364,7 +362,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -388,7 +387,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -403,7 +402,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -480,7 +480,7 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1196,7 +1196,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1466,7 +1466,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1475,7 +1475,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1563,14 +1564,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1674,7 +1667,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("A", readAscii(connection));
   }
 
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
     Internal.instance.addLenient(headers, ": A");
@@ -1769,8 +1762,7 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
@@ -1795,7 +1787,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
+  private Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(result));
     sink.writeUtf8(data);
@@ -1898,7 +1890,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
             aborted.set(true);
           }
 
-          @Override public OutputStream getBody() throws IOException {
+          @Override public OutputStream getBody() {
             return null;
           }
         };
@@ -1924,10 +1916,9 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override
       public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders)
-          throws IOException {
+          Map<String, List<String>> requestHeaders) {
         return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
+          @Override public Map<String, List<String>> getHeaders() {
             String contentType = "text/plain";
             Map<String, List<String>> headers = new LinkedHashMap<>();
             headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
@@ -1939,7 +1930,7 @@ public CacheResponse get(URI uri, String requestMethod,
             return headers;
           }
 
-          @Override public InputStream getBody() throws IOException {
+          @Override public InputStream getBody() {
             return new ByteArrayInputStream(cachedContent);
           }
         };
@@ -1988,32 +1979,32 @@ private InsecureResponseCache(ResponseCache delegate) {
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
     AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(connection1));
 
     // Not cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(hostnameVerifier);
     assertEquals("DEF", readAscii(connection2));
   }
 
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+  @Test public void responseCacheRequestHeaders() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
+          Map<String, List<String>> requestHeaders) {
         requestHeadersRef.set(requestHeaders);
         return null;
       }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 5c35b8d6c9..4a1179e779 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -48,6 +48,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -56,6 +57,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.apache</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index 45d27aafd1..c55543f569 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -8,7 +8,7 @@
 
 /** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
 final class HttpEntityBody extends RequestBody {
-  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.get("application/octet-stream");
 
   private final HttpEntity entity;
   private final MediaType mediaType;
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
new file mode 100644
index 0000000000..30132b47c8
--- /dev/null
+++ b/okhttp-dnsoverhttps/README.md
@@ -0,0 +1,5 @@
+OkHttp DNS over HTTPS Implementation
+====================================
+
+This module is an experimental implementation of DNS over HTTPS using OkHttp.
+API is not considered stable and may change at any time.
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
new file mode 100644
index 0000000000..224f432979
--- /dev/null
+++ b/okhttp-dnsoverhttps/pom.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-dnsoverhttps</artifactId>
+  <name>OkHttp DNS over HTTPS</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.dnsoverhttps</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
similarity index 53%
rename from okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
rename to okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
index 03e8ce08e9..2cd474d30b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.dnsoverhttps;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
-import java.util.Collections;
 import java.util.List;
 import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing route selection
- * fallbacks to prevent the host machine's various IP addresses from interfering.
+ * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
+ *
+ * Returns hardcoded results for the known host.
  */
-public class SingleInetAddressDns implements Dns {
+final class BootstrapDns implements Dns {
+  private final String dnsHostname;
+  private final List<InetAddress> dnsServers;
+
+  BootstrapDns(String dnsHostname, List<InetAddress> dnsServers) {
+    this.dnsHostname = dnsHostname;
+    this.dnsServers = dnsServers;
+  }
+
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
+    if (!this.dnsHostname.equals(hostname)) {
+      throw new UnknownHostException(
+          "BootstrapDns called for " + hostname + " instead of " + dnsHostname);
+    }
+
+    return dnsServers;
   }
 }
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
new file mode 100644
index 0000000000..67442f3313
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import javax.annotation.Nullable;
+import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+import okio.ByteString;
+
+/**
+ * DNS over HTTPS implementation.
+ *
+ * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
+ *
+ * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
+ * using either the HTTP GET or POST method and the other requirements
+ * of this section.  The DNS API server defines the URI used by the
+ * request through the use of a URI Template.</blockquote>
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * <p><strong>As of OkHttp 3.11, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 3.12 or 3.13 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
+ */
+public class DnsOverHttps implements Dns {
+  public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
+  public static final int MAX_RESPONSE_SIZE = 64 * 1024;
+  private final OkHttpClient client;
+  private final HttpUrl url;
+  private final boolean includeIPv6;
+  private final boolean post;
+  private final boolean resolvePrivateAddresses;
+  private final boolean resolvePublicAddresses;
+
+  DnsOverHttps(Builder builder) {
+    if (builder.client == null) {
+      throw new NullPointerException("client not set");
+    }
+    if (builder.url == null) {
+      throw new NullPointerException("url not set");
+    }
+
+    this.url = builder.url;
+    this.includeIPv6 = builder.includeIPv6;
+    this.post = builder.post;
+    this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
+    this.resolvePublicAddresses = builder.resolvePublicAddresses;
+    this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
+  }
+
+  private static Dns buildBootstrapClient(Builder builder) {
+    List<InetAddress> hosts = builder.bootstrapDnsHosts;
+
+    if (hosts != null) {
+      return new BootstrapDns(builder.url.host(), hosts);
+    } else {
+      return builder.systemDns;
+    }
+  }
+
+  public HttpUrl url() {
+    return url;
+  }
+
+  public boolean post() {
+    return post;
+  }
+
+  public boolean includeIPv6() {
+    return includeIPv6;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public boolean resolvePrivateAddresses() {
+    return resolvePrivateAddresses;
+  }
+
+  public boolean resolvePublicAddresses() {
+    return resolvePublicAddresses;
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
+      boolean privateHost = isPrivateHost(hostname);
+
+      if (privateHost && !resolvePrivateAddresses) {
+        throw new UnknownHostException("private hosts not resolved");
+      }
+
+      if (!privateHost && !resolvePublicAddresses) {
+        throw new UnknownHostException("public hosts not resolved");
+      }
+    }
+
+    return lookupHttps(hostname);
+  }
+
+  private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
+    List<Call> networkRequests = new ArrayList<>(2);
+    List<Exception> failures = new ArrayList<>(2);
+    List<InetAddress> results = new ArrayList<>(5);
+
+    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);
+
+    if (includeIPv6) {
+      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);
+    }
+
+    executeRequests(hostname, networkRequests, results, failures);
+
+    if (!results.isEmpty()) {
+      return results;
+    }
+
+    return throwBestFailure(hostname, failures);
+  }
+
+  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,
+      List<Exception> failures, int type) {
+    Request request = buildRequest(hostname, type);
+    Response response = getCacheOnlyResponse(request);
+
+    if (response != null) {
+      processResponse(response, hostname, results, failures);
+    } else {
+      networkRequests.add(client.newCall(request));
+    }
+  }
+
+  private void executeRequests(final String hostname, List<Call> networkRequests,
+      final List<InetAddress> responses, final List<Exception> failures) {
+    final CountDownLatch latch = new CountDownLatch(networkRequests.size());
+
+    for (Call call : networkRequests) {
+      call.enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          synchronized (failures) {
+            failures.add(e);
+          }
+          latch.countDown();
+        }
+
+        @Override public void onResponse(Call call, Response response) {
+          processResponse(response, hostname, responses, failures);
+          latch.countDown();
+        }
+      });
+    }
+
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      failures.add(e);
+    }
+  }
+
+  private void processResponse(Response response, String hostname, List<InetAddress> results,
+      List<Exception> failures) {
+    try {
+      List<InetAddress> addresses = readResponse(hostname, response);
+      synchronized (results) {
+        results.addAll(addresses);
+      }
+    } catch (Exception e) {
+      synchronized (failures) {
+        failures.add(e);
+      }
+    }
+  }
+
+  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures)
+      throws UnknownHostException {
+    if (failures.size() == 0) {
+      throw new UnknownHostException(hostname);
+    }
+
+    Exception failure = failures.get(0);
+
+    if (failure instanceof UnknownHostException) {
+      throw (UnknownHostException) failure;
+    }
+
+    UnknownHostException unknownHostException = new UnknownHostException(hostname);
+    unknownHostException.initCause(failure);
+
+    for (int i = 1; i < failures.size(); i++) {
+      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));
+    }
+
+    throw unknownHostException;
+  }
+
+  private @Nullable Response getCacheOnlyResponse(Request request) {
+    if (!post && client.cache() != null) {
+      try {
+        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();
+
+        Response cacheResponse = client.newCall(cacheRequest).execute();
+
+        if (cacheResponse.code() != 504) {
+          return cacheResponse;
+        }
+      } catch (IOException ioe) {
+        // Failures are ignored as we can fallback to the network
+        // and hopefully repopulate the cache.
+      }
+    }
+
+    return null;
+  }
+
+  private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
+    if (response.cacheResponse() == null && response.protocol() != Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: " + response.protocol(), null);
+    }
+
+    try {
+      if (!response.isSuccessful()) {
+        throw new IOException("response: " + response.code() + " " + response.message());
+      }
+
+      ResponseBody body = response.body();
+
+      if (body.contentLength() > MAX_RESPONSE_SIZE) {
+        throw new IOException("response size exceeds limit ("
+            + MAX_RESPONSE_SIZE
+            + " bytes): "
+            + body.contentLength()
+            + " bytes");
+      }
+
+      ByteString responseBytes = body.source().readByteString();
+
+      return DnsRecordCodec.decodeAnswers(hostname, responseBytes);
+    } finally {
+      response.close();
+    }
+  }
+
+  private Request buildRequest(String hostname, int type) {
+    Request.Builder requestBuilder = new Request.Builder().header("Accept", DNS_MESSAGE.toString());
+
+    ByteString query = DnsRecordCodec.encodeQuery(hostname, type);
+
+    if (post) {
+      requestBuilder = requestBuilder.url(url).post(RequestBody.create(DNS_MESSAGE, query));
+    } else {
+      String encoded = query.base64Url().replace("=", "");
+      HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
+
+      requestBuilder = requestBuilder.url(requestUrl);
+    }
+
+    return requestBuilder.build();
+  }
+
+  static boolean isPrivateHost(String host) {
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null;
+  }
+
+  public static final class Builder {
+    @Nullable OkHttpClient client = null;
+    @Nullable HttpUrl url = null;
+    boolean includeIPv6 = true;
+    boolean post = false;
+    Dns systemDns = Dns.SYSTEM;
+    @Nullable List<InetAddress> bootstrapDnsHosts = null;
+    boolean resolvePrivateAddresses = false;
+    boolean resolvePublicAddresses = true;
+
+    public Builder() {
+    }
+
+    public DnsOverHttps build() {
+      return new DnsOverHttps(this);
+    }
+
+    public Builder client(OkHttpClient client) {
+      this.client = client;
+      return this;
+    }
+
+    public Builder url(HttpUrl url) {
+      this.url = url;
+      return this;
+    }
+
+    public Builder includeIPv6(boolean includeIPv6) {
+      this.includeIPv6 = includeIPv6;
+      return this;
+    }
+
+    public Builder post(boolean post) {
+      this.post = post;
+      return this;
+    }
+
+    public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
+      this.resolvePrivateAddresses = resolvePrivateAddresses;
+      return this;
+    }
+
+    public Builder resolvePublicAddresses(boolean resolvePublicAddresses) {
+      this.resolvePublicAddresses = resolvePublicAddresses;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(@Nullable List<InetAddress> bootstrapDnsHosts) {
+      this.bootstrapDnsHosts = bootstrapDnsHosts;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(InetAddress... bootstrapDnsHosts) {
+      return bootstrapDnsHosts(Arrays.asList(bootstrapDnsHosts));
+    }
+
+    public Builder systemDns(Dns systemDns) {
+      this.systemDns = systemDns;
+      return this;
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
new file mode 100644
index 0000000000..4c1cfc481e
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.dnsoverhttps;
+
+import java.io.EOFException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Utf8;
+
+/**
+ * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
+ */
+class DnsRecordCodec {
+  private static final byte SERVFAIL = 2;
+  private static final byte NXDOMAIN = 3;
+  public static final int TYPE_A = 0x0001;
+  public static final int TYPE_AAAA = 0x001c;
+  private static final int TYPE_PTR = 0x000c;
+  private static final Charset ASCII = Charset.forName("ASCII");
+
+  private DnsRecordCodec() {
+  }
+
+  public static ByteString encodeQuery(String host, int type) {
+    Buffer buf = new Buffer();
+
+    buf.writeShort(0); // query id
+    buf.writeShort(256); // flags with recursion
+    buf.writeShort(1); // question count
+    buf.writeShort(0); // answerCount
+    buf.writeShort(0); // authorityResourceCount
+    buf.writeShort(0); // additional
+
+    Buffer nameBuf = new Buffer();
+    final String[] labels = host.split("\\.");
+    for (String label : labels) {
+      long utf8ByteCount = Utf8.size(label);
+      if (utf8ByteCount != label.length()) {
+        throw new IllegalArgumentException("non-ascii hostname: " + host);
+      }
+      nameBuf.writeByte((byte) utf8ByteCount);
+      nameBuf.writeUtf8(label);
+    }
+    nameBuf.writeByte(0); // end
+
+    nameBuf.copyTo(buf, 0, nameBuf.size());
+    buf.writeShort(type);
+    buf.writeShort(1); // CLASS_IN
+
+    return buf.readByteString();
+  }
+
+  public static List<InetAddress> decodeAnswers(String hostname, ByteString byteString)
+      throws Exception {
+    List<InetAddress> result = new ArrayList<>();
+
+    Buffer buf = new Buffer();
+    buf.write(byteString);
+    buf.readShort(); // query id
+
+    final int flags = buf.readShort() & 0xffff;
+    if (flags >> 15 == 0) {
+      throw new IllegalArgumentException("not a response");
+    }
+
+    byte responseCode = (byte) (flags & 0xf);
+
+    if (responseCode == NXDOMAIN) {
+      throw new UnknownHostException(hostname + ": NXDOMAIN");
+    } else if (responseCode == SERVFAIL) {
+      throw new UnknownHostException(hostname + ": SERVFAIL");
+    }
+
+    final int questionCount = buf.readShort() & 0xffff;
+    final int answerCount = buf.readShort() & 0xffff;
+    buf.readShort(); // authority record count
+    buf.readShort(); // additional record count
+
+    for (int i = 0; i < questionCount; i++) {
+      skipName(buf); // name
+      buf.readShort(); // type
+      buf.readShort(); // class
+    }
+
+    for (int i = 0; i < answerCount; i++) {
+      skipName(buf); // name
+
+      int type = buf.readShort() & 0xffff;
+      buf.readShort(); // class
+      final long ttl = buf.readInt() & 0xffffffffL; // ttl
+      final int length = buf.readShort() & 0xffff;
+
+      if (type == TYPE_A || type == TYPE_AAAA) {
+        byte[] bytes = new byte[length];
+        buf.read(bytes);
+        result.add(InetAddress.getByAddress(bytes));
+      } else {
+        buf.skip(length);
+      }
+    }
+
+    return result;
+  }
+
+  private static void skipName(Buffer in) throws EOFException {
+    // 0 - 63 bytes
+    int length = in.readByte();
+
+    if (length < 0) {
+      // compressed name pointer, first two bits are 1
+      // drop second byte of compression offset
+      in.skip(1);
+    } else {
+      while (length > 0) {
+        // skip each part of the domain name
+        in.skip(length);
+        length = in.readByte();
+      }
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
new file mode 100644
index 0000000000..54da565bc2
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
@@ -0,0 +1,3 @@
+/** A DNS over HTTPS implementation for OkHttp. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
new file mode 100644
index 0000000000..c6c16278dd
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class DnsOverHttpsTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final OkHttpClient bootstrapClient =
+      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
+  private Dns dns = buildLocalhost(bootstrapClient, false);
+
+  @Before public void setUp() {
+    server.setProtocols(bootstrapClient.protocols());
+  }
+
+  @Test public void getOne() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+  }
+
+  @Test public void getIpv6() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
+            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
+            + "0010000003b00102a032880f0290011faceb00c00000002"));
+
+    dns = buildLocalhost(bootstrapClient, true);
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(2, result.size());
+    assertTrue(result.contains(address("157.240.1.18")));
+    assertTrue(result.contains(address("2a03:2880:f029:11:face:b00c:0:2")));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET", request1.getMethod());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET", request2.getMethod());
+
+    assertEquals(new HashSet<>(
+            Arrays.asList("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+                "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ")),
+        new LinkedHashSet<>(Arrays.asList(request1.getPath(), request2.getPath())));
+  }
+
+  @Test public void failure() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
+            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
+            + "4c01b5adb12c100000e10000003840012750000000e10"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (UnknownHostException uhe) {
+      uhe.printStackTrace();
+      assertEquals("google.com: NXDOMAIN", uhe.getMessage());
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+  }
+
+  @Test public void failOnExcessiveResponse() {
+    char[] array = new char[128 * 1024 + 2];
+    Arrays.fill(array, '0');
+    server.enqueue(dnsResponse(new String(array)));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof IOException);
+      assertEquals("response size exceeds limit (65536 bytes): 65537 bytes", cause.getMessage());
+    }
+  }
+
+  @Test public void failOnBadResponse() {
+    server.enqueue(dnsResponse("00"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof RuntimeException);
+    }
+  }
+
+  // TODO GET preferred order - with tests to confirm this
+  // 1. successful fresh cached GET response
+  // 2. unsuccessful (404, 500) fresh cached GET response
+  // 3. successful network response
+  // 4. successful stale cached GET response
+  // 5. unsuccessful response
+
+  // TODO how closely to follow POST rules on caching?
+
+  @Test public void usesCache() throws Exception {
+    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
+    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
+    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
+
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
+
+    List<InetAddress> result = cachedDns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+
+    result = cachedDns.lookup("google.com");
+    assertEquals(singletonList(address("157.240.1.18")), result);
+  }
+
+  private MockResponse dnsResponse(String s) {
+    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
+        .addHeader("content-type", "application/dns-message")
+        .addHeader("content-length", s.length() / 2);
+  }
+
+  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
+    HttpUrl url = server.url("/lookup?ct");
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .includeIPv6(includeIPv6)
+        .resolvePrivateAddresses(true)
+        .url(url)
+        .build();
+  }
+
+  private static InetAddress address(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // impossible for IP addresses
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
new file mode 100644
index 0000000000..3a12b4d254
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okio.ByteString;
+import org.junit.Test;
+
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class DnsRecordCodecTest {
+  @Test public void testGoogleDotComEncoding() {
+    String encoded = encodeQuery("google.com", TYPE_A);
+
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ", encoded);
+  }
+
+  private String encodeQuery(String host, int type) {
+    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
+  }
+
+  @Test public void testGoogleDotComEncodingWithIPv6() {
+    String encoded = encodeQuery("google.com", TYPE_AAAA);
+
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ", encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
+    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("216.58.213.78")), encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("157.240.1.18")), decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
+
+    assertEquals(
+        Collections.singletonList(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2")),
+        decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
+    try {
+      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
+          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
+      fail();
+    } catch (UnknownHostException uhe) {
+      assertEquals("sdflkhfsdlkjdf.ee: NXDOMAIN", uhe.getMessage());
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
new file mode 100644
index 0000000000..301eee57ca
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+/**
+ * Temporary registry of known DNS over HTTPS providers.
+ *
+ * https://github.com/curl/curl/wiki/DNS-over-HTTPS
+ */
+public class DohProviders {
+  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .build();
+  }
+
+  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("1.1.1.1"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
+            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
+        .includeIPv6(false)
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
+      boolean workingOnly, boolean getOnly) {
+
+    List<DnsOverHttps> result = new ArrayList<>();
+
+    result.add(buildGoogle(client));
+    if (!getOnly) {
+      result.add(buildGooglePost(client));
+    }
+    result.add(buildCloudflare(client));
+    result.add(buildCloudflareIp(client));
+    if (!getOnly) {
+      result.add(buildCloudflarePost(client));
+    }
+    if (!workingOnly) {
+      //result.add(buildCleanBrowsing(client)); // timeouts
+      result.add(buildCryptoSx(client)); // 521 - server down
+    }
+    result.add(buildChantra(client));
+
+    return result;
+  }
+
+  private static InetAddress getByIp(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // unlikely
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
new file mode 100644
index 0000000000..65975ae5cc
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+public class TestDohMain {
+  public static void main(String[] args) throws IOException {
+    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
+
+    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
+
+    List<String> names = Arrays.asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
+
+    try {
+      System.out.println("uncached\n********\n");
+      List<DnsOverHttps> dnsProviders =
+          DohProviders.providers(bootstrapClient, false, false, false);
+      runBatch(dnsProviders, names);
+
+      Cache dnsCache =
+          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
+              10 * 1024 * 1024);
+
+      System.out.println("Bad targets\n***********\n");
+
+      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
+      List<DnsOverHttps> badProviders = Collections.singletonList(
+          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
+      runBatch(badProviders, names);
+
+      System.out.println("cached first run\n****************\n");
+      names = Arrays.asList("google.com", "graph.facebook.com");
+      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+
+      System.out.println("cached second run\n*****************\n");
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+    } finally {
+      bootstrapClient.connectionPool().evictAll();
+      bootstrapClient.dispatcher().executorService().shutdownNow();
+      Cache cache = bootstrapClient.cache();
+      if (cache != null) {
+        cache.close();
+      }
+    }
+  }
+
+  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
+    long time = System.currentTimeMillis();
+
+    for (DnsOverHttps dns : dnsProviders) {
+      System.out.println("Testing " + dns.url());
+
+      for (String host : names) {
+        System.out.print(host + ": ");
+        System.out.flush();
+
+        try {
+          List<InetAddress> results = dns.lookup(host);
+          System.out.println(results);
+        } catch (UnknownHostException uhe) {
+          Throwable e = uhe;
+
+          while (e != null) {
+            System.out.println(e.toString());
+
+            e = e.getCause();
+          }
+        }
+      }
+
+      System.out.println();
+    }
+
+    time = System.currentTimeMillis() - time;
+
+    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
+  }
+}
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 1c5dcd952a..fae2f6e6ca 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -11,7 +11,7 @@ OkHttpClient client = new OkHttpClient.Builder()
   .build();
 ```
 
-You can change the log level at any time by calling `setLevel`.
+You can change the log level at any time by calling `setLevel()`.
 
 To log to a custom location, pass a `Logger` instance to the constructor.
 ```java
@@ -22,11 +22,16 @@ HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
 });
 ```
 
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
 the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
 contents of request and response bodies. This data should only be logged in a controlled way or in
 a non-production environment.
 
+You can redact headers that may contain sensitive information by calling `redactHeader()`.
+```java
+logging.redactHeader("Authorization");
+logging.redactHeader("Cookie");
+```
 
 Download
 --------
@@ -42,7 +47,7 @@ Get via Maven:
 
 or via Gradle 
 ```groovy
-compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+implementation 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
 ```
 
 
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 1513f73b44..cff9ce9147 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -41,5 +41,28 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.logging</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 173d88caff..c6acbccf1e 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,13 +18,15 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
@@ -33,6 +35,7 @@
 import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.GzipSource;
 
 import static okhttp3.internal.platform.Platform.INFO;
 
@@ -123,6 +126,15 @@ public HttpLoggingInterceptor(Logger logger) {
 
   private final Logger logger;
 
+  private volatile Set<String> headersToRedact = Collections.emptySet();
+
+  public void redactHeader(String name) {
+    Set<String> newHeadersToRedact = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    newHeadersToRedact.addAll(headersToRedact);
+    newHeadersToRedact.add(name);
+    headersToRedact = newHeadersToRedact;
+  }
+
   private volatile Level level = Level.NONE;
 
   /** Change the level at which this interceptor logs. */
@@ -151,8 +163,10 @@ public Level getLevel() {
     boolean hasRequestBody = requestBody != null;
 
     Connection connection = chain.connection();
-    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
-    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+    String requestStartMessage = "--> "
+        + request.method()
+        + ' ' + request.url()
+        + (connection != null ? " " + connection.protocol() : "");
     if (!logHeaders && hasRequestBody) {
       requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
     }
@@ -175,13 +189,13 @@ public Level getLevel() {
         String name = headers.name(i);
         // Skip headers from the request body as they are explicitly logged above.
         if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logger.log(name + ": " + headers.value(i));
+          logHeader(headers, i);
         }
       }
 
       if (!logBody || !hasRequestBody) {
         logger.log("--> END " + request.method());
-      } else if (bodyEncoded(request.headers())) {
+      } else if (bodyHasUnknownEncoding(request.headers())) {
         logger.log("--> END " + request.method() + " (encoded body omitted)");
       } else {
         Buffer buffer = new Buffer();
@@ -218,25 +232,42 @@ public Level getLevel() {
     ResponseBody responseBody = response.body();
     long contentLength = responseBody.contentLength();
     String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- " + response.code() + ' ' + response.message() + ' '
-        + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
-        + bodySize + " body" : "") + ')');
+    logger.log("<-- "
+        + response.code()
+        + (response.message().isEmpty() ? "" : ' ' + response.message())
+        + ' ' + response.request().url()
+        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
 
     if (logHeaders) {
       Headers headers = response.headers();
       for (int i = 0, count = headers.size(); i < count; i++) {
-        logger.log(headers.name(i) + ": " + headers.value(i));
+        logHeader(headers, i);
       }
 
       if (!logBody || !HttpHeaders.hasBody(response)) {
         logger.log("<-- END HTTP");
-      } else if (bodyEncoded(response.headers())) {
+      } else if (bodyHasUnknownEncoding(response.headers())) {
         logger.log("<-- END HTTP (encoded body omitted)");
       } else {
         BufferedSource source = responseBody.source();
         source.request(Long.MAX_VALUE); // Buffer the entire body.
         Buffer buffer = source.buffer();
 
+        Long gzippedLength = null;
+        if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
+          gzippedLength = buffer.size();
+          GzipSource gzippedResponseBody = null;
+          try {
+            gzippedResponseBody = new GzipSource(buffer.clone());
+            buffer = new Buffer();
+            buffer.writeAll(gzippedResponseBody);
+          } finally {
+            if (gzippedResponseBody != null) {
+              gzippedResponseBody.close();
+            }
+          }
+        }
+
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
@@ -254,13 +285,23 @@ public Level getLevel() {
           logger.log(buffer.clone().readString(charset));
         }
 
-        logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+        if (gzippedLength != null) {
+            logger.log("<-- END HTTP (" + buffer.size() + "-byte, "
+                + gzippedLength + "-gzipped-byte body)");
+        } else {
+            logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+        }
       }
     }
 
     return response;
   }
 
+  private void logHeader(Headers headers, int i) {
+    String value = headersToRedact.contains(headers.name(i)) ? "██" : headers.value(i);
+    logger.log(headers.name(i) + ": " + value);
+  }
+
   /**
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
@@ -285,8 +326,10 @@ static boolean isPlaintext(Buffer buffer) {
     }
   }
 
-  private boolean bodyEncoded(Headers headers) {
+  private static boolean bodyHasUnknownEncoding(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
-    return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+    return contentEncoding != null
+        && !contentEncoding.equalsIgnoreCase("identity")
+        && !contentEncoding.equalsIgnoreCase("gzip");
   }
 }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
new file mode 100644
index 0000000000..da38261bfb
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * An OkHttp EventListener, which logs call events. Can be applied as an
+ * {@linkplain OkHttpClient#eventListenerFactory() event listener factory}.
+ *
+ * <p>The format of the logs created by this class should not be considered stable and may change
+ * slightly between releases. If you need a stable logging format, use your own event listener.
+ */
+public final class LoggingEventListener extends EventListener {
+  private final HttpLoggingInterceptor.Logger logger;
+  private long startNs;
+
+  private LoggingEventListener(HttpLoggingInterceptor.Logger logger) {
+    this.logger = logger;
+  }
+
+  @Override
+  public void callStart(Call call) {
+    startNs = System.nanoTime();
+
+    logWithTime("callStart: " + call.request());
+  }
+
+  @Override
+  public void dnsStart(Call call, String domainName) {
+    logWithTime("dnsStart: " + domainName);
+  }
+
+  @Override
+  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logWithTime("dnsEnd: " + inetAddressList);
+  }
+
+  @Override
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+    logWithTime("connectStart: " + inetSocketAddress + " " + proxy);
+  }
+
+  @Override
+  public void secureConnectStart(Call call) {
+    logWithTime("secureConnectStart");
+  }
+
+  @Override
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+    logWithTime("secureConnectEnd: " + handshake);
+  }
+
+  @Override
+  public void connectEnd(
+      Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) {
+    logWithTime("connectEnd: " + protocol);
+  }
+
+  @Override
+  public void connectFailed(
+      Call call,
+      InetSocketAddress inetSocketAddress,
+      Proxy proxy,
+      @Nullable Protocol protocol,
+      IOException ioe) {
+    logWithTime("connectFailed: " + protocol + " " + ioe);
+  }
+
+  @Override
+  public void connectionAcquired(Call call, Connection connection) {
+    logWithTime("connectionAcquired: " + connection);
+  }
+
+  @Override
+  public void connectionReleased(Call call, Connection connection) {
+    logWithTime("connectionReleased");
+  }
+
+  @Override
+  public void requestHeadersStart(Call call) {
+    logWithTime("requestHeadersStart");
+  }
+
+  @Override
+  public void requestHeadersEnd(Call call, Request request) {
+    logWithTime("requestHeadersEnd");
+  }
+
+  @Override
+  public void requestBodyStart(Call call) {
+    logWithTime("requestBodyStart");
+  }
+
+  @Override
+  public void requestBodyEnd(Call call, long byteCount) {
+    logWithTime("requestBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void responseHeadersStart(Call call) {
+    logWithTime("responseHeadersStart");
+  }
+
+  @Override
+  public void responseHeadersEnd(Call call, Response response) {
+    logWithTime("responseHeadersEnd: " + response);
+  }
+
+  @Override
+  public void responseBodyStart(Call call) {
+    logWithTime("responseBodyStart");
+  }
+
+  @Override
+  public void responseBodyEnd(Call call, long byteCount) {
+    logWithTime("responseBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void callEnd(Call call) {
+    logWithTime("callEnd");
+  }
+
+  @Override
+  public void callFailed(Call call, IOException ioe) {
+    logWithTime("callFailed: " + ioe);
+  }
+
+  private void logWithTime(String message) {
+    long timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+    logger.log("[" + timeMs + " ms] " + message);
+  }
+
+  public static class Factory implements EventListener.Factory {
+    private final HttpLoggingInterceptor.Logger logger;
+
+    public Factory() {
+      this(HttpLoggingInterceptor.Logger.DEFAULT);
+    }
+
+    public Factory(HttpLoggingInterceptor.Logger logger) {
+      this.logger = logger;
+    }
+
+    @Override
+    public EventListener create(Call call) {
+      return new LoggingEventListener(logger);
+    }
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
index 39904701cf..62d0ff5761 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -1,3 +1,3 @@
 /** An OkHttp interceptor which logs HTTP request and response data. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index c631899fb3..6fd53f7753 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -19,18 +19,24 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.regex.Pattern;
+import javax.net.ssl.HostnameVerifier;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -39,17 +45,22 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
 
   @Rule public final MockWebServer server = new MockWebServer();
 
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -71,6 +82,9 @@ private void setLevel(Level level) {
     client = new OkHttpClient.Builder()
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
         .build();
 
     host = server.getHostName() + ":" + server.getPort();
@@ -117,7 +131,7 @@ private void setLevel(Level level) {
     client.newCall(request().build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -134,7 +148,7 @@ private void setLevel(Level level) {
     client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogEqual("--> POST " + url + " (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -154,7 +168,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
         .assertNoMoreLogs();
 
@@ -174,7 +188,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
         .assertNoMoreLogs();
 
@@ -192,7 +206,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -221,7 +235,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
@@ -254,7 +268,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -293,7 +307,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -326,7 +340,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -356,7 +370,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -393,7 +407,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -422,7 +436,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("")
@@ -460,7 +474,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -496,7 +510,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
@@ -522,7 +536,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void bodyResponseNotIdentityEncoded() throws IOException {
+  @Test public void bodyResponseGzipEncoded() throws IOException {
     setLevel(Level.BODY);
 
     server.enqueue(new MockResponse()
@@ -531,7 +545,10 @@ private void bodyGetNoBody(int code) throws IOException {
         .setBody(new Buffer().write(ByteString.decodeBase64(
             "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
     Response response = client.newCall(request().build()).execute();
-    response.body().close();
+
+    ResponseBody responseBody = response.body();
+    assertEquals("Expected response body to be valid","Hello, Hello, Hello", responseBody.string());
+    responseBody.close();
 
     networkLogs
         .assertLogEqual("--> GET " + url + " http/1.1")
@@ -544,11 +561,13 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Encoding: gzip")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("<-- END HTTP (encoded body omitted)")
+        .assertLogEqual("")
+        .assertLogEqual("Hello, Hello, Hello")
+        .assertLogEqual("<-- END HTTP (19-byte, 29-gzipped-byte body)")
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
@@ -558,6 +577,43 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test public void bodyResponseUnknownEncoded() throws IOException {
+      setLevel(Level.BODY);
+
+      server.enqueue(new MockResponse()
+          // It's invalid to return this if not requested, but the server might anyway
+          .setHeader("Content-Encoding", "br")
+          .setHeader("Content-Type", PLAIN)
+          .setBody(new Buffer().write(ByteString.decodeBase64(
+              "iwmASGVsbG8sIEhlbGxvLCBIZWxsbwoD"))));
+      Response response = client.newCall(request().build()).execute();
+      response.body().close();
+
+      networkLogs
+          .assertLogEqual("--> GET " + url + " http/1.1")
+          .assertLogEqual("Host: " + host)
+          .assertLogEqual("Connection: Keep-Alive")
+          .assertLogEqual("Accept-Encoding: gzip")
+          .assertLogMatch("User-Agent: okhttp/.+")
+          .assertLogEqual("--> END GET")
+          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+          .assertLogEqual("Content-Encoding: br")
+          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+          .assertLogMatch("Content-Length: \\d+")
+          .assertLogEqual("<-- END HTTP (encoded body omitted)")
+          .assertNoMoreLogs();
+
+      applicationLogs
+          .assertLogEqual("--> GET " + url)
+          .assertLogEqual("--> END GET")
+          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+          .assertLogEqual("Content-Encoding: br")
+          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+          .assertLogMatch("Content-Length: \\d+")
+          .assertLogEqual("<-- END HTTP (encoded body omitted)")
+          .assertNoMoreLogs();
+    }
+
   @Test public void bodyGetMalformedCharset() throws IOException {
     setLevel(Level.BODY);
 
@@ -583,7 +639,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/html; charset=0")
@@ -594,7 +650,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void isPlaintext() throws IOException {
+  @Test public void isPlaintext() {
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
@@ -622,7 +678,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 9")
@@ -664,16 +720,94 @@ private void bodyGetNoBody(int code) throws IOException {
     }
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
         .assertNoMoreLogs();
   }
 
+  @Test public void http2() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " h2")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void headersAreRedacted() throws Exception {
+    HttpLoggingInterceptor networkInterceptor =
+        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
+    networkInterceptor.redactHeader("sEnSiTiVe");
+
+    HttpLoggingInterceptor applicationInterceptor =
+        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
+    applicationInterceptor.redactHeader("sEnSiTiVe");
+
+    client =
+        new OkHttpClient.Builder()
+            .addNetworkInterceptor(networkInterceptor)
+            .addInterceptor(applicationInterceptor)
+            .build();
+
+    server.enqueue(
+        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
+    Response response =
+        client
+            .newCall(
+                request()
+                    .addHeader("SeNsItIvE", "Value")
+                    .addHeader("Not-Sensitive", "Value")
+                    .build())
+            .execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
 
-  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+  static class LogRecorder implements HttpLoggingInterceptor.Logger {
     private final List<String> logs = new ArrayList<>();
     private int index;
 
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
new file mode 100644
index 0000000000..c7ead4bbf6
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.List;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class LoggingEventListenerTest {
+  private static final MediaType PLAIN = MediaType.get("text/plain");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final LogRecorder logRecorder = new LogRecorder();
+  private final LoggingEventListener.Factory loggingEventListenerFactory =
+      new LoggingEventListener.Factory(logRecorder);
+  private OkHttpClient client;
+  private HttpUrl url;
+
+  @Before
+  public void setUp() {
+    client =
+        new OkHttpClient.Builder()
+            .eventListenerFactory(loggingEventListenerFactory)
+            .sslSocketFactory(
+                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+            .retryOnConnectionFailure(false)
+            .build();
+
+    url = server.url("/");
+  }
+
+  @Test
+  public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=6")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void post() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("requestBodyStart")
+        .assertLogMatch("requestBodyEnd: byteCount=6")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void secureGet() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch("secureConnectEnd: Handshake\\{"
+            + "tlsVersion=TLS_1_2 "
+            + "cipherSuite=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 "
+            + "peerCertificates=\\[CN=localhost\\] "
+            + "localCertificates=\\[\\]}")
+        .assertLogMatch("connectEnd: h2")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=.+ protocol=h2}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void dnsFail() throws IOException {
+    client =
+        new OkHttpClient.Builder()
+            .dns(
+                new Dns() {
+                  @Override
+                  public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+                    throw new UnknownHostException("reason");
+                  }
+                })
+            .eventListenerFactory(loggingEventListenerFactory)
+            .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void connectFail() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    url = server.url("/");
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch(
+            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertLogMatch(
+            "callFailed: javax.net.ssl.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
+    LogRecorder assertLogMatch(String pattern) {
+      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
+    }
+  }
+}
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
new file mode 100644
index 0000000000..2b1bc42830
--- /dev/null
+++ b/okhttp-sse/README.md
@@ -0,0 +1,5 @@
+OkHttp Server-Sent Events
+=========================
+
+Experimental support for server-sent events.
+API is not considered stable and may change at any time.
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
new file mode 100644
index 0000000000..110c3a4456
--- /dev/null
+++ b/okhttp-sse/pom.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-sse</artifactId>
+  <name>OkHttp Server-Sent Events</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.sse</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
new file mode 100644
index 0000000000..c49e49f4aa
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+
+public final class RealEventSource
+    implements EventSource, ServerSentEventReader.Callback, Callback {
+
+  private final Request request;
+  private final EventSourceListener listener;
+
+  private @Nullable Call call;
+
+  public RealEventSource(Request request, EventSourceListener listener) {
+    this.request = request;
+    this.listener = listener;
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .build();
+    call = client.newCall(request);
+    call.timeout().clearTimeout();
+    call.enqueue(this);
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    processResponse(response);
+  }
+
+  public void processResponse(Response response) {
+    try {
+      if (!response.isSuccessful()) {
+        listener.onFailure(this, null, response);
+        return;
+      }
+
+      ResponseBody body = response.body();
+
+      //noinspection ConstantConditions main body is never null
+      MediaType contentType = body.contentType();
+      if (!isEventStream(contentType)) {
+        listener.onFailure(this,
+            new IllegalStateException("Invalid content-type: " + contentType), response);
+        return;
+      }
+
+      // Replace the body with an empty one so the callbacks can't see real data.
+      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
+
+      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
+      try {
+        listener.onOpen(this, response);
+        while (reader.processNextEvent()) {
+        }
+      } catch (Exception e) {
+        listener.onFailure(this, e, response);
+        return;
+      }
+
+      listener.onClosed(this);
+    } finally {
+      response.close();
+    }
+  }
+
+  private static boolean isEventStream(@Nullable MediaType contentType) {
+    return contentType != null && contentType.type().equals("text") && contentType.subtype()
+        .equals("event-stream");
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    listener.onFailure(this, e, null);
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+    listener.onEvent(this, id, type, data);
+  }
+
+  @Override public void onRetryChange(long timeMs) {
+    // Ignored. We do not auto-retry.
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
new file mode 100644
index 0000000000..0e0e775fb6
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+public final class ServerSentEventReader {
+  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
+  private static final ByteString DATA = ByteString.encodeUtf8("data");
+  private static final ByteString ID = ByteString.encodeUtf8("id");
+  private static final ByteString EVENT = ByteString.encodeUtf8("event");
+  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
+
+  public interface Callback {
+    void onEvent(@Nullable String id, @Nullable String type, String data);
+    void onRetryChange(long timeMs);
+  }
+
+  private final BufferedSource source;
+  private final Callback callback;
+
+  private String lastId = null;
+
+  public ServerSentEventReader(BufferedSource source, Callback callback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (callback == null) throw new NullPointerException("callback == null");
+    this.source = source;
+    this.callback = callback;
+  }
+
+  /**
+   * Process the next event. This will result in a single call to {@link Callback#onEvent}
+   * <em>unless</em> the data section was empty. Any number of calls to
+   * {@link Callback#onRetryChange} may occur while processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  boolean processNextEvent() throws IOException {
+    String id = lastId;
+    String type = null;
+    Buffer data = new Buffer();
+
+    while (true) {
+      long lineEnd = source.indexOfElement(CRLF);
+      if (lineEnd == -1L) {
+        return false;
+      }
+
+      switch (source.buffer().getByte(0)) {
+        case '\r':
+        case '\n':
+          completeEvent(id, type, data);
+          return true;
+
+        case 'd':
+          if (isKey(DATA)) {
+            parseData(data, lineEnd);
+            continue;
+          }
+          break;
+
+        case 'e':
+          if (isKey(EVENT)) {
+            type = parseEvent(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'i':
+          if (isKey(ID)) {
+            id = parseId(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'r':
+          if (isKey(RETRY)) {
+            parseRetry(lineEnd);
+            continue;
+          }
+          break;
+      }
+
+      source.skip(lineEnd);
+      skipCrAndOrLf();
+    }
+  }
+
+  private void completeEvent(String id, String type, Buffer data) throws IOException {
+    skipCrAndOrLf();
+
+    if (data.size() != 0L) {
+      lastId = id;
+      data.skip(1L); // Leading newline.
+      callback.onEvent(id, type, data.readUtf8());
+    }
+  }
+
+  private void parseData(Buffer data, long end) throws IOException {
+    data.writeByte('\n');
+    end -= skipNameAndDivider(4L);
+    source.readFully(data, end);
+    skipCrAndOrLf();
+  }
+
+  private String parseEvent(long end) throws IOException {
+    String type = null;
+    end -= skipNameAndDivider(5L);
+    if (end != 0L) {
+      type = source.readUtf8(end);
+    }
+    skipCrAndOrLf();
+    return type;
+  }
+
+  private String parseId(long end) throws IOException {
+    String id;
+    end -= skipNameAndDivider(2L);
+    if (end != 0L) {
+      id = source.readUtf8(end);
+    } else {
+      id = null;
+    }
+    skipCrAndOrLf();
+    return id;
+  }
+
+  private void parseRetry(long end) throws IOException {
+    end -= skipNameAndDivider(5L);
+    String retryString = source.readUtf8(end);
+    long retryMs = -1L;
+    try {
+      retryMs = Long.parseLong(retryString);
+    } catch (NumberFormatException ignored) {
+    }
+    if (retryMs != -1L) {
+      callback.onRetryChange(retryMs);
+    }
+    skipCrAndOrLf();
+  }
+
+  /**
+   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
+   * a newline.
+   */
+  private boolean isKey(ByteString key) throws IOException {
+    if (source.rangeEquals(0, key)) {
+      byte nextByte = source.buffer().getByte(key.size());
+      return nextByte == ':'
+          || nextByte == '\r'
+          || nextByte == '\n';
+    }
+    return false;
+  }
+
+  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
+  private void skipCrAndOrLf() throws IOException {
+    if ((source.readByte() & 0xff) == '\r'
+        && source.request(1)
+        && source.buffer().getByte(0) == '\n') {
+      source.skip(1);
+    }
+  }
+
+  /**
+   * Consumes the field name of the specified length and the optional colon and its optional
+   * trailing space. Returns the number of bytes skipped.
+   */
+  private long skipNameAndDivider(long length) throws IOException {
+    source.skip(length);
+
+    if (source.buffer().getByte(0) == ':') {
+      source.skip(1L);
+      length++;
+
+      if (source.buffer().getByte(0) == ' ') {
+        source.skip(1);
+        length++;
+      }
+    }
+
+    return length;
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
new file mode 100644
index 0000000000..afcf5f4f9d
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Private support classes for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
new file mode 100644
index 0000000000..fe703dc8c0
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.Request;
+
+public interface EventSource {
+  /** Returns the original request that initiated this event source. */
+  Request request();
+
+  /**
+   * Immediately and violently release resources held by this event source. This does nothing if
+   * the event source has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new event source and immediately returns it. Creating an event source initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must cancel the returned event source when it is no longer
+     * in use.
+     */
+    EventSource newEventSource(Request request, EventSourceListener listener);
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
new file mode 100644
index 0000000000..4246625eca
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import javax.annotation.Nullable;
+import okhttp3.Response;
+
+public abstract class EventSourceListener {
+  /**
+   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
+   * events.
+   */
+  public void onOpen(EventSource eventSource, Response response) {
+  }
+
+  /**
+   * TODO description.
+   */
+  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+  }
+
+  /**
+   * TODO description.
+   * No further calls to this listener will be made.
+   */
+  public void onClosed(EventSource eventSource) {
+  }
+
+  /**
+   * Invoked when an event source has been closed due to an error reading from or writing to the
+   * network. Incoming events may have been lost. No further calls to this listener will be made.
+   */
+  public void onFailure(EventSource eventSource, @Nullable Throwable t,
+      @Nullable Response response) {
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
new file mode 100644
index 0000000000..77f596c5f2
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.sse.RealEventSource;
+
+public final class EventSources {
+  public static EventSource.Factory createFactory(final OkHttpClient client) {
+    return new EventSource.Factory() {
+      @Override public EventSource newEventSource(Request request, EventSourceListener listener) {
+        RealEventSource eventSource = new RealEventSource(request, listener);
+        eventSource.connect(client);
+        return eventSource;
+      }
+    };
+  }
+
+  public static void processResponse(Response response, EventSourceListener listener) {
+    RealEventSource eventSource = new RealEventSource(response.request(), listener);
+    eventSource.processResponse(response);
+  }
+
+  private EventSources() {
+    throw new AssertionError();
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
new file mode 100644
index 0000000000..2a5f883883
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Support for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
new file mode 100644
index 0000000000..149be0014c
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import javax.annotation.Nullable;
+
+final class Event {
+  final @Nullable String id;
+  final @Nullable String type;
+  final String data;
+
+  Event(@Nullable String id, @Nullable String type, String data) {
+    if (data == null) throw new NullPointerException("data == null");
+    this.id = id;
+    this.type = type;
+    this.data = data;
+  }
+
+  @Override public String toString() {
+    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof Event)) return false;
+    Event other = (Event) o;
+    return (id != null ? id.equals(other.id) : other.id == null)
+        && (type != null ? type.equals(other.type) : other.type == null)
+        && data.equals(other.data);
+  }
+
+  @Override public int hashCode() {
+    int result = (id != null ? id.hashCode() : 0);
+    result = 31 * result + (type != null ? type.hashCode() : 0);
+    result = 31 * result + data.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
new file mode 100644
index 0000000000..7f576eece9
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSources;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+
+public final class EventSourceHttpTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final EventSourceRecorder listener = new EventSourceRecorder();
+  private OkHttpClient client = defaultClient();
+
+  @After public void after() {
+    listener.assertExhausted();
+  }
+
+  @Test public void event() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  @Test public void badContentType() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/plain"));
+
+    EventSource source = newEventSource();
+    listener.assertFailure("Invalid content-type: text/plain");
+  }
+
+  @Test public void badResponseCode() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
+
+    EventSource source = newEventSource();
+    listener.assertFailure(null);
+  }
+
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBodyDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  private EventSource newEventSource() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    EventSource.Factory factory = EventSources.createFactory(client);
+    return factory.newEventSource(request, listener);
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
new file mode 100644
index 0000000000..cf4afd4ec9
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.annotation.Nullable;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class EventSourceRecorder extends EventSourceListener {
+  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
+
+  @Override public void onOpen(EventSource eventSource, Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    events.add(new Open(eventSource, response));
+  }
+
+  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    events.add(new Event(id, type, data));
+  }
+
+  @Override public void onClosed(EventSource eventSource) {
+    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    events.add(new Closed());
+  }
+
+  @Override
+  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    events.add(new Failure(t, response));
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
+    Object actual = nextEvent();
+    assertEquals(new Event(id, type, data), actual);
+  }
+
+  public EventSource assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).eventSource;
+  }
+
+  public void assertClose() {
+    Object event = nextEvent();
+    if (!(event instanceof Closed)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+  }
+
+  public void assertFailure(@Nullable String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    if (message != null) {
+      assertEquals(message, ((Failure) event).t.getMessage());
+    } else {
+      assertNull(((Failure) event).t);
+    }
+  }
+
+  static final class Open {
+    final EventSource eventSource;
+    final Response response;
+
+    Open(EventSource eventSource, Response response) {
+      this.eventSource = eventSource;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + ']';
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Closed {
+    @Override public String toString() {
+      return "Closed[]";
+    }
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
new file mode 100644
index 0000000000..697a2d2019
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class ServerSentEventIteratorTest {
+  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
+  private final Deque<Object> callbacks = new ArrayDeque<>();
+
+  @After public void after() {
+    assertTrue("Unconsumed events: " + callbacks, callbacks.isEmpty());
+  }
+  
+  @Test public void multiline() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\n"
+        + "data: +2\n"
+        + "data: 10\n"
+        + "\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCr() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r"
+        + "data: +2\r"
+        + "data: 10\r"
+        + "\r");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCrLf() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r\n"
+        + "data: +2\r\n"
+        + "data: 10\r\n"
+        + "\r\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void eventType() throws IOException {
+    consumeEvents(""
+        + "event: add\n"
+        + "data: 73857293\n"
+        + "\n"
+        + "event: remove\n"
+        + "data: 2153\n"
+        + "\n"
+        + "event: add\n"
+        + "data: 113411\n"
+        + "\n");
+    assertEquals(new Event(null, "add", "73857293"), callbacks.remove());
+    assertEquals(new Event(null, "remove", "2153"), callbacks.remove());
+    assertEquals(new Event(null, "add", "113411"), callbacks.remove());
+  }
+
+  @Test public void commentsIgnored() throws IOException {
+    consumeEvents(""
+        + ": test stream\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void idCleared() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "id\n"
+        + "\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event(null, null, "second event"), callbacks.remove());
+    assertEquals(new Event(null, null, "third event"), callbacks.remove());
+  }
+
+  @Test public void nakedFieldNames() throws IOException {
+    consumeEvents(""
+        + "data\n"
+        + "\n"
+        + "data\n"
+        + "data\n"
+        + "\n"
+        + "data:\n");
+    assertEquals(new Event(null, null, ""), callbacks.remove());
+    assertEquals(new Event(null, null, "\n"), callbacks.remove());
+  }
+
+  @Test public void colonSpaceOptional() throws IOException {
+    consumeEvents(""
+        + "data:test\n"
+        + "\n"
+        + "data: test\n"
+        + "\n");
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+  }
+
+  @Test public void leadingWhitespace() throws IOException {
+    consumeEvents(""
+        + "data:  test\n"
+        + "\n");
+    assertEquals(new Event(null, null, " test"), callbacks.remove());
+  }
+
+  @Test public void idReusedAcrossEvents() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n"
+        + "id: 2\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+    assertEquals(new Event("2", null, "third event"), callbacks.remove());
+  }
+
+  @Test public void idIgnoredFromEmptyEvent() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "id: 2\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+  }
+
+  @Test public void retry() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void retryInvalidFormatIgnored() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "retry: hey"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+  }
+  
+  private void consumeEvents(String source) throws IOException {
+    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
+      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+        callbacks.add(new Event(id, type, data));
+      }
+      @Override public void onRetryChange(long timeMs) {
+        callbacks.add(timeMs);
+      }
+    };
+    Buffer buffer = new Buffer().writeUtf8(source);
+    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
+    while (reader.processNextEvent());
+    assertEquals("Unconsumed buffer: " + buffer.readUtf8(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index f6a7c1f40d..19363356c3 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -29,4 +29,21 @@
       <scope>provided</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.testing</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
similarity index 53%
rename from okhttp-tests/src/test/java/okhttp3/TestUtil.java
rename to okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index 6f44cc5ba5..2a85617dc1 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -1,12 +1,44 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3;
 
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
+  public static final InetSocketAddress UNREACHABLE_ADDRESS
+      = new InetSocketAddress("198.51.100.1", 8080);
+
+  /**
+   * A network that resolves only one IP address per host. Use this when testing route selection
+   * fallbacks to prevent the host machine's various IP addresses from interfering.
+   */
+  private static final Dns SINGLE_INET_ADDRESS_DNS = new Dns() {
+    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+      return Collections.singletonList(addresses.get(0));
+    }
+  };
+
   private TestUtil() {
   }
 
@@ -26,7 +58,7 @@ public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
         .dispatcher(dispatcher)
-        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
         .build();
   }
 
@@ -49,7 +81,7 @@ public static String repeat(char c, int count) {
    * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
    * java/lang/ref/FinalizationTester.java
    */
-  public static void awaitGarbageCollection() throws InterruptedException {
+  public static void awaitGarbageCollection() throws Exception {
     Runtime.getRuntime().gc();
     Thread.sleep(100);
     System.runFinalization();
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index 38652c07de..ae034cd9a6 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -17,6 +17,9 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.internal.Throwables;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
@@ -30,8 +33,9 @@
 
   private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
   private Description lastTestStarted;
+  private final Map<Throwable, String> exceptions = new LinkedHashMap<>();
 
-  @Override public void testRunStarted(Description description) throws Exception {
+  @Override public void testRunStarted(Description description) {
     System.err.println("Installing aggressive uncaught exception handler");
     oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
     Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
@@ -48,17 +52,26 @@
           errorText.append("\n");
         }
         System.err.print(errorText.toString());
-        System.exit(-1);
+
+        synchronized (exceptions) {
+          exceptions.put(throwable, lastTestStarted.getDisplayName());
+        }
       }
     });
   }
 
-  @Override public void testStarted(Description description) throws Exception {
+  @Override public void testStarted(Description description) {
     lastTestStarted = description;
   }
 
   @Override public void testRunFinished(Result result) throws Exception {
     Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
     System.err.println("Uninstalled aggressive uncaught exception handler");
+
+    synchronized (exceptions) {
+      if (!exceptions.isEmpty()) {
+        throw Throwables.rethrowAsException(exceptions.keySet().iterator().next());
+      }
+    }
   }
 }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 2ac6188ae8..c25a0516b1 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -33,11 +33,21 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -50,6 +60,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>logging-interceptor</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -57,6 +73,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.1.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -80,6 +97,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-deploy-plugin</artifactId>
+        <version>2.7</version>
         <configuration>
           <skip>true</skip>
         </configuration>
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
new file mode 100644
index 0000000000..dfe5279985
--- /dev/null
+++ b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
@@ -0,0 +1,113 @@
+package okhttp3;
+
+import java.io.IOException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.Conscrypt;
+
+public class TestTls13Request {
+
+  // TLS 1.3
+  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256
+  };
+
+  /**
+   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
+   * as part of MODERN_TLS or folded into the default OkHttp client once published and
+   * available in JDK11 or Conscrypt.
+   */
+  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
+      .cipherSuites(TLS13_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3)
+      .supportsTlsExtensions(true)
+      .build();
+
+
+  private static final ConnectionSpec TLS_12 =
+      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
+          .build();
+
+  private TestTls13Request() {
+  }
+
+  public static void main(String[] args) {
+    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
+    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
+
+    System.out.println(
+        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
+
+    // https://github.com/tlswg/tls13-spec/wiki/Implementations
+    List<String> urls =
+        Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
+            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
+            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
+            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
+            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
+            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
+            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
+
+    System.out.println("TLS1.3+TLS1.2");
+    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
+
+    System.out.println("\nTLS1.3 only");
+    testClient(urls, buildClient(TLS_13));
+
+    System.out.println("\nTLS1.3 then fallback");
+    testClient(urls, buildClient(TLS_13, TLS_12));
+  }
+
+  private static void testClient(List<String> urls, OkHttpClient client) {
+    try {
+      for (String url : urls) {
+        sendRequest(client, url);
+      }
+    } finally {
+      client.dispatcher.executorService().shutdownNow();
+      client.connectionPool.evictAll();
+    }
+  }
+
+  private static OkHttpClient buildClient(ConnectionSpec... specs) {
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(specs)).build();
+  }
+
+  private static void sendRequest(OkHttpClient client, String url) {
+    System.out.printf("%-40s ", url);
+    System.out.flush();
+
+    System.out.println(Platform.get());
+
+    Request request = new Request.Builder().url(url).build();
+
+    Response response = null;
+    try {
+      response = client.newCall(request).execute();
+
+      Handshake handshake = response.handshake();
+      System.out.println(handshake.tlsVersion()
+          + " "
+          + handshake.cipherSuite()
+          + " "
+          + response.protocol()
+          + " "
+          + response.code
+          + " "
+          + response.body.bytes().length
+          + "b");
+    } catch (IOException ioe) {
+      System.out.println(ioe.toString());
+    } finally {
+      if (response != null) {
+        response.close();
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 09b480c647..0d9ca9fa75 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -38,10 +38,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -54,6 +54,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -72,7 +73,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -253,14 +254,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -349,7 +351,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -363,7 +365,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -389,7 +392,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -404,7 +407,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/")));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -774,7 +778,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        ? RequestBody.create(MediaType.get("text/plain"), "foo")
         : null;
   }
 
@@ -862,7 +866,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     Request request = new Request.Builder()
         .url(url)
-        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
         .build();
     Response invalidate = client.newCall(request).execute();
     assertEquals("", invalidate.body().string());
@@ -1033,6 +1037,43 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
+  @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody("ABCABCABC")
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
+  @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody(gzip("ABCABCABC"))
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: identity"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
@@ -1341,7 +1382,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1719,7 +1760,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1728,7 +1769,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -2482,7 +2524,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
   @Test public void immutableIsCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
@@ -2496,7 +2538,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(new MockResponse()
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("B"));
     server.enqueue(new MockResponse()
         .setBody("C"));
@@ -2507,6 +2549,19 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals("B", get(url).body().string());
   }
 
+  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Cache-Control: immutable")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 380707622e..9671e45167 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -23,10 +24,8 @@
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.ServerSocket;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
@@ -46,11 +45,13 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.logging.SimpleFormatter;
-import javax.net.ServerSocketFactory;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -58,18 +59,17 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.tls.HeldCertificate;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -86,8 +86,11 @@
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -99,12 +102,11 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private ServerSocket nullServer;
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
@@ -113,7 +115,6 @@
 
   @After public void tearDown() throws Exception {
     cache.delete();
-    Util.closeQuietly(nullServer);
     logger.removeHandler(logHandler);
   }
 
@@ -156,7 +157,7 @@
       requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+      assertEquals("Expected URL scheme 'http' or 'https' but was 'ftp'", expected.getMessage());
     }
   }
 
@@ -166,7 +167,7 @@
       requestBuilder.url("http://localhost:65536/");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+      assertEquals("Invalid URL port: \"65536\"", expected.getMessage());
     }
   }
 
@@ -209,7 +210,7 @@
     server.enqueue(new MockResponse());
 
     try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -246,10 +247,9 @@
         .url(server.url("/"))
         .head()
         .build();
-    executeSynchronously(headRequest)
-        .assertCode(200)
-        .assertHeader("Content-Length", "100")
-        .assertBody("");
+    Response response = client.newCall(headRequest).execute();
+    assertEquals(200, response.code());
+    assertArrayEquals(new byte[0], response.body().bytes());
 
     Request getRequest = new Request.Builder()
         .url(server.url("/"))
@@ -304,7 +304,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -397,7 +397,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -423,7 +423,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     executeSynchronously("/")
@@ -438,7 +438,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     try {
@@ -449,6 +449,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * We had a bug where we were passing a null route to the authenticator.
+   * https://github.com/square/okhttp/issues/3809
+   */
+  @Test public void authenticateWithNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
+
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    executeSynchronously("/")
+        .assertCode(401);
+
+    assertNotNull(authenticator.onlyRoute());
+  }
+
   @Test public void delete() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -483,7 +505,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -500,7 +522,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -529,7 +551,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -553,6 +575,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     patch();
   }
 
+  @Test public void customMethodWithBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("CUSTOM", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
     server.enqueue(new MockResponse());
 
@@ -832,10 +873,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * special address that never connects. The automatic retry will succeed.
    */
   @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    InetSocketAddress unreachableAddress = new InetSocketAddress("10.255.255.1", 8080);
-
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, unreachableAddress));
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
     proxySelector.proxies.add(server.toProxyAddress());
 
     server.enqueue(new MockResponse()
@@ -858,14 +897,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * never responds. The manual retry will succeed.
    */
   @Test public void readTimeoutFails() throws Exception {
-    InetSocketAddress nullServerAddress = startNullServer();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
+    server2.enqueue(new MockResponse()
+        .setBody("success!"));
 
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
     proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
+    proxySelector.proxies.add(server2.toProxyAddress());
 
     client = client.newBuilder()
         .proxySelector(proxySelector)
@@ -902,7 +941,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 1: set a deadline on the request body.
     RequestBody requestBody1 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -920,7 +959,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 2: check for the absence of a deadline on the request body.
     RequestBody requestBody2 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -1031,11 +1070,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("response that will never be received"));
     RecordedResponse response = executeSynchronously("/");
     response.assertFailure(
+            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
             SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
             SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
     );
@@ -1043,16 +1083,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     executeSynchronously("/").assertBody("abc");
@@ -1061,23 +1101,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
     }
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(sslClient.socketFactory);
+        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1095,14 +1134,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     Request request = new Request.Builder()
@@ -1117,11 +1158,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1132,6 +1173,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 11 response to the FAIL_HANDSHAKE
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     }
   }
 
@@ -1152,6 +1197,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
+    }
+  }
+
   @Test public void setFollowSslRedirectsFalse() throws Exception {
     enableTls();
     server.enqueue(new MockResponse()
@@ -1218,7 +1282,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -1244,7 +1308,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
@@ -1560,7 +1624,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -1573,30 +1637,50 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/")).build()).execute();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
   }
 
-  private void enqueueRequestTimeoutResponses() {
+  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setResponseCode(408)
         .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "1")
         .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("You took too long!", response.body().string());
   }
 
   @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
+    Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
-        .build()).execute();
+        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
 
@@ -1607,6 +1691,91 @@ private void enqueueRequestTimeoutResponses() {
     assertEquals("Hello", request2.getBody().readUtf8());
   }
 
+  @Test public void disableClientRequestTimeoutRetry() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+  }
+
+  @Test public void maxClientRequestTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void maxUnavailableTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(503, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
   @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
     // given
     server.enqueue(new MockResponse()
@@ -1618,7 +1787,7 @@ private void enqueueRequestTimeoutResponses() {
     // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
 
     // then
@@ -1709,7 +1878,7 @@ private void enqueueRequestTimeoutResponses() {
         .addHeader("Location: " + server2.url("/b")));
 
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
@@ -1829,6 +1998,25 @@ private void enqueueRequestTimeoutResponses() {
         .assertFailure("HTTP 205 had non-zero Content-Length: 39");
   }
 
+  @Test public void httpWithExcessiveHeaders() throws IOException {
+    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
+
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+
+    server.enqueue(new MockResponse()
+        .setStatus(longLine)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+  }
+
+  private String stringFill(char fillChar, int length) {
+    char[] value = new char[length];
+    Arrays.fill(value, fillChar);
+    return new String(value);
+  }
+
   @Test public void canceledBeforeExecute() throws Exception {
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -1851,16 +2039,13 @@ private void enqueueRequestTimeoutResponses() {
 
   /** Cancel a call that's waiting for connect to complete. */
   private void cancelDuringConnect(String scheme) throws Exception {
-    InetSocketAddress socketAddress = startNullServer();
-
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme(scheme)
-        .host(socketAddress.getHostName())
-        .port(socketAddress.getPort())
-        .build();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
 
     long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder().url(url).build());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/").newBuilder().scheme(scheme).build())
+        .build());
     cancelLater(call, cancelDelayMillis);
 
     long startNanos = System.nanoTime();
@@ -1873,20 +2058,29 @@ private void cancelDuringConnect(String scheme) throws Exception {
     assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
   }
 
-  private InetSocketAddress startNullServer() throws IOException {
-    InetSocketAddress address = new InetSocketAddress(InetAddress.getByName("localhost"), 0);
-    nullServer = ServerSocketFactory.getDefault().createServerSocket();
-    nullServer.bind(address);
-    return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
-  }
-
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
+    final CountDownLatch latch = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            try {
+              latch.await();
+            } catch (InterruptedException e) {
+              throw new AssertionError(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
         .build());
     call.enqueue(callback);
     call.cancel();
+    latch.countDown();
+
     callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
@@ -2122,7 +2316,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password"))
+        .authenticator(new RecordingOkAuthenticator("password", null))
         .build();
 
     executeSynchronously("/").assertBody("abcabcabc");
@@ -2224,7 +2418,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request)
@@ -2240,7 +2434,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .post(RequestBody.create(MediaType.get("text/plain"), ""))
         .build();
 
     executeSynchronously(request)
@@ -2264,7 +2458,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     Call call = client.newCall(request);
@@ -2285,18 +2479,16 @@ private InetSocketAddress startNullServer() throws IOException {
 
   @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
     server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
+        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    assertEquals(100, response.code());
-    assertEquals("Continue", response.message());
-    assertEquals("", response.body().string());
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("abc", recordedRequest.getBody().readUtf8());
@@ -2307,6 +2499,35 @@ private InetSocketAddress startNullServer() throws IOException {
     serverRespondsWithUnsolicited100Continue();
   }
 
+  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
+    client = client.newBuilder()
+        .readTimeout(1, TimeUnit.SECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWith100ContinueOnly();
+  }
+
   @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
@@ -2315,7 +2536,7 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2337,7 +2558,7 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2356,7 +2577,7 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2447,7 +2668,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
   @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2456,7 +2677,8 @@ private InetSocketAddress startNullServer() throws IOException {
 
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(hostnameVerifier)
         .build();
@@ -2484,7 +2706,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Respond to a proxy authorization challenge. */
   @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
@@ -2495,9 +2717,10 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2530,7 +2753,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Request request = new Request.Builder()
@@ -2553,7 +2776,7 @@ private InetSocketAddress startNullServer() throws IOException {
    * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setResponseCode(407)
@@ -2566,9 +2789,10 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2589,7 +2813,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     for (int i = 0; i < 21; i++) {
       server.enqueue(new MockResponse()
@@ -2599,9 +2823,10 @@ private InetSocketAddress startNullServer() throws IOException {
     }
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2620,8 +2845,8 @@ private InetSocketAddress startNullServer() throws IOException {
    * We used to have that behavior but it is problematic because unrelated requests end up sharing
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
-  @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+  @Test public void noPreemptiveProxyAuthorization() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2629,7 +2854,8 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
@@ -2641,11 +2867,107 @@ private InetSocketAddress startNullServer() throws IOException {
     Response response = client.newCall(request).execute();
     assertEquals("response body", response.body().string());
 
+    RecordedRequest connect1 = server.takeRequest();
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that we can send authentication information without being prompted first. */
+  @Test public void preemptiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) {
+            assertEquals("CONNECT", response.request().method());
+            assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());
+            assertEquals("android.com", response.request().url().host());
+
+            List<Challenge> challenges = response.challenges();
+            assertEquals("OkHttp-Preemptive", challenges.get(0).scheme());
+
+            return response.request().newBuilder()
+                .header("Proxy-Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals("CONNECT", connect.getMethod());
+    assertEquals(credential, connect.getHeader("Proxy-Authorization"));
+    assertEquals("/", connect.getPath());
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("password", get.getHeader("Proxy-Authorization"));
+    assertEquals("GET", get.getMethod());
+    assertNull(get.getHeader("Proxy-Authorization"));
+    assertEquals("/foo", get.getPath());
+  }
+
+  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
+        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
+        .setBody("proxy auth required"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse());
+
+    final List<String> challengeSchemes = new ArrayList<>();
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) {
+            List<Challenge> challenges = response.challenges();
+            challengeSchemes.add(challenges.get(0).scheme());
+            return response.request().newBuilder()
+                .header("Proxy-Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT", connect1.getMethod());
+    assertEquals(credential, connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT", connect2.getMethod());
+    assertEquals(credential, connect2.getHeader("Proxy-Authorization"));
+
+    assertEquals(Arrays.asList("OkHttp-Preemptive", "Basic"), challengeSchemes);
   }
 
   @Test public void interceptorGetsHttp2() throws Exception {
@@ -2761,7 +3083,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request);
@@ -2771,7 +3093,7 @@ private InetSocketAddress startNullServer() throws IOException {
   @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
   @Test public void invalidHost() throws Exception {
     Request request = new Request.Builder()
-        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .url(HttpUrl.get("http://1234.1.1.1/"))
         .build();
 
     executeSynchronously(request)
@@ -2818,7 +3140,7 @@ private void upload(
   /** https://github.com/square/okhttp/issues/2344 */
   @Test public void ipv6HostHasSquareBraces() throws Exception {
     // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -2827,7 +3149,8 @@ private void upload(
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -2853,7 +3176,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     return new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() throws IOException {
@@ -2949,23 +3272,70 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     }
   }
 
+  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
+  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
   @Test public void httpsWithIpAddress() throws Exception {
     String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
 
     // Create a certificate with an IP address in the subject alt name.
     HeldCertificate heldCertificate = new HeldCertificate.Builder()
         .commonName("example.com")
-        .subjectAlternativeName(localIpAddress)
+        .addSubjectAlternativeName(localIpAddress)
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-        .addTrustedCertificate(heldCertificate.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate())
         .build();
 
     // Use that certificate on the server and trust it on the client.
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Collections.singletonList(Protocol.HTTP_1_1))
         .build();
@@ -2986,6 +3356,35 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
   }
 
+  @Test public void postWithFileNotFound() throws Exception {
+    final AtomicInteger called = new AtomicInteger(0);
+
+    RequestBody body = new RequestBody() {
+      @Nullable @Override public MediaType contentType() {
+        return MediaType.get("application/octet-stream");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        called.incrementAndGet();
+        throw new FileNotFoundException();
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build();
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(FileNotFoundException.class);
+
+    assertEquals(1L, called.get());
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -3049,10 +3448,11 @@ private void enableProtocol(Protocol protocol) {
 
   private void enableTls() {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -3101,6 +3501,6 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 3c5267bcc9..e61cb9f294 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,39 +15,36 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.HeldCertificate;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() throws Exception {
+  @Test public void equalsFromCertificate() {
     HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber("2")
+        .serialNumber(2L)
         .build();
     assertEquals(
-        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
-        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()),
+        CertificateChainCleaner.get(rootB.certificate(), rootA.certificate()));
   }
 
-  @Test public void equalsFromTrustManager() throws Exception {
-    SslClient client = new SslClient.Builder().build();
-    X509TrustManager x509TrustManager = client.trustManager;
+  @Test public void equalsFromTrustManager() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
+    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
     assertEquals(
         CertificateChainCleaner.get(x509TrustManager),
         CertificateChainCleaner.get(x509TrustManager));
@@ -55,15 +52,15 @@
 
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(root), cleaner.clean(list(root), "hostname"));
   }
 
-  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+  @Test public void normalizeUnknownSelfSignedCertificate() {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get();
 
@@ -76,123 +73,123 @@
 
   @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certA), "hostname")); // Root is added!
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, root, certB), "hostname"));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, certB), "hostname"));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
     HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(selfSigned)
+        .serialNumber(2L)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(trusted)
+        .serialNumber(3L)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certA)
+        .serialNumber(4L)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
-        selfSigned.certificate, trusted.certificate);
+        selfSigned.certificate(), trusted.certificate());
     assertEquals(list(certB, certA, trusted, selfSigned),
         cleaner.clean(list(certB, certA), "hostname"));
     assertEquals(list(certB, certA, trusted, selfSigned),
@@ -203,22 +200,22 @@
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
     HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
-        .serialNumber("2")
+        .signedBy(unknownSigner)
+        .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
-        .serialNumber("3")
+        .signedBy(trusted)
+        .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("4")
+        .signedBy(intermediateCa)
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
     assertEquals(list(certificate, intermediateCa, trusted),
         cleaner.clean(list(certificate, intermediateCa), "hostname"));
     assertEquals(list(certificate, intermediateCa, trusted),
@@ -229,23 +226,23 @@
     List<HeldCertificate> heldCertificates = chainOfLength(10);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     assertEquals(certificates, cleaner.clean(certificates, "hostname"));
     assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
   }
 
-  @Test public void chainTooLong() throws Exception {
+  @Test public void chainTooLong() {
     List<HeldCertificate> heldCertificates = chainOfLength(11);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     try {
       cleaner.clean(certificates, "hostname");
@@ -255,12 +252,12 @@
   }
 
   /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+  private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(Integer.toString(i))
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(i)
           .build());
     }
     return result;
@@ -269,7 +266,7 @@
   private List<Certificate> list(HeldCertificate... heldCertificates) {
     List<Certificate> result = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate);
+      result.add(heldCertificate.certificate());
     }
     return result;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 0745982fb2..28e2af8423 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -15,13 +15,12 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.CertificatePinner.Pin;
-import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -40,24 +39,20 @@
   static String certC1Sha256Pin;
 
   static {
-    try {
-      certA1 = new HeldCertificate.Builder()
-          .serialNumber("100")
-          .build();
-      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
-
-      certB1 = new HeldCertificate.Builder()
-          .serialNumber("200")
-          .build();
-      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
-
-      certC1 = new HeldCertificate.Builder()
-          .serialNumber("300")
-          .build();
-      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
+    certA1 = new HeldCertificate.Builder()
+        .serialNumber(100L)
+        .build();
+    certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate()).base64();
+
+    certB1 = new HeldCertificate.Builder()
+        .serialNumber(200L)
+        .build();
+    certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate()).base64();
+
+    certC1 = new HeldCertificate.Builder()
+        .serialNumber(300L)
+        .build();
+    certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate()).base64();
   }
 
   @Test public void malformedPin() throws Exception {
@@ -81,16 +76,16 @@
   /** Multiple certificates generated from the same keypair have the same pin. */
   @Test public void sameKeypairSamePin() throws Exception {
     HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair)
-        .serialNumber("101")
+        .keyPair(certA1.keyPair())
+        .serialNumber(101L)
         .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
 
     HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair)
-        .serialNumber("201")
+        .keyPair(certB1.keyPair())
+        .serialNumber(201L)
         .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
 
     assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
     assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
@@ -102,15 +97,15 @@
         .add("example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckSha1Pin() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
@@ -118,7 +113,7 @@
         .add("example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheck() throws Exception {
@@ -127,7 +122,7 @@
         .build();
 
     try {
-      certificatePinner.check("example.com", certB1.certificate);
+      certificatePinner.check("example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -138,8 +133,8 @@
         .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("example.com", certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("example.com", certB1.certificate());
   }
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
@@ -148,13 +143,13 @@
         .add("www.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("www.example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("www.example.com", certA1.certificate());
   }
 
   @Test public void absentHostnameMatches() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
@@ -162,7 +157,7 @@
         .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
@@ -171,7 +166,7 @@
         .add("*.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
@@ -180,7 +175,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certB1.certificate);
+      certificatePinner.check("a.example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -191,8 +186,8 @@
         .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -202,8 +197,8 @@
         .add("a.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -214,7 +209,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certC1.certificate);
+      certificatePinner.check("a.example.com", certC1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
index 63b3023253..64754ad5c0 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -48,7 +48,7 @@
 
   @Test public void instancesAreInterned() {
     assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
-    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+    assertSame(TLS_KRB5_WITH_DES_CBC_MD5,
         forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
index 5e3b25afdf..be741a0b53 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -17,16 +17,19 @@
 
 import java.io.IOException;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
-import okhttp3.internal.tls.HeldCertificate;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -48,18 +51,18 @@
 
   @Before public void setUp() throws Exception {
     rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(0)
         .commonName("root")
         .build();
     certificate = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .serialNumber(2L)
         .commonName(server.getHostName())
-        .subjectAlternativeName(server.getHostName())
-        .subjectAlternativeName("san.com")
-        .subjectAlternativeName("*.wildcard.com")
-        .subjectAlternativeName("differentdns.com")
+        .addSubjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName("san.com")
+        .addSubjectAlternativeName("*.wildcard.com")
+        .addSubjectAlternativeName("differentdns.com")
         .build();
 
     serverIps = Dns.SYSTEM.lookup(server.getHostName());
@@ -70,18 +73,19 @@
     dns.set("www.wildcard.com", serverIps);
     dns.set("differentdns.com", Collections.<InetAddress>emptyList());
 
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
 
     client = new OkHttpClient.Builder().dns(dns)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, rootCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate)
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     url = server.url("/robots.txt");
   }
@@ -177,7 +181,7 @@
   /** Can still coalesce when pinning is used if pins match. */
   @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
     CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate()).base64())
         .build();
     client = client.newBuilder().certificatePinner(pinner).build();
 
@@ -245,6 +249,17 @@
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
 
+    final AtomicInteger connectCount = new AtomicInteger();
+    EventListener listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        connectCount.getAndIncrement();
+      }
+    };
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
     assert200Http2Response(execute(url), server.getHostName());
 
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
@@ -254,6 +269,7 @@
     assert200Http2Response(execute(sanUrl), "san.com");
 
     assertEquals(1, client.connectionPool().connectionCount());
+    assertEquals(1, connectCount.get());
   }
 
   /** Check that wildcard SANs are supported. */
@@ -304,7 +320,7 @@
   }
 
   private Response execute(String url) throws IOException {
-    return execute(HttpUrl.parse(url));
+    return execute(HttpUrl.get(url));
   }
 
   private Response execute(HttpUrl url) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 9ef1b146ca..d2c778ce65 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -85,7 +85,7 @@
     synchronized (pool) {
       StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
           EventListener.NONE, null);
-      streamAllocation.acquire(c1);
+      streamAllocation.acquire(c1, true);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -179,7 +179,7 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
     synchronized (pool) {
       StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
           EventListener.NONE, null);
-      leak.acquire(connection);
+      leak.acquire(connection, true);
     }
   }
 
@@ -193,7 +193,7 @@ private RealConnection newConnection(ConnectionPool pool, Route route, long idle
 
   private Address newAddress(String name) {
     return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        new RecordingOkAuthenticator("password", null), null, Collections.<Protocol>emptyList(),
         Collections.<ConnectionSpec>emptyList(),
         ProxySelector.getDefault());
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index 533d8ab352..f5c8e75c85 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,22 +15,21 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLException;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -39,7 +38,7 @@
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
 
   @Test public void connectionsAreReused() throws Exception {
@@ -193,7 +192,7 @@
 
     Request requestB = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
     assertEquals("b", responseB.body().string());
@@ -253,9 +252,10 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SslClient sslClient2 = new SslClient.Builder().build();
+    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -339,11 +339,12 @@ private void enableHttp2() {
 
   private void enableHttpsAndAlpn(Protocol... protocols) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocols))
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocols(client.protocols());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
new file mode 100644
index 0000000000..2add4201e3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import okhttp3.internal.platform.ConscryptPlatform;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.OpenSSLProvider;
+import org.junit.Assume;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ConscryptTest {
+  public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
+  private OkHttpClient client = buildClient();
+
+  private OkHttpClient buildClient() {
+    ConnectionSpec spec = new ConnectionSpec.Builder(true)
+        .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
+        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
+        .supportsTlsExtensions(true)
+        .build();
+
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
+  }
+
+  private static void assumeConscrypt() {
+    Assume.assumeTrue("conscrypt".equals(System.getProperty("okhttp.platform")));
+  }
+
+  private static void assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com");
+    } catch (UnknownHostException uhe) {
+      Assume.assumeNoException(uhe);
+    }
+  }
+
+  @Test
+  public void testMozilla() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://mozilla.org/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testGoogle() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://google.com/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testBuild() {
+    assertNotNull(ConscryptPlatform.buildIfSupported());
+  }
+
+  @Test
+  public void testPreferred() {
+    Assume.assumeFalse(Platform.isConscryptPreferred());
+
+    try {
+      Security.insertProviderAt(new OpenSSLProvider(), 1);
+      assertTrue(Platform.isConscryptPreferred());
+    } finally {
+      Security.removeProvider("Conscrypt");
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index da152db9c1..b38dd3dd9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -33,7 +33,7 @@
 import static org.junit.Assert.fail;
 
 public final class CookieTest {
-  HttpUrl url = HttpUrl.parse("https://example.com/");
+  HttpUrl url = HttpUrl.get("https://example.com/");
 
   @Test public void simpleCookie() throws Exception {
     Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
@@ -216,73 +216,102 @@
 
   @Test public void domainMatches() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** If no domain is present, match only the origin domain. */
   @Test public void domainMatchesNoDomain() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore an optional leading `.` in the domain. */
   @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore the entire attribute if the domain ends with `.`. */
   @Test public void domainIgnoredWithTrailingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
     assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
     assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
   }
 
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
+    assertEquals("::1", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertEquals("1::", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[1::]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertEquals("::1:ffff:ffff", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/")));
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
+    assertNull(cookie);
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
+    assertEquals("::1", cookie.domain());
+  }
+
   /**
    * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
    * may change in the future. If this test begins to fail, please double check they are still
    * present in the public suffix list.
    */
   @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
+    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
     assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
     assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
     assertNull(Cookie.parse(ascii, "a=b; domain=com"));
 
-    HttpUrl unicode = HttpUrl.parse("https://長.長.長崎.jp");
+    HttpUrl unicode = HttpUrl.get("https://長.長.長崎.jp");
     assertNotNull(Cookie.parse(unicode, "a=b; domain=長.長崎.jp"));
     assertNull(Cookie.parse(unicode, "a=b; domain=長崎.jp"));
 
-    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
     assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
     assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
   }
@@ -293,23 +322,23 @@
   }
 
   @Test public void defaultPath() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path());
   }
 
   @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=quux").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=").path());
   }
 
   @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/"),
         "a=b; path=/quux").path());
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=/quux").path());
   }
 
@@ -507,6 +536,15 @@
     assertEquals(true, cookie.httpOnly());
   }
 
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertEquals("::1", cookie.domain());
+  }
+
   @Test public void equalsAndHashCode() throws Exception {
     List<String> cookieStrings = Arrays.asList(
         "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index ab2a955273..17489b045d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -276,7 +276,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -289,7 +289,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=.squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -302,7 +302,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    HttpUrl url = HttpUrl.get("https://squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -315,11 +315,11 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
     cookieJar.saveFromResponse(url1, Arrays.asList(
         Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
 
-    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
     List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
     assertEquals(Collections.<Cookie>emptyList(), actualCookies);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index e4896a94d1..80cdb78cfd 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,6 +1,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.RealCall.AsyncCall;
@@ -26,14 +28,18 @@
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
+  RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
+  RecordingEventListener listener = new RecordingEventListener();
   OkHttpClient client = defaultClient().newBuilder()
       .dispatcher(dispatcher)
+      .eventListener(listener)
       .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
+    listener.forbidLock(dispatcher);
   }
 
   @Test public void maxRequestsZero() throws Exception {
@@ -74,6 +80,14 @@
     executor.assertJobs("http://a/1", "http://a/2");
   }
 
+  @Test public void maxPerHostNotEnforcedForWebSockets() {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newWebSocket(newRequest("http://a/1"), webSocketListener);
+    client.newWebSocket(newRequest("http://a/2"), webSocketListener);
+    client.newWebSocket(newRequest("http://a/3"), webSocketListener);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3");
+  }
+
   @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequests(2);
     client.newCall(newRequest("http://a/1")).enqueue(callback);
@@ -216,7 +230,7 @@
     assertFalse(a4.isCanceled());
   }
 
-  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
     final AtomicBoolean idle = new AtomicBoolean();
     dispatcher.setIdleCallback(new Runnable() {
       @Override public void run() {
@@ -255,6 +269,54 @@
     assertTrue(idle.get());
   }
 
+  @Test public void executionRejectedImmediately() throws Exception {
+    Request request = newRequest("http://a/1");
+    executor.shutdown();
+    client.newCall(request).enqueue(callback);
+    callback.await(request.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallFailed"), listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequests(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    executor.finishJob("http://a/1"); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
   private <T> Set<T> set(T... values) {
     return set(Arrays.asList(values));
   }
@@ -278,9 +340,11 @@ private Thread makeSynchronousCall(final Call call) {
   }
 
   class RecordingExecutor extends AbstractExecutorService {
+    private boolean shutdown;
     private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
+      if (shutdown) throw new RejectedExecutionException();
       calls.add((AsyncCall) command);
     }
 
@@ -305,7 +369,7 @@ public void finishJob(String url) {
     }
 
     @Override public void shutdown() {
-      throw new UnsupportedOperationException();
+      shutdown = true;
     }
 
     @Override public List<Runnable> shutdownNow() {
@@ -320,8 +384,7 @@ public void finishJob(String url) {
       throw new UnsupportedOperationException();
     }
 
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
-        throws InterruptedException {
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit) {
       throw new UnsupportedOperationException();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
new file mode 100644
index 0000000000..5bdcea0f8a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.internal.RecordingHeadersListener;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.internal.duplex.MwsDuplexAccess;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
+import okhttp3.tls.HandshakeCertificates;
+import okio.BufferedSource;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static junit.framework.TestCase.assertTrue;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertEquals;
+
+public final class DuplexTest {
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void clientReadsHeadersDataHeadersData() throws IOException {
+    final LatchParty latchParty = new LatchParty();
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2");
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public HeadersListener onRequest(RecordedRequest request,
+          BufferedSource requestBodySource, HttpSink responseBodySink) throws IOException {
+
+        latchParty.step(1);
+        responseBodySink.sink().writeUtf8("ok");
+        responseBodySink.sink().flush();
+        responseBodySink.headers(Headers.of("b", "banana"));
+
+        latchParty.step(3);
+        responseBodySink.sink().writeUtf8("taco");
+        responseBodySink.sink().flush();
+
+        latchParty.step(5);
+        responseBodySink.headers(Headers.of("c", "cookie"));
+        responseBodySink.sink().close();
+
+        return null;
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .duplex("POST")
+        .build());
+
+    Response response = call.execute();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+    response.headersListener(headersListener);
+
+    assertEquals(Headers.of("h1", "v1", "h2", "v2"), response.headers());
+
+    latchParty.step(2);
+    BufferedSource source = response.body().source();
+    assertEquals("ok", source.readUtf8(2));
+
+    latchParty.step(4);
+    assertEquals("taco", source.readUtf8(4));
+    assertEquals(Headers.of("b", "banana"), headersListener.takeFirst());
+
+    latchParty.step(6);
+    assertTrue(source.exhausted());
+    assertEquals(Collections.singletonList(Headers.of("c", "cookie")), headersListener.takeAll());
+  }
+
+  @Test public void serverReadsHeadersDataHeadersData() throws IOException {
+    final RecordingHeadersListener serverHeadersListener = new RecordingHeadersListener();
+    final AtomicReference<BufferedSource> requestBodySourceRef = new AtomicReference<>();
+
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2");
+    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
+      @Override public HeadersListener onRequest(RecordedRequest request,
+          BufferedSource requestBodySource, HttpSink responseBodySink) throws IOException {
+        responseBodySink.sink().close();
+
+        requestBodySourceRef.set(requestBodySource);
+        return serverHeadersListener;
+      }
+    });
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .duplex("POST")
+        .build());
+
+    Response response = call.execute();
+    HttpSink httpSink = response.httpSink();
+    httpSink.sink().writeUtf8("hey\n");
+    httpSink.headers(Headers.of("a", "android"));
+    httpSink.sink().writeUtf8("whats going on\n");
+    httpSink.headers(Headers.of("b", "blackberry"));
+    httpSink.sink().close();
+
+    // check what the server received
+    BufferedSource requestBodySource = requestBodySourceRef.get();
+    assertEquals("hey", requestBodySource.readUtf8Line());
+    assertEquals("whats going on", requestBodySource.readUtf8Line());
+    assertTrue(requestBodySource.exhausted());
+    assertEquals(Arrays.asList(Headers.of("a", "android"), Headers.of("b", "blackberry")),
+        serverHeadersListener.takeAll());
+  }
+
+  // TODO(oldergod) write tests for headers discarded with 100 Continue
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+  }
+
+  static final class LatchParty {
+    private int currentRound = 1;
+
+    synchronized void step(int round) {
+      try {
+        // Wait until I can be released.
+        while (currentRound != round) {
+          wait();
+        }
+
+        // Release the other thread.
+        currentRound++;
+        notifyAll();
+      } catch (InterruptedException e) {
+        throw new AssertionError();
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 29b7fa4016..0838bd9549 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -16,78 +16,372 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import java.net.UnknownHostException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.CallFailed;
+import okhttp3.RecordingEventListener.ConnectEnd;
+import okhttp3.RecordingEventListener.ConnectFailed;
+import okhttp3.RecordingEventListener.ConnectStart;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.DnsEnd;
+import okhttp3.RecordingEventListener.DnsStart;
+import okhttp3.RecordingEventListener.RequestBodyEnd;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
+import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
+import okhttp3.RecordingEventListener.SecureConnectEnd;
+import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.any;
+import static org.hamcrest.CoreMatchers.either;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 public final class EventListenerTest {
+  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private OkHttpClient client;
-  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
   private final RecordingEventListener listener = new RecordingEventListener();
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
+
+  private OkHttpClient client;
+  private SocksProxy socksProxy;
 
   @Before public void setUp() {
-    client = new OkHttpClient.Builder()
-        .dns(singleDns)
+    client = defaultClient().newBuilder()
         .eventListener(listener)
         .build();
+
+    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(client.dispatcher());
+  }
+
+  @After public void tearDown() throws Exception {
+    if (socksProxy != null) {
+      socksProxy.shutdown();
+    }
   }
 
   @Test public void successfulCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
 
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
     assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
     response.body().close();
 
-    List<Class<?>> expectedEvents = Arrays.asList(DnsStart.class, DnsEnd.class);
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void successfulHttpsCallEventSequence() throws IOException {
-    enableTls(false);
-    server.enqueue(new MockResponse());
+  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    final CountDownLatch completionLatch = new CountDownLatch(1);
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        completionLatch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) {
+        response.close();
+        completionLatch.countDown();
+      }
+    };
+
+    call.enqueue(callback);
+
+    completionLatch.await();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedCallEventSequence() {
+    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
+
+    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedDribbledCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBody("0123456789")
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), equalTo("unexpected end of stream"));
+    }
 
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+    ResponseBodyEnd bodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+    assertEquals(5, bodyEnd.bytesRead);
+  }
+
+  @Test public void canceledCallEventSequence() {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
     assertEquals(200, response.code());
+    response.body().string();
     response.body().close();
 
-    List<Class<?>> expectedEvents = Arrays.asList(
-        DnsStart.class, DnsEnd.class,
-        SecureConnectStart.class, SecureConnectEnd.class);
+    assumeThat(response, responseMatcher);
+
+    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void secondCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build()).execute().close();
+
+    listener.removeUpToEvent(CallEnd.class);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.close();
+
+    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
+  private void assertBytesReadWritten(RecordingEventListener listener,
+      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
+      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
+
+    if (requestHeaderLength != null) {
+      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
+      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+    } else {
+      assertFalse("Found RequestHeadersEnd",
+          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+    }
+
+    if (requestBodyBytes != null) {
+      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
+      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+    } else {
+      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+    }
+
+    if (responseHeaderLength != null) {
+      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
+      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+    } else {
+      assertFalse("Found ResponseHeadersEnd",
+          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+    }
+
+    if (responseBodyBytes != null) {
+      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+    } else {
+      assertFalse("Found ResponseBodyEnd",
+          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+    }
+  }
+
+  private Matcher<Long> greaterThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("> " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) > value;
+      }
+    };
+  }
+
+  private Matcher<Long> lessThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("< " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) < value;
+      }
+    };
+  }
+
+  private Matcher<Response> matchesProtocol(final Protocol protocol) {
+    return new BaseMatcher<Response>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("is HTTP/2");
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Response)o).protocol == protocol;
+      }
+    };
+  }
+
+  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(0L));
+  }
+
+  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(3L));
+  }
+
+  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(6L));
+  }
+
+  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
+        greaterThan(6L));
+  }
+
   @Test public void successfulDnsLookup() throws IOException {
     server.enqueue(new MockResponse());
 
@@ -100,13 +394,12 @@
 
     DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
     assertSame(call, dnsStart.call);
-    assertEquals("localhost", dnsStart.domainName);
+    assertEquals(server.getHostName(), dnsStart.domainName);
 
     DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
     assertSame(call, dnsEnd.call);
-    assertEquals("localhost", dnsEnd.domainName);
+    assertEquals(server.getHostName(), dnsEnd.domainName);
     assertEquals(1, dnsEnd.inetAddressList.size());
-    assertNull(dnsEnd.throwable);
   }
 
   @Test public void noDnsLookupOnPooledConnection() throws IOException {
@@ -130,9 +423,9 @@
     assertEquals(200, response2.code());
     response2.body().close();
 
-    List<Class<?>> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains(DnsStart.class));
-    assertFalse(recordedEvents.contains(DnsEnd.class));
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("DnsStart"));
+    assertFalse(recordedEvents.contains("DnsEnd"));
   }
 
   @Test public void multipleDnsLookupsForSingleCall() throws IOException {
@@ -142,8 +435,8 @@
     server.enqueue(new MockResponse());
 
     FakeDns dns = new FakeDns();
-    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
-    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
+    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
 
     client = client.newBuilder()
         .dns(dns)
@@ -177,16 +470,14 @@
 
     listener.removeUpToEvent(DnsStart.class);
 
-    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    assertSame(call, dnsEnd.call);
-    assertEquals("fakeurl", dnsEnd.domainName);
-    assertNull(dnsEnd.inetAddressList);
-    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
   }
 
   @Test public void emptyDnsLookup() {
     Dns emptyDns = new Dns() {
-      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      @Override public List<InetAddress> lookup(String hostname) {
         return Collections.emptyList();
       }
     };
@@ -205,15 +496,180 @@
 
     listener.removeUpToEvent(DnsStart.class);
 
-    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    assertSame(call, dnsEnd.call);
-    assertEquals("fakeurl", dnsEnd.domainName);
-    assertNull(dnsEnd.inetAddressList);
-    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void successfulConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void failedConnect() throws UnknownHostException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
+    assertSame(call, connectFailed.call);
+    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
+    assertNull(connectFailed.protocol);
+    assertNotNull(connectFailed.ioe);
+  }
+
+  @Test public void multipleConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulHttpProxyConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://www.fakeurl")
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(server.toProxyAddress(), connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void successfulSocksProxyConnect() throws Exception {
+    server.enqueue(new MockResponse());
+
+    socksProxy = new SocksProxy();
+    socksProxy.play();
+    Proxy proxy = socksProxy.proxy();
+
+    client = client.newBuilder()
+        .proxy(proxy)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
+        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(proxy, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void authenticatingTunnelProxyConnect() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertNull(connectEnd.protocol);
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
   }
 
   @Test public void successfulSecureConnect() throws IOException {
-    enableTls(false);
+    enableTlsWithTunnel(false);
     server.enqueue(new MockResponse());
 
     Call call = client.newCall(new Request.Builder()
@@ -229,11 +685,10 @@
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
     assertSame(call, secureEnd.call);
     assertNotNull(secureEnd.handshake);
-    assertNull(secureEnd.throwable);
   }
 
   @Test public void failedSecureConnect() {
-    enableTls(false);
+    enableTlsWithTunnel(false);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
@@ -249,14 +704,13 @@
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
     assertSame(call, secureStart.call);
 
-    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertSame(call, secureEnd.call);
-    assertNull(secureEnd.handshake);
-    assertTrue(secureEnd.throwable instanceof IOException);
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertNotNull(callFailed.ioe);
   }
 
   @Test public void secureConnectWithTunnel() throws IOException {
-    enableTls(true);
+    enableTlsWithTunnel(true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
     server.enqueue(new MockResponse());
@@ -278,11 +732,10 @@
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
     assertSame(call, secureEnd.call);
     assertNotNull(secureEnd.handshake);
-    assertNull(secureEnd.throwable);
   }
 
   @Test public void multipleSecureConnectsForSingleCall() throws IOException {
-    enableTls(false);
+    enableTlsWithTunnel(false);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse());
@@ -299,14 +752,14 @@
     response.body().close();
 
     listener.removeUpToEvent(SecureConnectStart.class);
-    listener.removeUpToEvent(SecureConnectEnd.class);
+    listener.removeUpToEvent(ConnectFailed.class);
 
     listener.removeUpToEvent(SecureConnectStart.class);
     listener.removeUpToEvent(SecureConnectEnd.class);
   }
 
   @Test public void noSecureConnectsOnPooledConnection() throws IOException {
-    enableTls(false);
+    enableTlsWithTunnel(false);
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
@@ -331,106 +784,345 @@
     assertEquals(200, response2.code());
     response2.body().close();
 
-    List<Class<?>> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains(SecureConnectStart.class));
-    assertFalse(recordedEvents.contains(SecureConnectEnd.class));
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("SecureConnectStart"));
+    assertFalse(recordedEvents.contains("SecureConnectEnd"));
   }
 
-  private void enableTls(boolean tunnelProxy) {
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(sslClient.socketFactory, tunnelProxy);
+  @Test public void successfulConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(call, connectionAcquired.call);
+    assertNotNull(connectionAcquired.connection);
   }
 
-  static final class DnsStart {
-    final Call call;
-    final String domainName;
+  @Test public void noConnectionFoundOnFollowUp() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
 
-    DnsStart(Call call, String domainName) {
-      this.call = call;
-      this.domainName = domainName;
-    }
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+
+    List<String> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains("ConnectionAcquired"));
   }
 
-  static final class DnsEnd {
-    final Call call;
-    final String domainName;
-    final List<InetAddress> inetAddressList;
-    final Throwable throwable;
+  @Test public void pooledConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
 
-    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, Throwable throwable) {
-      this.call = call;
-      this.domainName = domainName;
-      this.inetAddressList = inetAddressList;
-      this.throwable = throwable;
-    }
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
   }
 
-  static final class SecureConnectStart {
-    final Call call;
+  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo")
+        .addHeader("Connection", "Close"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
 
-    SecureConnectStart(Call call) {
-      this.call = call;
-    }
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+  }
+
+  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void responseBodyFailHttp() throws IOException {
+    responseBodyFail(Protocol.HTTP_1_1);
   }
 
-  static final class SecureConnectEnd {
-    final Call call;
-    final Handshake handshake;
-    final Throwable throwable;
+  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
+    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
 
-    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-      this.call = call;
-      this.handshake = handshake;
-      this.throwable = throwable;
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    if (expectedProtocol == Protocol.HTTP_2) {
+      // soft failure since client may not support depending on Platform
+      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
     }
+    assertEquals(expectedProtocol, response.protocol());
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void emptyResponseBody() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Ignore("this reports CallFailed not CallEnd")
+  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodyFail();
   }
 
-  static final class RecordingEventListener extends EventListener {
-    final Deque<Object> eventSequence = new ArrayDeque<>();
+  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp() throws IOException {
+    requestBodyFail();
+  }
 
-    /**
-     * Removes recorded events up to (and including) an event is found whose class equals
-     * {@code eventClass} and returns it.
-     */
-    <T> T removeUpToEvent(Class<T> eventClass) {
-      Object event = eventSequence.poll();
-      while (event != null && !eventClass.isInstance(event)) {
-        event = eventSequence.poll();
+  private void requestBodyFail() {
+    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.get("text/plain");
       }
-      if (event == null) throw new AssertionError();
-      return (T) event;
-    }
 
-    List<Class<?>> recordedEventTypes() {
-      List<Class<?>> eventTypes = new ArrayList<>();
-      for (Object event : eventSequence) {
-        eventTypes.add(event.getClass());
+      @Override public long contentLength() {
+        return 1024 * 8192;
       }
-      return eventTypes;
-    }
 
-    void clearAllEvents() {
-      eventSequence.clear();
-    }
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int i = 0; i < 1024; i++) {
+          sink.write(new byte[8192]);
+          sink.flush();
+        }
+      }
+    };
 
-    @Override public void dnsStart(Call call, String domainName) {
-      eventSequence.offer(new DnsStart(call, domainName));
-    }
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
 
-    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList,
-        Throwable throwable) {
-      eventSequence.offer(new DnsEnd(call, domainName, inetAddressList, throwable));
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
     }
 
-    @Override public void secureConnectStart(Call call) {
-      eventSequence.offer(new SecureConnectStart(call));
-    }
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
 
-    @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-      eventSequence.offer(new SecureConnectEnd(call, handshake, throwable));
-    }
+  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessStreaming() throws IOException {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.get("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(new byte[8192]);
+        sink.flush();
+      }
+    };
+
+    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessEmpty() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
+        equalTo(19L));
+  }
+
+  @Test public void successfulCallEventSequenceWithListener() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder().addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(
+        HttpLoggingInterceptor.Level.BODY)).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
+      Matcher<Long> responseHeaderLength) throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build());
+    Response response = call.execute();
+    assertEquals("World!", response.body().string());
+
+    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
+        equalTo(6L));
+  }
+
+  private void enableTlsWithTunnel(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
+  }
+
+  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Ignore("CallEnd emitted twice")
+  @Test
+  public void redirectUsingNewConnectionEventSequence() throws IOException {
+    MockWebServer otherServer = new MockWebServer();
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: " + otherServer.url("/foo")));
+    otherServer.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
index 34e40b96f7..b0cb8a6d0f 100644
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
+import java.nio.charset.Charset;
 
 import static org.junit.Assert.assertEquals;
 
@@ -196,4 +197,17 @@ private String formEncode(int codePoint) throws IOException {
     buffer.skip(3); // Skip "a=b" prefix.
     return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
   }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "Nicolás")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 16ef3bef7d..494ac90b85 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -25,11 +26,17 @@
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -39,12 +46,12 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> headerBlock = headerEntries(
+    Headers headerBlock = Headers.of(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(":version", headers.name(0));
@@ -116,6 +123,25 @@
     }
   }
 
+  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
+    try {
+      Headers headers = new Headers.Builder()
+          .addUnsafeNonAscii("héader1", "value1")
+          .build();
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
+    Headers headers = new Headers.Builder()
+        .addUnsafeNonAscii("header1", "valué1")
+        .build();
+    assertEquals("header1: valué1\n", headers.toString());
+  }
+
   @Test public void ofThrowsOddNumberOfHeaders() {
     try {
       Headers.of("User-Agent", "OkHttp", "Content-Length");
@@ -155,7 +181,7 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofRejectsNulChar() {
+  @Test public void ofRejectsNullChar() {
     try {
       Headers.of("User-Agent", "Square\u0000OkHttp");
       fail();
@@ -173,7 +199,7 @@
 
   @Test public void ofMapThrowsOnEmptyName() {
     try {
-      Headers.of(Collections.singletonMap("", "OkHttp"));
+      Headers.of(singletonMap("", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -181,24 +207,24 @@
 
   @Test public void ofMapThrowsOnBlankName() {
     try {
-      Headers.of(Collections.singletonMap(" ", "OkHttp"));
+      Headers.of(singletonMap(" ", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
+    Headers headers = Headers.of(singletonMap("User-Agent", ""));
     assertEquals("", headers.value(0));
   }
 
   @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
+    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
     assertEquals("User-Agent", headers.name(0));
   }
 
   @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
+    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
     assertEquals("OkHttp", headers.value(0));
   }
 
@@ -211,17 +237,17 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofMapRejectsNulCharInName() {
+  @Test public void ofMapRejectsNullCharInName() {
     try {
-      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void ofMapRejectsNulCharInValue() {
+  @Test public void ofMapRejectsNullCharInValue() {
     try {
-      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -249,8 +275,8 @@
 
   @Test public void toMultimapAllowsCaseInsensitiveGet() {
     Headers headers = Headers.of(
-            "cache-control", "no-store",
-            "Cache-Control", "no-cache");
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache");
     Map<String, List<String>> headerMap = headers.toMultimap();
     assertEquals(2, headerMap.get("cache-control").size());
     assertEquals(2, headerMap.get("Cache-Control").size());
@@ -308,6 +334,46 @@
     }
   }
 
+  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of("héader1", "value1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of(singletonMap("héader1", "value1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of(singletonMap("header1", "valué1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
   @Test public void headersEquals() {
     Headers headers1 = new Headers.Builder()
         .add("Connection", "close")
@@ -342,9 +408,22 @@
     assertEquals("A: a\nB: bb\n", headers.toString());
   }
 
+  @Test public void headersAddAll() {
+    Headers sourceHeaders = new Headers.Builder()
+        .add("A", "aa")
+        .add("a", "aa")
+        .add("B", "bb")
+        .build();
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .addAll(sourceHeaders)
+        .add("C", "c")
+        .build();
+    assertEquals("A: a\nA: aa\na: aa\nB: bb\nC: c\n", headers.toString());
+  }
+
   /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallenges() {
-    // Strict RFC 2617 header.
+  @Test public void testDigestChallengeWithStrictRfc2617Header() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
@@ -353,85 +432,432 @@
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header #2.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
             + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Wrong header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithMissingRealm() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
             + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("underrealm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpaces() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
             + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
             + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithCamelCasedNames() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DiGeSt", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithCamelCasedNames2() {
     // Strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DIgEsT", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Unquoted.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+    assertEquals(singletonMap("realm", "myrealm"), challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithoutAuthParams() {
     // Scheme only.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    assertEquals(emptyMap(), challenges.get(0).authParams());
+  }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "UTF-8");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "US-ASCII");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void spacesAroundKeyValueSeparator() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void onlyCommaBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleSeparatorsBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unknownAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("foo", "bar");
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void escapedCharactersInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my\\\"realm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my, realm,"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
+  @Test public void doubleQuoteInToken() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68InsteadOfAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==")
+        .build();
+
+    assertEquals(singletonList(
+        new Challenge("Other", singletonMap(((String) null), "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68AndAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Other", singletonMap((String) null, "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void repeatedAuthParamKey() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
+        .build();
+
+    assertEquals(emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest")
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Digest")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleBasicAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Basic realm=myotherrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void byteCount() {
+    assertEquals(0L, new Headers.Builder().build().byteCount());
+    assertEquals(10L, new Headers.Builder()
+        .add("abc", "def")
+        .build()
+        .byteCount());
+    assertEquals(20L, new Headers.Builder()
+        .add("abc", "def")
+        .add("ghi", "jkl")
+        .build()
+        .byteCount());
+  }
+
+  @Test public void addDate() {
+    Date expected = new Date(0);
+    Headers headers = new Headers.Builder()
+        .add("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("testDate"));
+  }
+
+  @Test public void addDateNull() {
+    try {
+      new Headers.Builder()
+          .add("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
+  }
+
+  @Test public void setDate() {
+    Date expected = new Date(1000);
+    Headers headers = new Headers.Builder()
+        .add("testDate", new Date(0))
+        .set("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("testDate"));
+  }
+
+  @Test public void setDateNull() {
+    try {
+      new Headers.Builder()
+          .set("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 12aedc57a3..e780d8bd9b 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -15,109 +15,129 @@
  */
 package okhttp3;
 
-import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import okhttp3.UrlComponentEncodingTester.Component;
 import okhttp3.UrlComponentEncodingTester.Encoding;
 import org.junit.Ignore;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
+@RunWith(Parameterized.class)
 public final class HttpUrlTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+  
+  @Parameterized.Parameter
+  public boolean useGet;
+  
+  HttpUrl parse(String url) {
+    return useGet
+        ? HttpUrl.get(url)
+        : HttpUrl.parse(url);
+  }
+  
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = HttpUrl.parse("http://host/");
-    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
-    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
-    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
-    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+    HttpUrl expected = parse("http://host/");
+    assertEquals(expected, parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, parse(" http://host/ ")); // Both.
+    assertEquals(expected, parse("    http://host/    ")); // Both.
+    assertEquals(expected, parse("http://host/").resolve("   "));
+    assertEquals(expected, parse("http://host/").resolve("  .  "));
   }
 
   @Test public void parseHostAsciiNonPrintable() throws Exception {
     String host = "host\u0001";
-    assertNull(HttpUrl.parse("http://" + host + "/"));
+    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
+    // TODO make exception message escape non-printable characters
   }
 
   @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
     // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
-    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
-    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
-    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
-    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
-    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
-    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
-    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
-    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
-    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
-    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
-    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
-    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
-    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
-    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
-    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
-    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
-    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
-    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
-    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
-    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
-    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
-    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
-    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
-    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
-    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
-    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
-    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
-    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
-    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+    assertEquals("/%0B", parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", parse("http://h/\u3000").encodedPath()); // ideographic space
   }
 
   @Test public void scheme() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
-    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
-        new HttpUrl.Builder().parse(null, "image640://480.png"));
-    assertEquals(null, HttpUrl.parse("httpp://host/"));
-    assertEquals(null, HttpUrl.parse("0ttp://host/"));
-    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
-    assertEquals(null, HttpUrl.parse("httpss://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("Http://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("HTTP://host/"));
+    assertEquals(parse("https://host/"), parse("https://host/"));
+    assertEquals(parse("https://host/"), parse("HTTPS://host/"));
+
+    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
+    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
+    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
+    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
+    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
+    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
+    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
   }
 
   @Test public void parseNoScheme() throws Exception {
-    assertEquals(null, HttpUrl.parse("//host"));
-    assertEquals(null, HttpUrl.parse("/path"));
-    assertEquals(null, HttpUrl.parse("path"));
-    assertEquals(null, HttpUrl.parse("?query"));
-    assertEquals(null, HttpUrl.parse("#fragment"));
+    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
   }
 
   @Test public void newBuilderResolve() throws Exception {
     // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
-    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
-    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(parse("http://host/a/b"), base.newBuilder("").build());
     assertEquals(null, base.newBuilder("ftp://b"));
     assertEquals(null, base.newBuilder("ht+tp://b"));
     assertEquals(null, base.newBuilder("ht-tp://b"));
@@ -125,27 +145,27 @@
   }
 
   @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
     assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
     assertEquals("http://host/...", baseWithUsernameOnly.redact());
     assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(parse("http://host/path"), base.resolve("/path"));
+    assertEquals(parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(parse("http://host/a/b"), base.resolve(""));
+    assertEquals(parse("http://host/path"), base.resolve("\\path"));
   }
 
   @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
+    HttpUrl base = parse("http://a/");
     assertEquals(null, base.resolve("ftp://b"));
     assertEquals(null, base.resolve("ht+tp://b"));
     assertEquals(null, base.resolve("ht-tp://b"));
@@ -153,159 +173,159 @@
   }
 
   @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
-    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+    HttpUrl base = parse("http://a/");
+    assertEquals(parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
   @Test public void rfc3886NormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    HttpUrl url = parse("http://a/b/c/d;p?q");
     assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
-    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(parse("http://a/g"), url.resolve("/g"));
+    assertEquals(parse("http://g"), url.resolve("//g"));
+    assertEquals(parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(parse("http://a/b/"), url.resolve(".."));
+    assertEquals(parse("http://a/b/"), url.resolve("../"));
+    assertEquals(parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(parse("http://a/"), url.resolve("../.."));
+    assertEquals(parse("http://a/"), url.resolve("../../"));
+    assertEquals(parse("http://a/g"), url.resolve("../../g"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
   @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
-    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
-    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    assertEquals(parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
   }
 
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+    assertEquals(parse("http://host/path"), parse("http:host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http://host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:///host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http://\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("https://a/b/c");
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("https://a/b/c");
+    assertEquals(parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/b/c");
-    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("http://a/b/c");
+    assertEquals(parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void username() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
-    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+    assertEquals(parse("http://host/path"), parse("http://@host/path"));
+    assertEquals(parse("http://user@host/path"), parse("http://user@host/path"));
   }
 
   /** Given multiple '@' characters, the last one is the delimiter. */
   @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
     assertEquals("foo@bar", httpUrl.username());
     assertEquals("", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+    assertEquals(parse("http://foo%40bar@baz/path"), httpUrl);
   }
 
   /** Given multiple ':' characters, the first one is the delimiter. */
   @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
     assertEquals("foo", httpUrl.username());
     assertEquals("pass1@bar:pass2", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
+    assertEquals(parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
   }
 
   @Test public void usernameAndPassword() throws Exception {
-    assertEquals(HttpUrl.parse("http://username:password@host/path"),
-        HttpUrl.parse("http://username:password@host/path"));
-    assertEquals(HttpUrl.parse("http://username@host/path"),
-        HttpUrl.parse("http://username:@host/path"));
+    assertEquals(parse("http://username:password@host/path"),
+        parse("http://username:password@host/path"));
+    assertEquals(parse("http://username@host/path"),
+        parse("http://username:@host/path"));
   }
 
   @Test public void passwordWithEmptyUsername() throws Exception {
     // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
-    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+    assertEquals(parse("http://host/path"), parse("http://:@host/path"));
+    assertEquals("password%40", parse("http://:password@@host/path").encodedPassword());
   }
 
   @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
-    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
-    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+    assertEquals("/%00", parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", parse("http://host/\ufffd").encodedPath());
   }
 
   @Test public void usernameCharacters() throws Exception {
@@ -325,188 +345,220 @@
   }
 
   @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\n/"));
-    assertEquals(null, HttpUrl.parse("http:// /"));
-    assertEquals(null, HttpUrl.parse("http://%20/"));
+    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
+    assertInvalid("http:// /", "Invalid URL host: \" \"");
+    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
   }
 
   @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://σ").host());
+    assertEquals("abcd", parse("http://abcd").host());
+    assertEquals("xn--4xa", parse("http://σ").host());
   }
 
   @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://Σ").host());
+    assertEquals("abcd", parse("http://ABCD").host());
+    assertEquals("xn--4xa", parse("http://Σ").host());
   }
 
   @Test public void hostnameIgnoredCharacters() throws Exception {
     // The soft hyphen (­) should be ignored.
-    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+    assertEquals("abcd", parse("http://AB\u00adCD").host());
   }
 
   @Test public void hostnameMultipleCharacterMapping() throws Exception {
     // Map the single character telephone symbol (℡) to the string "tel".
-    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+    assertEquals("tel", parse("http://\u2121").host());
   }
 
   @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+    assertEquals("xn--pu5l", parse("http://\uD87E\uDE1D").host());
   }
 
   @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
   @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+    assertEquals("abcd", parse("http://ab\uDB40\uDDEFcd").host());
   }
 
   @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
   }
 
   @Test public void hostIpv6() throws Exception {
     // Square braces are absent from host()...
-    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+    assertEquals("::1", parse("http://[::1]/").host());
 
     // ... but they're included in toString().
-    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+    assertEquals("http://[::1]/", parse("http://[::1]/").toString());
 
     // IPv6 colons don't interfere with port numbers or passwords.
-    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
-    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
-    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+    assertEquals(8080, parse("http://[::1]:8080/").port());
+    assertEquals("password", parse("http://user:password@[::1]/").password());
+    assertEquals("::1", parse("http://user:password@[::1]:8080/").host());
 
     // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+    assertEquals("::1", parse("http://[%3A%3A%31]/").host());
 
     // Including the Square braces themselves! (This is what Chrome does.)
-    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+    assertEquals("::1", parse("http://%5B%3A%3A1%5D/").host());
   }
 
   @Test public void hostIpv6AddressDifferentFormats() throws Exception {
     // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
     String a3 = "2001:db8::1:0:0:1";
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:DB8:0:0:1::1]").host());
   }
 
   @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+    assertEquals("::1", parse("http://[::0001]").host());
+    assertEquals("::1", parse("http://[0000::0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
   }
 
   @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+    assertEquals("1::", parse("http://[0001:0000::]").host());
+    assertEquals("1::", parse("http://[0001::0000]").host());
+    assertEquals("1::", parse("http://[0001::]").host());
+    assertEquals("1::", parse("http://[1::]").host());
   }
 
   @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
   }
 
   @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:1]"));
-    assertEquals(null, HttpUrl.parse("http://[:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
+    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
+    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
+    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
+    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
+    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
+    assertInvalid("http://[::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
   }
 
   @Test public void hostIpv6ScopedAddress() throws Exception {
     // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
+        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
   }
 
   @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
-    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+    assertEquals("::1:ffff:ffff", parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
     // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
     // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
   }
 
   @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
+    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
+        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
+    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
   }
 
   @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
     // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
   }
 
   @Test public void hostIpv6CanonicalForm() throws Exception {
     assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
-        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
-    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
-    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
-    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
-    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
-    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
-    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
-    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
-    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
-    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
-    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
-    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+        parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", parse("http://[2001:0:0:1:0:0:0:1]/").host());
+    assertEquals("1::", parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
   /** The builder permits square braces but does not require them. */
   @Test public void hostIPv6Builder() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://example.com/");
+    HttpUrl base = parse("http://example.com/");
     assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
@@ -514,26 +566,26 @@
   }
 
   @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
-    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
-    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+    assertEquals("255.255.255.255", parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", parse("http://0.0.0.0/").host());
   }
 
   @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
   @Test public void hostWithTrailingDot() throws Exception {
-    assertEquals("host.", HttpUrl.parse("http://host./").host());
+    assertEquals("host.", parse("http://host./").host());
   }
 
   @Test public void port() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
-    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
-    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
-    assertEquals(null, HttpUrl.parse("http://host:0/"));
-    assertEquals(null, HttpUrl.parse("http://host:65536/"));
-    assertEquals(null, HttpUrl.parse("http://host:-1/"));
-    assertEquals(null, HttpUrl.parse("http://host:a/"));
-    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+    assertEquals(parse("http://host/"), parse("http://host:80/"));
+    assertEquals(parse("http://host:99/"), parse("http://host:99/"));
+    assertEquals(parse("http://host/"), parse("http://host:/"));
+    assertEquals(65535, parse("http://host:65535/").port());
+    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
+    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
+    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
+    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
+    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
   }
 
   @Test public void pathCharacters() throws Exception {
@@ -553,6 +605,15 @@
         .test(Component.QUERY);
   }
 
+  @Test public void queryValueCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY_VALUE);
+  }
+
   @Test public void fragmentCharacters() throws Exception {
     new UrlComponentEncodingTester()
         .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
@@ -562,7 +623,7 @@
   }
 
   @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#Σ");
+    HttpUrl url = parse("http://host/#Σ");
     assertEquals("http://host/#Σ", url.toString());
     assertEquals("Σ", url.fragment());
     assertEquals("Σ", url.encodedFragment());
@@ -570,7 +631,7 @@
   }
 
   @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    HttpUrl url = parse("http://host/#\u0080");
     assertEquals("http://host/#\u0080", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("\u0080", url.encodedFragment());
@@ -578,7 +639,7 @@
   }
 
   @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    HttpUrl url = parse("http://host/#%C2%80");
     assertEquals("http://host/#%C2%80", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("%C2%80", url.encodedFragment());
@@ -586,7 +647,7 @@
   }
 
   @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    HttpUrl url = parse("http://host/#%80");
     assertEquals("http://host/#%80", url.toString());
     assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
     assertEquals("%80", url.encodedFragment());
@@ -594,106 +655,106 @@
   }
 
   @Test public void relativePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
-    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
-    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(parse("http://host/a/"), base.resolve(".."));
+    assertEquals(parse("http://host/"), base.resolve("../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2e"));
   }
 
   @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
-    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+    HttpUrl base = parse("http://host/a/b/c/");
+    assertEquals(parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../../../a/b/.."));
   }
 
   @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(parse("http://host/"), base.resolve("..\\.."));
   }
 
   @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
   }
 
   @Test public void decodeUsername() {
-    assertEquals("user", HttpUrl.parse("http://user@host/").username());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+    assertEquals("user", parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", parse("http://%F0%9F%8D%A9@host/").username());
   }
 
   @Test public void decodePassword() {
-    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
-    assertEquals("", HttpUrl.parse("http://user:@host/").password());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+    assertEquals("password", parse("http://user:password@host/").password());
+    assertEquals("", parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", parse("http://user:%F0%9F%8D%A9@host/").password());
   }
 
   @Test public void decodeSlashCharacterInDecodedPathSegment() {
     assertEquals(Arrays.asList("a/b/c"),
-        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+        parse("http://host/a%2Fb%2Fc").pathSegments());
   }
 
   @Test public void decodeEmptyPathSegments() {
     assertEquals(Arrays.asList(""),
-        HttpUrl.parse("http://host/").pathSegments());
+        parse("http://host/").pathSegments());
   }
 
   @Test public void percentDecode() throws Exception {
     assertEquals(Arrays.asList("\u0000"),
-        HttpUrl.parse("http://host/%00").pathSegments());
+        parse("http://host/%00").pathSegments());
     assertEquals(Arrays.asList("a", "\u2603", "c"),
-        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+        parse("http://host/a/%E2%98%83/c").pathSegments());
     assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
-        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+        parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
     assertEquals(Arrays.asList("a", "b", "c"),
-        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+        parse("http://host/a/%62/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+        parse("http://host/a/%7A/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+        parse("http://host/a/%7a/c").pathSegments());
   }
 
   @Test public void malformedPercentEncoding() {
     assertEquals(Arrays.asList("a%f", "b"),
-        HttpUrl.parse("http://host/a%f/b").pathSegments());
+        parse("http://host/a%f/b").pathSegments());
     assertEquals(Arrays.asList("%", "b"),
-        HttpUrl.parse("http://host/%/b").pathSegments());
+        parse("http://host/%/b").pathSegments());
     assertEquals(Arrays.asList("%"),
-        HttpUrl.parse("http://host/%").pathSegments());
+        parse("http://host/%").pathSegments());
     assertEquals(Arrays.asList("%00"),
-        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
+        parse("http://github.com/%%30%30").pathSegments());
   }
 
   @Test public void malformedUtf8Encoding() {
     // Replace a partial UTF-8 sequence with the Unicode replacement character.
     assertEquals(Arrays.asList("a", "\ufffdx", "c"),
-        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+        parse("http://host/a/%E2%98x/c").pathSegments());
   }
 
   @Test public void incompleteUrlComposition() throws Exception {
@@ -711,6 +772,19 @@
     }
   }
 
+  @Test public void builderToString() {
+    assertEquals("https://host.com/path", parse("https://host.com/path").newBuilder().toString());
+  }
+
+  @Test public void incompleteBuilderToString() {
+    assertEquals("https:///path",
+        new HttpUrl.Builder().scheme("https").encodedPath("/path").toString());
+    assertEquals("//host.com/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").toString());
+    assertEquals("//host.com:8080/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString());
+  }
+
   @Test public void minimalUrlComposition() throws Exception {
     HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
     assertEquals("http://host/", url.toString());
@@ -747,17 +821,17 @@
   }
 
   @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertEquals(443, HttpUrl.parse("http://example.com")
+    assertEquals(443, parse("http://example.com")
         .newBuilder()
         .scheme("https")
         .build().port());
 
-    assertEquals(80, HttpUrl.parse("https://example.com")
+    assertEquals(80, parse("https://example.com")
         .newBuilder()
         .scheme("http")
         .build().port());
 
-    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+    assertEquals(1234, parse("https://example.com:1234")
         .newBuilder()
         .scheme("http")
         .build().port());
@@ -860,7 +934,7 @@
   }
 
   @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
     assertEquals("/a/b/c/d",
         base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
@@ -872,12 +946,12 @@
   }
 
   @Test public void pathSize() throws Exception {
-    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
-    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+    assertEquals(1, parse("http://host/").pathSize());
+    assertEquals(3, parse("http://host/a/b/c").pathSize());
   }
 
   @Test public void addPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
 
     // Add a string with zero slashes: resulting URL gains one slash.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -897,7 +971,7 @@
   }
 
   @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    HttpUrl base = parse("http://host/a/b/c/");
 
     // Add a string with zero slashes: resulting URL gains zero slashes.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -917,30 +991,30 @@
   }
 
   @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
     assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
   }
 
   @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c//d/e///f",
         base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/d/e/%20/",
         base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
   }
 
   @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/%252e",
         base.newBuilder().addPathSegment("%2e").build().encodedPath());
     assertEquals("/a/b/c/%252e%252e",
@@ -948,47 +1022,47 @@
   }
 
   @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
   }
 
   @Test public void setPathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
     assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
     assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
   }
 
   @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
     assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
     assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
   }
 
   @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
     assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
   }
 
   @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, ".");
       fail();
@@ -997,7 +1071,7 @@
   }
 
   @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, "..");
       fail();
@@ -1006,7 +1080,7 @@
   }
 
   @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1020,13 +1094,13 @@
   }
 
   @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%25/b/c",
         base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
   }
 
   @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".");
       fail();
@@ -1035,7 +1109,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".\n");
       fail();
@@ -1044,7 +1118,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..");
       fail();
@@ -1053,7 +1127,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..\n");
       fail();
@@ -1062,7 +1136,7 @@
   }
 
   @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1076,7 +1150,7 @@
   }
 
   @Test public void removePathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .build();
@@ -1084,7 +1158,7 @@
   }
 
   @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .removePathSegment(0)
@@ -1103,19 +1177,19 @@
   }
 
   @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URL javaNetUrl = httpUrl.url();
     assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
   }
 
   @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URI uri = httpUrl.uri();
     assertEquals("http://username:password@host/path?query#fragment", uri.toString());
   }
 
   @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
     URI uri = httpUrl.uri();
     assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
   }
@@ -1168,8 +1242,11 @@
         .host("host")
         .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
         .build();
-    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
-    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.uri().toString());
+    assertEquals("a", url.queryParameter("=[]:;\"~|?#@^/$%*"));
   }
 
   @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
@@ -1178,8 +1255,11 @@
         .host("host")
         .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
         .build();
-    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
-    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.uri().toString());
+    assertEquals("=[]:;\"~|?#@^/$%*", url.queryParameter("a"));
   }
 
   @Test public void toUriQueryValueSpecialCharacters() throws Exception {
@@ -1192,6 +1272,42 @@
     assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
   }
 
+  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
+   * We retain the encoded (or non-encoded) state of the input.
+   */
+  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
+   * into a canonical form because doing so could be semantically different.
+   */
+  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
+    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~", url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
   @Test public void toUriFragmentSpecialCharacters() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1204,44 +1320,44 @@
 
   @Test public void toUriWithControlCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
-    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
-    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    assertEquals(new URI("http://host/a%00b"), parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), parse("http://host/a\u009fb").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
-    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
-    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    assertEquals(new URI("http://host/?a%00b"), parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), parse("http://host/?a\u009fb").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+    assertEquals(new URI("http://host/#a%00b"), parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u009fb").uri());
   }
 
   @Test public void toUriWithSpaceCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
-    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
-    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
-    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    assertEquals(new URI("http://host/a%0Bb"), parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), parse("http://host/a\u3000b").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
-    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
-    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
-    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    assertEquals(new URI("http://host/?a%0Bb"), parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), parse("http://host/?a\u3000b").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
-    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+    assertEquals(new URI("http://host/#a%0Bb"), parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u3000b").uri());
   }
 
   @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+    assertEquals(new URI("http://host/%25xx"), parse("http://host/%xx").uri());
   }
 
   @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
-    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
+    assertEquals(new URI("http://host/%25a"), parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), parse("http://host/%").uri());
   }
 
   @Test public void fromJavaNetUrl() throws Exception {
@@ -1271,29 +1387,8 @@
     assertEquals(null, HttpUrl.get(uri));
   }
 
-  @Test public void fromJavaNetUrl_checked() throws Exception {
-    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("mailto:user@example.com");
-      fail();
-    } catch (MalformedURLException e) {
-    }
-  }
-
-  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("http://hostw ithspace/");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
   @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
     assertEquals("c+=& d", url.queryParameterValue(0));
@@ -1307,14 +1402,14 @@
   }
 
   @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
     assertEquals("c =& d", url.queryParameter("a =& b"));
   }
 
   @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .removeAllQueryParameters("a+=& b")
         .build();
@@ -1323,7 +1418,7 @@
   }
 
   @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .removeAllEncodedQueryParameters("a+=& b")
         .build();
@@ -1332,7 +1427,7 @@
   }
 
   @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .setQueryParameter("a+=& b", "ef")
         .build();
@@ -1341,7 +1436,7 @@
   }
 
   @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .setEncodedQueryParameter("a+=& b", "ef")
         .build();
@@ -1350,7 +1445,7 @@
   }
 
   @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .addQueryParameter("a+=& b", "e+=& f")
         .build();
@@ -1362,14 +1457,14 @@
   }
 
   @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query(null)
         .build();
     assertEquals(0, url.querySize());
   }
 
   @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .build();
     assertEquals(1, url.querySize());
@@ -1378,7 +1473,7 @@
   }
 
   @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("&")
         .build();
     assertEquals(2, url.querySize());
@@ -1389,7 +1484,7 @@
   }
 
   @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .removeAllQueryParameters("a")
         .build();
@@ -1397,7 +1492,7 @@
   }
 
   @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    HttpUrl url = parse("http://host/?foo&bar&baz");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1410,7 +1505,7 @@
   }
 
   @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1423,7 +1518,7 @@
   }
 
   @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
     assertEquals(3, url.querySize());
     assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
     assertEquals("1", url.queryParameterValue(0));
@@ -1433,13 +1528,20 @@
   }
 
   @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    HttpUrl url = parse("http://host/?%6d=m&+=%20");
     assertEquals("m", url.queryParameterName(0));
     assertEquals(" ", url.queryParameterName(1));
     assertEquals("m", url.queryParameter("m"));
     assertEquals(" ", url.queryParameter(" "));
   }
 
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = parse("http://host/?#fragment");
+    assertEquals("fragment", url.fragment());
+    assertEquals("", url.query());
+    assertEquals("", url.encodedQuery());
+  }
+
   @Test public void roundTripBuilder() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1461,7 +1563,7 @@
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = parse(urlString);
     assertEquals("%6d%6D", url.encodedUsername());
     assertEquals("%6d%6D", url.encodedPassword());
     assertEquals("/%6d%6D", url.encodedPath());
@@ -1474,7 +1576,7 @@
   }
 
   @Test public void clearFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .fragment(null)
         .build();
@@ -1484,7 +1586,7 @@
   }
 
   @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .encodedFragment(null)
         .build();
@@ -1494,17 +1596,30 @@
   }
 
   @Test public void topPrivateDomain() {
-    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
-    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://栃.栃木.jp").topPrivateDomain());
+    assertEquals("google.com", parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", parse("https://栃.栃木.jp").topPrivateDomain());
     assertEquals("xn--ewv.xn--4pvxs.jp",
-        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
-
-    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://栃木.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
+        parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(parse("https://co.uk").topPrivateDomain());
+    assertNull(parse("https://square").topPrivateDomain());
+    assertNull(parse("https://栃木.jp").topPrivateDomain());
+    assertNull(parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(parse("https://localhost").topPrivateDomain());
+    assertNull(parse("https://127.0.0.1").topPrivateDomain());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 7a4fc33630..a1ad679f34 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
@@ -23,6 +24,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -40,9 +42,11 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
@@ -63,7 +67,7 @@
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
         .build();
 
     client = client.newBuilder()
@@ -87,7 +91,7 @@
             .protocol(Protocol.HTTP_1_1)
             .code(200)
             .message("Intercepted!")
-            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+            .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
             .build();
       }
     };
@@ -144,7 +148,7 @@
         String sameHost = address.url().host();
         int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
-            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
+            .url("http://" + sameHost + ":" + differentPort + "/")
             .build());
       }
     };
@@ -230,7 +234,7 @@
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
-        MediaType mediaType = MediaType.parse("text/plain");
+        MediaType mediaType = MediaType.get("text/plain");
         RequestBody body = RequestBody.create(mediaType, "abc");
         return chain.proceed(originalRequest.newBuilder()
             .method("POST", body)
@@ -279,7 +283,7 @@ private void rewriteRequestToServer(boolean network) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     client.newCall(request).execute();
@@ -703,6 +707,162 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     }
   }
 
+  @Test public void connectTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.connectTimeoutMillis());
+
+        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.connectTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.connectTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithReadTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.readTimeoutMillis());
+
+        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.readTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.readTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .readTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request1);
+    Response response = call.execute();
+    ResponseBody body = response.body();
+    try {
+      body.string();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithWriteTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.writeTimeoutMillis());
+
+        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.writeTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.writeTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.get("text/plain"), data))
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute(); // we want this call to throw a SocketTimeoutException
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainCanCancelCall() throws Exception {
+    final AtomicReference<Call> callRef = new AtomicReference<>();
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Call call = chain.call();
+        callRef.set(call);
+
+        assertFalse(call.isCanceled());
+        call.cancel();
+        assertTrue(call.isCanceled());
+
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertSame(call, callRef.get());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -784,7 +944,7 @@ public ExceptionCatchingExecutor() {
       });
     }
 
-    public Exception takeException() throws InterruptedException {
+    public Exception takeException() throws Exception {
       return exceptions.take();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index b2d3f396fa..f0b194713d 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,12 +17,17 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
+import java.util.Arrays;
+import java.util.Collection;
 import okhttp3.internal.Util;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -30,16 +35,34 @@
  * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
  * MediaTypeTest.
  */
+@RunWith(Parameterized.class)
 public class MediaTypeTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  private MediaType parse(String string) {
+    return useGet
+        ? MediaType.get(string)
+        : MediaType.parse(string);
+  }
+
   @Test public void testParse() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
+    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
     assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
+    assertTrue(mediaType.equals(parse("text/plain;boundary=foo;charset=utf-8")));
     assertEquals(mediaType.hashCode(),
-        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
+        parse("text/plain;boundary=foo;charset=utf-8").hashCode());
   }
 
   @Test public void testValidParse() throws Exception {
@@ -61,75 +84,86 @@
   }
 
   @Test public void testInvalidParse() throws Exception {
-    assertInvalid("");
-    assertInvalid("/");
-    assertInvalid("/");
-    assertInvalid("text");
-    assertInvalid("text/");
-    assertInvalid("te<t/plain");
-    assertInvalid("text/pl@in");
-    assertInvalid("text/plain; a");
-    assertInvalid("text/plain; a=");
-    assertInvalid("text/plain; a=@");
-    assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1; b");
-    assertInvalid("text/plain; a=1; b=");
-    assertInvalid("text/plain; a=\u2025");
-    assertInvalid(" text/plain");
-    assertInvalid("te xt/plain");
-    assertInvalid("text /plain");
-    assertInvalid("text/ plain");
-    assertInvalid("text/pl ain");
-    assertInvalid("text/plain ");
-    assertInvalid("text/plain ; a=1");
+    assertInvalid("", "No subtype found for: \"\"");
+    assertInvalid("/", "No subtype found for: \"/\"");
+    assertInvalid("text", "No subtype found for: \"text\"");
+    assertInvalid("text/", "No subtype found for: \"text/\"");
+    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
+    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
+    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
+    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
+    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
+
+    assertInvalid("text/pl@in",
+        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
+    assertInvalid("text/plain; a",
+        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
+    assertInvalid("text/plain; a=",
+        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
+    assertInvalid("text/plain; a=@",
+        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
+    assertInvalid("text/plain; a=\"@",
+        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
+    assertInvalid("text/plain; a=1; b",
+        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
+    assertInvalid("text/plain; a=1; b=",
+        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
+    assertInvalid("text/plain; a=\u2025",
+        "Parameter is not formatted correctly: \"a=‥\" for: \"text/plain; a=‥\"");
+    assertInvalid("text/pl ain",
+        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
+    assertInvalid("text/plain ",
+        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
+    assertInvalid("text/plain ; a=1",
+        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
   }
 
   @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
+    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
     assertEquals("!#$%&'*+-.{|}~", mediaType.type());
     assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
   }
 
   @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
+    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = MediaType.parse(
+    MediaType mediaType = parse(
         "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testMultipleCharsets() {
-    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
+    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
+        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
   }
 
   @Test public void testIllegalCharsetName() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
+    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
+    MediaType mediaType = parse("text/plain; charset=utf-wtf");
     assertNull(mediaType.charset());
   }
 
@@ -138,32 +172,32 @@
    * unpleasant IllegalCharsetNameException.
    */
   @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    MediaType mediaType = parse("text/plain;charset='utf-8'");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
+    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
+    MediaType mediaType = parse("text/plain;charset=\"'\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = MediaType.parse("text/plain");
+    MediaType noCharset = parse("text/plain");
     assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
     assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
 
-    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
+    MediaType charset = parse("text/plain; charset=iso-8859-1");
     assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
   @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;");
+    MediaType mediaType = parse("text/plain;");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertNull(mediaType.charset());
@@ -171,11 +205,19 @@
   }
 
   private void assertMediaType(String string) {
-    MediaType mediaType = MediaType.parse(string);
-    assertEquals(string, mediaType.toString());
-  }
-
-  private void assertInvalid(String string) {
-    assertNull(string, MediaType.parse(string));
+    assertEquals(string, parse(string).toString());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index 35d2f67906..f936d56a80 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -129,13 +129,13 @@
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
-                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
                 .addPart(
                     Headers.of(
                         "Content-Disposition", "file; filename=\"file2.gif\"",
                         "Content-Transfer-Encoding", "binary"),
                     RequestBody.create(
-                        MediaType.parse("image/gif"),
+                        MediaType.get("image/gif"),
                         "... contents of file2.gif ...".getBytes(UTF_8)))
                 .build())
         .build();
@@ -171,7 +171,7 @@
         + "\r\n"
         + "%22\r\n"
         + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
         + "Content-Length: 5\r\n"
         + "\r\n"
         + "Alpha\r\n"
@@ -180,10 +180,10 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u0391", "Alpha")
+        .addFormDataPart("field with \u007e", "Alpha")
         .build();
 
     Buffer buffer = new Buffer();
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 5c13119e46..f84b557b56 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -22,7 +22,11 @@
 import java.net.ResponseCache;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
@@ -35,8 +39,14 @@
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private final MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    server.start();
+  }
 
   @After public void tearDown() throws Exception {
+    server.shutdown();
     ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
     CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
@@ -44,6 +54,7 @@
 
   @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
+    assertEquals(0, client.callTimeoutMillis());
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
@@ -52,6 +63,10 @@
 
   @Test public void timeoutValidRange() {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.callTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
@@ -64,6 +79,10 @@
       builder.readTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
+    try {
+      builder.callTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
@@ -127,4 +146,98 @@
     OkHttpClient clientB = TestUtil.defaultClient();
     assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
   }
+
+  @Test public void nullInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addNetworkInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.interceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.networkInterceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null network interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+    assertEquals(1, okHttpClient.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
+  }
+
+  @Test public void nullDefaultProxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector.setDefault(null);
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.socketFactory(SSLSocketFactory.getDefault());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
new file mode 100644
index 0000000000..78b408093d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ProtocolTest {
+  @Test
+  public void testGetKnown() throws IOException {
+    assertEquals(Protocol.HTTP_1_0, Protocol.get("http/1.0"));
+    assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
+    assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
+    assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.get("h2_prior_knowledge"));
+    assertEquals(Protocol.QUIC, Protocol.get("quic"));
+  }
+
+  @Test(expected = IOException.class)
+  public void testGetUnknown() throws IOException {
+    Protocol.get("tcp");
+  }
+
+  @Test
+  public void testToString() throws IOException {
+    assertEquals("http/1.0", Protocol.HTTP_1_0.toString());
+    assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
+    assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
+    assertEquals("h2", Protocol.HTTP_2.toString());
+    assertEquals("h2_prior_knowledge", Protocol.H2_PRIOR_KNOWLEDGE.toString());
+    assertEquals("quic", Protocol.QUIC.toString());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index af750fadc3..d34380cc4f 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -157,7 +157,7 @@ public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
   }
 
   public RecordedResponse assertFailure(String... messages) {
-    assertNotNull(failure);
+    assertNotNull("No failure found", failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
     return this;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
new file mode 100644
index 0000000000..6799300cdf
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+
+  final List<Object> forbiddenLocks = new ArrayList<>();
+
+  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
+  public void forbidLock(Object lock) {
+    forbiddenLocks.add(lock);
+  }
+
+  /**
+   * Removes recorded events up to (and including) an event is found whose class equals
+   * {@code eventClass} and returns it.
+   */
+  public <T> T removeUpToEvent(Class<T> eventClass) {
+    Object event = eventSequence.poll();
+    while (event != null && !eventClass.isInstance(event)) {
+      event = eventSequence.poll();
+    }
+    if (event == null) throw new AssertionError();
+    return eventClass.cast(event);
+  }
+
+  public List<String> recordedEventTypes() {
+    List<String> eventTypes = new ArrayList<>();
+    for (CallEvent event : eventSequence) {
+      eventTypes.add(event.getName());
+    }
+    return eventTypes;
+  }
+
+  public void clearAllEvents() {
+    eventSequence.clear();
+  }
+
+  private void logEvent(CallEvent e) {
+    for (Object lock : forbiddenLocks) {
+      assertFalse(lock.toString(), Thread.holdsLock(lock));
+    }
+
+    CallEvent startEvent = e.closes();
+
+    if (startEvent != null) {
+      assertTrue(e.getName() + " without matching " + startEvent.getName(),
+          eventSequence.contains(startEvent));
+    }
+
+    eventSequence.offer(e);
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    logEvent(new DnsStart(call, domainName));
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList));
+  }
+
+  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+      Proxy proxy) {
+    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
+  }
+
+  @Override public void secureConnectStart(Call call) {
+    logEvent(new SecureConnectStart(call));
+  }
+
+  @Override public void secureConnectEnd(Call call, Handshake handshake) {
+    logEvent(new SecureConnectEnd(call, handshake));
+  }
+
+  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, Protocol protocol) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
+  }
+
+  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol, IOException ioe) {
+    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
+  }
+
+  @Override public void connectionAcquired(Call call, Connection connection) {
+    logEvent(new ConnectionAcquired(call, connection));
+  }
+
+  @Override public void connectionReleased(Call call, Connection connection) {
+    logEvent(new ConnectionReleased(call, connection));
+  }
+
+  @Override public void callStart(Call call) {
+    logEvent(new CallStart(call));
+  }
+
+  @Override public void requestHeadersStart(Call call) {
+    logEvent(new RequestHeadersStart(call));
+  }
+
+  @Override public void requestHeadersEnd(Call call, Request request) {
+    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+  }
+
+  @Override public void requestBodyStart(Call call) {
+    logEvent(new RequestBodyStart(call));
+  }
+
+  @Override public void requestBodyEnd(Call call, long byteCount) {
+    logEvent(new RequestBodyEnd(call, byteCount));
+  }
+
+  @Override public void responseHeadersStart(Call call) {
+    logEvent(new ResponseHeadersStart(call));
+  }
+
+  @Override public void responseHeadersEnd(Call call, Response response) {
+    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+  }
+
+  @Override public void responseBodyStart(Call call) {
+    logEvent(new ResponseBodyStart(call));
+  }
+
+  @Override public void responseBodyEnd(Call call, long byteCount) {
+    logEvent(new ResponseBodyEnd(call, byteCount));
+  }
+
+  @Override public void callEnd(Call call) {
+    logEvent(new CallEnd(call));
+  }
+
+  @Override public void callFailed(Call call, IOException ioe) {
+    logEvent(new CallFailed(call, ioe));
+  }
+
+  static class CallEvent {
+    final Call call;
+    final List<Object> params;
+
+    CallEvent(Call call, Object... params) {
+      this.call = call;
+      this.params = Arrays.asList(params);
+    }
+
+    public String getName() {
+      return getClass().getSimpleName();
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof CallEvent)) return false;
+
+      CallEvent callEvent = (CallEvent) o;
+
+      if (!getName().equals(callEvent.getName())) return false;
+      if (!call.equals(callEvent.call)) return false;
+      return params.equals(callEvent.params);
+    }
+
+    @Override public int hashCode() {
+      int result = call.hashCode();
+      result = 31 * result + getName().hashCode();
+      result = 31 * result + params.hashCode();
+      return result;
+    }
+
+    public @Nullable CallEvent closes() {
+      return null;
+    }
+  }
+
+  static final class DnsStart extends CallEvent {
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      super(call, domainName);
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd extends CallEvent {
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      super(call, domainName, inetAddressList);
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new DnsStart(call, domainName);
+    }
+  }
+
+  static final class ConnectStart extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Proxy proxy;
+
+    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      super(call, inetSocketAddress, proxy);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+    }
+  }
+
+  static final class ConnectEnd extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+
+    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      super(call, inetSocketAddress, proxy, protocol);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+    }
+
+    @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class ConnectFailed extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+    final IOException ioe;
+
+    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
+        IOException ioe) {
+      super(call, inetSocketAddress, proxy, protocol, ioe);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+      this.ioe = ioe;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class SecureConnectStart extends CallEvent {
+    SecureConnectStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class SecureConnectEnd extends CallEvent {
+    final Handshake handshake;
+
+    SecureConnectEnd(Call call, Handshake handshake) {
+      super(call, handshake);
+      this.handshake = handshake;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new SecureConnectStart(call);
+    }
+  }
+
+  static final class ConnectionAcquired extends CallEvent {
+    final Connection connection;
+
+    ConnectionAcquired(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased extends CallEvent {
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectionAcquired(call, connection);
+    }
+  }
+
+  static final class CallStart extends CallEvent {
+    CallStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class CallEnd extends CallEvent {
+    CallEnd(Call call) {
+      super(call);
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new CallStart(call);
+    }
+  }
+
+  static final class CallFailed extends CallEvent {
+    final IOException ioe;
+
+    CallFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
+  static final class RequestHeadersStart extends CallEvent {
+    RequestHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    RequestHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class RequestBodyStart extends CallEvent {
+    RequestBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestBodyEnd extends CallEvent {
+    final long bytesWritten;
+
+    RequestBodyEnd(Call call, long bytesWritten) {
+      super(call, bytesWritten);
+      this.bytesWritten = bytesWritten;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestBodyStart(call);
+    }
+  }
+
+  static final class ResponseHeadersStart extends CallEvent {
+    ResponseHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    ResponseHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class ResponseBodyStart extends CallEvent {
+    ResponseBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseBodyEnd extends CallEvent {
+    final long bytesRead;
+
+    ResponseBodyEnd(Call call, long bytesRead) {
+      super(call, bytesRead);
+      this.bytesRead = bytesRead;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ResponseBodyStart(call);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
new file mode 100644
index 0000000000..45a13c4786
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+public final class RecordingWebSocketListener extends WebSocketListener {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    // TODO
+  }
+
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    // TODO
+  }
+
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    // TODO
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    // TODO
+  }
+
+  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
+    // TODO
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
+    // TODO
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 5c205d7031..50b7bcb53d 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -21,17 +21,19 @@
 import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.UUID;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -40,15 +42,15 @@
   }
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
+    assertEquals(MediaType.get("text/plain; charset=utf-8"), body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("e0a080", bodyToHex(body));
   }
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
     RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(contentType, body.contentType());
     assertEquals(2, body.contentLength());
@@ -56,7 +58,7 @@
   }
 
   @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -65,7 +67,7 @@
   }
 
   @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -79,7 +81,7 @@
     writer.write("abc");
     writer.close();
 
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, file);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -89,7 +91,7 @@
 
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
   @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.parse("application/json");
+    MediaType contentType = MediaType.get("application/json");
     RequestBody body = RequestBody.create(contentType, "{}");
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
@@ -120,24 +122,24 @@
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
     assertEquals(new URI("http://localhost/api"), request.url().uri());
-    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
+    assertEquals(HttpUrl.get("http://localhost/api"), request.url());
   }
 
-  @Test public void newBuilderUrlResetsUrl() throws Exception {
+  @Test public void newBuilderUrlResetsUrl() {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
     Request builtRequestWithoutCache =
         requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
     Request builtRequestWithCache = requestWithCache.newBuilder().url(
         "http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithCache.url());
   }
 
-  @Test public void cacheControl() throws Exception {
+  @Test public void cacheControl() {
     Request request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noCache().build())
         .url("https://square.com")
@@ -145,7 +147,7 @@
     assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
   }
 
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
     Request request = new Request.Builder()
         .header("Cache-Control", "foo")
         .cacheControl(new CacheControl.Builder().build())
@@ -154,13 +156,13 @@
     assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
   }
 
-  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+  @Test public void headerAcceptsPermittedCharacters() {
     Request.Builder builder = new Request.Builder();
     builder.header("AZab09~", "AZab09 ~");
     builder.addHeader("AZab09~", "AZab09 ~");
   }
 
-  @Test public void emptyNameForbidden() throws Exception {
+  @Test public void emptyNameForbidden() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header("", "Value");
@@ -174,7 +176,7 @@
     }
   }
 
-  @Test public void headerForbidsNullArguments() throws Exception {
+  @Test public void headerForbidsNullArguments() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header(null, "Value");
@@ -198,7 +200,7 @@
     }
   }
 
-  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+  @Test public void headerAllowsTabOnlyInValues() {
     Request.Builder builder = new Request.Builder();
     builder.header("key", "sample\tvalue");
     try {
@@ -208,7 +210,7 @@
     }
   }
 
-  @Test public void headerForbidsControlCharacters() throws Exception {
+  @Test public void headerForbidsControlCharacters() {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
@@ -242,6 +244,111 @@ private void assertForbiddenHeader(String s) {
     }
   }
 
+  @Test public void noTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void defaultTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void nullRemovesTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag("a")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void removeAbsentTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void objectTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void typedTag() {
+    UUID uuidTag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag)
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void replaceOnlyTag() {
+    UUID uuidTag1 = UUID.randomUUID();
+    UUID uuidTag2 = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag1)
+        .tag(UUID.class, uuidTag2)
+        .build();
+    assertSame(uuidTag2, request.tag(UUID.class));
+  }
+
+  @Test public void multipleTags() {
+    UUID uuidTag = UUID.randomUUID();
+    String stringTag = "dilophosaurus";
+    Long longTag = 20170815L;
+    Object objectTag = new Object();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, objectTag)
+        .tag(UUID.class, uuidTag)
+        .tag(String.class, stringTag)
+        .tag(Long.class, longTag)
+        .build();
+    assertSame(objectTag, request.tag());
+    assertSame(objectTag, request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertSame(stringTag, request.tag(String.class));
+    assertSame(longTag, request.tag(Long.class));
+  }
+
+  /** Confirm that we don't accidentally share the backing map between objects. */
+  @Test public void tagsAreImmutable() {
+    Request.Builder builder = new Request.Builder()
+        .url("https://square.com");
+    Request requestA = builder.tag(String.class, "a").build();
+    Request requestB = builder.tag(String.class, "b").build();
+    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
+    assertSame("a", requestA.tag(String.class));
+    assertSame("b", requestB.tag(String.class));
+    assertSame("c", requestC.tag(String.class));
+  }
+
   private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
index 47feecacb6..40f994c526 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -396,8 +396,8 @@ static ResponseBody body(String hex) {
   }
 
   static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
   }
 
   static String exhaust(Reader reader) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index 69ce1fab8c..d56241ac91 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -23,6 +23,9 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -41,7 +44,7 @@
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
  */
 public final class SocksProxy {
-  public final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
 
   private static final int VERSION_5 = 5;
   private static final int METHOD_NONE = 0xff;
@@ -58,6 +61,8 @@
 
   private ServerSocket serverSocket;
   private AtomicInteger connectionCount = new AtomicInteger();
+  private final Set<Socket> openSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
@@ -73,6 +78,10 @@ public void play() throws IOException {
           logger.info(name + " done accepting connections: " + e.getMessage());
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed unexpectedly", e);
+        } finally {
+          for (Socket socket : openSockets) {
+            Util.closeQuietly(socket);
+          }
         }
       }
     });
@@ -103,6 +112,7 @@ private void service(final Socket from) {
           BufferedSink fromSink = Okio.buffer(Okio.sink(from));
           hello(fromSource, fromSink);
           acceptCommand(from.getInetAddress(), fromSource, fromSink);
+          openSockets.add(from);
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed", e);
           Util.closeQuietly(from);
@@ -192,6 +202,8 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
         // Copy sources to sinks in both directions.
         BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
         BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
+        openSockets.add(toSocket);
+
         transfer(fromAddress, toAddress, fromSource, toSink);
         transfer(fromAddress, toAddress, toSource, fromSink);
         break;
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index f0d63f17aa..83a6617b90 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -99,7 +99,7 @@
 
     HttpUrl url = server.url("/")
         .newBuilder()
-        .host(socksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
         .build();
 
     Request request = new Request.Builder().url(url).build();
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 0ec9bc34fb..055b25e226 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -42,7 +44,13 @@
   @Override public void close() {
   }
 
-  public String take() throws InterruptedException {
+  public List<String> takeAll() {
+    List<String> list = new ArrayList<>();
+    logs.drainTo(list);
+    return list;
+  }
+
+  public String take() throws Exception {
     String message = logs.poll(10, TimeUnit.SECONDS);
     if (message == null) {
       throw new AssertionError("Timed out waiting for log message.");
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index a566babadb..963f45f333 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -24,12 +24,14 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
+import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
@@ -42,7 +44,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -58,7 +59,6 @@
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -67,15 +67,15 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -87,6 +87,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static java.util.Locale.US;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static okhttp3.TestUtil.defaultClient;
@@ -101,6 +102,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -115,12 +117,12 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     urlFactory = new OkUrlFactory(defaultClient());
   }
@@ -139,7 +141,7 @@
     }
   }
 
-  @Test public void requestHeaders() throws IOException, InterruptedException {
+  @Test public void requestHeaders() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -200,14 +202,14 @@
     }
   }
 
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
+  @Test public void getRequestPropertyReturnsLastValue() {
     connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
   }
 
-  @Test public void responseHeaders() throws IOException, InterruptedException {
+  @Test public void responseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
         .addHeader("A: c")
         .addHeader("B: d")
@@ -241,7 +243,7 @@
     connection.getInputStream().close();
   }
 
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+  @Test public void serverSendsInvalidResponseHeaders() {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -252,7 +254,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+  @Test public void serverSendsInvalidCodeTooLarge() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -263,7 +265,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+  @Test public void serverSendsInvalidCodeNotANumber() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -274,7 +276,7 @@
     }
   }
 
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+  @Test public void serverSendsUnnecessaryWhitespace() {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -385,7 +387,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   // Check that we recognize a few basic mime types by extension.
   // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
+  @Test public void bug10100() {
     assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
     assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
   }
@@ -553,11 +555,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -569,11 +572,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -609,12 +613,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
+    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
@@ -624,7 +628,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
         .cache(cache)
         .connectionPool(connectionPool)
         .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -635,7 +639,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
           .cache(cache)
           .connectionPool(connectionPool)
           .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -648,19 +652,20 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   }
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection1);
 
-    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    SSLContext sslContext2 = Platform.get().getSSLContext();
     sslContext2.init(null, null, null);
     SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
 
@@ -683,14 +688,16 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
 
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -701,19 +708,19 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     RecordedRequest fallbackRequest = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
+    assertEquals(TlsVersion.TLS_1_2, fallbackRequest.getTlsVersion());
   }
 
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -732,7 +739,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .setSocketPolicy(DISCONNECT_AT_END));
@@ -740,7 +747,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
 
     assertContent("abc", urlFactory.open(server.url("/").url()));
@@ -765,8 +773,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
     connection = urlFactory.open(server.url("/foo").url());
@@ -823,7 +831,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     }
   }
 
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
       public Socket createSocket() {
         throw new IllegalArgumentException("useless");
@@ -848,9 +856,10 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     };
 
     if (useHttps) {
-      server.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -928,12 +937,13 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.url("/foo").url();
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -967,14 +977,15 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -996,7 +1007,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
@@ -1007,8 +1018,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
@@ -1023,7 +1034,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
-  private void initResponseCache() throws IOException {
+  private void initResponseCache() {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .cache(cache)
@@ -1031,18 +1042,18 @@ private void initResponseCache() throws IOException {
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
+  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1067,7 +1078,7 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
@@ -1077,7 +1088,8 @@ private void initResponseCache() throws IOException {
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxyAuthenticator(new JavaNetAuthenticator())
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1102,14 +1114,15 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1121,7 +1134,7 @@ private void initResponseCache() throws IOException {
   }
 
   @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslClient.socketFactory;
+    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     server.useHttps(socketFactory, true);
@@ -1132,7 +1145,7 @@ private void initResponseCache() throws IOException {
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, sslClient.trustManager)
+        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     URL url = new URL("https://android.com/foo");
@@ -1161,7 +1174,7 @@ private void initResponseCache() throws IOException {
     in.close();
   }
 
-  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
+  @Test public void disconnectDuringConnect_cookieJar() {
     final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
     class DisconnectingCookieJar implements CookieJar {
       @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
@@ -1197,7 +1210,7 @@ private void initResponseCache() throws IOException {
     assertEquals(200, connection.getResponseCode());
   }
 
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
     URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
     assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
   }
@@ -1331,7 +1344,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
    * This test checks whether connections are gzipped by default. This behavior in not required by
    * the API, so a failure of this test does not imply a bug in the implementation.
    */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
+  @Test public void gzipEncodingEnabledByDefault() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
@@ -1397,11 +1410,11 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
       boolean tls) throws Exception {
     if (tls) {
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -1517,7 +1530,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
+  @Test public void setChunkedStreamingMode() throws Exception {
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
@@ -1600,7 +1613,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
@@ -1654,7 +1667,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
@@ -1669,7 +1682,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   private List<String> authCallsForHeader(String authHeader) throws IOException {
@@ -1717,15 +1730,15 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
     assertEquals(requestMethod, connection.getRequestMethod());
   }
 
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+  @Test public void setInvalidRequestMethodLowercase() {
     assertInvalidRequestMethod("get");
   }
 
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
+  @Test public void setInvalidRequestMethodConnect() {
     assertInvalidRequestMethod("CONNECT");
   }
 
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
+  private void assertInvalidRequestMethod(String requestMethod) {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
@@ -1759,7 +1772,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     assertContent("mp3 data", connection);
   }
 
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetNegativeFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
@@ -1768,7 +1781,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
+  @Test public void canSetNegativeChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
@@ -1795,7 +1808,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
+  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
@@ -1805,7 +1818,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
@@ -1828,11 +1841,12 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -1930,6 +1944,37 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mötorhead".toCharArray())));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Authorization"));
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
+  }
+
   /** https://code.google.com/p/android/issues/detail?id=74026 */
   @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
@@ -2012,15 +2057,16 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     }
   }
 
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void redirectedOnHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -2034,22 +2080,23 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
   }
 
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .followSslRedirects(false)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
+  @Test public void notRedirectedFromHttpToHttps() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
@@ -2064,13 +2111,14 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2084,7 +2132,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2092,7 +2140,8 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2111,11 +2160,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.useHttps(sslClient.socketFactory, false);
-      server2.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -2182,7 +2232,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
         .addHeader("Location: " + server2.url("/b").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build());
     assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
@@ -2392,15 +2442,15 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
+    RecordingTrustManager trustManager = new RecordingTrustManager(handshakeCertificates.trustManager());
+    SSLContext sslContext = Platform.get().getSSLContext();
     sslContext.init(null, new TrustManager[] { trustManager }, null);
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(hostnameVerifier)
         .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
@@ -2411,8 +2461,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent("GHI", urlFactory.open(url));
 
     assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=localhost 1]"), trustManager.calls);
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
@@ -2528,7 +2577,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     }
   }
 
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
+  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -2541,7 +2590,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals("ABC", request.getBody().readUtf8());
   }
 
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
+  @Test public void connectionCloseInRequest() throws Exception {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
@@ -2557,7 +2606,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
+  @Test public void connectionCloseInResponse() throws Exception {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
@@ -2572,7 +2621,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
+  @Test public void connectionCloseWithRedirect() throws Exception {
     MockResponse response = new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
@@ -2595,9 +2644,6 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .build());
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
@@ -2611,7 +2657,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
+  @Test public void responseCodeDisagreesWithHeaders() {
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
@@ -2677,7 +2723,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
   }
 
-  @Test public void getHeadersThrows() throws IOException {
+  @Test public void getHeadersThrows() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
     connection = urlFactory.open(server.url("/").url());
@@ -3048,7 +3094,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals("", connection.getHeaderField("A"));
   }
 
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
+  @Test public void emptyRequestHeaderNameIsStrict() {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
     try {
@@ -3068,7 +3114,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     connection.getInputStream().close();
   }
 
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
+  @Test public void requestHeaderValidationIsStrict() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.addRequestProperty("a\tb", "Value");
@@ -3133,7 +3179,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3142,7 +3188,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals(credential, server.takeRequest().getHeader("Authorization"));
 
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyRoute().proxy());
     Response response = authenticator.onlyResponse();
     assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
@@ -3155,7 +3201,8 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    RecordingOkAuthenticator authenticator
+        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3179,7 +3226,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("c"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
+        Credentials.basic("jesse", "peanutbutter"), "Basic");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3200,7 +3247,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/0").url());
@@ -3214,7 +3261,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
@@ -3243,14 +3290,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     assertContent("A", connection);
   }
 
-  @Test public void http10SelectedProtocol() throws Exception {
+  @Test public void http10SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
-  @Test public void http11SelectedProtocol() throws Exception {
+  @Test public void http11SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
@@ -3258,7 +3305,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+  @Test public void zeroLengthPost() throws Exception {
     zeroLengthPayload("POST");
   }
 
@@ -3268,7 +3315,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+  @Test public void zeroLengthPut() throws Exception {
     zeroLengthPayload("PUT");
   }
 
@@ -3277,8 +3324,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPut();
   }
 
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
+  private void zeroLengthPayload(String method) throws Exception {
     server.enqueue(new MockResponse());
     connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
@@ -3314,7 +3360,7 @@ private void zeroLengthPayload(String method)
     assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
@@ -3322,7 +3368,7 @@ private void zeroLengthPayload(String method)
     }
   }
 
-  @Test public void setProtocolsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
@@ -3352,12 +3398,12 @@ private void zeroLengthPayload(String method)
   }
 
   @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
 
     HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    connection.setSSLSocketFactory(sslClient.socketFactory);
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     try {
       connection.getInputStream();
       fail();
@@ -3365,6 +3411,11 @@ private void zeroLengthPayload(String method)
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 1.9 response to the FAIL_HANDSHAKE
+      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
+    } catch (SocketException expected) {
+      // Conscrypt's response to the FAIL_HANDSHAKE
     }
   }
 
@@ -3395,6 +3446,16 @@ private void zeroLengthPayload(String method)
     assertEquals(1, requestB.getSequenceNumber());
   }
 
+  @Test public void nullSSLSocketFactory_throws() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    try {
+      connection.setSSLSocketFactory(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   /**
    * We had a bug where we weren't closing Gzip streams on redirects.
    * https://github.com/square/okhttp/issues/441
@@ -3467,7 +3528,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void interceptorsNotInvoked() throws Exception {
     Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
+      @Override public Response intercept(Chain chain) {
         throw new AssertionError();
       }
     };
@@ -3535,14 +3596,14 @@ private void zeroLengthPayload(String method)
     testInstanceFollowsRedirects("https://www.google.com/");
   }
 
-  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+  @Test public void setSslSocketFactoryFailsOnJdk9() {
     assumeTrue(getPlatform().equals("jdk9"));
 
     enableProtocol(Protocol.HTTP_2);
     URL url = server.url("/").url();
     HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
     try {
-      connection.setSSLSocketFactory(sslClient.socketFactory);
+      connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -3640,6 +3701,20 @@ private void zeroLengthPayload(String method)
     assertEquals(0, request2.getSequenceNumber());
   }
 
+  @Test public void authenticateNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    Authenticator.setDefault(new RecordingAuthenticator(null));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(401, connection.getResponseCode());
+  }
+
   private void testInstanceFollowsRedirects(String spec) throws Exception {
     URL url = new URL(spec);
     HttpURLConnection urlConnection = urlFactory.open(url);
@@ -3678,8 +3753,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
 
@@ -3719,8 +3793,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   enum ProxyConfig {
     NO_PROXY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(Proxy.NO_PROXY)
             .build());
@@ -3730,8 +3803,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     CREATE_ARG() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(server.toProxyAddress())
             .build());
@@ -3741,8 +3813,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("proxyHost", server.getHostName());
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3751,8 +3822,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("http.proxyHost", server.getHostName());
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3761,8 +3831,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("https.proxyHost", server.getHostName());
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3778,7 +3847,7 @@ public abstract HttpURLConnection connect(
     private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
-    public RecordingTrustManager(X509TrustManager delegate) {
+    RecordingTrustManager(X509TrustManager delegate) {
       this.delegate = delegate;
     }
 
@@ -3786,13 +3855,11 @@ public RecordingTrustManager(X509TrustManager delegate) {
       return delegate.getAcceptedIssuers();
     }
 
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkClientTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkClientTrusted " + certificatesToString(chain));
     }
 
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkServerTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkServerTrusted " + certificatesToString(chain));
     }
 
@@ -3811,11 +3878,12 @@ private String certificatesToString(X509Certificate[] certificates) {
    */
   private void enableProtocol(Protocol protocol) {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
     server.setProtocols(urlFactory.client().protocols());
   }
@@ -3826,7 +3894,7 @@ private void enableProtocol(Protocol protocol) {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 
   private String getPlatform() {
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 56611be40a..5875bc3970 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -230,7 +230,7 @@ public UrlComponentEncodingTester test(Component component) {
   private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
@@ -238,7 +238,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
 
   private void testEncodeAndDecode(int codePoint, Component component) {
     String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
     component.set(builder, expected);
     HttpUrl url = builder.build();
     String actual = component.get(url);
@@ -252,7 +252,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
     if (encoding != Encoding.PERCENT) return;
     String identity = Encoding.IDENTITY.encode(codePoint);
     String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
@@ -262,7 +262,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
   private void testToUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -271,7 +271,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
 
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -282,7 +282,7 @@ private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
     String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
     HttpUrl toAndFromUri = HttpUrl.get(uri);
     if (uriEscaped) {
@@ -402,6 +402,25 @@ public String encode(int codePoint) {
         return query.substring(1, query.length() - 1);
       }
     },
+    QUERY_VALUE {
+      @Override public String urlString(String value) {
+        return "http://example.com/?q=a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(3, query.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addQueryParameter("q", "a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String value = url.queryParameter("q");
+        return value.substring(1, value.length() - 1);
+      }
+    },
     FRAGMENT {
       @Override public String urlString(String value) {
         return "http://example.com/#a" + value + "z";
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index a15c57ea35..605d606fb0 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -98,7 +98,7 @@ private void testHttpUrl() {
     if (testData.base.equals("about:blank")) {
       url = HttpUrl.parse(testData.input);
     } else {
-      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      HttpUrl baseUrl = HttpUrl.get(testData.base);
       url = baseUrl.resolve(testData.input);
     }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
new file mode 100644
index 0000000000..603f221397
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -0,0 +1,296 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+
+  @Test public void defaultConfigIsNoTimeout() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    assertEquals(0, call.timeout().timeoutNanos());
+  }
+
+  @Test public void configureClientDefault() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    OkHttpClient timeoutClient = client.newBuilder()
+        .callTimeout(456, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = timeoutClient.newCall(request);
+    assertEquals(TimeUnit.MILLISECONDS.toNanos(456), call.timeout().timeoutNanos());
+  }
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/b")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/c")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/d")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/e")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/f")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/a"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertFalse(call.isCanceled());
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8("abc");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8("def");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java
new file mode 100644
index 0000000000..a4ab9635c5
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingHeadersListener.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.internal.duplex.HeadersListener;
+
+public final class RecordingHeadersListener implements HeadersListener {
+  final ArrayDeque<Headers> receivedHeaders = new ArrayDeque<>();
+
+  @Override public void onHeaders(Headers headers) {
+    receivedHeaders.add(headers);
+  }
+
+  public @Nullable Headers takeFirst() {
+    return receivedHeaders.poll();
+  }
+
+  public List<Headers> takeAll() {
+    List<Headers> result = new ArrayList<>();
+    for (Headers headers; (headers = receivedHeaders.poll()) != null; ) {
+      result.add(headers);
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 7d9d2bfe6a..126fce4d7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -16,21 +16,24 @@
 package okhttp3.internal;
 
 import java.io.IOException;
-import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.Authenticator;
+import okhttp3.Challenge;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
 
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
-  public final List<Proxy> proxies = new ArrayList<>();
-  public final String credential;
+  public final List<Route> routes = new ArrayList<>();
+  public @Nullable String credential;
+  public @Nullable String scheme;
 
-  public RecordingOkAuthenticator(String credential) {
+  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
     this.credential = credential;
+    this.scheme = scheme;
   }
 
   public Response onlyResponse() {
@@ -38,17 +41,33 @@ public Response onlyResponse() {
     return responses.get(0);
   }
 
-  public Proxy onlyProxy() {
-    if (proxies.size() != 1) throw new IllegalStateException();
-    return proxies.get(0);
+  public Route onlyRoute() {
+    if (routes.size() != 1) throw new IllegalStateException();
+    return routes.get(0);
   }
 
   @Override public Request authenticate(Route route, Response response) throws IOException {
+    if (route == null) throw new NullPointerException("route == null");
+    if (response == null) throw new NullPointerException("response == null");
+
     responses.add(response);
-    proxies.add(route.proxy());
+    routes.add(route);
+
+    if (!schemeMatches(response) || credential == null) return null;
+
     String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
         .addHeader(header, credential)
         .build();
   }
+
+  private boolean schemeMatches(Response response) {
+    if (scheme == null) return true;
+
+    for (Challenge challenge : response.challenges()) {
+      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
+    }
+
+    return false;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
new file mode 100644
index 0000000000..af92f5eb84
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
@@ -0,0 +1,48 @@
+ /*
+  * Copyright (C) 2012 The Android Open Source Project
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+package okhttp3.internal;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+ public class UtilTest {
+  @Test public void testAssertionError() {
+    NullPointerException nullPointerException = new NullPointerException();
+    AssertionError ae = Util.assertionError("npe", nullPointerException);
+    assertSame(nullPointerException, ae.getCause());
+    assertEquals("npe", ae.getMessage());
+  }
+
+  @Test public void immutableMap() {
+    Map<String, String> map = new LinkedHashMap<>();
+    map.put("a", "A");
+    Map<String, String> immutableCopy = Util.immutableMap(map);
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    map.clear();
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    try {
+      immutableCopy.clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index b0b06e9f87..e366e4081b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -25,9 +25,10 @@
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -40,7 +41,7 @@
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
 
   @Test
   public void nonRetryableIOException() throws Exception {
@@ -121,7 +122,7 @@ private static ConnectionSpecSelector createConnectionSpecSelector(
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
     socket.setEnabledProtocols(javaNames(tlsVersions));
     return socket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 209d79d5c5..44e939aaea 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 
 public class RouteExceptionTest {
@@ -25,6 +26,7 @@
   @Test public void getConnectionIOException_single() {
     IOException firstException = new IOException();
     RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getFirstConnectException());
     assertSame(firstException, re.getLastConnectException());
   }
 
@@ -36,12 +38,13 @@
     re.addConnectException(secondException);
     re.addConnectException(thirdException);
 
-    IOException connectionIOException = re.getLastConnectException();
-    assertSame(thirdException, connectionIOException);
-    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
-    assertSame(secondException, thirdSuppressedExceptions[0]);
+    IOException connectionIOException = re.getFirstConnectException();
+    assertSame(firstException, connectionIOException);
+    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
+    assertEquals(2, suppressedExceptions.length);
+    assertSame(secondException, suppressedExceptions[0]);
+    assertSame(thirdException, suppressedExceptions[1]);
 
-    Throwable[] secondSuppressedException = secondException.getSuppressed();
-    assertSame(firstException, secondSuppressedException[0]);
+    assertSame(thirdException, re.getLastConnectException());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 0f43e54da1..6c4a0d2d9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -23,7 +23,6 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.net.UnknownHostException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.NoSuchElementException;
@@ -40,13 +39,15 @@
 import okhttp3.Route;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Test;
 
 import static java.net.Proxy.NO_PROXY;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -68,8 +69,8 @@
   private int uriPort = 1003;
 
   private SocketFactory socketFactory;
-  private final SslClient sslClient = SslClient.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
   private final Authenticator authenticator = Authenticator.NONE;
@@ -90,8 +91,15 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
+    assertFalse(selection.hasNext());
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
 
     assertFalse(routeSelector.hasNext());
     try {
@@ -108,10 +116,20 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(1));
-    Route route = routeSelector.next();
+    RouteSelector.Selection selection = routeSelector.next();
+    Route route = selection.next();
     routeDatabase.failed(route);
     routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertFalse(selection.hasNext());
+
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -128,9 +146,11 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(proxyAHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -144,9 +164,11 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -171,9 +193,11 @@
         EventListener.NONE);
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -184,9 +208,11 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(address.url().uri());
@@ -204,15 +230,19 @@
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.set(proxyAHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.set(proxyBHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
+    assertFalse(selection2.hasNext());
 
     // No more proxies to try.
     assertFalse(routeSelector.hasNext());
@@ -229,9 +259,11 @@
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.set(uriHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -247,8 +279,10 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(proxyAHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     assertTrue(routeSelector.hasNext());
     dns.clear(proxyBHost);
@@ -261,9 +295,11 @@
 
     assertTrue(routeSelector.hasNext());
     dns.set(proxyAHost, dns.allocate(1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
+    assertFalse(selection2.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -276,21 +312,25 @@
 
     // Proxy A
     dns.set(proxyAHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    assertFalse(selection1.hasNext());
 
     // Proxy B
     dns.set(proxyBHost, dns.allocate(2));
-    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
+    assertFalse(selection2.hasNext());
 
     // No more proxies to attempt.
     assertFalse(routeSelector.hasNext());
   }
 
-  @Test public void failedRoutesAreLast() throws Exception {
+  @Test public void failedRouteWithSingleProxy() throws Exception {
     Address address = httpsAddress();
     RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
         EventListener.NONE);
@@ -299,10 +339,8 @@
     dns.set(uriHost, dns.allocate(numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
-    List<Route> regularRoutes = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next());
-    }
+    RouteSelector.Selection selection1 = routeSelector.next();
+    List<Route> regularRoutes = selection1.getAll();
 
     // Check that we do indeed have more than one route.
     assertEquals(numberOfAddresses, regularRoutes.size());
@@ -311,14 +349,70 @@
     // Reset selector
     routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
 
-    List<Route> routesWithFailedRoute = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next());
-    }
+    // The first selection prioritizes the non-failed routes.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertEquals(regularRoutes.get(1), selection2.next());
+    assertFalse(selection2.hasNext());
+
+    // The second selection will contain all failed routes.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    assertEquals(regularRoutes.get(0), selection3.next());
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRouteWithMultipleProxies() throws IOException {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
-    assertEquals(regularRoutes.get(0),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
+    dns.set(proxyAHost, dns.allocate(1));
+    dns.set(proxyBHost, dns.allocate(1));
+
+    // Mark the ProxyA route as failed.
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(proxyAHost);
+    Route route = selection.next();
+    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    routeDatabase.failed(route);
+
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+
+    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    dns.assertRequests(proxyAHost, proxyBHost);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    assertFalse(selection2.hasNext());
+
+    // Confirm the last selection contains the postponed route from ProxyA.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    dns.assertRequests();
+    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void queryForAllSelectedRoutes() throws IOException {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(uriHost);
+
+    List<Route> routes = selection.getAll();
+    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertSame(routes.get(0), selection.next());
+    assertSame(routes.get(1), selection.next());
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
   }
 
   @Test public void getHostString() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index bd4038d4a1..fb37e7e491 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -45,9 +45,8 @@ public void assertRequests(URI... expectedUris) {
 
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
-    failures.add(
-        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-            ioe.getMessage()));
+    failures.add(Util.format("%s %s:%d %s",
+        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
   }
 
   @Override public String toString() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 9ac3b93ecc..ed2b05085f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -36,6 +36,7 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -92,6 +93,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      assertTrue(Thread.interrupted());
     }
 
     connection.disconnect();
@@ -115,6 +117,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      assertTrue(Thread.interrupted());
     }
 
     responseBody.close();
@@ -128,7 +131,7 @@ private void interruptLater(final int delayMillis) {
           sleep(delayMillis);
           toInterrupt.interrupt();
         } catch (InterruptedException e) {
-          throw new RuntimeException(e);
+          throw new AssertionError(e);
         }
       }
     };
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 6a90ac0458..454f5eec99 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -484,6 +484,35 @@
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
 
+  @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
+    bytesIn.writeByte(0x7d); // == Literal indexed ==
+    // Indexed name (idx = 60) -> "www-authenticate"
+    bytesIn.writeByte(0x05); // Literal value (len = 5)
+    bytesIn.writeUtf8("Basic");
+
+    hpackReader.readHeaders();
+
+    assertEquals(Arrays.asList(new Header("www-authenticate", "Basic")), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
+    bytesIn.writeByte(0x40);
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+    bytesIn.writeByte(0x05); // Literal value (len = 5)
+    bytesIn.writeUtf8("Basic");
+
+    bytesIn.writeByte(0x7e);
+    bytesIn.writeByte(0x06); // Literal value (len = 6)
+    bytesIn.writeUtf8("Basic2");
+
+    hpackReader.readHeaders();
+
+    assertEquals(
+        Arrays.asList(new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2")),
+        hpackReader.getAndResetHeaderList());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
    */
@@ -501,6 +530,27 @@
     checkReadThirdRequestWithoutHuffman();
   }
 
+  @Test public void readFailingRequestExample() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+    // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+    // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+
+    bytesIn.writeByte(0x7f); // == Bad index! ==
+
+    // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large 78", e.getMessage());
+    }
+  }
+
   private void firstRequestWithoutHuffman() {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index c8af96913b..4b7b585ccc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -24,6 +24,8 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Headers;
+import okhttp3.internal.RecordingHeadersListener;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
@@ -33,6 +35,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Utf8;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -83,28 +86,6 @@
     assertTrue(ping.ack);
   }
 
-  @Test public void clientPingsServerHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
     Settings initial = new Settings();
     initial.set(INITIAL_WINDOW_SIZE, 1684);
@@ -130,7 +111,6 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
     assertEquals(3368, connection.peerSettings.getInitialWindowSize());
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
     // New Stream is has the most recent initial window size.
     assertEquals(3368, stream.bytesLeftInWriteWindow);
   }
@@ -195,7 +175,7 @@
 
     // Play it back.
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    connection.writePingAndAwaitPong(); // Ensure the SETTINGS have been received.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
     sink.writeUtf8("abcdefghi");
@@ -215,6 +195,39 @@
     assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
   }
 
+  /**
+   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
+   * just prior to us canceling a stream.
+   */
+  @Test public void discardedDataFramesAreCounted() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.sendFrame().headers(3, headerEntries("a", "apple"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(true, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
+    Source source = stream1.getSource();
+    Buffer buffer = new Buffer();
+    while (buffer.size() != 1024) source.read(buffer, 1024);
+    stream1.close(ErrorCode.CANCEL);
+
+    InFrame frame1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, frame1.type);
+    InFrame frame2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame2.type);
+    InFrame frame3 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame3.type);
+
+    assertEquals(2048, connection.unacknowledgedBytesRead);
+  }
+
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -231,7 +244,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -291,7 +304,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -513,9 +526,9 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
-    connection.ping().roundTripTime();
+    connection.writePingAndAwaitPong();
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -529,6 +542,125 @@
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
+  @Test public void clientReadsHeadersDataHeadersData() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("cyborg"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    assertStreamData("robotcyborg", stream.getSource());
+    assertEquals(Arrays.asList(Headers.of("a", "android"), Headers.of("b", "banana")),
+        headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void clientReadsHeadersDataPingPongHeadersData() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("cyborg"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    BufferedSource source = Okio.buffer(stream.getSource());
+
+    assertStreamPrefix("robot", source);
+    assertEquals(Arrays.asList(Headers.of("a", "android")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+
+    assertStreamPrefix("cyborg", source);
+    assertEquals(Arrays.asList(Headers.of("b", "banana")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void clientReadsHeadersDataHeadersClose() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    BufferedSource source = Okio.buffer(stream.getSource());
+
+    assertStreamPrefix("robot", source);
+    assertEquals(Arrays.asList(Headers.of("a", "android")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+    source.close();
+    assertEquals(Arrays.asList(Headers.of("b", "banana")), headersListener.takeAll());
+
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void serverReadsHeadersDataHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // HEADERS
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    stream.writeHeaders(headerEntries("e", "elephant"), true);
+    connection.writePingAndAwaitPong();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+
+    InFrame nextFrame = peer.takeFrame();
+    assertEquals(headerEntries("e", "elephant"), nextFrame.headerBlock);
+  }
+
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -543,7 +675,7 @@
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -582,15 +714,18 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+    long pingAtNanos = System.nanoTime();
+    connection.writePingAndAwaitPong();
+    long elapsedNanos = System.nanoTime() - pingAtNanos;
+    assertTrue(elapsedNanos > 0);
+    assertTrue(elapsedNanos < TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(0x4f4b6f6b, pingFrame.payload1); // OkOk
+    assertEquals(0xf09f8da9, pingFrame.payload2); // donut
     assertFalse(pingFrame.ack);
   }
 
@@ -759,7 +894,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the RST_CANCEL has been received.
     try {
       out.writeUtf8("square");
       out.flush();
@@ -782,7 +917,6 @@
     assertFalse(synStream.outFinished);
     InFrame ping = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
   }
 
   /**
@@ -890,7 +1024,7 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source source = stream.getSource();
     assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -914,8 +1048,8 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -940,7 +1074,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
@@ -973,7 +1107,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("b", "banana"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -997,7 +1131,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
@@ -1028,7 +1162,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -1077,10 +1211,15 @@
     // play it back
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
-    Ping ping = connection.ping();
+    synchronized (connection) {
+      if (connection.shutdown) {
+        throw new ConnectionShutdownException();
+      }
+    }
+    connection.writePing(false, 0x01, 0x02);
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+    connection.awaitPong(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
@@ -1093,28 +1232,6 @@
     assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
   }
 
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.shutdown(ErrorCode.INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-
-    // verify the peer received what was expected
-    InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
-  }
-
   @Test public void close() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1160,21 +1277,6 @@
     assertEquals(3, rstStream.streamId);
   }
 
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
   @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1189,7 +1291,7 @@
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -1250,7 +1352,7 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
+    connection.writePingAndAwaitPong(); // Make sure settings have been received.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     Sink sink = stream.getSink();
     sink.write(new Buffer().writeUtf8("abcde"), 5);
@@ -1286,7 +1388,6 @@
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(3, 5);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0);
     peer.acceptFrame(); // DATA
@@ -1295,9 +1396,9 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    connection.writePingAndAwaitPong(); // Make sure settings have been acked.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    connection.writePingAndAwaitPong(); // Make sure the window update has been received.
     Sink sink = stream.getSink();
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     sink.write(new Buffer().writeUtf8("abcdef"), 6);
@@ -1361,9 +1462,9 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
-        stream.takeResponseHeaders());
+    connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertEquals(Headers.of("c", "c3po"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1387,9 +1488,9 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime();
-    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    connection.writePingAndAwaitPong();
+    assertEquals(Headers.of("c", "cola"), stream.takeHeaders());
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
@@ -1421,7 +1522,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -1499,7 +1600,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
@@ -1565,7 +1666,7 @@
 
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
@@ -1588,12 +1689,17 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
+  /** Reads {@code prefix} from {@code source}. */
+  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
+    assertEquals(prefix, source.readUtf8(Utf8.size(prefix)));
+  }
+
   /**
    * Returns true when all work currently in progress by the watchdog have completed. This method
    * creates more work for the watchdog and waits for that work to be executed. When it is, we know
    * work that preceded this call is complete.
    */
-  private void awaitWatchdogIdle() throws InterruptedException {
+  private void awaitWatchdogIdle() throws Exception {
     final CountDownLatch latch = new CountDownLatch(1);
     AsyncTimeout watchdogJob = new AsyncTimeout() {
       @Override protected void timedOut() {
@@ -1663,7 +1769,7 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
   private static class RecordingPushObserver implements PushObserver {
     final List<Object> events = new ArrayList<>();
 
-    public synchronized Object takeEvent() throws InterruptedException {
+    public synchronized Object takeEvent() throws Exception {
       while (events.isEmpty()) {
         wait();
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 3ef429a957..eb0acf4963 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,16 +20,20 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import javax.net.ssl.HostnameVerifier;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import okhttp3.Cache;
 import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
 import okhttp3.Headers;
@@ -42,14 +46,13 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.TestLogHandler;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -57,9 +60,9 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -68,39 +71,85 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
-/** Test how SPDY interacts with HTTP/2 features. */
+/** Test how HTTP/2 interacts with HTTP features. */
+@RunWith(Parameterized.class)
 public final class HttpOverHttp2Test {
+  private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
+  private static final HandshakeCertificates handshakeCertificates = localhost();
+
+  @Parameters(name = "{0}")
+  public static Collection<Protocol> data() {
+    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
+  }
+
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private Cache cache;
+  private TestLogHandler http2Handler = new TestLogHandler();
+  private Level previousLevel;
+  private String scheme;
+  private Protocol protocol;
+
+  public HttpOverHttp2Test(Protocol protocol) {
+    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
+    this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
+    this.protocol = protocol;
+  }
 
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = defaultClient().newBuilder()
+  private static OkHttpClient buildH2PriorKnowledgeClient() {
+    return defaultClient().newBuilder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+  }
+
+  private static OkHttpClient buildHttp2Client() {
+    return defaultClient().newBuilder()
         .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
   }
 
-  @After public void tearDown() throws Exception {
+  @Before public void setUp() {
+    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+    } else {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    }
+
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+
+    http2Logger.addHandler(http2Handler);
+    previousLevel = http2Logger.getLevel();
+    http2Logger.setLevel(Level.FINE);
+  }
+
+  @After public void tearDown() {
     Authenticator.setDefault(null);
+    http2Logger.removeHandler(http2Handler);
+    http2Logger.setLevel(previousLevel);
+
+    client.connectionPool().evictAll();
   }
 
   @Test public void get() throws Exception {
@@ -115,11 +164,12 @@
 
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
+    assertEquals(protocol, response.protocol());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
   }
 
@@ -144,7 +194,7 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -171,10 +221,10 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -202,10 +252,10 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -250,6 +300,101 @@
     response2.close();
   }
 
+  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and discard what we've buffered for the response body. This should free up
+    // the connection flow-control window so new requests can proceed.
+    call1.cancel();
+    assertFalse("Call should not have completed successfully.",
+        Util.discard(response1.body().source(), 1, TimeUnit.SECONDS));
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  /** Wait for the client to receive {@code dataLength} DATA frames. */
+  private void waitForDataFrames(int dataLength) throws Exception {
+    int expectedFrameCount = dataLength / 16384;
+    int dataFrameCount = 0;
+    while (dataFrameCount < expectedFrameCount) {
+      String log = http2Handler.take();
+      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
+        dataFrameCount++;
+      }
+    }
+  }
+
+  @Test public void connectionWindowUpdateOnClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and close the response body. This should discard the buffered data and update
+    // the connnection flow-control window.
+    call1.cancel();
+    response1.close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE, response1.body().contentLength());
+    int read = response1.body().source().read(new byte[8192]);
+    assertEquals(8192, read);
+
+    // Make a second call that should transmit the response headers. The response body won't be
+    // transmitted until the flow-control window is updated from the first request.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+
+    // Close the response body. This should discard the buffered data and update the connection
+    // flow-control window.
+    response1.close();
+
+    assertEquals("abc", response2.body().string());
+  }
+
   /** https://github.com/square/okhttp/issues/373 */
   @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
@@ -287,7 +432,7 @@
 
     String credential = Credentials.basic("username", "password");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
@@ -702,6 +847,70 @@
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
   }
 
+  @Test public void recoverFromCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    callAndCancel(0);
+
+    // Make a second request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("def", response.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("abc"));
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("def"));
+    server.enqueue(new MockResponse()
+            .setBody("ghi"));
+
+    client = client.newBuilder()
+            .dns(new DoubleInetAddressDns())
+            .build();
+
+    callAndCancel(0);
+    callAndCancel(1);
+
+    // Make a third request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+            .url(server.url("/"))
+            .build());
+    Response response = call.execute();
+    assertEquals("ghi", response.body().string());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  /** Make a call and canceling it as soon as it's accepted by the server. */
+  private void callAndCancel(int expectedSequenceNumber) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call1, IOException e) {
+      }
+
+      @Override public void onResponse(Call call1, Response response) {
+      }
+    });
+    assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber());
+    call.cancel();
+  }
+
   @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
     noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
   }
@@ -732,6 +941,74 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     }
   }
 
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
+      @Override public Request authenticate(Route route, Response response) throws IOException {
+        responses.offer(response.body().string());
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        return response.request();
+      }
+    };
+
+    OkHttpClient blockingAuthClient = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        responses.offer(response.body().string());
+      }
+    };
+
+    // Make the first request waiting until we get our auth challenge.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    blockingAuthClient.newCall(request).enqueue(callback);
+    String response1 = responses.take();
+    assertEquals("", response1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Now make the second request which will restrict the first HTTP/2 connection from creating new
+    // streams.
+    client.newCall(request).enqueue(callback);
+    String response2 = responses.take();
+    assertEquals("DEF", response2);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
+    // one.
+    latch.countDown();
+    String response3 = responses.take();
+    assertEquals("ABC", response3);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void nonAsciiResponseHeader() throws Exception {
     server.enqueue(new MockResponse()
         .addHeaderLenient("Alpha", "α")
@@ -762,11 +1039,11 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
 
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -788,11 +1065,11 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -804,12 +1081,6 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
-    client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
-        .build();
-
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .method("DELETE", null)
@@ -817,51 +1088,108 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm no data frames were sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
-    }
+    List<String> logs = http2Handler.takeAll();
 
-    assertEquals(1, handler.headerFrameCount);
-    assertTrue(handler.dataFrames.isEmpty());
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
   }
 
   @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    assertEquals(protocol, response.protocol());
+
+    List<String> logs = http2Handler.takeAll();
+
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
+    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
+  }
+
+  @Test public void pingsTransmitted() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
     client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
+        .pingInterval(500, TimeUnit.MILLISECONDS)
         .build();
 
+    // Delay the response to give 1 ping enough time to be sent and replied to.
+    server.enqueue(new MockResponse()
+        .setBodyDelay(750, TimeUnit.MILLISECONDS)
+        .setBody("ABC"));
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", Util.EMPTY_REQUEST)
         .build());
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm an empty data frame was sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
+
+    // Confirm a single ping was sent and received, and its reply was sent and received.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK"));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
+
+  @Test public void missingPongsFailsConnection() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
+    client = client.newBuilder()
+        .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Set up the server to ignore the socket. It won't respond to pings!
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
+
+    // Make a call. It'll fail as soon as our pings detect a problem.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    long executeAtNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+
+    long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Confirm a single ping was sent but not acknowledged.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
+  private String firstFrame(List<String> logs, String type) {
+    for (String log: logs) {
+      if (log.contains(type)) {
+        return log;
+      }
     }
+    return null;
+  }
 
-    assertEquals(1, handler.headerFrameCount);
-    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  private int countFrames(List<String> logs, String message) {
+    int result = 0;
+    for (String log: logs) {
+      if (log.equals(message)) {
+        result++;
+      }
+    }
+    return result;
   }
 
   /**
@@ -978,6 +1306,31 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void responseHeadersAfterGoaway() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(1, SECONDS)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("DEF"));
+
+    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        bodies.add(response.body().string());
+      }
+      @Override public void onFailure(Call call, IOException e) {
+        System.out.println(e);
+      }
+    };
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+
+    assertEquals("DEF", bodies.poll(2, SECONDS));
+    assertEquals("ABC", bodies.poll(2, SECONDS));
+    assertEquals(2, server.getRequestCount());
+  }
+
   /**
    * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
    * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
@@ -986,7 +1339,9 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
    * <p>This test uses proxy tunnels to get a hook while a connection is being established.
    */
   @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    assumeTrue(protocol == Protocol.HTTP_2);
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
 
     // Force a fresh connection pool for the test.
     client.connectionPool().evictAll();
@@ -1093,7 +1448,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
   }
 
-  public Buffer gzip(String bytes) throws IOException {
+  private Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
     sink.writeUtf8(bytes);
@@ -1105,7 +1460,7 @@ public Buffer gzip(String bytes) throws IOException {
     String path;
     CountDownLatch countDownLatch;
 
-    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+    AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -1123,28 +1478,4 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
-
-  static final class RecordingHandler extends BaseTestHandler {
-    int headerFrameCount;
-    final List<Integer> dataFrames = new ArrayList<>();
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-    }
-
-    @Override public void ackSettings() {
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      dataFrames.add(length);
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      headerFrameCount++;
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index fe5f82fd4a..376c46d1f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -100,7 +100,7 @@ public Http2Writer truncateLastFrame(int length) {
     return writer;
   }
 
-  public InFrame takeFrame() throws InterruptedException {
+  public InFrame takeFrame() throws Exception {
     return inFrames.take();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ada8f78969..2889911d52 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -39,4 +39,9 @@ public void findsAlpnMethods() {
     assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
     assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Jdk9Platform", new Jdk9Platform(null, null).toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
index ffd5842e83..48504202b5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -32,4 +32,9 @@
   public static String getPlatform() {
     return System.getProperty("okhttp.platform", "platform");
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Platform", new Platform().toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
index 9e9ec71dd8..e999890991 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -17,7 +17,6 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InterruptedIOException;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -272,14 +271,14 @@ private void checkPublicSuffix(String domain, String registrablePart) {
       return;
     }
 
-    String canonicalDomain = Util.domainToAscii(domain);
+    String canonicalDomain = Util.canonicalizeHost(domain);
     if (canonicalDomain == null) return;
 
     String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
     if (registrablePart == null) {
       assertNull(result);
     } else {
-      assertEquals(Util.domainToAscii(registrablePart), result);
+      assertEquals(Util.canonicalizeHost(registrablePart), result);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 27b1c7783f..ffb116eea7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -15,22 +15,37 @@
  */
 package okhttp3.internal.tls;
 
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -41,37 +56,38 @@
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, intermediateCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -97,37 +113,38 @@
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
         .build();
-    SslClient contextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -158,8 +175,8 @@
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
 
@@ -167,24 +184,25 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("good_intermediate_ca")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
-        .serialNumber("3")
+        .signedBy(goodIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -194,32 +212,21 @@
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("bad_intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
 
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -243,13 +250,13 @@
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .ca(3)
+        .serialNumber(2L)
+        .certificateAuthority(1)
         .commonName("compromised_root")
         .build();
 
@@ -257,20 +264,21 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("3")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(3L)
         .commonName("intermediate_ca")
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
-        .addTrustedCertificate(compromisedRootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
+        .addTrustedCertificate(compromisedRootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -280,32 +288,20 @@
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(compromisedRootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
-
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -329,4 +325,21 @@
       assertTrue(message, message.startsWith("Certificate pinning failure!"));
     }
   }
+
+  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
+    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
+    X509TrustManager trustManager = newTrustManager(
+        keystoreType, Collections.<X509Certificate>emptyList());
+    SSLContext sslContext = Platform.get().getSSLContext();
+    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+        new SecureRandom());
+    return sslContext.getSocketFactory();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 2ec0d6494d..ff3fb12270 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -15,35 +15,44 @@
  */
 package okhttp3.internal.tls;
 
-import java.io.IOException;
 import java.net.SocketException;
 import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
-import okhttp3.DelegatingSSLSocketFactory;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ClientAuthTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
-  public enum ClientAuth {
-    NONE, WANTS, NEEDS
-  }
-
   private HeldCertificate serverRootCa;
   private HeldCertificate serverIntermediateCa;
   private HeldCertificate serverCert;
@@ -52,110 +61,121 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void setUp() throws GeneralSecurityException {
+  public void setUp() {
     serverRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
-        .commonName(server.getHostName())
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
+        .commonName("Local Host")
+        .addSubjectAlternativeName(server.getHostName())
         .build();
 
     clientRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(13)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(12)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
-        .serialNumber("4")
+        .signedBy(clientIntermediateCa)
+        .serialNumber(4L)
         .commonName("Jethro Willis")
+        .addSubjectAlternativeName("jethrowillis.com")
         .build();
   }
 
   @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.noClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(null, response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(null, response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -163,22 +183,50 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
+      assertEquals("jdk9", getPlatform());
+    }
+  }
+
+  @Test public void commonNameIsNotTrusted() throws Exception {
+    serverCert = new HeldCertificate.Builder()
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
+        .commonName(server.getHostName())
+        .addSubjectAlternativeName("different-host.com")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
+
+    server.useHttps(socketFactory, false);
+    server.requireClientAuth();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .commonName("Jethro Willis")
         .build();
 
     OkHttpClient client = buildClient(clientCert2);
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -186,42 +234,45 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      // javax.net.ssl.SSLException: readRecord
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
+      assertEquals("jdk9", getPlatform());
     }
   }
 
-  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
-    SslClient.Builder sslClientBuilder = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate);
+  private OkHttpClient buildClient(
+      HeldCertificate heldCertificate, X509Certificate... intermediates) {
+    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRootCa.certificate());
 
-    if (cert != null) {
-      sslClientBuilder.certificateChain(cert, chain);
+    if (heldCertificate != null) {
+      builder.heldCertificate(heldCertificate, intermediates);
     }
 
-    SslClient sslClient = sslClientBuilder.build();
+    HandshakeCertificates handshakeCertificates = builder.build();
     return defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
   }
 
-  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
-    SslClient serverSslClient = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate)
-        .addTrustedCertificate(clientRootCa.certificate)
-        .certificateChain(serverCert, serverIntermediateCa)
-        .build();
-
-    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        if (clientAuth == ClientAuth.NEEDS) {
-          sslSocket.setNeedClientAuth(true);
-        } else if (clientAuth == ClientAuth.WANTS) {
-          sslSocket.setWantClientAuth(true);
-        }
-
-        return super.configureSocket(sslSocket);
-      }
-    };
+  private SSLSocketFactory buildServerSslSocketFactory() {
+    // The test uses JDK default SSL Context instead of the Platform provided one
+    // as Conscrypt seems to have some differences, we only want to test client side here.
+    try {
+      X509KeyManager keyManager = newKeyManager(
+          null, serverCert, serverIntermediateCa.certificate());
+      X509TrustManager trustManager = newTrustManager(
+          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
+          new SecureRandom());
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index f03f197d94..6dd5bbbd7c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -72,7 +72,7 @@
         + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
         + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("foo.com", session));
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
   }
@@ -105,7 +105,7 @@
         + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
         + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -258,7 +258,7 @@
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
     assertFalse(verifier.verify("a.bar.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -291,8 +291,8 @@
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
     assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
+    assertFalse(verifier.verify("www.foo.com", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.foo.com", session));
     assertFalse(verifier.verify("a.b.foo.com", session));
   }
 
@@ -325,8 +325,8 @@
         + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
         + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.co.jp", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("foo.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
   }
 
   /**
@@ -451,7 +451,7 @@
         + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
         + "qUYo4ES548JdpQtcLrW2sA==\n"
         + "-----END CERTIFICATE-----");
-    assertTrue(verifier.verify("google.com", session));
+    assertFalse(verifier.verify("google.com", session));
   }
 
   @Test public void subjectAltName() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index f3564997f2..38b2762e6a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -18,6 +18,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
@@ -34,6 +35,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
   // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
@@ -79,6 +81,15 @@
     assertFalse(client.webSocket.send("Hello!"));
   }
 
+  @Test public void clientCloseWith0Fails() throws IOException {
+    try {
+      client.webSocket.close(0, null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+    }
+  }
+
   @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
     client2Server.source().close();
     client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
@@ -294,6 +305,43 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
   }
 
+  @Test public void unacknowledgedPingFailsConnection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // Don't process the ping and pong frames!
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
+  @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.
+    server.webSocket.pong(ByteString.encodeUtf8("pong 1"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 2"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 3"));
+    client.processNextFrame();
+
+    // After 500ms the client automatically pings and the server pongs back.
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d);
+
+    // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
+    // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
   /** One peer's streams, listener, and web socket in the test. */
   private static class TestStreams extends RealWebSocket.Streams {
     private final String name;
@@ -316,8 +364,8 @@ public void initWebSocket(Random random, int pingIntervalMillis) throws IOExcept
           .request(new Request.Builder().url(url).build())
           .protocol(Protocol.HTTP_1_1)
           .build();
-      webSocket = new RealWebSocket(response.request(), listener, random);
-      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
+      webSocket.initReaderAndWriter(name, this);
     }
 
     public boolean processNextFrame() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index 2d38049bf7..1e17baa9c2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -17,26 +17,32 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.Random;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.TestLogHandler;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
@@ -46,6 +52,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.TestUtil.repeat;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -56,7 +63,7 @@
 public final class WebSocketHttpTest {
   @Rule public final MockWebServer webServer = new MockWebServer();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
@@ -76,7 +83,7 @@
     clientListener.assertExhausted();
   }
 
-  @Test public void textMessage() throws IOException {
+  @Test public void textMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -87,7 +94,7 @@
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
-  @Test public void binaryMessage() throws IOException {
+  @Test public void binaryMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -98,7 +105,7 @@
     serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
   }
 
-  @Test public void nullStringThrows() throws IOException {
+  @Test public void nullStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -111,7 +118,7 @@
     }
   }
 
-  @Test public void nullByteStringThrows() throws IOException {
+  @Test public void nullByteStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -124,7 +131,7 @@
     }
   }
 
-  @Test public void serverMessage() throws IOException {
+  @Test public void serverMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -152,7 +159,7 @@
   }
 
   @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
+  @Test public void throwingOnFailLogs() throws Exception {
     TestLogHandler logs = new TestLogHandler();
     Logger logger = Logger.getLogger(OkHttpClient.class.getName());
     logger.addHandler(logs);
@@ -172,7 +179,7 @@
     logger.removeHandler(logs);
   }
 
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -192,7 +199,7 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -208,6 +215,40 @@
 
     server.close(1000, "bye");
     clientListener.assertFailure(e);
+    serverListener.assertFailure();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledByCloseWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+      }
+    });
+
+    server.close(1001, "bye");
+    clientListener.assertClosed(1001, "bye");
+    clientListener.assertExhausted();
+    serverListener.assertClosing(1000,  "");
+    serverListener.assertClosed(1000,  "");
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.close(1001, "bye");
+    clientListener.assertClosing(1001, "bye");
+    clientListener.assertExhausted();
     serverListener.assertExhausted();
   }
 
@@ -227,7 +268,7 @@
         "Expected HTTP 101 response but was '404 Not Found'");
   }
 
-  @Test public void clientTimeoutClosesBody() throws IOException {
+  @Test public void clientTimeoutClosesBody() {
     webServer.enqueue(new MockResponse().setResponseCode(408));
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
@@ -311,7 +352,7 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+  @Test public void webSocketAndApplicationInterceptors() {
     final AtomicInteger interceptedCount = new AtomicInteger();
 
     client = client.newBuilder()
@@ -320,7 +361,7 @@
             assertNull(chain.request().body());
             Response response = chain.proceed(chain.request());
             assertEquals("Upgrade", response.header("Connection"));
-            assertTrue("", response.body().source().exhausted());
+            assertTrue(response.body().source().exhausted());
             interceptedCount.incrementAndGet();
             return response;
           }
@@ -337,10 +378,10 @@
     server.close(1000, null);
   }
 
-  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+  @Test public void webSocketAndNetworkInterceptors() {
     client = client.newBuilder()
         .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
+          @Override public Response intercept(Chain chain) {
             throw new AssertionError(); // Network interceptors don't execute.
           }
         }).build();
@@ -355,7 +396,7 @@
     server.close(1000, null);
   }
 
-  @Test public void overflowOutgoingQueue() throws IOException {
+  @Test public void overflowOutgoingQueue() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -388,7 +429,7 @@
     serverListener.assertClosed(1001, "");
   }
 
-  @Test public void closeReasonMaximumLength() throws IOException {
+  @Test public void closeReasonMaximumLength() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     String clientReason = repeat('C', 123);
@@ -408,7 +449,7 @@
     serverListener.assertClosed(1000, clientReason);
   }
 
-  @Test public void closeReasonTooLong() throws IOException {
+  @Test public void closeReasonTooLong() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -433,35 +474,37 @@
     serverListener.assertClosed(1000, "");
   }
 
-  @Test public void wsScheme() throws IOException {
+  @Test public void wsScheme() {
     websocketScheme("ws");
   }
 
-  @Test public void wsUppercaseScheme() throws IOException {
+  @Test public void wsUppercaseScheme() {
     websocketScheme("WS");
   }
 
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void wssScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("wss");
   }
 
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void httpsScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("https");
   }
 
-  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+  @Test public void readTimeoutAppliesToHttpRequest() {
     webServer.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
 
@@ -476,9 +519,9 @@
    * reading a frame we enable the read timeout. In this test we have the server returning the first
    * byte of a frame but no more frames.
    */
-  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+  @Test public void readTimeoutAppliesWithinFrames() {
     webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      @Override public MockResponse dispatch(RecordedRequest request) {
         return upgradeResponse(request)
             .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
             .removeHeader("Content-Length")
@@ -519,7 +562,7 @@
     RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
 
     long startNanos = System.nanoTime();
-    while (webSocket.pongCount() < 3) {
+    while (webSocket.receivedPongCount() < 3) {
       Thread.sleep(50);
     }
 
@@ -527,12 +570,13 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertEquals(3, server.pingCount());
-    assertEquals(3, webSocket.pongCount());
+    assertEquals(3, webSocket.sentPingCount());
+    assertEquals(3, server.receivedPingCount());
+    assertEquals(3, webSocket.receivedPongCount());
 
     // The server has never pinged the client.
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, server.receivedPongCount());
+    assertEquals(0, webSocket.receivedPingCount());
   }
 
   @Test public void clientDoesNotPingServerByDefault() throws Exception {
@@ -545,14 +589,49 @@
     Thread.sleep(1000);
 
     // No pings and no pongs.
-    assertEquals(0, server.pingCount());
-    assertEquals(0, webSocket.pongCount());
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, webSocket.sentPingCount());
+    assertEquals(0, webSocket.receivedPingCount());
+    assertEquals(0, webSocket.receivedPongCount());
+    assertEquals(0, server.sentPingCount());
+    assertEquals(0, server.receivedPingCount());
+    assertEquals(0, server.receivedPongCount());
+  }
+
+  /**
+   * Configure the websocket to send pings every 500 ms. Artificially prevent the server from
+   * responding to pings. The client should give up when attempting to send its 2nd ping, at about
+   * 1000 ms.
+   */
+  @Test public void unacknowledgedPingFailsConnection() {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Stall in onOpen to prevent pongs from being sent.
+    final CountDownLatch latch = new CountDownLatch(1);
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        try {
+          latch.await(); // The server can't respond to pings!
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+    }));
+
+    long openAtNanos = System.nanoTime();
+    newWebSocket();
+    clientListener.assertOpen();
+    clientListener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    latch.countDown();
+
+    long elapsedUntilFailure = System.nanoTime() - openAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     RealWebSocket webSocket = newWebSocket();
 
@@ -574,6 +653,80 @@
     serverListener.assertClosed(1000, "goodbye");
   }
 
+  @Test public void webSocketsDontTriggerEventListener() {
+    RecordingEventListener listener = new RecordingEventListener();
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("Web Sockets and Events?!");
+    serverListener.assertTextMessage("Web Sockets and Events?!");
+
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, "");
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1000, "");
+
+    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+  }
+
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    Thread.sleep(500);
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  /**
+   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
+   * successful. This test confirms that connections are released back to the connection pool!
+   * https://github.com/square/okhttp/issues/4258
+   */
+  @Test public void webSocketConnectionIsReleased() throws Exception {
+    // This test assumes HTTP/1.1 pooling semantics.
+    client = client.newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
+        .setBody("not found!"));
+    webServer.enqueue(new MockResponse());
+
+    newWebSocket();
+    clientListener.assertFailure();
+
+    Request regularRequest = new Request.Builder()
+        .url(webServer.url("/"))
+        .build();
+    Response response = client.newCall(regularRequest).execute();
+    response.close();
+
+    assertEquals(0, webServer.takeRequest().getSequenceNumber());
+    assertEquals(1, webServer.takeRequest().getSequenceNumber());
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
@@ -583,7 +736,7 @@ private MockResponse upgradeResponse(RecordedRequest request) {
         .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
   }
 
-  private void websocketScheme(String scheme) throws IOException {
+  private void websocketScheme(String scheme) {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     Request request = new Request.Builder()
@@ -603,7 +756,8 @@ private RealWebSocket newWebSocket() {
   }
 
   private RealWebSocket newWebSocket(Request request) {
-    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    RealWebSocket webSocket = new RealWebSocket(
+        request, clientListener, random, client.pingIntervalMillis());
     webSocket.connect(client);
     return webSocket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 21cf06df5d..9fa5d1d9dc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -271,6 +271,13 @@
     callback.assertClosing(1000, "Hello");
   }
 
+  @Test public void closeIncompleteCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("880703e948656c6c6f")); // Close with code and reason
+    data.close();
+    clientReader.processNextFrame();
+    callback.assertClosing(1001, "Hello");
+  }
+
   @Test public void closeOutOfRangeThrows() throws IOException {
     data.write(ByteString.decodeHex("88020001")); // Close with code 1
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index ec043d9f41..f6256ac42f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.Response;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
@@ -108,7 +109,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
     }
   }
 
-  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response)  {
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
     Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
 
     WebSocketListener delegate = this.delegate;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index a303cc1052..e183d0e2a8 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -174,15 +174,19 @@
   }
 
   @Test public void serverBinaryMessage() throws IOException {
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
+
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0232");
-    assertData(binaryData(50));
+    assertData(data);
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0032");
-    assertData(binaryData(50));
+    assertData(data);
 
     sink.close();
     assertData("8000");
@@ -229,28 +233,25 @@
   }
 
   @Test public void clientBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-
-    random.setSeed(0); // Reset the seed so real data matches.
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
 
     BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    byte[] part1 = binaryData(50);
-    sink.write(part1).flush();
-    toggleMask(part1, 50, maskKey1, 0);
+    sink.write(data).flush();
     assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
+    assertData("60b420bb");
+    assertData(""
+        + "0000000058e5f96f1a7fb386dec41920967d0d185a443df4d7"
+        + "c4c9376391d4a65e0ed8230d1332734b796dee2b4495fb4376");
 
-    byte[] part2 = binaryData(50);
-    sink.write(part2).close();
-    toggleMask(part2, 50, maskKey2, 0);
+    sink.write(data).close();
     assertData("80b2");
-    assertData(maskKey2);
-    assertData(part2);
+    assertData("3851d9d4");
+    assertData(""
+        + "58e5f96f00000000429a4ae98621e04fce98f47702a1c49b8f"
+        + "2130583b742dc906eb214c55f6cb1c139c948173a16c941b93");
   }
 
   @Test public void serverEmptyClose() throws IOException {
@@ -385,7 +386,10 @@
   }
 
   private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
+    assertData(ByteString.decodeHex(hex));
+  }
+
+  private void assertData(ByteString expected) throws EOFException {
     ByteString actual = data.readByteString(expected.size());
     assertEquals(expected, actual);
   }
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
new file mode 100644
index 0000000000..2ecaa5c3bf
--- /dev/null
+++ b/okhttp-tls/README.md
@@ -0,0 +1,246 @@
+OkHttp TLS
+==========
+
+Approachable APIs for using TLS.
+
+A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
+[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
+for HTTPS:
+
+```java
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .build();
+```
+
+[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
+Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
+returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
+policy:
+
+```java
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(localhostCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+```
+
+`HandshakeCertificates` also works for clients where its job is to define which root certificates
+to trust. In this simplified example we trust the server's self-signed certificate:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(localhostCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
+handshake. The best part of this example is that we don't need to make our test code insecure with a
+a fake `HostnameVerifier` or `X509TrustManager`.
+
+Certificate Authorities
+-----------------------
+
+The above example uses a self-signed certificate. This is convenient for testing but not
+representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
+to generate a trusted root certificate, an intermediate certificate, and a server certificate.
+We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
+int specifies how many intermediate certificates are allowed beneath it in the chain.
+
+```java
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(1)
+    .build();
+
+HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .signedBy(rootCertificate)
+    .build();
+
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .signedBy(intermediateCertificate)
+    .build();
+```
+
+To serve this configuration the server needs to provide its clients with a chain of certificates
+starting with its own and including everything up-to but not including the root. We don't need to
+include root certificates because the client already has them.
+
+```java
+HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
+    .build();
+```
+
+The client only needs to know the trusted root certificate. It checks the server's certificate by
+validating the signatures within the chain.
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+Client Authentication
+---------------------
+
+The above scenario is representative of most TLS set ups: the client uses certificates to validate
+the identity of a server. The converse is also possible. Here we create a server that authenticates
+a client and a client that authenticates a server.
+
+```java
+// Create the root for client and server to trust. We could also use different roots for each!
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .build();
+
+// Create a server certificate and a server that uses it.
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .commonName("ingen")
+    .addSubjectAlternativeName(server.getHostName())
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(serverCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+server.requestClientAuth();
+server.enqueue(new MockResponse());
+
+// Create a client certificate and a client that uses it.
+HeldCertificate clientCertificate = new HeldCertificate.Builder()
+    .commonName("ianmalcolm")
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(clientCertificate)
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+
+// Connect 'em all together. Certificates are exchanged in the handshake.
+Call call = client.newCall(new Request.Builder()
+    .url(server.url("/"))
+    .build());
+Response response = call.execute();
+System.out.println(response.handshake().peerPrincipal());
+RecordedRequest recordedRequest = server.takeRequest();
+System.out.println(recordedRequest.getHandshake().peerPrincipal());
+```
+
+This handshake is successful because each party has prearranged to trust the root certificate that
+signs the other party's chain.
+
+Well-Known Certificate Authorities
+----------------------------------
+
+In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
+Internet this set of trusted root certificates is usually provided by default by the host platform.
+Such a set typically includes many root certificates from well-known certificate authorities like
+Entrust and Verisign.
+
+This is the behavior you'll get with your OkHttpClient if you don't specifically configure
+`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addPlatformTrustedCertificates()
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+PEM files
+---------
+
+You can encode a `HeldCertificate` in PEM format:
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.certificatePem())
+```
+
+```
+-----BEGIN CERTIFICATE-----
+MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
+LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
+ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
+LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
+zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
+k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
+msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
+-----END CERTIFICATE-----
+```
+
+You can also do so with the private key. Be careful with these!
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.privateKeyPkcs8Pem())
+```
+
+```
+-----BEGIN PRIVATE KEY-----
+MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
+IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
+SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
+OdHOim9+
+-----END PRIVATE KEY-----
+```
+
+Recommendations
+---------------
+
+Typically servers need a held certificate plus a chain of intermediates. Servers only need the
+private key for their own certificate. The chain served by a server doesn't need the root
+certificate.
+
+The trusted roots don't need to be the same for client and server when using client authentication.
+Clients might rely on the platform certificates and servers might use a private
+organization-specific certificate authority.
+
+By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
+
+By default server certificates need to identify which hostnames they're trusted for. You may add as
+many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
+form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
+
+By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
+clients use `HeldCertificate.Builder.rsa2048()`.
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-tls</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle
+```groovy
+implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
+```
+
+ [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
+ [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
+ [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
+ [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
new file mode 100644
index 0000000000..dfdde62651
--- /dev/null
+++ b/okhttp-tls/pom.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tls</artifactId>
+  <name>OkHttp Transport Layer Security (TLS)</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>okhttp3.tls.internal:okhttp3.tls.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.tls</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
new file mode 100644
index 0000000000..34e9e9a497
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+
+/**
+ * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
+ * Client and server exchange these certificates during the handshake phase of a TLS connection.
+ *
+ * <h3>Server Authentication</h3>
+ *
+ * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
+ * and that they own the hostnames that they represent. Server authentication is required.
+ *
+ * <p>To perform server authentication:
+ *
+ * <ul>
+ *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The certificate's subject alternative
+ *       names must match the server's hostname. The server must also have is a (possibly-empty)
+ *       chain of intermediate certificates to establish trust from a root certificate to the
+ *       server's certificate. The root certificate is not included in this chain.
+ *   <li>The client's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the server's certificate chain. Typically this is a set of
+ *       well-known root certificates that is distributed with the HTTP client or its platform. It
+ *       may be augmented by certificates private to an organization or service.
+ * </ul>
+ *
+ * <h3>Client Authentication</h3>
+ *
+ * <p>This is authentication of the client by the server during the TLS handshake. Client
+ * authentication is optional.
+ *
+ * <p>To perform client authentication:
+ *
+ * <ul>
+ *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The client must also have a
+ *       (possibly-empty) chain of intermediate certificates to establish trust from a root
+ *       certificate to the client's certificate. The root certificate is not included in this
+ *       chain.
+ *   <li>The server's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the client's certificate chain. Typically this is not the same
+ *       set of root certificates used in server authentication. Instead it will be a small set of
+ *       roots private to an organization or service.
+ * </ul>
+ */
+public final class HandshakeCertificates {
+  private final X509KeyManager keyManager;
+  private final X509TrustManager trustManager;
+
+  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
+    this.keyManager = keyManager;
+    this.trustManager = trustManager;
+  }
+
+  public X509KeyManager keyManager() {
+    return keyManager;
+  }
+
+  public X509TrustManager trustManager() {
+    return trustManager;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslContext().getSocketFactory();
+  }
+
+  public SSLContext sslContext() {
+    try {
+      SSLContext sslContext = Platform.get().getSSLContext();
+      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
+          new SecureRandom());
+      return sslContext;
+    } catch (KeyManagementException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static final class Builder {
+    private @Nullable HeldCertificate heldCertificate;
+    private @Nullable X509Certificate[] intermediates;
+
+    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
+
+    /**
+     * Configure the certificate chain to use when being authenticated. The first certificate is
+     * the held certificate, further certificates are included in the handshake so the peer can
+     * build a trusted path to a trusted root certificate.
+     *
+     * <p>The chain should include all intermediate certificates but does not need the root
+     * certificate that we expect to be known by the remote peer. The peer already has that
+     * certificate so transmitting it is unnecessary.
+     */
+    public Builder heldCertificate(HeldCertificate heldCertificate,
+        X509Certificate... intermediates) {
+      this.heldCertificate = heldCertificate;
+      this.intermediates = intermediates.clone(); // Defensive copy.
+      return this;
+    }
+
+    /**
+     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
+     * a chain of certificates whose root is one of these.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.trustedCertificates.add(certificate);
+      return this;
+    }
+
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
+    public HandshakeCertificates build() {
+      try {
+        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
+        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
+        return new HandshakeCertificates(keyManager, trustManager);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
new file mode 100644
index 0000000000..8709dc1438
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
@@ -0,0 +1,434 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.X509Certificate;
+import java.security.interfaces.RSAPrivateKey;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.security.auth.x500.X500Principal;
+import okio.ByteString;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A certificate and its private key. These are some properties of certificates that are used with
+ * TLS:
+ *
+ * <ul>
+ *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
+ *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
+ *       or "www.squareup.com".
+ *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
+ *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
+ *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
+ *       *.api.squareup.com}).
+ *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
+ *       interval starts or after it ends.
+ *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
+ *       digital signatures. Note that the private key is not a part of the certificate!
+ *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
+ *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
+ *       certificates once they've confirmed that the owner of the private key is also the owner of
+ *       the certificate's other properties.
+ * </ul>
+ *
+ * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
+ * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
+ * middle of the chain are called "intermediates". Organizations that offer certificate signing are
+ * called certificate authorities (CAs).
+ *
+ * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
+ * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
+ * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
+ * clients to trust.
+ *
+ * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
+ * these three certificates are used. <pre>{@code
+ *
+ * www.squareup.com certificate:
+ *
+ *   Common Name: www.squareup.com
+ *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
+ *   Validity: 2018-07-03T20:18:17Z – 2019-08-01T20:48:15Z
+ *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
+ *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
+ *
+ * signed by intermediate certificate:
+ *
+ *   Common Name: Entrust Certification Authority - L1M
+ *   Subject Alternative Names: none
+ *   Validity: 2014-12-15T15:25:03Z – 2030-10-15T15:55:03Z
+ *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
+ *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
+ *
+ * signed by root certificate:
+ *
+ *   Common Name: Entrust Root Certification Authority - G2
+ *   Subject Alternative Names: none
+ *   Validity: 2009-07-07T17:25:54Z – 2030-12-07T17:55:54Z
+ *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
+ *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
+ *
+ * }</pre>
+ *
+ * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
+ * Certification Authority - G2". That certificate is used to verify the signature of the
+ * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
+ * is used to verify the signature of the "www.squareup.com" certificate.
+ *
+ * <p>This roles are reversed for client authentication. In that case the client has a private key
+ * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
+ * the client. Subject alternative names are not used for client authentication.
+ */
+public final class HeldCertificate {
+  private final X509Certificate certificate;
+  private final KeyPair keyPair;
+
+  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
+    if (keyPair == null) throw new NullPointerException("keyPair == null");
+    if (certificate == null) throw new NullPointerException("certificate == null");
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public X509Certificate certificate() {
+    return certificate;
+  }
+
+  public KeyPair keyPair() {
+    return keyPair;
+  }
+
+  /**
+   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
+   * format</a>.
+   */
+  public String certificatePem() {
+    try {
+      StringBuilder result = new StringBuilder();
+      result.append("-----BEGIN CERTIFICATE-----\n");
+      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
+      result.append("-----END CERTIFICATE-----\n");
+      return result.toString();
+    } catch (CertificateEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
+   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs8Pem() {
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN PRIVATE KEY-----\n");
+    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
+    result.append("-----END PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
+   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs1Pem() {
+    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
+      throw new IllegalStateException("PKCS1 only supports RSA keys");
+    }
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
+    encodeBase64Lines(result, pkcs1Bytes());
+    result.append("-----END RSA PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  private ByteString pkcs1Bytes() {
+    try {
+      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
+      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private void encodeBase64Lines(StringBuilder out, ByteString data) {
+    String base64 = data.base64();
+    for (int i = 0; i < base64.length(); i += 64) {
+      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
+    }
+  }
+
+  /** Build a held certificate with reasonable defaults. */
+  public static final class Builder {
+    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
+
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private long notBefore = -1L;
+    private long notAfter = -1L;
+    private @Nullable String cn;
+    private @Nullable String ou;
+    private final List<String> altNames = new ArrayList<>();
+    private @Nullable BigInteger serialNumber;
+    private @Nullable KeyPair keyPair;
+    private @Nullable HeldCertificate signedBy;
+    private int maxIntermediateCas = -1;
+    private @Nullable String keyAlgorithm;
+    private int keySize;
+
+    public Builder() {
+      ecdsa256();
+    }
+
+    /**
+     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
+     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
+     * to use the default interval, 24 hours starting when the certificate is created.
+     */
+    public Builder validityInterval(long notBefore, long notAfter) {
+      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
+        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
+      }
+      this.notBefore = notBefore;
+      this.notAfter = notAfter;
+      return this;
+    }
+
+    /**
+     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
+     * The precision of this field is seconds; further precision will be truncated.
+     */
+    public Builder duration(long duration, TimeUnit unit) {
+      long now = System.currentTimeMillis();
+      return validityInterval(now, now + unit.toMillis(duration));
+    }
+
+    /**
+     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
+     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
+     * extension will be omitted.
+     */
+    public Builder addSubjectAlternativeName(String altName) {
+      if (altName == null) throw new NullPointerException("altName == null");
+      altNames.add(altName);
+      return this;
+    }
+
+    /**
+     * Set this certificate's common name (CN). Historically this held the hostname of TLS
+     * certificate, but that practice was deprecated by <a
+     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
+     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
+     * be used.
+     */
+    public Builder commonName(String cn) {
+      this.cn = cn;
+      return this;
+    }
+
+    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
+    public Builder organizationalUnit(String ou) {
+      this.ou = ou;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(BigInteger serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(long serialNumber) {
+      return serialNumber(BigInteger.valueOf(serialNumber));
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
+      return keyPair(new KeyPair(publicKey, privateKey));
+    }
+
+    /**
+     * Set the certificate that will issue this certificate. If unset the certificate will be
+     * self-signed.
+     */
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
+     * intermediate signing certificates beneath it.
+     *
+     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
+     * certificate can sign other certificates (but those certificates cannot themselves sign
+     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
+     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
+     */
+    public Builder certificateAuthority(int maxIntermediateCas) {
+      if (maxIntermediateCas < 0) {
+        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
+      }
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
+     * security. ECDSA keys are noticeably faster than RSA keys.
+     *
+     * <p>This is the default configuration and has been since this API was introduced in OkHttp
+     * 3.11.0. Note that the default may change in future releases.
+     */
+    public Builder ecdsa256() {
+      keyAlgorithm = "EC";
+      keySize = 256;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
+     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
+     */
+    public Builder rsa2048() {
+      keyAlgorithm = "RSA";
+      keySize = 2048;
+      return this;
+    }
+
+    public HeldCertificate build() {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+
+      X500Principal subject = buildSubject();
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
+      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
+      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(serialNumber);
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(notBefore));
+      generator.setNotAfter(new Date(notAfter));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
+          ? "SHA256WithRSAEncryption"
+          : "SHA256withECDSA");
+
+      if (maxIntermediateCas != -1) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
+      try {
+        X509Certificate certificate = generator.generateX509Certificate(
+            signedByKeyPair.getPrivate());
+        return new HeldCertificate(heldKeyPair, certificate);
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    private X500Principal buildSubject() {
+      StringBuilder nameBuilder = new StringBuilder();
+      if (cn != null) {
+        nameBuilder.append("CN=").append(cn);
+      } else {
+        nameBuilder.append("CN=").append(UUID.randomUUID());
+      }
+      if (ou != null) {
+        nameBuilder.append(", OU=").append(ou);
+      }
+      return new X500Principal(nameBuilder.toString());
+    }
+
+    private KeyPair generateKeyPair() {
+      try {
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
+        keyPairGenerator.initialize(keySize, new SecureRandom());
+        return keyPairGenerator.generateKeyPair();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
new file mode 100644
index 0000000000..b127b36861
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
+
+public final class TlsUtil {
+  public static final char[] password = "password".toCharArray();
+  private static HandshakeCertificates localhost; // Lazily initialized.
+
+  private TlsUtil() {
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized HandshakeCertificates localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .commonName("localhost")
+          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
+          .build();
+
+      localhost = new HandshakeCertificates.Builder()
+          .heldCertificate(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate())
+          .build();
+
+      return localhost;
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** Returns a trust manager that trusts {@code trustedCertificates}. */
+  public static X509TrustManager newTrustManager(String keyStoreType,
+      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
+    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
+    TrustManagerFactory factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    factory.init(trustStore);
+    TrustManager[] result = factory.getTrustManagers();
+    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
+    }
+    return (X509TrustManager) result[0];
+  }
+
+  /**
+   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
+   * {@code heldCertificate} is null.
+   */
+  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
+
+    if (heldCertificate != null) {
+      Certificate[] chain = new Certificate[1 + intermediates.length];
+      chain[0] = heldCertificate.certificate();
+      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
+      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
+    }
+
+    KeyManagerFactory factory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    factory.init(keyStore, password);
+    KeyManager[] result = factory.getKeyManagers();
+    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
+      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
+    }
+    return (X509KeyManager) result[0];
+  }
+
+  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
+    if (keyStoreType == null) {
+      keyStoreType = KeyStore.getDefaultType();
+    }
+
+    try {
+      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
new file mode 100644
index 0000000000..061e524be6
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
@@ -0,0 +1,3 @@
+/** OkHttp Transport Layer Security (TLS) library. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
new file mode 100644
index 0000000000..c2e4f3a45f
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
+import okhttp3.internal.Util;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class HandshakeCertificatesTest {
+  private ExecutorService executorService;
+  private ServerSocket serverSocket;
+
+  @Before public void setUp() {
+    executorService = Executors.newCachedThreadPool();
+  }
+
+  @After public void tearDown() {
+    executorService.shutdown();
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Test public void clientAndServer() throws Exception {
+    HeldCertificate clientRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(clientRoot)
+        .build();
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientIntermediate)
+        .build();
+
+    HeldCertificate serverRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(serverRoot)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverIntermediate)
+        .build();
+
+    HandshakeCertificates server = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientRoot.certificate())
+        .heldCertificate(serverCertificate, serverIntermediate.certificate())
+        .build();
+
+    HandshakeCertificates client = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRoot.certificate())
+        .heldCertificate(clientCertificate, clientIntermediate.certificate())
+        .build();
+
+    InetSocketAddress serverAddress = startTlsServer();
+    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
+    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
+
+    Handshake serverHandshake = serverHandshakeFuture.get();
+    assertEquals(serverHandshake.peerCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+    assertEquals(serverHandshake.localCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+
+    Handshake clientHandshake = clientHandshakeFuture.get();
+    assertEquals(clientHandshake.peerCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+    assertEquals(clientHandshake.localCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+
+  }
+
+  @Test public void keyManager() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate intermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(root)
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .signedBy(intermediate)
+        .build();
+
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediate.certificate())
+        .build();
+    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
+        handshakeCertificates.keyManager().getPrivateKey("private"));
+    assertEquals(Arrays.asList(certificate.certificate(), intermediate.certificate()),
+        Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private")));
+  }
+
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf(" ")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertTrue(names.toString(), names.contains("CN=Entrust"));
+  }
+
+  private InetSocketAddress startTlsServer() throws IOException {
+    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+    serverSocket = serverSocketFactory.createServerSocket();
+    InetAddress serverAddress = InetAddress.getByName("localhost");
+    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
+    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
+  }
+
+  private Future<Handshake> doServerHandshake(final HandshakeCertificates server) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = null;
+        SSLSocket sslSocket = null;
+        try {
+          rawSocket = serverSocket.accept();
+          sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.setUseClientMode(false);
+          sslSocket.setWantClientAuth(true);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private Future<Handshake> doClientHandshake(
+      final HandshakeCertificates client, final InetSocketAddress serverAddress) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = SocketFactory.getDefault().createSocket();
+        rawSocket.connect(serverAddress);
+        SSLSocket sslSocket = null;
+        try {
+          sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
+    assertEquals(ByteString.of(expected.getEncoded()), ByteString.of(actual.getEncoded()));
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
new file mode 100644
index 0000000000..ffec150f32
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.math.BigInteger;
+import java.security.KeyFactory;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.ByteString;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class HeldCertificateTest {
+  @Test public void defaultCertificate() throws CertificateParsingException {
+    long now = System.currentTimeMillis();
+    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("self-signed",
+        certificate.getIssuerX500Principal().getName(),
+        certificate.getSubjectX500Principal().getName());
+    assertTrue(certificate.getIssuerX500Principal().getName().matches("CN=[0-9a-f-]{36}"));
+    assertEquals(BigInteger.ONE, certificate.getSerialNumber());
+    assertNull(certificate.getSubjectAlternativeNames());
+
+    double deltaMillis = 1000.0;
+    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+  }
+
+  @Test public void customInterval() {
+    // 5 seconds starting on 1970-01-01.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .validityInterval(5_000L, 10_000L)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals(5_000L, certificate.getNotBefore().getTime());
+    assertEquals(10_000L, certificate.getNotAfter().getTime());
+  }
+
+  @Test public void customDuration() {
+    long now = System.currentTimeMillis();
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .duration(5, TimeUnit.SECONDS)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+
+    double deltaMillis = 1000.0;
+    long durationMillis = 5_000L;
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+  }
+
+  @Test public void subjectAlternativeNames() throws CertificateParsingException {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName("1.1.1.1")
+        .addSubjectAlternativeName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    List<List<?>> subjectAlternativeNames = new ArrayList<>(
+        certificate.getSubjectAlternativeNames());
+    assertEquals(subjectAlternativeNames, Arrays.asList(
+        Arrays.asList(GeneralName.iPAddress, "1.1.1.1"),
+        Arrays.asList(GeneralName.dNSName, "cash.app")));
+  }
+
+  @Test public void commonName() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app", certificate.getSubjectX500Principal().getName());
+  }
+
+  @Test public void organizationalUnit() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .organizationalUnit("cash")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app,OU=cash", certificate.getSubjectX500Principal().getName());
+  }
+
+  /** Confirm golden values of encoded PEMs. */
+  @Test public void pems() throws Exception {
+    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
+
+    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
+        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
+        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
+    PublicKey publicKey = keyFactory.generatePublic(
+        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
+
+    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
+        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
+        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
+        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
+        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
+        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
+        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
+        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
+        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
+        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
+        + "XH+NyxKwboE");
+    PrivateKey privateKey = keyFactory.generatePrivate(
+        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .keyPair(publicKey, privateKey)
+        .commonName("cash.app")
+        .validityInterval(0L, 1_000L)
+        .rsa2048()
+        .build();
+
+    assertEquals(heldCertificate.certificatePem(), ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
+        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
+        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
+        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
+        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
+        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
+        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
+        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
+        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
+        + "-----END CERTIFICATE-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs1Pem(), ""
+        + "-----BEGIN RSA PRIVATE KEY-----\n"
+        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
+        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
+        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
+        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
+        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
+        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
+        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
+        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
+        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
+        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
+        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
+        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
+        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
+        + "-----END RSA PRIVATE KEY-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs8Pem(), ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
+        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
+        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
+        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
+        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
+        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
+        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
+        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
+        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
+        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
+        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
+        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
+        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
+        + "UXH+NyxKwboE\n"
+        + "-----END PRIVATE KEY-----\n");
+  }
+
+  @Test public void ecdsaSignedByRsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHRSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHRSA", leaf.certificate().getSigAlgName());
+  }
+
+  @Test public void rsaSignedByEcdsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHECDSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHECDSA", leaf.certificate().getSigAlgName());
+  }
+}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 64d479751f..86537f25b8 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -35,6 +35,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -54,6 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -61,6 +68,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.urlconnection</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index b5440a4d02..94eb4558c2 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -22,12 +22,14 @@
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.util.List;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 
 /**
  * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
  * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
  * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
  */
+@EverythingIsNonNull
 public final class JavaNetAuthenticator implements Authenticator {
   @Override public Request authenticate(Route route, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
@@ -54,7 +56,8 @@
       }
 
       if (auth != null) {
-        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        String credential = Credentials.basic(
+            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
         return request.newBuilder()
             .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
             .build();
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
index 5d4f671a31..c6cca30184 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 import okhttp3.internal.platform.Platform;
 
 import static okhttp3.internal.Util.delimiterOffset;
@@ -29,6 +30,7 @@
 import static okhttp3.internal.platform.Platform.WARN;
 
 /** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+@EverythingIsNonNull
 public final class JavaNetCookieJar implements CookieJar {
   private final CookieHandler cookieHandler;
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 0bbe613492..f4e88161c9 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -22,6 +22,7 @@
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
 import okhttp3.internal.URLFilter;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.huc.OkHttpsURLConnection;
 
@@ -30,6 +31,7 @@
  * upcoming release. Applications that need this should either downgrade to the system's built-in
  * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
  */
+@EverythingIsNonNull
 public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
   private OkHttpClient client;
   private URLFilter urlFilter;
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 344a61e446..31e532d0ad 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -23,10 +23,12 @@
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.Arrays;
 import java.util.Collections;
@@ -50,13 +52,13 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.platform.Platform;
+import okio.Buffer;
 
 import static okhttp3.internal.platform.Platform.WARN;
 
@@ -132,6 +134,7 @@ public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
           throw propagate(callFailure);
         }
       } catch (InterruptedException e) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
         throw new InterruptedIOException();
       }
     }
@@ -369,8 +372,22 @@ private Call buildCall() throws IOException {
       requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
     }
 
+    HttpUrl url;
+    try {
+      url = HttpUrl.get(getURL().toString());
+    } catch (IllegalArgumentException e) {
+      if (Internal.instance.isInvalidHttpUrlHost(e)) {
+        UnknownHostException unknownHost = new UnknownHostException();
+        unknownHost.initCause(e);
+        throw unknownHost;
+      }
+      MalformedURLException malformedUrl = new MalformedURLException();
+      malformedUrl.initCause(e);
+      throw malformedUrl;
+    }
+
     Request request = new Request.Builder()
-        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .url(url)
         .headers(requestHeaders.build())
         .method(method, requestBody)
         .build();
@@ -398,7 +415,25 @@ private Call buildCall() throws IOException {
 
   private String defaultUserAgent() {
     String agent = System.getProperty("http.agent");
-    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+    return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  private static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      buffer.writeUtf8CodePoint('?');
+      for (int j = i + Character.charCount(c); j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
   }
 
   /**
@@ -427,6 +462,7 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
             lock.wait(); // Wait until the response is returned or the call fails.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
@@ -616,6 +652,7 @@ public void proceed() {
             lock.wait(); // Wait until proceed() is called.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
index 0057174226..9dc40b80a2 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -58,6 +58,9 @@ public OkHttpsURLConnection(OkHttpURLConnection delegate) {
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    if (sslSocketFactory == null) {
+      throw new IllegalArgumentException("sslSocketFactory == null");
+    }
     // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
     delegate.client = delegate.client.newBuilder()
         .sslSocketFactory(sslSocketFactory)
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index d0f706f0d0..914725fb84 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -2,8 +2,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -14,9 +17,10 @@
 import okhttp3.internal.URLFilter;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Before;
@@ -24,6 +28,7 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static okio.Okio.buffer;
 import static okio.Okio.source;
 import static org.junit.Assert.assertEquals;
@@ -36,7 +41,7 @@
   private OkUrlFactory factory;
   private Cache cache;
 
-  @Before public void setUp() throws IOException {
+  @Before public void setUp() {
     cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
     OkHttpClient client = new OkHttpClient.Builder()
         .cache(cache)
@@ -52,7 +57,7 @@
    * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
    * an origin server.
    */
-  @Test public void originServerSends407() throws Exception {
+  @Test public void originServerSends407() {
     server.enqueue(new MockResponse().setResponseCode(407));
 
     HttpURLConnection conn = factory.open(server.url("/").url());
@@ -177,16 +182,17 @@ public void checkURLPermitted(URL url) throws IOException {
   }
 
   @Test
-  public void testURLFilterRedirect() throws Exception {
+  public void testURLFilterRedirect() {
     MockWebServer cleartextServer = new MockWebServer();
     cleartextServer.enqueue(new MockResponse()
         .setBody("Blocked!"));
     final URL blockedURL = cleartextServer.url("/").url();
 
-    SslClient contextBuilder = SslClient.localhost();
-    server.useHttps(contextBuilder.socketFactory, false);
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .followSslRedirects(true)
         .build());
     factory.setUrlFilter(new URLFilter() {
@@ -211,6 +217,71 @@ public void checkURLPermitted(URL url) throws IOException {
     }
   }
 
+  @Test public void usesValidHeaderValueForDefaultUserAgent() throws Exception {
+    String userAgent =  "🍩 " + "\u001F" + ('\u001f' + 1) + ('\u007f' - 1)+ '\u007f' + " 🍩";
+    String expected = "? ?" + ('\u001f' + 1) + ('\u007f' - 1) + "? ?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void usesSimpleDefaultUserAgentWithoutModification() throws Exception {
+    String userAgent = "OkHttp";
+    String expected = "OkHttp";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void handlesBadUnicodeStringsInDefaultUserAgent() throws Exception {
+    String userAgent =  "🔊".substring(0, 1);
+    String expected = "?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void javaNetUrlMalformedUrl() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://example.com:-1"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (MalformedURLException expected) {
+    }
+  }
+
+  @Test public void javaNetUrlBadHost() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://hostw ithspace/"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
     BufferedSource source = buffer(source(connection.getInputStream()));
     String actual = source.readString(US_ASCII);
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index ab4af9a350..23ff40c89e 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -44,10 +44,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -58,6 +58,7 @@
 import org.junit.Test;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -79,12 +80,12 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
     urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
@@ -98,7 +99,7 @@
     cache.delete();
   }
 
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+  @Test public void responseCacheAccessWithOkHttpMember() {
     assertSame(cache, urlFactory.client().cache());
   }
 
@@ -262,13 +263,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
 
@@ -280,7 +282,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
@@ -340,7 +342,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
@@ -351,7 +353,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -377,7 +380,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
@@ -389,7 +392,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -412,7 +416,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1079,7 +1083,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1407,7 +1411,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void varyAndHttps() throws Exception {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
@@ -1415,13 +1419,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URL url = server.url("/").url();
     HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
     HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1805,8 +1809,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index e2a9a723bc..a16a6c1b27 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
@@ -27,6 +32,12 @@
       <artifactId>jsr305</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>1.17</version>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -46,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -53,6 +65,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 9e34bc9706..10482ffead 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -19,17 +19,50 @@
 import javax.annotation.Nullable;
 
 /**
- * Responds to an authentication challenge from either a remote web server or a proxy server.
- * Implementations may either attempt to satisfy the challenge by returning a request that includes
- * an authorization header, or they may refuse the challenge by returning null. In this case the
- * unauthenticated response will be returned to the caller that triggered it.
+ * Performs either <strong>preemptive</strong> authentication before connecting to a proxy server,
+ * or <strong>reactive</strong> authentication after receiving a challenge from either an origin web
+ * server or proxy server.
+ *
+ * <h3>Preemptive Authentication</h3>
+ *
+ * <p>To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
+ * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by <a
+ * href="https://tools.ietf.org/html/rfc2817">RFC 2817</a>. The HTTP CONNECT request that creates
+ * this tunnel connection is special: it does not participate in any {@linkplain Interceptor
+ * interceptors} or {@linkplain EventListener event listeners}. It doesn't include the motivating
+ * request's HTTP headers or even its full URL; only the target server's hostname is sent to the
+ * proxy.
+ *
+ * <p>Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it
+ * may prepare preemptive authentication. OkHttp will call {@link #authenticate} with a fake {@code
+ * HTTP/1.1 407 Proxy Authentication Required} response that has a {@code Proxy-Authenticate:
+ * OkHttp-Preemptive} challenge. The proxy authenticator may return either either an authenticated
+ * request, or null to connect without authentication.
+ * <pre>   {@code
+ *    for (Challenge challenge : response.challenges()) {
+ *      // If this is preemptive auth, use a preemptive credential.
+ *      if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
+ *        return response.request().newBuilder()
+ *            .header("Proxy-Authorization", "secret")
+ *            .build();
+ *      }
+ *    }
+ *
+ *    return null; // Didn't find a preemptive auth scheme.
+ * }</pre>
+ *
+ * <h3>Reactive Authentication</h3>
+ *
+ * <p>Implementations authenticate by returning a follow-up request that includes an authorization
+ * header, or they may decline the challenge by returning null. In this case the unauthenticated
+ * response will be returned to the caller that triggered it.
  *
  * <p>Implementations should check if the initial request already included an attempt to
  * authenticate. If so it is likely that further attempts will not be useful and the authenticator
  * should give up.
  *
- * <p>When authentication is requested by an origin server, the response code is 401 and the
- * implementation should respond with a new request that sets the "Authorization" header.
+ * <p>When reactive authentication is requested by an origin web server, the response code is 401
+ * and the implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
  *    if (response.request().header("Authorization") != null) {
@@ -42,7 +75,7 @@
  *        .build();
  * }</pre>
  *
- * <p>When authentication is requested by a proxy server, the response code is 407 and the
+ * <p>When reactive authentication is requested by a proxy server, the response code is 407 and the
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
@@ -56,13 +89,16 @@
  *        .build();
  * }</pre>
  *
+ * <p>The proxy authenticator may implement preemptive authentication, reactive authentication, or
+ * both.
+ *
  * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
  * or both.
  */
 public interface Authenticator {
   /** An authenticator that knows no credentials and makes no attempt to authenticate. */
   Authenticator NONE = new Authenticator() {
-    @Override public Request authenticate(Route route, Response response) {
+    @Override public Request authenticate(@Nullable Route route, Response response) {
       return null;
     }
   };
@@ -70,6 +106,10 @@
   /**
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
+   *
+   * <p>The route is best effort, it currently may not always be provided even when logically
+   * available. It may also not be provided when an authenticator is re-used manually in an
+   * application interceptor, such as when implementing client-specific retries.
    */
-  @Nullable Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index d43d91d257..343df45113 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -175,6 +175,9 @@
   private int hitCount;
   private int requestCount;
 
+  /**
+   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
+   */
   public Cache(File directory, long maxSize) {
     this(directory, maxSize, FileSystem.SYSTEM);
   }
@@ -379,6 +382,7 @@ public long size() throws IOException {
     return cache.size();
   }
 
+  /** Max size of the cache (in bytes). */
   public long maxSize() {
     return cache.getMaxSize();
   }
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 58b17bf405..a32add5f97 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -8,8 +8,7 @@
  * A Cache-Control header with cache directives from a server or client. These directives set policy
  * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
- * 14.9</a>.
+ * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
  */
 public final class CacheControl {
   /**
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad21..67d0f88d3d 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import okio.Timeout;
 
 /**
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
@@ -32,7 +33,7 @@
    * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
    * close the underlying {@link ResponseBody}.
    *
-   * <pre>@{code
+   * <pre>{@code
    *
    *   // ensure the response (and underlying response body) is closed
    *   try (Response response = client.newCall(request).execute()) {
@@ -80,6 +81,15 @@
 
   boolean isCanceled();
 
+  /**
+   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+   * body, server processing, and reading the response body. If the call requires redirects or
+   * retries all must complete within one timeout period.
+   *
+   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
+   */
+  Timeout timeout();
+
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 1d8eb97750..d509364544 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -182,7 +182,7 @@ public void check(String hostname, List<Certificate> peerCertificates)
           if (sha1 == null) sha1 = sha1(x509Certificate);
           if (pin.hash.equals(sha1)) return; // Success!
         } else {
-          throw new AssertionError();
+          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
         }
       }
     }
@@ -226,7 +226,8 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner withCertificateChainCleaner(
+      @Nullable CertificateChainCleaner certificateChainCleaner) {
     return equal(this.certificateChainCleaner, certificateChainCleaner)
         ? this
         : new CertificatePinner(pins, certificateChainCleaner);
@@ -267,8 +268,8 @@ static ByteString sha256(X509Certificate x509Certificate) {
     Pin(String pattern, String pin) {
       this.pattern = pattern;
       this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.parse("http://" + pattern).host();
+          ? HttpUrl.get("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.get("http://" + pattern).host();
       if (pin.startsWith("sha1/")) {
         this.hashAlgorithm = "sha1/";
         this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index 196de325b8..bff1cb830e 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,18 +15,47 @@
  */
 package okhttp3;
 
+import java.nio.charset.Charset;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
 import javax.annotation.Nullable;
 
-/** An RFC 2617 challenge. */
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Locale.US;
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** An RFC 7235 challenge. */
 public final class Challenge {
   private final String scheme;
-  private final String realm;
+  private final Map<String, String> authParams;
+
+  public Challenge(String scheme, Map<String, String> authParams) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (authParams == null) throw new NullPointerException("authParams == null");
+    this.scheme = scheme;
+    Map<String, String> newAuthParams = new LinkedHashMap<>();
+    for (Entry<String, String> authParam : authParams.entrySet()) {
+      String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US);
+      newAuthParams.put(key, authParam.getValue());
+    }
+    this.authParams = unmodifiableMap(newAuthParams);
+  }
 
   public Challenge(String scheme, String realm) {
     if (scheme == null) throw new NullPointerException("scheme == null");
     if (realm == null) throw new NullPointerException("realm == null");
     this.scheme = scheme;
-    this.realm = realm;
+    this.authParams = singletonMap("realm", realm);
+  }
+
+  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
+  public Challenge withCharset(Charset charset) {
+    if (charset == null) throw new NullPointerException("charset == null");
+    Map<String, String> authParams = new LinkedHashMap<>(this.authParams);
+    authParams.put("charset", charset.name());
+    return new Challenge(scheme, authParams);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -34,25 +63,45 @@ public String scheme() {
     return scheme;
   }
 
+  /**
+   * Returns the auth params, including {@code realm} and {@code charset} if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  public Map<String, String> authParams() {
+    return authParams;
+  }
+
   /** Returns the protection space. */
   public String realm() {
-    return realm;
+    return authParams.get("realm");
+  }
+
+  /** Returns the charset that should be used to encode the credentials. */
+  public Charset charset() {
+    String charset = authParams.get("charset");
+    if (charset != null) {
+      try {
+        return Charset.forName(charset);
+      } catch (Exception ignore) {
+      }
+    }
+    return ISO_8859_1;
   }
 
   @Override public boolean equals(@Nullable Object other) {
     return other instanceof Challenge
         && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).realm.equals(realm);
+        && ((Challenge) other).authParams.equals(authParams);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + realm.hashCode();
     result = 31 * result + scheme.hashCode();
+    result = 31 * result + authParams.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme + " realm=\"" + realm + "\"";
+    return scheme + " authParams=" + authParams;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index a71ddc5ed9..ec1875359b 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -18,9 +18,9 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -29,10 +29,16 @@
  * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
  * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
  * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 20) or Java (through JDK 8) are omitted for brevity.
+ * 24) or Java (through JDK 9) are omitted for brevity.
  *
- * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Android.
+ * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
+ * which lists the cipher suites supported by Android.
+ *
+ * <p>See <a href="https://docs.oracle.com/javase/10/security/oracle-providers.htm">JDK 10 Providers</a>
+ * which lists the cipher suites supported by Oracle.
+ *
+ * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
+ * from conscrypt, which lists the cipher suites supported by Conscrypt.
  */
 public final class CipherSuite {
   /**
@@ -55,339 +61,346 @@
   };
 
   /**
-   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * Holds interned instances. This needs to be above the init() calls below so that it's
    * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
    */
-  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
+  private static final Map<String, CipherSuite> INSTANCES = new LinkedHashMap<>();
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
 
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+
+  // TLS 1.3 https://tools.ietf.org/html/rfc8446
+  public static final CipherSuite TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301);
+  public static final CipherSuite TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302);
+  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
+  public static final CipherSuite TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304);
+  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = init("TLS_AES_256_CCM_8_SHA256", 0x1305);
 
   final String javaName;
 
@@ -398,12 +411,28 @@
   public static synchronized CipherSuite forJavaName(String javaName) {
     CipherSuite result = INSTANCES.get(javaName);
     if (result == null) {
-      result = new CipherSuite(javaName);
+      result = INSTANCES.get(secondaryName(javaName));
+
+      if (result == null) {
+        result = new CipherSuite(javaName);
+      }
+
+      // Add the new cipher suite, or a confirmed alias.
       INSTANCES.put(javaName, result);
     }
     return result;
   }
 
+  private static String secondaryName(String javaName) {
+    if (javaName.startsWith("TLS_")) {
+      return "SSL_" + javaName.substring(4);
+    } else if (javaName.startsWith("SSL_")) {
+      return "TLS_" + javaName.substring(4);
+    } else {
+      return javaName;
+    }
+  }
+
   static List<CipherSuite> forJavaNames(String... cipherSuites) {
     List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
     for (String cipherSuite : cipherSuites) {
@@ -424,8 +453,10 @@ private CipherSuite(String javaName) {
    *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    */
-  private static CipherSuite of(String javaName, int value) {
-    return forJavaName(javaName);
+  private static CipherSuite init(String javaName, int value) {
+    CipherSuite suite = new CipherSuite(javaName);
+    INSTANCES.put(javaName, suite);
+    return suite;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index 9fe9bbd889..cb6d70996d 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -48,11 +48,11 @@
  *
  * <h3>Connection Reuse</h3>
  *
- * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
- * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
- * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
- * connection currently carrying zero streams is an idle stream. We keep it alive because reusing an
- * existing connection is typically faster than establishing a new one.
+ * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
+ * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
+ * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
+ * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
+ * an existing connection is typically faster than establishing a new one.
  *
  * <p>When a single logical call requires multiple streams due to redirects or authorization
  * challenges, we prefer to use the same physical connection for all streams in the sequence. There
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 6e305ab7bd..605f275661 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -123,7 +123,7 @@ public synchronized int connectionCount() {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.isEligible(address, route)) {
-        streamAllocation.acquire(connection);
+        streamAllocation.acquire(connection, true);
         return connection;
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 25b9ee328b..004a97065b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -40,10 +40,34 @@
  */
 public final class ConnectionSpec {
 
+  // Most secure but generally supported list.
+  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
   // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
   // All of these suites are available on Android 7.0; earlier releases support a subset of these
   // suites. https://github.com/square/okhttp/issues/1972
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
@@ -54,9 +78,7 @@
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
@@ -65,6 +87,13 @@
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
+  /** A secure TLS connection assuming a modern client platform and server. */
+  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
+      .cipherSuites(RESTRICTED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+      .supportsTlsExtensions(true)
+      .build();
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
@@ -73,7 +102,8 @@
       .build();
 
   /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index a20cac407d..7a4f24ba20 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -30,8 +30,8 @@
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 
 import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.canonicalizeHost;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
@@ -429,7 +429,7 @@ private static String parseDomain(String s) {
     if (s.startsWith(".")) {
       s = s.substring(1);
     }
-    String canonicalDomain = domainToAscii(s);
+    String canonicalDomain = canonicalizeHost(s);
     if (canonicalDomain == null) {
       throw new IllegalArgumentException();
     }
@@ -458,10 +458,10 @@ private static String parseDomain(String s) {
    * #domain() domain} values must all be set before calling {@link #build}.
    */
   public static final class Builder {
-    String name;
-    String value;
+    @Nullable String name;
+    @Nullable String value;
     long expiresAt = HttpDate.MAX_DATE;
-    String domain;
+    @Nullable String domain;
     String path = "/";
     boolean secure;
     boolean httpOnly;
@@ -508,7 +508,7 @@ public Builder hostOnlyDomain(String domain) {
 
     private Builder domain(String domain, boolean hostOnly) {
       if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.domainToAscii(domain);
+      String canonicalDomain = Util.canonicalizeHost(domain);
       if (canonicalDomain == null) {
         throw new IllegalArgumentException("unexpected domain: " + domain);
       }
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index c88c44e505..530863e4a8 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -18,20 +18,21 @@
 import java.nio.charset.Charset;
 import okio.ByteString;
 
+import static okhttp3.internal.Util.ISO_8859_1;
+
 /** Factory for HTTP authorization credentials. */
 public final class Credentials {
   private Credentials() {
   }
 
   /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String userName, String password) {
-    return basic(userName, password, Charset.forName("ISO-8859-1"));
+  public static String basic(String username, String password) {
+    return basic(username, password, ISO_8859_1);
   }
 
-  public static String basic(String userName, String password, Charset charset) {
-    String usernameAndPassword = userName + ":" + password;
-    byte[] bytes = usernameAndPassword.getBytes(charset);
-    String encoded = ByteString.of(bytes).base64();
+  public static String basic(String username, String password, Charset charset) {
+    String usernameAndPassword = username + ":" + password;
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
     return "Basic " + encoded;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 43f5aa48e7..3e33dff6bf 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -75,12 +75,14 @@ public synchronized ExecutorService executorService() {
    * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
    * will remain in flight.
    */
-  public synchronized void setMaxRequests(int maxRequests) {
+  public void setMaxRequests(int maxRequests) {
     if (maxRequests < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
-    this.maxRequests = maxRequests;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequests = maxRequests;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequests() {
@@ -95,13 +97,17 @@ public synchronized int getMaxRequests() {
    *
    * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
    * requests will remain in flight.
+   *
+   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
    */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
     if (maxRequestsPerHost < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
     }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequestsPerHost = maxRequestsPerHost;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequestsPerHost() {
@@ -124,13 +130,11 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
-  synchronized void enqueue(AsyncCall call) {
-    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningAsyncCalls.add(call);
-      executorService().execute(call);
-    } else {
+  void enqueue(AsyncCall call) {
+    synchronized (this) {
       readyAsyncCalls.add(call);
     }
+    promoteAndExecute();
   }
 
   /**
@@ -151,27 +155,45 @@ public synchronized void cancelAll() {
     }
   }
 
-  private void promoteCalls() {
-    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+  /**
+   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
+   * them on the executor service. Must not be called with synchronization because executing calls
+   * can call into user code.
+   *
+   * @return true if the dispatcher is currently running calls.
+   */
+  private boolean promoteAndExecute() {
+    assert (!Thread.holdsLock(this));
+
+    List<AsyncCall> executableCalls = new ArrayList<>();
+    boolean isRunning;
+    synchronized (this) {
+      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+        AsyncCall asyncCall = i.next();
 
-    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
+        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
 
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningAsyncCalls.add(call);
-        executorService().execute(call);
+        executableCalls.add(asyncCall);
+        runningAsyncCalls.add(asyncCall);
       }
+      isRunning = runningCallsCount() > 0;
+    }
 
-      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    for (int i = 0, size = executableCalls.size(); i < size; i++) {
+      AsyncCall asyncCall = executableCalls.get(i);
+      asyncCall.executeOn(executorService());
     }
+
+    return isRunning;
   }
 
   /** Returns the number of running calls that share a host with {@code call}. */
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
     for (AsyncCall c : runningAsyncCalls) {
+      if (c.get().forWebSocket) continue;
       if (c.host().equals(call.host())) result++;
     }
     return result;
@@ -184,25 +206,24 @@ synchronized void executed(RealCall call) {
 
   /** Used by {@code AsyncCall#run} to signal completion. */
   void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call, true);
+    finished(runningAsyncCalls, call);
   }
 
   /** Used by {@code Call#execute} to signal completion. */
   void finished(RealCall call) {
-    finished(runningSyncCalls, call, false);
+    finished(runningSyncCalls, call);
   }
 
-  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
-    int runningCallsCount;
+  private <T> void finished(Deque<T> calls, T call) {
     Runnable idleCallback;
     synchronized (this) {
       if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      if (promoteCalls) promoteCalls();
-      runningCallsCount = runningCallsCount();
       idleCallback = this.idleCallback;
     }
 
-    if (runningCallsCount == 0 && idleCallback != null) {
+    boolean isRunning = promoteAndExecute();
+
+    if (!isRunning && idleCallback != null) {
       idleCallback.run();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index a2e6db591c..de3b4cb215 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -36,7 +36,14 @@
   Dns SYSTEM = new Dns() {
     @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
       if (hostname == null) throw new UnknownHostException("hostname == null");
-      return Arrays.asList(InetAddress.getAllByName(hostname));
+      try {
+        return Arrays.asList(InetAddress.getAllByName(hostname));
+      } catch (NullPointerException e) {
+        UnknownHostException unknownHostException =
+            new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
+        unknownHostException.initCause(e);
+        throw unknownHostException;
+      }
     }
   };
 
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index 3c64409d38..fb8d4c7f4a 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -15,10 +15,40 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import java.util.List;
 import javax.annotation.Nullable;
 
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * <p>All start/connect/acquire events will eventually receive a matching end/release event,
+ * either successful (non-null parameters), or failed (non-null throwable).  The first common
+ * parameters of each event pair are used to link the event in case of concurrent or repeated
+ * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * <p>Nesting is as follows
+ * <ul>
+ *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
+ *   <li>call -&gt; (connection acquire/release)*</li>
+ * </ul>
+ *
+ * <p>Request events are ordered:
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * <p>Since connections may be reused, the dns and connect events may not be present for a call,
+ * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
+ * attempt to mutate the event parameters, or be reentrant back into the client.
+ * Any IO - writing to files or network should be done asynchronously.
+ */
 public abstract class EventListener {
   public static final EventListener NONE = new EventListener() {
   };
@@ -31,7 +61,15 @@ public EventListener create(Call call) {
     };
   }
 
-  public void fetchStart(Call call) {
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
+   * or redirects will be handled within the boundaries of a single callStart and {@link
+   * #callEnd}/{@link #callFailed} pair.
+   */
+  public void callStart(Call call) {
   }
 
   /**
@@ -49,19 +87,21 @@ public void dnsStart(Call call, String domainName) {
   /**
    * Invoked immediately after a DNS lookup.
    *
-   * <p>This method is always invoked after {@link #dnsStart(Call, String)}.
-   *
-   * <p>{@code inetAddressList} will be non-null and {@code throwable} will be null in the case of a
-   * successful DNS lookup.
-   *
-   * <p>{@code inetAddressList} will be null and {@code throwable} will be non-null in the case of a
-   * failed DNS lookup.
+   * <p>This method is invoked after {@link #dnsStart}.
    */
-  public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> inetAddressList,
-      @Nullable Throwable throwable) {
+  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
   }
 
-  public void connectStart(Call call, InetAddress address, int port) {
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
+   * reused.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
   }
 
   /**
@@ -69,8 +109,8 @@ public void connectStart(Call call, InetAddress address, int port) {
    *
    * <p>This method is invoked if the following conditions are met:
    * <ul>
-   *   <li>The {@link Call#request()} requires TLS.</li>
-   *   <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
+   * <li>The {@link Call#request()} requires TLS.</li>
+   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
    * </ul>
    *
    * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
@@ -82,47 +122,159 @@ public void secureConnectStart(Call call) {
   /**
    * Invoked immediately after a TLS connection was attempted.
    *
-   * <p>This method is always invoked after {@link #secureConnectStart(Call)}.
+   * <p>This method is invoked after {@link #secureConnectStart}.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
    *
-   * <p>{@code handshake} will be non-null and {@code throwable} will be null in the case of a
-   * successful TLS connection.
+   * <p>If the {@code call} uses HTTPS, this will be invoked after
+   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
+   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
+   */
+  public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
    *
-   * <p>{@code handshake} will be null and {@code throwable} will be non-null in the case of a
-   * failed TLS connection attempt.
+   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
+   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
+   * Proxy)}.
    */
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake,
-      @Nullable Throwable throwable) {
+  public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol, IOException ioe) {
   }
 
-  public void connectEnd(Call call,  InetAddress address, int port, String protocol,
-      Throwable throwable) {
+  /**
+   * Invoked after a connection has been acquired for the {@code call}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionAcquired(Call call, Connection connection) {
   }
 
+  /**
+   * Invoked after a connection has been released for the {@code call}.
+   *
+   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionReleased(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void requestHeadersStart(Call call) {
   }
 
-  public void requestHeadersEnd(Call call, Throwable throwable) {
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  public void requestHeadersEnd(Call call, Request request) {
   }
 
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void requestBodyStart(Call call) {
   }
 
-  public void requestBodyEnd(Call call, Throwable throwable) {
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void requestBodyEnd(Call call, long byteCount) {
   }
 
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void responseHeadersStart(Call call) {
   }
 
-  public void responseHeadersEnd(Call call, Throwable throwable) {
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * <p>This method is always invoked after {@link #responseHeadersStart}.
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  public void responseHeadersEnd(Call call, Response response) {
   }
 
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This will usually be invoked only 1 time for a single {@link Call},
+   * exceptions are a limited set of cases including failure recovery.
+   */
   public void responseBodyStart(Call call) {
   }
 
-  public void responseBodyEnd(Call call, Throwable throwable) {
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
+   * websocket upgrade.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void responseBodyEnd(Call call, long byteCount) {
   }
 
-  public void fetchEnd(Call call, Throwable throwable) {
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callEnd(Call call) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callFailed(Call call, IOException ioe) {
   }
 
   public interface Factory {
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 1b8d51f070..d3937834c3 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -27,8 +28,7 @@
 import static okhttp3.HttpUrl.percentDecode;
 
 public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
+  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
 
   private final List<String> encodedNames;
   private final List<String> encodedValues;
@@ -105,16 +105,31 @@ private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes)
   public static final class Builder {
     private final List<String> names = new ArrayList<>();
     private final List<String> values = new ArrayList<>();
+    private final Charset charset;
+
+    public Builder() {
+      this(null);
+    }
+
+    public Builder(Charset charset) {
+      this.charset = charset;
+    }
 
     public Builder add(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
+      if (name == null) throw new NullPointerException("name == null");
+      if (value == null) throw new NullPointerException("value == null");
+
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
       return this;
     }
 
     public Builder addEncoded(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
+      if (name == null) throw new NullPointerException("name == null");
+      if (value == null) throw new NullPointerException("value == null");
+
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index 59a5418b86..e6c86bcad9 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -15,9 +15,11 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -46,13 +48,17 @@ private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
     this.localCertificates = localCertificates;
   }
 
-  public static Handshake get(SSLSession session) {
+  public static Handshake get(SSLSession session) throws IOException {
     String cipherSuiteString = session.getCipherSuite();
     if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {
+      throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL");
+    }
     CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
 
     String tlsVersionString = session.getProtocol();
     if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    if ("NONE".equals(tlsVersionString)) throw new IOException("tlsVersion == NONE");
     TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
 
     Certificate[] peerCertificates;
@@ -135,4 +141,31 @@ public CipherSuite cipherSuite() {
     result = 31 * result + localCertificates.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Handshake{"
+        + "tlsVersion="
+        + tlsVersion
+        + " cipherSuite="
+        + cipherSuite
+        + " peerCertificates="
+        + names(peerCertificates)
+        + " localCertificates="
+        + names(localCertificates)
+        + '}';
+  }
+
+  private List<String> names(List<Certificate> certificates) {
+    ArrayList<String> strings = new ArrayList<>();
+
+    for (Certificate cert : certificates) {
+      if (cert instanceof X509Certificate) {
+        strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN()));
+      } else {
+        strings.add(cert.getType());
+      }
+    }
+
+    return strings;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 18342c2f0d..8b662c96ac 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -110,6 +110,23 @@ public String value(int index) {
         : Collections.<String>emptyList();
   }
 
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  public long byteCount() {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    long result = namesAndValues.length * 2;
+
+    for (int i = 0, size = namesAndValues.length; i < size; i++) {
+      result += namesAndValues[i].length();
+    }
+
+    return result;
+  }
+
   public Builder newBuilder() {
     Builder result = new Builder();
     Collections.addAll(result.namesAndValues, namesAndValues);
@@ -203,9 +220,8 @@ public static Headers of(String... namesAndValues) {
     for (int i = 0; i < namesAndValues.length; i += 2) {
       String name = namesAndValues[i];
       String value = namesAndValues[i + 1];
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
     }
 
     return new Headers(namesAndValues);
@@ -226,9 +242,8 @@ public static Headers of(Map<String, String> headers) {
       }
       String name = header.getKey().trim();
       String value = header.getValue().trim();
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
       namesAndValues[i] = name;
       namesAndValues[i + 1] = value;
       i += 2;
@@ -237,6 +252,29 @@ public static Headers of(Map<String, String> headers) {
     return new Headers(namesAndValues);
   }
 
+  static void checkName(String name) {
+    if (name == null) throw new NullPointerException("name == null");
+    if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+    for (int i = 0, length = name.length(); i < length; i++) {
+      char c = name.charAt(i);
+      if (c <= '\u0020' || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+      }
+    }
+  }
+
+  static void checkValue(String value, String name) {
+    if (value == null) throw new NullPointerException("value for name " + name + " == null");
+    for (int i = 0, length = value.length(); i < length; i++) {
+      char c = value.charAt(i);
+      if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
+      }
+    }
+  }
+
   public static final class Builder {
     final List<String> namesAndValues = new ArrayList<>(20);
 
@@ -266,12 +304,56 @@ public Builder add(String line) {
       return add(line.substring(0, index).trim(), line.substring(index + 1));
     }
 
-    /** Add a field with the specified value. */
+    /**
+     * Add a header with the specified name and value. Does validation of header names and values.
+     */
     public Builder add(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
       return addLenient(name, value);
     }
 
+    /**
+     * Add a header with the specified name and value. Does validation of header names, allowing
+     * non-ASCII values.
+     */
+    public Builder addUnsafeNonAscii(String name, String value) {
+      checkName(name);
+      return addLenient(name, value);
+    }
+
+    /**
+     * Adds all headers from an existing collection.
+     */
+    public Builder addAll(Headers headers) {
+      int size = headers.size();
+      for (int i = 0; i < size; i++) {
+        addLenient(headers.name(i), headers.value(i));
+      }
+
+      return this;
+    }
+
+    /**
+     * Add a header with the specified name and formatted Date.
+     * Does validation of header names and values.
+     */
+    public Builder add(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      add(name, HttpDate.format(value));
+      return this;
+    }
+
+    /**
+     * Set a field with the specified date. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    public Builder set(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      set(name, HttpDate.format(value));
+      return this;
+    }
+
     /**
      * Add a field with the specified value without any validation. Only appropriate for headers
      * from the remote peer or cache.
@@ -298,32 +380,13 @@ public Builder removeAll(String name) {
      * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
       removeAll(name);
       addLenient(name, value);
       return this;
     }
 
-    private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-      for (int i = 0, length = name.length(); i < length; i++) {
-        char c = name.charAt(i);
-        if (c <= '\u0020' || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-        }
-      }
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      for (int i = 0, length = value.length(); i < length; i++) {
-        char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-        }
-      }
-    }
-
     /** Equivalent to {@code build().get(name)}, but potentially faster. */
     public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 555c4bd1ed..9ca007cefd 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -20,19 +20,19 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.UnknownHostException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.Nullable;
+import okhttp3.internal.Util;
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.Buffer;
 
+import static okhttp3.internal.Util.decodeHexDigit;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
 import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
 import static okhttp3.internal.Util.verifyAsIpAddress;
@@ -280,7 +280,8 @@
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
  *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #get get()}
+ * throws {@link IllegalArgumentException} on invalid input or {@link #parse parse()}
  * returns null if the input is an invalid URL. You can even be explicit about whether each
  * component has been encoded already.
  */
@@ -292,7 +293,8 @@
   static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
   static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
   static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_REENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~";
   static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
   static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
   static final String FRAGMENT_ENCODE_SET = "";
@@ -610,7 +612,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
   public @Nullable String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
+    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -886,9 +888,11 @@ public Builder newBuilder() {
    * or null if the resulting URL is not well-formed.
    */
   public @Nullable Builder newBuilder(String link) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(this, link);
-    return result == Builder.ParseResult.SUCCESS ? builder : null;
+    try {
+      return new Builder().parse(this, link);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
@@ -896,40 +900,28 @@ public Builder newBuilder() {
    * URL, or null if it isn't.
    */
   public static @Nullable HttpUrl parse(String url) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+    try {
+      return get(url);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
+   * Returns a new {@code HttpUrl} representing {@code url}.
+   *
+   * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
    */
-  public static @Nullable HttpUrl get(URL url) {
-    return parse(url.toString());
+  public static HttpUrl get(String url) {
+    return new Builder().parse(null, url).build();
   }
 
   /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or throws an exception if it isn't.
-   *
-   * @throws MalformedURLException if there was a non-host related URL issue
-   * @throws UnknownHostException if the host was invalid
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
    */
-  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    switch (result) {
-      case SUCCESS:
-        return builder.build();
-      case INVALID_HOST:
-        throw new UnknownHostException("Invalid host: " + url);
-      case UNSUPPORTED_SCHEME:
-      case MISSING_SCHEME:
-      case INVALID_PORT:
-      default:
-        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
-    }
+  public static @Nullable HttpUrl get(URL url) {
+    return parse(url.toString());
   }
 
   public static @Nullable HttpUrl get(URI uri) {
@@ -1096,7 +1088,8 @@ private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
+              null);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -1109,7 +1102,8 @@ public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
         throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
+          null);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -1167,9 +1161,9 @@ public Builder addEncodedQueryParameter(String encodedName, @Nullable String enc
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
+          ? canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
           : null);
       return this;
     }
@@ -1199,7 +1193,7 @@ public Builder removeAllEncodedQueryParameters(String encodedName) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       return this;
     }
 
@@ -1264,8 +1258,12 @@ public HttpUrl build() {
 
     @Override public String toString() {
       StringBuilder result = new StringBuilder();
-      result.append(scheme);
-      result.append("://");
+      if (scheme != null) {
+        result.append(scheme);
+        result.append("://");
+      } else {
+        result.append("//");
+      }
 
       if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
         result.append(encodedUsername);
@@ -1276,19 +1274,23 @@ public HttpUrl build() {
         result.append('@');
       }
 
-      if (host.indexOf(':') != -1) {
-        // Host is an IPv6 address.
-        result.append('[');
-        result.append(host);
-        result.append(']');
-      } else {
-        result.append(host);
+      if (host != null) {
+        if (host.indexOf(':') != -1) {
+          // Host is an IPv6 address.
+          result.append('[');
+          result.append(host);
+          result.append(']');
+        } else {
+          result.append(host);
+        }
       }
 
-      int effectivePort = effectivePort();
-      if (effectivePort != defaultPort(scheme)) {
-        result.append(':');
-        result.append(effectivePort);
+      if (port != -1 || scheme != null) {
+        int effectivePort = effectivePort();
+        if (scheme == null || effectivePort != defaultPort(scheme)) {
+          result.append(':');
+          result.append(effectivePort);
+        }
       }
 
       pathSegmentsToString(result, encodedPathSegments);
@@ -1306,15 +1308,9 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    enum ParseResult {
-      SUCCESS,
-      MISSING_SCHEME,
-      UNSUPPORTED_SCHEME,
-      INVALID_PORT,
-      INVALID_HOST,
-    }
+    static final String INVALID_HOST = "Invalid URL host";
 
-    ParseResult parse(@Nullable HttpUrl base, String input) {
+    Builder parse(@Nullable HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -1328,12 +1324,14 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
           this.scheme = "http";
           pos += "http:".length();
         } else {
-          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+          throw new IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '"
+              + input.substring(0, schemeDelimiterOffset) + "'");
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return ParseResult.MISSING_SCHEME; // No scheme.
+        throw new IllegalArgumentException(
+            "Expected URL scheme 'http' or 'https' but no colon was found");
       }
 
       // Authority.
@@ -1364,19 +1362,22 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
                 int passwordColonOffset = delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
+                    null);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true;
                   this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                      null);
                 }
                 hasUsername = true;
               } else {
                 this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                    null);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -1389,14 +1390,20 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
               // Host info precedes.
               int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
               if (portColonOffset + 1 < componentDelimiterOffset) {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (port == -1) {
+                  throw new IllegalArgumentException("Invalid URL port: \""
+                      + input.substring(portColonOffset + 1, componentDelimiterOffset) + '"');
+                }
               } else {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = defaultPort(this.scheme);
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = defaultPort(scheme);
+              }
+              if (host == null) {
+                throw new IllegalArgumentException(
+                    INVALID_HOST + ": \"" + input.substring(pos, portColonOffset) + '"');
               }
-              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -1423,17 +1430,17 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
       if (pos < limit && input.charAt(pos) == '?') {
         int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
         pos = queryDelimiterOffset;
       }
 
       // Fragment.
       if (pos < limit && input.charAt(pos) == '#') {
         this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
       }
 
-      return ParseResult.SUCCESS;
+      return this;
     }
 
     private void resolvePath(String input, int pos, int limit) {
@@ -1467,7 +1474,7 @@ private void resolvePath(String input, int pos, int limit) {
     private void push(String input, int pos, int limit, boolean addTrailingSlash,
         boolean alreadyEncoded) {
       String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
       if (isDot(segment)) {
         return; // Skip '.' path segments.
       }
@@ -1582,168 +1589,13 @@ private static String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
-
-      // If the input contains a :, it’s an IPv6 address.
-      if (percentDecoded.contains(":")) {
-        // If the input is encased in square braces "[...]", drop 'em.
-        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
-            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
-            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
-        if (inetAddress == null) return null;
-        byte[] address = inetAddress.getAddress();
-        if (address.length == 16) return inet6AddressToAscii(address);
-        throw new AssertionError();
-      }
-
-      return domainToAscii(percentDecoded);
-    }
-
-    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-    private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
-      byte[] address = new byte[16];
-      int b = 0;
-      int compress = -1;
-      int groupOffset = -1;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return null; // Too many groups.
-
-        // Read a delimiter.
-        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-          if (compress != -1) return null; // Multiple "::" delimiters.
-          i += 2;
-          b += 2;
-          compress = b;
-          if (i == limit) break;
-        } else if (b != 0) {
-          // Group separator ":" delimiter.
-          if (input.regionMatches(i, ":", 0, 1)) {
-            i++;
-          } else if (input.regionMatches(i, ".", 0, 1)) {
-            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-            b += 2; // We rewound two bytes and then added four.
-            break;
-          } else {
-            return null; // Wrong delimiter.
-          }
-        }
-
-        // Read a group, one to four hex digits.
-        int value = 0;
-        groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          int hexDigit = decodeHexDigit(c);
-          if (hexDigit == -1) break;
-          value = (value << 4) + hexDigit;
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-        // We've successfully read a group. Assign its value to our byte array.
-        address[b++] = (byte) ((value >>> 8) & 0xff);
-        address[b++] = (byte) (value & 0xff);
-      }
-
-      // All done. If compression happened, we need to move bytes to the right place in the
-      // address. Here's a sample:
-      //
-      //      input: "1111:2222:3333::7777:8888"
-      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-      //   compress: 6
-      //          b: 10
-      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-      //
-      if (b != address.length) {
-        if (compress == -1) return null; // Address didn't have compression or enough groups.
-        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-      }
-
-      try {
-        return InetAddress.getByAddress(address);
-      } catch (UnknownHostException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-    private static boolean decodeIpv4Suffix(
-        String input, int pos, int limit, byte[] address, int addressOffset) {
-      int b = addressOffset;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return false; // Too many groups.
-
-        // Read a delimiter.
-        if (b != addressOffset) {
-          if (input.charAt(i) != '.') return false; // Wrong delimiter.
-          i++;
-        }
-
-        // Read 1 or more decimal digits for a value in 0..255.
-        int value = 0;
-        int groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          if (c < '0' || c > '9') break;
-          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-          value = (value * 10) + c - '0';
-          if (value > 255) return false; // Value out of range.
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0) return false; // No digits.
-
-        // We've successfully read a byte.
-        address[b++] = (byte) value;
-      }
-
-      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-      return true; // Success.
-    }
-
-    /** Encodes an IPv6 address in canonical form according to RFC 5952. */
-    private static String inet6AddressToAscii(byte[] address) {
-      // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
-      // A run must be longer than one group (section 4.2.2).
-      // If there are multiple equal runs, the first one must be used (section 4.2.3).
-      int longestRunOffset = -1;
-      int longestRunLength = 0;
-      for (int i = 0; i < address.length; i += 2) {
-        int currentRunOffset = i;
-        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
-          i += 2;
-        }
-        int currentRunLength = i - currentRunOffset;
-        if (currentRunLength > longestRunLength && currentRunLength >= 4) {
-          longestRunOffset = currentRunOffset;
-          longestRunLength = currentRunLength;
-        }
-      }
-
-      // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
-      Buffer result = new Buffer();
-      for (int i = 0; i < address.length; ) {
-        if (i == longestRunOffset) {
-          result.writeByte(':');
-          i += longestRunLength;
-          if (i == 16) result.writeByte(':');
-        } else {
-          if (i > 0) result.writeByte(':');
-          int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
-          result.writeHexadecimalUnsignedLong(group);
-          i += 2;
-        }
-      }
-      return result.readUtf8();
+      return Util.canonicalizeHost(percentDecoded);
     }
 
     private static int parsePort(String input, int pos, int limit) {
       try {
         // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
         int i = Integer.parseInt(portString);
         if (i > 0 && i <= 65535) return i;
         return -1;
@@ -1810,13 +1662,6 @@ static boolean percentEncoded(String encoded, int pos, int limit) {
         && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
   }
 
-  static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
   /**
    * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
    * transformations:
@@ -1832,9 +1677,11 @@ static int decodeHexDigit(char c) {
    * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
    * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
    * @param asciiOnly true to encode all non-ASCII codepoints.
+   * @param charset which charset to use, null equals UTF-8.
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1848,7 +1695,7 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
         Buffer out = new Buffer();
         out.writeUtf8(input, pos, i);
         canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-            asciiOnly);
+            asciiOnly, charset);
         return out.readUtf8();
       }
     }
@@ -1858,8 +1705,9 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
   }
 
   static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
-    Buffer utf8Buffer = null; // Lazily allocated.
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
+    Buffer encodedCharBuffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1875,12 +1723,18 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
           || encodeSet.indexOf(codePoint) != -1
           || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
         // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+        if (encodedCharBuffer == null) {
+          encodedCharBuffer = new Buffer();
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
+
+        if (charset == null || charset.equals(Util.UTF_8)) {
+          encodedCharBuffer.writeUtf8CodePoint(codePoint);
+        } else {
+          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
+        }
+
+        while (!encodedCharBuffer.exhausted()) {
+          int b = encodedCharBuffer.readByte() & 0xff;
           out.writeByte('%');
           out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
           out.writeByte(HEX_DIGITS[b & 0xf]);
@@ -1893,8 +1747,15 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly) {
+      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
     return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
+            charset);
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+   return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index 71e133e097..1005592697 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 
 /**
@@ -36,5 +37,19 @@
      * of network interceptors; for application interceptors this is always null.
      */
     @Nullable Connection connection();
+
+    Call call();
+
+    int connectTimeoutMillis();
+
+    Chain withConnectTimeout(int timeout, TimeUnit unit);
+
+    int readTimeoutMillis();
+
+    Chain withReadTimeout(int timeout, TimeUnit unit);
+
+    int writeTimeoutMillis();
+
+    Chain withWriteTimeout(int timeout, TimeUnit unit);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index 95194c5711..ddbd8fcb16 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -45,12 +45,15 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
+   * Returns a media type for {@code string}.
+   *
+   * @throws IllegalArgumentException if {@code string} is not a well-formed media type.
    */
-  public static @Nullable MediaType parse(String string) {
+  public static MediaType get(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) return null;
+    if (!typeSubtype.lookingAt()) {
+      throw new IllegalArgumentException("No subtype found for: \"" + string + '"');
+    }
     String type = typeSubtype.group(1).toLowerCase(Locale.US);
     String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
 
@@ -58,7 +61,13 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
     Matcher parameter = PARAMETER.matcher(string);
     for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
       parameter.region(s, string.length());
-      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+      if (!parameter.lookingAt()) {
+        throw new IllegalArgumentException("Parameter is not formatted correctly: \""
+            + string.substring(s)
+            + "\" for: \""
+            + string
+            + '"');
+      }
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
@@ -74,7 +83,13 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        return null; // Multiple different charsets!
+        throw new IllegalArgumentException("Multiple charsets defined: \""
+            + charset
+            + "\" and: \""
+            + charsetParameter
+            + "\" for: \""
+            + string
+            + '"');
       }
       charset = charsetParameter;
     }
@@ -82,6 +97,18 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
     return new MediaType(string, type, subtype, charset);
   }
 
+  /**
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
+   */
+  public static @Nullable MediaType parse(String string) {
+    try {
+      return get(string);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
+  }
+
   /**
    * Returns the high-level media type, such as "text", "image", "audio", "video", or
    * "application".
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 09c1eaf2fe..800064cfb5 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -32,34 +32,34 @@
    * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
    * not recognize must be treated as being of subtype "mixed".
    */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+  public static final MediaType MIXED = MediaType.get("multipart/mixed");
 
   /**
    * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
    * semantics are different. In particular, each of the body parts is an "alternative" version of
    * the same information.
    */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
    * "text/plain" to "message/rfc822".
    */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+  public static final MediaType DIGEST = MediaType.get("multipart/digest");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a parallel entity, the order of body parts is not significant.
    */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
 
   /**
    * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
    * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
    * fills out the form. Each field has a name. Within a given form, the names are unique.
    */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+  public static final MediaType FORM = MediaType.get("multipart/form-data");
 
   private static final byte[] COLONSPACE = {':', ' '};
   private static final byte[] CRLF = {'\r', '\n'};
@@ -74,7 +74,7 @@
   MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
     this.boundary = boundary;
     this.originalType = type;
-    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
     this.parts = Util.immutableList(parts);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index d61ed5de2f..3dc92fd536 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,15 +15,13 @@
  */
 package okhttp3;
 
-import java.net.MalformedURLException;
+import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
+import java.time.Duration;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
@@ -36,7 +34,6 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
@@ -44,10 +41,20 @@
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
+import okio.Sink;
+import okio.Source;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+import static okhttp3.internal.Util.assertionError;
+import static okhttp3.internal.Util.checkDuration;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
@@ -176,18 +183,45 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         tlsConfiguration.apply(sslSocket, isFallback);
       }
 
-      @Override public HttpUrl getHttpUrlChecked(String url)
-          throws MalformedURLException, UnknownHostException {
-        return HttpUrl.getChecked(url);
+      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
+        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
       }
 
       @Override public StreamAllocation streamAllocation(Call call) {
         return ((RealCall) call).streamAllocation();
       }
 
+      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
+        return ((RealCall) call).timeoutExit(e);
+      }
+
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
+
+      @Override public void duplex(Request.Builder requestBuilder, String method) {
+        requestBuilder.duplex(method);
+      }
+
+      @Override public void setHttp2Codec(Response.Builder builder, Http2Codec http2Codec) {
+        builder.http2Codec(http2Codec);
+      }
+
+      @Override public void httpSink(Response.Builder responseBuilder, HttpSink httpSink) {
+        responseBuilder.httpSink(httpSink);
+      }
+
+      @Override public HttpSink httpSink(Response response) {
+        return response.httpSink();
+      }
+
+      @Override public boolean isDuplex(Request request) {
+        return request.isDuplex();
+      }
+
+      @Override public void headersListener(Response response, HeadersListener headersListener) {
+        response.headersListener(headersListener);
+      }
     };
   }
 
@@ -203,8 +237,8 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final @Nullable Cache cache;
   final @Nullable InternalCache internalCache;
   final SocketFactory socketFactory;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable CertificateChainCleaner certificateChainCleaner;
+  final SSLSocketFactory sslSocketFactory;
+  final CertificateChainCleaner certificateChainCleaner;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
   final Authenticator proxyAuthenticator;
@@ -214,6 +248,7 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final boolean followSslRedirects;
   final boolean followRedirects;
   final boolean retryOnConnectionFailure;
+  final int callTimeout;
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
@@ -246,11 +281,15 @@ public OkHttpClient() {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      X509TrustManager trustManager = Util.platformTrustManager();
+      this.sslSocketFactory = newSslSocketFactory(trustManager);
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
 
+    if (sslSocketFactory != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactory);
+    }
+
     this.hostnameVerifier = builder.hostnameVerifier;
     this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
         certificateChainCleaner);
@@ -261,38 +300,35 @@ public OkHttpClient() {
     this.followSslRedirects = builder.followSslRedirects;
     this.followRedirects = builder.followRedirects;
     this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.callTimeout = builder.callTimeout;
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
     this.pingInterval = builder.pingInterval;
-  }
 
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+    if (interceptors.contains(null)) {
+      throw new IllegalStateException("Null interceptor: " + interceptors);
+    }
+    if (networkInterceptors.contains(null)) {
+      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
     }
   }
 
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
     try {
-      SSLContext sslContext = SSLContext.getInstance("TLS");
+      SSLContext sslContext = Platform.get().getSSLContext();
       sslContext.init(null, new TrustManager[] { trustManager }, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
+  /** Default call timeout (in milliseconds). */
+  public int callTimeoutMillis() {
+    return callTimeout;
+  }
+
   /** Default connect timeout (in milliseconds). */
   public int connectTimeoutMillis() {
     return connectTimeout;
@@ -313,7 +349,7 @@ public int pingIntervalMillis() {
     return pingInterval;
   }
 
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
@@ -325,7 +361,7 @@ public CookieJar cookieJar() {
     return cookieJar;
   }
 
-  public Cache cache() {
+  public @Nullable Cache cache() {
     return cache;
   }
 
@@ -422,7 +458,7 @@ public Dispatcher dispatcher() {
    * Uses {@code request} to connect a new web socket.
    */
   @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random());
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
     webSocket.connect(this);
     return webSocket;
   }
@@ -455,6 +491,7 @@ public Builder newBuilder() {
     boolean followSslRedirects;
     boolean followRedirects;
     boolean retryOnConnectionFailure;
+    int callTimeout;
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
@@ -466,6 +503,9 @@ public Builder() {
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
       eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
+      if (proxySelector == null) {
+        proxySelector = new NullProxySelector();
+      }
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
       hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -477,6 +517,7 @@ public Builder() {
       followSslRedirects = true;
       followRedirects = true;
       retryOnConnectionFailure = true;
+      callTimeout = 0;
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
@@ -507,34 +548,106 @@ public Builder() {
       this.followSslRedirects = okHttpClient.followSslRedirects;
       this.followRedirects = okHttpClient.followRedirects;
       this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.callTimeout = okHttpClient.callTimeout;
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
       this.pingInterval = okHttpClient.pingInterval;
     }
 
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     */
+    public Builder callTimeout(long timeout, TimeUnit unit) {
+      callTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     */
+    @IgnoreJRERequirement
+    public Builder callTimeout(Duration duration) {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
+     *
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
       connectTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     *
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    public Builder connectTimeout(Duration duration) {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
       readTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder readTimeout(Duration duration) {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
       writeTimeout = checkDuration("timeout", timeout, unit);
@@ -542,10 +655,30 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
-     * enforced on the acknowledging pongs.
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder writeTimeout(Duration duration) {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
      *
      * <p>The default value of 0 disables client-initiated pings.
      */
@@ -554,19 +687,29 @@ public Builder pingInterval(long interval, TimeUnit unit) {
       return this;
     }
 
-    private static int checkDuration(String name, long duration, TimeUnit unit) {
-      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(duration);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
-      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
-      return (int) millis;
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    public Builder pingInterval(Duration duration) {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
     }
 
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
      */
     public Builder proxy(@Nullable Proxy proxy) {
       this.proxy = proxy;
@@ -582,6 +725,7 @@ public Builder proxy(@Nullable Proxy proxy) {
      * be used.
      */
     public Builder proxySelector(ProxySelector proxySelector) {
+      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
       this.proxySelector = proxySelector;
       return this;
     }
@@ -632,6 +776,9 @@ public Builder dns(Dns dns) {
      */
     public Builder socketFactory(SocketFactory socketFactory) {
       if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      if (socketFactory instanceof SSLSocketFactory) {
+        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
+      }
       this.socketFactory = socketFactory;
       return this;
     }
@@ -647,13 +794,8 @@ public Builder socketFactory(SocketFactory socketFactory) {
      */
     public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
       if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      if (trustManager == null) {
-        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-            + ", sslSocketFactory is " + sslSocketFactory.getClass());
-      }
       this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
       return this;
     }
 
@@ -683,7 +825,7 @@ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
      *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
      *
      *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .sslSocketFactory(sslSocketFactory, trustManager)
      *       .build();
      * }</pre>
      */
@@ -813,7 +955,9 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+     *         (cleartext only)</a>
      * </ul>
      *
      * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
@@ -821,22 +965,30 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <p>If multiple protocols are specified, <a
      * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
+     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
      *
      * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
      * Response#protocol()}.
      *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     * @param protocols the protocols to use, in order of preference. If the list contains {@link
+     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+     *     not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
       // Create a private copy of the list.
       protocols = new ArrayList<>(protocols);
 
       // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+          && !protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException(
+            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+        throw new IllegalArgumentException(
+            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
       }
       if (protocols.contains(Protocol.HTTP_1_0)) {
         throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
@@ -868,6 +1020,7 @@ public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
     }
 
     public Builder addInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       interceptors.add(interceptor);
       return this;
     }
@@ -882,16 +1035,29 @@ public Builder addInterceptor(Interceptor interceptor) {
     }
 
     public Builder addNetworkInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       networkInterceptors.add(interceptor);
       return this;
     }
 
+    /**
+     * Configure a single client scoped listener that will receive all analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
     public Builder eventListener(EventListener eventListener) {
       if (eventListener == null) throw new NullPointerException("eventListener == null");
       this.eventListenerFactory = EventListener.factory(eventListener);
       return this;
     }
 
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
     public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
       if (eventListenerFactory == null) {
         throw new NullPointerException("eventListenerFactory == null");
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index 88d15b9b6b..a96070ed59 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -35,8 +35,8 @@
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
-   * 2616</a>, and tracks revisions to that spec.
+   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
+   * 7230</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
@@ -59,7 +59,26 @@
    * that enforce this may send an exception message including the string {@code
    * INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2");
+  HTTP_2("h2"),
+
+  /**
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
+   *
+   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
+   * Knowledge</a>
+   */
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
+
+  /**
+   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
+   * designed from the ground up and optimized for HTTP/2 semantics.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
+   * interceptor that provides support.
+   */
+  QUIC("quic");
 
   private final String protocol;
 
@@ -76,14 +95,19 @@ public static Protocol get(String protocol) throws IOException {
     // Unroll the loop over values() to save an allocation.
     if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
     if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    if (protocol.equals(QUIC.protocol)) return QUIC;
     throw new IOException("Unexpected protocol: " + protocol);
   }
 
   /**
    * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
    * "h2".
+   *
+   * @see <a href="https://www.iana.org/assignments/tls-extensiontype-values">IANA
+   * tls-extensiontype-values</a>
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index d09c1b7d44..a9ba5be366 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,8 +16,12 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nullable;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -27,18 +31,22 @@
 import okhttp3.internal.http.RealInterceptorChain;
 import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final AsyncTimeout timeout;
 
   /**
    * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
    * This will be set after we create the call instance then create the event listener instance.
    */
-  private EventListener eventListener;
+  private @Nullable EventListener eventListener;
 
   /** The application's original request unadulterated by redirects or auth headers. */
   final Request originalRequest;
@@ -52,6 +60,12 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+    this.timeout = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        cancel();
+      }
+    };
+    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
   }
 
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
@@ -71,16 +85,32 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    timeout.enter();
+    eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
+    } catch (IOException e) {
+      e = timeoutExit(e);
+      eventListener.callFailed(this, e);
+      throw e;
     } finally {
       client.dispatcher().finished(this);
     }
   }
 
+  @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException("timeout");
+    if (cause != null) {
+      e.initCause(cause);
+    }
+    return e;
+  }
+
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
@@ -92,6 +122,7 @@ private void captureCallStackTrace() {
       executed = true;
     }
     captureCallStackTrace();
+    eventListener.callStart(this);
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
@@ -99,6 +130,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.cancel();
   }
 
+  @Override public Timeout timeout() {
+    return timeout;
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
@@ -136,8 +171,31 @@ RealCall get() {
       return RealCall.this;
     }
 
+    /**
+     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
+     * if the executor has been shut down by reporting the call as failed.
+     */
+    void executeOn(ExecutorService executorService) {
+      assert (!Thread.holdsLock(client.dispatcher()));
+      boolean success = false;
+      try {
+        executorService.execute(this);
+        success = true;
+      } catch (RejectedExecutionException e) {
+        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
+        ioException.initCause(e);
+        eventListener.callFailed(RealCall.this, ioException);
+        responseCallback.onFailure(RealCall.this, ioException);
+      } finally {
+        if (!success) {
+          client.dispatcher().finished(this); // This call is no longer running!
+        }
+      }
+    }
+
     @Override protected void execute() {
       boolean signalledCallback = false;
+      timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
@@ -148,10 +206,12 @@ RealCall get() {
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
+        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
+          eventListener.callFailed(RealCall.this, e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
@@ -187,8 +247,10 @@ Response getResponseWithInterceptorChain() throws IOException {
     }
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    Interceptor.Chain chain = new RealInterceptorChain(
-        interceptors, null, null, null, 0, originalRequest, this, eventListener);
+    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+        originalRequest, this, eventListener, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis());
+
     return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index cb88696260..e06a29c075 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -16,7 +16,10 @@
 package okhttp3;
 
 import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
@@ -30,16 +33,18 @@
   final String method;
   final Headers headers;
   final @Nullable RequestBody body;
-  final Object tag;
+  final boolean duplex;
+  final Map<Class<?>, Object> tags;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Request(Builder builder) {
     this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
-    this.tag = builder.tag != null ? builder.tag : this;
+    this.duplex = builder.duplex;
+    this.tags = Util.immutableMap(builder.tags);
   }
 
   public HttpUrl url() {
@@ -54,7 +59,7 @@ public Headers headers() {
     return headers;
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return headers.get(name);
   }
 
@@ -66,8 +71,28 @@ public String header(String name) {
     return body;
   }
 
-  public Object tag() {
-    return tag;
+  boolean isDuplex() {
+    return duplex;
+  }
+
+  /**
+   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
+   * that key.
+   *
+   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+   * returned either this request, or the request upon which this request was derived with {@link
+   * #newBuilder()}.
+   */
+  public @Nullable Object tag() {
+    return tag(Object.class);
+  }
+
+  /**
+   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
+   * key.
+   */
+  public @Nullable <T> T tag(Class<? extends T> type) {
+    return type.cast(tags.get(type));
   }
 
   public Builder newBuilder() {
@@ -92,17 +117,20 @@ public boolean isHttps() {
         + method
         + ", url="
         + url
-        + ", tag="
-        + (tag != this ? tag : null)
+        + ", tags="
+        + tags
         + '}';
   }
 
   public static class Builder {
-    HttpUrl url;
+    @Nullable HttpUrl url;
     String method;
     Headers.Builder headers;
-    RequestBody body;
-    Object tag;
+    @Nullable RequestBody body;
+    boolean duplex;
+
+    /** A mutable map of tags, or an immutable empty map if we don't have any. */
+    Map<Class<?>, Object> tags = Collections.emptyMap();
 
     public Builder() {
       this.method = "GET";
@@ -113,7 +141,10 @@ public Builder() {
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
-      this.tag = request.tag;
+      this.duplex = request.duplex;
+      this.tags = request.tags.isEmpty()
+          ? Collections.<Class<?>, Object>emptyMap()
+          : new LinkedHashMap<>(request.tags);
       this.headers = request.headers.newBuilder();
     }
 
@@ -139,9 +170,7 @@ public Builder url(String url) {
         url = "https:" + url.substring(4);
       }
 
-      HttpUrl parsed = HttpUrl.parse(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url));
     }
 
     /**
@@ -152,9 +181,7 @@ public Builder url(String url) {
      */
     public Builder url(URL url) {
       if (url == null) throw new NullPointerException("url == null");
-      HttpUrl parsed = HttpUrl.get(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url.toString()));
     }
 
     /**
@@ -178,6 +205,7 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    /** Removes all headers named {@code name} on this builder. */
     public Builder removeHeader(String name) {
       headers.removeAll(name);
       return this;
@@ -239,15 +267,45 @@ public Builder method(String method, @Nullable RequestBody body) {
       }
       this.method = method;
       this.body = body;
+      this.duplex = false;
+      return this;
+    }
+
+    Builder duplex(String method) {
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
+      if (!HttpMethod.permitsRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
+      this.method = method;
+      this.body = null;
+      this.duplex = true;
       return this;
     }
 
+    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
+    public Builder tag(@Nullable Object tag) {
+      return tag(Object.class, tag);
+    }
+
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
-     * is unspecified or null, the request is canceled by using the request itself as the tag.
+     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
+     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
+     * type}.
+     *
+     * <p>Use this API to attach timing, debugging, or other application data to a request so that
+     * you may read it in interceptors, event listeners, or callbacks.
      */
-    public Builder tag(Object tag) {
-      this.tag = tag;
+    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      if (tag == null) {
+        tags.remove(type);
+      } else {
+        if (tags.isEmpty()) tags = new LinkedHashMap<>();
+        tags.put(type, type.cast(tag));
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 3cb29477d3..baf33ce6c6 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -102,7 +102,7 @@ public static RequestBody create(final @Nullable MediaType contentType, final by
 
   /** Returns a new request body that transmits the content of {@code file}. */
   public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("content == null");
+    if (file == null) throw new NullPointerException("file == null");
 
     return new RequestBody() {
       @Override public @Nullable MediaType contentType() {
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 1e3ab454a5..3ecbcc9621 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -20,7 +20,10 @@
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
 import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http2.Http2Codec;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -53,8 +56,10 @@
   final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
+  final HttpSink httpSink;
+  final @Nullable Http2Codec http2Codec;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Response(Builder builder) {
     this.request = builder.request;
@@ -69,6 +74,8 @@
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
+    this.httpSink = builder.httpSink;
+    this.http2Codec = builder.http2Codec;
   }
 
   /**
@@ -115,7 +122,7 @@ public String message() {
    * Returns the TLS handshake of the connection that carried this response, or null if the response
    * was received without TLS.
    */
-  public Handshake handshake() {
+  public @Nullable Handshake handshake() {
     return handshake;
   }
 
@@ -136,6 +143,14 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Should work for any trailers actually right?
+   */
+  void headersListener(HeadersListener listener) {
+    if (http2Codec == null) throw new IllegalStateException("http2Codec == null");
+    http2Codec.setHeadersListener(listener);
+  }
+
   /**
    * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
    * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
@@ -148,21 +163,11 @@ public Headers headers() {
    * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
    */
   public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource source = body.source();
-    source.request(byteCount);
-    Buffer copy = source.buffer().clone();
-
-    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
-    Buffer result;
-    if (copy.size() > byteCount) {
-      result = new Buffer();
-      result.write(copy, byteCount);
-      copy.clear();
-    } else {
-      result = copy;
-    }
-
-    return ResponseBody.create(body.contentType(), result.size(), result);
+    BufferedSource peeked = body.source().peek();
+    Buffer buffer = new Buffer();
+    peeked.request(byteCount);
+    buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size()));
+    return ResponseBody.create(body.contentType(), buffer.size(), buffer);
   }
 
   /**
@@ -225,10 +230,15 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code. If the response code
-   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
-   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
-   * returns an empty list of challenges.
+   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
+   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
+   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
+   * Otherwise this returns an empty list of challenges.
+   *
+   * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
+   * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
+   * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
+   * auth param, this is up to the caller that interprets these challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -295,19 +305,25 @@ public long receivedResponseAtMillis() {
         + '}';
   }
 
+  HttpSink httpSink() {
+    return httpSink;
+  }
+
   public static class Builder {
-    Request request;
-    Protocol protocol;
+    @Nullable Request request;
+    @Nullable Protocol protocol;
     int code = -1;
     String message;
     @Nullable Handshake handshake;
     Headers.Builder headers;
-    ResponseBody body;
-    Response networkResponse;
-    Response cacheResponse;
-    Response priorResponse;
+    @Nullable ResponseBody body;
+    @Nullable Response networkResponse;
+    @Nullable Response cacheResponse;
+    @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
+    @Nullable HttpSink httpSink;
+    @Nullable Http2Codec http2Codec;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -326,6 +342,8 @@ public Builder() {
       this.priorResponse = response.priorResponse;
       this.sentRequestAtMillis = response.sentRequestAtMillis;
       this.receivedResponseAtMillis = response.receivedResponseAtMillis;
+      this.httpSink = response.httpSink;
+      this.http2Codec = response.http2Codec;
     }
 
     public Builder request(Request request) {
@@ -433,6 +451,16 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
+    Builder httpSink(@Nullable HttpSink httpSink) {
+      this.httpSink = httpSink;
+      return this;
+    }
+
+    Builder http2Codec(@Nullable Http2Codec http2Codec) {
+      this.http2Codec = http2Codec;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 17447f3d64..9b06b6ea8f 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -25,6 +25,7 @@
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 
 import static okhttp3.internal.Util.UTF_8;
 
@@ -48,7 +49,7 @@
  *   <li>Response.body().close()</li>
  *   <li>Response.body().source().close()</li>
  *   <li>Response.body().charStream().close()</li>
- *   <li>Response.body().byteString().close()</li>
+ *   <li>Response.body().byteStream().close()</li>
  *   <li>Response.body().bytes()</li>
  *   <li>Response.body().string()</li>
  * </ul>
@@ -101,7 +102,7 @@
  */
 public abstract class ResponseBody implements Closeable {
   /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
+  private @Nullable Reader reader;
 
   public abstract @Nullable MediaType contentType();
 
@@ -210,6 +211,12 @@ public static ResponseBody create(final @Nullable MediaType contentType, byte[]
     return create(contentType, content.length, buffer);
   }
 
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(@Nullable MediaType contentType, ByteString content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.size(), buffer);
+  }
+
   /** Returns a new response body that transmits {@code content}. */
   public static ResponseBody create(final @Nullable MediaType contentType,
       final long contentLength, final BufferedSource content) {
@@ -234,7 +241,7 @@ public static ResponseBody create(final @Nullable MediaType contentType,
     private final Charset charset;
 
     private boolean closed;
-    private Reader delegate;
+    private @Nullable Reader delegate;
 
     BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
index 83b585c968..46d95dec3a 100644
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -82,9 +82,9 @@
    * message.
    *
    * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
-   * this web socket. This method returns false in that case, and in any other case where this
-   * web socket is closing, closed, or canceled.
+   * outgoing message buffer (16 MiB) will be rejected and trigger a
+   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
+   * case, and in any other case where this web socket is closing, closed, or canceled.
    *
    * <p>This method returns immediately.
    */
@@ -99,8 +99,9 @@
    * a graceful shutdown was already underway or if the web socket is already closed or canceled.
    *
    * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
    * @param reason Reason for shutting down or {@code null}.
+   * @throws IllegalArgumentException if code is invalid.
    */
   boolean close(int code, @Nullable String reason);
 
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
index d46e916dd8..69276d933b 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import javax.annotation.Nullable;
 import okio.ByteString;
 
 public abstract class WebSocketListener {
@@ -33,7 +34,10 @@ public void onMessage(WebSocket webSocket, String text) {
   public void onMessage(WebSocket webSocket, ByteString bytes) {
   }
 
-  /** Invoked when the peer has indicated that no more incoming messages will be transmitted. */
+  /**
+   * Invoked when the remote peer has indicated that no more incoming messages will be
+   * transmitted.
+   */
   public void onClosing(WebSocket webSocket, int code, String reason) {
   }
 
@@ -49,6 +53,6 @@ public void onClosed(WebSocket webSocket, int code, String reason) {
    * network. Both outgoing and incoming messages may have been lost. No further calls to this
    * listener will be made.
    */
-  public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1be96fd3e7..536eba7b16 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,16 +15,15 @@
  */
 package okhttp3.internal;
 
-import java.net.MalformedURLException;
+import java.io.IOException;
 import java.net.Socket;
-import java.net.UnknownHostException;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
-import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -33,6 +32,9 @@
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.duplex.HeadersListener;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.internal.http2.Http2Codec;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -72,10 +74,23 @@ public abstract Socket deduplicate(
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
-  public abstract HttpUrl getHttpUrlChecked(String url)
-      throws MalformedURLException, UnknownHostException;
+  public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
 
   public abstract StreamAllocation streamAllocation(Call call);
 
+  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
+
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
+
+  public abstract void duplex(Request.Builder requestBuilder, String method);
+
+  public abstract void setHttp2Codec(Response.Builder builder, Http2Codec http2Codec);
+
+  public abstract void httpSink(Response.Builder responseBuilder, HttpSink httpSink);
+
+  public abstract HttpSink httpSink(Response response);
+
+  public abstract boolean isDuplex(Request request);
+
+  public abstract void headersListener(Response response, HeadersListener headersListener);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 494e8ea73d..66e559cc18 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,23 +18,37 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.IDN;
+import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import okhttp3.internal.http2.Header;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -55,6 +69,7 @@
   private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
 
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
   private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
   private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
   private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
@@ -69,6 +84,27 @@
     }
   };
 
+  private static final Method addSuppressedExceptionMethod;
+
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+
+  public static void addSuppressedIfPossible(Throwable e, Throwable suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -188,6 +224,13 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return map.isEmpty()
+        ? Collections.<K, V>emptyMap()
+        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
   /** Returns an immutable list containing {@code elements}. */
   public static <T> List<T> immutableList(T... elements) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
@@ -252,23 +295,6 @@ public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
         : host;
   }
 
-  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
-  public static String toHumanReadableAscii(String s) {
-    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
-      c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
-
-      Buffer buffer = new Buffer();
-      buffer.writeUtf8(s, 0, i);
-      for (int j = i; j < length; j += Character.charCount(c)) {
-        c = s.codePointAt(j);
-        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
-      }
-      return buffer.readUtf8();
-    }
-    return s;
-  }
-
   /**
    * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
    * https://code.google.com/p/android/issues/detail?id=54072
@@ -362,14 +388,28 @@ public static int delimiterOffset(String input, int pos, int limit, char delimit
   }
 
   /**
-   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
-   * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
-   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
-   * contains unsupported ASCII characters.
+   * If {@code host} is an IP address, this returns the IP address in canonical form.
+   *
+   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+   * example this converts {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
+   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
+   * if the result contains unsupported ASCII characters.
    */
-  public static String domainToAscii(String input) {
+  public static String canonicalizeHost(String host) {
+    // If the input contains a :, it’s an IPv6 address.
+    if (host.contains(":")) {
+      // If the input is encased in square braces "[...]", drop 'em.
+      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
+          ? decodeIpv6(host, 1, host.length() - 1)
+          : decodeIpv6(host, 0, host.length());
+      if (inetAddress == null) return null;
+      byte[] address = inetAddress.getAddress();
+      if (address.length == 16) return inet6AddressToAscii(address);
+      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
+    }
+
     try {
-      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      String result = IDN.toASCII(host).toLowerCase(Locale.US);
       if (result.isEmpty()) return null;
 
       // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
@@ -450,4 +490,196 @@ public static Charset bomAwareCharset(BufferedSource source, Charset charset) th
     }
     return charset;
   }
+
+  public static int checkDuration(String name, long duration, TimeUnit unit) {
+    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+    if (unit == null) throw new NullPointerException("unit == null");
+    long millis = unit.toMillis(duration);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+    return (int) millis;
+  }
+
+  public static AssertionError assertionError(String message, Exception e) {
+    AssertionError assertionError = new AssertionError(message);
+    try {
+      assertionError.initCause(e);
+    } catch (IllegalStateException ise) {
+      // ignored, shouldn't happen
+    }
+    return assertionError;
+  }
+
+  public static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
+    byte[] address = new byte[16];
+    int b = 0;
+    int compress = -1;
+    int groupOffset = -1;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return null; // Too many groups.
+
+      // Read a delimiter.
+      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+        if (compress != -1) return null; // Multiple "::" delimiters.
+        i += 2;
+        b += 2;
+        compress = b;
+        if (i == limit) break;
+      } else if (b != 0) {
+        // Group separator ":" delimiter.
+        if (input.regionMatches(i, ":", 0, 1)) {
+          i++;
+        } else if (input.regionMatches(i, ".", 0, 1)) {
+          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+          b += 2; // We rewound two bytes and then added four.
+          break;
+        } else {
+          return null; // Wrong delimiter.
+        }
+      }
+
+      // Read a group, one to four hex digits.
+      int value = 0;
+      groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        int hexDigit = decodeHexDigit(c);
+        if (hexDigit == -1) break;
+        value = (value << 4) + hexDigit;
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+      // We've successfully read a group. Assign its value to our byte array.
+      address[b++] = (byte) ((value >>> 8) & 0xff);
+      address[b++] = (byte) (value & 0xff);
+    }
+
+    // All done. If compression happened, we need to move bytes to the right place in the
+    // address. Here's a sample:
+    //
+    //      input: "1111:2222:3333::7777:8888"
+    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+    //   compress: 6
+    //          b: 10
+    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+    //
+    if (b != address.length) {
+      if (compress == -1) return null; // Address didn't have compression or enough groups.
+      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+    }
+
+    try {
+      return InetAddress.getByAddress(address);
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+  private static boolean decodeIpv4Suffix(
+      String input, int pos, int limit, byte[] address, int addressOffset) {
+    int b = addressOffset;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return false; // Too many groups.
+
+      // Read a delimiter.
+      if (b != addressOffset) {
+        if (input.charAt(i) != '.') return false; // Wrong delimiter.
+        i++;
+      }
+
+      // Read 1 or more decimal digits for a value in 0..255.
+      int value = 0;
+      int groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        if (c < '0' || c > '9') break;
+        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+        value = (value * 10) + c - '0';
+        if (value > 255) return false; // Value out of range.
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0) return false; // No digits.
+
+      // We've successfully read a byte.
+      address[b++] = (byte) value;
+    }
+
+    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+    return true; // Success.
+  }
+
+  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
+  private static String inet6AddressToAscii(byte[] address) {
+    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+    // A run must be longer than one group (section 4.2.2).
+    // If there are multiple equal runs, the first one must be used (section 4.2.3).
+    int longestRunOffset = -1;
+    int longestRunLength = 0;
+    for (int i = 0; i < address.length; i += 2) {
+      int currentRunOffset = i;
+      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+        i += 2;
+      }
+      int currentRunLength = i - currentRunOffset;
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset;
+        longestRunLength = currentRunLength;
+      }
+    }
+
+    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+    Buffer result = new Buffer();
+    for (int i = 0; i < address.length; ) {
+      if (i == longestRunOffset) {
+        result.writeByte(':');
+        i += longestRunLength;
+        if (i == 16) result.writeByte(':');
+      } else {
+        if (i > 0) result.writeByte(':');
+        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+        result.writeHexadecimalUnsignedLong(group);
+        i += 2;
+      }
+    }
+    return result.readUtf8();
+  }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  public static Headers toHeaders(List<Header> headerBlock) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Header header : headerBlock) {
+      Internal.instance.addLenient(builder, header.name.utf8(), header.value.utf8());
+    }
+    return builder.build();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
new file mode 100644
index 0000000000..e97bb4d9cb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.annotations;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index e4d7e2f1d6..d46494d95b 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -207,12 +207,14 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
       }
     };
 
+    String contentType = response.header("Content-Type");
+    long contentLength = response.body().contentLength();
     return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
         .build();
   }
 
-  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
+  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
     Headers.Builder result = new Headers.Builder();
 
@@ -222,17 +224,15 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
       if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
         continue; // Drop 100-level freshness warnings.
       }
-      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
+              || networkHeaders.get(fieldName) == null) {
         Internal.instance.addLenient(result, fieldName, value);
       }
     }
 
     for (int i = 0, size = networkHeaders.size(); i < size; i++) {
       String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (isEndToEnd(fieldName)) {
+      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
         Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
       }
     }
@@ -254,4 +254,14 @@ static boolean isEndToEnd(String fieldName) {
         && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
         && !"Upgrade".equalsIgnoreCase(fieldName);
   }
+
+  /**
+   * Returns true if {@code fieldName} is content specific and therefore should always be used
+   * from cached headers.
+   */
+  static boolean isContentSpecificHeader(String fieldName) {
+    return "Content-Length".equalsIgnoreCase(fieldName)
+        || "Content-Encoding".equalsIgnoreCase(fieldName)
+        || "Content-Type".equalsIgnoreCase(fieldName);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 9b6cc1a375..c7fb69ceba 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -205,9 +205,6 @@ private CacheStrategy getCandidate() {
       }
 
       CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.immutable()) {
-        return new CacheStrategy(null, cacheResponse);
-      }
 
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
@@ -295,7 +292,7 @@ private long computeFreshnessLifetime() {
 
     /**
      * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
+     * 7234, 4.2.3 Calculating Age.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
index b1326cddc9..b4ce63012f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -17,7 +17,6 @@
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import okio.Buffer;
 import okio.Okio;
@@ -35,10 +34,6 @@
  * </ul>
  */
 final class FileOperator {
-  private static final int BUFFER_SIZE = 8192;
-
-  private final byte[] byteArray = new byte[BUFFER_SIZE];
-  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
   private final FileChannel fileChannel;
 
   FileOperator(FileChannel fileChannel) {
@@ -50,22 +45,9 @@ public void write(long pos, Buffer source, long byteCount) throws IOException {
     if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
-        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
-        source.read(byteArray, 0, toWrite);
-        byteBuffer.limit(toWrite);
-
-        // Copy bytes from the ByteBuffer to the file.
-        do {
-          int bytesWritten = fileChannel.write(byteBuffer, pos);
-          pos += bytesWritten;
-        } while (byteBuffer.hasRemaining());
-
-        byteCount -= toWrite;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesWritten = fileChannel.transferFrom(source, pos, byteCount);
+      pos += bytesWritten;
+      byteCount -= bytesWritten;
     }
   }
 
@@ -78,19 +60,9 @@ public void read(long pos, Buffer sink, long byteCount) throws IOException {
     if (byteCount < 0) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Read up to byteCount bytes.
-        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
-        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
-        int bytesRead = byteBuffer.position();
-
-        // Write those bytes to sink.
-        sink.write(byteArray, 0, bytesRead);
-        pos += bytesRead;
-        byteCount -= bytesRead;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesRead = fileChannel.transferTo(pos, byteCount, sink);
+      pos += bytesRead;
+      byteCount -= bytesRead;
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index cabd065813..b8a346c03a 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -39,7 +39,7 @@ public ConnectInterceptor(OkHttpClient client) {
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
+    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
     RealConnection connection = streamAllocation.connection();
 
     return realChain.proceed(request, streamAllocation, httpCodec, connection);
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 0b438bfa1f..34a116464d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -22,6 +22,7 @@
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -123,7 +124,9 @@ public boolean connectionFailed(IOException e) {
 
     // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
     // retry those when we probably should not.
-    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+    return (e instanceof SSLHandshakeException
+        || e instanceof SSLProtocolException
+        || e instanceof SSLException);
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 1df7ae98b8..25445fac50 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.net.ConnectException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
@@ -31,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
@@ -42,6 +44,7 @@
 import okhttp3.EventListener;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -72,6 +75,8 @@
 
 public final class RealConnection extends Http2Connection.Listener implements Connection {
   private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+  private static final int MAX_TUNNEL_ATTEMPTS = 21;
+
   private final ConnectionPool connectionPool;
   private final Route route;
 
@@ -124,7 +129,8 @@ public static RealConnection testConnection(
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
+      EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -141,16 +147,26 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         throw new RouteException(new UnknownServiceException(
             "CLEARTEXT communication to " + host + " not permitted by network security policy"));
       }
+    } else {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        throw new RouteException(new UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+      }
     }
 
     while (true) {
       try {
         if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break;
+          }
         } else {
-          connectSocket(connectTimeout, readTimeout);
+          connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
-        establishProtocol(connectionSpecSelector, call, eventListener);
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
         break;
       } catch (IOException e) {
         closeQuietly(socket);
@@ -163,6 +179,8 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         protocol = null;
         http2Connection = null;
 
+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
+
         if (routeException == null) {
           routeException = new RouteException(e);
         } else {
@@ -175,6 +193,12 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
       }
     }
 
+    if (route.requiresTunnel() && rawSocket == null) {
+      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
+          + MAX_TUNNEL_ATTEMPTS);
+      throw new RouteException(exception);
+    }
+
     if (http2Connection != null) {
       synchronized (connectionPool) {
         allocationLimit = http2Connection.maxConcurrentStreams();
@@ -186,18 +210,12 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
-      throws IOException {
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
-    int attemptedConnections = 0;
-    int maxAttempts = 21;
-    while (true) {
-      if (++attemptedConnections > maxAttempts) {
-        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
-      }
-
-      connectSocket(connectTimeout, readTimeout);
+    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
@@ -208,11 +226,13 @@ private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout
       rawSocket = null;
       sink = null;
       source = null;
+      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
     }
   }
 
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
+  private void connectSocket(int connectTimeout, int readTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
 
@@ -220,6 +240,7 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
         ? address.socketFactory().createSocket()
         : new Socket(proxy);
 
+    eventListener.connectStart(call, route.socketAddress(), proxy);
     rawSocket.setSoTimeout(readTimeout);
     try {
       Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
@@ -243,33 +264,40 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
     }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
-      EventListener eventListener) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
-      protocol = Protocol.HTTP_1_1;
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        socket = rawSocket;
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
+        startHttp2(pingIntervalMillis);
+        return;
+      }
+
       socket = rawSocket;
+      protocol = Protocol.HTTP_1_1;
       return;
     }
 
     eventListener.secureConnectStart(call);
-    try {
-      connectTls(connectionSpecSelector);
-    } catch (Exception e) {
-      eventListener.secureConnectEnd(call, null, e);
-      throw e;
-    }
-    eventListener.secureConnectEnd(call, handshake, null);
+    connectTls(connectionSpecSelector);
+    eventListener.secureConnectEnd(call, handshake);
 
     if (protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
-      http2Connection = new Http2Connection.Builder(true)
-          .socket(socket, route.address().url().host(), source, sink)
-          .listener(this)
-          .build();
-      http2Connection.start();
+      startHttp2(pingIntervalMillis);
     }
   }
 
+  private void startHttp2(int pingIntervalMillis) throws IOException {
+    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+    http2Connection = new Http2Connection.Builder(true)
+        .socket(socket, route.address().url().host(), source, sink)
+        .listener(this)
+        .pingIntervalMillis(pingIntervalMillis)
+        .build();
+    http2Connection.start();
+  }
+
   private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
@@ -289,10 +317,12 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
 
       // Force handshake. This can throw!
       sslSocket.startHandshake();
-      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+      // block for session establishment
+      SSLSession sslSocketSession = sslSocket.getSession();
+      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
 
       // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
         X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
         throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
             + "\n    certificate: " + CertificatePinner.pin(cert)
@@ -387,14 +417,37 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   *
+   * <p>In order to support preemptive authentication we pass a fake “Auth Failed” response to the
+   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+   * decline to do so by returning null, in which case OkHttp will use it as-is
    */
-  private Request createTunnelRequest() {
-    return new Request.Builder()
+  private Request createTunnelRequest() throws IOException {
+    Request proxyConnectRequest = new Request.Builder()
         .url(route.address().url())
+        .method("CONNECT", null)
         .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
         .header("User-Agent", Version.userAgent())
         .build();
+
+    Response fakeAuthChallengeResponse = new Response.Builder()
+        .request(proxyConnectRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .code(HttpURLConnection.HTTP_PROXY_AUTH)
+        .message("Preemptive Authenticate")
+        .body(Util.EMPTY_RESPONSE)
+        .sentRequestAtMillis(-1L)
+        .receivedResponseAtMillis(-1L)
+        .header("Proxy-Authenticate", "OkHttp-Preemptive")
+        .build();
+
+    Request authenticatedRequest = route.address().proxyAuthenticator()
+        .authenticate(route, fakeAuthChallengeResponse);
+
+    return authenticatedRequest != null
+        ? authenticatedRequest
+        : proxyConnectRequest;
   }
 
   /**
@@ -457,14 +510,14 @@ public boolean supportsUrl(HttpUrl url) {
     return true; // Success. The URL is supported.
   }
 
-  public HttpCodec newCodec(
-      OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
+  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
+      StreamAllocation streamAllocation) throws SocketException {
     if (http2Connection != null) {
-      return new Http2Codec(client, streamAllocation, http2Connection);
+      return new Http2Codec(client, chain, streamAllocation, http2Connection);
     } else {
-      socket.setSoTimeout(client.readTimeoutMillis());
-      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
+      socket.setSoTimeout(chain.readTimeoutMillis());
+      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
       return new Http1Codec(client, streamAllocation, source, sink);
     }
   }
@@ -472,7 +525,7 @@ public HttpCodec newCodec(
   public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec());
+        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
       }
     };
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 5f50576611..4ba0168621 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -16,48 +16,33 @@
 package okhttp3.internal.connection;
 
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+
+import static okhttp3.internal.Util.addSuppressedIfPossible;
 
 /**
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
 public final class RouteException extends RuntimeException {
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
+  private IOException firstException;
   private IOException lastException;
 
   public RouteException(IOException cause) {
     super(cause);
+    firstException = cause;
     lastException = cause;
   }
 
+  public IOException getFirstConnectException() {
+    return firstException;
+  }
+
   public IOException getLastConnectException() {
     return lastException;
   }
 
   public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
+    addSuppressedIfPossible(firstException, e);
     lastException = e;
   }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index ba1491c6e4..40752ce23d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -43,17 +43,12 @@
   private final Call call;
   private final EventListener eventListener;
 
-  /* The most recently attempted route. */
-  private Proxy lastProxy;
-  private InetSocketAddress lastInetSocketAddress;
-
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
   private int nextProxyIndex;
 
   /* State for negotiating the next socket address to use. */
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
-  private int nextInetSocketAddressIndex;
 
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
@@ -69,35 +64,45 @@ public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at least one route.
+   * Returns true if there's another set of routes to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
-    return hasNextInetSocketAddress()
-        || hasNextProxy()
-        || hasNextPostponed();
+    return hasNextProxy() || !postponedRoutes.isEmpty();
   }
 
-  public Route next() throws IOException {
-    // Compute the next route to attempt.
-    if (!hasNextInetSocketAddress()) {
-      if (!hasNextProxy()) {
-        if (!hasNextPostponed()) {
-          throw new NoSuchElementException();
+  public Selection next() throws IOException {
+    if (!hasNext()) {
+      throw new NoSuchElementException();
+    }
+
+    // Compute the next set of routes to attempt.
+    List<Route> routes = new ArrayList<>();
+    while (hasNextProxy()) {
+      // Postponed routes are always tried last. For example, if we have 2 proxies and all the
+      // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted
+      // all the good routes will we attempt the postponed routes.
+      Proxy proxy = nextProxy();
+      for (int i = 0, size = inetSocketAddresses.size(); i < size; i++) {
+        Route route = new Route(address, proxy, inetSocketAddresses.get(i));
+        if (routeDatabase.shouldPostpone(route)) {
+          postponedRoutes.add(route);
+        } else {
+          routes.add(route);
         }
-        return nextPostponed();
       }
-      lastProxy = nextProxy();
+
+      if (!routes.isEmpty()) {
+        break;
+      }
     }
-    lastInetSocketAddress = nextInetSocketAddress();
 
-    Route route = new Route(address, lastProxy, lastInetSocketAddress);
-    if (routeDatabase.shouldPostpone(route)) {
-      postponedRoutes.add(route);
-      // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return next();
+    if (routes.isEmpty()) {
+      // We've exhausted all Proxies so fallback to the postponed routes.
+      routes.addAll(postponedRoutes);
+      postponedRoutes.clear();
     }
 
-    return route;
+    return new Selection(routes);
   }
 
   /**
@@ -177,29 +182,18 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
       eventListener.dnsStart(call, socketHost);
 
       // Try each address for best behavior in mixed IPv4/IPv6 environments.
-      List<InetAddress> addresses;
-      try {
-        addresses = address.dns().lookup(socketHost);
-      } catch (Exception e) {
-        eventListener.dnsEnd(call, socketHost, null, e);
-        throw e;
-      }
+      List<InetAddress> addresses = address.dns().lookup(socketHost);
       if (addresses.isEmpty()) {
-        UnknownHostException exception = new UnknownHostException(
-            address.dns() + " returned no addresses for " + socketHost);
-        eventListener.dnsEnd(call, socketHost, null, exception);
-        throw exception;
+        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
       }
 
-      eventListener.dnsEnd(call, socketHost, addresses, null);
+      eventListener.dnsEnd(call, socketHost, addresses);
 
       for (int i = 0, size = addresses.size(); i < size; i++) {
         InetAddress inetAddress = addresses.get(i);
         inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
       }
     }
-
-    nextInetSocketAddressIndex = 0;
   }
 
   /**
@@ -220,27 +214,28 @@ static String getHostString(InetSocketAddress socketAddress) {
     return address.getHostAddress();
   }
 
-  /** Returns true if there's another socket address to try. */
-  private boolean hasNextInetSocketAddress() {
-    return nextInetSocketAddressIndex < inetSocketAddresses.size();
-  }
+  /** A set of selected Routes. */
+  public static final class Selection {
+    private final List<Route> routes;
+    private int nextRouteIndex = 0;
 
-  /** Returns the next socket address to try. */
-  private InetSocketAddress nextInetSocketAddress() throws IOException {
-    if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.url().host()
-          + "; exhausted inet socket addresses: " + inetSocketAddresses);
+    Selection(List<Route> routes) {
+      this.routes = routes;
     }
-    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
-  }
 
-  /** Returns true if there is another postponed route to try. */
-  private boolean hasNextPostponed() {
-    return !postponedRoutes.isEmpty();
-  }
+    public boolean hasNext() {
+      return nextRouteIndex < routes.size();
+    }
 
-  /** Returns the next postponed route to try. */
-  private Route nextPostponed() {
-    return postponedRoutes.remove(0);
+    public Route next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
+      return routes.get(nextRouteIndex++);
+    }
+
+    public List<Route> getAll() {
+      return new ArrayList<>(routes);
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index ecca028c3c..dcad3d80db 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -19,10 +19,13 @@
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
 import java.net.Socket;
+import java.util.List;
 import okhttp3.Address;
 import okhttp3.Call;
+import okhttp3.Connection;
 import okhttp3.ConnectionPool;
 import okhttp3.EventListener;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Route;
 import okhttp3.internal.Internal;
@@ -73,16 +76,18 @@
  */
 public final class StreamAllocation {
   public final Address address;
+  private RouteSelector.Selection routeSelection;
   private Route route;
   private final ConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
+  public final Call call;
+  public final EventListener eventListener;
   private final Object callStackTrace;
 
   // State guarded by connectionPool.
   private final RouteSelector routeSelector;
   private int refusedStreamCount;
   private RealConnection connection;
+  private boolean reportedAcquired;
   private boolean released;
   private boolean canceled;
   private HttpCodec codec;
@@ -97,16 +102,18 @@ public StreamAllocation(ConnectionPool connectionPool, Address address, Call cal
     this.callStackTrace = callStackTrace;
   }
 
-  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
-    int connectTimeout = client.connectTimeoutMillis();
-    int readTimeout = client.readTimeoutMillis();
-    int writeTimeout = client.writeTimeoutMillis();
+  public HttpCodec newStream(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, this);
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       synchronized (connectionPool) {
         codec = resultCodec;
@@ -122,11 +129,11 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
    * until a healthy connection is found.
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
+          pingIntervalMillis, connectionRetryEnabled);
 
       // If this is a brand new connection, we can skip the extensive health checks.
       synchronized (connectionPool) {
@@ -151,60 +158,110 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
-    Route selectedRoute;
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    Connection releasedConnection;
+    Socket toClose;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
       if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
-      // Attempt to use an already-allocated connection.
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new streams.
+      releasedConnection = this.connection;
+      toClose = releaseIfNoNewStreams();
+      if (this.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = this.connection;
+        releasedConnection = null;
+      }
+      if (!reportedAcquired) {
+        // If the connection was never reported acquired, don't report it as released!
+        releasedConnection = null;
       }
 
-      // Attempt to get a connection from the pool.
-      Internal.instance.get(connectionPool, address, this, null);
-      if (connection != null) {
-        return connection;
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        Internal.instance.get(connectionPool, address, this, null);
+        if (connection != null) {
+          foundPooledConnection = true;
+          result = connection;
+        } else {
+          selectedRoute = route;
+        }
       }
+    }
+    closeQuietly(toClose);
 
-      selectedRoute = route;
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
     }
 
-    // If we need a route, make one. This is a blocking operation.
-    if (selectedRoute == null) {
-      selectedRoute = routeSelector.next();
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
     }
 
-    RealConnection result;
     synchronized (connectionPool) {
       if (canceled) throw new IOException("Canceled");
 
-      // Now that we have an IP address, make another attempt at getting a connection from the pool.
-      // This could match due to connection coalescing.
-      Internal.instance.get(connectionPool, address, this, selectedRoute);
-      if (connection != null) {
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        List<Route> routes = routeSelection.getAll();
+        for (int i = 0, size = routes.size(); i < size; i++) {
+          Route route = routes.get(i);
+          Internal.instance.get(connectionPool, address, this, route);
+          if (connection != null) {
+            foundPooledConnection = true;
+            result = connection;
+            this.route = route;
+            break;
+          }
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
         route = selectedRoute;
-        return connection;
+        refusedStreamCount = 0;
+        result = new RealConnection(connectionPool, selectedRoute);
+        acquire(result, false);
       }
+    }
 
-      // Create a connection and assign it to this allocation immediately. This makes it possible
-      // for an asynchronous cancel() to interrupt the handshake we're about to do.
-      route = selectedRoute;
-      refusedStreamCount = 0;
-      result = new RealConnection(connectionPool, selectedRoute);
-      acquire(result);
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(
-        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
     Socket socket = null;
     synchronized (connectionPool) {
+      reportedAcquired = true;
+
       // Pool the connection.
       Internal.instance.put(connectionPool, result);
 
@@ -217,11 +274,31 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     }
     closeQuietly(socket);
 
+    eventListener.connectionAcquired(call, result);
     return result;
   }
 
-  public void streamFinished(boolean noNewStreams, HttpCodec codec) {
+  /**
+   * Releases the currently held connection and returns a socket to close if the held connection
+   * restricts new streams from being created. With HTTP/2 multiple requests share the same
+   * connection so it's possible that our connection is restricted from creating new streams during
+   * a follow-up request.
+   */
+  private Socket releaseIfNoNewStreams() {
+    assert (Thread.holdsLock(connectionPool));
+    RealConnection allocatedConnection = this.connection;
+    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+      return deallocate(false, false, true);
+    }
+    return null;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
+    eventListener.responseBodyEnd(call, bytesRead);
+
     Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
     synchronized (connectionPool) {
       if (codec == null || codec != this.codec) {
         throw new IllegalStateException("expected " + this.codec + " but was " + codec);
@@ -229,9 +306,23 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec) {
       if (!noNewStreams) {
         connection.successCount++;
       }
+      releasedConnection = connection;
       socket = deallocate(noNewStreams, false, true);
+      if (connection != null) releasedConnection = null;
+      callEnd = this.released;
     }
     closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (e != null) {
+      e = Internal.instance.timeoutExit(call, e);
+      eventListener.callFailed(call, e);
+    } else if (callEnd) {
+      Internal.instance.timeoutExit(call, null);
+      eventListener.callEnd(call);
+    }
   }
 
   public HttpCodec codec() {
@@ -244,25 +335,43 @@ private RouteDatabase routeDatabase() {
     return Internal.instance.routeDatabase(connectionPool);
   }
 
+  public Route route() {
+    return route;
+  }
+
   public synchronized RealConnection connection() {
     return connection;
   }
 
   public void release() {
     Socket socket;
+    Connection releasedConnection;
     synchronized (connectionPool) {
+      releasedConnection = connection;
       socket = deallocate(false, true, false);
+      if (connection != null) releasedConnection = null;
     }
     closeQuietly(socket);
+    if (releasedConnection != null) {
+      Internal.instance.timeoutExit(call, null);
+      eventListener.connectionReleased(call, releasedConnection);
+      eventListener.callEnd(call);
+    }
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
   public void noNewStreams() {
     Socket socket;
+    Connection releasedConnection;
     synchronized (connectionPool) {
+      releasedConnection = connection;
       socket = deallocate(true, false, false);
+      if (connection != null) releasedConnection = null;
     }
     closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
   }
 
   /**
@@ -317,17 +426,21 @@ public void cancel() {
 
   public void streamFailed(IOException e) {
     Socket socket;
+    Connection releasedConnection;
     boolean noNewStreams = false;
 
     synchronized (connectionPool) {
       if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
           refusedStreamCount++;
-        }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          if (refusedStreamCount > 1) {
+            noNewStreams = true;
+            route = null;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
           noNewStreams = true;
           route = null;
         }
@@ -343,21 +456,27 @@ public void streamFailed(IOException e) {
           route = null;
         }
       }
+      releasedConnection = connection;
       socket = deallocate(noNewStreams, false, true);
+      if (connection != null || !reportedAcquired) releasedConnection = null;
     }
 
     closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
   }
 
   /**
    * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
    * {@link #release} on the same connection.
    */
-  public void acquire(RealConnection connection) {
+  public void acquire(RealConnection connection, boolean reportedAcquired) {
     assert (Thread.holdsLock(connectionPool));
     if (this.connection != null) throw new IllegalStateException();
 
     this.connection = connection;
+    this.reportedAcquired = reportedAcquired;
     connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
   }
 
@@ -397,7 +516,9 @@ public Socket releaseAndAcquire(RealConnection newConnection) {
   }
 
   public boolean hasMoreRoutes() {
-    return route != null || routeSelector.hasNext();
+    return route != null
+        || (routeSelection != null && routeSelection.hasNext())
+        || routeSelector.hasNext();
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/duplex/HeadersListener.java b/okhttp/src/main/java/okhttp3/internal/duplex/HeadersListener.java
new file mode 100644
index 0000000000..4bb2b9ca3c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/duplex/HeadersListener.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import okhttp3.Headers;
+
+public interface HeadersListener {
+  void onHeaders(Headers headers);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/duplex/HttpSink.java b/okhttp/src/main/java/okhttp3/internal/duplex/HttpSink.java
new file mode 100644
index 0000000000..54b3cf425b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/duplex/HttpSink.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import java.io.Closeable;
+import java.io.IOException;
+import okhttp3.Headers;
+import okio.BufferedSink;
+
+/**
+ * A writable request or response that interleaves headers and data. Used for duplex!
+ *
+ * Currently only implemented for HTTP/2.
+ */
+public interface HttpSink extends Closeable {
+  BufferedSink sink();
+  void headers(Headers headers) throws IOException;
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index 54b561da88..c10dc34cdc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -106,7 +106,8 @@ public BridgeInterceptor(CookieJar cookieJar) {
           .removeAll("Content-Length")
           .build();
       responseBuilder.headers(strippedHeaders);
-      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+      String contentType = networkResponse.header("Content-Type");
+      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
     }
 
     return responseBuilder.build();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 3bc47183eb..e99436bed7 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,13 +17,22 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.duplex.HttpSink;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
+import okio.Buffer;
 import okio.BufferedSink;
+import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 
@@ -36,53 +45,122 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
+    final RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    final HttpCodec httpCodec = realChain.httpStream();
     StreamAllocation streamAllocation = realChain.streamAllocation();
     RealConnection connection = (RealConnection) realChain.connection();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
+
+    realChain.eventListener().requestHeadersStart(realChain.call());
     httpCodec.writeRequestHeaders(request);
+    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
 
+    HttpSink httpSink = null;
     Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+    if (HttpMethod.permitsRequestBody(request.method())
+        && (request.body() != null || Internal.instance.isDuplex(request))) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return what
-      // we did get (such as a 4xx response) without ever transmitting the request body.
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
         httpCodec.flushRequest();
+        realChain.eventListener().responseHeadersStart(realChain.call());
         responseBuilder = httpCodec.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
+        if (Internal.instance.isDuplex(request)) {
+          // Prepare a duplex body so that the application can send a request body later.
+          final CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, -1L));
+          final BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+          httpSink = new HttpSink() {
+            @Override public BufferedSink sink() {
+              return bufferedRequestBody;
+            }
+
+            @Override public void headers(Headers headers) throws IOException {
+              List<Header> headerBlock = new ArrayList<>(headers.size() / 2);
+              for (int i = 0, size = headers.size(); i < size; i++) {
+                headerBlock.add(new Header(headers.name(i), headers.value(i)));
+              }
+              ((Http2Codec) httpCodec).writeRequestHeaders(headerBlock);
+            }
+
+            @Override public void close() throws IOException {
+              bufferedRequestBody.close();
+              realChain.eventListener()
+                  .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+            }
+          };
+        } else {
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          realChain.eventListener().requestBodyStart(realChain.call());
+          long contentLength = request.body().contentLength();
+          CountingSink requestBodyOut =
+              new CountingSink(httpCodec.createRequestBody(request, contentLength));
+          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+          request.body().writeTo(bufferedRequestBody);
+          bufferedRequestBody.close();
+          realChain.eventListener()
+              .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+        }
       } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from
-        // being reused. Otherwise we're still obligated to transmit the request body to leave the
-        // connection in a consistent state.
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+        // from being reused. Otherwise we're still obligated to transmit the request body to
+        // leave the connection in a consistent state.
         streamAllocation.noNewStreams();
       }
     }
 
-    httpCodec.finishRequest();
+    if (Internal.instance.isDuplex(request)) {
+      httpCodec.flushRequest();
+    } else {
+      httpCodec.finishRequest();
+    }
 
     if (responseBuilder == null) {
+      realChain.eventListener().responseHeadersStart(realChain.call());
       responseBuilder = httpCodec.readResponseHeaders(false);
     }
 
-    Response response = responseBuilder
+    responseBuilder
         .request(request)
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
+        .receivedResponseAtMillis(System.currentTimeMillis());
+    Internal.instance.httpSink(responseBuilder, httpSink);
+    Response response = responseBuilder.build();
 
     int code = response.code();
+    if (code == 100) {
+      // server sent a 100-continue even though we did not request one.
+      // try again to read the actual response
+      responseBuilder = httpCodec.readResponseHeaders(false);
+
+      responseBuilder
+          .request(request)
+          .handshake(streamAllocation.connection().handshake())
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis());
+      Internal.instance.httpSink(responseBuilder, httpSink);
+      response = responseBuilder.build();
+
+      code = response.code();
+    }
+
+    if (Internal.instance.isDuplex(request)) {
+      Response.Builder builder = response.newBuilder();
+      Internal.instance.setHttp2Codec(builder, (Http2Codec) httpCodec);
+      response = builder.build();
+    }
+
+    realChain.eventListener()
+            .responseHeadersEnd(realChain.call(), response);
+
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
       response = response.newBuilder()
@@ -106,4 +184,17 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     return response;
   }
+
+  static final class CountingSink extends ForwardingSink {
+    long successfulCount;
+
+    CountingSink(Sink delegate) {
+      super(delegate);
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      super.write(source, byteCount);
+      successfulCount += byteCount;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 2991dd7b51..6df2cfd2ec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -37,7 +37,7 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          // Date format specified by RFC 7231 section 7.1.1.1.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
           rfc1123.setTimeZone(UTC);
@@ -90,7 +90,7 @@ public static Date parse(String value) {
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-          // specified by RFC 2616.
+          // specified by RFC 7231.
           format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index 0ce0d07858..479fe07a24 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -15,13 +15,15 @@
  */
 package okhttp3.internal.http;
 
+import java.io.EOFException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import okhttp3.Challenge;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
@@ -29,6 +31,8 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
+import okio.Buffer;
+import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
@@ -37,10 +41,8 @@
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class HttpHeaders {
-  private static final String TOKEN = "([^ \"=]*)";
-  private static final String QUOTED_STRING = "\"([^\"]*)\"";
-  private static final Pattern PARAMETER
-      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
+  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
+  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
 
   private HttpHeaders() {
   }
@@ -143,34 +145,168 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 2617 challenges, also wrong ordered ones.
-   * This API is only interested in the scheme name and realm.
+   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
+   * interpret a token.
+   *
+   * <p>For example, the first line has a parameter name/value pair and the second line has a single
+   * token68:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest foo=bar
+   *   WWW-Authenticate: Digest foo=
+   * }</pre>
+   *
+   * <p>Similarly, the first line has one challenge and the second line has two challenges:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest ,foo=bar
+   *   WWW-Authenticate: Digest ,foo
+   * }</pre>
    */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> challenges = new ArrayList<>();
-    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
-    for (String header : authenticationHeaders) {
-      int index = header.indexOf(' ');
-      if (index == -1) continue;
-
-      Matcher matcher = PARAMETER.matcher(header);
-      for (int i = index; matcher.find(i); i = matcher.end()) {
-        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          String scheme = header.substring(0, index);
-          String realm = matcher.group(3);
-          if (realm != null) {
-            challenges.add(new Challenge(scheme, realm));
-            break;
-          }
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
+    List<Challenge> result = new ArrayList<>();
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
+        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
+        parseChallengeHeader(result, header);
+      }
+    }
+    return result;
+  }
+
+  private static void parseChallengeHeader(List<Challenge> result, Buffer header) {
+    String peek = null;
+
+    while (true) {
+      // Read a scheme name for this challenge if we don't have one already.
+      if (peek == null) {
+        skipWhitespaceAndCommas(header);
+        peek = readToken(header);
+        if (peek == null) return;
+      }
+
+      String schemeName = peek;
+
+      // Read a token68, a sequence of parameters, or nothing.
+      boolean commaPrefixed = skipWhitespaceAndCommas(header);
+      peek = readToken(header);
+      if (peek == null) {
+        if (!header.exhausted()) return; // Expected a token; got something else.
+        result.add(new Challenge(schemeName, Collections.<String, String>emptyMap()));
+        return;
+      }
+
+      int eqCount = skipAll(header, (byte) '=');
+      boolean commaSuffixed = skipWhitespaceAndCommas(header);
+
+      // It's a token68 because there isn't a value after it.
+      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
+        result.add(new Challenge(schemeName, Collections.singletonMap(
+            (String) null, peek + repeat('=', eqCount))));
+        peek = null;
+        continue;
+      }
+
+      // It's a series of parameter names and values.
+      Map<String, String> parameters = new LinkedHashMap<>();
+      eqCount += skipAll(header, (byte) '=');
+      while (true) {
+        if (peek == null) {
+          peek = readToken(header);
+          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
+          eqCount = skipAll(header, (byte) '=');
         }
+        if (eqCount == 0) break; // We peeked a scheme name.
+        if (eqCount > 1) return; // Unexpected '=' characters.
+        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
+
+        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
+            ? readQuotedString(header)
+            : readToken(header);
+        if (parameterValue == null) return; // Expected a value.
+        String replaced = parameters.put(peek, parameterValue);
+        peek = null;
+        if (replaced != null) return; // Unexpected duplicate parameter.
+        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
+      }
+      result.add(new Challenge(schemeName, parameters));
+    }
+  }
+
+  /** Returns true if any commas were skipped. */
+  private static boolean skipWhitespaceAndCommas(Buffer buffer) {
+    boolean commaFound = false;
+    while (!buffer.exhausted()) {
+      byte b = buffer.getByte(0);
+      if (b == ',') {
+        buffer.readByte(); // Consume ','.
+        commaFound = true;
+      } else if (b == ' ' || b == '\t') {
+        buffer.readByte(); // Consume space or tab.
+      } else {
+        break;
       }
     }
-    return challenges;
+    return commaFound;
+  }
+
+  private static int skipAll(Buffer buffer, byte b) {
+    int count = 0;
+    while (!buffer.exhausted() && buffer.getByte(0) == b) {
+      count++;
+      buffer.readByte();
+    }
+    return count;
+  }
+
+  /**
+   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
+   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
+   * double-quoted string.
+   */
+  private static String readQuotedString(Buffer buffer) {
+    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
+    Buffer result = new Buffer();
+    while (true) {
+      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
+      if (i == -1L) return null; // Unterminated quoted string.
+
+      if (buffer.getByte(i) == '"') {
+        result.write(buffer, i);
+        buffer.readByte(); // Consume '"'.
+        return result.readUtf8();
+      }
+
+      if (buffer.size() == i + 1L) return null; // Dangling escape.
+      result.write(buffer, i);
+      buffer.readByte(); // Consume '\'.
+      result.write(buffer, 1L); // The escaped character.
+    }
+  }
+
+  /**
+   * Consumes and returns a non-empty token, terminating at special characters in {@link
+   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
+   */
+  private static String readToken(Buffer buffer) {
+    try {
+      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
+      if (tokenSize == -1L) tokenSize = buffer.size();
+
+      return tokenSize != 0L
+          ? buffer.readUtf8(tokenSize)
+          : null;
+    } catch (EOFException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
   }
 
   public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index e10fa88a77..da45901512 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -33,12 +33,7 @@ public static boolean requiresRequestBody(String method) {
   }
 
   public static boolean permitsRequestBody(String method) {
-    return requiresRequestBody(method)
-        || method.equals("OPTIONS")
-        || method.equals("DELETE")    // Permitted as spec is ambiguous.
-        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
-        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
-        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+    return !(method.equals("GET") || method.equals("HEAD"));
   }
 
   public static boolean redirectsWithBody(String method) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 77d2076997..2631a5422d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -17,15 +17,19 @@
 
 import java.io.IOException;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Call;
 import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
 
+import static okhttp3.internal.Util.checkDuration;
+
 /**
  * A concrete interceptor chain that carries the entire interceptor chain: all application
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
@@ -39,11 +43,14 @@
   private final Request request;
   private final Call call;
   private final EventListener eventListener;
+  private final int connectTimeout;
+  private final int readTimeout;
+  private final int writeTimeout;
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
       HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
-      EventListener eventListener) {
+      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
     this.interceptors = interceptors;
     this.connection = connection;
     this.streamAllocation = streamAllocation;
@@ -52,12 +59,45 @@ public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation str
     this.request = request;
     this.call = call;
     this.eventListener = eventListener;
+    this.connectTimeout = connectTimeout;
+    this.readTimeout = readTimeout;
+    this.writeTimeout = writeTimeout;
   }
 
   @Override public Connection connection() {
     return connection;
   }
 
+  @Override public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, millis, readTimeout, writeTimeout);
+  }
+
+  @Override public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, millis, writeTimeout);
+  }
+
+  @Override public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, readTimeout, millis);
+  }
+
   public StreamAllocation streamAllocation() {
     return streamAllocation;
   }
@@ -66,7 +106,7 @@ public HttpCodec httpStream() {
     return httpCodec;
   }
 
-  public Call call() {
+  @Override public Call call() {
     return call;
   }
 
@@ -102,7 +142,8 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
 
     // Call the next interceptor in the chain.
     RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener);
+        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+        writeTimeout);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
@@ -122,6 +163,11 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
           "interceptor " + interceptor + " returned a response with no body");
     }
 
+    if (Internal.instance.isDuplex(request) && Internal.instance.httpSink(response) == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no httpSink");
+    }
+
     return response;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index 673189c299..970d7ca949 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -15,27 +15,33 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Headers;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
-  private final Headers headers;
+  /**
+   * Use a string to avoid parsing the content type until needed. This also defers problems caused
+   * by malformed content types.
+   */
+  private final @Nullable String contentTypeString;
+  private final long contentLength;
   private final BufferedSource source;
 
-  public RealResponseBody(Headers headers, BufferedSource source) {
-    this.headers = headers;
+  public RealResponseBody(
+      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
+    this.contentTypeString = contentTypeString;
+    this.contentLength = contentLength;
     this.source = source;
   }
 
   @Override public MediaType contentType() {
-    String contentType = headers.get("Content-Type");
-    return contentType != null ? MediaType.parse(contentType) : null;
+    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
   }
 
   @Override public long contentLength() {
-    return HttpHeaders.contentLength(headers);
+    return contentLength;
   }
 
   @Override public BufferedSource source() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 990be2a9af..f8e787acac 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.http;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.HttpRetryException;
@@ -29,7 +30,6 @@
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
-import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
@@ -49,6 +49,7 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
@@ -66,7 +67,7 @@
 
   private final OkHttpClient client;
   private final boolean forWebSocket;
-  private StreamAllocation streamAllocation;
+  private volatile StreamAllocation streamAllocation;
   private Object callStackTrace;
   private volatile boolean canceled;
 
@@ -108,8 +109,9 @@ public StreamAllocation streamAllocation() {
     Call call = realChain.call();
     EventListener eventListener = realChain.eventListener();
 
-    streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
-        call, eventListener, callStackTrace);
+    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
+        createAddress(request.url()), call, eventListener, callStackTrace);
+    this.streamAllocation = streamAllocation;
 
     int followUpCount = 0;
     Response priorResponse = null;
@@ -119,22 +121,22 @@ public StreamAllocation streamAllocation() {
         throw new IOException("Canceled");
       }
 
-      Response response = null;
+      Response response;
       boolean releaseConnection = true;
       try {
         response = realChain.proceed(request, streamAllocation, null, null);
         releaseConnection = false;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), false, request)) {
-          throw e.getLastConnectException();
+        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
+          throw e.getFirstConnectException();
         }
         releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, requestSendStarted, request)) throw e;
+        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
         releaseConnection = false;
         continue;
       } finally {
@@ -154,12 +156,16 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
-      Request followUp = followUpRequest(response);
+      Request followUp;
+      try {
+        followUp = followUpRequest(response, streamAllocation.route());
+      } catch (IOException e) {
+        streamAllocation.release();
+        throw e;
+      }
 
       if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
-        }
+        streamAllocation.release();
         return response;
       }
 
@@ -179,6 +185,7 @@ public StreamAllocation streamAllocation() {
         streamAllocation.release();
         streamAllocation = new StreamAllocation(client.connectionPool(),
             createAddress(followUp.url()), call, eventListener, callStackTrace);
+        this.streamAllocation = streamAllocation;
       } else if (streamAllocation.codec() != null) {
         throw new IllegalStateException("Closing the body of " + response
             + " didn't close its backing stream. Bad interceptor?");
@@ -210,14 +217,15 @@ private Address createAddress(HttpUrl url) {
    * be recovered if the body is buffered or if the failure occurred before the request has been
    * sent.
    */
-  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+  private boolean recover(IOException e, StreamAllocation streamAllocation,
+      boolean requestSendStarted, Request userRequest) {
     streamAllocation.streamFailed(e);
 
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+    if (requestSendStarted && requestIsUnrepeatable(e, userRequest)) return false;
 
     // This exception is fatal.
     if (!isRecoverable(e, requestSendStarted)) return false;
@@ -229,6 +237,11 @@ private boolean recover(IOException e, boolean requestSendStarted, Request userR
     return true;
   }
 
+  private boolean requestIsUnrepeatable(IOException e, Request userRequest) {
+    return userRequest.body() instanceof UnrepeatableRequestBody
+        || e instanceof FileNotFoundException;
+  }
+
   private boolean isRecoverable(IOException e, boolean requestSendStarted) {
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
@@ -266,12 +279,8 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse) throws IOException {
+  private Request followUpRequest(Response userResponse, Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
     int responseCode = userResponse.code();
 
     final String method = userResponse.request().method();
@@ -344,17 +353,62 @@ private Request followUpRequest(Response userResponse) throws IOException {
         // 408's are rare in practice, but some servers like HAProxy use this response code. The
         // spec says that we may repeat the request without modifications. Modern browsers also
         // repeat the request (even non-idempotent ones.)
+        if (!client.retryOnConnectionFailure()) {
+          // The application layer has directed us not to retry the request.
+          return null;
+        }
+
         if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
           return null;
         }
 
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, 0) > 0) {
+          return null;
+        }
+
         return userResponse.request();
 
+      case HTTP_UNAVAILABLE:
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+          // specifically received an instruction to retry without delay
+          return userResponse.request();
+        }
+
+        return null;
+
       default:
         return null;
     }
   }
 
+  private int retryAfter(Response userResponse, int defaultDelay) {
+    String header = userResponse.header("Retry-After");
+
+    if (header == null) {
+      return defaultDelay;
+    }
+
+    // https://tools.ietf.org/html/rfc7231#section-7.1.3
+    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+    if (header.matches("\\d+")) {
+      return Integer.valueOf(header);
+    }
+
+    return Integer.MAX_VALUE;
+  }
+
   /**
    * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
    * engine.
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 4be3a32ccc..6c7b4373c4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -74,6 +74,7 @@
   private static final int STATE_OPEN_RESPONSE_BODY = 4;
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
+  private static final int HEADER_LIMIT = 256 * 1024;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
   final OkHttpClient client;
@@ -83,6 +84,7 @@
   final BufferedSource source;
   final BufferedSink sink;
   int state = STATE_IDLE;
+  private long headerLimit = HEADER_LIMIT;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
@@ -129,28 +131,26 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
 
-  private Source getTransferStream(Response response) throws IOException {
     if (!HttpHeaders.hasBody(response)) {
-      return newFixedLengthSource(0);
+      Source source = newFixedLengthSource(0);
+      return new RealResponseBody(contentType, 0, Okio.buffer(source));
     }
 
     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(response.request().url());
+      Source source = newChunkedSource(response.request().url());
+      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
     }
 
     long contentLength = HttpHeaders.contentLength(response);
     if (contentLength != -1) {
-      return newFixedLengthSource(contentLength);
+      Source source = newFixedLengthSource(contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
     }
 
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return newUnknownLengthSource();
+    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
   }
 
   /** Returns true if this connection is closed. */
@@ -186,7 +186,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
 
     try {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+      StatusLine statusLine = StatusLine.parse(readHeaderLine());
 
       Response.Builder responseBuilder = new Response.Builder()
           .protocol(statusLine.protocol)
@@ -196,6 +196,9 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
 
       if (expectContinue && statusLine.code == HTTP_CONTINUE) {
         return null;
+      } else if (statusLine.code == HTTP_CONTINUE) {
+        state = STATE_READ_RESPONSE_HEADERS;
+        return responseBuilder;
       }
 
       state = STATE_OPEN_RESPONSE_BODY;
@@ -208,11 +211,17 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
   }
 
+  private String readHeaderLine() throws IOException {
+    String line = source.readUtf8LineStrict(headerLimit);
+    headerLimit -= line.length();
+    return line;
+  }
+
   /** Reads headers or trailers. */
   public Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
-    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+    for (String line; (line = readHeaderLine()).length() != 0; ) {
       Internal.instance.addLenient(headers, line);
     }
     return headers.build();
@@ -343,16 +352,30 @@ void detachTimeout(ForwardingTimeout timeout) {
   private abstract class AbstractSource implements Source {
     protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
+    protected long bytesRead = 0;
 
     @Override public Timeout timeout() {
       return timeout;
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = source.read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(false, e);
+        throw e;
+      }
+    }
+
     /**
      * Closes the cache entry and makes the socket available for reuse. This should be invoked when
      * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean reuseConnection) throws IOException {
+    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
       if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
@@ -360,7 +383,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
       }
     }
   }
@@ -372,7 +395,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
     FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
@@ -381,15 +404,16 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised content length.
+        throw e;
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
       return read;
     }
@@ -398,7 +422,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
 
       closed = true;
@@ -426,10 +450,11 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
         if (!hasMoreChunks) return -1;
       }
 
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        throw e;
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -453,14 +478,14 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
@@ -479,10 +504,10 @@ private void readChunkSize() throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = super.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(true);
+        endOfInput(true, null);
         return -1;
       }
       return read;
@@ -491,7 +516,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
index 26defebe06..6a704684fc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
@@ -28,7 +28,17 @@
 
   REFUSED_STREAM(7),
 
-  CANCEL(8);
+  CANCEL(8),
+
+  COMPRESSION_ERROR(9),
+
+  CONNECT_ERROR(0xa),
+
+  ENHANCE_YOUR_CALM(0xb),
+
+  INADEQUATE_SECURITY(0xc),
+
+  HTTP_1_1_REQUIRED(0xd);
 
   public final int httpCode;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 3cfd7be8d7..a306ac4622 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -22,11 +22,19 @@
 public final class Header {
   // Special header names defined in HTTP/2 spec.
   public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
+
+  public static final String RESPONSE_STATUS_UTF8 = ":status";
+  public static final String TARGET_METHOD_UTF8 = ":method";
+  public static final String TARGET_PATH_UTF8 = ":path";
+  public static final String TARGET_SCHEME_UTF8 = ":scheme";
+  public static final String TARGET_AUTHORITY_UTF8 = ":authority";
+
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(RESPONSE_STATUS_UTF8);
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(TARGET_METHOD_UTF8);
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(TARGET_PATH_UTF8);
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(TARGET_SCHEME_UTF8);
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(TARGET_AUTHORITY_UTF8);
+
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index a28698bf01..258ac9b269 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -221,7 +221,7 @@ private void readIndexedHeader(int index) throws IOException {
         headerList.add(staticEntry);
       } else {
         int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
+        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
           throw new IOException("Header index too large " + (index + 1));
         }
         headerList.add(dynamicTable[dynamicTableIndex]);
@@ -258,11 +258,16 @@ private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOExceptio
       insertIntoDynamicTable(-1, new Header(name, value));
     }
 
-    private ByteString getName(int index) {
+    private ByteString getName(int index) throws IOException {
       if (isStaticHeader(index)) {
         return STATIC_HEADER_TABLE[index].name;
       } else {
-        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
+          throw new IOException("Header index too large " + (index + 1));
+        }
+
+        return dynamicTable[dynamicTableIndex].name;
       }
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 0ed8be7b39..83758f67f6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -22,6 +22,7 @@
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -30,10 +31,13 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.duplex.HeadersListener;
 import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
 import okio.ByteString;
 import okio.ForwardingSource;
 import okio.Okio;
@@ -41,25 +45,29 @@
 import okio.Source;
 
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
 
 /** Encode requests and responses using HTTP/2 frames. */
 public final class Http2Codec implements HttpCodec {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+  private static final String CONNECTION = "connection";
+  private static final String HOST = "host";
+  private static final String KEEP_ALIVE = "keep-alive";
+  private static final String PROXY_CONNECTION = "proxy-connection";
+  private static final String TRANSFER_ENCODING = "transfer-encoding";
+  private static final String TE = "te";
+  private static final String ENCODING = "encoding";
+  private static final String UPGRADE = "upgrade";
 
   /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -68,11 +76,11 @@
       TRANSFER_ENCODING,
       ENCODING,
       UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      TARGET_METHOD_UTF8,
+      TARGET_PATH_UTF8,
+      TARGET_SCHEME_UTF8,
+      TARGET_AUTHORITY_UTF8);
+  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -82,16 +90,20 @@
       ENCODING,
       UPGRADE);
 
-  private final OkHttpClient client;
+  private final Interceptor.Chain chain;
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
+  private final Protocol protocol;
 
-  public Http2Codec(
-      OkHttpClient client, StreamAllocation streamAllocation, Http2Connection connection) {
-    this.client = client;
+  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
+      Http2Connection connection) {
+    this.chain = chain;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
+    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        ? Protocol.H2_PRIOR_KNOWLEDGE
+        : Protocol.HTTP_2;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -101,11 +113,22 @@ public Http2Codec(
   @Override public void writeRequestHeaders(Request request) throws IOException {
     if (stream != null) return;
 
-    boolean hasRequestBody = request.body() != null;
+    boolean hasRequestBody = request.body() != null || Internal.instance.isDuplex(request);
     List<Header> requestHeaders = http2HeadersList(request);
     stream = connection.newStream(requestHeaders, hasRequestBody);
-    stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  /** Write more headers for the request. */
+  public void writeRequestHeaders(List<Header> headers) throws IOException {
+    if (stream == null) throw new IllegalStateException("stream == null");
+    stream.writeHeaders(headers, true);
+  }
+
+  public void setHeadersListener(HeadersListener headersListener) {
+    if (stream == null) throw new IllegalStateException("stream == null");
+    stream.setHeadersListener(headersListener);
   }
 
   @Override public void flushRequest() throws IOException {
@@ -117,8 +140,8 @@ public Http2Codec(
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    List<Header> headers = stream.takeResponseHeaders();
-    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    Headers headers = stream.takeHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
       return null;
     }
@@ -139,7 +162,7 @@ public Http2Codec(
     for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
       ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name.utf8())) {
         result.add(new Header(name, headers.value(i)));
       }
     }
@@ -147,42 +170,34 @@ public Http2Codec(
   }
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
+      Protocol protocol) throws IOException {
     StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      Header header = headerBlock.get(i);
-
-      // If there were multiple header blocks they will be delimited by nulls. Discard existing
-      // header blocks if the existing header block is a '100 Continue' intermediate response.
-      if (header == null) {
-        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
-          statusLine = null;
-          headersBuilder = new Headers.Builder();
-        }
-        continue;
-      }
-
-      ByteString name = header.name;
-      String value = header.value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
+      String name = headerBlock.name(i);
+      String value = headerBlock.value(i);
+      if (name.equals(RESPONSE_STATUS_UTF8)) {
         statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+        Internal.instance.addLenient(headersBuilder, name, value);
       }
     }
     if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
 
     return new Response.Builder()
-        .protocol(Protocol.HTTP_2)
+        .protocol(protocol)
         .code(statusLine.code)
         .message(statusLine.message)
         .headers(headersBuilder.build());
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
+    long contentLength = HttpHeaders.contentLength(response);
     Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
+    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
   }
 
   @Override public void cancel() {
@@ -190,13 +205,35 @@ public Http2Codec(
   }
 
   class StreamFinishingSource extends ForwardingSource {
+    boolean completed = false;
+    long bytesRead = 0;
+
     StreamFinishingSource(Source delegate) {
       super(delegate);
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(e);
+        throw e;
+      }
+    }
+
     @Override public void close() throws IOException {
-      streamAllocation.streamFinished(false, Http2Codec.this);
       super.close();
+      endOfInput(null);
+    }
+
+    private void endOfInput(IOException e) {
+      if (completed) return;
+      completed = true;
+      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 023a7ff35d..aa77584e23 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -27,9 +27,13 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
@@ -40,6 +44,8 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
 
@@ -66,7 +72,13 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /**
+   * Shared executor to send notifications of incoming streams. This executor requires multiple
+   * threads because listeners are not required to return promptly.
+   */
+  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp Http2Connection", true));
 
@@ -75,7 +87,7 @@
 
   /**
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #executor}.
+   * on {@link #listenerExecutor}.
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
@@ -84,14 +96,17 @@
   int nextStreamId;
   boolean shutdown;
 
+  /** Asynchronously writes frames to the outgoing socket. */
+  private final ScheduledExecutorService writerExecutor;
+
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
 
-  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
-  private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
   final PushObserver pushObserver;
-  private int nextPingId;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
 
   /**
    * The total number of bytes consumed by the application, but not yet acknowledged by sending a
@@ -109,8 +124,6 @@
   /** Settings we communicate to the peer. */
   Settings okHttpSettings = new Settings();
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
@@ -132,8 +145,6 @@
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
-    nextPingId = builder.client ? 1 : 2;
-
     // Flow control was designed more for servers, or proxies than edge clients.
     // If we are a client, set the flow control window to 16MiB.  This avoids
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
@@ -144,6 +155,13 @@
 
     hostname = builder.hostname;
 
+    writerExecutor = new ScheduledThreadPoolExecutor(1,
+        Util.threadFactory(Util.format("OkHttp %s Writer", hostname), false));
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
+          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
+    }
+
     // Like newSingleThreadExecutor, except lazy creates the thread.
     pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
@@ -183,6 +201,14 @@ public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
+  synchronized void updateConnectionFlowControl(long read) {
+    unacknowledgedBytesRead += read;
+    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead);
+      unacknowledgedBytesRead = 0;
+    }
+  }
+
   /**
    * Returns a new server-initiated stream.
    *
@@ -215,12 +241,15 @@ private Http2Stream newStream(
 
     synchronized (writer) {
       synchronized (this) {
+        if (nextStreamId > Integer.MAX_VALUE / 2) {
+          shutdown(REFUSED_STREAM);
+        }
         if (shutdown) {
           throw new ConnectionShutdownException();
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
@@ -279,6 +308,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
 
@@ -292,23 +322,20 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
     }
   }
 
-  /**
-   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) Http2Connection.this.notifyAll();
-  }
-
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+    try {
+      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+        @Override public void execute() {
+          try {
+            writeSynReset(streamId, errorCode);
+          } catch (IOException e) {
+            failConnection();
+          }
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
@@ -316,59 +343,70 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writer.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
+    try {
+      writerExecutor.execute(
+          new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+            @Override public void execute() {
+              try {
+                writer.windowUpdate(streamId, unacknowledgedBytesRead);
+              } catch (IOException e) {
+                failConnection();
+              }
+            }
+          });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
-  /**
-   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
-   * observe its round trip time.
-   */
-  public Ping ping() throws IOException {
-    Ping ping = new Ping();
-    int pingId;
-    synchronized (this) {
-      if (shutdown) {
-        throw new ConnectionShutdownException();
-      }
-      pingId = nextPingId;
-      nextPingId += 2;
-      if (pings == null) pings = new LinkedHashMap<>();
-      pings.put(pingId, ping);
+  final class PingRunnable extends NamedRunnable {
+    final boolean reply;
+    final int payload1;
+    final int payload2;
+
+    PingRunnable(boolean reply, int payload1, int payload2) {
+      super("OkHttp %s ping %08x%08x", hostname, payload1, payload2);
+      this.reply = reply;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+    }
+
+    @Override public void execute() {
+      writePing(reply, payload1, payload2);
     }
-    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
-    return ping;
   }
 
-  void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostname, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
+  void writePing(boolean reply, int payload1, int payload2) {
+    if (!reply) {
+      boolean failedDueToMissingPong;
+      synchronized (this) {
+        failedDueToMissingPong = awaitingPong;
+        awaitingPong = true;
       }
-    });
-  }
+      if (failedDueToMissingPong) {
+        failConnection();
+        return;
+      }
+    }
 
-  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (writer) {
-      // Observe the sent time immediately before performing I/O.
-      if (ping != null) ping.send();
+    try {
       writer.ping(reply, payload1, payload2);
+    } catch (IOException e) {
+      failConnection();
     }
   }
 
-  synchronized Ping removePing(int id) {
-    return pings != null ? pings.remove(id) : null;
+  /** For testing: sends a ping and waits for a pong. */
+  void writePingAndAwaitPong() throws InterruptedException {
+    writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
+    awaitPong();
+  }
+
+  /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
+  synchronized void awaitPong() throws InterruptedException {
+    while (awaitingPong) {
+      wait();
+    }
   }
 
   public void flush() throws IOException {
@@ -414,16 +452,11 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     }
 
     Http2Stream[] streamsToClose = null;
-    Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
         streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
         streams.clear();
       }
-      if (pings != null) {
-        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
-        pings = null;
-      }
     }
 
     if (streamsToClose != null) {
@@ -436,12 +469,6 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       }
     }
 
-    if (pingsToCancel != null) {
-      for (Ping ping : pingsToCancel) {
-        ping.cancel();
-      }
-    }
-
     // Close the writer to release its resources (such as deflaters).
     try {
       writer.close();
@@ -456,9 +483,20 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       thrown = e;
     }
 
+    // Release the threads.
+    writerExecutor.shutdown();
+    pushExecutor.shutdown();
+
     if (thrown != null) throw thrown;
   }
 
+  private void failConnection() {
+    try {
+      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Sends any initial frames and starts reading frames from the remote peer. This should be called
    * after {@link Builder#build} for all new connections.
@@ -491,8 +529,8 @@ public void setSettings(Settings settings) throws IOException {
           throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
-        writer.settings(settings);
       }
+      writer.settings(settings);
     }
   }
 
@@ -508,6 +546,7 @@ public synchronized boolean isShutdown() {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    int pingIntervalMillis;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -541,6 +580,11 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
+    public Builder pingIntervalMillis(int pingIntervalMillis) {
+      this.pingIntervalMillis = pingIntervalMillis;
+      return this;
+    }
+
     public Http2Connection build() {
       return new Http2Connection(this);
     }
@@ -588,6 +632,7 @@ public Http2Connection build() {
       Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        updateConnectionFlowControl(length);
         source.skip(length);
         return;
       }
@@ -605,12 +650,12 @@ public Http2Connection build() {
       }
       Http2Stream stream;
       synchronized (Http2Connection.this) {
-        // If we're shutdown, don't bother with this stream.
-        if (shutdown) return;
-
         stream = getStream(streamId);
 
         if (stream == null) {
+          // If we're shutdown, don't bother with this stream.
+          if (shutdown) return;
+
           // If the stream ID is less than the last created ID, assume it's already closed.
           if (streamId <= lastGoodStreamId) return;
 
@@ -618,11 +663,12 @@ public Http2Connection build() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
+          Headers headers = Util.toHeaders(headerBlock);
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock);
+              false, inFinished, headers);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
@@ -667,14 +713,13 @@ public Http2Connection build() {
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
-            addBytesToWriteWindow(delta);
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -690,14 +735,19 @@ public Http2Connection build() {
     }
 
     private void applyAndAckSettings(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
-        @Override public void execute() {
-          try {
-            writer.applyAndAckSettings(peerSettings);
-          } catch (IOException ignored) {
+      try {
+        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+          @Override public void execute() {
+            try {
+              writer.applyAndAckSettings(peerSettings);
+            } catch (IOException e) {
+              failConnection();
+            }
           }
-        }
-      });
+        });
+      } catch (RejectedExecutionException ignored) {
+        // This connection has been closed.
+      }
     }
 
     @Override public void ackSettings() {
@@ -706,13 +756,17 @@ private void applyAndAckSettings(final Settings peerSettings) {
 
     @Override public void ping(boolean reply, int payload1, int payload2) {
       if (reply) {
-        Ping ping = removePing(payload1);
-        if (ping != null) {
-          ping.receive();
+        synchronized (Http2Connection.this) {
+          awaitingPong = false;
+          Http2Connection.this.notifyAll();
         }
       } else {
-        // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
+        try {
+          // Send a reply to a client ping if this is a server and vice versa.
+          writerExecutor.execute(new PingRunnable(true, payload1, payload2));
+        } catch (RejectedExecutionException ignored) {
+          // This connection has been closed.
+        }
       }
     }
 
@@ -730,7 +784,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
       // Fail all streams created after the last good stream ID.
       for (Http2Stream http2Stream : streamsCopy) {
         if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
-          http2Stream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          http2Stream.receiveRstStream(REFUSED_STREAM);
           removeStream(http2Stream.getId());
         }
       }
@@ -784,38 +838,46 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-        try {
-          if (cancel) {
-            writer.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+          try {
+            if (cancel) {
+              writer.rstStream(streamId, ErrorCode.CANCEL);
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+          try {
+            if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
+            if (cancel || inFinished) {
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   /**
@@ -828,7 +890,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -845,7 +907,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
   }
 
   void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (Http2Connection.this) {
@@ -855,17 +917,23 @@ void pushResetLater(final int streamId, final ErrorCode errorCode) {
     });
   }
 
+  private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
+    if (!isShutdown()) {
+      pushExecutor.execute(namedRunnable);
+    }
+  }
+
   /** Listener of streams and settings initiated by the peer. */
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
       @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(ErrorCode.REFUSED_STREAM);
+        stream.close(REFUSED_STREAM);
       }
     };
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
      * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index 2b093b3323..1484a269eb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -254,7 +254,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
     if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
     Settings settings = new Settings();
     for (int i = 0; i < length; i += 6) {
-      short id = source.readShort();
+      int id = source.readShort() & 0xFFFF;
       int value = source.readInt();
 
       switch (id) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 19ac954d7e..c38483d7a1 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -19,8 +19,14 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.SocketTimeoutException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
+import okhttp3.internal.duplex.HeadersListener;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -51,11 +57,12 @@
   final int id;
   final Http2Connection connection;
 
-  /** Request headers. Immutable and non null. */
-  private final List<Header> requestHeaders;
-
-  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
-  private List<Header> responseHeaders;
+  /**
+   * Received headers yet to be {@linkplain #takeHeaders taken}, or {@linkplain FramingSource#read
+   * read}.
+   */
+  private final Deque<Headers> headersQueue = new ArrayDeque<>();
+  private HeadersListener headersListener;
 
   /** True if response headers have been sent or received. */
   private boolean hasResponseHeaders;
@@ -73,9 +80,9 @@
   ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
+      @Nullable Headers headers) {
     if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
@@ -84,7 +91,15 @@
     this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.requestHeaders = requestHeaders;
+    if (headers != null) {
+      headersQueue.add(headers);
+    }
+
+    if (isLocallyInitiated() && headers != null) {
+      throw new IllegalStateException("locally-initiated streams shouldn't have headers yet");
+    } else if (!isLocallyInitiated() && headers == null) {
+      throw new IllegalStateException("remotely-initiated streams should have headers");
+    }
   }
 
   public int getId() {
@@ -124,31 +139,22 @@ public Http2Connection getConnection() {
     return connection;
   }
 
-  public List<Header> getRequestHeaders() {
-    return requestHeaders;
-  }
-
   /**
    * Removes and returns the stream's received response headers, blocking if necessary until headers
    * have been received. If the returned list contains multiple blocks of headers the blocks will be
    * delimited by 'null'.
    */
-  public synchronized List<Header> takeResponseHeaders() throws IOException {
-    if (!isLocallyInitiated()) {
-      throw new IllegalStateException("servers cannot read response headers");
-    }
+  public synchronized Headers takeHeaders() throws IOException {
     readTimeout.enter();
     try {
-      while (responseHeaders == null && errorCode == null) {
+      while (headersQueue.isEmpty() && errorCode == null) {
         waitForIo();
       }
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    List<Header> result = responseHeaders;
-    if (result != null) {
-      responseHeaders = null;
-      return result;
+    if (!headersQueue.isEmpty()) {
+      return headersQueue.removeFirst();
     }
     throw new StreamResetException(errorCode);
   }
@@ -167,22 +173,34 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+  public void writeHeaders(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     if (responseHeaders == null) {
-      throw new NullPointerException("responseHeaders == null");
+      throw new NullPointerException("headers == null");
     }
     boolean outFinished = false;
+    boolean flushHeaders = false;
     synchronized (this) {
       this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
+        flushHeaders = true;
         outFinished = true;
       }
     }
+
+    // Only DATA frames are subject to flow-control. Transmit the HEADER frame if the connection
+    // flow-control window is fully depleted.
+    if (!flushHeaders) {
+      synchronized (connection) {
+        flushHeaders = connection.bytesLeftInWriteWindow == 0L;
+      }
+    }
+
+    // TODO(jwilson): rename to writeHeaders
     connection.writeSynReply(id, outFinished, responseHeaders);
 
-    if (outFinished) {
+    if (flushHeaders) {
       connection.flush();
     }
   }
@@ -204,7 +222,7 @@ public Source getSource() {
    * Returns a sink that can be used to write data to the peer.
    *
    * @throws IllegalStateException if this stream was initiated by the peer and a {@link
-   * #sendResponseHeaders} has not yet been sent.
+   * #writeHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -254,22 +272,18 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
+  /**
+   * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or
+   * {@link FramingSource#read} them.
+   */
   void receiveHeaders(List<Header> headers) {
     assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open = true;
+    boolean open;
     synchronized (this) {
       hasResponseHeaders = true;
-      if (responseHeaders == null) {
-        responseHeaders = headers;
-        open = isOpen();
-        notifyAll();
-      } else {
-        List<Header> newHeaders = new ArrayList<>();
-        newHeaders.addAll(responseHeaders);
-        newHeaders.add(null); // Delimit separate blocks of headers with null.
-        newHeaders.addAll(headers);
-        this.responseHeaders = newHeaders;
-      }
+      headersQueue.add(Util.toHeaders(headers));
+      open = isOpen();
+      notifyAll();
     }
     if (!open) {
       connection.removeStream(id);
@@ -301,6 +315,10 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
+  public synchronized void setHeadersListener(HeadersListener headersListener) {
+    this.headersListener = headersListener;
+  }
+
   /**
    * A source that reads the incoming data frames of a stream. Although this class uses
    * synchronization to safely receive incoming data frames, it is not intended for use by multiple
@@ -332,49 +350,83 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-      long read;
-      synchronized (Http2Stream.this) {
-        waitUntilReadable();
-        checkNotClosed();
-        if (readBuffer.size() == 0) return -1; // This source is exhausted.
-
-        // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
-
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-          unacknowledgedBytesRead = 0;
+      while (true) {
+        Headers headersToDeliver = null;
+        HeadersListener headersListenerToNotify = null;
+        long readBytesDelivered = -1;
+        ErrorCode errorCodeToDeliver = null;
+
+        // 1. Decide what to do in a synchronized block.
+
+        synchronized (Http2Stream.this) {
+          readTimeout.enter();
+          try {
+            if (errorCode != null) {
+              // Prepare to deliver an error.
+              errorCodeToDeliver = errorCode;
+            }
+
+            if (closed) {
+              throw new IOException("stream closed");
+
+            } else if (!headersQueue.isEmpty() && headersListener != null) {
+              // Prepare to deliver headers.
+              headersToDeliver = headersQueue.removeFirst();
+              headersListenerToNotify = headersListener;
+
+            } else if (readBuffer.size() > 0) {
+              // Prepare to read bytes. Start by moving them to the caller's buffer.
+              readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+              unacknowledgedBytesRead += readBytesDelivered;
+
+              if (errorCodeToDeliver == null
+                  && unacknowledgedBytesRead
+                  >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+                // Flow control: notify the peer that we're ready for more data! Only send a
+                // WINDOW_UPDATE if the stream isn't in error.
+                connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+                unacknowledgedBytesRead = 0;
+              }
+            } else if (!finished && errorCodeToDeliver == null) {
+              // Nothing to do. Wait until that changes then try again.
+              waitForIo();
+              continue;
+            }
+          } finally {
+            readTimeout.exitAndThrowIfTimedOut();
+          }
         }
-      }
 
-      // Update connection.unacknowledgedBytesRead outside the stream lock.
-      synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += read;
-        if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-          connection.unacknowledgedBytesRead = 0;
+        // 2. Do it outside of the synchronized block and timeout.
+
+        if (headersToDeliver != null && headersListenerToNotify != null) {
+          headersListenerToNotify.onHeaders(headersToDeliver);
+          continue;
         }
-      }
 
-      return read;
-    }
+        if (readBytesDelivered != -1) {
+          // Update connection.unacknowledgedBytesRead outside the synchronized block.
+          updateConnectionFlowControl(readBytesDelivered);
+          return readBytesDelivered;
+        }
 
-    /** Returns once the source is either readable or finished. */
-    private void waitUntilReadable() throws IOException {
-      readTimeout.enter();
-      try {
-        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          waitForIo();
+        if (errorCodeToDeliver != null) {
+          // We defer throwing the exception until now so that we can refill the connection
+          // flow-control window. This is necessary because we don't transmit window updates until
+          // the application reads the data. If we throw this prior to updating the connection
+          // flow-control window, we risk having it go to 0 preventing the server from sending data.
+          throw new StreamResetException(errorCodeToDeliver);
         }
-      } finally {
-        readTimeout.exitAndThrowIfTimedOut();
+
+        return -1; // This source is exhausted.
       }
     }
 
+    private void updateConnectionFlowControl(long read) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      connection.updateConnectionFlowControl(read);
+    }
+
     void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
 
@@ -420,20 +472,28 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
+      long bytesDiscarded;
+      List<Headers> headersToDeliver = null;
+      HeadersListener headersListenerToNotify = null;
       synchronized (Http2Stream.this) {
         closed = true;
+        bytesDiscarded = readBuffer.size();
         readBuffer.clear();
-        Http2Stream.this.notifyAll();
+        if (!headersQueue.isEmpty() && headersListener != null) {
+          headersToDeliver = new ArrayList<>(headersQueue);
+          headersQueue.clear();
+          headersListenerToNotify = headersListener;
+        }
+        Http2Stream.this.notifyAll(); // TODO(jwilson): Unnecessary?
       }
-      cancelStreamIfNecessary();
-    }
-
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
+      if (bytesDiscarded > 0) {
+        updateConnectionFlowControl(bytesDiscarded);
       }
-      if (errorCode != null) {
-        throw new StreamResetException(errorCode);
+      cancelStreamIfNecessary();
+      if (headersListenerToNotify != null) {
+        for (Headers headers : headersToDeliver) {
+          headersListenerToNotify.onHeaders(headers);
+        }
       }
     }
   }
@@ -576,6 +636,7 @@ void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
+      Thread.currentThread().interrupt(); // Retain interrupted status.
       throw new InterruptedIOException();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
deleted file mode 100644
index 7847db7aab..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A locally-originated ping.
- */
-final class Ping {
-  private final CountDownLatch latch = new CountDownLatch(1);
-  private long sent = -1;
-  private long received = -1;
-
-  Ping() {
-  }
-
-  void send() {
-    if (sent != -1) throw new IllegalStateException();
-    sent = System.nanoTime();
-  }
-
-  void receive() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = System.nanoTime();
-    latch.countDown();
-  }
-
-  void cancel() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = sent - 1;
-    latch.countDown();
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
-   * necessary. Returns -1 if the response was canceled.
-   */
-  public long roundTripTime() throws InterruptedException {
-    latch.await();
-    return received - sent;
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
-   * or -2 if the timeout elapsed before the round trip completed.
-   */
-  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
-    if (latch.await(timeout, unit)) {
-      return received - sent;
-    } else {
-      return -2;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index 31772c63f7..08b102c6e0 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.platform;
 
+import android.os.Build;
 import android.util.Log;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
@@ -22,10 +23,14 @@
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.security.cert.Certificate;
 import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -36,6 +41,8 @@
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 
+import static okhttp3.internal.Util.assertionError;
+
 /** Android 2.3 or better. */
 class AndroidPlatform extends Platform {
   private static final int MAX_LOG_LENGTH = 4000;
@@ -73,10 +80,20 @@
       IOException ioException = new IOException("Exception in connect");
       ioException.initCause(e);
       throw ioException;
+    } catch (ClassCastException e) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(e);
+        throw ioException;
+      } else {
+        throw e;
+      }
     }
   }
 
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
     if (context == null) {
       // If that didn't work, try the Google Play Services SSL provider before giving up. This
@@ -113,7 +130,7 @@
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     if (getAlpnSelectedProtocol == null) return null;
     if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
@@ -121,7 +138,7 @@
     return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
   }
 
-  @Override public void log(int level, String message, Throwable t) {
+  @Override public void log(int level, String message, @Nullable Throwable t) {
     int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
     if (t != null) message = message + '\n' + Log.getStackTraceString(t);
 
@@ -158,7 +175,7 @@
     } catch (ClassNotFoundException | NoSuchMethodException e) {
       return super.isCleartextTrafficPermitted(hostname);
     } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to determine cleartext support", e);
     }
   }
 
@@ -184,6 +201,23 @@ private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> netwo
     }
   }
 
+  /**
+   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
+   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
+   * ALPN support.
+   */
+  private static boolean supportsAlpn() {
+    if (Security.getProvider("GMSCore_OpenSSL") != null) {
+      return true;
+    } else {
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        return true;
+      } catch (ClassNotFoundException ignored) { }
+    }
+    return false;
+  }
+
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
     try {
       Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
@@ -216,12 +250,11 @@ public static Platform buildIfSupported() {
       OptionalMethod<Socket> getAlpnSelectedProtocol = null;
       OptionalMethod<Socket> setAlpnProtocols = null;
 
-      // Attempt to find Android 5.0+ APIs.
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      } catch (ClassNotFoundException ignored) {
+      if (supportsAlpn()) {
+        getAlpnSelectedProtocol
+            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols
+            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
       }
 
       return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
@@ -372,7 +405,7 @@ static CloseGuard get() {
                 ? trustAnchor.getTrustedCert()
                 : null;
       } catch (IllegalAccessException e) {
-        throw new AssertionError();
+        throw assertionError("unable to get issues and signature", e);
       } catch (InvocationTargetException e) {
         return null;
       }
@@ -396,4 +429,29 @@ public int hashCode() {
       return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
     }
   }
+
+  @Override public SSLContext getSSLContext() {
+    boolean tryTls12;
+    try {
+      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
+    } catch (NoClassDefFoundError e) {
+      // Not a real Android runtime; probably RoboVM or MoE
+      // Try to load TLS 1.2 explicitly.
+      tryTls12 = true;
+    }
+
+    if (tryTls12) {
+      try {
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS");
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
new file mode 100644
index 0000000000..e460595329
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.Provider;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import org.conscrypt.Conscrypt;
+
+/**
+ * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
+ *
+ * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
+ */
+public class ConscryptPlatform extends Platform {
+  private ConscryptPlatform() {
+  }
+
+  private Provider getProvider() {
+    return Conscrypt.newProviderBuilder().provideTrustManager().build();
+  }
+
+  @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
+      return super.trustManager(sslSocketFactory);
+    }
+
+    try {
+      // org.conscrypt.SSLParametersImpl
+      Object sp =
+          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
+
+      if (sp != null) {
+        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
+      }
+
+      return null;
+    } catch (Exception e) {
+      throw new UnsupportedOperationException(
+          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
+    }
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true);
+        Conscrypt.setHostname(sslSocket, hostname);
+      }
+
+      // Enable ALPN.
+      List<String> names = Platform.alpnProtocolNames(protocols);
+      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols);
+    }
+  }
+
+  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      return Conscrypt.getApplicationProtocol(sslSocket);
+    } else {
+      return super.getSelectedProtocol(sslSocket);
+    }
+  }
+
+  @Override public SSLContext getSSLContext() {
+    try {
+      return SSLContext.getInstance("TLSv1.3", getProvider());
+    } catch (NoSuchAlgorithmException e) {
+      try {
+        // Allow for Conscrypt 1.2
+        return SSLContext.getInstance("TLS", getProvider());
+      } catch (NoSuchAlgorithmException e2) {
+        throw new IllegalStateException("No TLS provider", e);
+      }
+    }
+  }
+
+  public static ConscryptPlatform buildIfSupported() {
+    try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.conscrypt.Conscrypt");
+
+      if (!Conscrypt.isAvailable()) {
+        return null;
+      }
+
+      return new ConscryptPlatform();
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  @Override
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+    if (Conscrypt.isConscrypt(socketFactory)) {
+      Conscrypt.setUseEngineSocket(socketFactory, true);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 19f444dd55..455e8bcbb8 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -18,12 +18,15 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 9+.
  */
@@ -49,12 +52,12 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       sslSocket.setSSLParameters(sslParameters);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to set ssl parameters", e);
     }
   }
 
   @Override
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       String protocol = (String) getProtocolMethod.invoke(socket);
 
@@ -66,7 +69,7 @@ public String getSelectedProtocol(SSLSocket socket) {
 
       return protocol;
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocols", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 5dd11ee362..dee0b3fe53 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -20,10 +20,13 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
  */
@@ -52,19 +55,19 @@
           new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
       putMethod.invoke(null, sslSocket, provider);
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError(e);
+      throw assertionError("unable to set alpn", e);
     }
   }
 
   @Override public void afterHandshake(SSLSocket sslSocket) {
     try {
       removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException ignored) {
-      throw new AssertionError();
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to remove alpn", e);
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
@@ -75,7 +78,7 @@
       }
       return provider.unsupported ? null : provider.selected;
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocol", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index 7ff1c717c3..ac15233867 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -20,10 +20,14 @@
 import java.lang.reflect.Field;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
@@ -85,7 +89,7 @@ public String getPrefix() {
     return "OkHttp";
   }
 
-  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
     // platforms in order to support Robolectric, which mixes classes from both Android and the
     // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
@@ -104,7 +108,7 @@ public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
    *
    * @param hostname non-null for client-side handshakes; null for server-side handshakes.
    */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+  public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname,
       List<Protocol> protocols) {
   }
 
@@ -116,16 +120,16 @@ public void afterHandshake(SSLSocket sslSocket) {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
+  public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout)
+      throws IOException {
     socket.connect(address, connectTimeout);
   }
 
-  public void log(int level, String message, Throwable t) {
+  public void log(int level, String message, @Nullable Throwable t) {
     Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
     logger.log(logLevel, message, t);
   }
@@ -168,6 +172,30 @@ public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager tru
     return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
   }
 
+  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
+    X509TrustManager trustManager = trustManager(sslSocketFactory);
+
+    if (trustManager == null) {
+      throw new IllegalStateException("Unable to extract the trust manager on "
+          + Platform.get()
+          + ", sslSocketFactory is "
+          + sslSocketFactory.getClass());
+    }
+
+    return buildCertificateChainCleaner(trustManager);
+  }
+
+  public static boolean isConscryptPreferred() {
+    // mainly to allow tests to run cleanly
+    if ("conscrypt".equals(System.getProperty("okhttp.platform"))) {
+      return true;
+    }
+
+    // check if Provider manually installed
+    String preferredProvider = Security.getProviders()[0].getName();
+    return "Conscrypt".equals(preferredProvider);
+  }
+
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
     Platform android = AndroidPlatform.buildIfSupported();
@@ -176,6 +204,14 @@ private static Platform findPlatform() {
       return android;
     }
 
+    if (isConscryptPreferred()) {
+      Platform conscrypt = ConscryptPlatform.buildIfSupported();
+
+      if (conscrypt != null) {
+        return conscrypt;
+      }
+    }
+
     Platform jdk9 = Jdk9Platform.buildIfSupported();
 
     if (jdk9 != null) {
@@ -207,7 +243,7 @@ private static Platform findPlatform() {
     return result.readByteArray();
   }
 
-  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+  static @Nullable <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
     for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
       try {
         Field field = c.getDeclaredField(fieldName);
@@ -230,7 +266,32 @@ private static Platform findPlatform() {
     return null;
   }
 
-    public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-      return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+  public SSLContext getSSLContext() {
+    String jvmVersion = System.getProperty("java.specification.version");
+    if ("1.7".equals(jvmVersion)) {
+      try {
+        // JDK 1.7 (public version) only support > TLSv1 with named protocols
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS");
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
     }
+  }
+
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+    return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+  }
+
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
new file mode 100644
index 0000000000..d18b6335f1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.proxy;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
+ */
+public class NullProxySelector extends ProxySelector {
+  @Override public List<Proxy> select(URI uri) {
+    if (uri == null) {
+      throw new IllegalArgumentException("uri must not be null");
+    }
+    return Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
index 75dafdd0a3..0e39bd0f87 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -63,12 +63,14 @@ public static PublicSuffixDatabase get() {
 
   /**
    * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
-   * Returns null if the domain is a public suffix.
+   * Returns null if the domain is a public suffix or a private address.
    *
    * <p>Here are some examples: <pre>{@code
    * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
    * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
    * assertNull(getEffectiveTldPlusOne("com"));
+   * assertNull(getEffectiveTldPlusOne("localhost"));
+   * assertNull(getEffectiveTldPlusOne("mymacbook"));
    * }</pre>
    *
    * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
@@ -112,6 +114,7 @@ public String getEffectiveTldPlusOne(String domain) {
       try {
         readCompleteLatch.await();
       } catch (InterruptedException ignored) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
 
@@ -289,6 +292,7 @@ private void readTheListUninterruptibly() {
           readTheList();
           return;
         } catch (InterruptedIOException e) {
+          Thread.interrupted(); // Temporarily clear the interrupted state.
           interrupted = true;
         } catch (IOException e) {
           Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
@@ -297,7 +301,7 @@ private void readTheListUninterruptibly() {
       }
     } finally {
       if (interrupted) {
-        Thread.currentThread().interrupt();
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index 7441abadad..36ac5b3813 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -27,7 +27,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
 
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -73,24 +72,12 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
   /** Returns true if {@code certificate} matches {@code hostname}. */
   private boolean verifyHostname(String hostname, X509Certificate certificate) {
     hostname = hostname.toLowerCase(Locale.US);
-    boolean hasDns = false;
     List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      hasDns = true;
-      if (verifyHostname(hostname, altNames.get(i))) {
+    for (String altName : altNames) {
+      if (verifyHostname(hostname, altName)) {
         return true;
       }
     }
-
-    if (!hasDns) {
-      X500Principal principal = certificate.getSubjectX500Principal();
-      // RFC 2818 advises using the most specific name for matching.
-      String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
-      if (cn != null) {
-        return verifyHostname(hostname, cn);
-      }
-    }
-
     return false;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 5e01f40413..baee049f1b 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -18,6 +18,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.List;
@@ -26,8 +27,10 @@
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.Call;
 import okhttp3.Callback;
+import okhttp3.EventListener;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -70,6 +73,7 @@
 
   final WebSocketListener listener;
   private final Random random;
+  private final long pingIntervalMillis;
   private final String key;
 
   /** Non-null for client web sockets. These can be canceled. */
@@ -123,19 +127,27 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
-  /** For testing. */
-  int pingCount;
+  /** Total number of pings sent by this web socket. */
+  private int sentPingCount;
 
-  /** For testing. */
-  int pongCount;
+  /** Total number of pings received by this web socket. */
+  private int receivedPingCount;
 
-  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+  /** Total number of pongs received by this web socket. */
+  private int receivedPongCount;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random,
+      long pingIntervalMillis) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
     this.originalRequest = request;
     this.listener = listener;
     this.random = random;
+    this.pingIntervalMillis = pingIntervalMillis;
 
     byte[] nonce = new byte[16];
     random.nextBytes(nonce);
@@ -167,9 +179,9 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random)
 
   public void connect(OkHttpClient client) {
     client = client.newBuilder()
+        .eventListener(EventListener.NONE)
         .protocols(ONLY_HTTP1)
         .build();
-    final int pingIntervalMillis = client.pingIntervalMillis();
     final Request request = originalRequest.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
@@ -177,6 +189,7 @@ public void connect(OkHttpClient client) {
         .header("Sec-WebSocket-Version", "13")
         .build();
     call = Internal.instance.newWebSocketCall(client, request);
+    call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
         try {
@@ -196,7 +209,7 @@ public void connect(OkHttpClient client) {
         try {
           listener.onOpen(RealWebSocket.this, response);
           String name = "OkHttp WebSocket " + request.url().redact();
-          initReaderAndWriter(name, pingIntervalMillis, streams);
+          initReaderAndWriter(name, streams);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
@@ -237,8 +250,7 @@ void checkResponse(Response response) throws ProtocolException {
     }
   }
 
-  public void initReaderAndWriter(
-      String name, long pingIntervalMillis, Streams streams) throws IOException {
+  public void initReaderAndWriter(String name, Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
@@ -295,12 +307,16 @@ void tearDown() throws InterruptedException {
     executor.awaitTermination(10, TimeUnit.SECONDS);
   }
 
-  synchronized int pingCount() {
-    return pingCount;
+  synchronized int sentPingCount() {
+    return sentPingCount;
+  }
+
+  synchronized int receivedPingCount() {
+    return receivedPingCount;
   }
 
-  synchronized int pongCount() {
-    return pongCount;
+  synchronized int receivedPongCount() {
+    return receivedPongCount;
   }
 
   @Override public void onReadMessage(String text) throws IOException {
@@ -317,12 +333,13 @@ synchronized int pongCount() {
 
     pongQueue.add(payload);
     runWriter();
-    pingCount++;
+    receivedPingCount++;
   }
 
   @Override public synchronized void onReadPong(ByteString buffer) {
     // This API doesn't expose pings.
-    pongCount++;
+    receivedPongCount++;
+    awaitingPong = false;
   }
 
   @Override public void onReadClose(int code, String reason) {
@@ -516,9 +533,20 @@ boolean writeOneFrame() throws IOException {
 
   void writePingFrame() {
     WebSocketWriter writer;
+    int failedPing;
     synchronized (this) {
       if (failed) return;
       writer = this.writer;
+      failedPing = awaitingPong ? sentPingCount : -1;
+      sentPingCount++;
+      awaitingPong = true;
+    }
+
+    if (failedPing != -1) {
+      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
+          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
+          null);
+      return;
     }
 
     try {
@@ -528,7 +556,7 @@ void writePingFrame() {
     }
   }
 
-  public void failWebSocket(Exception e, Response response) {
+  public void failWebSocket(Exception e, @Nullable Response response) {
     Streams streamsToClose;
     synchronized (this) {
       if (failed) return; // Already failed.
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 5be61eea5f..489979845e 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,8 +15,7 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.IOException;
-import java.net.ProtocolException;
+import okio.Buffer;
 import okio.ByteString;
 
 public final class WebSocketProtocol {
@@ -90,19 +89,19 @@
 
   /** Used when an unchecked exception was thrown in a listener. */
   static final int CLOSE_CLIENT_GOING_AWAY = 1001;
-  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
-  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
   /** Used when an empty close frame was received (i.e., without a status code). */
   static final int CLOSE_NO_STATUS_CODE = 1005;
-  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
-  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
 
-  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {
+    int keyIndex = 0;
     int keyLength = key.length;
-    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
-      int keyIndex = (int) (frameBytesRead % keyLength);
-      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
-    }
+    do {
+      byte[] buffer = cursor.data;
+      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {
+        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter.
+        buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+      }
+    } while (cursor.next() != -1);
   }
 
   static String closeCodeExceptionMessage(int code) {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 7e83a30a1d..6d5d22e67d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.concurrent.TimeUnit;
@@ -46,8 +45,8 @@
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
- * <p>
- * This class is not thread safe.
+ *
+ * <p>This class is not thread safe.
  */
 final class WebSocketReader {
   public interface FrameCallback {
@@ -67,13 +66,14 @@
   // Stateful data about the current frame.
   int opcode;
   long frameLength;
-  long frameBytesRead;
   boolean isFinalFrame;
   boolean isControlFrame;
-  boolean isMasked;
 
-  final byte[] maskKey = new byte[4];
-  final byte[] maskBuffer = new byte[8192];
+  private final Buffer controlFrameBuffer = new Buffer();
+  private final Buffer messageFrameBuffer = new Buffer();
+
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
@@ -81,6 +81,10 @@
     this.isClient = isClient;
     this.source = source;
     this.frameCallback = frameCallback;
+
+    // Masks are only a concern for server writers.
+    maskKey = isClient ? null : new byte[4];
+    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
   }
 
   /**
@@ -134,7 +138,7 @@ private void readHeader() throws IOException {
 
     int b1 = source.readByte() & 0xff;
 
-    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
       throw new ProtocolException(isClient
@@ -153,7 +157,6 @@ private void readHeader() throws IOException {
             "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
       }
     }
-    frameBytesRead = 0;
 
     if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
       throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
@@ -166,38 +169,33 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = new Buffer();
-    if (frameBytesRead < frameLength) {
-      if (isClient) {
-        source.readFully(buffer, frameLength);
-      } else {
-        while (frameBytesRead < frameLength) {
-          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
-          int read = source.read(maskBuffer, 0, toRead);
-          if (read == -1) throw new EOFException();
-          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-          buffer.write(maskBuffer, 0, read);
-          frameBytesRead += read;
-        }
+    if (frameLength > 0) {
+      source.readFully(controlFrameBuffer, frameLength);
+
+      if (!isClient) {
+        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(0);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     }
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(buffer.readByteString());
+        frameCallback.onReadPing(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(buffer.readByteString());
+        frameCallback.onReadPong(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
         int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        long bufferSize = buffer.size();
+        long bufferSize = controlFrameBuffer.size();
         if (bufferSize == 1) {
           throw new ProtocolException("Malformed close payload length of 1.");
         } else if (bufferSize != 0) {
-          code = buffer.readShort();
-          reason = buffer.readUtf8();
+          code = controlFrameBuffer.readShort();
+          reason = controlFrameBuffer.readUtf8();
           String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
           if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
         }
@@ -215,18 +213,17 @@ private void readMessageFrame() throws IOException {
       throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    Buffer message = new Buffer();
-    readMessage(message);
+    readMessage();
 
     if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(message.readUtf8());
+      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
     } else {
-      frameCallback.onReadMessage(message.readByteString());
+      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  void readUntilNonControlFrame() throws IOException {
+  private void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -241,37 +238,27 @@ void readUntilNonControlFrame() throws IOException {
    * fragments will be processed. If the message payload is masked this will unmask as it's being
    * processed.
    */
-  private void readMessage(Buffer sink) throws IOException {
+  private void readMessage() throws IOException {
     while (true) {
       if (closed) throw new IOException("closed");
 
-      if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return; // We are exhausted and have no continuations.
+      if (frameLength > 0) {
+        source.readFully(messageFrameBuffer, frameLength);
 
-        readUntilNonControlFrame();
-        if (opcode != OPCODE_CONTINUATION) {
-          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-        }
-        if (isFinalFrame && frameLength == 0) {
-          return; // Fast-path for empty final frame.
+        if (!isClient) {
+          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
+          maskCursor.seek(messageFrameBuffer.size() - frameLength);
+          toggleMask(maskCursor, maskKey);
+          maskCursor.close();
         }
       }
 
-      long toRead = frameLength - frameBytesRead;
-
-      long read;
-      if (isMasked) {
-        toRead = Math.min(toRead, maskBuffer.length);
-        read = source.read(maskBuffer, 0, (int) toRead);
-        if (read == -1) throw new EOFException();
-        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-        sink.write(maskBuffer, 0, (int) read);
-      } else {
-        read = source.read(sink, toRead);
-        if (read == -1) throw new EOFException();
-      }
+      if (isFinalFrame) break; // We are exhausted and have no continuations.
 
-      frameBytesRead += read;
+      readUntilNonControlFrame();
+      if (opcode != OPCODE_CONTINUATION) {
+        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+      }
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 9c466d672d..baffe06b19 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -39,18 +39,15 @@
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
  *
- * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
- * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
- * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
- * the wire with frames from the "main" sending thread.
+ * <p>This class is not thread safe.
  */
 final class WebSocketWriter {
   final boolean isClient;
   final Random random;
 
-  /** Writes must be guarded by synchronizing on 'this'. */
   final BufferedSink sink;
-  /** Access must be guarded by synchronizing on 'this'. */
+  /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
+  final Buffer sinkBuffer;
   boolean writerClosed;
 
   final Buffer buffer = new Buffer();
@@ -58,33 +55,30 @@
 
   boolean activeWriter;
 
-  final byte[] maskKey;
-  final byte[] maskBuffer;
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
     this.sink = sink;
+    this.sinkBuffer = sink.buffer();
     this.random = random;
 
     // Masks are only a concern for client writers.
     maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[8192] : null;
+    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;
   }
 
   /** Send a ping with the supplied {@code payload}. */
   void writePing(ByteString payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
-    }
+    writeControlFrame(OPCODE_CONTROL_PING, payload);
   }
 
   /** Send a pong with the supplied {@code payload}. */
   void writePong(ByteString payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
-    }
+    writeControlFrame(OPCODE_CONTROL_PONG, payload);
   }
 
   /**
@@ -108,18 +102,14 @@ void writeClose(int code, ByteString reason) throws IOException {
       payload = buffer.readByteString();
     }
 
-    synchronized (this) {
-      try {
-        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
-      } finally {
-        writerClosed = true;
-      }
+    try {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+    } finally {
+      writerClosed = true;
     }
   }
 
-  private void writeControlFrameSynchronized(int opcode, ByteString payload) throws IOException {
-    assert Thread.holdsLock(this);
-
+  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
     if (writerClosed) throw new IOException("closed");
 
     int length = payload.size();
@@ -129,22 +119,28 @@ private void writeControlFrameSynchronized(int opcode, ByteString payload) throw
     }
 
     int b0 = B0_FLAG_FIN | opcode;
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = length;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
 
       random.nextBytes(maskKey);
-      sink.write(maskKey);
+      sinkBuffer.write(maskKey);
+
+      if (length > 0) {
+        long payloadStart = sinkBuffer.size();
+        sinkBuffer.write(payload);
 
-      byte[] bytes = payload.toByteArray();
-      toggleMask(bytes, bytes.length, maskKey, 0);
-      sink.write(bytes);
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(payloadStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
+      }
     } else {
-      sink.writeByte(b1);
-      sink.write(payload);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.write(payload);
     }
 
     sink.flush();
@@ -169,17 +165,15 @@ Sink newMessageSink(int formatOpcode, long contentLength) {
     return frameSink;
   }
 
-  void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
       boolean isFinal) throws IOException {
-    assert Thread.holdsLock(this);
-
     if (writerClosed) throw new IOException("closed");
 
     int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
     if (isFinal) {
       b0 |= B0_FLAG_FIN;
     }
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = 0;
     if (isClient) {
@@ -187,31 +181,32 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
     } else if (byteCount <= PAYLOAD_SHORT_MAX) {
       b1 |= PAYLOAD_SHORT;
-      sink.writeByte(b1);
-      sink.writeShort((int) byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeShort((int) byteCount);
     } else {
       b1 |= PAYLOAD_LONG;
-      sink.writeByte(b1);
-      sink.writeLong(byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeLong(byteCount);
     }
 
     if (isClient) {
       random.nextBytes(maskKey);
-      sink.write(maskKey);
-
-      for (long written = 0; written < byteCount; ) {
-        int toRead = (int) Math.min(byteCount, maskBuffer.length);
-        int read = buffer.read(maskBuffer, 0, toRead);
-        if (read == -1) throw new AssertionError();
-        toggleMask(maskBuffer, read, maskKey, written);
-        sink.write(maskBuffer, 0, read);
-        written += read;
+      sinkBuffer.write(maskKey);
+
+      if (byteCount > 0) {
+        long bufferStart = sinkBuffer.size();
+        sinkBuffer.write(buffer, byteCount);
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(bufferStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     } else {
-      sink.write(buffer, byteCount);
+      sinkBuffer.write(buffer, byteCount);
     }
 
     sink.emit();
@@ -235,9 +230,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
 
       long emitCount = buffer.completeSegmentByteCount();
       if (emitCount > 0 && !deferWrite) {
-        synchronized (WebSocketWriter.this) {
-          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
-        }
+        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
         isFirstFrame = false;
       }
     }
@@ -245,9 +238,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     @Override public void flush() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
       isFirstFrame = false;
     }
 
@@ -259,9 +250,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     @Override public void close() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
       closed = true;
       activeWriter = false;
     }
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
index a34c5bbf86..725b054363 100644
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -1,3 +1,3 @@
 /** An HTTP+HTTP/2 client for Android and Java applications. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3;
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
new file mode 100644
index 0000000000..0c6f707575
--- /dev/null
+++ b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
@@ -0,0 +1,11 @@
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/pom.xml b/pom.xml
index c92a23be3c..339b59a04d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.9.0-SNAPSHOT</version>
+  <version>3.13.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -25,13 +25,18 @@
     <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
+    <module>okhttp-sse</module>
     <module>okhttp-testing-support</module>
+    <module>okhttp-tls</module>
     <module>okhttp-urlconnection</module>
 
     <module>okhttp-logging-interceptor</module>
 
+    <module>okhttp-dnsoverhttps</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
+    <module>bom</module>
     <module>samples</module>
     <module>benchmarks</module>
   </modules>
@@ -45,12 +50,14 @@
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
     <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.2</apache.http.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
+    <apache.http.version>4.2.6</apache.http.version>
+    <bouncycastle.version>1.60</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.13.0</okio.version>
+    <jnr-unixsocket.version>0.19</jnr-unixsocket.version>
+    <okio.version>1.16.0</okio.version>
+    <conscrypt.version>1.4.0</conscrypt.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -126,6 +133,16 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.github.jnr</groupId>
+        <artifactId>jnr-unixsocket</artifactId>
+        <version>${jnr-unixsocket.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.conscrypt</groupId>
+        <artifactId>conscrypt-openjdk-uber</artifactId>
+        <version>${conscrypt.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -135,7 +152,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
+          <version>3.7.0</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
@@ -146,12 +163,12 @@
             <dependency>
               <groupId>org.codehaus.plexus</groupId>
               <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.1</version>
+              <version>2.8.4</version>
             </dependency>
             <dependency>
               <groupId>com.google.errorprone</groupId>
               <artifactId>error_prone_core</artifactId>
-              <version>2.0.16</version>
+              <version>2.3.1</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -159,11 +176,12 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.17</version>
+          <version>2.21.0</version>
           <configuration>
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
             </systemPropertyVariables>
+            <redirectTestOutputToFile>true</redirectTestOutputToFile>
             <properties>
               <!--
                 Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
@@ -180,7 +198,7 @@
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.17</version>
+              <version>2.21.0</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -188,7 +206,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.10.4</version>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -333,6 +351,18 @@
         <okhttp.platform>jdk9</okhttp.platform>
       </properties>
     </profile>
+    <profile>
+      <id>conscrypt</id>
+      <properties>
+        <okhttp.platform>conscrypt</okhttp.platform>
+      </properties>
+      <dependencies>
+        <dependency>
+          <groupId>org.conscrypt</groupId>
+          <artifactId>conscrypt-openjdk-uber</artifactId>
+        </dependency>
+      </dependencies>
+    </profile>
     <!-- ALPN Versions targeted for each Java 8 minor release -->
     <!-- Check versions with this page: -->
     <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
@@ -552,5 +582,104 @@
         <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_141</id>
+      <activation>
+        <jdk>1.8.0_141</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_144</id>
+      <activation>
+        <jdk>1.8.0_144</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_151</id>
+      <activation>
+        <jdk>1.8.0_151</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_152</id>
+      <activation>
+        <jdk>1.8.0_152</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_161</id>
+      <activation>
+        <jdk>1.8.0_161</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_162</id>
+      <activation>
+        <jdk>1.8.0_162</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_171</id>
+      <activation>
+        <jdk>1.8.0_171</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_172</id>
+      <activation>
+        <jdk>1.8.0_172</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_181</id>
+      <activation>
+        <jdk>1.8.0_181</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_191</id>
+      <activation>
+        <jdk>1.8.0_191</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_192</id>
+      <activation>
+        <jdk>1.8.0_192</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index ef746a07bf..121f522335 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 0818961703..07f61032d3 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -95,32 +95,33 @@ public void fetch(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
         .build();
-    Response response = client.newCall(request).execute();
-    String responseSource = response.networkResponse() != null
-        ? ("(network: " + response.networkResponse().code() + " over " + response.protocol() + ")")
-        : "(cache)";
-    int responseCode = response.code();
-
-    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
-
-    String contentType = response.header("Content-Type");
-    if (responseCode != 200 || contentType == null) {
-      response.body().close();
-      return;
-    }
+    try (Response response = client.newCall(request).execute()) {
+      String responseSource = response.networkResponse() != null ? ("(network: "
+          + response.networkResponse().code()
+          + " over "
+          + response.protocol()
+          + ")") : "(cache)";
+      int responseCode = response.code();
+
+      System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+      String contentType = response.header("Content-Type");
+      if (responseCode != 200 || contentType == null) {
+        return;
+      }
 
-    MediaType mediaType = MediaType.parse(contentType);
-    if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
-      response.body().close();
-      return;
-    }
+      MediaType mediaType = MediaType.parse(contentType);
+      if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
+        return;
+      }
 
-    Document document = Jsoup.parse(response.body().string(), url.toString());
-    for (Element element : document.select("a[href]")) {
-      String href = element.attr("href");
-      HttpUrl link = response.request().url().resolve(href);
-      if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
-      queue.add(link.newBuilder().fragment(null).build());
+      Document document = Jsoup.parse(response.body().string(), url.toString());
+      for (Element element : document.select("a[href]")) {
+        String href = element.attr("href");
+        HttpUrl link = response.request().url().resolve(href);
+        if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+        queue.add(link.newBuilder().fragment(null).build());
+      }
     }
   }
 
@@ -139,7 +140,7 @@ public static void main(String[] args) throws IOException {
         .build();
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(HttpUrl.parse(args[1]));
+    crawler.queue.add(HttpUrl.get(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index d8336f71bf..85f5d36f73 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,6 +18,16 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index b6e70ccc7d..ddaacb6c5e 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -8,8 +8,7 @@
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON
-      = MediaType.parse("application/json; charset=utf-8");
+  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
 
   OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
new file mode 100644
index 0000000000..6c15d700df
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.Date;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CurrentDateHeader {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new CurrentDateInterceptor())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.request().header("Date"));
+    }
+  }
+
+  static class CurrentDateInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      Headers newHeaders = request.headers()
+          .newBuilder()
+          .add("Date", new Date())
+          .build();
+      Request newRequest = request.newBuilder()
+          .headers(newHeaders)
+          .build();
+      return chain.proceed(newRequest);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CurrentDateHeader().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
new file mode 100644
index 0000000000..dd537f52b2
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.net.InetAddress;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
+
+/**
+ * Create an HTTPS server with a self-signed certificate that OkHttp trusts.
+ */
+public class HttpsServer {
+  public void run() throws Exception {
+    String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+    HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName(localhost)
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(localhostCertificate)
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(localhostCertificate.certificate())
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    System.out.println(response.handshake().tlsVersion());
+  }
+
+  public static void main(String... args) throws Exception {
+    new HttpsServer().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index b216b24b3b..0e52cddd26 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -25,7 +25,7 @@
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 3e93a00e82..60534d7de2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -30,7 +30,7 @@
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.get("image/png");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 440c7768ea..90ec01c6b8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -25,7 +25,7 @@
 
 public final class PostStreaming {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
index b313ce0d1a..c73b9154ed 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -27,7 +27,7 @@
 
 public final class PostStreamingWithPipe {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 8a312bde8a..6c8ea4f9e3 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -24,7 +24,7 @@
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
new file mode 100644
index 0000000000..abbf0eb0c0
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Credentials;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class PreemptiveAuth {
+  private final OkHttpClient client;
+
+  public PreemptiveAuth() {
+    client = new OkHttpClient.Builder()
+        .addInterceptor(
+            new BasicAuthInterceptor("publicobject.com", "jesse", "password1"))
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PreemptiveAuth().run();
+  }
+
+  static final class BasicAuthInterceptor implements Interceptor {
+    private final String credentials;
+    private final String host;
+
+    BasicAuthInterceptor(String host, String username, String password) {
+      this.credentials = Credentials.basic(username, password);
+      this.host = host;
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      if (request.url().host().equals(host)) {
+        request = request.newBuilder()
+            .header("Authorization", credentials)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
new file mode 100644
index 0000000000..1366a82f15
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public final class PrintEvents {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListenerFactory(PrintingEventListener.FACTORY)
+      .build();
+
+  public void run() throws Exception {
+    Request washingtonPostRequest = new Request.Builder()
+        .url("https://www.washingtonpost.com/")
+        .build();
+    client.newCall(washingtonPostRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+
+    Request newYorkTimesRequest = new Request.Builder()
+        .url("https://www.nytimes.com/")
+        .build();
+    client.newCall(newYorkTimesRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEvents().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    private static final Factory FACTORY = new Factory() {
+      final AtomicLong nextCallId = new AtomicLong(1L);
+
+      @Override public EventListener create(Call call) {
+        long callId = nextCallId.getAndIncrement();
+        System.out.printf("%04d %s%n", callId, call.request().url());
+        return new PrintingEventListener(callId, System.nanoTime());
+      }
+    };
+
+    final long callId;
+    final long callStartNanos;
+
+    PrintingEventListener(long callId, long callStartNanos) {
+      this.callId = callId;
+      this.callStartNanos = callStartNanos;
+    }
+
+    private void printEvent(String name) {
+      long elapsedNanos = System.nanoTime() - callStartNanos;
+      System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
new file mode 100644
index 0000000000..6acedb19e7
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * This prints events for a single in-flight call. It won't work for multiple concurrent calls
+ * because we don't know what callStartNanos refers to.
+ */
+public final class PrintEventsNonConcurrent {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListener(new PrintingEventListener())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    System.out.println("REQUEST 1 (new connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+
+    System.out.println("REQUEST 2 (pooled connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEventsNonConcurrent().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    long callStartNanos;
+
+    private void printEvent(String name) {
+      long nowNanos = System.nanoTime();
+      if (name.equals("callStart")) {
+        callStartNanos = nowNanos;
+      }
+      long elapsedNanos = nowNanos - callStartNanos;
+      System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index 30566908a1..e75a3cc949 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -36,11 +36,27 @@ public void run() throws Exception {
         .build();
 
     final ProgressListener progressListener = new ProgressListener() {
+      boolean firstUpdate = true;
+
       @Override public void update(long bytesRead, long contentLength, boolean done) {
-        System.out.println(bytesRead);
-        System.out.println(contentLength);
-        System.out.println(done);
-        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+        if (done) {
+          System.out.println("completed");
+        } else {
+          if (firstUpdate) {
+            firstUpdate = false;
+            if (contentLength == -1) {
+              System.out.println("content-length: unknown");
+            } else {
+              System.out.format("content-length: %d\n", contentLength);
+            }
+          }
+
+          System.out.println(bytesRead);
+
+          if (contentLength != -1) {
+            System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+          }
+        }
       }
     };
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index b1a62c0fa3..5473f67011 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -39,7 +39,7 @@
    * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
-  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.get("application/json");
 
   private final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new GzipRequestInterceptor())
diff --git a/samples/pom.xml b/samples/pom.xml
index 4f617d0d34..4cb343bce2 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
@@ -20,6 +20,7 @@
     <module>simple-client</module>
     <module>slack</module>
     <module>static-server</module>
+    <module>unixdomainsockets</module>
   </modules>
 
   <build>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 1f8f6507f3..9b193b2033 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index ec9019110b..f2ac973db2 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -31,23 +31,22 @@ public static void main(String... args) throws Exception {
         .build();
 
     // Execute the request and retrieve the response.
-    Response response = client.newCall(request).execute();
-
-    // Deserialize HTTP response to concrete type.
-    ResponseBody body = response.body();
-    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
-    body.close();
-
-    // Sort list by the most contributions.
-    Collections.sort(contributors, new Comparator<Contributor>() {
-      @Override public int compare(Contributor c1, Contributor c2) {
-        return c2.contributions - c1.contributions;
+    try (Response response = client.newCall(request).execute()) {
+      // Deserialize HTTP response to concrete type.
+      ResponseBody body = response.body();
+      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+
+      // Sort list by the most contributions.
+      Collections.sort(contributors, new Comparator<Contributor>() {
+        @Override public int compare(Contributor c1, Contributor c2) {
+          return c2.contributions - c1.contributions;
+        }
+      });
+
+      // Output list of contributors.
+      for (Contributor contributor : contributors) {
+        System.out.println(contributor.login + ": " + contributor.contributions);
       }
-    });
-
-    // Output list of contributors.
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + ": " + contributor.contributions);
     }
   }
 
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index d065531a84..ea003abc2e 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
index 04ba201c96..c0ad139aed 100644
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -76,7 +76,7 @@ private HttpUrl redirectUrl() {
   }
 
   /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+  @Override public MockResponse dispatch(RecordedRequest request) {
     HttpUrl requestUrl = mockWebServer.url(request.getPath());
     String code = requestUrl.queryParameter("code");
     String stateString = requestUrl.queryParameter("state");
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0ec0ef7a45..4ab8565942 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -38,7 +38,7 @@
  * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
  */
 public final class SlackApi {
-  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final HttpUrl baseUrl = HttpUrl.get("https://slack.com/api/");
   private final OkHttpClient httpClient;
   private final Moshi moshi;
 
@@ -120,7 +120,7 @@ public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
     @FromJson HttpUrl urlFromJson(String urlString) {
       if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
       if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
-      return HttpUrl.parse(urlString);
+      return HttpUrl.get(urlString);
     }
   }
 }
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 26f091a3c9..058d63f0ef 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.9.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
new file mode 100644
index 0000000000..0f1c5459fb
--- /dev/null
+++ b/samples/unixdomainsockets/pom.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>unixdomainsockets</artifactId>
+  <name>Sample: UNIX domain sockets</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.github.jnr</groupId>
+      <artifactId>jnr-unixsocket</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
new file mode 100644
index 0000000000..8512c2d38d
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+/**
+ * Create UNIX domain sockets for MockWebServer and OkHttp and connect 'em together. Note that we
+ * cannot do TLS over domain sockets.
+ */
+public class ClientAndServer {
+  public void run() throws Exception {
+    File socketFile = new File("/tmp/ClientAndServer.sock");
+    socketFile.delete(); // Clean up from previous runs.
+
+    MockWebServer server = new MockWebServer();
+    server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
+    server.enqueue(new MockResponse().setBody("hello"));
+    server.start();
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .socketFactory(new UnixDomainSocketFactory(socketFile))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.body().string());
+    }
+
+    server.shutdown();
+    socketFile.delete();
+  }
+
+  public static void main(String... args) throws Exception {
+    new ClientAndServer().run();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
new file mode 100644
index 0000000000..f9ec4a08f8
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.ServerSocketFactory;
+import jnr.unixsocket.UnixServerSocketChannel;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style ServerSocketFactory over UNIX domain sockets. */
+public final class UnixDomainServerSocketFactory extends ServerSocketFactory {
+  private final File path;
+
+  public UnixDomainServerSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private ServerSocket createUnixDomainSocket() throws IOException {
+    return new UnixDomainServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(
+      int port, int backlog, InetAddress inetAddress) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  final class UnixDomainServerSocket extends ServerSocket {
+    private UnixServerSocketChannel serverSocketChannel;
+    private InetSocketAddress endpoint;
+
+    UnixDomainServerSocket() throws IOException {
+    }
+
+    @Override public void bind(SocketAddress endpoint, int backlog) throws IOException {
+      this.endpoint = (InetSocketAddress) endpoint;
+
+      UnixSocketAddress address = new UnixSocketAddress(path);
+      serverSocketChannel = UnixServerSocketChannel.open();
+      serverSocketChannel.configureBlocking(true);
+      serverSocketChannel.socket().bind(address);
+    }
+
+    @Override public int getLocalPort() {
+      return 1; // A white lie. There is no local port.
+    }
+
+    @Override public SocketAddress getLocalSocketAddress() {
+      return endpoint;
+    }
+
+    @Override public Socket accept() throws IOException {
+      UnixSocketChannel socketChannel = serverSocketChannel.accept();
+
+      return new UnixSocket(socketChannel) {
+        @Override public InetAddress getInetAddress() {
+          return endpoint.getAddress(); // TODO(jwilson): fake the remote address?
+        }
+      };
+    }
+
+    @Override public void close() throws IOException {
+      serverSocketChannel.close();
+    }
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
new file mode 100644
index 0000000000..8b16e398f7
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.SocketFactory;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
+public final class UnixDomainSocketFactory extends SocketFactory {
+  private final File path;
+
+  public UnixDomainSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private Socket createUnixDomainSocket() throws IOException {
+    UnixSocketChannel channel = UnixSocketChannel.open();
+
+    return new UnixSocket(channel) {
+      private InetSocketAddress inetSocketAddress;
+
+      @Override public void connect(SocketAddress endpoint) throws IOException {
+        connect(endpoint, Integer.valueOf(0));
+      }
+
+      @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+        connect(endpoint, Integer.valueOf(timeout));
+      }
+
+      @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
+        this.inetSocketAddress = (InetSocketAddress) endpoint;
+        super.connect(new UnixSocketAddress(path), timeout);
+      }
+
+      @Override public InetAddress getInetAddress() {
+        return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
+      }
+    };
+  }
+
+  @Override public Socket createSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(String host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      String host, int port, InetAddress localHost, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+}
diff --git a/website/index.html b/website/index.html
index 6f0df48a03..0725793100 100644
--- a/website/index.html
+++ b/website/index.html
@@ -8,7 +8,7 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -22,8 +22,8 @@ <h1>OkHttp</h1>
             <menu>
               <ul>
                 <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                <li><a href="https://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
               </ul>
             </menu>
           </div>
@@ -69,7 +69,7 @@ <h3 id="overview">Overview</h3>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and prints its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -88,7 +88,7 @@ <h4>Post to a Server</h4>
 
 <pre class="prettyprint">
 public static final MediaType JSON
-    = MediaType.parse("application/json; charset=utf-8");
+    = MediaType.get("application/json; charset=utf-8");
 
 OkHttpClient client = new OkHttpClient();
 
@@ -106,10 +106,10 @@ <h4>Post to a Server</h4>
 
             <h3 id="download">Download</h3>
             <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+            <p>You'll also need <a href="https://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
-            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p>The source code to OkHttp, its samples, and this website is <a href="https://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -119,12 +119,22 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            
+            <p>Some general advice</p>
+            <ul>
+                <li>Don’t change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
+                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
+                <li>Get working code on a personal branch with tests before you submit a PR.</li>
+                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
+                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
+            </ul>
+            
+            <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
             <pre>Copyright 2016 Square, Inc.
@@ -153,7 +163,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="3.x/okhttp/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
+                <li><a href="https://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -165,7 +175,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 4b78fe23ac..6e134dd857 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -4,4 +4,4 @@
  * Version: 2.0.0
  * Author: Jake Wharton
  * License: Apache 2.0
- */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="http://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
\ No newline at end of file
+ */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="https://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
