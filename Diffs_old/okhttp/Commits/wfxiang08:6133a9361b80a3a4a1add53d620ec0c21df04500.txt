diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
index 7293392083..1a7d883b12 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
@@ -105,7 +105,8 @@ public void enqueue(final WebSocketListener listener) {
       }
     };
     // TODO call.enqueue(responseCallback, true);
-    Internal.instance.callEnqueue(call, responseCallback, true);
+    Internal.instance.setCallWebSocket(call);
+    call.enqueue(responseCallback);
   }
 
   /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index b23e6a2212..778ab8019b 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -110,11 +110,6 @@
         return connectionPool.routeDatabase;
       }
 
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        ((RealCall) call).enqueue(responseCallback, forWebSocket);
-      }
-
       @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
         return ((RealCall) call).engine.streamAllocation;
       }
@@ -128,6 +123,10 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
           throws MalformedURLException, UnknownHostException {
         return HttpUrl.getChecked(url);
       }
+
+      @Override public void setCallWebSocket(Call call) {
+        ((RealCall) call).setForWebSocket();
+      }
     };
   }
 
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index c78062dfcc..6444ffc348 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -34,6 +34,7 @@
   // Guarded by this.
   private boolean executed;
   volatile boolean canceled;
+  private boolean forWebSocket;
 
   /** The application's original request unadulterated by redirects or auth headers. */
   Request originalRequest;
@@ -55,7 +56,7 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
     }
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain(false);
+      Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
@@ -63,16 +64,17 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
     }
   }
 
-  @Override public void enqueue(Callback responseCallback) {
-    enqueue(responseCallback, false);
+  synchronized void setForWebSocket() {
+    if (executed) throw new IllegalStateException("Already Executed");
+    this.forWebSocket = true;
   }
 
-  void enqueue(Callback responseCallback, boolean forWebSocket) {
+  @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+    client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
   @Override public void cancel() {
@@ -90,12 +92,10 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
 
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
-    private final boolean forWebSocket;
 
-    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
+    private AsyncCall(Callback responseCallback) {
       super("OkHttp %s", redactedUrl().toString());
       this.responseCallback = responseCallback;
-      this.forWebSocket = forWebSocket;
     }
 
     String host() {
@@ -117,7 +117,7 @@ RealCall get() {
     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
-        Response response = getResponseWithInterceptorChain(forWebSocket);
+        Response response = getResponseWithInterceptorChain();
         if (canceled) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
@@ -151,20 +151,18 @@ HttpUrl redactedUrl() {
     return originalRequest.url().resolve("/...");
   }
 
-  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
-    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
+  private Response getResponseWithInterceptorChain() throws IOException {
+    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest);
     return chain.proceed(originalRequest);
   }
 
   class ApplicationInterceptorChain implements Interceptor.Chain {
     private final int index;
     private final Request request;
-    private final boolean forWebSocket;
 
-    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
+    ApplicationInterceptorChain(int index, Request request) {
       this.index = index;
       this.request = request;
-      this.forWebSocket = forWebSocket;
     }
 
     @Override public Connection connection() {
@@ -176,9 +174,10 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
     }
 
     @Override public Response proceed(Request request) throws IOException {
+      Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request);
+
       // If there's another interceptor in the chain, call that.
       if (index < client.interceptors().size()) {
-        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
         Interceptor interceptor = client.interceptors().get(index);
         Response interceptedResponse = interceptor.intercept(chain);
 
@@ -191,111 +190,116 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
       }
 
       // No more interceptors. Do HTTP.
-      return getResponse(request, forWebSocket);
+      return new RetryAndFollowUpInterceptor().intercept(chain);
     }
   }
 
   /**
-   * Performs the request and returns the response. May return null if this call was canceled.
+   * Performs the request and returns the response. May throw if this call was canceled. This isn't
+   * a regular interceptor because it doesn't delegate to the chain.
    */
-  Response getResponse(Request request, boolean forWebSocket) throws IOException {
-    // Copy body metadata to the appropriate request headers.
-    RequestBody body = request.body();
-    if (body != null) {
-      Request.Builder requestBuilder = request.newBuilder();
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
-    }
+  class RetryAndFollowUpInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+
+      // Copy body metadata to the appropriate request headers.
+      RequestBody body = request.body();
+      if (body != null) {
+        Request.Builder requestBuilder = request.newBuilder();
+
+        MediaType contentType = body.contentType();
+        if (contentType != null) {
+          requestBuilder.header("Content-Type", contentType.toString());
+        }
 
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, forWebSocket, null, null);
+        long contentLength = body.contentLength();
+        if (contentLength != -1) {
+          requestBuilder.header("Content-Length", Long.toString(contentLength));
+          requestBuilder.removeHeader("Transfer-Encoding");
+        } else {
+          requestBuilder.header("Transfer-Encoding", "chunked");
+          requestBuilder.removeHeader("Content-Length");
+        }
 
-    int followUpCount = 0;
-    while (true) {
-      if (canceled) {
-        engine.releaseStreamAllocation();
-        throw new IOException("Canceled");
+        request = requestBuilder.build();
       }
 
-      boolean releaseConnection = true;
-      try {
-        engine.sendRequest();
-        engine.readResponse();
-        releaseConnection = false;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
+      // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+      engine = new HttpEngine(client, request.url(), forWebSocket, null, null);
+
+      int followUpCount = 0;
+      while (true) {
+        if (canceled) {
+          engine.releaseStreamAllocation();
+          throw new IOException("Canceled");
         }
-        // Give up; recovery is not possible.
-        throw e.getLastConnectException();
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, false);
-        if (retryEngine != null) {
+
+        Response response = null;
+        boolean releaseConnection = true;
+        try {
+          response = engine.proceed(request);
           releaseConnection = false;
-          engine = retryEngine;
-          continue;
+        } catch (RouteException e) {
+          // The attempt to connect via a route failed. The request will not have been sent.
+          HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);
+          if (retryEngine != null) {
+            releaseConnection = false;
+            engine = retryEngine;
+            continue;
+          }
+          // Give up; recovery is not possible.
+          throw e.getLastConnectException();
+        } catch (IOException e) {
+          // An attempt to communicate with a server failed. The request may have been sent.
+          HttpEngine retryEngine = engine.recover(e, false, null);
+          if (retryEngine != null) {
+            releaseConnection = false;
+            engine = retryEngine;
+            continue;
+          }
+
+          // Give up; recovery is not possible.
+          throw e;
+        } finally {
+          // We're throwing an unchecked exception. Release any resources.
+          if (releaseConnection) {
+            StreamAllocation streamAllocation = engine.close(null);
+            streamAllocation.release();
+          }
         }
 
-        // Give up; recovery is not possible.
-        throw e;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          StreamAllocation streamAllocation = engine.close();
-          streamAllocation.release();
+        Request followUp = engine.followUpRequest(response);
+
+        if (followUp == null) {
+          if (!forWebSocket) {
+            engine.releaseStreamAllocation();
+          }
+          return response;
         }
-      }
 
-      Response response = engine.getResponse();
-      Request followUp = engine.followUpRequest();
+        StreamAllocation streamAllocation = engine.close(response);
 
-      if (followUp == null) {
-        if (!forWebSocket) {
-          engine.releaseStreamAllocation();
+        if (++followUpCount > MAX_FOLLOW_UPS) {
+          streamAllocation.release();
+          throw new ProtocolException("Too many follow-up requests: " + followUpCount);
         }
-        return response;
-      }
-
-      StreamAllocation streamAllocation = engine.close();
 
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
+        if (followUp.body() instanceof UnrepeatableRequestBody) {
+          throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+        }
 
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-      }
+        if (!engine.sameConnection(response, followUp.url())) {
+          streamAllocation.release();
+          streamAllocation = null;
+        } else if (streamAllocation.stream() != null) {
+          throw new IllegalStateException("Closing the body of " + response
+              + " didn't close its backing stream. Bad interceptor?");
+        }
 
-      if (!engine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      } else if (streamAllocation.stream() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
+        request = followUp;
+        engine = new HttpEngine(client, request.url(), forWebSocket, streamAllocation,
+            response);
       }
-
-      request = followUp;
-      engine = new HttpEngine(client, request, false, forWebSocket, streamAllocation, response);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 5ed594eacf..9bcb7dafc0 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -20,7 +20,6 @@
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
-import okhttp3.Callback;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
@@ -65,8 +64,7 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
   public abstract HttpUrl getHttpUrlChecked(String url)
       throws MalformedURLException, UnknownHostException;
 
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
-
   public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
+
+  public abstract void setCallWebSocket(Call call);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index a1845bfe22..91a3c69339 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -124,57 +124,19 @@
    */
   private boolean transparentGzip;
 
-  /**
-   * True if the request body must be completely buffered before transmission; false if it can be
-   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
-   * retransmit if necessary. The upside of streaming is that we can save memory.
-   */
-  public final boolean bufferRequestBody;
-
-  /**
-   * The original application-provided request. Never modified by OkHttp. When follow-up requests
-   * are necessary, they are derived from this request.
-   */
-  private final Request userRequest;
-
-  /**
-   * The request to send on the network, or null for no network request. This is derived from the
-   * user request, and customized to support OkHttp features like compression and caching.
-   */
-  private Request networkRequest;
-
-  /**
-   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
-   * Conditional caching means this may be non-null even when the network request is non-null. Never
-   * modified by OkHttp.
-   */
-  private Response cacheResponse;
-
-  /**
-   * The user-visible response. This is derived from either the network response, cache response, or
-   * both. It is customized to support OkHttp features like compression and caching.
-   */
-  private Response userResponse;
+  /** The original application-provided request URL. Never modified by OkHttp. */
+  private final HttpUrl userRequestUrl;
 
   private final boolean forWebSocket;
 
-  /** The cache request currently being populated from a network response. */
-  private CacheRequest storeRequest;
-  private CacheStrategy cacheStrategy;
-
-  /**
-   * @param request the HTTP request without a body. The body must be written via the engine's
-   * request body stream.
-   */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+  public HttpEngine(OkHttpClient client, HttpUrl userRequestUrl,
       boolean forWebSocket, StreamAllocation streamAllocation, Response priorResponse) {
     this.client = client;
-    this.userRequest = request;
-    this.bufferRequestBody = bufferRequestBody;
+    this.userRequestUrl = userRequestUrl;
     this.forWebSocket = forWebSocket;
     this.streamAllocation = streamAllocation != null
         ? streamAllocation
-        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
+        : new StreamAllocation(client.connectionPool(), createAddress(client, userRequestUrl));
     this.priorResponse = priorResponse;
   }
 
@@ -185,10 +147,9 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
    * recoverable. See {@link #recover}.
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   * {@link #recover(IOException, boolean)}.
+   * {@link #recover}.
    */
-  public void sendRequest() throws RouteException, IOException {
-    if (cacheStrategy != null) return; // Already sent.
+  public Response proceed(Request userRequest) throws IOException {
     if (httpStream != null) throw new IllegalStateException();
 
     Request request = networkRequest(userRequest);
@@ -199,9 +160,10 @@ public void sendRequest() throws RouteException, IOException {
         : null;
 
     long now = System.currentTimeMillis();
-    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
-    networkRequest = cacheStrategy.networkRequest;
-    cacheResponse = cacheStrategy.cacheResponse;
+
+    CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+    Request networkRequest = cacheStrategy.networkRequest;
+    Response cacheResponse = cacheStrategy.cacheResponse;
 
     if (responseCache != null) {
       responseCache.trackResponse(cacheStrategy);
@@ -213,7 +175,7 @@ public void sendRequest() throws RouteException, IOException {
 
     // If we're forbidden from using the network and the cache is insufficient, fail.
     if (networkRequest == null && cacheResponse == null) {
-      userResponse = new Response.Builder()
+      return new Response.Builder()
           .request(userRequest)
           .priorResponse(stripBody(priorResponse))
           .protocol(Protocol.HTTP_1_1)
@@ -223,24 +185,22 @@ public void sendRequest() throws RouteException, IOException {
           .sentRequestAtMillis(sentRequestMillis)
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build();
-      return;
     }
 
     // If we don't need the network, we're done.
     if (networkRequest == null) {
-      userResponse = cacheResponse.newBuilder()
+      Response userResponse = cacheResponse.newBuilder()
           .request(userRequest)
           .priorResponse(stripBody(priorResponse))
           .cacheResponse(stripBody(cacheResponse))
           .build();
-      userResponse = unzip(userResponse);
-      return;
+      return unzip(userResponse);
     }
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean success = false;
     try {
-      httpStream = connect();
+      httpStream = connect(networkRequest);
       httpStream.setHttpEngine(this);
       success = true;
     } finally {
@@ -249,9 +209,58 @@ public void sendRequest() throws RouteException, IOException {
         closeQuietly(cacheCandidate.body());
       }
     }
+
+    Response networkResponse;
+    if (forWebSocket) {
+      httpStream.writeRequestHeaders(networkRequest);
+      networkResponse = readNetworkResponse(networkRequest);
+    } else {
+      networkResponse = new NetworkInterceptorChain(0, networkRequest,
+          streamAllocation.connection()).proceed(networkRequest);
+    }
+
+    receiveHeaders(networkResponse.headers());
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        Response userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+        releaseStreamAllocation();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        responseCache.trackConditionalCacheHit();
+        responseCache.update(cacheResponse, userResponse);
+        return unzip(userResponse);
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+
+    Response userResponse = networkResponse.newBuilder()
+        .request(userRequest)
+        .priorResponse(stripBody(priorResponse))
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
+    if (hasBody(userResponse)) {
+      CacheRequest cacheRequest = maybeCache(
+          userResponse, networkResponse.request(), responseCache);
+      userResponse = unzip(cacheWritingResponse(cacheRequest, userResponse));
+    }
+
+    return userResponse;
   }
 
-  private HttpStream connect() throws RouteException, IOException {
+  private HttpStream connect(Request networkRequest) throws IOException {
     boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
     return streamAllocation.newStream(client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis(),
@@ -277,13 +286,6 @@ boolean permitsRequestBody(Request request) {
     return HttpMethod.permitsRequestBody(request.method());
   }
 
-  /** Returns the engine's response. */
-  // TODO: the returned body will always be null.
-  public Response getResponse() {
-    if (userResponse == null) throw new IllegalStateException();
-    return userResponse;
-  }
-
   public Connection getConnection() {
     return streamAllocation.connection();
   }
@@ -293,7 +295,7 @@ public Connection getConnection() {
    * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
    * permanent. Requests with a body can only be recovered if the body is buffered.
    */
-  public HttpEngine recover(IOException e, boolean routeException) {
+  public HttpEngine recover(IOException e, boolean routeException, Response userResponse) {
     streamAllocation.streamFailed(e);
 
     if (!client.retryOnConnectionFailure()) {
@@ -308,11 +310,11 @@ public HttpEngine recover(IOException e, boolean routeException) {
       return null; // No more routes to attempt.
     }
 
-    StreamAllocation streamAllocation = close();
+    StreamAllocation streamAllocation = close(userResponse);
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody,
-        forWebSocket, streamAllocation, priorResponse);
+    return new HttpEngine(client, userRequestUrl, forWebSocket, streamAllocation,
+        priorResponse);
   }
 
   private boolean isRecoverable(IOException e, boolean routeException) {
@@ -347,9 +349,9 @@ private boolean isRecoverable(IOException e, boolean routeException) {
     return true;
   }
 
-  private void maybeCache() throws IOException {
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    if (responseCache == null) return;
+  private CacheRequest maybeCache(Response userResponse, Request networkRequest,
+      InternalCache responseCache) throws IOException {
+    if (responseCache == null) return null;
 
     // Should we cache this response for this request?
     if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
@@ -360,11 +362,11 @@ private void maybeCache() throws IOException {
           // The cache cannot be written.
         }
       }
-      return;
+      return null;
     }
 
     // Offer this request to the cache.
-    storeRequest = responseCache.put(userResponse);
+    return responseCache.put(userResponse);
   }
 
   /**
@@ -392,7 +394,7 @@ public void cancel() {
    * Release any resources held by this engine. Returns the stream allocation held by this engine,
    * which itself must be used or released.
    */
-  public StreamAllocation close() {
+  public StreamAllocation close(Response userResponse) {
     if (userResponse != null) {
       closeQuietly(userResponse.body());
     } else {
@@ -417,7 +419,7 @@ public StreamAllocation close() {
    * attempt to decompress the zero-byte source.
    */
   private Response unzip(final Response response) throws IOException {
-    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+    if (!transparentGzip || !"gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
       return response;
     }
 
@@ -510,71 +512,6 @@ private String cookieHeader(List<Cookie> cookies) {
     return cookieHeader.toString();
   }
 
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response headers and starts
-   * reading the HTTP response body if it exists.
-   */
-  public void readResponse() throws IOException {
-    if (userResponse != null) {
-      return; // Already ready.
-    }
-    if (networkRequest == null && cacheResponse == null) {
-      throw new IllegalStateException("call sendRequest() first!");
-    }
-    if (networkRequest == null) {
-      return; // No network response to read.
-    }
-
-    Response networkResponse;
-
-    if (forWebSocket) {
-      httpStream.writeRequestHeaders(networkRequest);
-      networkResponse = readNetworkResponse();
-    } else {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest,
-          streamAllocation.connection()).proceed(networkRequest);
-    }
-
-    receiveHeaders(networkResponse.headers());
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (validate(cacheResponse, networkResponse)) {
-        userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-        releaseStreamAllocation();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        InternalCache responseCache = Internal.instance.internalCache(client);
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, userResponse);
-        userResponse = unzip(userResponse);
-        return;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
-
-    userResponse = networkResponse.newBuilder()
-        .request(userRequest)
-        .priorResponse(stripBody(priorResponse))
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
-
-    if (hasBody(userResponse)) {
-      maybeCache();
-      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
-    }
-  }
-
   class NetworkInterceptorChain implements Interceptor.Chain {
     private final int index;
     private final Request request;
@@ -637,9 +574,6 @@ public void readResponse() throws IOException {
 
       httpStream.writeRequestHeaders(request);
 
-      //Update the networkRequest with the possibly updated interceptor request.
-      networkRequest = request;
-
       if (permitsRequestBody(request) && request.body() != null) {
         Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
@@ -647,7 +581,7 @@ public void readResponse() throws IOException {
         bufferedRequestBody.close();
       }
 
-      Response response = readNetworkResponse();
+      Response response = readNetworkResponse(request);
 
       int code = response.code();
       if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
@@ -659,7 +593,7 @@ public void readResponse() throws IOException {
     }
   }
 
-  private Response readNetworkResponse() throws IOException {
+  private Response readNetworkResponse(Request networkRequest) throws IOException {
     httpStream.finishRequest();
 
     Response networkResponse = httpStream.readResponseHeaders()
@@ -802,10 +736,10 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
   public void receiveHeaders(Headers headers) throws IOException {
     if (client.cookieJar() == CookieJar.NO_COOKIES) return;
 
-    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
+    List<Cookie> cookies = Cookie.parseAll(userRequestUrl, headers);
     if (cookies.isEmpty()) return;
 
-    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
+    client.cookieJar().saveFromResponse(userRequestUrl, cookies);
   }
 
   /**
@@ -813,7 +747,7 @@ public void receiveHeaders(Headers headers) throws IOException {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  public Request followUpRequest() throws IOException {
+  public Request followUpRequest(Response userResponse) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     Connection connection = streamAllocation.connection();
     Route route = connection != null
@@ -821,7 +755,7 @@ public Request followUpRequest() throws IOException {
         : null;
     int responseCode = userResponse.code();
 
-    final String method = userRequest.method();
+    final String method = userResponse.request().method();
     switch (responseCode) {
       case HTTP_PROXY_AUTH:
         Proxy selectedProxy = route != null
@@ -852,17 +786,17 @@ public Request followUpRequest() throws IOException {
 
         String location = userResponse.header("Location");
         if (location == null) return null;
-        HttpUrl url = userRequest.url().resolve(location);
+        HttpUrl url = userResponse.request().url().resolve(location);
 
         // Don't follow redirects to unsupported protocols.
         if (url == null) return null;
 
         // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
+        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
         if (!sameScheme && !client.followSslRedirects()) return null;
 
         // Redirects don't include a request body.
-        Request.Builder requestBuilder = userRequest.newBuilder();
+        Request.Builder requestBuilder = userResponse.request().newBuilder();
         if (HttpMethod.permitsRequestBody(method)) {
           if (HttpMethod.redirectsToGet(method)) {
             requestBuilder.method("GET", null);
@@ -877,7 +811,7 @@ public Request followUpRequest() throws IOException {
         // When redirecting across hosts, drop all authentication headers. This
         // is potentially annoying to the application layer since they have no
         // way to retain them.
-        if (!sameConnection(url)) {
+        if (!sameConnection(userResponse, url)) {
           requestBuilder.removeHeader("Authorization");
         }
 
@@ -887,11 +821,11 @@ public Request followUpRequest() throws IOException {
         // 408's are rare in practice, but some servers like HAProxy use this response code. The
         // spec says that we may repeat the request without modifications. Modern browsers also
         // repeat the request (even non-idempotent ones.)
-        if (userRequest.body() instanceof UnrepeatableRequestBody) {
+        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
           return null;
         }
 
-        return userRequest;
+        return userResponse.request();
 
       default:
         return null;
@@ -902,26 +836,25 @@ public Request followUpRequest() throws IOException {
    * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
    * engine.
    */
-  public boolean sameConnection(HttpUrl followUp) {
-    HttpUrl url = userRequest.url();
+  public boolean sameConnection(Response response, HttpUrl followUp) {
+    HttpUrl url = response.request().url();
     return url.host().equals(followUp.host())
         && url.port() == followUp.port()
         && url.scheme().equals(followUp.scheme());
   }
 
-  private static Address createAddress(OkHttpClient client, Request request) {
+  private static Address createAddress(OkHttpClient client, HttpUrl url) {
     SSLSocketFactory sslSocketFactory = null;
     HostnameVerifier hostnameVerifier = null;
     CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
+    if (url.isHttps()) {
       sslSocketFactory = client.sslSocketFactory();
       hostnameVerifier = client.hostnameVerifier();
       certificatePinner = client.certificatePinner();
     }
 
-    return new Address(request.url().host(), request.url().port(), client.dns(),
-        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.proxyAuthenticator(), client.proxy(), client.protocols(),
-        client.connectionSpecs(), client.proxySelector());
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
index 030b346a5a..d18f04a77d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
@@ -23,7 +23,7 @@
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
-public final class RouteException extends Exception {
+public final class RouteException extends RuntimeException {
   private static final Method addSuppressedExceptionMethod;
 
   static {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
index aee74cf0bb..aca2a5a311 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -87,8 +87,7 @@ public StreamAllocation(ConnectionPool connectionPool, Address address) {
   }
 
   public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws RouteException, IOException {
+      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException {
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
           writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
@@ -118,7 +117,7 @@ public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeou
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
       int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException, RouteException {
+      throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
           connectionRetryEnabled);
@@ -146,7 +145,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException, RouteException {
+      boolean connectionRetryEnabled) throws IOException {
     Route selectedRoute;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index ef6e8f84d9..5edd0a53e8 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -90,7 +90,7 @@ public RealConnection(Route route) {
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
