diff --git a/.gitignore b/.gitignore
index 226a3f3d65..6321303cef 100644
--- a/.gitignore
+++ b/.gitignore
@@ -22,3 +22,9 @@ classes
 obj
 
 .DS_Store
+
+.gradle
+gradle
+gradlew
+gradlew.bat
+local.properties
diff --git a/benchmarks/build.gradle b/benchmarks/build.gradle
new file mode 100644
index 0000000000..5531967787
--- /dev/null
+++ b/benchmarks/build.gradle
@@ -0,0 +1,20 @@
+
+description = 'Benchmarks'
+dependencies {
+    compile group: 'com.google.caliper', name: 'caliper', version:'1.0-beta-1'
+    compile group: 'com.google.guava', name: 'guava', version:'14.0.1'
+  compile project(':okhttp')
+  compile project(':okhttp-urlconnection')
+  compile project(':mockwebserver')
+    compile group: 'org.bouncycastle', name: 'bcprov-jdk15on', version:'1.48'
+    compile group: 'org.apache.httpcomponents', name: 'httpclient', version:'4.2.2'
+    compile group: 'io.netty', name: 'netty-transport', version:'4.0.15.Final'
+    compile group: 'io.netty', name: 'netty-handler', version:'4.0.15.Final'
+    compile group: 'io.netty', name: 'netty-codec-http', version:'4.0.15.Final'
+    compile group: 'com.jcraft', name: 'jzlib', version:'1.1.2'
+    compile(group: 'org.mortbay.jetty.npn', name: 'npn-boot', version:'1.1.7.v20140316') {
+       /* This dependency was originally in the Maven provided scope, but the project was not of type war.
+       This behavior is not yet supported by Gradle, so this dependency has been converted to a compile dependency.
+       Please review and delete this closure when resolved. */
+    }
+}
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000000..c37e39588f
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,22 @@
+buildscript {
+    repositories {
+        maven { url "https://github.com/layerhq/releases-gradle/raw/master/releases" }
+        mavenCentral()
+    }
+    dependencies {
+        classpath group: 'com.layer', name: 'git-repo-plugin', version: '1.0.0'
+    }
+}
+
+apply from: project.file("version.gradle")
+
+allprojects {
+    group = 'com.squareup.okhttp'
+    version = rootProject.version
+}
+
+project.ext {
+    gitRepoHome = project.hasProperty("gitRepoHome") ? project.getProperty("gitRepoHome") : "${System.env.HOME}/.gitRepos"
+    org = project.hasProperty("org") ? project.getProperty("org") : "layerhq"
+    repo = project.hasProperty("repo") ? project.getProperty("repo") : "maven-private"
+}
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
new file mode 100644
index 0000000000..dbca8ea91c
--- /dev/null
+++ b/mockwebserver/build.gradle
@@ -0,0 +1,72 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'git-repo'
+
+description = 'MockWebServer'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+repositories {
+    maven { url "${System.env.HOME}/.m2/repository" }
+    github("layerhq", "maven-private", "master", "releases")
+    mavenCentral()
+}
+
+dependencies {
+  compile project(':okhttp')
+    compile group: 'org.bouncycastle', name: 'bcprov-jdk15on', version:'1.48'
+    compile group: 'junit', name: 'junit', version:'4.11'
+}
+
+
+/*************************************************
+ * Uploading
+ * e.g. > gradle clean build publish
+ ************************************************/
+
+task sourceJar(type: Jar) {
+    from sourceSets.main.allJava
+}
+
+task testJar(type: Jar) {
+    from sourceSets.test.output
+    exclude "**/*Test*"
+}
+
+task testSourceJar(type: Jar) {
+    from sourceSets.test.allJava
+}
+
+public String getLocalGit() {
+    return "$rootProject.ext.gitRepoHome/$rootProject.ext.org/$rootProject.ext.repo"
+}
+
+publishing {
+    publications {
+        mavenJava(MavenPublication) {
+            groupId = group
+            artifactId = 'mockwebserver'
+            version = rootProject.version
+            from components.java
+
+            artifact sourceJar {
+                classifier "sources"
+            }
+
+            artifact testJar {
+                classifier "test"
+            }
+
+            artifact testSourceJar {
+                classifier "testsources"
+            }
+        }
+    }
+    repositories {
+        maven {
+            url "file://${getLocalGit()}/releases"
+        }
+    }
+}
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
new file mode 100644
index 0000000000..c02b8a9bbd
--- /dev/null
+++ b/okcurl/build.gradle
@@ -0,0 +1,10 @@
+
+description = 'OkCurl'
+dependencies {
+  compile project(':okhttp')
+    compile group: 'org.bouncycastle', name: 'bcprov-jdk15on', version:'1.48'
+    compile group: 'org.mortbay.jetty.npn', name: 'npn-boot', version:'1.1.7.v20140316'
+    compile group: 'io.airlift', name: 'airline', version:'0.6'
+    compile group: 'com.google.guava', name: 'guava', version:'16.0'
+    testCompile group: 'junit', name: 'junit', version:'4.11'
+}
diff --git a/okhttp-apache/build.gradle b/okhttp-apache/build.gradle
new file mode 100644
index 0000000000..17cc6b17b8
--- /dev/null
+++ b/okhttp-apache/build.gradle
@@ -0,0 +1,12 @@
+
+description = 'OkHttp Apache HttpClient'
+dependencies {
+  compile project(':okhttp')
+  testCompile project(':mockwebserver')
+    testCompile group: 'junit', name: 'junit', version:'4.11'
+    compile(group: 'org.apache.httpcomponents', name: 'httpclient', version:'4.2.2') {
+       /* This dependency was originally in the Maven provided scope, but the project was not of type war.
+       This behavior is not yet supported by Gradle, so this dependency has been converted to a compile dependency.
+       Please review and delete this closure when resolved. */
+    }
+}
diff --git a/okhttp-tests/build.gradle b/okhttp-tests/build.gradle
new file mode 100644
index 0000000000..89f43dee1d
--- /dev/null
+++ b/okhttp-tests/build.gradle
@@ -0,0 +1,9 @@
+
+description = 'OkHttp Tests'
+dependencies {
+    compile group: 'com.squareup.okio', name: 'okio', version:'0.9.0-LAYER'
+  compile project(':okhttp')
+  compile project(':okhttp-urlconnection')
+    testCompile group: 'junit', name: 'junit', version:'4.11'
+  testCompile project(':mockwebserver')
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 68ba1dd4c6..8f2ec381b2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.PushPromise;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.File;
@@ -292,6 +293,37 @@
     patch();
   }
 
+  @Test public void push_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    server.enqueue(new MockResponse()
+        .withPush(new PushPromise("GET", "/pushed", Arrays.asList("foo: bar"),
+             new MockResponse().setBody("push data")))
+        .setBody("abc"));
+    server.play();
+
+    TestPushObserver pushObserver = new TestPushObserver();
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    executeSynchronously(request, pushObserver)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+
+    synchronized (pushObserver) {
+      if (!pushObserver.gotRequest()) {
+        pushObserver.wait();
+      }
+      assertNull(pushObserver.exception());
+      assertEquals("/pushed", pushObserver.response().header("path"));
+      assertEquals("push data", new String(pushObserver.response().body().bytes()));
+    }
+  }
+
   @Test public void illegalToExecuteTwice() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -1204,9 +1236,14 @@
         .assertRequestHeader("Accept-Encoding", "gzip");
   }
 
+  private RecordedResponse executeSynchronously(Request request, PushObserver pushObserver) throws IOException {
+      Call call = client.newCall(request.newBuilder().pushObserver(pushObserver).build());
+      Response response = call.execute();
+      return new RecordedResponse(request, response, response.body().string(), null);
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Response response = client.newCall(request).execute();
-    return new RecordedResponse(request, response, response.body().string(), null);
+      return executeSynchronously(request, null);
   }
 
   /**
@@ -1243,4 +1280,33 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     }
   }
+  private class TestPushObserver implements PushObserver {
+    private boolean gotRequest = false;
+    private IOException exception = null;
+    private Response response = null;
+    private String data = null;
+
+    public boolean gotRequest() {
+      return gotRequest;
+    }
+
+    public IOException exception() {
+      return exception;
+    }
+
+    public Response response() {
+      return response;
+    }
+
+
+    @Override public synchronized boolean onPush(Response response) {
+      try {
+          this.response = response;
+        return false;
+      } finally {
+        gotRequest = true;
+        notifyAll();
+      }
+    }
+  };
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index e58730e015..b852ae7fd5 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -596,7 +596,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .addHeader("key1", "value1_1")
         .addHeader("key2", "value2")
         .addHeader("key1", "value1_2")
-        .body(null)
+        .body((ResponseBody) null)
         .build();
     CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
     assertFalse(javaCacheResponse instanceof SecureCacheResponse);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 05072897ed..89aa6bfc38 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1530,6 +1530,37 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     assertEquals(expectedResponseHeaders, observer.takeEvent());
   }
 
+  @Test public void pushStream() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedPushHeaders = Arrays.asList(
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().synStream(false, true, 2, 3, expectedPushHeaders);
+    peer.sendFrame().data(true, 3, data(0));
+    peer.sendFrame().data(true, 2, new Buffer().writeUtf8("robot"));
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, SPDY3)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedPushHeaders, observer.takeEvent());
+    assertEquals("robot", observer.takeEvent());
+  }
+
   @Test public void doublePushPromise() throws Exception {
     peer.setVariantAndClient(HTTP_2, false);
 
@@ -1567,7 +1598,7 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
 
     // play it back
     connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL).build();
+        .pushObserver(SpdyPushObserver.CANCEL).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1642,27 +1673,18 @@ static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
 
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
+  static final SpdyPushObserver IGNORE = new SpdyPushObserver() {
 
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+    @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
       return false;
     }
 
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
+    @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
       return false;
     }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
   };
 
-  private static class RecordingPushObserver implements PushObserver {
+  private static class RecordingPushObserver implements SpdyPushObserver {
     final List<Object> events = new ArrayList<Object>();
 
     public synchronized Object takeEvent() throws InterruptedException {
@@ -1672,32 +1694,26 @@ public synchronized Object takeEvent() throws InterruptedException {
       return events.remove(0);
     }
 
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+    @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
       assertEquals(2, streamId);
       events.add(requestHeaders);
       notifyAll();
       return false;
     }
 
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
+    @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
+      assertEquals(2, push.getId());
+      events.add(push.getRequestHeaders());
+      Source in = push.getSource();
+      try {
+        String data = Okio.buffer(in).readByteString(5).utf8();
+
+        events.add(data);
+        notifyAll();
+      } catch (IOException expected) {
+        // Just don't push anything to events
+      }
       return false;
     }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
   }
 }
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
new file mode 100644
index 0000000000..75cc6c86c0
--- /dev/null
+++ b/okhttp-urlconnection/build.gradle
@@ -0,0 +1,6 @@
+
+description = 'OkHttp URLConnection'
+dependencies {
+  compile project(':okhttp')
+    testCompile group: 'junit', name: 'junit', version:'4.11'
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 2dbaea0957..ee0b247f26 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -308,8 +308,8 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
-        priorResponse);
+    return new HttpEngine(engineClient, request, doOutput, bufferRequestBody, connection, null,
+        requestBody, priorResponse);
   }
 
   /**
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
new file mode 100644
index 0000000000..972a58259f
--- /dev/null
+++ b/okhttp/build.gradle
@@ -0,0 +1,77 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'git-repo'
+
+description = 'OkHttp'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+repositories {
+    maven { url "${System.env.HOME}/.m2/repository" }
+    github("layerhq", "maven-private", "master", "releases")
+    mavenCentral()
+}
+
+dependencies {
+    compile group: 'com.squareup.okio', name: 'okio', version:'0.9.0.a71ef0da.LAYER'
+}
+
+
+/*************************************************
+ * Uploading
+ * e.g. > gradle clean build publish
+ ************************************************/
+
+task sourceJar(type: Jar) {
+    from sourceSets.main.allJava
+}
+
+task testJar(type: Jar) {
+    from sourceSets.test.output
+    exclude "**/*Test*"
+}
+
+task testSourceJar(type: Jar) {
+    from sourceSets.test.allJava
+}
+
+public String getLocalGit() {
+    return "$rootProject.ext.gitRepoHome/$rootProject.ext.org/$rootProject.ext.repo"
+}
+
+publishing {
+    publications {
+        mavenJava(MavenPublication) {
+            groupId = group
+            artifactId = 'okhttp'
+            version = rootProject.version
+            from components.java
+
+            artifact sourceJar {
+                classifier "sources"
+            }
+
+            artifact testJar {
+                classifier "test"
+            }
+
+            artifact testSourceJar {
+                classifier "testsources"
+            }
+        }
+    }
+    repositories {
+        maven {
+            url "file://${getLocalGit()}/releases"
+        }
+    }
+}
+
+task cleanLocalGit(type: Delete) {
+    doFirst {
+        println "Deleting local git repo `${getLocalGit()}`..."
+        delete "${getLocalGit()}"
+    }
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 8b994410ab..89d82921c7 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -16,6 +16,7 @@
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
+      <version>0.9.0-LAYER</version>
     </dependency>
   </dependencies>
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 2e0a732f19..c3c511886b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -19,12 +19,10 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import java.io.IOException;
 import java.net.ProtocolException;
 import okio.BufferedSink;
-import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
 
@@ -188,7 +186,8 @@ private Response getResponse() throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, requestBodyOut, null);
+    engine = new HttpEngine(client, request, request.body() != null, false, null, null,
+            requestBodyOut, null);
 
     while (true) {
       if (canceled) return null;
@@ -219,7 +218,7 @@ private Response getResponse() throws IOException {
       if (followUp == null) {
         engine.releaseConnection();
         return response.newBuilder()
-            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .body(engine.getResponseBody())
             .build();
       }
 
@@ -233,30 +232,8 @@ private Response getResponse() throws IOException {
 
       Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, connection, null, null, response);
-    }
-  }
-
-  private static class RealResponseBody extends ResponseBody {
-    private final Response response;
-    private final BufferedSource source;
-
-    RealResponseBody(Response response, BufferedSource source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header("Content-Type");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public BufferedSource source() {
-      return source;
+      engine = new HttpEngine(client, request, request.body() != null, false, connection, null,
+              null, response);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 87290411d9..4e0414ea11 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -63,6 +63,7 @@
   private final ConnectionPool pool;
   private final Route route;
 
+  private final ConnectionObserver connectionObserver;
   private Socket socket;
   private boolean connected = false;
   private HttpConnection httpConnection;
@@ -82,6 +83,7 @@
   public Connection(ConnectionPool pool, Route route) {
     this.pool = pool;
     this.route = route;
+    this.connectionObserver = pool.getConnectionObserver();
   }
 
   Object getOwner() {
@@ -191,6 +193,7 @@ private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeo
     handshake = Handshake.get(sslSocket.getSession());
 
     String maybeProtocol;
+    protocol = route.address.protocols.get(0);
     if (useNpn && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
       protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
     }
@@ -198,7 +201,10 @@ private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeo
     if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
       spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
+          .connection(this)
+          .connectionObserver(connectionObserver)
+          .protocol(protocol)
+          .build();
       spdyConnection.sendConnectionPreface();
     } else {
       httpConnection = new HttpConnection(pool, this, socket);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionObserver.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionObserver.java
new file mode 100644
index 0000000000..6039236d3b
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionObserver.java
@@ -0,0 +1,10 @@
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+public interface ConnectionObserver {
+    /**
+     * Invoked when an exception occurs on the Connection's socket
+     */
+    void onIOException(Connection connection, IOException e);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index aac94c060a..2392e1b16d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -76,6 +76,7 @@
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
 
+  private final ConnectionObserver connectionObserver;
   private final LinkedList<Connection> connections = new LinkedList<Connection>();
 
   /** We use a single background thread to cleanup expired connections. */
@@ -115,9 +116,15 @@
     }
   };
 
+
   public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
+    this(maxIdleConnections, keepAliveDurationMs, null);
+  }
+
+  public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs, ConnectionObserver connectionObserver) {
     this.maxIdleConnections = maxIdleConnections;
     this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
+    this.connectionObserver = connectionObserver;
   }
 
   /**
@@ -150,6 +157,10 @@ public static ConnectionPool getDefault() {
     return systemDefault;
   }
 
+  protected ConnectionObserver getConnectionObserver() {
+    return connectionObserver;
+  }
+
   /** Returns total number of connections in the pool. */
   public synchronized int getConnectionCount() {
     return connections.size();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 2a1df0bf6d..c5fa5f3d78 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -457,7 +457,7 @@ public OkHttpClient cancel(Object tag) {
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  OkHttpClient copyWithDefaults() {
+  public OkHttpClient copyWithDefaults() {
     OkHttpClient result = clone();
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java
new file mode 100644
index 0000000000..222b05d888
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/PushObserver.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+/**
+ * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} and
+ * {@link com.squareup.okhttp.Protocol#SPDY_3 SPDY/3} only.
+ * Processes server-initiated HTTP requests on the client. Implementations must
+ * quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>Return true to request cancellation of a pushed stream.  Note that this
+ * does not guarantee future frames won't arrive on the stream ID.
+ */
+public interface PushObserver {
+  /**
+   * Receive a push initiated by the server. The push is in the form of
+   * an http response, where the request is either a previous client response
+   * (SPDY) or a push promise "request" from the server (HTTP/2).
+   *
+   * @param response The push from the server
+   * @return true to cancel the push stream
+   */
+  boolean onPush(Response response);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 5d1ec86482..bd0ecfa687 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
+
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URI;
@@ -33,6 +34,7 @@
   private final Headers headers;
   private final RequestBody body;
   private final Object tag;
+  private final PushObserver pushObserver;
 
   private volatile URI uri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
@@ -43,6 +45,7 @@ private Request(Builder builder) {
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.pushObserver = builder.pushObserver;
   }
 
   public URL url() {
@@ -86,6 +89,10 @@ public Object tag() {
     return tag;
   }
 
+  public PushObserver pushObserver() {
+    return pushObserver;
+  }
+
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -119,6 +126,7 @@ public boolean isHttps() {
     private Headers.Builder headers;
     private RequestBody body;
     private Object tag;
+    private PushObserver pushObserver = null;
 
     public Builder() {
       this.method = "GET";
@@ -131,6 +139,7 @@ private Builder(Request request) {
       this.body = request.body;
       this.tag = request.tag;
       this.headers = request.headers.newBuilder();
+      this.pushObserver = request.pushObserver;
     }
 
     public Builder url(String url) {
@@ -209,6 +218,11 @@ public Builder method(String method, RequestBody body) {
       return this;
     }
 
+    public Builder pushObserver(PushObserver pushObserver) {
+      this.pushObserver = pushObserver;
+      return this;
+    }
+
     /**
      * Attaches {@code tag} to the request. It can be used later to cancel the
      * request. If the tag is unspecified or null, the request is canceled by
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 2762992229..1afc5bf66a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,6 +16,8 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.OkHeaders;
+import okio.BufferedSource;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -296,6 +298,38 @@ public Builder body(ResponseBody body) {
       return this;
     }
 
+    public Builder body(BufferedSource source) {
+      return body(new RealResponseBody(source));
+    }
+
+    private class RealResponseBody extends ResponseBody {
+      private final MediaType mediaType;
+      private final BufferedSource source;
+      private final long contentLength;
+
+      RealResponseBody(BufferedSource source) {
+        if (headers == null) {
+          throw new IllegalStateException("Set headers before setting the body");
+        }
+        String contentType = headers.get("Content-Type");
+        mediaType = contentType != null ? MediaType.parse(contentType) : null;
+        this.source = source;
+        this.contentLength = OkHeaders.contentLength(headers.build());
+      }
+
+      @Override public MediaType contentType() {
+        return mediaType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    }
+
     public Builder networkResponse(Response networkResponse) {
       if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
       this.networkResponse = networkResponse;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index fbedbb36ca..710573096b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -256,17 +256,7 @@ private Android(Class<?> openSslSocketClass, Method setUseSessionTickets, Method
     }
 
     @Override public String getSelectedProtocol(SSLSocket socket) {
-      if (getNpnSelectedProtocol == null) return null;
-      if (!openSslSocketClass.isInstance(socket)) return null;
-      try {
-        byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
-        if (npnResult == null) return null;
-        return new String(npnResult, Util.UTF_8);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
+      return null;
     }
 
     @Override public void tagSocket(Socket socket) throws SocketException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 7890052530..c4ac949d1b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -164,6 +164,14 @@
    */
   private Response userResponse;
 
+  /**
+   * True if this connection ever intends to do output. This is necessary
+   * because we don't see the actual body until after we've established
+   * the connection and sent up headers, but those headers depend on
+   * whether or not there will ever be a body.
+   */
+  private boolean willHaveRequestBody;
+
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
 
@@ -187,11 +195,13 @@
    *     immediately preceding this attempt, or null if this request doesn't
    *     recover from a failure.
    */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
-      Response priorResponse) {
+  public HttpEngine(OkHttpClient client, Request request, boolean willHaveRequestBody,
+      boolean bufferRequestBody, Connection connection, RouteSelector routeSelector,
+      RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
+
+    this.willHaveRequestBody = willHaveRequestBody;
     this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
     this.routeSelector = routeSelector;
@@ -288,7 +298,7 @@ public void sendRequest() throws IOException {
 
   private static Response stripBody(Response response) {
     return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
+        ? response.newBuilder().body((ResponseBody) null).build()
         : response;
   }
 
@@ -339,8 +349,8 @@ public void writingRequestHeaders() {
   }
 
   boolean hasRequestBody() {
-    return HttpMethod.hasRequestBody(userRequest.method())
-        && !Util.emptySink().equals(requestBodyOut);
+    return HttpMethod.hasRequestBody(userRequest.method()) && willHaveRequestBody
+            && !Util.emptySink().equals(requestBodyOut);
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
@@ -411,8 +421,8 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut, priorResponse);
+    return new HttpEngine(client, userRequest, willHaveRequestBody, bufferRequestBody, connection,
+        routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
   public HttpEngine recover(IOException e) {
@@ -629,6 +639,10 @@ private Request networkRequest(Request request) throws IOException {
     return result.build();
   }
 
+  public boolean isTransparentGzip() {
+    return transparentGzip;
+  }
+
   public static String getDefaultUserAgent() {
     String agent = System.getProperty("http.agent");
     return agent != null ? agent : ("Java" + System.getProperty("java.version"));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 07713ec472..91f29f6b8d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,15 +16,17 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.PushObserver;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
+import com.squareup.okhttp.internal.spdy.SpdyPushObserver;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheRequest;
@@ -36,7 +38,10 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
 import okio.ByteString;
+import okio.Okio;
 import okio.Sink;
 import okio.Source;
 import okio.Timeout;
@@ -69,6 +74,8 @@
       ByteString.encodeUtf8("encoding"),
       ByteString.encodeUtf8("upgrade"));
 
+  private static final String VALUE_DELIMITER = "0x00";
+
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -84,7 +91,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     return stream.getSink();
   }
 
-  @Override public void writeRequestHeaders(Request request) throws IOException {
+  @Override public void writeRequestHeaders(final Request request) throws IOException {
     if (stream != null) return;
 
     httpEngine.writingRequestHeaders();
@@ -95,6 +102,37 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
     stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
+
+    final PushObserver pushCallback = request.pushObserver();
+    if (pushCallback != null) {
+      stream.pushObserver = new SpdyPushObserver() {
+        @Override public synchronized boolean onPromise(int streamId, List<Header> requestHeaders) {
+          return true;
+        }
+
+        @Override public synchronized boolean onPush(SpdyStream associated, SpdyStream push) {
+          try {
+            Response partialResponse = parsePushResponse(request, push.getRequestHeaders(),
+                    spdyConnection.getProtocol()).build();
+
+            SpdySource source = new SpdySource(push, null);
+            BufferedSource buffer;
+            if (httpEngine.isTransparentGzip()
+                    && "gzip".equalsIgnoreCase(partialResponse.headers().get("Content-Encoding"))) {
+              buffer = Okio.buffer(new GzipSource(source));
+            } else {
+              buffer = Okio.buffer(source);
+            }
+            Response response = partialResponse.newBuilder()
+                    .body(buffer)
+                    .build();
+            return pushCallback.onPush(response);
+          } catch (IOException ignored) {
+            return true;
+          }
+        }
+      };
+    }
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -211,6 +249,44 @@ private static String joinOnNull(String first, String second) {
         .headers(headersBuilder.build());
   }
 
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder parsePushResponse(Request request, List<Header> headerBlock,
+                                                  Protocol protocol) throws IOException {
+    String path = null;
+    String host = null;
+    String scheme = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
+    for (Header header : headerBlock) {
+      ByteString name = header.name;
+      String values = header.value.utf8();
+      for (String value : values.split(VALUE_DELIMITER)) {
+        if (name.equals(TARGET_PATH)) {
+          path = value;
+        } else if (name.equals(TARGET_HOST)) {
+          host = value;
+        } else if (name.equals(TARGET_SCHEME)) {
+          scheme = value;
+        }
+        if (!isProhibitedHeader(protocol, name)) {
+          headersBuilder.add(name.utf8(), value);
+        }
+      }
+    }
+    if (path == null || host == null || scheme == null) {
+      throw new ProtocolException("Expected ':path',':host', ':scheme' headers are not set");
+    }
+
+    return new Response.Builder()
+            .code(200)
+            .message("OK")
+            .request(request)
+            .protocol(protocol)
+            .headers(headersBuilder.build());
+  }
+
+
   @Override public void emptyTransferStream() {
     // Do nothing.
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 520a28bebf..ecadb33c1f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionObserver;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
@@ -25,10 +27,9 @@
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
@@ -37,6 +38,7 @@
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.IOExceptionObserver;
 import okio.Okio;
 
 import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
@@ -51,6 +53,7 @@
  * was triggered by a certain caller can be caught and handled by that caller.
  */
 public final class SpdyConnection implements Closeable {
+    private static final long PUSH_IDLE_TIMEOUT = 10 * 1000;
 
   // Internal state of this connection is guarded by 'this'. No blocking
   // operations may be performed while holding this lock!
@@ -68,6 +71,11 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp SpdyConnection", true));
 
+    private final Connection connection;
+
+    // Optional callback that will be invoked when a socket gets closed
+    private final ConnectionObserver connectionObserver;
+
   /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
   final Protocol protocol;
 
@@ -79,7 +87,7 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
+  private final Map<Integer, SpdyStream> streams = new ConcurrentHashMap<Integer, SpdyStream>();
   private final String hostName;
   private int lastGoodStreamId;
   private int nextStreamId;
@@ -92,7 +100,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  private final SpdyPushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -128,8 +136,9 @@
   final Reader readerRunnable;
 
   private SpdyConnection(Builder builder) throws IOException {
+    connection = builder.connection;
+    connectionObserver = builder.connectionObserver;
     protocol = builder.protocol;
-    pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-5.1.1
@@ -148,21 +157,28 @@ private SpdyConnection(Builder builder) throws IOException {
 
     if (protocol == Protocol.HTTP_2) {
       variant = new Http20Draft12();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1,
-          0L, TimeUnit.MILLISECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
-      pushExecutor = null;
     } else {
       throw new AssertionError(protocol);
     }
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1,
+      PUSH_IDLE_TIMEOUT, TimeUnit.MILLISECONDS,
+      new LinkedBlockingQueue<Runnable>(),
+      Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
     socket = builder.socket;
-    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
+    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket, new IOExceptionObserver() {
+      public void onIOException(IOException e) {
+        if (connectionObserver != null) {
+          connectionObserver.onIOException(connection, e);
+        }
+      }
+    })), client);
     maxFrameSize = variant.maxFrameSize();
+    pushObserver = builder.pushObserver;
 
     readerRunnable = new Reader();
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -221,7 +237,6 @@ public synchronized long getIdleStartTimeNs() {
   public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
     return newStream(associatedStreamId, requestHeaders, out, false);
   }
 
@@ -258,7 +273,7 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
           setIdle(false);
         }
       }
-      if (associatedStreamId == 0) {
+      if (associatedStreamId == 0 || protocol == Protocol.SPDY_3) {
         frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
             requestHeaders);
       } else if (client) {
@@ -502,11 +517,13 @@ public void sendConnectionPreface() throws IOException {
   }
 
   public static class Builder {
+    private Connection connection;
+    private ConnectionObserver connectionObserver;
     private String hostName;
     private Socket socket;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
-    private PushObserver pushObserver = PushObserver.CANCEL;
+    private SpdyPushObserver pushObserver = SpdyPushObserver.CANCEL;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
@@ -533,11 +550,21 @@ public Builder protocol(Protocol protocol) {
       return this;
     }
 
-    public Builder pushObserver(PushObserver pushObserver) {
+    public Builder pushObserver(SpdyPushObserver pushObserver) {
       this.pushObserver = pushObserver;
       return this;
     }
 
+    public Builder connection(Connection connection) {
+      this.connection = connection;
+      return this;
+    }
+
+    public Builder connectionObserver(ConnectionObserver connectionObserver) {
+      this.connectionObserver = connectionObserver;
+      return this;
+    }
+
     public SpdyConnection build() throws IOException {
       return new SpdyConnection(this);
     }
@@ -558,7 +585,13 @@ private Reader() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
+        frameReader = variant.newReader(Okio.buffer(Okio.source(socket, new IOExceptionObserver() {
+                public void onIOException(IOException e) {
+                        if (SpdyConnection.this.connectionObserver != null) {
+                            SpdyConnection.this.connectionObserver.onIOException(SpdyConnection.this.connection, e);
+                    }
+                }
+            })), client);
         if (!client) {
           frameReader.readConnectionPreface();
         }
@@ -579,11 +612,7 @@ private Reader() {
     }
 
     @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (pushedStream(streamId)) {
-        pushDataLater(streamId, source, length, inFinished);
-        return;
-      }
+      throws IOException {
       SpdyStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
@@ -597,18 +626,25 @@ private Reader() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-      if (pushedStream(streamId)) {
-        pushHeadersLater(streamId, headerBlock, inFinished);
-        return;
-      }
+      int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       SpdyStream stream;
+      SpdyStream associated = null;
       synchronized (SpdyConnection.this) {
         // If we're shutdown, don't bother with this stream.
         if (shutdown) return;
 
         stream = getStream(streamId);
 
+        // Fetch associated stream
+        if (pushedStream(streamId)) {
+          associated = getStream(associatedStreamId);
+
+          if (associated == null) {
+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+            return;
+          }
+        }
+
         if (stream == null) {
           // The headers claim to be for an existing stream, but we don't have one.
           if (headersMode.failIfStreamAbsent()) {
@@ -627,6 +663,14 @@ private Reader() {
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
+
+          // Handle PUSH streams
+          if (pushedStream(streamId)) {
+            pushStreamLater(associated, newStream);
+            return;
+          }
+
+          // Handle server incoming requests
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
@@ -653,10 +697,6 @@ private Reader() {
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (pushedStream(streamId)) {
-        pushResetLater(streamId, errorCode);
-        return;
-      }
       SpdyStream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
@@ -696,7 +736,8 @@ private Reader() {
 
     private void ackSettingsLater() {
       executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
-        @Override public void execute() {
+        @Override
+        public void execute() {
           try {
             frameWriter.ackSettings();
           } catch (IOException ignored) {
@@ -721,8 +762,9 @@ private void ackSettingsLater() {
       }
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (debugData.size() > 0) { // TODO: log the debugData
+     @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (debugData.size() > 0) {
+        // TODO: log the debugData
       }
       synchronized (SpdyConnection.this) {
         shutdown = true;
@@ -757,46 +799,32 @@ private void ackSettingsLater() {
     }
 
     @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
+      boolean exclusive) {
       // TODO: honor priority.
     }
 
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
-      pushRequestLater(promisedStreamId, requestHeaders);
+    @Override public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
+      pushPromiseLater(promisedStreamId, requestHeaders);
     }
 
     @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
+      String host, int port, long maxAge) {
       // TODO: register alternate service.
     }
   }
 
-  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  /** Even, positive numbered streams are pushed streams in HTTP/2 and SPDY/3. */
   private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+    return (protocol == Protocol.HTTP_2 || client) && streamId > 0 && (streamId & 1) == 0;
   }
 
-  // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
-
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
-    synchronized (this) {
-      if (currentPushRequests.contains(streamId)) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        return;
-      }
-      currentPushRequests.add(streamId);
-    }
+  private void pushPromiseLater(final int streamId, final List<Header> requestHeaders) {
     pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+        boolean cancel = pushObserver.onPromise(streamId, requestHeaders);
         try {
           if (cancel) {
             frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
           }
         } catch (IOException ignored) {
         }
@@ -804,58 +832,30 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
-      final boolean inFinished) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+  private void pushStreamLater(final SpdyStream associated, final SpdyStream push) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, push.getId()) {
       @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
+        SpdyPushObserver streamPushObserver;
+        boolean cancel;
+        int pushId;
+        synchronized (associated) {
+          if (associated.pushObserver != null) {
+            streamPushObserver = associated.pushObserver;
+          } else {
+            streamPushObserver = pushObserver;
+          }
+          synchronized (push) {
+            pushId = push.getId();
+            cancel = streamPushObserver.onPush(associated, push);
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
-  }
-
-  /**
-   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
-   * process the data.  This avoids corrupting the stream.
-   */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
-      final boolean inFinished) throws IOException {
-    final Buffer buffer = new Buffer();
-    source.require(byteCount); // Eagerly read the frame before firing client thread.
-    source.read(buffer, byteCount);
-    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
-      @Override public void execute() {
         try {
-          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
+          if (cancel) {
+            frameWriter.rstStream(pushId, ErrorCode.CANCEL);
           }
         } catch (IOException ignored) {
         }
       }
     });
   }
-
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
-      @Override public void execute() {
-        pushObserver.onReset(streamId, errorCode);
-        synchronized (SpdyConnection.this) {
-          currentPushRequests.remove(streamId);
-        }
-      }
-    });
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
index cdb51f65a5..dda77a5180 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyPushObserver.java
@@ -15,9 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import java.io.IOException;
 import java.util.List;
-import okio.BufferedSource;
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
@@ -38,7 +36,7 @@
  * <p>Return true to request cancellation of a pushed stream.  Note that this
  * does not guarantee future frames won't arrive on the stream ID.
  */
-public interface PushObserver {
+public interface SpdyPushObserver {
   /**
    * Describes the request that the server intends to push a response for.
    *
@@ -46,7 +44,7 @@
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
    * {@code :authority}, and (@code :path}.
    */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
+  boolean onPromise(int streamId, List<Header> requestHeaders);
 
   /**
    * The response headers corresponding to a pushed request.  When {@code last}
@@ -56,40 +54,16 @@
    * @param responseHeaders minimally includes {@code :status}.
    * @param last when true, there is no response data.
    */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+  boolean onPush(SpdyStream associated, SpdyStream push);
 
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
-
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
-
-  PushObserver CANCEL = new PushObserver() {
+  SpdyPushObserver CANCEL = new SpdyPushObserver() {
 
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+    @Override public boolean onPromise(int streamId, List<Header> requestHeaders) {
       return true;
     }
 
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+    @Override public boolean onPush(SpdyStream associated, SpdyStream push) {
       return true;
     }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
   };
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 30e2ccb3b7..fdb22c4cee 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -65,6 +65,7 @@
   final SpdyDataSink sink;
   private final SpdyTimeout readTimeout = new SpdyTimeout();
   private final SpdyTimeout writeTimeout = new SpdyTimeout();
+  public SpdyPushObserver pushObserver = null;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
diff --git a/pom.xml b/pom.xml
index 4202ae29d6..1ae08f529e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -68,7 +68,16 @@
     </license>
   </licenses>
 
-  <dependencyManagement>
+    <distributionManagement>
+        <repository>
+            <id>deployment</id>
+            <name>Internal Releases</name>
+            <url>${env.OKHTTP_DEPLOYMENT_URL}</url>
+        </repository>
+    </distributionManagement>
+
+
+    <dependencyManagement>
     <dependencies>
       <dependency>
         <groupId>com.squareup.okio</groupId>
diff --git a/samples/crawler/build.gradle b/samples/crawler/build.gradle
new file mode 100644
index 0000000000..11f8e98787
--- /dev/null
+++ b/samples/crawler/build.gradle
@@ -0,0 +1,6 @@
+group = 'com.squareup.okhttp.sample'
+description = 'Sample: Crawler'
+dependencies {
+  compile project(':okhttp')
+    compile group: 'org.jsoup', name: 'jsoup', version:'1.7.3'
+}
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
new file mode 100644
index 0000000000..16cbc738fa
--- /dev/null
+++ b/samples/guide/build.gradle
@@ -0,0 +1,5 @@
+group = 'com.squareup.okhttp.sample'
+description = 'Sample: Guide'
+dependencies {
+  compile project(':okhttp')
+}
diff --git a/samples/simple-client/build.gradle b/samples/simple-client/build.gradle
new file mode 100644
index 0000000000..672d9fc2f6
--- /dev/null
+++ b/samples/simple-client/build.gradle
@@ -0,0 +1,6 @@
+group = 'com.squareup.okhttp.sample'
+description = 'Sample: Simple Client'
+dependencies {
+  compile project(':okhttp')
+    compile group: 'com.google.code.gson', name: 'gson', version:'2.2.3'
+}
diff --git a/samples/static-server/build.gradle b/samples/static-server/build.gradle
new file mode 100644
index 0000000000..6bc70a764c
--- /dev/null
+++ b/samples/static-server/build.gradle
@@ -0,0 +1,5 @@
+group = 'com.squareup.okhttp.sample'
+description = 'Sample: Static Server'
+dependencies {
+  compile project(':mockwebserver')
+}
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000000..3e0d2a0ee7
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,26 @@
+rootProject.name = 'parent'
+include ':okhttp'
+//include ':okhttp-apache'
+//include ':okhttp-tests'
+//include ':okhttp-urlconnection'
+//include ':okcurl'
+include ':mockwebserver'
+//include ':sample-parent:guide'
+//include ':sample-parent:crawler'
+//include ':sample-parent:simple-client'
+//include ':sample-parent:static-server'
+//include ':sample-parent'
+//include ':benchmarks'
+
+project(':okhttp').projectDir = "$rootDir/okhttp" as File
+//project(':okhttp-apache').projectDir = "$rootDir/okhttp-apache" as File
+//project(':okhttp-tests').projectDir = "$rootDir/okhttp-tests" as File
+//project(':okhttp-urlconnection').projectDir = "$rootDir/okhttp-urlconnection" as File
+//project(':okcurl').projectDir = "$rootDir/okcurl" as File
+project(':mockwebserver').projectDir = "$rootDir/mockwebserver" as File
+//project(':sample-parent:guide').projectDir = "$rootDir/samples/guide" as File
+//project(':sample-parent:crawler').projectDir = "$rootDir/samples/crawler" as File
+//project(':sample-parent:simple-client').projectDir = "$rootDir/samples/simple-client" as File
+//project(':sample-parent:static-server').projectDir = "$rootDir/samples/static-server" as File
+//project(':sample-parent').projectDir = "$rootDir/samples" as File
+//project(':benchmarks').projectDir = "$rootDir/benchmarks" as File
diff --git a/version.gradle b/version.gradle
new file mode 100644
index 0000000000..184c67d1d3
--- /dev/null
+++ b/version.gradle
@@ -0,0 +1 @@
+version = '2.0.0-LAYER'
