diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
index a8ef919334..8a45e892b1 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -331,7 +331,8 @@ class MockWebServer : ExternalResource(), Closeable {
    * @return the head of the request queue
    */
   @Throws(InterruptedException::class)
-  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? = requestQueue.poll(timeout, unit)
+  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? =
+      requestQueue.poll(timeout, unit)
 
   @JvmName("-deprecated_requestCount")
   @Deprecated(
@@ -593,11 +594,18 @@ class MockWebServer : ExternalResource(), Closeable {
       source: BufferedSource,
       sink: BufferedSink
     ): Boolean {
-      val request = readRequest(socket, source, sink, sequenceNumber) ?: return false
+      if (source.exhausted()) {
+        return false // No more requests on this socket.
+      }
 
+      val request = readRequest(socket, source, sink, sequenceNumber)
       atomicRequestCount.incrementAndGet()
       requestQueue.add(request)
 
+      if (request.failure != null) {
+        return false // Nothing to respond to.
+      }
+
       val response = dispatcher.dispatch(request)
       if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
         socket.close()
@@ -674,78 +682,80 @@ class MockWebServer : ExternalResource(), Closeable {
     source: BufferedSource,
     sink: BufferedSink,
     sequenceNumber: Int
-  ): RecordedRequest? {
-    val request: String
-    try {
-      request = source.readUtf8LineStrict()
-    } catch (streamIsClosed: IOException) {
-      return null // no request because we closed the stream
-    }
-
-    if (request.isEmpty()) {
-      return null // no request because the stream is exhausted
-    }
+  ): RecordedRequest {
+    var request = ""
     val headers = Headers.Builder()
     var contentLength = -1L
     var chunked = false
     var expectContinue = false
-    while (true) {
-      val header = source.readUtf8LineStrict()
-      if (header.isEmpty()) {
-        break
-      }
-      addHeaderLenient(headers, header)
-      val lowercaseHeader = header.toLowerCase(Locale.US)
-      if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
-        contentLength = header.substring(15).trim().toLong()
-      }
-      if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
-              18).trim() == "chunked") {
-        chunked = true
+    val requestBody = TruncatingBuffer(bodyLimit)
+    val chunkSizes = mutableListOf<Int>()
+    var failure: IOException? = null
+
+    try {
+      request = source.readUtf8LineStrict()
+      if (request.isEmpty()) {
+        throw ProtocolException("no request because the stream is exhausted")
       }
-      if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
-              7).trim().equals("100-continue", ignoreCase = true)) {
-        expectContinue = true
+
+      while (true) {
+        val header = source.readUtf8LineStrict()
+        if (header.isEmpty()) {
+          break
+        }
+        addHeaderLenient(headers, header)
+        val lowercaseHeader = header.toLowerCase(Locale.US)
+        if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
+          contentLength = header.substring(15).trim().toLong()
+        }
+        if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
+                18).trim() == "chunked") {
+          chunked = true
+        }
+        if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
+                7).trim().equals("100-continue", ignoreCase = true)) {
+          expectContinue = true
+        }
       }
-    }
 
-    val socketPolicy = dispatcher.peek().socketPolicy
-    if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
-      sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
-      sink.writeUtf8("Content-Length: 0\r\n")
-      sink.writeUtf8("\r\n")
-      sink.flush()
-    }
+      val socketPolicy = dispatcher.peek().socketPolicy
+      if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
+        sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
+        sink.writeUtf8("Content-Length: 0\r\n")
+        sink.writeUtf8("\r\n")
+        sink.flush()
+      }
 
-    var hasBody = false
-    val requestBody = TruncatingBuffer(bodyLimit)
-    val chunkSizes = mutableListOf<Int>()
-    val policy = dispatcher.peek()
-    if (contentLength != -1L) {
-      hasBody = contentLength > 0L
-      throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
-    } else if (chunked) {
-      hasBody = true
-      while (true) {
-        val chunkSize = source.readUtf8LineStrict().trim().toInt(16)
-        if (chunkSize == 0) {
+      var hasBody = false
+      val policy = dispatcher.peek()
+      if (contentLength != -1L) {
+        hasBody = contentLength > 0L
+        throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
+      } else if (chunked) {
+        hasBody = true
+        while (true) {
+          val chunkSize = source.readUtf8LineStrict().trim().toInt(16)
+          if (chunkSize == 0) {
+            readEmptyLine(source)
+            break
+          }
+          chunkSizes.add(chunkSize)
+          throttledTransfer(policy, socket, source,
+              requestBody.buffer(), chunkSize.toLong(), true)
           readEmptyLine(source)
-          break
         }
-        chunkSizes.add(chunkSize)
-        throttledTransfer(policy, socket, source,
-            requestBody.buffer(), chunkSize.toLong(), true)
-        readEmptyLine(source)
       }
-    }
 
-    val method = request.substringBefore(' ')
-    require(!hasBody || HttpMethod.permitsRequestBody(method)) {
-      "Request must not have a body: $request"
+      val method = request.substringBefore(' ')
+      require(!hasBody || HttpMethod.permitsRequestBody(method)) {
+        "Request must not have a body: $request"
+      }
+    } catch (e: IOException) {
+      failure = e
     }
 
     return RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket)
+        requestBody.buffer, sequenceNumber, socket, failure)
   }
 
   @Throws(IOException::class)
@@ -959,6 +969,9 @@ class MockWebServer : ExternalResource(), Closeable {
       val request = readRequest(stream)
       atomicRequestCount.incrementAndGet()
       requestQueue.add(request)
+      if (request.failure != null) {
+        return // Nothing to respond to.
+      }
 
       val response: MockResponse = dispatcher.dispatch(request)
 
@@ -1013,17 +1026,21 @@ class MockWebServer : ExternalResource(), Closeable {
       }
 
       val body = Buffer()
+      val requestLine = "$method $path HTTP/1.1"
+      var exception: IOException? = null
       if (readBody && !peek.isDuplex) {
-        val contentLengthString = headers["content-length"]
-        val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
-        throttledTransfer(peek, socket, stream.getSource().buffer(),
-            body, byteCount, true)
+        try {
+          val contentLengthString = headers["content-length"]
+          val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
+          throttledTransfer(peek, socket, stream.getSource().buffer(),
+              body, byteCount, true)
+        } catch (e: IOException) {
+          exception = e
+        }
       }
 
-      val requestLine = "$method $path HTTP/1.1"
-      val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
-      return RecordedRequest(requestLine, headers, chunkSizes, body.size, body,
-          sequenceNumber.getAndIncrement(), socket)
+      return RecordedRequest(requestLine, headers, emptyList(), body.size, body,
+          sequenceNumber.getAndIncrement(), socket, exception)
     }
 
     @Throws(IOException::class)
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
index 9b34b23203..1db64aa94a 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
@@ -29,7 +29,7 @@ import java.net.Socket
 import javax.net.ssl.SSLSocket
 
 /** An HTTP request that came into the mock web server. */
-class RecordedRequest(
+class RecordedRequest @JvmOverloads constructor(
   val requestLine: String,
 
   /** All headers. */
@@ -52,7 +52,13 @@ class RecordedRequest(
    * multiple requests, each request is assigned its own sequence number.
    */
   val sequenceNumber: Int,
-  socket: Socket
+  socket: Socket,
+
+  /**
+   * The failure MockWebServer recorded when attempting to decode this request. If, for example,
+   * the inbound request was truncated, this exception will be non-null.
+   */
+  val failure: IOException? = null
 ) {
   val method: String?
   val path: String?
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 2007278869..5f0f513740 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -1,7 +1,7 @@
 Logging Interceptor
 ===================
 
-An [OkHttp interceptor][1] which logs HTTP request and response data.
+An [OkHttp interceptor][interceptors] which logs HTTP request and response data.
 
 ```java
 HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
@@ -41,5 +41,4 @@ implementation("com.squareup.okhttp3:logging-interceptor:4.2.1")
 ```
 
 
-
- [1]: ../INTERCEPTORS.md
+[interceptors]: https://square.github.io/okhttp/interceptors/
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
index 933d986a1e..b4de378151 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -68,8 +68,8 @@ class OkHttpClientTestRule : TestRule {
 
   private fun ensureAllTaskQueuesIdle() {
     for (queue in TaskRunner.INSTANCE.activeQueues()) {
-      assertThat(queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(500L)))
-          .withFailMessage("Queue still active after 500ms")
+      assertThat(queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(1000L)))
+          .withFailMessage("Queue still active after 1000ms")
           .isTrue()
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
index 1100df057c..1a159374ca 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
@@ -56,8 +56,6 @@ abstract class Task(
   /** Undefined unless this is in [TaskQueue.futureTasks]. */
   internal var nextExecuteNanoTime = -1L
 
-  internal var runRunnable: Runnable? = null
-
   /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */
   abstract fun runOnce(): Long
 
@@ -66,19 +64,5 @@ abstract class Task(
 
     check(this.queue === null) { "task is in multiple queues" }
     this.queue = queue
-
-    this.runRunnable = Runnable {
-      val currentThread = Thread.currentThread()
-      val oldName = currentThread.name
-      currentThread.name = name
-
-      var delayNanos = -1L
-      try {
-        delayNanos = runOnce()
-      } finally {
-        queue.runCompleted(this, delayNanos)
-        currentThread.name = oldName
-      }
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
index 9925c58b95..148c4b91c6 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
@@ -28,22 +28,16 @@ import java.util.concurrent.TimeUnit
 class TaskQueue internal constructor(
   private val taskRunner: TaskRunner
 ) {
-  private var shutdown = false
+  internal var shutdown = false
 
   /** This queue's currently-executing task, or null if none is currently executing. */
-  private var activeTask: Task? = null
-
-  /** True if the [activeTask] should not recur when it completes. */
-  private var cancelActiveTask = false
+  internal var activeTask: Task? = null
 
   /** Scheduled tasks ordered by [Task.nextExecuteNanoTime]. */
-  private val futureTasks = mutableListOf<Task>()
-
-  internal fun isActive(): Boolean {
-    check(Thread.holdsLock(taskRunner))
+  internal val futureTasks = mutableListOf<Task>()
 
-    return activeTask != null || futureTasks.isNotEmpty()
-  }
+  /** True if the [activeTask] should be canceled when it completes. */
+  internal var cancelActiveTask = false
 
   /**
    * Returns a snapshot of tasks currently scheduled for execution. Does not include the
@@ -87,7 +81,7 @@ class TaskQueue internal constructor(
   fun awaitIdle(delayNanos: Long): Boolean {
     val latch = CountDownLatch(1)
 
-    val task = object : Task("awaitIdle") {
+    val task = object : Task("awaitIdle", cancelable = false) {
       override fun runOnce(): Long {
         latch.countDown()
         return -1L
@@ -104,8 +98,8 @@ class TaskQueue internal constructor(
     return latch.await(delayNanos, TimeUnit.NANOSECONDS)
   }
 
-  /** Adds [task] to run in [delayNanos]. Returns true if the coordinator should run. */
-  private fun scheduleAndDecide(task: Task, delayNanos: Long): Boolean {
+  /** Adds [task] to run in [delayNanos]. Returns true if the coordinator is impacted. */
+  internal fun scheduleAndDecide(task: Task, delayNanos: Long): Boolean {
     task.initQueue(this)
 
     val now = taskRunner.backend.nanoTime()
@@ -124,7 +118,7 @@ class TaskQueue internal constructor(
     if (insertAt == -1) insertAt = futureTasks.size
     futureTasks.add(insertAt, task)
 
-    // Run the coordinator if we inserted at the front.
+    // Impact the coordinator if we inserted at the front.
     return insertAt == 0
   }
 
@@ -154,8 +148,8 @@ class TaskQueue internal constructor(
     }
   }
 
-  /** Returns true if the coordinator should run. */
-  private fun cancelAllAndDecide(): Boolean {
+  /** Returns true if the coordinator is impacted. */
+  internal fun cancelAllAndDecide(): Boolean {
     if (activeTask != null && activeTask!!.cancelable) {
       cancelActiveTask = true
     }
@@ -169,43 +163,4 @@ class TaskQueue internal constructor(
     }
     return tasksCanceled
   }
-
-  /**
-   * Posts the next available task to an executor for immediate execution.
-   *
-   * Returns the delay until the next call to this method, -1L for no further calls, or
-   * [Long.MAX_VALUE] to wait indefinitely.
-   */
-  internal fun executeReadyTask(now: Long): Long {
-    check(Thread.holdsLock(taskRunner))
-
-    if (activeTask != null) return Long.MAX_VALUE // This queue is busy.
-
-    // Check if a task is immediately ready.
-    val runTask = futureTasks.firstOrNull() ?: return -1L
-    val delayNanos = runTask.nextExecuteNanoTime - now
-    if (delayNanos <= 0) {
-      activeTask = runTask
-      futureTasks.removeAt(0)
-      taskRunner.backend.executeTask(runTask.runRunnable!!)
-      return Long.MAX_VALUE // This queue is busy until the run completes.
-    }
-
-    // Wait until the next task is ready.
-    return delayNanos
-  }
-
-  internal fun runCompleted(task: Task, delayNanos: Long) {
-    synchronized(taskRunner) {
-      check(activeTask === task)
-
-      if (delayNanos != -1L && !cancelActiveTask && !shutdown) {
-        scheduleAndDecide(task, delayNanos)
-      }
-
-      activeTask = null
-      cancelActiveTask = false
-      taskRunner.kickCoordinator(this)
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
index 69c9ee2934..a14df066fa 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
@@ -18,7 +18,6 @@ package okhttp3.internal.concurrent
 import okhttp3.internal.addIfAbsent
 import okhttp3.internal.notify
 import okhttp3.internal.threadFactory
-import java.util.concurrent.LinkedBlockingQueue
 import java.util.concurrent.SynchronousQueue
 import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
@@ -38,104 +37,214 @@ import java.util.concurrent.TimeUnit
 class TaskRunner(
   val backend: Backend = RealBackend()
 ) {
-  // All state in all tasks and queues is guarded by this.
+  private var coordinatorWaiting = false
+  private var coordinatorWakeUpAt = 0L
 
-  private var coordinatorRunning = false
-  private val activeQueues = mutableListOf<TaskQueue>()
-  private val coordinator = Runnable { coordinate() }
+  /** Queues with tasks that are currently executing their [TaskQueue.activeTask]. */
+  private val busyQueues = mutableListOf<TaskQueue>()
 
-  fun newQueue() = TaskQueue(this)
+  /** Queues not in [busyQueues] that have non-empty [TaskQueue.futureTasks]. */
+  private val readyQueues = mutableListOf<TaskQueue>()
 
-  /**
-   * Returns a snapshot of queues that currently have tasks scheduled. The task runner does not
-   * necessarily track queues that have no tasks scheduled.
-   */
-  fun activeQueues(): List<TaskQueue> {
-    synchronized(this) {
-      return activeQueues.toList()
+  private val runnable: Runnable = object : Runnable {
+    override fun run() {
+      while (true) {
+        val task = synchronized(this@TaskRunner) {
+          awaitTaskToRun()
+        } ?: return
+
+        runTask(task)
+      }
     }
   }
 
-  internal fun kickCoordinator(queue: TaskQueue) {
+  internal fun kickCoordinator(taskQueue: TaskQueue) {
     check(Thread.holdsLock(this))
 
-    if (queue.isActive()) {
-      activeQueues.addIfAbsent(queue)
-    } else {
-      activeQueues.remove(queue)
+    if (taskQueue.activeTask == null) {
+      if (taskQueue.futureTasks.isNotEmpty()) {
+        readyQueues.addIfAbsent(taskQueue)
+      } else {
+        readyQueues.remove(taskQueue)
+      }
     }
 
-    if (coordinatorRunning) {
-      backend.coordinatorNotify(this)
+    if (coordinatorWaiting) {
+      backend.coordinatorNotify(this@TaskRunner)
     } else {
-      coordinatorRunning = true
-      backend.executeCoordinator(coordinator)
+      backend.execute(runnable)
     }
   }
 
-  private fun coordinate() {
-    synchronized(this) {
-      while (true) {
-        val now = backend.nanoTime()
-        val delayNanos = executeReadyTasks(now)
+  private fun beforeRun(task: Task) {
+    check(Thread.holdsLock(this))
 
-        if (delayNanos == -1L) {
-          coordinatorRunning = false
-          return
-        }
+    task.nextExecuteNanoTime = -1L
+    val queue = task.queue!!
+    queue.futureTasks.remove(task)
+    readyQueues.remove(queue)
+    queue.activeTask = task
+    busyQueues.add(queue)
+  }
 
-        try {
-          backend.coordinatorWait(this, delayNanos)
-        } catch (_: InterruptedException) {
-          // Will cause the coordinator to exit unless other tasks are scheduled!
-          cancelAll()
-        }
+  private fun runTask(task: Task) {
+    check(!Thread.holdsLock(this))
+
+    val currentThread = Thread.currentThread()
+    val oldName = currentThread.name
+    currentThread.name = task.name
+
+    var delayNanos = -1L
+    try {
+      delayNanos = task.runOnce()
+    } finally {
+      synchronized(this) {
+        afterRun(task, delayNanos)
       }
+      currentThread.name = oldName
+    }
+  }
+
+  private fun afterRun(task: Task, delayNanos: Long) {
+    check(Thread.holdsLock(this))
+
+    val queue = task.queue!!
+    check(queue.activeTask === task)
+
+    val cancelActiveTask = queue.cancelActiveTask
+    queue.cancelActiveTask = false
+    queue.activeTask = null
+    busyQueues.remove(queue)
+
+    if (delayNanos != -1L && !cancelActiveTask && !queue.shutdown) {
+      queue.scheduleAndDecide(task, delayNanos)
+    }
+
+    if (queue.futureTasks.isNotEmpty()) {
+      readyQueues.add(queue)
     }
   }
 
   /**
-   * Start executing the next available tasks for all queues.
-   *
-   * Returns the delay until the next call to this method, -1L for no further calls, or
-   * [Long.MAX_VALUE] to wait indefinitely.
+   * Returns an immediately-executable task for the calling thread to execute, sleeping as necessary
+   * until one is ready. If there are no ready queues, or if other threads have everything under
+   * control this will return null. If there is more than a single task ready to execute immediately
+   * this will launch another thread to handle that work.
    */
-  private fun executeReadyTasks(now: Long): Long {
-    var result = -1L
+  fun awaitTaskToRun(): Task? {
+    check(Thread.holdsLock(this))
+
+    while (true) {
+      if (readyQueues.isEmpty()) {
+        return null // Nothing to do.
+      }
+
+      val now = backend.nanoTime()
+      var minDelayNanos = Long.MAX_VALUE
+      var readyTask: Task? = null
+      var multipleReadyTasks = false
+
+      // Decide what to run. This loop's goal wants to:
+      //  * Find out what this thread should do (either run a task or sleep)
+      //  * Find out if there's enough work to start another thread.
+      eachQueue@ for (queue in readyQueues) {
+        val candidate = queue.futureTasks[0]
+        val candidateDelay = maxOf(0L, candidate.nextExecuteNanoTime - now)
 
-    for (queue in activeQueues) {
-      val delayNanos = queue.executeReadyTask(now)
-      if (delayNanos == -1L) continue
-      result = if (result == -1L) delayNanos else minOf(result, delayNanos)
+        when {
+          // Compute the delay of the soonest-executable task.
+          candidateDelay > 0L -> {
+            minDelayNanos = minOf(candidateDelay, minDelayNanos)
+            continue@eachQueue
+          }
+
+          // If we already have more than one task, that's enough work for now. Stop searching.
+          readyTask != null -> {
+            multipleReadyTasks = true
+            break@eachQueue
+          }
+
+          // We have a task to execute when we complete the loop.
+          else -> {
+            readyTask = candidate
+          }
+        }
+      }
+
+      // Implement the decision.
+      when {
+        // We have a task ready to go. Get ready.
+        readyTask != null -> {
+          beforeRun(readyTask)
+
+          // Also start another thread if there's more work or scheduling to do.
+          if (multipleReadyTasks || !coordinatorWaiting && readyQueues.isNotEmpty()) {
+            backend.execute(runnable)
+          }
+
+          return readyTask
+        }
+
+        // Notify the coordinator of a task that's coming up soon.
+        coordinatorWaiting -> {
+          if (minDelayNanos < coordinatorWakeUpAt - now) {
+            backend.coordinatorNotify(this@TaskRunner)
+          }
+          return null
+        }
+
+        // No other thread is coordinating. Become the coordinator!
+        else -> {
+          coordinatorWaiting = true
+          coordinatorWakeUpAt = now + minDelayNanos
+          try {
+            backend.coordinatorWait(this@TaskRunner, minDelayNanos)
+          } catch (_: InterruptedException) {
+            // Will cause all tasks to exit unless more are scheduled!
+            cancelAll()
+          } finally {
+            coordinatorWaiting = false
+          }
+        }
+      }
     }
+  }
+
+  fun newQueue() = TaskQueue(this)
 
-    return result
+  /**
+   * Returns a snapshot of queues that currently have tasks scheduled. The task runner does not
+   * necessarily track queues that have no tasks scheduled.
+   */
+  fun activeQueues(): List<TaskQueue> {
+    synchronized(this) {
+      return busyQueues + readyQueues
+    }
   }
 
   private fun cancelAll() {
-    for (i in activeQueues.size - 1 downTo 0) {
-      activeQueues[i].cancelAll()
+    for (i in busyQueues.size - 1 downTo 0) {
+      readyQueues[i].cancelAllAndDecide()
+    }
+    for (i in readyQueues.size - 1 downTo 0) {
+      val queue = readyQueues[i]
+      queue.cancelAllAndDecide()
+      if (queue.futureTasks.isEmpty()) {
+        readyQueues.removeAt(i)
+      }
     }
   }
 
   interface Backend {
-    fun executeCoordinator(runnable: Runnable)
-    fun executeTask(runnable: Runnable)
+    fun beforeTask(taskRunner: TaskRunner)
     fun nanoTime(): Long
     fun coordinatorNotify(taskRunner: TaskRunner)
     fun coordinatorWait(taskRunner: TaskRunner, nanos: Long)
+    fun execute(runnable: Runnable)
   }
 
   internal class RealBackend : Backend {
-    private val coordinatorExecutor = ThreadPoolExecutor(
-        0, // corePoolSize.
-        1, // maximumPoolSize.
-        60L, TimeUnit.SECONDS, // keepAliveTime.
-        LinkedBlockingQueue<Runnable>(),
-        threadFactory("OkHttp Task Coordinator", true)
-    )
-
-    private val taskExecutor = ThreadPoolExecutor(
+    private val executor = ThreadPoolExecutor(
         0, // corePoolSize.
         Int.MAX_VALUE, // maximumPoolSize.
         60L, TimeUnit.SECONDS, // keepAliveTime.
@@ -143,12 +252,7 @@ class TaskRunner(
         threadFactory("OkHttp Task", true)
     )
 
-    override fun executeCoordinator(runnable: Runnable) {
-      coordinatorExecutor.execute(runnable)
-    }
-
-    override fun executeTask(runnable: Runnable) {
-      taskExecutor.execute(runnable)
+    override fun beforeTask(taskRunner: TaskRunner) {
     }
 
     override fun nanoTime() = System.nanoTime()
@@ -171,9 +275,12 @@ class TaskRunner(
       }
     }
 
+    override fun execute(runnable: Runnable) {
+      executor.execute(runnable)
+    }
+
     fun shutdown() {
-      coordinatorExecutor.shutdown()
-      taskExecutor.shutdown()
+      executor.shutdown()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
index 243535415d..7dad0e67f2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
@@ -534,6 +534,7 @@ class Http2Stream internal constructor(
     @Throws(IOException::class)
     private fun emitFrame(outFinishedOnLastFrame: Boolean) {
       val toWrite: Long
+      val outFinished: Boolean
       synchronized(this@Http2Stream) {
         writeTimeout.enter()
         try {
@@ -550,11 +551,11 @@ class Http2Stream internal constructor(
         checkOutNotClosed() // Kick out if the stream was reset or closed while waiting.
         toWrite = minOf(writeBytesMaximum - writeBytesTotal, sendBuffer.size)
         writeBytesTotal += toWrite
+        outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size && errorCode == null
       }
 
       writeTimeout.enter()
       try {
-        val outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size
         connection.writeData(id, outFinished, sendBuffer, toWrite)
       } finally {
         writeTimeout.exitAndThrowIfTimedOut()
@@ -578,8 +579,11 @@ class Http2Stream internal constructor(
     @Throws(IOException::class)
     override fun close() {
       assert(!Thread.holdsLock(this@Http2Stream))
+
+      val outFinished: Boolean
       synchronized(this@Http2Stream) {
         if (closed) return
+        outFinished = errorCode == null
       }
       if (!sink.finished) {
         // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at
@@ -592,7 +596,7 @@ class Http2Stream internal constructor(
             while (sendBuffer.size > 0L) {
               emitFrame(false)
             }
-            connection.writeHeaders(id, true, trailers!!.toHeaderList())
+            connection.writeHeaders(id, outFinished, trailers!!.toHeaderList())
           }
 
           hasData -> {
@@ -601,7 +605,7 @@ class Http2Stream internal constructor(
             }
           }
 
-          else -> {
+          outFinished -> {
             connection.writeData(id, true, null, 0L)
           }
         }
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
index 9caa0072d4..3dd056314a 100644
--- a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
@@ -134,6 +134,9 @@ class CallKotlinTest {
     recordedRequest = server.takeRequest()
     assertEquals("HEAD", recordedRequest.method)
 
+    recordedRequest = server.takeRequest()
+    assertThat(recordedRequest.failure).isNotNull()
+
     recordedRequest = server.takeRequest()
     assertEquals("HEAD", recordedRequest.method)
   }
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index e6e8f0d9c2..db3fa52120 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -72,7 +72,6 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.Flaky;
 import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
@@ -2453,6 +2452,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       fail();
     } catch (IOException expected) {
     }
+
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
@@ -3789,12 +3790,15 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.flush(); // For determinism, always send a partial request to the server.
             throw new IOException("boom");
           }
         })
         .build();
 
     executeSynchronously(request).assertFailure("boom");
+
+    assertThat(server.takeRequest().getFailure()).isNotNull();
   }
 
   @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
@@ -3842,6 +3846,7 @@ private void makeFailingCall() {
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.flush(); // For determinism, always send a partial request to the server.
         throw new IOException("write body fail!");
       }
     };
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
index 29d9840b3c..2e3a960ba5 100644
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
@@ -18,71 +18,82 @@ package okhttp3.internal.concurrent
 import okhttp3.internal.notify
 import okhttp3.internal.wait
 import org.assertj.core.api.Assertions.assertThat
+import java.util.concurrent.Executors
 
 /**
  * Runs a [TaskRunner] in a controlled environment so that everything is sequential and
  * deterministic. All tasks are executed on-demand on the test thread by calls to [runTasks] and
  * [advanceUntil].
- *
- * The coordinator does run in a background thread. Its [TaskRunner.Backend.coordinatorNotify] and
- * [TaskRunner.Backend.coordinatorWait] calls don't use wall-clock time to avoid delays.
  */
 class TaskFaker {
-  /** Null unless there's a coordinator runnable that needs to be started. */
-  private var coordinatorToRun: Runnable? = null
+  /** Runnables scheduled for execution. These will execute tasks and perform scheduling. */
+  private val futureRunnables = mutableListOf<Runnable>()
 
-  /** Null unless there's a coordinator thread currently executing. */
-  private var coordinatorThread: Thread? = null
+  /** Runnables currently executing. */
+  private val currentRunnables = mutableListOf<Runnable>()
 
-  /** Tasks to be executed by the test thread. */
-  private val tasks = mutableListOf<Runnable>()
+  /**
+   * Executor service for the runnables above. This executor service should never have more than two
+   * active threads: one for a currently-executing task and one for a currently-sleeping task.
+   */
+  private val executorService = Executors.newCachedThreadPool()
 
-  /** How many tasks can be executed immediately. */
-  val tasksSize: Int get() = tasks.size
+  /** True if this task faker has ever had multiple tasks scheduled to run concurrently. */
+  var isParallel = false
 
   /** Guarded by [taskRunner]. */
   var nanoTime = 0L
     private set
 
-  /** Guarded by taskRunner. Time at which we should yield execution to the coordinator. */
-  private var coordinatorWaitingUntilTime = Long.MAX_VALUE
+  /** The thread currently waiting for time to advance. */
+  private var waitingThread: Thread? = null
+
+  /** Guarded by taskRunner. Time at which we should yield execution to a waiting runnable. */
+  private var waitingUntilTime = Long.MAX_VALUE
 
-  /** Total number of tasks executed. */
-  private var executedTaskCount = 0
+  /** Total number of runnables executed. */
+  private var executedRunnableCount = 0
 
-  /** Stall once we've executed this many tasks. */
+  /** Stall once we've executed this many runnables. */
   private var executedTaskLimit = Int.MAX_VALUE
 
   /** A task runner that posts tasks to this fake. Tasks won't be executed until requested. */
   val taskRunner: TaskRunner = TaskRunner(object : TaskRunner.Backend {
-    override fun executeCoordinator(runnable: Runnable) {
-      check(coordinatorToRun == null)
-      coordinatorToRun = runnable
+    override fun beforeTask(taskRunner: TaskRunner) {
+      check(Thread.holdsLock(taskRunner))
+      while (executedRunnableCount >= executedTaskLimit) {
+        coordinatorWait(taskRunner, Long.MAX_VALUE)
+      }
     }
 
-    override fun executeTask(runnable: Runnable) {
-      tasks += runnable
+    override fun execute(runnable: Runnable) {
+      futureRunnables.add(runnable)
     }
 
-    override fun nanoTime(): Long {
-      return nanoTime
-    }
+    override fun nanoTime() = nanoTime
 
     override fun coordinatorNotify(taskRunner: TaskRunner) {
       check(Thread.holdsLock(taskRunner))
-      coordinatorWaitingUntilTime = nanoTime
+      waitingUntilTime = nanoTime
     }
 
     override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
       check(Thread.holdsLock(taskRunner))
-
-      coordinatorWaitingUntilTime = if (nanos < Long.MAX_VALUE) nanoTime + nanos else Long.MAX_VALUE
-      if (nanoTime < coordinatorWaitingUntilTime) {
-        // Stall because there's no work to do.
-        taskRunner.notify()
-        taskRunner.wait()
+      check(waitingUntilTime == Long.MAX_VALUE)
+      check(waitingThread == null)
+
+      waitingThread = Thread.currentThread()
+      waitingUntilTime = if (nanos < Long.MAX_VALUE) nanoTime + nanos else Long.MAX_VALUE
+      try {
+        if (nanoTime < waitingUntilTime) {
+          // Stall because there's no work to do.
+          taskRunner.notify()
+          taskRunner.wait()
+        }
+      } finally {
+        waitingThread = null
+        waitingUntilTime = Long.MAX_VALUE
       }
-      coordinatorWaitingUntilTime = Long.MAX_VALUE
     }
   })
 
@@ -101,7 +112,7 @@ class TaskFaker {
       while (true) {
         runRunnables(taskRunner)
 
-        if (coordinatorWaitingUntilTime <= nanoTime) {
+        if (waitingUntilTime <= nanoTime) {
           // Let the coordinator do its business at the new time.
           taskRunner.notify()
           taskRunner.wait()
@@ -116,35 +127,28 @@ class TaskFaker {
   private fun runRunnables(taskRunner: TaskRunner) {
     check(Thread.holdsLock(taskRunner))
 
-    if (coordinatorToRun != null) {
-      coordinatorThread = object : Thread() {
-        val runnable = coordinatorToRun!!
-        override fun run() {
+    while (futureRunnables.isNotEmpty()) {
+      val runnable = futureRunnables.removeAt(0)
+      currentRunnables.add(runnable)
+      if (currentRunnables.size > 1) isParallel = true
+      executorService.execute(Runnable {
+        try {
           runnable.run()
+        } finally {
+          currentRunnables.remove(runnable)
           synchronized(taskRunner) {
-            coordinatorThread = null
-            coordinatorWaitingUntilTime = Long.MAX_VALUE
-            taskRunner.notify() // Release the waiting advanceUntil() or runRunnables() call.
+            taskRunner.notify()
           }
         }
-      }
-      coordinatorThread!!.start()
-      coordinatorToRun = null
+      })
       taskRunner.wait() // Wait for the coordinator to stall.
     }
-
-    while (tasks.isNotEmpty() && executedTaskCount < executedTaskLimit) {
-      val task = tasks.removeAt(0)
-      task.run()
-      executedTaskCount++
-    }
   }
 
   fun assertNoMoreTasks() {
-    assertThat(coordinatorToRun).isNull()
-    assertThat(tasks).isEmpty()
-    assertThat(coordinatorWaitingUntilTime)
-        .withFailMessage("tasks are scheduled to run at $coordinatorWaitingUntilTime")
+    assertThat(futureRunnables).isEmpty()
+    assertThat(waitingUntilTime)
+        .withFailMessage("tasks are scheduled to run at $waitingUntilTime")
         .isEqualTo(Long.MAX_VALUE)
   }
 
@@ -152,14 +156,15 @@ class TaskFaker {
     check(!Thread.holdsLock(taskRunner))
 
     synchronized(taskRunner) {
-      coordinatorThread!!.interrupt()
+      check(waitingThread != null) { "no thread currently waiting" }
+      waitingThread!!.interrupt()
       taskRunner.wait() // Wait for the coordinator to stall.
     }
   }
 
   /** Advances and runs up to one task. */
   fun runNextTask() {
-    executedTaskLimit = executedTaskCount + 1
+    executedTaskLimit = executedRunnableCount + 1
     try {
       advanceUntil(nanoTime)
     } finally {
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
index 59ab4ff5bb..f0dcf91656 100644
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
@@ -271,21 +271,21 @@ class TaskRunnerTest {
   @Test fun singleQueueIsSerial() {
     redQueue.schedule(object : Task("task one") {
       override fun runOnce(): Long {
-        log += "one:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
 
     redQueue.schedule(object : Task("task two") {
       override fun runOnce(): Long {
-        log += "two:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
 
     redQueue.schedule(object : Task("task three") {
       override fun runOnce(): Long {
-        log += "three:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
@@ -295,9 +295,9 @@ class TaskRunnerTest {
 
     taskFaker.advanceUntil(100L)
     assertThat(log).containsExactly(
-        "one:run@100 tasksSize=0",
-        "two:run@100 tasksSize=0",
-        "three:run@100 tasksSize=0"
+        "one:run@100 parallel=false",
+        "two:run@100 parallel=false",
+        "three:run@100 parallel=false"
     )
 
     taskFaker.assertNoMoreTasks()
@@ -307,21 +307,21 @@ class TaskRunnerTest {
   @Test fun differentQueuesAreParallel() {
     redQueue.schedule(object : Task("task one") {
       override fun runOnce(): Long {
-        log += "one:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
 
     blueQueue.schedule(object : Task("task two") {
       override fun runOnce(): Long {
-        log += "two:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
 
     greenQueue.schedule(object : Task("task three") {
       override fun runOnce(): Long {
-        log += "three:run@${taskFaker.nanoTime} tasksSize=${taskFaker.tasksSize}"
+        log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
         return -1L
       }
     }, 100L)
@@ -331,9 +331,9 @@ class TaskRunnerTest {
 
     taskFaker.advanceUntil(100L)
     assertThat(log).containsExactly(
-        "one:run@100 tasksSize=2",
-        "two:run@100 tasksSize=1",
-        "three:run@100 tasksSize=0"
+        "one:run@100 parallel=true",
+        "two:run@100 parallel=true",
+        "three:run@100 parallel=true"
     )
 
     taskFaker.assertNoMoreTasks()
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
index 5e63e64408..bd1a80d1ad 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -196,7 +196,7 @@
     Thread[] threads = new Thread[Thread.activeCount() * 2];
     Thread.enumerate(threads);
     for (Thread t: threads) {
-      if (t != null && t.getName().equals("OkHttp Task Coordinator")) {
+      if (t != null && t.getName().equals("OkHttp Task")) {
         t.interrupt();
       }
     }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 7a05f6b43d..43e665019d 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -30,8 +30,10 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Callback;
@@ -1620,4 +1622,33 @@ public void shutdownAfterLateCoalescing() throws Exception {
 
     latch.await();
   }
+
+  @Test public void cancelWhileWritingRequestBodySendsCancelToServer() throws Exception {
+    server.enqueue(new MockResponse());
+
+    AtomicReference<Call> callReference = new AtomicReference<>();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return MediaType.get("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) {
+            callReference.get().cancel();
+          }
+        })
+        .build());
+    callReference.set(call);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(call.isCanceled()).isTrue();
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getFailure()).hasMessage("stream was reset: CANCEL");
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 25a3c66d13..33d367f997 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -34,6 +34,7 @@
 import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.testing.PlatformRule;
@@ -257,6 +258,8 @@ public void setUp() {
     } catch (SocketException expected) {
       assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
           PlatformRule.CONSCRYPT_PROPERTY);
+    } catch (ConnectionShutdownException expected) {
+      // It didn't fail until it reached the application layer.
     }
   }
 
