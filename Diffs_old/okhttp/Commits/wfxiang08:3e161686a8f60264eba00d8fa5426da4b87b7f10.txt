diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 0d30547afb..d6f90bb3ac 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -138,11 +138,11 @@ synchronized void enqueue(AsyncCall call) {
    */
   public synchronized void cancelAll() {
     for (AsyncCall call : readyAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (AsyncCall call : runningAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (RealCall call : runningSyncCalls) {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 778ab8019b..40f72331e2 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -111,7 +111,7 @@
       }
 
       @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
-        return ((RealCall) call).engine.streamAllocation;
+        return ((RealCall) call).streamAllocation();
       }
 
       @Override
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index c2a6a7653b..f7a335f2a6 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,36 +16,31 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.net.HttpRetryException;
-import java.net.ProtocolException;
 import java.util.ArrayList;
 import java.util.List;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Platform;
-import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.CallServerInterceptor;
 import okhttp3.internal.http.RealInterceptorChain;
-import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.http.UnrepeatableRequestBody;
 
 import static okhttp3.internal.Platform.INFO;
-import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
 final class RealCall implements Call {
   private final OkHttpClient client;
+  private final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
 
   // Guarded by this.
   private boolean executed;
-  volatile boolean canceled;
-  private boolean forWebSocket;
 
   /** The application's original request unadulterated by redirects or auth headers. */
   Request originalRequest;
-  HttpEngine engine;
 
   protected RealCall(OkHttpClient client, Request originalRequest) {
     this.client = client;
     this.originalRequest = originalRequest;
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
   }
 
   @Override public Request request() {
@@ -69,7 +64,7 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
 
   synchronized void setForWebSocket() {
     if (executed) throw new IllegalStateException("Already Executed");
-    this.forWebSocket = true;
+    this.retryAndFollowUpInterceptor.setForWebSocket(true);
   }
 
   @Override public void enqueue(Callback responseCallback) {
@@ -81,8 +76,7 @@ synchronized void setForWebSocket() {
   }
 
   @Override public void cancel() {
-    canceled = true;
-    if (engine != null) engine.cancel();
+    retryAndFollowUpInterceptor.cancel();
   }
 
   @Override public synchronized boolean isExecuted() {
@@ -90,7 +84,11 @@ synchronized void setForWebSocket() {
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    return retryAndFollowUpInterceptor.isCanceled();
+  }
+
+  StreamAllocation streamAllocation() {
+    return retryAndFollowUpInterceptor.streamAllocation();
   }
 
   final class AsyncCall extends NamedRunnable {
@@ -109,10 +107,6 @@ Request request() {
       return originalRequest;
     }
 
-    void cancel() {
-      RealCall.this.cancel();
-    }
-
     RealCall get() {
       return RealCall.this;
     }
@@ -121,7 +115,7 @@ RealCall get() {
       boolean signalledCallback = false;
       try {
         Response response = getResponseWithInterceptorChain();
-        if (canceled) {
+        if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
@@ -146,7 +140,7 @@ RealCall get() {
    * sensitive information.
    */
   private String toLoggableString() {
-    String string = canceled ? "canceled call" : "call";
+    String string = retryAndFollowUpInterceptor.isCanceled() ? "canceled call" : "call";
     return string + " to " + redactedUrl();
   }
 
@@ -158,123 +152,15 @@ private Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
-    interceptors.add(new RetryAndFollowUpInterceptor());
-    if (!forWebSocket) {
+    interceptors.add(retryAndFollowUpInterceptor);
+    if (!retryAndFollowUpInterceptor.isForWebSocket()) {
       interceptors.addAll(client.networkInterceptors());
     }
-    interceptors.add(new HttpEngine.CallServerInterceptor(forWebSocket));
+    interceptors.add(new CallServerInterceptor(
+        retryAndFollowUpInterceptor.isForWebSocket()));
 
     Interceptor.Chain chain = new RealInterceptorChain(
         interceptors, null, null, null, 0, originalRequest);
     return chain.proceed(originalRequest);
   }
-
-  /**
-   * Performs the request and returns the response. May throw if this call was canceled. This isn't
-   * a regular interceptor because it doesn't delegate to the chain.
-   */
-  class RetryAndFollowUpInterceptor implements Interceptor {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-
-      // Copy body metadata to the appropriate request headers.
-      RequestBody body = request.body();
-      if (body != null) {
-        Request.Builder requestBuilder = request.newBuilder();
-
-        MediaType contentType = body.contentType();
-        if (contentType != null) {
-          requestBuilder.header("Content-Type", contentType.toString());
-        }
-
-        long contentLength = body.contentLength();
-        if (contentLength != -1) {
-          requestBuilder.header("Content-Length", Long.toString(contentLength));
-          requestBuilder.removeHeader("Transfer-Encoding");
-        } else {
-          requestBuilder.header("Transfer-Encoding", "chunked");
-          requestBuilder.removeHeader("Content-Length");
-        }
-
-        request = requestBuilder.build();
-      }
-
-      // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-      engine = new HttpEngine(client, request.url(), forWebSocket, null, null);
-
-      int followUpCount = 0;
-      while (true) {
-        if (canceled) {
-          engine.releaseStreamAllocation();
-          throw new IOException("Canceled");
-        }
-
-        Response response = null;
-        boolean releaseConnection = true;
-        try {
-          response = engine.proceed(request, (RealInterceptorChain) chain);
-          releaseConnection = false;
-        } catch (RouteException e) {
-          // The attempt to connect via a route failed. The request will not have been sent.
-          HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, request);
-          if (retryEngine != null) {
-            releaseConnection = false;
-            engine = retryEngine;
-            continue;
-          }
-          // Give up; recovery is not possible.
-          throw e.getLastConnectException();
-        } catch (IOException e) {
-          // An attempt to communicate with a server failed. The request may have been sent.
-          HttpEngine retryEngine = engine.recover(e, false, request);
-          if (retryEngine != null) {
-            releaseConnection = false;
-            engine = retryEngine;
-            continue;
-          }
-
-          // Give up; recovery is not possible.
-          throw e;
-        } finally {
-          // We're throwing an unchecked exception. Release any resources.
-          if (releaseConnection) {
-            StreamAllocation streamAllocation = engine.close(null);
-            streamAllocation.release();
-          }
-        }
-
-        Request followUp = engine.followUpRequest(response);
-
-        if (followUp == null) {
-          if (!forWebSocket) {
-            engine.releaseStreamAllocation();
-          }
-          return response;
-        }
-
-        StreamAllocation streamAllocation = engine.close(response);
-
-        if (++followUpCount > MAX_FOLLOW_UPS) {
-          streamAllocation.release();
-          throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-        }
-
-        if (followUp.body() instanceof UnrepeatableRequestBody) {
-          throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-        }
-
-        if (!engine.sameConnection(response, followUp.url())) {
-          streamAllocation.release();
-          streamAllocation = null;
-        } else if (streamAllocation.stream() != null) {
-          throw new IllegalStateException("Closing the body of " + response
-              + " didn't close its backing stream. Bad interceptor?");
-        }
-
-        request = followUp;
-        engine = new HttpEngine(client, request.url(), forWebSocket, streamAllocation,
-            response);
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
new file mode 100644
index 0000000000..9a3f33ad13
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Sink;
+
+/** This is the last interceptor in the chain. It makes a network call to the server. */
+public final class CallServerInterceptor implements Interceptor {
+  private final boolean forWebSocket;
+
+  public CallServerInterceptor(boolean forWebSocket) {
+    this.forWebSocket = forWebSocket;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    HttpStream httpStream = ((RealInterceptorChain) chain).httpStream();
+    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
+    Request request = chain.request();
+
+    long sentRequestMillis = System.currentTimeMillis();
+    httpStream.writeRequestHeaders(request);
+
+    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+      Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
+      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+      request.body().writeTo(bufferedRequestBody);
+      bufferedRequestBody.close();
+    }
+
+    httpStream.finishRequest();
+
+    Response response = httpStream.readResponseHeaders()
+        .request(request)
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
+
+    if (!forWebSocket || response.code() != 101) {
+      response = response.newBuilder()
+          .body(httpStream.openResponseBody(response))
+          .build();
+    }
+
+    if ("close".equalsIgnoreCase(response.request().header("Connection"))
+        || "close".equalsIgnoreCase(response.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
+    int code = response.code();
+    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+      throw new ProtocolException(
+          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+    }
+
+    return response;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index e351a4d6dc..b142b8c3bb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -116,7 +116,7 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
     String requestLine = RequestLine.get(
-        request, httpEngine.getConnection().route().proxy().type());
+        request, streamAllocation.connection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 273eda726f..63fe466f7c 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -17,32 +17,22 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketTimeoutException;
-import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
-import okhttp3.Connection;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.Route;
 import okhttp3.internal.Internal;
 import okhttp3.internal.InternalCache;
 import okhttp3.internal.Version;
@@ -55,22 +45,13 @@
 import okio.Source;
 import okio.Timeout;
 
-import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 import static okhttp3.internal.Util.hostHeader;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
  * Handles a single HTTP request/response pair. The request and response may be served by the HTTP
@@ -98,10 +79,8 @@
   };
 
   final OkHttpClient client;
-
-  public final StreamAllocation streamAllocation;
-  private final Response priorResponse;
-  private HttpStream httpStream;
+  final StreamAllocation streamAllocation;
+  final Response priorResponse;
 
   /**
    * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
@@ -110,15 +89,12 @@
   private boolean transparentGzip;
 
   /** The original application-provided request URL. Never modified by OkHttp. */
-  private final HttpUrl userRequestUrl;
-
-  private final boolean forWebSocket;
+  final HttpUrl userRequestUrl;
 
-  public HttpEngine(OkHttpClient client, HttpUrl userRequestUrl,
-      boolean forWebSocket, StreamAllocation streamAllocation, Response priorResponse) {
+  public HttpEngine(OkHttpClient client, HttpUrl userRequestUrl, StreamAllocation streamAllocation,
+      Response priorResponse) {
     this.client = client;
     this.userRequestUrl = userRequestUrl;
-    this.forWebSocket = forWebSocket;
     this.streamAllocation = streamAllocation != null
         ? streamAllocation
         : new StreamAllocation(client.connectionPool(), createAddress(client, userRequestUrl));
@@ -130,13 +106,10 @@ public HttpEngine(OkHttpClient client, HttpUrl userRequestUrl,
    * Prepares the request headers and gets ready to start writing the request body if it exists.
    *
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   * recoverable. See {@link #recover}.
-   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   * {@link #recover}.
+   *     recoverable.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable.
    */
   public Response proceed(Request userRequest, RealInterceptorChain chain) throws IOException {
-    if (httpStream != null) throw new IllegalStateException();
-
     Request request = networkRequest(userRequest);
 
     InternalCache responseCache = Internal.instance.internalCache(client);
@@ -183,14 +156,13 @@ public Response proceed(Request userRequest, RealInterceptorChain chain) throws
     }
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean success = false;
+    HttpStream httpStream = null;
     try {
       httpStream = connect(networkRequest);
       httpStream.setHttpEngine(this);
-      success = true;
     } finally {
       // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (!success && cacheCandidate != null) {
+      if (httpStream == null && cacheCandidate != null) {
         closeQuietly(cacheCandidate.body());
       }
     }
@@ -211,7 +183,7 @@ public Response proceed(Request userRequest, RealInterceptorChain chain) throws
             .networkResponse(stripBody(networkResponse))
             .build();
         networkResponse.body().close();
-        releaseStreamAllocation();
+        streamAllocation.release();
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
@@ -252,72 +224,6 @@ private static Response stripBody(Response response) {
         : response;
   }
 
-  public Connection getConnection() {
-    return streamAllocation.connection();
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
-   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
-   * permanent. Requests with a body can only be recovered if the body is buffered.
-   */
-  public HttpEngine recover(IOException e, boolean routeException, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
-    if (!client.retryOnConnectionFailure()) {
-      return null; // The application layer has forbidden retries.
-    }
-
-    if (!routeException && userRequest.body() instanceof UnrepeatableRequestBody) {
-      return null; // We can't send the request body again.
-    }
-
-    if (!isRecoverable(e, routeException)) {
-      return null; // This exception is fatal.
-    }
-
-    if (!streamAllocation.hasMoreRoutes()) {
-      return null; // No more routes to attempt.
-    }
-
-    StreamAllocation streamAllocation = close(null);
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequestUrl, forWebSocket, streamAllocation, priorResponse);
-  }
-
-  private boolean isRecoverable(IOException e, boolean routeException) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && routeException;
-    }
-
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
   private CacheRequest maybeCache(Response userResponse, Request networkRequest,
       InternalCache responseCache) throws IOException {
     if (responseCache == null) return null;
@@ -338,27 +244,6 @@ private CacheRequest maybeCache(Response userResponse, Request networkRequest,
     return responseCache.put(userResponse);
   }
 
-  /**
-   * Configure the socket connection to be either pooled or closed when it is either exhausted or
-   * closed. If it is unneeded when this is called, it will be released immediately.
-   */
-  public void releaseStreamAllocation() throws IOException {
-    streamAllocation.release();
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held by this engine. Use this to
-   * interrupt an in-flight request from any thread. It's the caller's responsibility to close the
-   * request body and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    streamAllocation.cancel();
-  }
-
   /**
    * Release any resources held by this engine. Returns the stream allocation held by this engine,
    * which itself must be used or released.
@@ -387,7 +272,7 @@ public StreamAllocation close(Response userResponse) {
    * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
    * attempt to decompress the zero-byte source.
    */
-  private Response unzip(final Response response) throws IOException {
+  private Response unzip(Response response) throws IOException {
     if (!transparentGzip || !"gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
       return response;
     }
@@ -481,68 +366,6 @@ private String cookieHeader(List<Cookie> cookies) {
     return cookieHeader.toString();
   }
 
-  public static class CallServerInterceptor implements Interceptor {
-    private final boolean forWebSocket;
-
-    /** The time when the request headers were written, or -1 if they haven't been written yet. */
-    long sentRequestMillis = -1;
-
-    public CallServerInterceptor(boolean forWebSocket) {
-      this.forWebSocket = forWebSocket;
-    }
-
-    @Override public Response intercept(Chain chain) throws IOException {
-      HttpStream httpStream = ((RealInterceptorChain) chain).httpStream();
-      StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
-
-      Request request = chain.request();
-      sentRequestMillis = System.currentTimeMillis();
-      httpStream.writeRequestHeaders(request);
-
-      if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-        Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
-
-      Response response = readNetworkResponse(httpStream, streamAllocation, request);
-
-      int code = response.code();
-      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-        throw new ProtocolException(
-            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-      }
-
-      return response;
-    }
-
-    private Response readNetworkResponse(HttpStream httpStream, StreamAllocation streamAllocation,
-        Request networkRequest) throws IOException {
-      httpStream.finishRequest();
-
-      Response networkResponse = httpStream.readResponseHeaders()
-          .request(networkRequest)
-          .handshake(streamAllocation.connection().handshake())
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-
-      if (!forWebSocket || networkResponse.code() != 101) {
-        networkResponse = networkResponse.newBuilder()
-            .body(httpStream.openResponseBody(networkResponse))
-            .build();
-      }
-
-      if ("close".equalsIgnoreCase(networkResponse.request().header("Connection"))
-          || "close".equalsIgnoreCase(networkResponse.header("Connection"))) {
-        streamAllocation.noNewStreams();
-      }
-
-      return networkResponse;
-    }
-  }
-
   /**
    * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
    * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
@@ -668,107 +491,6 @@ public void receiveHeaders(Headers headers) throws IOException {
     client.cookieJar().saveFromResponse(userRequestUrl, cookies);
   }
 
-  /**
-   * Figures out the HTTP request to make in response to receiving this engine's response. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  public Request followUpRequest(Response userResponse) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
-
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            requestBuilder.method(method, null);
-          }
-          requestBuilder.removeHeader("Transfer-Encoding");
-          requestBuilder.removeHeader("Content-Length");
-          requestBuilder.removeHeader("Content-Type");
-        }
-
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse, url)) {
-          requestBuilder.removeHeader("Authorization");
-        }
-
-        return requestBuilder.url(url).build();
-
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
-          return null;
-        }
-
-        return userResponse.request();
-
-      default:
-        return null;
-    }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  public boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
-
   private static Address createAddress(OkHttpClient client, HttpUrl url) {
     SSLSocketFactory sslSocketFactory = null;
     HostnameVerifier hostnameVerifier = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
new file mode 100644
index 0000000000..cf35770482
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpRetryException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketTimeoutException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Connection;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+
+/**
+ * This interceptor recovers from failures and follows redirects as necessary. It may throw an
+ * {@link IOException} if the call was canceled.
+ */
+public final class RetryAndFollowUpInterceptor implements Interceptor {
+  private final OkHttpClient client;
+  private HttpEngine engine;
+  private boolean forWebSocket;
+  private volatile boolean canceled;
+
+  public RetryAndFollowUpInterceptor(OkHttpClient client) {
+    this.client = client;
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    canceled = true;
+    HttpEngine engine = this.engine;
+    if (engine != null) engine.streamAllocation.cancel();
+  }
+
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public void setForWebSocket(boolean forWebSocket) {
+    this.forWebSocket = forWebSocket;
+  }
+
+  public boolean isForWebSocket() {
+    return forWebSocket;
+  }
+
+  public StreamAllocation streamAllocation() {
+    return engine.streamAllocation;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+
+    // Copy body metadata to the appropriate request headers.
+    RequestBody body = request.body();
+    if (body != null) {
+      Request.Builder requestBuilder = request.newBuilder();
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request.url(), null, null);
+
+    int followUpCount = 0;
+    while (true) {
+      if (canceled) {
+        engine.streamAllocation.release();
+        throw new IOException("Canceled");
+      }
+
+      Response response = null;
+      boolean releaseConnection = true;
+      try {
+        response = engine.proceed(request, (RealInterceptorChain) chain);
+        releaseConnection = false;
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = recover(e.getLastConnectException(), true, request);
+        if (retryEngine != null) {
+          releaseConnection = false;
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
+      } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
+        HttpEngine retryEngine = recover(e, false, request);
+        if (retryEngine != null) {
+          releaseConnection = false;
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          StreamAllocation streamAllocation = engine.close(null);
+          streamAllocation.release();
+        }
+      }
+
+      Request followUp = followUpRequest(response);
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          engine.streamAllocation.release();
+        }
+        return response;
+      }
+
+      StreamAllocation streamAllocation = engine.close(response);
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (followUp.body() instanceof UnrepeatableRequestBody) {
+        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      }
+
+      if (!sameConnection(response, followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = null;
+      } else if (streamAllocation.stream() != null) {
+        throw new IllegalStateException("Closing the body of " + response
+            + " didn't close its backing stream. Bad interceptor?");
+      }
+
+      request = followUp;
+      engine = new HttpEngine(client, request.url(), streamAllocation, response);
+    }
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
+   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
+   * permanent. Requests with a body can only be recovered if the body is buffered.
+   */
+  private HttpEngine recover(IOException e, boolean routeException, Request userRequest) {
+    engine.streamAllocation.streamFailed(e);
+
+    if (!client.retryOnConnectionFailure()) {
+      return null; // The application layer has forbidden retries.
+    }
+
+    if (!routeException && userRequest.body() instanceof UnrepeatableRequestBody) {
+      return null; // We can't send the request body again.
+    }
+
+    if (!isRecoverable(e, routeException)) {
+      return null; // This exception is fatal.
+    }
+
+    if (!engine.streamAllocation.hasMoreRoutes()) {
+      return null; // No more routes to attempt.
+    }
+
+    StreamAllocation streamAllocation = engine.close(null);
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, engine.userRequestUrl, streamAllocation, engine.priorResponse);
+  }
+
+  private boolean isRecoverable(IOException e, boolean routeException) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && routeException;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
+   */
+  private Request followUpRequest(Response userResponse) throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Connection connection = engine.streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
+    int responseCode = userResponse.code();
+
+    final String method = userResponse.request().method();
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
+      case HTTP_UNAUTHORIZED:
+        return client.authenticator().authenticate(route, userResponse);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.followRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        HttpUrl url = userResponse.request().url().resolve(location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (url == null) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
+
+        // Redirects don't include a request body.
+        Request.Builder requestBuilder = userResponse.request().newBuilder();
+        if (HttpMethod.permitsRequestBody(method)) {
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            requestBuilder.method(method, null);
+          }
+          requestBuilder.removeHeader("Transfer-Encoding");
+          requestBuilder.removeHeader("Content-Length");
+          requestBuilder.removeHeader("Content-Type");
+        }
+
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(userResponse, url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
+        return requestBuilder.url(url).build();
+
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+          return null;
+        }
+
+        return userResponse.request();
+
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
+   */
+  private boolean sameConnection(Response response, HttpUrl followUp) {
+    HttpUrl url = response.request().url();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
+  }
+}
