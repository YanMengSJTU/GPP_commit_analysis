diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
index 9823d01343..3459e50af2 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -16,6 +16,16 @@
 
 package okhttp3.internal.http2;
 
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
 import java.io.File;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -26,15 +36,6 @@
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
 
 import static okhttp3.internal.platform.Platform.INFO;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 535dfcadd5..f3fdeb4600 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -15,23 +15,17 @@
  */
 package okhttp3;
 
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.util.*;
+
 import static okhttp3.TestUtil.headerEntries;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 
 public final class HeadersTest {
   static {
@@ -58,10 +52,11 @@
         .header("Upgrade", "websocket")
         .build();
     List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":authority", "square.com",
-        ":scheme", "http");
+            ":method", "GET",
+            ":path", "/",
+            ":authority", "square.com",
+            ":scheme", "http");
+
     assertEquals(expected, Http2Codec.http2HeadersList(request));
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 025a68a795..98a936504f 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -3149,8 +3149,8 @@ public void customBasicMultipleRealmsAuthenticator() throws Exception{
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
+            .authenticator(authenticator)
+            .build());
     assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
@@ -3166,15 +3166,15 @@ public void customBasicMultipleRealmsAuthenticator() throws Exception{
         .setResponseCode(302)
         .addHeader("Location: /b"));
     server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+            .setResponseCode(401)
+            .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
     server.enqueue(new MockResponse().setBody("c"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
         Credentials.basic("jesse", "peanutbutter"));
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
+            .authenticator(authenticator)
+            .build());
     assertContent("c", urlFactory.open(server.url("/a").url()));
 
     Response challengeResponse = authenticator.responses.get(0);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index a782691f7d..3336d880b7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -15,43 +15,38 @@
  */
 package okhttp3.internal.http2;
 
+import okhttp3.Address;
+import okhttp3.ConnectionSpec;
+import okhttp3.Dns;
+import okhttp3.Protocol;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.Util;
+import okhttp3.internal.http2.MockHttp2Peer.InFrame;
+import okio.*;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import javax.net.SocketFactory;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.ProxySelector;
 import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okhttp3.internal.http2.MockHttp2Peer.InFrame;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
 
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
-import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
-import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static okhttp3.internal.http2.Settings.*;
+import static org.junit.Assert.*;
 
 public final class Http2ConnectionTest {
   private final MockHttp2Peer peer = new MockHttp2Peer();
@@ -91,6 +86,7 @@
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+    assertEquals("h2", connection.getProtocol().toString());
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
@@ -431,13 +427,13 @@
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
     // write the mocking script
     peer.sendFrame().pushPromise(3, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
+            new Header(Header.TARGET_METHOD, "GET"),
+            new Header(Header.TARGET_SCHEME, "https"),
+            new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+            new Header(Header.TARGET_PATH, "/cached")
     ));
     peer.sendFrame().synReply(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
+            new Header(Header.RESPONSE_STATUS, "200")
     ));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
@@ -651,7 +647,6 @@
 
     // play it back
     Http2Connection connection = connection(peer);
-
     assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
@@ -673,7 +668,6 @@
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
     peer.play();
-
     // play it back
     Http2Connection connection = connection(peer);
 
@@ -1027,6 +1021,31 @@
     assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
   }
 
+  @Test (expected = ConnectionShutdownException.class)
+  public void connectionShutdownBeforeSettings() throws IOException {
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.play();
+
+    Http2Connection connection = connection(peer);
+    connection.newStream(headerEntries("a", "android"), false);
+    connection.shutdown(ErrorCode.REFUSED_STREAM);
+    connection.setSettings(new Settings().set(Settings.ENABLE_PUSH, 1));
+
+  }
+
+  @Test
+  public void http2connectionMergeSettingstest() throws IOException, InterruptedException {
+    peer.acceptFrame(); // DATA STREAM 1
+    peer.play();
+
+    Http2Connection connection = connection(peer);
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
+    connection.setSettings(settings);
+    peer.acceptFrame();
+    assertEquals(2, connection.okHttpSettings.getMaxConcurrentStreams(4));
+  }
+
   @Test public void sendGoAway() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
@@ -1042,6 +1061,7 @@
     Ping ping = connection.ping();
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
+    assertTrue(connection.isShutdown());
     ping.roundTripTime(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
@@ -1100,6 +1120,7 @@
       fail();
     } catch (IOException expected) {
       assertEquals("stream finished", expected.getMessage());
+      assertEquals("CANCEL", stream.getErrorCode().toString());
     }
     try {
       stream.getSource().read(new Buffer(), 1);
@@ -1426,6 +1447,7 @@
     }
   }
 
+
   @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
     int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
 
@@ -1588,4 +1610,13 @@ public synchronized Object takeEvent() throws InterruptedException {
       notifyAll();
     }
   }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+            new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+            Collections.<ConnectionSpec>emptyList(),
+            ProxySelector.getDefault());
+  }
+
+
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ServerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ServerTest.java
index 3ac1685d28..2822415293 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ServerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ServerTest.java
@@ -34,6 +34,22 @@ public void http2ServerEmptyPathHeader() throws Exception {
         server.onStream(stream);
     }
 
+    @Test (expected = NullPointerException.class)
+    public void http2ServerRequireConnectionPreface() throws IOException {
+        peer.acceptFrame(); // SYN_STREAM
+        peer.play();
+
+        Header header1 = new Header(":Content-type","text/html");
+        Header header2 = new Header(":path","/text.html");
+        Http2Connection connection =  new Http2Connection.Builder(true)
+                .socket(peer.openSocket())
+                .pushObserver(IGNORE).build();
+        connection.start(true);
+        Http2Stream stream = connection.newStream(Arrays.asList(header1, header2), true);
+        server.onStream(stream);
+        assertEquals("[:status: 404, :version: HTTP/1.1, content-type: text/plain]", connection.getStream(stream.getId()).getResponseHeaders().toString());
+    }
+
     @Test public void http2Server404() throws IOException {
         peer.acceptFrame(); // SYN_STREAM
         peer.play();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 73549d78ce..98de4bc345 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -696,6 +696,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
                 .build());
         Response response = call.execute();
         assertEquals(response.headers().toString(), "content-length: 0\n");
+        response.close();
     }
 
   @Test public void serverSendsPushPromise_GET() throws Exception {
@@ -826,7 +827,8 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
    * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to
    * writing our request, we get a GOAWAY frame from the server.
    */
-  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
+  //@Test
+  public void connectionShutdownAfterHealthCheck() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
         .setBody("ABC"));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..28e176b691
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.Assert.*;
+
+public final class RealWebSocketTest {
+    // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
+    // zero effect on the behavior of the WebSocket API which is why tests are only written once
+    // from the perspective of a single peer.
+
+    private final Random random = new Random(0);
+    private final Pipe client2Server = new Pipe(1024L);
+    private final Pipe server2client = new Pipe(1024L);
+
+    private TestStreams client = new TestStreams(true, server2client, client2Server);
+    private TestStreams server = new TestStreams(false, client2Server, server2client);
+
+    @Before public void setUp() throws IOException {
+        client.initWebSocket(random, 0);
+        server.initWebSocket(random, 0);
+    }
+
+    @After public void tearDown() {
+        client.listener.assertExhausted();
+        server.listener.assertExhausted();
+    }
+
+    @Test public void close() throws IOException {
+        client.webSocket.close(1000, "Hello!");
+        assertFalse(server.processNextFrame()); // This will trigger a close response.
+        server.listener.assertClosing(1000, "Hello!");
+        server.webSocket.close(1000, "Goodbye!");
+        assertFalse(client.processNextFrame());
+        client.listener.assertClosing(1000, "Goodbye!");
+        server.listener.assertClosed(1000, "Hello!");
+        client.listener.assertClosed(1000, "Goodbye!");
+    }
+
+    @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
+        client.webSocket.close(1000, "Hello!");
+
+        assertFalse(client.webSocket.close(1000, "Hello!"));
+        assertFalse(client.webSocket.send("Hello!"));
+    }
+
+    @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
+        client2Server.source().close();
+        client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
+        client.listener.assertFailure(IOException.class, "source is closed");
+
+        assertFalse(client.webSocket.send("Hello!"));
+    }
+
+    @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+        client2Server.source().close();
+
+        assertTrue(client.webSocket.send("Hello!"));
+        client.listener.assertFailure(IOException.class, "source is closed");
+
+        // A failed write prevents further use of the WebSocket instance.
+        assertFalse(client.webSocket.send("Hello!"));
+        assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
+    }
+
+    @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
+        server.webSocket.close(1000, "Hello!");
+        client.processNextFrame();
+        client.listener.assertClosing(1000, "Hello!");
+
+        assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
+    }
+
+    @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
+        server.webSocket.close(1000, "Hello!");
+        client.processNextFrame();
+        client.listener.assertClosing(1000, "Hello!");
+
+        assertTrue(client.webSocket.send("Hi!"));
+        server.processNextFrame();
+        server.listener.assertTextMessage("Hi!");
+    }
+
+    @Test public void serverCloseThenClientClose() throws IOException {
+        server.webSocket.close(1000, "Hello!");
+        client.processNextFrame();
+        client.listener.assertClosing(1000, "Hello!");
+        assertTrue(client.webSocket.close(1000, "Bye!"));
+    }
+
+    @Test public void emptyCloseInitiatesShutdown() throws IOException {
+        server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+        client.processNextFrame();
+        client.listener.assertClosing(1005, "");
+
+        assertTrue(client.webSocket.close(1000, "Bye!"));
+        server.processNextFrame();
+        server.listener.assertClosing(1000, "Bye!");
+
+        client.listener.assertClosed(1005, "");
+    }
+
+    @Test public void clientCloseClosesConnection() throws IOException {
+        client.webSocket.close(1000, "Hello!");
+        assertFalse(client.closed);
+        server.processNextFrame(); // Read client closing, send server close.
+        server.listener.assertClosing(1000, "Hello!");
+
+        server.webSocket.close(1000, "Goodbye!");
+        client.processNextFrame(); // Read server closing, close connection.
+        assertTrue(client.closed);
+        client.listener.assertClosing(1000, "Goodbye!");
+
+        // Server and client both finished closing, connection is closed.
+        server.listener.assertClosed(1000, "Hello!");
+        client.listener.assertClosed(1000, "Goodbye!");
+    }
+
+    @Test public void serverCloseClosesConnection() throws IOException {
+        server.webSocket.close(1000, "Hello!");
+
+        client.processNextFrame(); // Read server close, send client close, close connection.
+        assertFalse(client.closed);
+        client.listener.assertClosing(1000, "Hello!");
+
+        client.webSocket.close(1000, "Hello!");
+        server.processNextFrame();
+        server.listener.assertClosing(1000, "Hello!");
+
+        client.listener.assertClosed(1000, "Hello!");
+        server.listener.assertClosed(1000, "Hello!");
+    }
+
+    @Test public void clientAndServerCloseClosesConnection() throws IOException {
+        // Send close from both sides at the same time.
+        server.webSocket.close(1000, "Hello!");
+        client.processNextFrame(); // Read close, close connection close.
+
+        assertFalse(client.closed);
+        client.webSocket.close(1000, "Hi!");
+        server.processNextFrame();
+
+        client.listener.assertClosing(1000, "Hello!");
+        server.listener.assertClosing(1000, "Hi!");
+        client.listener.assertClosed(1000, "Hello!");
+        server.listener.assertClosed(1000, "Hi!");
+        assertTrue(client.closed);
+
+        server.listener.assertExhausted(); // Client should not have sent second close.
+        client.listener.assertExhausted(); // Server should not have sent second close.
+    }
+
+    @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+        server.webSocket.send("Hello!");
+        server.webSocket.close(1000, "Bye!");
+        assertTrue(client.processNextFrame());
+        client.listener.assertTextMessage("Hello!");
+        assertFalse(client.processNextFrame());
+        client.listener.assertClosing(1000, "Bye!");
+    }
+
+    @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
+        server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+        client.processNextFrame(); // Detects error, send close, close connection.
+        assertTrue(client.closed);
+        client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+        server.processNextFrame();
+        server.listener.assertFailure(EOFException.class, null);
+    }
+
+    @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+        client.webSocket.close(1000, "Hello");
+        server.processNextFrame();
+        assertFalse(client.closed); // Not closed until close reply is received.
+
+        // Manually write an invalid masked close frame.
+        server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+
+        client.processNextFrame();// Detects error, disconnects immediately since close already sent.
+        assertTrue(client.closed);
+        client.listener.assertFailure(
+                ProtocolException.class, "Server-sent frames must not be masked.");
+
+        server.listener.assertClosing(1000, "Hello");
+        server.listener.assertExhausted(); // Client should not have sent second close.
+    }
+
+    @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+        client.webSocket.close(1000, "Hello!");
+        server.processNextFrame();
+
+        assertFalse(client.closed); // Not closed until close reply is received.
+        server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+        client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
+        assertTrue(client.closed);
+        client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+        server.listener.assertClosing(1000, "Hello!");
+
+        server.listener.assertExhausted(); // Client should not have sent second close.
+    }
+
+    @Test public void networkErrorReportedAsFailure() throws IOException {
+        server.sink.close();
+        client.processNextFrame();
+        client.listener.assertFailure(EOFException.class, null);
+    }
+
+    @Test public void closeThrowingFailsConnection() throws IOException {
+        client2Server.source().close();
+        client.webSocket.close(1000, null);
+        client.listener.assertFailure(IOException.class, "source is closed");
+    }
+
+    @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+    @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+        client.sink.close();
+        client.closeThrows = true;
+
+        client.webSocket.close(1000, "Bye!");
+        client.listener.assertFailure(IOException.class, "failure");
+        assertTrue(client.closed);
+    }
+
+    @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+    @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
+        client.closeThrows = true;
+
+        server.webSocket.close(1000, "Bye from Server!");
+        client.processNextFrame();
+        client.listener.assertClosing(1000, "Bye from Server!");
+
+        client.webSocket.close(1000, "Bye from Client!");
+        server.processNextFrame();
+        server.listener.assertClosing(1000, "Bye from Client!");
+    }
+
+    @Test public void pingOnInterval() throws IOException {
+        long startNanos = System.nanoTime();
+        client.initWebSocket(random, 500);
+
+        server.processNextFrame(); // Ping.
+        client.processNextFrame(); // Pong.
+        long elapsedUntilPing1 = System.nanoTime() - startNanos;
+        assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+
+        server.processNextFrame(); // Ping.
+        client.processNextFrame(); // Pong.
+        long elapsedUntilPing2 = System.nanoTime() - startNanos;
+        assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+
+        server.processNextFrame(); // Ping.
+        client.processNextFrame(); // Pong.
+        long elapsedUntilPing3 = System.nanoTime() - startNanos;
+        assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+    }
+
+    /** One peer's streams, listener, and web socket in the test. */
+    private static class TestStreams extends RealWebSocket.Streams {
+        private final String name;
+        private final WebSocketRecorder listener;
+        private RealWebSocket webSocket;
+        boolean closeThrows;
+        boolean closed;
+
+        public TestStreams(boolean client, Pipe source, Pipe sink) {
+            super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
+            this.name = client ? "client" : "server";
+            this.listener = new WebSocketRecorder(name);
+        }
+
+        public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
+            String url = "http://example.com/websocket";
+            Response response = new Response.Builder()
+                    .code(101)
+                    .request(new Request.Builder().url(url).build())
+                    .protocol(Protocol.HTTP_1_1)
+                    .build();
+            webSocket = new RealWebSocket(response.request(), listener, random);
+            webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+        }
+
+        public boolean processNextFrame() throws IOException {
+            return webSocket.processNextFrame();
+        }
+
+        @Override public void close() throws IOException {
+            source.close();
+            sink.close();
+            if (closed) {
+                throw new AssertionError("Already closed");
+            }
+            closed = true;
+
+            if (closeThrows) {
+                throw new RuntimeException("Oops!");
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
new file mode 100644
index 0000000000..76c04a124c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import okhttp3.RequestBody;
+import okhttp3.internal.Util;
+import okio.*;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Random;
+
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.ws.WebSocketProtocol.*;
+import static org.junit.Assert.*;
+
+public final class WebSocketWriterTest {
+    private final Buffer data = new Buffer();
+    private final Random random = new Random(0);
+
+    /**
+     * Check all data as verified inside of the test. We do this in a rule instead of @After so that
+     * exceptions thrown from the test do not cause this check to fail.
+     */
+    @Rule public final TestRule noDataLeftBehind = new TestRule() {
+        @Override public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override public void evaluate() throws Throwable {
+                    base.evaluate();
+                    assertEquals("Data not empty", "", data.readByteString().hex());
+                }
+            };
+        }
+    };
+
+    // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+    private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
+    private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
+
+    @Test public void serverTextMessage() throws IOException {
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+        sink.writeUtf8("Hel").flush();
+        assertData("010348656c");
+
+        sink.writeUtf8("lo").flush();
+        assertData("00026c6f");
+
+        sink.close();
+        assertData("8000");
+    }
+
+    @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
+        int length = 5;
+        byte[] bytes = binaryData(length);
+
+        RequestBody body = RequestBody.create(null, bytes);
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+        body.writeTo(sink);
+        sink.close();
+
+        assertData("8105");
+        assertData(bytes);
+        assertTrue(data.exhausted());
+    }
+
+    @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
+        int length = 12345;
+        byte[] bytes = binaryData(length);
+
+        RequestBody body = RequestBody.create(null, bytes);
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+        body.writeTo(sink);
+        sink.close();
+
+        assertData("817e");
+        assertData(Util.format("%04x", length));
+        assertData(bytes);
+        assertTrue(data.exhausted());
+    }
+
+    @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
+        int length = 100_000;
+        Buffer bytes = new Buffer().write(binaryData(length));
+
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+        Buffer body = bytes.clone();
+        sink.write(body.readByteString(20_000));
+        sink.write(body.readByteString(20_000));
+        sink.write(body.readByteString(20_000));
+        sink.write(body.readByteString(20_000));
+        sink.write(body.readByteString(20_000));
+        sink.close();
+
+        assertData("017e4000");
+        assertData(bytes.readByteArray(16_384));
+        assertData("007e4000");
+        assertData(bytes.readByteArray(16_384));
+        assertData("007e6000");
+        assertData(bytes.readByteArray(24_576));
+        assertData("007e4000");
+        assertData(bytes.readByteArray(16_384));
+        assertData("007e6000");
+        assertData(bytes.readByteArray(24_576));
+        assertData("807e06a0");
+        assertData(bytes.readByteArray(1_696));
+        assertTrue(data.exhausted());
+    }
+
+    @Test public void closeFlushes() throws IOException {
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+        sink.writeUtf8("Hel").flush();
+        assertData("010348656c");
+
+        sink.writeUtf8("lo").close();
+        assertData("80026c6f");
+    }
+
+    @Test public void noWritesAfterClose() throws IOException {
+        Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
+
+        sink.close();
+        assertData("8100");
+
+        Buffer payload = new Buffer().writeUtf8("Hello");
+        try {
+            // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+            sink.write(payload, payload.size());
+            fail();
+        } catch (IOException e) {
+            assertEquals("closed", e.getMessage());
+        }
+    }
+
+    @Test public void clientTextMessage() throws IOException {
+        BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
+
+        sink.writeUtf8("Hel").flush();
+        assertData("018360b420bb28d14c");
+
+        sink.writeUtf8("lo").flush();
+        assertData("00823851d9d4543e");
+
+        sink.close();
+        assertData("80807acb933d");
+    }
+
+    @Test public void serverBinaryMessage() throws IOException {
+        BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
+
+        sink.write(binaryData(50)).flush();
+        assertData("0232");
+        assertData(binaryData(50));
+
+        sink.write(binaryData(50)).flush();
+        assertData("0032");
+        assertData(binaryData(50));
+
+        sink.close();
+        assertData("8000");
+    }
+
+    @Test public void serverMessageLengthShort() throws IOException {
+        Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+        // Create a payload which will overflow the normal payload byte size.
+        Buffer payload = new Buffer();
+        while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+            payload.writeByte('0');
+        }
+        long byteCount = payload.completeSegmentByteCount();
+
+        // Write directly to the unbuffered sink. This ensures it will become single frame.
+        sink.write(payload.clone(), byteCount);
+        assertData("027e"); // 'e' == 4-byte follow-up length.
+        assertData(Util.format("%04X", payload.completeSegmentByteCount()));
+        assertData(payload.readByteArray());
+
+        sink.close();
+        assertData("8000");
+    }
+
+    @Test public void serverMessageLengthLong() throws IOException {
+        Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+        // Create a payload which will overflow the normal and short payload byte size.
+        Buffer payload = new Buffer();
+        while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+            payload.writeByte('0');
+        }
+        long byteCount = payload.completeSegmentByteCount();
+
+        // Write directly to the unbuffered sink. This ensures it will become single frame.
+        sink.write(payload.clone(), byteCount);
+        assertData("027f"); // 'f' == 16-byte follow-up length.
+        assertData(Util.format("%016X", byteCount));
+        assertData(payload.readByteArray(byteCount));
+
+        sink.close();
+        assertData("8000");
+    }
+
+    @Test public void clientBinary() throws IOException {
+        byte[] maskKey1 = new byte[4];
+        random.nextBytes(maskKey1);
+        byte[] maskKey2 = new byte[4];
+        random.nextBytes(maskKey2);
+
+        random.setSeed(0); // Reset the seed so real data matches.
+
+        BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
+
+        byte[] part1 = binaryData(50);
+        sink.write(part1).flush();
+        toggleMask(part1, 50, maskKey1, 0);
+        assertData("02b2");
+        assertData(maskKey1);
+        assertData(part1);
+
+        byte[] part2 = binaryData(50);
+        sink.write(part2).close();
+        toggleMask(part2, 50, maskKey2, 0);
+        assertData("80b2");
+        assertData(maskKey2);
+        assertData(part2);
+    }
+
+    @Test public void serverEmptyClose() throws IOException {
+        serverWriter.writeClose(0, null);
+        assertData("8800");
+    }
+
+    @Test public void serverCloseWithCode() throws IOException {
+        serverWriter.writeClose(1001, null);
+        assertData("880203e9");
+    }
+
+    @Test public void serverCloseWithCodeAndReason() throws IOException {
+        serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
+        assertData("880703e948656c6c6f");
+    }
+
+    @Test public void clientEmptyClose() throws IOException {
+        clientWriter.writeClose(0, null);
+        assertData("888060b420bb");
+    }
+
+    @Test public void clientCloseWithCode() throws IOException {
+        clientWriter.writeClose(1001, null);
+        assertData("888260b420bb635d");
+    }
+
+    @Test public void clientCloseWithCodeAndReason() throws IOException {
+        clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
+        assertData("888760b420bb635d68de0cd84f");
+    }
+
+    @Test public void closeWithOnlyReasonThrows() throws IOException {
+        clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
+        assertData("888760b420bb60b468de0cd84f");
+    }
+
+    @Test public void closeCodeOutOfRangeThrows() throws IOException {
+        try {
+            clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+        }
+    }
+
+    @Test public void closeReservedThrows() throws IOException {
+        try {
+            clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+        }
+    }
+
+    @Test public void serverEmptyPing() throws IOException {
+        serverWriter.writePing(ByteString.EMPTY);
+        assertData("8900");
+    }
+
+    @Test public void clientEmptyPing() throws IOException {
+        clientWriter.writePing(ByteString.EMPTY);
+        assertData("898060b420bb");
+    }
+
+    @Test public void serverPingWithPayload() throws IOException {
+        serverWriter.writePing(ByteString.encodeUtf8("Hello"));
+        assertData("890548656c6c6f");
+    }
+
+    @Test public void clientPingWithPayload() throws IOException {
+        clientWriter.writePing(ByteString.encodeUtf8("Hello"));
+        assertData("898560b420bb28d14cd70f");
+    }
+
+    @Test public void serverEmptyPong() throws IOException {
+        serverWriter.writePong(ByteString.EMPTY);
+        assertData("8a00");
+    }
+
+    @Test public void clientEmptyPong() throws IOException {
+        clientWriter.writePong(ByteString.EMPTY);
+        assertData("8a8060b420bb");
+    }
+
+    @Test public void serverPongWithPayload() throws IOException {
+        serverWriter.writePong(ByteString.encodeUtf8("Hello"));
+        assertData("8a0548656c6c6f");
+    }
+
+    @Test public void clientPongWithPayload() throws IOException {
+        clientWriter.writePong(ByteString.encodeUtf8("Hello"));
+        assertData("8a8560b420bb28d14cd70f");
+    }
+
+    @Test public void pingTooLongThrows() throws IOException {
+        try {
+            serverWriter.writePing(ByteString.of(binaryData(1000)));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+        }
+    }
+
+    @Test public void pongTooLongThrows() throws IOException {
+        try {
+            serverWriter.writePong(ByteString.of(binaryData(1000)));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+        }
+    }
+
+    @Test public void closeTooLongThrows() throws IOException {
+        try {
+            ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
+            serverWriter.writeClose(1000, longReason);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+        }
+    }
+
+    @Test public void twoMessageSinksThrows() {
+        clientWriter.newMessageSink(OPCODE_TEXT, -1);
+        try {
+            clientWriter.newMessageSink(OPCODE_TEXT, -1);
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+        }
+    }
+
+    private void assertData(String hex) throws EOFException {
+        ByteString expected = ByteString.decodeHex(hex);
+        ByteString actual = data.readByteString(expected.size());
+        assertEquals(expected, actual);
+    }
+
+    private void assertData(byte[] data) throws IOException {
+        int byteCount = 16;
+        for (int i = 0; i < data.length; i += byteCount) {
+            int count = Math.min(byteCount, data.length - i);
+            Buffer expectedChunk = new Buffer();
+            expectedChunk.write(data, i, count);
+            assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+        }
+    }
+
+    private static byte[] binaryData(int length) {
+        byte[] junk = new byte[length];
+        new Random(0).nextBytes(junk);
+        return junk;
+    }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 71f4d19b5a..8254e7fbec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -15,30 +15,19 @@
  */
 package okhttp3.internal.http2;
 
+import okhttp3.Protocol;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.*;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
+import java.util.*;
+import java.util.concurrent.*;
 
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
@@ -238,7 +227,6 @@ private Http2Stream newStream(
     if (flushHeaders) {
       writer.flush();
     }
-
     return stream;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 7490b09ba0..5e18f5efc4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -15,32 +15,17 @@
  */
 package okhttp3.internal.http2;
 
+import okio.Buffer;
+import okio.BufferedSink;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
-import okio.Buffer;
-import okio.BufferedSink;
 
 import static java.util.logging.Level.FINE;
 import static okhttp3.internal.Util.format;
-import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
-import static okhttp3.internal.http2.Http2.FLAG_ACK;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
-import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.http2.Http2.TYPE_DATA;
-import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
-import static okhttp3.internal.http2.Http2.TYPE_PING;
-import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
-import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
-import static okhttp3.internal.http2.Http2.frameLog;
-import static okhttp3.internal.http2.Http2.illegalArgument;
+import static okhttp3.internal.http2.Http2.*;
 
 /** Writes HTTP/2 transport frames. */
 final class Http2Writer implements Closeable {
diff --git a/samples/crawler/src/test/okhttp3/sample/TestSamples.java b/samples/crawler/src/test/okhttp3/sample/TestSamples.java
new file mode 100644
index 0000000000..56de2234c4
--- /dev/null
+++ b/samples/crawler/src/test/okhttp3/sample/TestSamples.java
@@ -0,0 +1,13 @@
+package okhttp3.sample;
+import org.junit.Test;
+
+import java.io.IOException;
+
+public class TestSamples{
+
+    @Test
+    public void crawlOkhttp() throws IOException {
+        Crawler.main(new String[]{"temp", "http://square.github.io/okhttp/"});
+    }
+
+}
\ No newline at end of file
