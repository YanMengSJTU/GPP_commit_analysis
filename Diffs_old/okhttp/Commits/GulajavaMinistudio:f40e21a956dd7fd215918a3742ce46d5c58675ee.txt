diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index d18559bb75..8dc3c57bce 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -21,10 +21,10 @@ import okhttp3.ConnectionPool
 import okhttp3.Route
 import okhttp3.internal.closeQuietly
 import okhttp3.internal.connection.Transmitter.TransmitterReference
+import okhttp3.internal.lockAndWaitNanos
 import okhttp3.internal.notifyAll
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.threadFactory
-import okhttp3.internal.lockAndWaitNanos
 import java.io.IOException
 import java.net.Proxy
 import java.util.ArrayDeque
@@ -47,7 +47,9 @@ class RealConnectionPool(
         if (waitNanos == -1L) return
         try {
           this@RealConnectionPool.lockAndWaitNanos(waitNanos)
-        } catch (_: InterruptedException) {
+        } catch (ie: InterruptedException) {
+          // Will cause the thread to exit unless other connections are created!
+          evictAll()
         }
       }
     }
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
index c756b09056..e9908f89f2 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -179,6 +179,27 @@
     assertThat(c1.getNoNewExchanges()).isTrue();
   }
 
+  @Test public void interruptStopsThread() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    RealConnection c1 = newConnection(pool, routeA1, Long.MAX_VALUE);
+
+    assertThat(pool.getCleanupRunning()).isTrue();
+
+    Thread.sleep(100);
+
+    Thread[] threads = new Thread[Thread.activeCount() * 2];
+    Thread.enumerate(threads);
+    for (Thread t: threads) {
+      if (t != null && t.getName().equals("OkHttp ConnectionPool")) {
+        t.interrupt();
+      }
+    }
+
+    Thread.sleep(100);
+
+    assertThat(pool.getCleanupRunning()).isFalse();
+  }
+
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
     synchronized (RealConnectionPool.Companion.get(pool)) {
