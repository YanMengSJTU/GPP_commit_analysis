diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 3fdaf676e8..aed4b1038d 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -344,7 +344,6 @@ public void processConnection() throws Exception {
               .handler(spdySocketHandler).build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
           openClientSockets.remove(socket);
-          spdyConnection.readConnectionHeader();
           return;
         }
 
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
new file mode 100644
index 0000000000..af0ba2e212
--- /dev/null
+++ b/okcurl/pom.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okcurl</artifactId>
+  <name>OkCurl</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.airlift</groupId>
+      <artifactId>airline</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>src/main/resources</directory>
+        <filtering>true</filtering>
+      </resource>
+    </resources>
+
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>com.squareup.okhttp.curl.Main</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.skife.maven</groupId>
+        <artifactId>really-executable-jar-maven-plugin</artifactId>
+        <version>1.1.0</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>really-executable-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <flags>-Xbootclasspath/p:$0</flags>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
new file mode 100644
index 0000000000..88caf94fe9
--- /dev/null
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -0,0 +1,208 @@
+package com.squareup.okhttp.curl;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Failure;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import io.airlift.command.Arguments;
+import io.airlift.command.Command;
+import io.airlift.command.HelpOption;
+import io.airlift.command.Option;
+import io.airlift.command.SingleCommand;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Properties;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+@Command(name = Main.NAME, description = "A curl for the next-generation web.")
+public class Main extends HelpOption implements Runnable, Response.Receiver {
+  static final String NAME = "okcurl";
+  static final int DEFAULT_TIMEOUT = -1;
+
+  public static void main(String... args) {
+    SingleCommand.singleCommand(Main.class).parse(args).run();
+  }
+
+  private static String versionString() {
+    try {
+      Properties prop = new Properties();
+      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
+      prop.load(in);
+      in.close();
+      return prop.getProperty("version");
+    } catch (IOException e) {
+      throw new AssertionError("Could not load okcurl-version.properties.");
+    }
+  }
+
+  private static String protocols() {
+    return Joiner.on(", ").join(Lists.transform(Arrays.asList(Protocol.values()),
+        new Function<Protocol, String>() {
+          @Override public String apply(Protocol protocol) {
+            return protocol.name.utf8();
+          }
+        }));
+  }
+
+  @Option(name = { "-X", "--request" }, description = "Specify request command to use",
+      allowedValues = { "GET", "HEAD" })
+  public String method = "GET";
+
+  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  public List<String> headers;
+
+  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  public String userAgent = NAME + "/" + versionString();
+
+  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
+  public int connectTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
+  public int readTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  public boolean followRedirects;
+
+  @Option(name = { "-k", "--insecure" },
+      description = "Allow connections to SSL sites without certs")
+  public boolean allowInsecure;
+
+  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  public boolean showHeaders;
+
+  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  public String referer;
+
+  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  public boolean version;
+
+  @Arguments(title = "url", description = "Remote resource URL")
+  public String url;
+
+  private OkHttpClient client;
+
+  @Override public void run() {
+    if (showHelpIfRequested()) {
+      return;
+    }
+    if (version) {
+      System.out.println(NAME + " " + versionString());
+      System.out.println("Protocols: " + protocols());
+      return;
+    }
+
+    client = getConfiguredClient();
+    Request request = getConfiguredRequest();
+    client.enqueue(request, this);
+
+    // Immediately begin triggering an executor shutdown so that after execution of the above
+    // request the threads do not stick around until timeout.
+    client.getDispatcher().getExecutorService().shutdown();
+  }
+
+  private OkHttpClient getConfiguredClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setFollowProtocolRedirects(followRedirects);
+    if (connectTimeout != DEFAULT_TIMEOUT) {
+      client.setConnectTimeout(connectTimeout, SECONDS);
+    }
+    if (readTimeout != DEFAULT_TIMEOUT) {
+      client.setReadTimeout(readTimeout, SECONDS);
+    }
+    if (allowInsecure) {
+      client.setSslSocketFactory(createInsecureSslSocketFactory());
+    }
+    // If we don't set this reference, there's no way to clean shutdown persistent connections.
+    client.setConnectionPool(ConnectionPool.getDefault());
+    return client;
+  }
+
+  private Request getConfiguredRequest() {
+    Request.Builder request = new Request.Builder();
+    request.method(method, null);
+    request.url(url);
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", -1);
+        request.header(parts[0], parts[1]);
+      }
+    }
+    if (referer != null) {
+      request.header("Referer", referer);
+    }
+    request.header("User-Agent", userAgent);
+    return request.build();
+  }
+
+  @Override public void onFailure(Failure failure) {
+    failure.exception().printStackTrace();
+    close();
+  }
+
+  @Override public boolean onResponse(Response response) throws IOException {
+    if (showHeaders) {
+      System.out.println(response.statusLine());
+      Headers headers = response.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        System.out.println(headers.name(i) + ": " + headers.value(i));
+      }
+      System.out.println();
+    }
+
+    Response.Body body = response.body();
+    byte[] buffer = new byte[1024];
+    while (body.ready()) {
+      int c = body.byteStream().read(buffer);
+      if (c == -1) {
+        close();
+        return true;
+      }
+
+      System.out.write(buffer, 0, c);
+    }
+    close();
+    return false;
+  }
+
+  private void close() {
+    client.getConnectionPool().evictAll(); // Close any persistent connections.
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory() {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      TrustManager permissive = new X509TrustManager() {
+        @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public void checkServerTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public X509Certificate[] getAcceptedIssuers() {
+          return null;
+        }
+      };
+      context.init(null, new TrustManager[] { permissive }, null);
+      return context.getSocketFactory();
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
new file mode 100644
index 0000000000..defbd48204
--- /dev/null
+++ b/okcurl/src/main/resources/okcurl-version.properties
@@ -0,0 +1 @@
+version=${project.version}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index e609db9528..f5823a4991 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -404,4 +404,17 @@ public static void asciiLowerCase(byte[] bytes) {
   public static byte asciiLowerCase(byte c) {
     return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
   }
+
+  public static int reverseBytesShort(short s) {
+    int i = s & 0xffff;
+    return (i & 0xff00) >>> 8
+        |  (i & 0x00ff) << 8;
+  }
+
+  public static int reverseBytesInt(int i) {
+    return (i & 0xff000000) >>> 24
+        |  (i & 0x00ff0000) >>> 8
+        |  (i & 0x0000ff00) << 8
+        |  (i & 0x000000ff) << 24;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
new file mode 100644
index 0000000000..db62b6c28a
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+
+/**
+ * A source that keeps a buffer internally so that callers can do small reads
+ * without a performance penalty.
+ */
+public final class BufferedSource implements Source {
+  public final OkBuffer buffer;
+  public final Source source;
+  private boolean closed;
+
+  public BufferedSource(Source source, OkBuffer buffer) {
+    this.buffer = buffer;
+    this.source = source;
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+      throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (closed) throw new IllegalStateException("closed");
+
+    if (buffer.byteCount == 0) {
+      long read = source.read(buffer, Segment.SIZE, deadline);
+      if (read == -1) return -1;
+    }
+
+    long toRead = Math.min(byteCount, buffer.byteCount);
+    return buffer.read(sink, toRead, deadline);
+  }
+
+  /**
+   * Returns true if there are no more bytes in the buffer or the source. This
+   * will block until there are bytes to read or the source is definitely
+   * exhausted.
+   */
+  public boolean exhausted(Deadline deadline) throws IOException {
+    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, deadline) == -1;
+  }
+
+  /**
+   * Returns when the buffer contains at least {@code byteCount} bytes. Throws
+   * an {@link EOFException} if the source is exhausted before the required
+   * bytes can be read.
+   */
+  void require(long byteCount, Deadline deadline) throws IOException {
+    while (buffer.byteCount < byteCount) {
+      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+    }
+  }
+
+  public byte readByte() throws IOException {
+    require(1, Deadline.NONE);
+    return buffer.readByte();
+  }
+
+  public ByteString readByteString(int byteCount) throws IOException {
+    require(byteCount, Deadline.NONE);
+    return buffer.readByteString(byteCount);
+  }
+
+  public short readShort() throws IOException {
+    require(2, Deadline.NONE);
+    return buffer.readShort();
+  }
+
+  public int readShortLe() throws IOException {
+    require(2, Deadline.NONE);
+    return buffer.readShortLe();
+  }
+
+  public int readInt() throws IOException {
+    require(4, Deadline.NONE);
+    return buffer.readInt();
+  }
+
+  public int readIntLe() throws IOException {
+    require(4, Deadline.NONE);
+    return buffer.readIntLe();
+  }
+
+  /**
+   * Reads and discards {@code byteCount} bytes from {@code source} using {@code
+   * buffer} as a buffer. Throws an {@link EOFException} if the source is
+   * exhausted before the requested bytes can be skipped.
+   */
+  public void skip(long byteCount, Deadline deadline) throws IOException {
+    while (byteCount > 0) {
+      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE, deadline) == -1) {
+        throw new EOFException();
+      }
+      long toSkip = Math.min(byteCount, buffer.byteCount());
+      buffer.skip(toSkip);
+      byteCount -= toSkip;
+    }
+  }
+
+  /**
+   * Returns the index of {@code b} in the buffer, refilling it if necessary
+   * until it is found. This reads an unbounded number of bytes into the buffer.
+   */
+  public long seek(byte b, Deadline deadline) throws IOException {
+    long start = 0;
+    long index;
+    while ((index = buffer.indexOf(b, start)) == -1) {
+      start = buffer.byteCount;
+      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+    }
+    return index;
+  }
+
+  /** Returns an input stream that reads from this source. */
+  public InputStream inputStream() {
+    return new InputStream() {
+      @Override public int read() throws IOException {
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+        return buffer.readByte() & 0xff;
+      }
+
+      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
+        checkOffsetAndCount(data.length, offset, byteCount);
+
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+
+        Segment head = buffer.head;
+        int toCopy = Math.min(byteCount, head.limit - head.pos);
+        System.arraycopy(head.data, head.pos, data, offset, toCopy);
+
+        head.pos += toCopy;
+        buffer.byteCount -= toCopy;
+
+        if (head.pos == head.limit) {
+          buffer.head = head.pop();
+          SegmentPool.INSTANCE.recycle(head);
+        }
+
+        return toCopy;
+      }
+
+      @Override public int available() throws IOException {
+        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
+      }
+
+      @Override public void close() throws IOException {
+        BufferedSource.this.close(Deadline.NONE);
+      }
+
+      @Override public String toString() {
+        return BufferedSource.this.toString() + ".inputStream()";
+      }
+    };
+  }
+
+  @Override public void close(Deadline deadline) throws IOException {
+    if (closed) return;
+    closed = true;
+    source.close(deadline);
+    buffer.clear();
+  }
+
+  @Override public String toString() {
+    return "BufferedSource(" + source + ")";
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
index 9a6a799edc..340ed3c842 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
@@ -106,6 +106,31 @@ public static ByteString readLowerCase(InputStream in, int count) throws IOExcep
     return new ByteString(result);
   }
 
+  /**
+   * Returns a byte string equal to this byte string, but with the bytes 'A'
+   * through 'Z' replaced with the corresponding byte in 'a' through 'z'.
+   * Returns this byte string if it contains no bytes in 'A' through 'Z'.
+   */
+  public ByteString toAsciiLowercase() {
+    // Search for an uppercase character. If we don't find one, return this.
+    for (int i = 0; i < data.length; i++) {
+      byte c = data[i];
+      if (c < 'A' || c > 'Z') continue;
+
+      // If we reach this point, this string is not not lowercase. Create and
+      // return a new byte string.
+      byte[] lowercase = data.clone();
+      lowercase[i++] = (byte) (c - ('A' - 'a'));
+      for (; i < lowercase.length; i++) {
+        c = lowercase[i];
+        if (c < 'A' || c > 'Z') continue;
+        lowercase[i] = (byte) (c - ('A' - 'a'));
+      }
+      return new ByteString(lowercase);
+    }
+    return this;
+  }
+
   public static ByteString concat(ByteString... byteStrings) {
     int size = 0;
     for (ByteString byteString : byteStrings) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
new file mode 100644
index 0000000000..11e460d039
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+import java.util.zip.CRC32;
+import java.util.zip.Inflater;
+
+public final class GzipSource implements Source {
+  private static final byte FHCRC = 1;
+  private static final byte FEXTRA = 2;
+  private static final byte FNAME = 3;
+  private static final byte FCOMMENT = 4;
+
+  private static final byte SECTION_HEADER = 0;
+  private static final byte SECTION_BODY = 1;
+  private static final byte SECTION_TRAILER = 2;
+  private static final byte SECTION_DONE = 3;
+
+  /** The current section. Always progresses forward. */
+  private int section = SECTION_HEADER;
+
+  /**
+   * Our source should yield a GZIP header (which we consume directly), followed
+   * by deflated bytes (which we consume via an InflaterSource), followed by a
+   * GZIP trailer (which we also consume directly).
+   */
+  private final BufferedSource source;
+
+  /** The inflater used to decompress the deflated body. */
+  private final Inflater inflater;
+
+  /**
+   * The inflater source takes care of moving data between compressed source and
+   * decompressed sink buffers.
+   */
+  private final InflaterSource inflaterSource;
+
+  /** Checksum used to check both the GZIP header and decompressed body. */
+  private final CRC32 crc = new CRC32();
+
+  public GzipSource(Source source) throws IOException {
+    this.inflater = new Inflater(true);
+    this.source = new BufferedSource(source, new OkBuffer());
+    this.inflaterSource = new InflaterSource(this.source, inflater);
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (byteCount == 0) return 0;
+
+    // If we haven't consumed the header, we must consume it before anything else.
+    if (section == SECTION_HEADER) {
+      consumeHeader(deadline);
+      section = SECTION_BODY;
+    }
+
+    // Attempt to read at least a byte of the body. If we do, we're done.
+    if (section == SECTION_BODY) {
+      long offset = sink.byteCount;
+      long result = inflaterSource.read(sink, byteCount, deadline);
+      if (result != -1) {
+        updateCrc(sink, offset, result);
+        return result;
+      }
+      section = SECTION_TRAILER;
+    }
+
+    // The body is exhausted; time to read the trailer. We always consume the
+    // trailer before returning a -1 exhausted result; that way if you read to
+    // the end of a GzipSource you guarantee that the CRC has been checked.
+    if (section == SECTION_TRAILER) {
+      consumeTrailer(deadline);
+      section = SECTION_DONE;
+    }
+
+    return -1;
+  }
+
+  private void consumeHeader(Deadline deadline) throws IOException {
+    // Read the 10-byte header. We peek at the flags byte first so we know if we
+    // need to CRC the entire header. Then we read the magic ID1ID2 sequence.
+    // We can skip everything else in the first 10 bytes.
+    // +---+---+---+---+---+---+---+---+---+---+
+    // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
+    // +---+---+---+---+---+---+---+---+---+---+
+    source.require(10, deadline);
+    byte flags = source.buffer.getByte(3);
+    boolean fhcrc = ((flags >> FHCRC) & 1) == 1;
+    if (fhcrc) updateCrc(source.buffer, 0, 10);
+
+    short id1id2 = source.readShort();
+    checkEqual("ID1ID2", (short) 0x1f8b, id1id2);
+    source.skip(8, deadline);
+
+    // Skip optional extra fields.
+    // +---+---+=================================+
+    // | XLEN  |...XLEN bytes of "extra field"...| (more-->)
+    // +---+---+=================================+
+    if (((flags >> FEXTRA) & 1) == 1) {
+      source.require(2, deadline);
+      if (fhcrc) updateCrc(source.buffer, 0, 2);
+      int xlen = source.buffer.readShortLe() & 0xffff;
+      source.require(xlen, deadline);
+      if (fhcrc) updateCrc(source.buffer, 0, xlen);
+      source.skip(xlen, deadline);
+    }
+
+    // Skip an optional 0-terminated name.
+    // +=========================================+
+    // |...original file name, zero-terminated...| (more-->)
+    // +=========================================+
+    if (((flags >> FNAME) & 1) == 1) {
+      long index = source.seek((byte) 0, deadline);
+      if (fhcrc) updateCrc(source.buffer, 0, index + 1);
+      source.buffer.skip(index + 1);
+    }
+
+    // Skip an optional 0-terminated comment.
+    // +===================================+
+    // |...file comment, zero-terminated...| (more-->)
+    // +===================================+
+    if (((flags >> FCOMMENT) & 1) == 1) {
+      long index = source.seek((byte) 0, deadline);
+      if (fhcrc) updateCrc(source.buffer, 0, index + 1);
+      source.skip(index + 1, deadline);
+    }
+
+    // Confirm the optional header CRC.
+    // +---+---+
+    // | CRC16 |
+    // +---+---+
+    if (fhcrc) {
+      checkEqual("FHCRC", source.readShortLe(), (short) crc.getValue());
+      crc.reset();
+    }
+  }
+
+  private void consumeTrailer(Deadline deadline) throws IOException {
+    // Read the eight-byte trailer. Confirm the body's CRC and size.
+    // +---+---+---+---+---+---+---+---+
+    // |     CRC32     |     ISIZE     |
+    // +---+---+---+---+---+---+---+---+
+    checkEqual("CRC", source.readIntLe(), (int) crc.getValue());
+    checkEqual("ISIZE", source.readIntLe(), inflater.getTotalOut());
+  }
+
+  @Override public void close(Deadline deadline) throws IOException {
+    inflaterSource.close(deadline);
+  }
+
+  /** Updates the CRC with the given bytes. */
+  private void updateCrc(OkBuffer buffer, long offset, long byteCount) {
+    for (Segment s = buffer.head; byteCount > 0; s = s.next) {
+      int segmentByteCount = s.limit - s.pos;
+      if (offset < segmentByteCount) {
+        int toUpdate = (int) Math.min(byteCount, segmentByteCount - offset);
+        crc.update(s.data, (int) (s.pos + offset), toUpdate);
+        byteCount -= toUpdate;
+      }
+      offset -= segmentByteCount; // Track the offset of the current segment.
+    }
+  }
+
+  private void checkEqual(String name, int expected, int actual) throws IOException {
+    if (actual != expected) {
+      throw new IOException(String.format(
+          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
index 3a11d115db..ce67f12072 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
@@ -22,9 +22,8 @@
 
 /** A source that inflates another source. */
 public final class InflaterSource implements Source {
-  private final Source source;
+  private final BufferedSource source;
   private final Inflater inflater;
-  private final OkBuffer buffer = new OkBuffer();
 
   /**
    * When we call Inflater.setInput(), the inflater keeps our byte array until
@@ -35,6 +34,15 @@
   private boolean closed;
 
   public InflaterSource(Source source, Inflater inflater) {
+    this(new BufferedSource(source, new OkBuffer()), inflater);
+  }
+
+  /**
+   * This package-private constructor shares a buffer with its trusted caller.
+   * In general we can't share a BufferedSource because the inflater holds input
+   * bytes until they are inflated.
+   */
+  InflaterSource(BufferedSource source, Inflater inflater) {
     if (source == null) throw new IllegalArgumentException("source == null");
     if (inflater == null) throw new IllegalArgumentException("inflater == null");
     this.source = source;
@@ -48,31 +56,7 @@ public InflaterSource(Source source, Inflater inflater) {
     if (byteCount == 0) return 0;
 
     while (true) {
-      boolean sourceExhausted = false;
-      if (inflater.needsInput()) {
-        // Release buffer bytes from the inflater.
-        if (bufferBytesHeldByInflater > 0) {
-          Segment head = buffer.head;
-          head.pos += bufferBytesHeldByInflater;
-          buffer.byteCount -= bufferBytesHeldByInflater;
-          if (head.pos == head.limit) {
-            buffer.head = head.pop();
-            SegmentPool.INSTANCE.recycle(head);
-          }
-        }
-
-        // Refill the buffer with compressed data from the source.
-        if (buffer.byteCount == 0) {
-          sourceExhausted = source.read(buffer, Segment.SIZE, deadline) == -1;
-        }
-
-        // Acquire buffer bytes for the inflater.
-        if (buffer.byteCount > 0) {
-          Segment head = buffer.head;
-          bufferBytesHeldByInflater = head.limit - head.pos;
-          inflater.setInput(head.data, head.pos, bufferBytesHeldByInflater);
-        }
-      }
+      boolean sourceExhausted = refill(deadline);
 
       // Decompress the inflater's compressed data into the sink.
       try {
@@ -83,7 +67,10 @@ public InflaterSource(Source source, Inflater inflater) {
           sink.byteCount += bytesInflated;
           return bytesInflated;
         }
-        if (inflater.finished() || inflater.needsDictionary()) return -1;
+        if (inflater.finished() || inflater.needsDictionary()) {
+          releaseInflatedBytes();
+          return -1;
+        }
         if (sourceExhausted) throw new EOFException("source exhausted prematurely");
       } catch (DataFormatException e) {
         throw new IOException(e);
@@ -91,6 +78,35 @@ public InflaterSource(Source source, Inflater inflater) {
     }
   }
 
+  /**
+   * Refills the inflater with compressed data if it needs input. (And only if
+   * it needs input). Returns true if the inflater required input but the source
+   * was exhausted.
+   */
+  public boolean refill(Deadline deadline) throws IOException {
+    if (!inflater.needsInput()) return false;
+
+    releaseInflatedBytes();
+    if (inflater.getRemaining() != 0) throw new IllegalStateException("?"); // TODO: possible?
+
+    // If there are compressed bytes in the source, assign them to the inflater.
+    if (source.exhausted(deadline)) return true;
+
+    // Assign buffer bytes to the inflater.
+    Segment head = source.buffer.head;
+    bufferBytesHeldByInflater = head.limit - head.pos;
+    inflater.setInput(head.data, head.pos, bufferBytesHeldByInflater);
+    return false;
+  }
+
+  /** When the inflater has processed compressed data, remove it from the buffer. */
+  private void releaseInflatedBytes() {
+    if (bufferBytesHeldByInflater == 0) return;
+    int toRelease = bufferBytesHeldByInflater - inflater.getRemaining();
+    bufferBytesHeldByInflater -= toRelease;
+    source.buffer.skip(toRelease);
+  }
+
   @Override public void close(Deadline deadline) throws IOException {
     if (closed) return;
     inflater.end();
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index 7fd538c92a..8352908499 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -21,6 +21,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
 /**
@@ -53,7 +54,7 @@ public long byteCount() {
     return byteCount;
   }
 
-  /** Reads a byte from the front of this buffer and returns it. */
+  /** Removes a byte from the front of this buffer and returns it. */
   public byte readByte() {
     if (byteCount < 1) throw new IllegalArgumentException("byteCount < 1: " + byteCount);
 
@@ -75,7 +76,17 @@ public byte readByte() {
     return b;
   }
 
-  /** Reads a Big-Endian short from the front of this buffer and returns it. */
+  /** Returns the byte at {@code i}. */
+  public byte getByte(long i) {
+    checkOffsetAndCount(byteCount, i, 1);
+    for (Segment s = head; true; s = s.next) {
+      int segmentByteCount = s.limit - s.pos;
+      if (i < segmentByteCount) return s.data[s.pos + (int) i];
+      i -= segmentByteCount;
+    }
+  }
+
+  /** Removes a Big-Endian short from the front of this buffer and returns it. */
   public short readShort() {
     if (byteCount < 2) throw new IllegalArgumentException("byteCount < 2: " + byteCount);
 
@@ -105,7 +116,7 @@ public short readShort() {
     return (short) s;
   }
 
-  /** Reads a Big-Endian int from the front of this buffer and returns it. */
+  /** Removes a Big-Endian int from the front of this buffer and returns it. */
   public int readInt() {
     if (byteCount < 4) throw new IllegalArgumentException("byteCount < 4: " + byteCount);
 
@@ -138,6 +149,16 @@ public int readInt() {
     return i;
   }
 
+  /** Removes a Little-Endian short from the front of this buffer and returns it. */
+  public int readShortLe() {
+    return Util.reverseBytesShort(readShort());
+  }
+
+  /** Removes a Little-Endian int from the front of this buffer and returns it. */
+  public int readIntLe() {
+    return Util.reverseBytesInt(readInt());
+  }
+
   /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
   public ByteString readByteString(int byteCount) {
     return new ByteString(readBytes(byteCount));
@@ -145,7 +166,25 @@ public ByteString readByteString(int byteCount) {
 
   /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
   public String readUtf8(int byteCount) {
-    return new String(readBytes(byteCount), Util.UTF_8);
+    checkOffsetAndCount(this.byteCount, 0, byteCount);
+    if (byteCount == 0) return "";
+
+    Segment head = this.head;
+    if (head.pos + byteCount > head.limit) {
+      // If the string spans multiple segments, delegate to readBytes().
+      return new String(readBytes(byteCount), Util.UTF_8);
+    }
+
+    String result = new String(head.data, head.pos, byteCount, UTF_8);
+    head.pos += byteCount;
+    this.byteCount -= byteCount;
+
+    if (head.pos == head.limit) {
+      this.head = head.pop();
+      SegmentPool.INSTANCE.recycle(head);
+    }
+
+    return result;
   }
 
   private byte[] readBytes(int byteCount) {
@@ -172,6 +211,32 @@ public String readUtf8(int byteCount) {
     return result;
   }
 
+  /**
+   * Discards all bytes in this buffer. Calling this method when you're done
+   * with a buffer will return its segments to the pool.
+   */
+  public void clear() {
+    skip(byteCount);
+  }
+
+  /** Discards {@code byteCount} bytes from the head of this buffer. */
+  public void skip(long byteCount) {
+    checkOffsetAndCount(this.byteCount, 0, byteCount);
+
+    this.byteCount -= byteCount;
+    while (byteCount > 0) {
+      int toSkip = (int) Math.min(byteCount, head.limit - head.pos);
+      byteCount -= toSkip;
+      head.pos += toSkip;
+
+      if (head.pos == head.limit) {
+        Segment toRecycle = head;
+        head = toRecycle.pop();
+        SegmentPool.INSTANCE.recycle(toRecycle);
+      }
+    }
+  }
+
   /** Appends {@code byteString} to this. */
   public void write(ByteString byteString) {
     write(byteString.data, 0, byteString.data.length);
@@ -195,7 +260,7 @@ void write(byte[] data, int offset, int byteCount) {
       tail.limit += toCopy;
     }
 
-    this.byteCount += data.length;
+    this.byteCount += byteCount;
   }
 
   /** Appends a Big-Endian byte to the end of this buffer. */
@@ -302,14 +367,16 @@ Segment writableSegment(int minimumCapacity) {
     // an equivalent buffer [30%, 62%, 82%] and then move the head segment,
     // yielding sink [51%, 91%, 30%] and source [62%, 82%].
 
-    if (source == this) throw new IllegalArgumentException("source == this");
+    if (source == this) {
+      throw new IllegalArgumentException("source == this");
+    }
     checkOffsetAndCount(source.byteCount, 0, byteCount);
 
     while (byteCount > 0) {
       // Is a prefix of the source's head segment all that we need to move?
       if (byteCount < (source.head.limit - source.head.pos)) {
-        Segment tail = head.prev;
-        if (head == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
+        Segment tail = head != null ? head.prev : null;
+        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
           // We're going to need another segment. Split the source's head
           // segment in two, then move the first of those two to this buffer.
           source.head = source.head.split((int) byteCount);
@@ -352,15 +419,29 @@ Segment writableSegment(int minimumCapacity) {
    * contain {@code b}.
    */
   public long indexOf(byte b) throws IOException {
+    return indexOf(b, 0);
+  }
+
+  /**
+   * Returns the index of {@code b} in this at or beyond {@code fromIndex}, or
+   * -1 if this buffer does not contain {@code b} in that range.
+   */
+  public long indexOf(byte b, long fromIndex) throws IOException {
     Segment s = head;
     if (s == null) return -1L;
     long offset = 0L;
     do {
-      byte[] data = s.data;
-      for (int pos = s.pos, limit = s.limit; pos < limit; pos++) {
-        if (data[pos] == b) return offset + pos - s.pos;
+      int segmentByteCount = s.limit - s.pos;
+      if (fromIndex > segmentByteCount) {
+        fromIndex -= segmentByteCount;
+      } else {
+        byte[] data = s.data;
+        for (long pos = s.pos + fromIndex, limit = s.limit; pos < limit; pos++) {
+          if (data[(int) pos] == b) return offset + pos - s.pos;
+        }
+        fromIndex = 0;
       }
-      offset += s.limit - s.pos;
+      offset += segmentByteCount;
       s = s.next;
     } while (s != head);
     return -1L;
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
index 230ab4c76d..47c185a452 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -134,57 +134,4 @@ public static Source source(final InputStream in) {
       }
     };
   }
-
-  /**
-   * Returns an input stream that reads from {@code source}. This may buffer
-   * data by reading extra data eagerly.
-   */
-  public static InputStream inputStream(final Source source) {
-    return new InputStream() {
-      final OkBuffer buffer = new OkBuffer();
-
-      @Override public int read() throws IOException {
-        if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
-          if (count == -1) return -1;
-        }
-        return buffer.readByte();
-      }
-
-      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
-        checkOffsetAndCount(data.length, offset, byteCount);
-
-        if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
-          if (count == -1) return -1;
-        }
-
-        Segment head = buffer.head;
-        int toCopy = Math.min(byteCount, head.limit - head.pos);
-        System.arraycopy(head.data, head.pos, data, offset, toCopy);
-
-        head.pos += toCopy;
-        buffer.byteCount -= toCopy;
-
-        if (head.pos == head.limit) {
-          buffer.head = head.pop();
-          SegmentPool.INSTANCE.recycle(head);
-        }
-
-        return toCopy;
-      }
-
-      @Override public int available() throws IOException {
-        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
-      }
-
-      @Override public void close() throws IOException {
-        super.close();
-      }
-
-      @Override public String toString() {
-        return "inputStream(" + source + ")";
-      }
-    };
-  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 9d4c233c6a..9eeac7eb48 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -16,9 +16,10 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
 
 /** Reads transport frames for SPDY/3 or HTTP/2. */
@@ -27,7 +28,8 @@
   boolean nextFrame(Handler handler) throws IOException;
 
   public interface Handler {
-    void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
 
     /**
      * Create or update incoming headers, creating the corresponding streams
@@ -71,11 +73,12 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * on a new connection if they are idempotent.
      *
      * @param lastGoodStreamId the last stream ID the peer processed before
-     * sending this message. If {@lastGoodStreamId} is zero, the peer processed no frames.
+     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
+     *     processed no frames.
      * @param errorCode reason for closing the connection.
      * @param debugData only valid for http/2; opaque debug data to send.
      */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData);
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
     /**
      * Notifies that an additional {@code windowSizeIncrement} bytes can be
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 0bd8b06779..418c4310e4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,10 +1,12 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
-import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -13,8 +15,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.squareup.okhttp.internal.Util.asciiLowerCase;
-
 /**
  * Read and write HPACK v05.
  *
@@ -99,8 +99,8 @@ private HpackDraft05() {
   static final class Reader {
     private final Huffman.Codec huffmanCodec;
 
-    private final InputStream in;
     private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private final BufferedSource source;
     private int maxHeaderTableByteCount;
 
     // Visible for testing.
@@ -123,10 +123,10 @@ private HpackDraft05() {
     long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
 
-    Reader(boolean client, int maxHeaderTableByteCount, InputStream in) {
+    Reader(boolean client, int maxHeaderTableByteCount, Source source) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
-      this.in = in;
+      this.source = new BufferedSource(source, new OkBuffer());
     }
 
     int maxHeaderTableByteCount() {
@@ -181,8 +181,8 @@ private int evictToRecoverBytes(int bytesToRecover) {
      * set of emitted headers.
      */
     void readHeaders() throws IOException {
-      while (in.available() > 0) {
-        int b = in.read() & 0xff;
+      while (!source.exhausted(Deadline.NONE)) {
+        int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -333,7 +333,7 @@ private void insertIntoHeaderTable(int index, Header entry) {
     }
 
     private int readByte() throws IOException {
-      return in.read() & 0xff;
+      return source.readByte() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -365,16 +365,24 @@ int readInt(int firstByte, int prefixMask) throws IOException {
     ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
+
+      boolean huffmanDecode = false;
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
         length &= ~0x80;
-        byte[] buff = new byte[length];
-        Util.readFully(in, buff);
-        buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
-        if (asciiLowercase) asciiLowerCase(buff);
-        return ByteString.of(buff);
+        huffmanDecode = true;
+      }
+
+      ByteString byteString = source.readByteString(length);
+
+      if (huffmanDecode) {
+        byteString = huffmanCodec.decode(byteString); // TODO: streaming Huffman!
+      }
+
+      if (asciiLowercase) {
+        byteString = byteString.toAsciiLowercase();
       }
-      return length == 0 ? ByteString.EMPTY
-          : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
+
+      return byteString;
     }
   }
 
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 0bc07a87bf..9f2228a489 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -16,15 +16,17 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
-import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.util.Arrays;
 import java.util.List;
 
 /**
@@ -37,8 +39,8 @@
     return Protocol.HTTP_2;
   }
 
-  private static final byte[] CONNECTION_HEADER =
-      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
+  private static final ByteString CONNECTION_HEADER
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
 
   static final byte TYPE_DATA = 0x0;
   static final byte TYPE_HEADERS = 0x1;
@@ -59,7 +61,7 @@
   static final byte FLAG_PRIORITY = 0x8;
 
   @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, 4096, client);
+    return new Reader(OkBuffers.source(in), 4096, client);
   }
 
   @Override public FrameWriter newWriter(OutputStream out, boolean client) {
@@ -67,40 +69,38 @@
   }
 
   static final class Reader implements FrameReader {
-    private final DataInputStream in;
-    private final ContinuationInputStream continuation;
+    private final BufferedSource source;
+    private final ContinuationSource continuation;
     private final boolean client;
 
     // Visible for testing.
     final HpackDraft05.Reader hpackReader;
 
-    Reader(InputStream in, int headerTableSize, boolean client) {
-      this.in = new DataInputStream(in);
+    Reader(Source source, int headerTableSize, boolean client) {
+      this.source = new BufferedSource(source, new OkBuffer());
       this.client = client;
-      this.continuation = new ContinuationInputStream(this.in);
+      this.continuation = new ContinuationSource(this.source);
       this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
       if (client) return; // Nothing to read; servers don't send connection headers!
-      byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
-      Util.readFully(in, connectionHeader);
-      if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
-        throw ioException("Expected a connection header but was %s",
-            Arrays.toString(connectionHeader));
+      ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
+      if (!CONNECTION_HEADER.equals(connectionHeader)) {
+        throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
       }
     }
 
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
+      int w2;
       try {
-        w1 = in.readInt();
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
 
-      int w2 = in.readInt();
-
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
       short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
       byte type = (byte) ((w1 & 0xff00) >> 8);
@@ -147,7 +147,7 @@
 
         default:
           // Implementations MUST ignore frames of unsupported or unrecognized types.
-          Util.skipByReading(in, length);
+          source.skip(length, Deadline.NONE);
       }
       return true;
     }
@@ -160,7 +160,7 @@ private void readHeaders(Handler handler, short length, byte flags, int streamId
 
       int priority = -1;
       if ((flags & FLAG_PRIORITY) != 0) {
-        priority = in.readInt() & 0x7fffffff;
+        priority = source.readInt() & 0x7fffffff;
         length -= 4; // account for above read.
       }
 
@@ -187,14 +187,14 @@ private void readData(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       boolean inFinished = (flags & FLAG_END_STREAM) != 0;
       // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      handler.data(inFinished, streamId, in, length);
+      handler.data(inFinished, streamId, source, length);
     }
 
     private void readPriority(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       // boolean r = (w1 & 0x80000000) != 0; // Reserved.
       int priority = (w1 & 0x7fffffff);
       handler.priority(streamId, priority);
@@ -204,7 +204,7 @@ private void readRstStream(Handler handler, short length, byte flags, int stream
         throws IOException {
       if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = in.readInt();
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -224,8 +224,8 @@ private void readSettings(Handler handler, short length, byte flags, int streamI
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
       Settings settings = new Settings();
       for (int i = 0; i < length; i += 8) {
-        int w1 = in.readInt();
-        int value = in.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         // int r = (w1 & 0xff000000) >>> 24; // Reserved.
         int id = w1 & 0xffffff;
         settings.set(id, 0, value);
@@ -241,7 +241,7 @@ private void readPushPromise(Handler handler, short length, byte flags, int stre
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
-      int promisedStreamId = in.readInt() & 0x7fffffff;
+      int promisedStreamId = source.readInt() & 0x7fffffff;
       length -= 4; // account for above read.
       List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
@@ -251,8 +251,8 @@ private void readPing(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = in.readInt();
-      int payload2 = in.readInt();
+      int payload1 = source.readInt();
+      int payload2 = source.readInt();
       boolean ack = (flags & FLAG_ACK) != 0;
       handler.ping(ack, payload1, payload2);
     }
@@ -261,17 +261,16 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = in.readInt();
-      int errorCodeInt = in.readInt();
+      int lastStreamId = source.readInt();
+      int errorCodeInt = source.readInt();
       int opaqueDataLength = length - 8;
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      byte[] debugData = Util.EMPTY_BYTE_ARRAY;
+      ByteString debugData = ByteString.EMPTY;
       if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = new byte[opaqueDataLength];
-        Util.readFully(in, debugData);
+        debugData = source.readByteString(opaqueDataLength);
       }
       handler.goAway(lastStreamId, errorCode, debugData);
     }
@@ -279,13 +278,13 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
     private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (in.readInt() & 0x7fffffff);
+      long increment = (source.readInt() & 0x7fffffff);
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
       handler.windowUpdate(streamId, increment);
     }
 
     @Override public void close() throws IOException {
-      in.close();
+      source.close(Deadline.NONE);
     }
   }
 
@@ -316,7 +315,7 @@ private void readWindowUpdate(Handler handler, short length, byte flags, int str
 
     @Override public synchronized void connectionHeader() throws IOException {
       if (!client) return; // Nothing to write; servers don't send connection headers!
-      out.write(CONNECTION_HEADER);
+      out.write(CONNECTION_HEADER.toByteArray());
       out.flush();
     }
 
@@ -477,11 +476,12 @@ private static IOException ioException(String message, Object... args) throws IO
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer.  This class lazily reads
-   * continuation frames as they are needed by {@link HpackDraft05.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer. This
+   * class lazily reads continuation frames as they are needed by {@link
+   * HpackDraft05.Reader#readHeaders()}.
    */
-  static final class ContinuationInputStream extends InputStream {
-    private final DataInputStream in;
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
 
     int length;
     byte flags;
@@ -489,65 +489,31 @@ private static IOException ioException(String message, Object... args) throws IO
 
     int left;
 
-    ContinuationInputStream(DataInputStream in) {
-      this.in = in;
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
     }
 
-    @Override public int read() throws IOException {
-      if (left == 0) {
-        if (endHeaders()) {
-          throw eofReading(1);
-        } else {
-          readContinuationHeader();
-        }
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+        throws IOException {
+      while (left == 0) {
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
       }
-      left--;
-      return in.read();
-    }
 
-    @Override public int available() throws IOException {
-      if (left == 0) {
-        if (endHeaders()) {
-          return 0;
-        } else {
-          readContinuationHeader();
-        }
-      }
-      return left;
-    }
-
-    @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
-      if (byteCount > left) {
-        if (endHeaders()) {
-          throw eofReading(byteCount);
-        } else {
-          int beforeContinuation = left;
-          Util.readFully(in, dst, offset, beforeContinuation);
-          readContinuationHeader();
-          int afterContinuation = byteCount - beforeContinuation;
-          offset += beforeContinuation;
-          Util.readFully(in, dst, offset, afterContinuation);
-          left -= afterContinuation;
-          return byteCount;
-        }
-      } else {
-        Util.readFully(in, dst, offset, byteCount);
-        left -= byteCount;
-        return byteCount;
-      }
+      long read = source.read(sink, Math.min(byteCount, left), deadline);
+      if (read == -1) return -1;
+      left -= read;
+      return read;
     }
 
-    private EOFException eofReading(int byteCount) throws EOFException {
-      int read = length - left;
-      throw new EOFException(
-          String.format("EOF reading %s more bytes; read %s/%s of frame.", byteCount, read,
-              length));
+    @Override public void close(Deadline deadline) throws IOException {
     }
 
     private void readContinuationHeader() throws IOException {
       int previousStreamId = streamId;
-      int w1 = in.readInt();
-      int w2 = in.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       length = left = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
@@ -555,9 +521,5 @@ private void readContinuationHeader() throws IOException {
       if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
       if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
     }
-
-    private boolean endHeaders() {
-      return (flags & FLAG_END_HEADERS) != 0;
-    }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index a7768d0ae3..d59f528d77 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -84,6 +85,10 @@ int encodedLength(byte[] bytes) {
       return (int) ((len + 7) >> 3);
     }
 
+    ByteString decode(ByteString buf) throws IOException {
+      return ByteString.of(decode(buf.toByteArray()));
+    }
+
     byte[] decode(byte[] buf) throws IOException {
       // FIXME
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 0d6d6bf7d7..b78ac60f34 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -1,16 +1,16 @@
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.Util;
-import java.io.Closeable;
-import java.io.DataInputStream;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.InflaterSource;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
 
 /**
  * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
@@ -18,29 +18,35 @@
  * buffer. We need to put all compressed bytes into that buffer -- but no other
  * bytes.
  */
-class NameValueBlockReader implements Closeable {
-  private final DataInputStream headerBlockIn;
-  private final FillableInflaterInputStream fillableInflaterInputStream;
+class NameValueBlockReader {
+  /** This source transforms compressed bytes into uncompressed bytes. */
+  private final InflaterSource inflaterSource;
+
+  /**
+   * How many compressed bytes must be read into inflaterSource before
+   * {@link #readNameValueBlock} returns.
+   */
   private int compressedLimit;
 
-  NameValueBlockReader(final InputStream in) {
-    // Limit the inflater input stream to only those bytes in the Name/Value block. We cut the
-    // inflater off at its source because we can't predict the ratio of compressed bytes to
-    // uncompressed bytes.
-    InputStream throttleStream = new InputStream() {
-      @Override public int read() throws IOException {
-        return Util.readSingleByte(this);
+  /** This source holds inflated bytes. */
+  private final BufferedSource source;
+
+  public NameValueBlockReader(final BufferedSource source) {
+    // Limit the inflater input stream to only those bytes in the Name/Value
+    // block. We cut the inflater off at its source because we can't predict the
+    // ratio of compressed bytes to uncompressed bytes.
+    Source throttleSource = new Source() {
+      @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+          throws IOException {
+        if (compressedLimit == 0) return -1; // Out of data for the current block.
+        long read = source.read(sink, Math.min(byteCount, compressedLimit), deadline);
+        if (read == -1) return -1;
+        compressedLimit -= read;
+        return read;
       }
 
-      @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
-        byteCount = Math.min(byteCount, compressedLimit);
-        int consumed = in.read(buffer, offset, byteCount);
-        compressedLimit -= consumed;
-        return consumed;
-      }
-
-      @Override public void close() throws IOException {
-        in.close();
+      @Override public void close(Deadline deadline) throws IOException {
+        source.close(deadline);
       }
     };
 
@@ -57,56 +63,45 @@
       }
     };
 
-    fillableInflaterInputStream = new FillableInflaterInputStream(throttleStream, inflater);
-    headerBlockIn = new DataInputStream(fillableInflaterInputStream);
-  }
-
-  /** Extend the inflater stream so we can eagerly fill the compressed bytes buffer if necessary. */
-  static class FillableInflaterInputStream extends InflaterInputStream {
-    public FillableInflaterInputStream(InputStream in, Inflater inf) {
-      super(in, inf);
-    }
-
-    @Override public void fill() throws IOException {
-      super.fill(); // This method is protected in the superclass.
-    }
+    this.inflaterSource = new InflaterSource(throttleSource, inflater);
+    this.source = new BufferedSource(inflaterSource, new OkBuffer());
   }
 
   public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
-    int numberOfPairs = headerBlockIn.readInt();
-    if (numberOfPairs < 0) {
-      throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    }
-    if (numberOfPairs > 1024) {
-      throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-    }
+
+    int numberOfPairs = source.readInt();
+    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+
     List<Header> entries = new ArrayList<Header>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = ByteString.readLowerCase(headerBlockIn, headerBlockIn.readInt());
-      ByteString values = ByteString.read(headerBlockIn, headerBlockIn.readInt());
+      ByteString name = readByteString().toAsciiLowercase();
+      ByteString values = readByteString();
       if (name.size() == 0) throw new IOException("name.size == 0");
       entries.add(new Header(name, values));
     }
 
     doneReading();
-
     return entries;
   }
 
-  private void doneReading() throws IOException {
-    if (compressedLimit == 0) return;
-
-    // Read any outstanding unread bytes. One side-effect of deflate compression is that sometimes
-    // there are bytes remaining in the stream after we've consumed all of the content.
-    fillableInflaterInputStream.fill();
+  private ByteString readByteString() throws IOException {
+    int length = source.readInt();
+    return source.readByteString(length);
+  }
 
-    if (compressedLimit != 0) {
-      throw new IOException("compressedLimit > 0: " + compressedLimit);
+  private void doneReading() throws IOException {
+    // Move any outstanding unread bytes into the inflater. One side-effect of
+    // deflate compression is that sometimes there are bytes remaining in the
+    // stream after we've consumed all of the content.
+    if (compressedLimit > 0) {
+      inflaterSource.refill(Deadline.NONE);
+      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
     }
   }
 
-  @Override public void close() throws IOException {
-    headerBlockIn.close();
+  public void close(Deadline deadline) throws IOException {
+    source.close(deadline);
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 75afc37555..e97aeac1d7 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -18,9 +18,13 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,8 +32,6 @@
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.zip.Deflater;
 
 /**
@@ -99,7 +101,7 @@
   }
 
   @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
+    return new Reader(OkBuffers.source(in), client);
   }
 
   @Override public FrameWriter newWriter(OutputStream out, boolean client) {
@@ -108,13 +110,13 @@
 
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
-    private final DataInputStream in;
+    private final BufferedSource source;
     private final boolean client;
     private final NameValueBlockReader headerBlockReader;
 
-    Reader(InputStream in, boolean client) {
-      this.in = new DataInputStream(in);
-      this.headerBlockReader = new NameValueBlockReader(in);
+    Reader(Source source, boolean client) {
+      this.source = new BufferedSource(source, new OkBuffer());
+      this.headerBlockReader = new NameValueBlockReader(this.source);
       this.client = client;
     }
 
@@ -127,12 +129,13 @@
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
+      int w2;
       try {
-        w1 = in.readInt();
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
-      int w2 = in.readInt();
 
       boolean control = (w1 & 0x80000000) != 0;
       int flags = (w2 & 0xff000000) >>> 24;
@@ -180,23 +183,21 @@
             return true;
 
           default:
-            Logger logger = Logger.getLogger("com.squareup.okhttp.internal.spdy.Spdy3");
-            logger.log(Level.INFO, "Ignoring unknown frame type " + type);
-            Util.skipByReading(in, length);
+            source.skip(length, Deadline.NONE);
             return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
         boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, in, length);
+        handler.data(inFinished, streamId, source, length);
         return true;
       }
     }
 
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
-      int w2 = in.readInt();
-      int s3 = in.readShort();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
+      int s3 = source.readShort();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
@@ -210,7 +211,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
@@ -219,8 +220,8 @@ private void readSynReply(Handler handler, int flags, int length) throws IOExcep
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int streamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -229,7 +230,7 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     }
 
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
@@ -237,8 +238,8 @@ private void readHeaders(Handler handler, int flags, int length) throws IOExcept
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = in.readInt();
-      int w2 = in.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       long increment = w2 & 0x7fffffff;
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
@@ -247,31 +248,31 @@ private void readWindowUpdate(Handler handler, int flags, int length) throws IOE
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = in.readInt();
+      int id = source.readInt();
       boolean ack = client == ((id & 1) == 1);
       handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int lastGoodStreamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      handler.goAway(lastGoodStreamId, errorCode, Util.EMPTY_BYTE_ARRAY);
+      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = in.readInt();
+      int numberOfEntries = source.readInt();
       if (length != 4 + 8 * numberOfEntries) {
         throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
       }
       Settings settings = new Settings();
       for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = in.readInt();
-        int value = in.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         int idFlags = (w1 & 0xff000000) >>> 24;
         int id = w1 & 0xffffff;
         settings.set(id, idFlags, value);
@@ -285,7 +286,7 @@ private static IOException ioException(String message, Object... args) throws IO
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, headerBlockReader);
+      headerBlockReader.close(Deadline.NONE);
     }
   }
 
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index daec4ce2ae..c4bc9ff08e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -18,6 +18,9 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -444,14 +447,6 @@ public void sendConnectionHeader() throws IOException {
     frameWriter.settings(okHttpSettings);
   }
 
-  /**
-   * Reads a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
-   */
-  public void readConnectionHeader() throws IOException {
-    frameReader.readConnectionHeader();
-  }
-
   public static class Builder {
     private String hostName;
     private InputStream in;
@@ -515,6 +510,9 @@ private Reader() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
+        if (!client) {
+          frameReader.readConnectionHeader();
+        }
         while (frameReader.nextFrame(this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
@@ -530,15 +528,15 @@ private Reader() {
       }
     }
 
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       SpdyStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-        Util.skipByReading(in, length);
+        source.skip(length, Deadline.NONE);
         return;
       }
-      dataStream.receiveData(in, length);
+      dataStream.receiveData(source, length);
       if (inFinished) {
         dataStream.receiveFin();
       }
@@ -665,8 +663,8 @@ private void ackSettingsLater() {
       }
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
-      if (debugData.length > 0) { // TODO: log the debugData
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (debugData.size() > 0) { // TODO: log the debugData
       }
       synchronized (SpdyConnection.this) {
         shutdown = true;
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index e36c8ebadf..8166cb953e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -17,6 +17,11 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Source;
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -35,9 +40,9 @@
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application
-   * (with {@link SpdyDataInputStream#read}), but not yet acknowledged by
-   * sending a {@code WINDOW_UPDATE} frame on this stream.
+   * The total number of bytes consumed by the application (with {@link
+   * SpdyDataSource#read}), but not yet acknowledged by sending a {@code
+   * WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
@@ -61,7 +66,8 @@
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
   private List<Header> responseHeaders;
 
-  private final SpdyDataInputStream in;
+  private final SpdyDataSource source;
+  private final InputStream in;
   final SpdyDataOutputStream out;
 
   /**
@@ -78,9 +84,10 @@
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow = connection.peerSettings.getInitialWindowSize();
-    this.in = new SpdyDataInputStream(connection.okHttpSettings.getInitialWindowSize());
+    this.source = new SpdyDataSource(connection.okHttpSettings.getInitialWindowSize());
+    this.in = new BufferedSource(source, new OkBuffer()).inputStream();
     this.out = new SpdyDataOutputStream();
-    this.in.finished = inFinished;
+    this.source.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
     this.requestHeaders = requestHeaders;
@@ -100,7 +107,9 @@ public synchronized boolean isOpen() {
     if (errorCode != null) {
       return false;
     }
-    if ((in.finished || in.closed) && (out.finished || out.closed) && responseHeaders != null) {
+    if ((source.finished || source.closed)
+        && (out.finished || out.closed)
+        && responseHeaders != null) {
       return false;
     }
     return true;
@@ -251,7 +260,7 @@ private boolean closeInternal(ErrorCode errorCode) {
       if (this.errorCode != null) {
         return false;
       }
-      if (in.finished && out.finished) {
+      if (source.finished && out.finished) {
         return false;
       }
       this.errorCode = errorCode;
@@ -292,16 +301,16 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
     }
   }
 
-  void receiveData(InputStream in, int length) throws IOException {
+  void receiveData(BufferedSource in, int length) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
-    this.in.receive(in, length);
+    this.source.receive(in, length);
   }
 
   void receiveFin() {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean open;
     synchronized (this) {
-      this.in.finished = true;
+      this.source.finished = true;
       open = isOpen();
       notifyAll();
     }
@@ -322,36 +331,19 @@ int getPriority() {
   }
 
   /**
-   * An input stream that reads the incoming data frames of a stream. Although
-   * this class uses synchronization to safely receive incoming data frames,
-   * it is not intended for use by multiple readers.
+   * A source that reads the incoming data frames of a stream. Although this
+   * class uses synchronization to safely receive incoming data frames, it is
+   * not intended for use by multiple readers.
    */
-  private final class SpdyDataInputStream extends InputStream {
-
-    // Store incoming data bytes in a circular buffer. When the buffer is
-    // empty, pos == -1. Otherwise pos is the first byte to read and limit
-    // is the first byte to write.
-    //
-    // { - - - X X X X - - - }
-    //         ^       ^
-    //        pos    limit
-    //
-    // { X X X - - - - X X X }
-    //         ^       ^
-    //       limit    pos
-    private final byte[] buffer;
-
-    private SpdyDataInputStream(int bufferLength) {
-      // TODO: We probably need to change to growable buffers here pretty soon.
-      // Otherwise we have a performance problem where we pay for 64 KiB even if we aren't using it.
-      buffer = connection.bufferPool.getBuf(bufferLength);
-    }
+  private final class SpdyDataSource implements Source {
+    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
+    private final OkBuffer receiveBuffer = new OkBuffer();
 
-    /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
-    private int pos = -1;
+    /** Buffer with readable data. Guarded by SpdyStream.this. */
+    private final OkBuffer readBuffer = new OkBuffer();
 
-    /** the last byte to be read. Never buffer.length */
-    private int limit;
+    /** Maximum number of bytes to buffer before reporting a flow control error. */
+    private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
     private boolean closed;
@@ -362,75 +354,42 @@ private SpdyDataInputStream(int bufferLength) {
      */
     private boolean finished;
 
-    @Override public int available() throws IOException {
-      synchronized (SpdyStream.this) {
-        checkNotClosed();
-        if (pos == -1) {
-          return 0;
-        } else if (limit > pos) {
-          return limit - pos;
-        } else {
-          return limit + (buffer.length - pos);
-        }
-      }
+    private SpdyDataSource(long maxByteCount) {
+      this.maxByteCount = maxByteCount;
     }
 
-    @Override public int read() throws IOException {
-      return Util.readSingleByte(this);
-    }
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-    @Override public int read(byte[] b, int offset, int count) throws IOException {
-      int copied = 0;
+      long read;
       synchronized (SpdyStream.this) {
-        checkOffsetAndCount(b.length, offset, count);
         waitUntilReadable();
         checkNotClosed();
+        if (readBuffer.byteCount() == 0) return -1; // This source is exhausted.
 
-        if (pos == -1) {
-          return -1;
-        }
-
-        // drain from [pos..buffer.length)
-        if (limit <= pos) {
-          int bytesToCopy = Math.min(count, buffer.length - pos);
-          System.arraycopy(buffer, pos, b, offset, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-          if (pos == buffer.length) {
-            pos = 0;
-          }
-        }
-
-        // drain from [pos..limit)
-        if (copied < count) {
-          int bytesToCopy = Math.min(limit - pos, count - copied);
-          System.arraycopy(buffer, pos, b, offset + copied, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-        }
+        // Move bytes from the read buffer into the caller's buffer.
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.byteCount()), deadline);
 
         // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += copied;
+        unacknowledgedBytesRead += read;
         if (unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
-
-        if (pos == limit) {
-          pos = -1;
-          limit = 0;
-        }
       }
+
       // Update connection.unacknowledgedBytesRead outside the stream lock.
       synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += copied;
+        connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
             >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
       }
-      return copied;
+
+      return read;
     }
 
     /**
@@ -446,7 +405,7 @@ private void waitUntilReadable() throws IOException {
         remaining = readTimeoutMillis;
       }
       try {
-        while (pos == -1 && !finished && !closed && errorCode == null) {
+        while (readBuffer.byteCount() == 0 && !finished && !closed && errorCode == null) {
           if (readTimeoutMillis == 0) {
             SpdyStream.this.wait();
           } else if (remaining > 0) {
@@ -461,71 +420,51 @@ private void waitUntilReadable() throws IOException {
       }
     }
 
-    void receive(InputStream in, int byteCount) throws IOException {
+    void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
 
-      if (byteCount == 0) {
-        return;
-      }
-
-      int pos;
-      int limit;
-      int firstNewByte;
-      boolean finished;
-      boolean flowControlError;
-      synchronized (SpdyStream.this) {
-        finished = this.finished;
-        pos = this.pos;
-        firstNewByte = this.limit;
-        limit = this.limit;
-        flowControlError = byteCount > buffer.length - available();
-      }
-
-      // If the peer sends more data than we can handle, discard it and close the connection.
-      if (flowControlError) {
-        Util.skipByReading(in, byteCount);
-        closeLater(ErrorCode.FLOW_CONTROL_ERROR);
-        return;
-      }
+      while (byteCount > 0) {
+        boolean finished;
+        boolean flowControlError;
+        synchronized (SpdyStream.this) {
+          finished = this.finished;
+          flowControlError = byteCount + readBuffer.byteCount() > maxByteCount;
+        }
 
-      // Discard data received after the stream is finished. It's probably a benign race.
-      if (finished) {
-        Util.skipByReading(in, byteCount);
-        return;
-      }
+        // If the peer sends more data than we can handle, discard it and close the connection.
+        if (flowControlError) {
+          in.skip(byteCount, Deadline.NONE);
+          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+          return;
+        }
 
-      // Fill the buffer without holding any locks. First fill [limit..buffer.length) if that
-      // won't overwrite unread data. Then fill [limit..pos). We can't hold a lock, otherwise
-      // writes will be blocked until reads complete.
-      if (pos < limit) {
-        int firstCopyCount = Math.min(byteCount, buffer.length - limit);
-        Util.readFully(in, buffer, limit, firstCopyCount);
-        limit += firstCopyCount;
-        byteCount -= firstCopyCount;
-        if (limit == buffer.length) {
-          limit = 0;
+        // Discard data received after the stream is finished. It's probably a benign race.
+        if (finished) {
+          in.skip(byteCount, Deadline.NONE);
+          return;
         }
-      }
-      if (byteCount > 0) {
-        Util.readFully(in, buffer, limit, byteCount);
-        limit += byteCount;
-      }
 
-      synchronized (SpdyStream.this) {
-        // Update the new limit, and mark the position as readable if necessary.
-        this.limit = limit;
-        if (this.pos == -1) {
-          this.pos = firstNewByte;
-          SpdyStream.this.notifyAll();
+        // Fill the receive buffer without holding any locks.
+        long read = in.read(receiveBuffer, byteCount, Deadline.NONE);
+        if (read == -1) throw new EOFException();
+        byteCount -= read;
+
+        // Move the received data to the read buffer to the reader can read it.
+        synchronized (SpdyStream.this) {
+          boolean wasEmpty = readBuffer.byteCount() == 0;
+          readBuffer.write(receiveBuffer, receiveBuffer.byteCount(), Deadline.NONE);
+          if (wasEmpty) {
+            SpdyStream.this.notifyAll();
+          }
         }
       }
     }
 
-    @Override public void close() throws IOException {
+    @Override public void close(Deadline deadline) throws IOException {
       synchronized (SpdyStream.this) {
         closed = true;
+        readBuffer.clear();
         SpdyStream.this.notifyAll();
-        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       cancelStreamIfNecessary();
     }
@@ -545,7 +484,7 @@ private void cancelStreamIfNecessary() throws IOException {
     boolean open;
     boolean cancel;
     synchronized (this) {
-      cancel = !in.finished && in.closed && (out.finished || out.closed);
+      cancel = !source.finished && source.closed && (out.finished || out.closed);
       open = isOpen();
     }
     if (cancel) {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
index 34d37e049c..dabb3d1f17 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -24,6 +24,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 public class ByteStringTest {
@@ -76,6 +77,19 @@
     assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
   }
 
+  @Test public void toAsciiLowerCaseNoUppercase() throws Exception {
+    ByteString s = ByteString.encodeUtf8("a1_+");
+    assertSame(s, s.toAsciiLowercase());
+  }
+
+  @Test public void toAsciiAllUppercase() throws Exception {
+    assertEquals(ByteString.encodeUtf8("ab"), ByteString.encodeUtf8("AB").toAsciiLowercase());
+  }
+
+  @Test public void toAsciiStartsLowercaseEndsUppercase() throws Exception {
+    assertEquals(ByteString.encodeUtf8("abcd"), ByteString.encodeUtf8("abCD").toAsciiLowercase());
+  }
+
   @Test public void write() throws Exception {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
new file mode 100644
index 0000000000..d4b59b6c07
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.zip.CRC32;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class GzipSourceTest {
+
+  @Test public void gunzip() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader, 0, gzipHeader.length);
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withHCRC() throws Exception {
+    CRC32 hcrc = new CRC32();
+    hcrc.update(gzipHeaderWithFlags((byte) 0x02));
+
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x02), 0, gzipHeader.length);
+    gzipped.writeShort(Util.reverseBytesShort((short) hcrc.getValue())); // little endian
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withExtra() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x04), 0, gzipHeader.length);
+    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
+    gzipped.write("blubber".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withName() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x08), 0, gzipHeader.length);
+    gzipped.write("foo.txt".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withComment() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x10), 0, gzipHeader.length);
+    gzipped.write("rubbish".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  /**
+   * For portability, it is a good idea to export the gzipped bytes and try running gzip.  Ex.
+   * {@code echo gzipped | base64 --decode | gzip -l -v}
+   */
+  @Test public void gunzip_withAll() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x1c), 0, gzipHeader.length);
+    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
+    gzipped.write("blubber".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.write("foo.txt".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write("rubbish".getBytes(Util.US_ASCII), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    assertGzipped(gzipped);
+  }
+
+  private void assertGzipped(OkBuffer gzipped) throws IOException {
+    OkBuffer gunzipped = gunzip(gzipped);
+    assertEquals("It's a UNIX system! I know this!",
+        gunzipped.readUtf8((int) gunzipped.byteCount()));
+  }
+
+  /**
+   * Note that you cannot test this with old versions of gzip, as they interpret flag bit 1 as
+   * CONTINUATION, not HCRC. For example, this is the case with the default gzip on osx.
+   */
+  @Test public void gunzipWhenHeaderCRCIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x02), 0, gzipHeader.length);
+    gzipped.writeShort((short) 0); // wrong HCRC!
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FHCRC: actual 0x0000261d != expected 0x00000000", e.getMessage());
+    }
+  }
+
+  @Test public void gunzipWhenCRCIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader, 0, gzipHeader.length);
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.writeInt(Util.reverseBytesInt(0x1234567)); // wrong CRC
+    gzipped.write(gzipTrailer, 3, 4);
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("CRC: actual 0x37ad8f8d != expected 0x01234567", e.getMessage());
+    }
+  }
+
+  @Test public void gunzipWhenLengthIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader, 0, gzipHeader.length);
+    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipTrailer, 0, 4);
+    gzipped.writeInt(Util.reverseBytesInt(0x123456)); // wrong length
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("ISIZE: actual 0x00000020 != expected 0x00123456", e.getMessage());
+    }
+  }
+
+  private byte[] gzipHeaderWithFlags(byte flags) {
+    byte[] result = Arrays.copyOf(gzipHeader, gzipHeader.length);
+    result[3] = flags;
+    return result;
+  }
+
+  private final byte[] gzipHeader = new byte[] {
+      (byte) 0x1f, (byte) 0x8b, (byte) 0x08, 0, 0, 0, 0, 0, 0, 0
+  };
+
+  // deflated "It's a UNIX system! I know this!"
+  private final byte[] deflated = new byte[] {
+      (byte) 0xf3, (byte) 0x2c, (byte) 0x51, (byte) 0x2f, (byte) 0x56, (byte) 0x48, (byte) 0x54,
+      (byte) 0x08, (byte) 0xf5, (byte) 0xf3, (byte) 0x8c, (byte) 0x50, (byte) 0x28, (byte) 0xae,
+      (byte) 0x2c, (byte) 0x2e, (byte) 0x49, (byte) 0xcd, (byte) 0x55, (byte) 0x54, (byte) 0xf0,
+      (byte) 0x54, (byte) 0xc8, (byte) 0xce, (byte) 0xcb, (byte) 0x2f, (byte) 0x57, (byte) 0x28,
+      (byte) 0xc9, (byte) 0xc8, (byte) 0x2c, (byte) 0x56, (byte) 0x04, (byte) 0x00
+  };
+
+  private final byte[] gzipTrailer = new byte[] {
+      (byte) 0x8d, (byte) 0x8f, (byte) 0xad, (byte) 0x37, // checksum of deflated
+      0x20, 0, 0, 0, // 32 in little endian
+  };
+
+  private OkBuffer gunzip(OkBuffer gzipped) throws IOException {
+    OkBuffer result = new OkBuffer();
+    GzipSource source = new GzipSource(gzipped);
+    while (source.read(result, Integer.MAX_VALUE, Deadline.NONE) != -1) {
+    }
+    return result;
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
index df07f65649..aeb3a12c62 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.bytes;
 
 import com.squareup.okhttp.internal.Base64;
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index eedb9def75..1b96890cb7 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -17,6 +17,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -47,6 +48,19 @@
     }
   }
 
+  @Test public void readUtf8SpansSegments() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 2));
+    buffer.readUtf8(Segment.SIZE - 1);
+    assertEquals("aa", buffer.readUtf8(2));
+  }
+
+  @Test public void readUtf8EntireBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE));
+    assertEquals(repeat('a', Segment.SIZE), buffer.readUtf8(Segment.SIZE));
+  }
+
   @Test public void bufferToString() throws Exception {
     OkBuffer buffer = new OkBuffer();
     buffer.writeUtf8("\u0000\u0001\u0002\u007f");
@@ -280,6 +294,23 @@
     assertEquals(-1, buffer.indexOf((byte) 'e'));
   }
 
+  @Test public void indexOfWithOffset() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    int halfSegment = Segment.SIZE / 2;
+    buffer.writeUtf8(repeat('a', halfSegment));
+    buffer.writeUtf8(repeat('b', halfSegment));
+    buffer.writeUtf8(repeat('c', halfSegment));
+    buffer.writeUtf8(repeat('d', halfSegment));
+    assertEquals(0, buffer.indexOf((byte) 'a', 0));
+    assertEquals(halfSegment - 1, buffer.indexOf((byte) 'a', halfSegment - 1));
+    assertEquals(halfSegment, buffer.indexOf((byte) 'b', halfSegment - 1));
+    assertEquals(halfSegment * 2, buffer.indexOf((byte) 'c', halfSegment - 1));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment - 1));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 2));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 3));
+    assertEquals(halfSegment * 4 - 1, buffer.indexOf((byte) 'd', halfSegment * 4 - 1));
+  }
+
   @Test public void sinkFromOutputStream() throws Exception {
     OkBuffer data = new OkBuffer();
     data.writeUtf8("a");
@@ -353,7 +384,7 @@
     source.writeUtf8(repeat('b', Segment.SIZE));
     source.writeUtf8("c");
 
-    InputStream in = OkBuffers.inputStream(source);
+    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
     assertEquals(0, in.available());
     assertEquals(Segment.SIZE + 2, source.byteCount());
 
@@ -386,7 +417,7 @@
   @Test public void inputStreamFromSourceBounds() throws IOException {
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', 100));
-    InputStream in = OkBuffers.inputStream(source);
+    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
     try {
       in.read(new byte[100], 50, 51);
       fail();
@@ -448,8 +479,8 @@
   @Test public void readByte() throws Exception {
     OkBuffer data = new OkBuffer();
     data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
-    assertEquals((byte) 0xab, data.readByte());
-    assertEquals((byte) 0xcd, data.readByte());
+    assertEquals(0xab, data.readByte() & 0xff);
+    assertEquals(0xcd, data.readByte() & 0xff);
     assertEquals(0, data.byteCount());
   }
 
@@ -494,6 +525,130 @@
     assertEquals(0, data.byteCount());
   }
 
+  @Test public void byteAt() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("a");
+    buffer.writeUtf8(repeat('b', Segment.SIZE));
+    buffer.writeUtf8("c");
+    assertEquals('a', buffer.getByte(0));
+    assertEquals('a', buffer.getByte(0)); // getByte doesn't mutate!
+    assertEquals('c', buffer.getByte(buffer.byteCount - 1));
+    assertEquals('b', buffer.getByte(buffer.byteCount - 2));
+    assertEquals('b', buffer.getByte(buffer.byteCount - 3));
+  }
+
+  @Test public void getByteOfEmptyBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    try {
+      buffer.getByte(0);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void skip() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("a");
+    buffer.writeUtf8(repeat('b', Segment.SIZE));
+    buffer.writeUtf8("c");
+    buffer.skip(1);
+    assertEquals('b', buffer.readByte() & 0xff);
+    buffer.skip(Segment.SIZE - 2);
+    assertEquals('b', buffer.readByte() & 0xff);
+    buffer.skip(1);
+    assertEquals(0, buffer.byteCount());
+  }
+
+  @Test public void testWritePrefixToEmptyBuffer() {
+    OkBuffer sink = new OkBuffer();
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("abcd");
+    sink.write(source, 2, Deadline.NONE);
+    assertEquals("ab", sink.readUtf8(2));
+  }
+
+  @Test public void requireTracksBufferFirst() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("bb");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("aa");
+
+    bufferedSource.require(2, Deadline.NONE);
+    assertEquals(2, bufferedSource.buffer.byteCount());
+    assertEquals(2, source.byteCount());
+  }
+
+  @Test public void requireIncludesBufferBytes() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("b");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("a");
+
+    bufferedSource.require(2, Deadline.NONE);
+    assertEquals("ab", bufferedSource.buffer.readUtf8(2));
+  }
+
+  @Test public void requireInsufficientData() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+
+    try {
+      bufferedSource.require(2, Deadline.NONE);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void requireReadsOneSegmentAtATime() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE));
+    source.writeUtf8(repeat('b', Segment.SIZE));
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+
+    bufferedSource.require(2, Deadline.NONE);
+    assertEquals(Segment.SIZE, source.byteCount());
+    assertEquals(Segment.SIZE, bufferedSource.buffer.byteCount());
+  }
+
+  @Test public void skipInsufficientData() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    try {
+      bufferedSource.skip(2, Deadline.NONE);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void skipReadsOneSegmentAtATime() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE));
+    source.writeUtf8(repeat('b', Segment.SIZE));
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.skip(2, Deadline.NONE);
+    assertEquals(Segment.SIZE, source.byteCount());
+    assertEquals(Segment.SIZE - 2, bufferedSource.buffer.byteCount());
+  }
+
+  @Test public void skipTracksBufferFirst() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("bb");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("aa");
+
+    bufferedSource.skip(2, Deadline.NONE);
+    assertEquals(0, bufferedSource.buffer.byteCount());
+    assertEquals(2, source.byteCount());
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 6dfc1e9a4c..e990a8ffdb 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -15,14 +15,15 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
 
 import static org.junit.Assert.fail;
 
 class BaseTestHandler implements FrameReader.Handler {
-  @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
       throws IOException {
     fail();
   }
@@ -49,13 +50,11 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override
-  public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
     fail();
   }
 
-  @Override
-  public void windowUpdate(int streamId, long windowSizeIncrement) {
+  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
     fail();
   }
 
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
deleted file mode 100644
index 67b53223de..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.TYPE_DATA;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class ContinuationInputStreamTest {
-  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
-  private final ContinuationInputStream continuation =
-      new ContinuationInputStream(new DataInputStream(bytesIn));
-
-  @Test public void readCantOverrunHeaderPayload() throws IOException {
-    bytesIn.set(onlyHeadersPayloadFollowedByData());
-
-    continuation.length = continuation.left = 3;
-    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read());
-    assertEquals(3, continuation.read());
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readCantOverrunHeaderContinuationPayload() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read());
-    assertEquals(3, continuation.read());
-    assertEquals(0, continuation.available());
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void availableWithContinuation() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read()); // exhaust frame one
-
-    assertEquals(0, continuation.left);
-    assertEquals(1, continuation.available()); // lazy reads next
-
-    assertEquals(1, continuation.length);
-    assertEquals(1, continuation.left);
-    assertEquals(3, continuation.read());
-
-    assertEquals(0, continuation.available());
-    assertEquals(0, continuation.left);
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readArrayCantOverrunHeaderPayload() throws IOException {
-    bytesIn.set(onlyHeadersPayloadFollowedByData());
-
-    continuation.length = continuation.left = 3;
-    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
-    continuation.streamId = 12345;
-
-    byte[] buff = new byte[3];
-    assertEquals(3, continuation.read(buff));
-    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
-
-    try {
-      continuation.read(buff);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readArrayCantOverrunHeaderContinuationPayload() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    byte[] buff = new byte[3];
-    assertEquals(3, continuation.read(buff));
-    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
-
-    try {
-      continuation.read(buff);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  static byte[] onlyHeadersPayloadFollowedByData() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-    dataOut.write(new byte[] {1, 2, 3});
-    dataOut.writeShort(0);
-    dataOut.write(TYPE_DATA);
-    dataOut.write(FLAG_END_STREAM);
-    dataOut.writeInt(0xFFFFFFFF);
-    return out.toByteArray();
-  }
-
-  static byte[] headersPayloadWithContinuationFollowedByData() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-    dataOut.write(new byte[] {1, 2});
-    dataOut.writeShort(1);
-    dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-    dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-    dataOut.writeInt(12345);
-    dataOut.write(3);
-    dataOut.writeShort(0);
-    dataOut.write(TYPE_DATA);
-    dataOut.write(FLAG_END_STREAM);
-    dataOut.writeInt(0xFFFFFFFF);
-    return out.toByteArray();
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 5f011835fa..45301e711b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -30,7 +31,6 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 public class HpackDraft05Test {
@@ -795,12 +795,12 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
-    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
   private HpackDraft05.Reader newReader(InputStream input) {
-    return new HpackDraft05.Reader(false, 4096, input);
+    return new HpackDraft05.Reader(false, 4096, OkBuffers.source(input));
   }
 
   private InputStream byteStream(int... bytes) {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 8023734130..be9e4e8a34 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -16,11 +16,12 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
@@ -347,14 +348,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     FrameReader fr = newReader(out);
 
     fr.nextFrame(new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
-          throws IOException {
+      @Override public void data(
+          boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(16383, length);
-        byte[] data = new byte[length];
-        Util.readFully(in, data);
-        for (byte b : data){
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()){
           assertEquals(2, b);
         }
       }
@@ -434,10 +434,11 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     FrameReader fr = newReader(out);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.length);
+        assertEquals(0, debugData.size());
       }
     });
   }
@@ -447,34 +448,36 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     DataOutputStream dataOut = new DataOutputStream(out);
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final byte[] expectedData = new byte[8];
-    Arrays.fill(expectedData, (byte) '*');
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
 
     // Compose the expected GOAWAY frame without debug data.
-    dataOut.writeShort(8 + expectedData.length);
+    dataOut.writeShort(8 + expectedData.size());
     dataOut.write(Http20Draft09.TYPE_GOAWAY);
     dataOut.write(0); // no flags.
     dataOut.writeInt(0); // connection-scope
     dataOut.writeInt(0); // never read any stream!
     dataOut.writeInt(expectedError.httpCode);
-    dataOut.write(expectedData);
+    dataOut.write(expectedData.toByteArray());
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData));
+    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData.toByteArray()));
 
     FrameReader fr = newReader(out);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertArrayEquals(expectedData, debugData);
+        assertEquals(expectedData, debugData);
       }
     });
   }
 
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
-    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), 4096, false);
+    OkBuffer buffer = new OkBuffer();
+    buffer.write(ByteString.of(out.toByteArray()));
+    return new Http20Draft09.Reader(buffer, 4096, false);
   }
 
   @Test public void frameSizeError() throws IOException {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index f890c001e9..e4a6b07dd9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -17,6 +17,8 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -38,7 +40,7 @@
   private boolean client = false;
   private Variant variant = new Spdy3();
   private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);;
+  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
@@ -231,14 +233,13 @@ public InFrame(int sequence, FrameReader reader) {
       this.headersMode = headersMode;
     }
 
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
-      this.data = new byte[length];
-      Util.readFully(in, this.data);
+      this.data = source.readByteString(length).toByteArray();
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
@@ -256,13 +257,12 @@ public InFrame(int sequence, FrameReader reader) {
       this.payload2 = payload2;
     }
 
-    @Override
-    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
-      this.data = debugData;
+      this.data = debugData.toByteArray();
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index c6adebb51a..e488617e88 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -16,7 +16,8 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -78,16 +79,19 @@
     FrameReader fr = newReader(out);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.length);
+        assertEquals(0, debugData.size());
       }
     });
   }
 
   private Spdy3.Reader newReader(ByteArrayOutputStream out) {
-    return new Spdy3.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    OkBuffer data = new OkBuffer();
+    data.write(ByteString.of(out.toByteArray()));
+    return new Spdy3.Reader(data, false);
   }
 
   private byte[] sendDataFrame(byte[] data) throws IOException {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index acf2f5c44d..8b5794bd69 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -38,7 +38,6 @@
 import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
 import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.SpdyStream.OUTPUT_BUFFER_SIZE;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
@@ -47,6 +46,7 @@
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
 import static com.squareup.okhttp.internal.spdy.SpdyConnection.INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.spdy.SpdyStream.OUTPUT_BUFFER_SIZE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -1339,9 +1339,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
   }
 
   /** https://github.com/square/okhttp/issues/333 */
-  @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
+  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
     // This specially-formatted frame has trailing deflated bytes after the name value block.
     String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
         + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
@@ -1352,6 +1350,49 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
         + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
         + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
         + "P//sgYAAAD//w==";
+    headerBlockHasTrailingCompressedBytes(frame, 60);
+  }
+
+  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
+    // This specially-formatted frame has trailing deflated bytes after the name value block.
+    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//8=";
+    headerBlockHasTrailingCompressedBytes(frame, 289);
+  }
+
+  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame(Base64.decode(frame.getBytes(UTF_8)));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.acceptFrame(); // DATA
@@ -1361,7 +1402,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
-    assertEquals(60, stream.getResponseHeaders().get(0).value.size());
+    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
     assertStreamData("robot", stream.getInputStream());
   }
 
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 17f4cdac20..a262e3f91a 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -18,12 +18,6 @@
       <artifactId>okhttp-protocols</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>org.mortbay.jetty.npn</groupId>
       <artifactId>npn-boot</artifactId>
@@ -35,6 +29,12 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 198fd4ea80..58e06be40b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -19,7 +19,7 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -27,7 +27,7 @@
 /**
  * Policy on when async requests are executed.
  *
- * <p>Each dispatcher uses an {@link Executor} to run jobs internally. If you
+ * <p>Each dispatcher uses an {@link ExecutorService} to run jobs internally. If you
  * supply your own executor, it should be able to run {@link #getMaxRequests the
  * configured maximum} number of jobs concurrently.
  */
@@ -36,7 +36,7 @@
   private int maxRequestsPerHost = 5;
 
   /** Executes jobs. Created lazily. */
-  private Executor executor;
+  private ExecutorService executorService;
 
   /** Ready jobs in the order they'll be run. */
   private final Deque<Job> readyJobs = new ArrayDeque<Job>();
@@ -44,19 +44,19 @@
   /** Running jobs. Includes canceled jobs that haven't finished yet. */
   private final Deque<Job> runningJobs = new ArrayDeque<Job>();
 
-  public Dispatcher(Executor executor) {
-    this.executor = executor;
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
   }
 
   public Dispatcher() {
   }
 
-  public synchronized Executor getExecutor() {
-    if (executor == null) {
-      executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+  public synchronized ExecutorService getExecutorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
-    return executor;
+    return executorService;
   }
 
   /**
@@ -107,7 +107,7 @@ synchronized void enqueue(OkHttpClient client, Request request, Response.Receive
 
     if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
       runningJobs.add(job);
-      getExecutor().execute(job);
+      getExecutorService().execute(job);
     } else {
       readyJobs.add(job);
     }
@@ -143,7 +143,7 @@ private void promoteJobs() {
       if (runningJobsForHost(job) < maxRequestsPerHost) {
         i.remove();
         runningJobs.add(job);
-        getExecutor().execute(job);
+        getExecutorService().execute(job);
       }
 
       if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 68e1cfadb9..b76b5cd45b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,8 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
@@ -31,11 +31,12 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 
 /** Configures and creates HTTP connections. */
@@ -202,8 +203,7 @@ public OkResponseCache getOkResponseCache() {
   /**
    * Sets the socket factory used to secure HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultSSLSocketFactory()
-   * system-wide default} SSL socket factory will be used.
+   * <p>If unset, a lazily created SSL socket factory will be used.
    */
   public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
@@ -218,7 +218,8 @@ public SSLSocketFactory getSslSocketFactory() {
    * Sets the verifier used to confirm that response certificates apply to
    * requested hostnames for HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultHostnameVerifier()
+   * <p>If unset, the
+   * {@link javax.net.ssl.HttpsURLConnection#getDefaultHostnameVerifier()
    * system-wide default} hostname verifier will be used.
    */
   public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
@@ -422,7 +423,7 @@ OkHttpClient copyWithDefaults() {
       result.responseCache = toOkResponseCacheOrNull(ResponseCache.getDefault());
     }
     if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
+      result.sslSocketFactory = getDefaultSSLSocketFactory();
     }
     if (result.hostnameVerifier == null) {
       result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -439,6 +440,30 @@ OkHttpClient copyWithDefaults() {
     return result;
   }
 
+  /**
+   * Java and Android programs default to using a single global SSL context,
+   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
+   * used the shared SSL context, when OkHttp enables NPN for its SPDY-related
+   * stuff, it would also enable NPN for other usages, which might crash them
+   * because NPN is enabled when it isn't expected to be.
+   * <p>
+   * This code avoids that by defaulting to an OkHttp created SSL context. The
+   * significant drawback of this approach is that apps that customize the
+   * global SSL context will lose these customizations.
+   */
+  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
+    if (sslSocketFactory == null) {
+      try {
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(null, null, null);
+        sslSocketFactory = sslContext.getSocketFactory();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(); // The system has no TLS. Just give up.
+      }
+    }
+    return sslSocketFactory;
+  }
+
   /** Returns a shallow copy of this OkHttpClient. */
   @Override public OkHttpClient clone() {
     try {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 034ed84b64..a42362fbff 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -4,7 +4,8 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.Executor;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -129,7 +130,7 @@
     executor.assertJobs("http://a/2");
   }
 
-  class RecordingExecutor implements Executor {
+  class RecordingExecutor extends AbstractExecutorService {
     private List<Job> jobs = new ArrayList<Job>();
 
     @Override public void execute(Runnable command) {
@@ -155,6 +156,27 @@ public void finishJob(String url) {
       }
       throw new AssertionError("No such job: " + url);
     }
+
+    @Override public void shutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public List<Runnable> shutdownNow() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isShutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isTerminated() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
+        throws InterruptedException {
+      throw new UnsupportedOperationException();
+    }
   }
 
   private Request newRequest(String url) {
diff --git a/pom.xml b/pom.xml
index aea71da07a..82861f3859 100644
--- a/pom.xml
+++ b/pom.xml
@@ -22,6 +22,7 @@
     <module>okhttp</module>
     <module>okhttp-apache</module>
     <module>okhttp-protocols</module>
+    <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
     <module>benchmarks</module>
@@ -36,6 +37,8 @@
     <bouncycastle.version>1.48</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
+    <airlift.version>0.6</airlift.version>
+    <guava.version>16.0</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.11</junit.version>
@@ -87,6 +90,16 @@
         <artifactId>httpclient</artifactId>
         <version>${apache.http.version}</version>
       </dependency>
+      <dependency>
+        <groupId>io.airlift</groupId>
+        <artifactId>airline</artifactId>
+        <version>${airlift.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
