diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index ddfa72bf81..835ff275a3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -117,6 +117,7 @@ public HttpCodec newStream(OkHttpClient client, Interceptor.Chain chain, boolean
 
             synchronized (connectionPool) {
                 codec = resultCodec;
+                // 返回流对象
                 return resultCodec;
             }
         } catch (IOException e) {
@@ -140,6 +141,7 @@ private RealConnection findHealthyConnection(int connectTimeout,
 
             // If this is a brand new connection, we can skip the extensive health checks.
             synchronized (connectionPool) {
+                // successCount记录该连接上执行流任务的次数，为零说明是新建立的连接
                 if (candidate.successCount == 0) {
                     return candidate;
                 }
@@ -148,6 +150,8 @@ private RealConnection findHealthyConnection(int connectTimeout,
             // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
             // isn't, take it out of the pool and start again.
             if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+                // 连接不可用
+                // 在该方法中会设置该Allocation对应的Connection对象的noNewStream标志位，标识这在该连接不再使用，在回收的线程中会将其回收
                 noNewStreams();
                 continue;
             }
@@ -250,6 +254,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
                 route = selectedRoute;
                 refusedStreamCount = 0;
                 result = new RealConnection(connectionPool, selectedRoute);
+                // 将该StreamAllocation对象，即this 添加到Connection对象的StreamAllocation引用列表中，标识在建立新的流使用到了该连接
                 acquire(result, false);
             }
         }
@@ -263,6 +268,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         // Do TCP + TLS handshakes. This is a blocking operation.
         result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
                 connectionRetryEnabled, call, eventListener);
+        // 新建的连接一定可用，所以将该连接移除黑名单
         routeDatabase().connected(result.route());
 
         Socket socket = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index c3696649cd..c0d1b35684 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -55,6 +55,8 @@ public Response intercept(Chain chain) throws IOException {
         long sentRequestMillis = System.currentTimeMillis();
 
         realChain.eventListener().requestHeadersStart(call);
+
+        // 1. 向socket中写入请求header信息
         httpCodec.writeRequestHeaders(request);
         realChain.eventListener().requestHeadersEnd(call, request);
 
@@ -79,6 +81,7 @@ public Response intercept(Chain chain) throws IOException {
                     // Write the request body if the "Expect: 100-continue" expectation was met.
                     realChain.eventListener().requestBodyStart(call);
                     long contentLength = request.body().contentLength();
+                    // 2. 向socket中写入请求body信息
                     CountingSink requestBodyOut =
                             new CountingSink(httpCodec.createRequestBody(request, contentLength));
                     BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
@@ -96,6 +99,7 @@ public Response intercept(Chain chain) throws IOException {
         }
 
         if (!(request.body() instanceof DuplexRequestBody)) {
+            // 3. 完成网络请求的写入
             httpCodec.finishRequest();
         }
 
@@ -116,6 +120,7 @@ public Response intercept(Chain chain) throws IOException {
         if (code == 100) {
             // server sent a 100-continue even though we did not request one.
             // try again to read the actual response
+            // 4. 读取网络响应header信息
             responseBuilder = httpCodec.readResponseHeaders(false);
 
             responseBuilder
@@ -137,6 +142,7 @@ public Response intercept(Chain chain) throws IOException {
                     .body(Util.EMPTY_RESPONSE)
                     .build();
         } else {
+            // 5. 读取网络响应的body信息
             response = response.newBuilder()
                     .body(httpCodec.openResponseBody(response))
                     .build();
