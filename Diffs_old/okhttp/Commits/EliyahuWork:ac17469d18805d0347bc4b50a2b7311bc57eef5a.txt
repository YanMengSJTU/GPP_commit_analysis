diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
index 9a6a799edc..65c5ff41da 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
@@ -46,6 +46,9 @@
    * Returns a new byte string containing a clone of the bytes of {@code data}.
    */
   public static ByteString of(byte... data) {
+    if (data == null) {
+      return null;
+    }
     return new ByteString(data.clone());
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index b1f35c6ce2..ab28363a30 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -28,6 +28,7 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.internal.Platform;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -39,6 +40,7 @@
 import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
@@ -75,6 +77,7 @@
  * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
+  public static final long SEC2NS = TimeUnit.SECONDS.toNanos(1);
   final OkHttpClient client;
 
   private Connection connection;
@@ -131,8 +134,6 @@
   private boolean connectionReleased;
 
   /**
-   * @param requestHeaders the client's supplied request headers. This class
-   *     creates a private copy that it can mutate.
    * @param connection the connection used for an intermediate response
    *     immediately prior to this request/response pair, such as a same-host
    *     redirect. This engine assumes ownership of the connection and must
@@ -640,5 +641,45 @@ public void receiveHeaders(Headers headers) throws IOException {
     if (cookieHandler != null) {
       cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
     }
+    // If connection is not SPDY, search headers for Keep-Alive, parse and set
+    // timeout.
+    if (connection != null && !connection.isSpdy()) {
+      String keepAliveHeader = headers.get("Keep-Alive");
+      if (keepAliveHeader != null) {
+        // We only care about the timeout, the server will issue
+        // "Connection: Close" on the last allowed request, so we do not need
+        // to handle max.
+        int i = keepAliveHeader.indexOf("timeout=");
+        if (i > -1
+            && (i == 0
+                || Character.isWhitespace(keepAliveHeader.charAt(i - 1)))) {
+          String timeoutStr;
+          int j = keepAliveHeader.indexOf(' ', i + 8);
+          if (j > -1) {
+            timeoutStr = keepAliveHeader.substring(i + 8, j);
+          } else {
+            timeoutStr = keepAliveHeader.substring(i + 8);
+          }
+          int len = timeoutStr.length();
+          long timeConversion = SEC2NS;
+          if (!Character.isDigit(timeoutStr.charAt(len - 1))) {
+            if (timeoutStr.endsWith("ms")
+                && Character.isDigit(timeoutStr.charAt(len - 3))) {
+              timeoutStr = timeoutStr.substring(0, len - 3);
+              timeConversion = TimeUnit.MILLISECONDS.toNanos(1);
+            } else {
+              Platform.get().logW("failed to parse string '" + timeoutStr + "'");
+              return;
+            }
+          }
+          try {
+            connection.setKeepAliveDurationNs(Integer.decode(timeoutStr) * timeConversion);
+          } catch (NumberFormatException e) {
+            Platform.get().logW("failed to parse string '" + timeoutStr
+                          + "' as integer. Exception=" + e.getMessage());
+          }
+        }
+      }
+    }
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index 59553a0153..aeb204153d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -37,7 +37,7 @@
 import static org.junit.Assert.assertTrue;
 
 public final class ConnectionPoolTest {
-  private static final int KEEP_ALIVE_DURATION_MS = 5000;
+  private static final long KEEP_ALIVE_DURATION_MS = 5000;
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
   private final MockWebServer spdyServer = new MockWebServer();
@@ -148,7 +148,7 @@
 
   @Test public void idleConnectionNotReturned() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    httpA.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
+    httpA.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
     pool.recycle(httpA);
     Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
     assertNull(pool.get(httpAddress));
@@ -166,8 +166,8 @@
 
   @Test public void expiredConnectionsAreEvicted() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    httpA.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
-    httpB.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
+    httpA.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
+    httpB.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
     pool.recycle(httpA);
     pool.recycle(httpB);
     Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
@@ -227,7 +227,7 @@
 
   @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    spdyA.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
+    spdyA.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
     pool.maybeShare(spdyA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(httpAddress));
@@ -353,9 +353,9 @@
     ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
 
     // Add 3 connections to the pool.
-    httpA.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
-    httpB.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
-    spdyA.setKeepAliveDurationNs(((long) KEEP_ALIVE_DURATION_MS) * 1000 * 1000);
+    httpA.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
+    httpB.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
+    spdyA.setKeepAliveDurationNs(KEEP_ALIVE_DURATION_MS * 1000 * 1000);
     pool.recycle(httpA);
     pool.recycle(httpB);
     pool.maybeShare(spdyA);
