diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
deleted file mode 100644
index b879072c02..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ /dev/null
@@ -1,3383 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-import java.net.UnknownServiceException;
-import java.security.cert.Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.logging.SimpleFormatter;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HeldCertificate;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CallTest {
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = defaultClient();
-  private RecordingCallback callback = new RecordingCallback();
-  private TestLogHandler logHandler = new TestLogHandler();
-  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  @Before public void setUp() throws Exception {
-    logger.addHandler(logHandler);
-  }
-
-  @After public void tearDown() throws Exception {
-    cache.delete();
-    logger.removeHandler(logHandler);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .clearHeaders()
-        .addHeader("content-type: text/plain")
-        .addHeader("content-length", "3"));
-
-    long sentAt = System.currentTimeMillis();
-    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
-    long receivedAt = System.currentTimeMillis();
-
-    recordedResponse.assertCode(200)
-        .assertSuccessful()
-        .assertHeaders(new Headers.Builder()
-            .add("content-type", "text/plain")
-            .add("content-length", "3")
-            .build())
-        .assertBody("abc")
-        .assertSentRequestAtMillis(sentAt, receivedAt)
-        .assertReceivedResponseAtMillis(sentAt, receivedAt);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
-  }
-
-  @Test public void buildRequestUsingHttpUrl() throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously("/").assertSuccessful();
-  }
-
-  @Test public void invalidScheme() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("ftp://hostname/path");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Expected URL scheme 'http' or 'https' but was 'ftp'", expected.getMessage());
-    }
-  }
-
-  @Test public void invalidPort() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("http://localhost:65536/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Invalid URL port: \"65536\"", expected.getMessage());
-    }
-  }
-
-  @Test public void getReturns500() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-    executeSynchronously("/")
-        .assertCode(500)
-        .assertNotSuccessful();
-  }
-
-  @Test public void get_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    get();
-  }
-
-  @Test public void get_HTTPS() throws Exception {
-    enableTls();
-    get();
-  }
-
-  @Test public void repeatedHeaderNames() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("B", "123")
-        .addHeader("B", "234"));
-
-    executeSynchronously("/", "A", "345", "A", "456")
-        .assertCode(200)
-        .assertHeader("B", "123", "234");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
-  }
-
-  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    repeatedHeaderNames();
-  }
-
-  @Test public void getWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void head() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("HEAD", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
-  }
-
-  @Test public void headResponseContentLengthIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Length", "100"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    Response response = client.newCall(headRequest).execute();
-    assertEquals(200, response.code());
-    assertArrayEquals(new byte[0], response.body().bytes());
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void headResponseContentEncodingIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Encoding", "chunked"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    executeSynchronously(headRequest)
-        .assertCode(200)
-        .assertHeader("Content-Encoding", "chunked")
-        .assertBody("");
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void head_HTTPS() throws Exception {
-    enableTls();
-    head();
-  }
-
-  @Test public void head_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    head();
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void post_HTTPS() throws Exception {
-    enableTls();
-    post();
-  }
-
-  @Test public void post_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    post();
-  }
-
-  @Test public void postZeroLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, new byte[0]))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void postZerolength_HTTPS() throws Exception {
-    enableTls();
-    postZeroLength();
-  }
-
-  @Test public void postZerolength_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postZeroLength();
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, body))
-        .build();
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertEquals(200, response.code());
-    response.body().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build();
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  /**
-   * We had a bug where we were passing a null route to the authenticator.
-   * https://github.com/square/okhttp/issues/3809
-   */
-  @Test public void authenticateWithNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null);
-
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(401);
-
-    assertNotNull(authenticator.onlyRoute());
-  }
-
-  @Test public void delete() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .delete()
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void delete_HTTPS() throws Exception {
-    enableTls();
-    delete();
-  }
-
-  @Test public void delete_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    delete();
-  }
-
-  @Test public void deleteWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-  }
-
-  @Test public void put() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PUT", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void put_HTTPS() throws Exception {
-    enableTls();
-    put();
-  }
-
-  @Test public void put_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    put();
-  }
-
-  @Test public void patch() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PATCH", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void patch_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    patch();
-  }
-
-  @Test public void patch_HTTPS() throws Exception {
-    enableTls();
-    patch();
-  }
-
-  @Test public void customMethodWithBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("CUSTOM", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, "abc"))
-        .build();
-
-    executeSynchronously(request).assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
-  }
-
-  @Test public void illegalToExecuteTwice() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    response.body().close();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
-    }
-
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
-  }
-
-  @Test public void illegalToExecuteTwice_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
-    }
-
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
-  }
-
-  @Test public void legalToExecuteTwiceCloning() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    Response response1 = call.execute();
-
-    Call cloned = call.clone();
-    Response response2 = cloned.execute();
-
-    assertEquals(response1.body().string(), "abc");
-    assertEquals(response2.body().string(), "def");
-  }
-
-  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    Call cloned = call.clone();
-    cloned.enqueue(callback);
-
-    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
-    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
-
-    Set<String> bodies = new LinkedHashSet<>();
-    bodies.add(firstResponse.getBody());
-    bodies.add(secondResponse.getBody());
-
-    assertTrue(bodies.contains("abc"));
-    assertTrue(bodies.contains("def"));
-  }
-
-  @Test public void get_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain")
-        .assertBody("abc");
-
-    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
-  }
-
-  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/secret"))
-        .build();
-
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        throw new IOException("a");
-      }
-    });
-
-    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
-        logHandler.take());
-  }
-
-  @Test public void connectionPooling() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    executeSynchronously("/a").assertBody("abc");
-    executeSynchronously("/b").assertBody("def");
-    executeSynchronously("/c").assertBody("ghi");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionPooling_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
-    callback.await(server.url("/a")).assertBody("abc");
-
-    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-    callback.await(server.url("/b")).assertBody("def");
-
-    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
-    callback.await(server.url("/c")).assertBody("ghi");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        InputStream bytes = response.body().byteStream();
-        assertEquals('a', bytes.read());
-        assertEquals('b', bytes.read());
-        assertEquals('c', bytes.read());
-
-        // This request will share a connection with 'A' cause it's all done.
-        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-      }
-    });
-
-    callback.await(server.url("/b")).assertCode(200).assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
-  }
-
-  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    // First request: time out after 1000ms.
-    client = client.newBuilder()
-        .readTimeout(1000, TimeUnit.MILLISECONDS)
-        .build();
-    executeSynchronously("/a").assertBody("abc");
-
-    // Second request: time out after 250ms.
-    client = client.newBuilder()
-        .readTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-    Request request = new Request.Builder().url(server.url("/b")).build();
-    Response response = client.newCall(request).execute();
-    BufferedSource bodySource = response.body().source();
-    assertEquals('d', bodySource.readByte());
-
-    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
-    long startNanos = System.nanoTime();
-    try {
-      bodySource.readByte();
-      fail();
-    } catch (IOException expected) {
-      // Timed out as expected.
-      long elapsedNanos = System.nanoTime() - startNanos;
-      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
-    } finally {
-      bodySource.close();
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/442 */
-  @Test public void tlsTimeoutsNotRetried() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse()
-        .setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      // If this succeeds, too many requests were made.
-      client.newCall(request).execute();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
-  /**
-   * Make a request with two routes. The first route will time out because it's connecting to a
-   * special address that never connects. The automatic retry will succeed.
-   */
-  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
-    proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
-
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .connectTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /**
-   * Make a request with two routes. The first route will fail because the null server connects but
-   * never responds. The manual retry will succeed.
-   */
-  @Test public void readTimeoutFails() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-    server2.enqueue(new MockResponse()
-        .setBody("success!"));
-
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(server.toProxyAddress());
-    proxySelector.proxies.add(server2.toProxyAddress());
-
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertFailure(SocketTimeoutException.class);
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /** https://github.com/square/okhttp/issues/1801 */
-  @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = defaultClient().newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new IOException();
-          }
-        })
-        .build();
-    Request request = new Request.Builder().url(server.url("/")).build();
-    c.newCall(request).enqueue(callback);
-    RecordedResponse response = callback.await(request.url());
-    assertEquals(request, response.request);
-  }
-
-  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Call 1: set a deadline on the request body.
-    RequestBody requestBody1 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.timeout().deadline(5, TimeUnit.SECONDS);
-      }
-    };
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody1)
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals(200, response1.code());
-
-    // Call 2: check for the absence of a deadline on the request body.
-    RequestBody requestBody2 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        assertFalse(sink.timeout().hasDeadline());
-        sink.writeUtf8("def");
-      }
-    };
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody2)
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals(200, response2.code());
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Call 1: set a deadline on the response body.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    BufferedSource body1 = response1.body().source();
-    assertEquals("abc", body1.readUtf8());
-    body1.timeout().deadline(5, TimeUnit.SECONDS);
-
-    // Call 2: check for the absence of a deadline on the request body.
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    BufferedSource body2 = response2.body().source();
-    assertEquals("def", body2.readUtf8());
-    assertFalse(body2.timeout().hasDeadline());
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void tls() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    executeSynchronously("/").assertHandshake();
-  }
-
-  @Test public void tls_Async() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertHandshake();
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("retry success"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-    assertTrue(client.retryOnConnectionFailure());
-
-    executeSynchronously("/").assertBody("seed connection pool");
-    executeSynchronously("/").assertBody("retry success");
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    recoverWhenRetryOnConnectionFailureIsTrue();
-  }
-
-  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .retryOnConnectionFailure(false)
-        .build();
-
-    executeSynchronously("/").assertBody("seed connection pool");
-
-    // If this succeeds, too many requests were made.
-    executeSynchronously("/")
-        .assertFailure(IOException.class)
-        .assertFailureMatches("stream was reset: CANCEL",
-            "unexpected end of stream on Connection.*"
-                + server.getHostName() + ":" + server.getPort() + ".*");
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    noRecoverWhenRetryOnConnectionFailureIsFalse();
-  }
-
-  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("response that will never be received"));
-    RecordedResponse response = executeSynchronously("/");
-    response.assertFailure(
-            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
-            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
-            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
-    );
-    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    executeSynchronously("/").assertBody("abc");
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
-    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
-    List<String> supportedCiphers =
-        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
-    if (!supportedCiphers.contains(tlsFallbackScsv)) {
-      // This only works if the client socket supports TLS_FALLBACK_SCSV.
-      return;
-    }
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    }
-
-    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
-    SSLSocket firstSocket = clientSockets.get(0);
-    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
-    SSLSocket secondSocket = clientSockets.get(1);
-    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertBody("abc");
-  }
-
-  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
-    client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 11 response to the FAIL_HANDSHAKE
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
-    }
-  }
-
-  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
-    // Configure the client with only TLS configurations. No cleartext!
-    client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
-    }
-  }
-
-  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
-    }
-  }
-
-  @Test public void setFollowSslRedirectsFalse() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: http://square.com"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertEquals(301, response.code());
-    response.body().close();
-  }
-
-  @Test public void matchingPinnedCertificate() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Make a first request without certificate pinning. Use it to collect certificates to pin.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
-    for (Certificate certificate : response1.handshake().peerCertificates()) {
-      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
-    }
-    response1.body().close();
-
-    // Make another request with certificate pinning. It should complete normally.
-    client = client.newBuilder()
-        .certificatePinner(certificatePinnerBuilder.build())
-        .build();
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertNotSame(response2.handshake(), response1.handshake());
-    response2.body().close();
-  }
-
-  @Test public void unmatchingPinnedCertificate() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse());
-
-    // Pin publicobject.com's cert.
-    client = client.newBuilder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .build())
-        .build();
-
-    // When we pin the wrong certificate, connectivity fails.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
-    }
-  }
-
-  @Test public void post_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("abc", response1.body().string());
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("def", response2.body().string());
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
-
-    RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
-
-    RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedOnFailureRecovery();
-  }
-
-  @Test public void cacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Charset")
-        .setBody("A"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    HttpUrl url = server.url("/");
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestMethod("GET")
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    cacheHit.assertNoNetworkResponse();
-  }
-
-  @Test public void conditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse().clearHeaders()
-        .addHeader("Donut: b")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
-        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
-        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the caller's request, plus some caching headers.
-    cacheHit.networkResponse()
-        .assertCode(304)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheHit_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("A");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  @Test public void conditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Donut: b")
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    // Different request, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheMiss = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-
-    // Check the user response. It has the application's original request.
-    cacheMiss.assertCode(200)
-        .assertBody("B")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cache response. Even though it's a miss, we used the cache.
-    cacheMiss.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the network request, plus caching headers.
-    cacheMiss.networkResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheMiss_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("B");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
-    executeSynchronously("/", "Cache-Control", "only-if-cached")
-        .assertCode(504)
-        .assertBody("")
-        .assertNoNetworkResponse()
-        .assertNoCacheResponse();
-  }
-
-  @Test public void networkDropsOnConditionalGet() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Seed the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("A");
-
-    // Attempt conditional cache validation and a DNS miss.
-    client.connectionPool().evictAll();
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    executeSynchronously("/").assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    executeSynchronously("/a")
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
-  }
-
-  @Test public void postRedirectsToGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
-        .build()).execute();
-    assertEquals("Page 2", response.body().string());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals("Body", response.body().string());
-  }
-
-  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "1")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals("You took too long!", response.body().string());
-  }
-
-  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals("Body", response.body().string());
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
-  }
-
-  @Test public void disableClientRequestTimeoutRetry() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
-  }
-
-  @Test public void maxClientRequestTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void maxUnavailableTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals(503, response.code());
-    assertEquals("You took too long!", response.body().string());
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertEquals("Body", response.body().string());
-  }
-
-  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
-    // given
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    // when
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
-        .build()).execute();
-
-    // then
-    assertEquals("Page 2", response.body().string());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
-    assertEquals("Request Body", page2.getBody().readUtf8());
-  }
-
-  @Test public void responseCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
-        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
-    assertEquals(2, responseCookies.size());
-    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
-        responseCookies.get(0).toString());
-    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
-        responseCookies.get(1).toString());
-  }
-
-  @Test public void requestCookies() throws Exception {
-    server.enqueue(new MockResponse());
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-
-    cookieJar.enqueueRequestCookies(
-        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
-        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/")));
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.getHostName());
-    cookie.setPath("/");
-    String portList = Integer.toString(server.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .build()).execute();
-    assertEquals("Page 2", response.body().string());
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("c=cookie", request1.getHeader("Cookie"));
-
-    RecordedRequest request2 = server2.takeRequest();
-    assertNull(request2.getHeader("Cookie"));
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
-
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    Response response = client.newCall(request).execute();
-    assertEquals("Page 2", response.body().string());
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
-  }
-
-  @Test public void redirect_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(server.url("/a"))
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    executeSynchronously("/0")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void follow20Redirects_Async() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0"))
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  @Test public void doesNotFollow21Redirects_Async() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
-  }
-
-  @Test public void http204WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(204)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
-  }
-
-  @Test public void http205WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(205)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
-  }
-
-  @Test public void httpWithExcessiveHeaders() throws IOException {
-    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
-
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-
-    server.enqueue(new MockResponse()
-        .setStatus(longLine)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailureMatches(".*unexpected end of stream on Connection.*");
-  }
-
-  private String stringFill(char fillChar, int length) {
-    char[] value = new char[length];
-    Arrays.fill(value, fillChar);
-    return new String(value);
-  }
-
-  @Test public void canceledBeforeExecute() throws Exception {
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void cancelDuringHttpConnect() throws Exception {
-    cancelDuringConnect("http");
-  }
-
-  @Test public void cancelDuringHttpsConnect() throws Exception {
-    cancelDuringConnect("https");
-  }
-
-  /** Cancel a call that's waiting for connect to complete. */
-  private void cancelDuringConnect(String scheme) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-
-    long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/").newBuilder().scheme(scheme).build())
-        .build());
-    cancelLater(call, cancelDelayMillis);
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
-  }
-
-  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
-    server.enqueue(new MockResponse());
-    final CountDownLatch latch = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            try {
-              latch.await();
-            } catch (InterruptedException e) {
-              throw new AssertionError(e);
-            }
-            return chain.proceed(chain.request());
-          }
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/a"))
-        .build());
-    call.enqueue(callback);
-    call.cancel();
-    latch.countDown();
-
-    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void cancelAll() throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call.enqueue(callback);
-    client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void cancelBeforeBodyIsRead() throws Exception {
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<Response> result = executor.submit(new Callable<Response>() {
-      @Override public Response call() throws Exception {
-        return call.execute();
-      }
-    });
-
-    Thread.sleep(100); // wait for it to go in flight.
-
-    call.cancel();
-    try {
-      result.get().body().bytes();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
-    enableTls();
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  /**
-   * This test puts a request in front of one that is to be canceled, so that it is canceled before
-   * I/O takes place.
-   */
-  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    // Force requests to be executed serially.
-    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
-    dispatcher.setMaxRequests(1);
-    client = client.newBuilder()
-        .dispatcher(dispatcher)
-        .build();
-
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    Request requestB = new Request.Builder().url(server.url("/b")).build();
-    final Call callA = client.newCall(requestA);
-    final Call callB = client.newCall(requestB);
-
-    server.setDispatcher(new Dispatcher() {
-      char nextResponse = 'A';
-
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        callB.cancel();
-        return new MockResponse().setBody(Character.toString(nextResponse++));
-      }
-    });
-
-    callA.enqueue(callback);
-    callB.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
-
-    callback.await(requestA.url()).assertBody("A");
-    // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(requestA);
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    call.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
-
-    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
-        "Socket closed");
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  /**
-   * There's a race condition where the cancel may apply after the stream has already been
-   * processed.
-   */
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<>();
-    final AtomicBoolean failureRef = new AtomicBoolean();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        failureRef.set(true);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        call.cancel();
-        try {
-          bodyRef.set(response.body().string());
-        } catch (IOException e) { // It is ok if this broke the stream.
-          bodyRef.set("A");
-          throw e; // We expect to not loop into onFailure in this case.
-        } finally {
-          latch.countDown();
-        }
-      }
-    });
-
-    latch.await();
-    assertEquals("A", bodyRef.get());
-    assertFalse(failureRef.get());
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
-      throws Exception {
-    enableTls();
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
-      throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void cancelWithInterceptor() throws Exception {
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            chain.proceed(chain.request());
-            throw new AssertionError(); // We expect an exception.
-          }
-        }).build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void gzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-    String bodySize = Long.toString(gzippedBody.size());
-
-    server.enqueue(new MockResponse()
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip"));
-
-    // Confirm that the user request doesn't have Accept-Encoding, and the user
-    // response doesn't have a Content-Encoding or Content-Length.
-    RecordedResponse userResponse = executeSynchronously("/");
-    userResponse.assertCode(200)
-        .assertRequestHeader("Accept-Encoding")
-        .assertHeader("Content-Encoding")
-        .assertHeader("Content-Length")
-        .assertBody("abcabcabc");
-
-    // But the network request doesn't lie. OkHttp used gzip for this call.
-    userResponse.networkResponse()
-        .assertHeader("Content-Encoding", "gzip")
-        .assertHeader("Content-Length", bodySize)
-        .assertRequestHeader("Accept-Encoding", "gzip");
-  }
-
-  /** https://github.com/square/okhttp/issues/1927 */
-  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setBody(gzip("abcabcabc"))
-        .addHeader("Content-Encoding: gzip"));
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password"))
-        .build();
-
-    executeSynchronously("/").assertBody("abcabcabc");
-  }
-
-  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-
-    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
-
-    // Make a range request.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Range", "bytes=0-")
-        .build();
-    Call call = client.newCall(request);
-
-    // The response is not decompressed.
-    Response response = call.execute();
-    assertEquals("gzip", response.header("Content-Encoding"));
-    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
-
-    // The request did not offer gzip support.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertNull(recordedRequest.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          responseRef.put(response);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    });
-
-    Response response = responseRef.take();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
-
-    // Make another request just to confirm that that connection can be reused...
-    executeSynchronously("/").assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-
-    // ... even before we close the response body!
-    response.body().close();
-  }
-
-  @Test public void userAgentIsIncludedByDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    executeSynchronously("/");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertTrue(recordedRequest.getHeader("User-Agent")
-        .matches(Version.userAgent()));
-  }
-
-  @Test public void setFollowRedirectsFalse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .followRedirects(false)
-        .build();
-    executeSynchronously("/a")
-        .assertBody("A")
-        .assertCode(302);
-  }
-
-  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), ""))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueEmptyRequestBody();
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    client = client.newBuilder()
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("", recordedRequest.getBody().readUtf8());
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueTimesOutWithoutContinue();
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWithUnsolicited100Continue();
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
-    client = client.newBuilder()
-        .readTimeout(1, TimeUnit.SECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWith100ContinueOnly();
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    successfulExpectContinuePermitsConnectionReuse();
-  }
-
-  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    executeSynchronously("/")
-        .assertHeader("a\tb", "c\u007fd")
-        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
-        .assertHeader("", "ef");
-  }
-
-  @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertCode(200);
-
-    dns.assertRequests("android.com");
-  }
-  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    List<InetAddress> ipAddresses = new ArrayList<>();
-    dns.set("android.com", ipAddresses);
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
-
-    dns.assertRequests("android.com");
-  }
-
-  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
-  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse().setBody("Response 1"));
-    server.enqueue(new MockResponse().setBody("Response 2"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.flush();
-
-        makeFailingCall();
-
-        sink.writeUtf8("def");
-        sink.flush();
-      }
-    };
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    assertEquals("Response 1", call.execute().body().string());
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Private", "Secret")
-        .header("User-Agent", "App 1.0")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("encrypted response from the origin server", response.body().string());
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals("App 1.0", get.getHeader("User-Agent"));
-
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Respond to a proxy authorization challenge. */
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
-  }
-
-  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
-  @Test public void httpProxyAuthenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
-        .build();
-
-    Request request = new Request.Builder()
-        .url("http://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
-
-    RecordedRequest get1 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
-    assertNull(get1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get2 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
-    assertEquals("password", get2.getHeader("Proxy-Authorization"));
-  }
-
-  /**
-   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
-   * TLS tunnel. https://github.com/square/okhttp/issues/2426
-   */
-  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
-
-    // First CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    // Second CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    // GET reuses the connection from the second connect.
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(407)
-          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-          .addHeader("Connection: close"));
-    }
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  /**
-   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
-   * We used to have that behavior but it is problematic because unrelated requests end up sharing
-   * credentials. Worse, that approach leaks proxy credentials to the origin server.
-   */
-  @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Proxy-Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("password", get.getHeader("Proxy-Authorization"));
-  }
-
-  @Test public void interceptorGetsHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    // Capture the protocol as it is observed by the interceptor.
-    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        protocolRef.set(chain.connection().protocol());
-        return chain.proceed(chain.request());
-      }
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    // Make an HTTP/2 request and confirm that the protocol matches.
-    server.enqueue(new MockResponse());
-    executeSynchronously("/");
-    assertEquals(Protocol.HTTP_2, protocolRef.get());
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 2147483648 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 00a OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus(" HTTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
-  }
-
-  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a b", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
-    }
-  }
-
-  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a\tb", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
-    }
-  }
-
-  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a b", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals("c", response.header("a b"));
-  }
-
-  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a\tb", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals("c", response.header("a\tb"));
-  }
-
-  @Test public void connectFails() throws Exception {
-    server.shutdown();
-
-    executeSynchronously("/")
-        .assertFailure(IOException.class);
-  }
-
-  @Test public void requestBodySurvivesRetries() throws Exception {
-    server.enqueue(new MockResponse());
-
-    // Enable a misconfigured proxy selector to guarantee that the request is retried.
-    client = client.newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build();
-    server2.shutdown();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request);
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
-  @Test public void invalidHost() throws Exception {
-    Request request = new Request.Builder()
-        .url(HttpUrl.get("http://1234.1.1.1/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
-    upload(true, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
-  }
-
-  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
-    upload(true, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
-  }
-
-  @Test public void uploadBodySmallFixedLength() throws Exception {
-    upload(false, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
-  }
-
-  @Test public void uploadBodyLargeFixedLength() throws Exception {
-    upload(false, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
-  }
-
-  private void upload(
-      final boolean chunked, final int size, final int writeSize) throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody(chunked, size, writeSize))
-        .build());
-  }
-
-  /** https://github.com/square/okhttp/issues/2344 */
-  @Test public void ipv6HostHasSquareBraces() throws Exception {
-    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://[::1]/")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("[::1]:443", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", get.getRequestLine());
-    assertEquals("[::1]", get.getHeader("Host"));
-  }
-
-  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
-    final byte[] buffer = new byte[writeSize];
-    Arrays.fill(buffer, (byte) 'x');
-
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain; charset=utf-8");
-      }
-
-      @Override public long contentLength() throws IOException {
-        return chunked ? -1L : size;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        for (int count = 0; count < size; count += writeSize) {
-          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
-        }
-      }
-    };
-  }
-
-  @Test public void emptyResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("abc", "def"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertHeader("abc", "def")
-        .assertBody("");
-  }
-
-  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = defaultClient().newBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.execute("));
-      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = defaultClient().newBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      final CountDownLatch latch = new CountDownLatch(1);
-      client.newCall(request).enqueue(new Callback() {
-        @Override public void onFailure(Call call, IOException e) {
-          fail();
-        }
-
-        @Override public void onResponse(Call call, Response response) throws IOException {
-          // Ignore the response so it gets leaked then GC'd.
-          latch.countDown();
-        }
-      });
-      latch.await();
-      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
-      // small delay appears to ensure the objects will get GC'd.
-      Thread.sleep(200);
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
-      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-
-    client.connectionPool().evictAll();
-    client = client.newBuilder()
-        .authenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            throw new IOException("IOException!");
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertEquals(1, client.connectionPool().idleConnectionCount());
-  }
-
-  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407));
-
-    client.connectionPool().evictAll();
-    client = client.newBuilder()
-        .proxyAuthenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            throw new IOException("IOException!");
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertEquals(1, client.connectionPool().idleConnectionCount());
-  }
-
-  @Test public void httpsWithIpAddress() throws Exception {
-    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
-
-    // Create a certificate with an IP address in the subject alt name.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("example.com")
-        .addSubjectAlternativeName(localIpAddress)
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate())
-        .build();
-
-    // Use that certificate on the server and trust it on the client.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .build();
-
-    // Make a request.
-    server.enqueue(new MockResponse());
-    HttpUrl url = server.url("/").newBuilder()
-        .host(localIpAddress)
-        .build();
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    executeSynchronously(request)
-        .assertCode(200);
-
-    // Confirm that the IP address was used in the host header.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
-  }
-
-  private void makeFailingCall() {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return 1;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        throw new IOException("write body fail!");
-      }
-    };
-    OkHttpClient nonRetryingClient = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-    Call call = nonRetryingClient.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("write body fail!", expected.getMessage());
-    }
-  }
-
-  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
-    Request.Builder builder = new Request.Builder();
-    builder.url(server.url(path));
-    for (int i = 0, size = headers.length; i < size; i += 2) {
-      builder.addHeader(headers[i], headers[i + 1]);
-    }
-    return executeSynchronously(builder.build());
-  }
-
-  private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Call call = client.newCall(request);
-    try {
-      Response response = call.execute();
-      String bodyString = response.body().string();
-      return new RecordedResponse(request, response, null, bodyString, null);
-    } catch (IOException e) {
-      return new RecordedResponse(request, null, null, null, e);
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private void cancelLater(final Call call, final long delay) {
-    new Thread("canceler") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delay);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        call.cancel();
-      }
-    }.start();
-  }
-
-  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
-
-    private List<SSLSocket> socketsCreated = new ArrayList<>();
-
-    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
-      super(delegate);
-    }
-
-    @Override
-    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-      socketsCreated.add(sslSocket);
-      return sslSocket;
-    }
-
-    public List<SSLSocket> getSocketsCreated() {
-      return socketsCreated;
-    }
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
deleted file mode 100644
index 04ba57126b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ /dev/null
@@ -1,1815 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import okhttp3.internal.io.FaultyFileSystem;
-import okhttp3.internal.io.FileSystem;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.Timeout;
-
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.cache.DiskLruCache.MAGIC;
-import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class DiskLruCacheTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(60 * 1000);
-
-  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
-  private final int appVersion = 100;
-  private File cacheDir;
-  private File journalFile;
-  private File journalBkpFile;
-  private final TestExecutor executor = new TestExecutor();
-
-  private DiskLruCache cache;
-  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
-
-  private void createNewCache() throws IOException {
-    createNewCacheWithSize(Integer.MAX_VALUE);
-  }
-
-  private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
-    synchronized (cache) {
-      cache.initialize();
-    }
-    toClose.add(cache);
-  }
-
-  @Before public void setUp() throws Exception {
-    cacheDir = tempDir.getRoot();
-    journalFile = new File(cacheDir, JOURNAL_FILE);
-    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
-    createNewCache();
-  }
-
-  @After public void tearDown() throws Exception {
-    while (!toClose.isEmpty()) {
-      toClose.pop().close();
-    }
-  }
-
-  @Test public void emptyCache() throws Exception {
-    cache.close();
-    assertJournalEquals();
-  }
-
-  @Test public void recoverFromInitializationFailure() throws IOException {
-    // Add an uncommitted entry. This will get detected on initialization, and the cache will
-    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
-    // incomplete.
-    DiskLruCache.Editor creator = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(creator.newSink(0));
-    sink.writeUtf8("Hello");
-    sink.close();
-
-    // Simulate a severe filesystem failure on the first initialization.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
-    fileSystem.setFaultyDelete(cacheDir, true);
-
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    try {
-      cache.get("k1");
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Now let it operate normally.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
-    fileSystem.setFaultyDelete(cacheDir, false);
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertNull(snapshot);
-  }
-
-  @Test public void validateKey() throws Exception {
-    String key = null;
-    try {
-      key = "has_space ";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_CR\r";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_LF\n";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_invalid/";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_invalid\u2603";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
-          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was too long.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-
-    // Test valid cases.
-
-    // Exactly 120.
-    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
-        + "01234567890123456789012345678901234567890123456789";
-    cache.edit(key).abort();
-    // Contains all valid characters.
-    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
-    cache.edit(key).abort();
-    // Contains dash.
-    key = "-20384573948576";
-    cache.edit(key).abort();
-  }
-
-  @Test public void writeAndReadEntry() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    assertNull(creator.newSource(0));
-    assertNull(creator.newSource(1));
-    creator.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-  }
-
-  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-    cache.close();
-
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    // Simulate a dirty close of 'cache' by opening the cache directory again.
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void journalWithEditAndPublish() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
-  }
-
-  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.abort();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
-    cache.edit("k1");
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertNull(cache.get("k1"));
-    setString(creator, 0, "A");
-    setString(creator, 1, "BC");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
-  }
-
-  @Test public void journalWithEditAndPublishAndRead() throws Exception {
-    DiskLruCache.Editor k1Creator = cache.edit("k1");
-    setString(k1Creator, 0, "AB");
-    setString(k1Creator, 1, "C");
-    k1Creator.commit();
-    DiskLruCache.Editor k2Creator = cache.edit("k2");
-    setString(k2Creator, 0, "DEF");
-    setString(k2Creator, 1, "G");
-    k2Creator.commit();
-    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
-    k1Snapshot.close();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
-  }
-
-  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.commit();
-    assertInoperable(editor);
-  }
-
-  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.abort();
-    assertInoperable(editor);
-  }
-
-  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "ABC");
-    setString(editor, 1, "B");
-    editor.commit();
-    File k1 = getCleanFile("k1", 0);
-    assertEquals("ABC", readFile(k1));
-    cache.remove("k1");
-    assertFalse(fileSystem.exists(k1));
-  }
-
-  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    assertTrue(cache.remove("a"));
-    setString(a, 1, "a2");
-    a.commit();
-    assertAbsent("a");
-  }
-
-  /**
-   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
-   * the same key can see different data.
-   */
-  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
-    DiskLruCache.Editor v1Creator = cache.edit("k1");
-    setString(v1Creator, 0, "AAaa");
-    setString(v1Creator, 1, "BBbb");
-    v1Creator.commit();
-
-    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
-    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertEquals('A', inV1.readByte());
-    assertEquals('A', inV1.readByte());
-
-    DiskLruCache.Editor v1Updater = cache.edit("k1");
-    setString(v1Updater, 0, "CCcc");
-    setString(v1Updater, 1, "DDdd");
-    v1Updater.commit();
-
-    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
-    assertSnapshotValue(snapshot2, 0, "CCcc");
-    assertSnapshotValue(snapshot2, 1, "DDdd");
-    snapshot2.close();
-
-    assertEquals('a', inV1.readByte());
-    assertEquals('a', inV1.readByte());
-    assertSnapshotValue(snapshot1, 1, "BBbb");
-    snapshot1.close();
-  }
-
-  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
-    cache.close();
-    File cleanFile0 = getCleanFile("k1", 0);
-    File cleanFile1 = getCleanFile("k1", 1);
-    File dirtyFile0 = getDirtyFile("k1", 0);
-    File dirtyFile1 = getDirtyFile("k1", 1);
-    writeFile(cleanFile0, "A");
-    writeFile(cleanFile1, "B");
-    writeFile(dirtyFile0, "C");
-    writeFile(dirtyFile1, "D");
-    createJournal("CLEAN k1 1 1", "DIRTY   k1");
-    createNewCache();
-    assertFalse(fileSystem.exists(cleanFile0));
-    assertFalse(fileSystem.exists(cleanFile1));
-    assertFalse(fileSystem.exists(dirtyFile0));
-    assertFalse(fileSystem.exists(dirtyFile1));
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "0", "100", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "101", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "1", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1", "BOGUS");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 0000x001 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
-    cache.close();
-    writeFile(getCleanFile("k1", 0), "A");
-    writeFile(getCleanFile("k1", 1), "B");
-
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    sink.close();
-    createNewCache();
-    assertNull(cache.get("k1"));
-
-    // The journal is not corrupt when editing after a truncated line.
-    set("k1", "C", "D");
-
-    cache.close();
-    createNewCache();
-    assertValue("k1", "C", "D");
-  }
-
-  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void keyWithSpaceNotPermitted() throws Exception {
-    try {
-      cache.edit("my key");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithNewlineNotPermitted() throws Exception {
-    try {
-      cache.edit("my\nkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
-    try {
-      cache.edit("my\rkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullKeyThrows() throws Exception {
-    try {
-      cache.edit(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    try {
-      creator.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
-
-    DiskLruCache.Editor creator2 = cache.edit("k1");
-    setString(creator2, 0, "B");
-    setString(creator2, 1, "C");
-    creator2.commit();
-  }
-
-  @Test public void revertWithTooFewValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    creator.abort();
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    DiskLruCache.Editor updater = cache.edit("k1");
-    setString(updater, 0, "C");
-    updater.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "C");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void growMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    cache.setMaxSize(20);
-    set("c", "c", "c"); // size 12
-    assertEquals(12, cache.size());
-  }
-
-  @Test public void shrinkMaxSizeEvicts() throws Exception {
-    cache.close();
-    createNewCacheWithSize(20);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    set("c", "c", "c"); // size 12
-    cache.setMaxSize(10);
-    assertEquals(1, executor.jobs.size());
-  }
-
-  @Test public void evictOnInsert() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    assertEquals(10, cache.size());
-
-    // Cause the size to grow to 12 should evict 'A'.
-    set("c", "c", "c");
-    cache.flush();
-    assertEquals(8, cache.size());
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-
-    // Causing the size to grow to 10 should evict nothing.
-    set("d", "d", "d");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-    assertValue("d", "d", "d");
-
-    // Causing the size to grow to 18 should evict 'B' and 'C'.
-    set("e", "eeee", "eeee");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "eeee", "eeee");
-  }
-
-  @Test public void evictOnUpdate() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aa"); // size 3
-    set("b", "b", "bb"); // size 3
-    set("c", "c", "cc"); // size 3
-    assertEquals(9, cache.size());
-
-    // Causing the size to grow to 11 should evict 'A'.
-    set("b", "b", "bbbb");
-    cache.flush();
-    assertEquals(8, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "bbbb");
-    assertValue("c", "c", "cc");
-  }
-
-  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    cache.get("b").close(); // 'B' is now least recently used.
-
-    // Causing the size to grow to 12 should evict 'A'.
-    set("f", "f", "f");
-    // Causing the size to grow to 12 should evict 'C'.
-    set("g", "g", "g");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-  }
-
-  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    set("f", "f", "f");
-    cache.get("b").close(); // 'B' is now least recently used.
-    assertEquals(12, cache.size());
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("g", "g", "g");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-    assertValue("g", "g", "g");
-  }
-
-  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaa", "aaaaaa"); // size=11
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaaaaaaaa", "a"); // size=12
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void removeAbsentElement() throws Exception {
-    cache.remove("a");
-  }
-
-  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
-    set("a", "a", "b");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertSame(snapshot.getSource(0), snapshot.getSource(0));
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-    }
-  }
-
-  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    executor.jobs.removeFirst().run();
-
-    // Sanity check that a rebuilt journal behaves normally.
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Don't allow edits under any circumstances.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("c"));
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertNull(snapshot.edit());
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalFailureIsRetried() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // The rebuild is retried on cache hits and on cache edits.
-    DiskLruCache.Snapshot snapshot = cache.get("b");
-    snapshot.close();
-    assertNull(cache.edit("d"));
-    assertEquals(2, executor.jobs.size());
-
-    // On cache misses, no retry job is queued.
-    assertNull(cache.get("c"));
-    assertEquals(2, executor.jobs.size());
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // In-flight editors can commit and have their values retained.
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    cache.close();
-    createNewCache();
-
-    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
-    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
-    // entirely on a subsequent open.
-    assertEquals(4, cache.size());
-    assertAbsent("c");
-    assertAbsent("d");
-    assertAbsent("e");
-  }
-
-  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertTrue(cache.remove("a"));
-    assertAbsent("a");
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-
-    assertJournalEquals("CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertTrue(cache.remove("a"));
-    assertAbsent("a");
-
-    cache.close();
-    createNewCache();
-
-    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
-    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
-    // with missing cache files, it should remove it from the cache entirely.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertEquals(2, cache.size());
-  }
-
-  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    cache.evictAll();
-
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-
-    cache.close();
-    createNewCache();
-
-    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
-    // when it tries to read the cache files for either entry, it will discover the cache files are
-    // missing and remove the entries from the cache.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertNull(cache.get("b"));
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "aa", "aa");
-      set("b", "bb", "bb");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Trigger a job to trim the cache.
-    cache.setMaxSize(4);
-    executor.jobs.removeFirst().run();
-
-    assertAbsent("a");
-    assertValue("b", "bb", "bb");
-  }
-
-  @Test public void restoreBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.close();
-
-    fileSystem.rename(journalFile, journalBkpFile);
-    assertFalse(fileSystem.exists(journalFile));
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
-  }
-
-  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.flush();
-
-    copyFile(journalFile, journalBkpFile);
-
-    creator = cache.edit("k2");
-    setString(creator, 0, "F");
-    setString(creator, 1, "GH");
-    creator.commit();
-    cache.close();
-
-    assertTrue(fileSystem.exists(journalFile));
-    assertTrue(fileSystem.exists(journalBkpFile));
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshotA = cache.get("k1");
-    assertSnapshotValue(snapshotA, 0, "ABC");
-    assertSnapshotValue(snapshotA, 1, "DE");
-
-    DiskLruCache.Snapshot snapshotB = cache.get("k2");
-    assertSnapshotValue(snapshotB, 0, "F");
-    assertSnapshotValue(snapshotB, 1, "GH");
-
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
-  }
-
-  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
-    cache.close();
-    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
-    set("a", "a", "a");
-    assertTrue(fileSystem.exists(new File(dir, "a.0")));
-    assertTrue(fileSystem.exists(new File(dir, "a.1")));
-    assertTrue(fileSystem.exists(new File(dir, "journal")));
-  }
-
-  @Test public void fileDeletedExternally() throws Exception {
-    set("a", "a", "a");
-    fileSystem.delete(getCleanFile("a", 1));
-    assertNull(cache.get("a"));
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void editSameVersion() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeAborted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.abort();
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.commit();
-    assertNull(snapshot.edit());
-  }
-
-  @Test public void editSinceEvicted() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    cache.flush();
-    assertNull(snapshot.edit());
-  }
-
-  @Test public void editSinceEvictedAndRecreated() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    set("a", "a", "aaaa"); // size 5; will evict 'B'
-    cache.flush();
-    assertNull(snapshot.edit());
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    set("a", "a", "a");
-    assertValue("a", "a", "a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesEdit() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-  }
-
-  @Test public void removeHandlesMissingFile() throws Exception {
-    set("a", "a", "a");
-    getCleanFile("a", 0).delete();
-    cache.remove("a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    setString(a, 0, "a1");
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-    assertNull(cache.get("a"));
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesRead() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    assertNull(cache.get("a"));
-  }
-
-  /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
-   * being edited required deletion for the operation to complete.
-   */
-  @Test public void trimToSizeWithActiveEdit() throws Exception {
-    set("a", "a1234", "a1234");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a123");
-
-    cache.setMaxSize(8); // Smaller than the sum of active edits!
-    cache.flush(); // Force trimToSize().
-    assertEquals(0, cache.size());
-    assertNull(cache.get("a"));
-
-    // After the edit is completed, its entry is still gone.
-    setString(a, 1, "a1");
-    a.commit();
-    assertAbsent("a");
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void evictAll() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-  }
-
-  @Test public void evictAllWithPartialCreate() throws Exception {
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    assertSnapshotValue(a, 0, "a");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertSnapshotValue(a, 1, "a");
-    a.close();
-  }
-
-  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertNull(a.edit());
-    a.close();
-  }
-
-  @Test public void iterator() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    set("c", "c1", "c2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    assertSnapshotValue(a, 0, "a1");
-    assertSnapshotValue(a, 1, "a2");
-    a.close();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    assertSnapshotValue(b, 0, "b1");
-    assertSnapshotValue(b, 1, "b2");
-    b.close();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot c = iterator.next();
-    assertEquals("c", c.key());
-    assertSnapshotValue(c, 0, "c1");
-    assertSnapshotValue(c, 1, "c2");
-    c.close();
-
-    assertFalse(iterator.hasNext());
-    try {
-      iterator.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    set("c", "c1", "c2");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    b.close();
-
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    set("b", "b3", "b4");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    assertSnapshotValue(b, 0, "b3");
-    assertSnapshotValue(b, 1, "b4");
-    b.close();
-  }
-
-  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    cache.remove("b");
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void iteratorRemove() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    a.close();
-    iterator.remove();
-
-    assertEquals(null, cache.get("a"));
-  }
-
-  @Test public void iteratorRemoveBeforeNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    iterator.remove();
-    a.close();
-
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cacheClosedTruncatesIterator() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    cache.close();
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void isClosed_uninitializedCache() throws Exception {
-    // Create an uninitialized cache.
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    assertFalse(cache.isClosed());
-    cache.close();
-    assertTrue(cache.isClosed());
-  }
-
-  @Test public void journalWriteFailsDuringEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertNull(cache.edit("c"));
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  /**
-   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
-   * https://github.com/square/okhttp/issues/1211
-   */
-  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during commit.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.commit();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during abort.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.abort();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringRemove() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Remove, but the journal write will fail.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertTrue(cache.remove("a"));
-
-    // Confirm that the entry was still removed.
-    fileSystem.setFaultyWrite(journalFile, false);
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-  }
-
-  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm that edits are prevented after a cache trim failure.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("b"));
-    assertNull(cache.edit("c"));
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // An edit should now add a job to clean up if the most recent trim failed.
-    assertNull(cache.edit("b"));
-    executor.jobs.pop().run();
-
-    // Confirm a successful cache trim now allows edits.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertNull(cache.edit("c"));
-    executor.jobs.pop().run();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aaa");
-    set("b", "bb", "bb");
-    DiskLruCache.Editor inFlightEditor = cache.edit("c");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // The in-flight editor can still write after a trim failure.
-    setString(inFlightEditor, 0, "cc");
-    setString(inFlightEditor, 1, "cc");
-    inFlightEditor.commit();
-
-    // Confirm the committed values are present after a successful cache trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    executor.jobs.pop().run();
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we still allow snapshot reads after a trim failure.
-    assertValue("a", "aa", "aa");
-    assertValue("b", "bb", "bbb");
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm snapshot writes are prevented after a trim failure.
-    DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertNull(snapshot1.edit());
-    snapshot1.close();
-    DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertNull(snapshot2.edit());
-    snapshot2.close();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful eviction should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.evictAll();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful removal which trims the cache should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.remove("a");
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful flush trims the cache and should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.flush();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim to fail on the second value leaving a partial snapshot.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
-    executor.jobs.pop().run();
-
-    // Confirm the partial snapshot is not returned.
-    assertNull(cache.get("a"));
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("a"));
-
-    // Confirm the partial snapshot is not returned after a successful trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
-    executor.jobs.pop().run();
-    assertNull(cache.get("a"));
-  }
-
-  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "a");
-    setString(editor, 1, "a");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "bb", "bb");
-    assertEquals(4, cache.size());
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertEquals(4, cache.size());
-    assertValue("k1", "bb", "bb");
-  }
-
-  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "bb");
-    setString(editor, 1, "bb");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "ccc", "ccc");
-    assertEquals(6, cache.size());
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertEquals(6, cache.size());
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void noNewSourceAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    assertNull(editor.newSource(0));
-  }
-
-  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor, then detach it.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(editor.newSink(0));
-    cache.evictAll();
-
-    // Create another value in its place.
-    set("k1", "ccc", "ccc");
-
-    // Complete the original edit. It goes into a black hole.
-    sink.writeUtf8("bb");
-    sink.close();
-
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void abortAfterDetach() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    editor.abort();
-    assertEquals(0, cache.size());
-    assertAbsent("k1");
-  }
-
-  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
-    List<String> expectedLines = new ArrayList<>();
-    expectedLines.add(MAGIC);
-    expectedLines.add(VERSION_1);
-    expectedLines.add("100");
-    expectedLines.add("2");
-    expectedLines.add("");
-    expectedLines.addAll(Arrays.asList(expectedBodyLines));
-    assertEquals(expectedLines, readJournalLines());
-  }
-
-  private void createJournal(String... bodyLines) throws Exception {
-    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
-  }
-
-  private void createJournalWithHeader(String magic, String version, String appVersion,
-      String valueCount, String blank, String... bodyLines) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(magic + "\n");
-    sink.writeUtf8(version + "\n");
-    sink.writeUtf8(appVersion + "\n");
-    sink.writeUtf8(valueCount + "\n");
-    sink.writeUtf8(blank + "\n");
-    for (String line : bodyLines) {
-      sink.writeUtf8(line);
-      sink.writeUtf8("\n");
-    }
-    sink.close();
-  }
-
-  private List<String> readJournalLines() throws Exception {
-    List<String> result = new ArrayList<>();
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      result.add(line);
-    }
-    source.close();
-    return result;
-  }
-
-  private File getCleanFile(String key, int index) {
-    return new File(cacheDir, key + "." + index);
-  }
-
-  private File getDirtyFile(String key, int index) {
-    return new File(cacheDir, key + "." + index + ".tmp");
-  }
-
-  private String readFile(File file) throws Exception {
-    BufferedSource source = Okio.buffer(fileSystem.source(file));
-    String result = source.readUtf8();
-    source.close();
-    return result;
-  }
-
-  public void writeFile(File file, String content) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
-    try {
-      setString(editor, 0, "A");
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSource(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSink(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.abort();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  private void generateSomeGarbageFiles() throws Exception {
-    File dir1 = new File(cacheDir, "dir1");
-    File dir2 = new File(dir1, "dir2");
-    writeFile(getCleanFile("g1", 0), "A");
-    writeFile(getCleanFile("g1", 1), "B");
-    writeFile(getCleanFile("g2", 0), "C");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(new File(cacheDir, "otherFile0"), "E");
-    writeFile(new File(dir2, "otherFile1"), "F");
-  }
-
-  private void assertGarbageFilesAllDeleted() {
-    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
-    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
-    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
-  }
-
-  private void set(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Editor editor = cache.edit(key);
-    setString(editor, 0, value0);
-    setString(editor, 1, value1);
-    editor.commit();
-  }
-
-  public static void setString(DiskLruCache.Editor editor, int index, String value)
-      throws IOException {
-    BufferedSink writer = Okio.buffer(editor.newSink(index));
-    writer.writeUtf8(value);
-    writer.close();
-  }
-
-  private void assertAbsent(String key) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    if (snapshot != null) {
-      snapshot.close();
-      fail();
-    }
-    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
-    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
-  }
-
-  private void assertValue(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    assertSnapshotValue(snapshot, 0, value0);
-    assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
-    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
-    snapshot.close();
-  }
-
-  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
-      throws IOException {
-    assertEquals(value, sourceAsString(snapshot.getSource(index)));
-    assertEquals(value.length(), snapshot.getLength(index));
-  }
-
-  private String sourceAsString(Source source) throws IOException {
-    return source != null ? Okio.buffer(source).readUtf8() : null;
-  }
-
-  private void copyFile(File from, File to) throws IOException {
-    Source source = fileSystem.source(from);
-    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
-    sink.writeAll(source);
-    source.close();
-    sink.close();
-  }
-
-  private static class TestExecutor implements Executor {
-    final Deque<Runnable> jobs = new ArrayDeque<>();
-
-    @Override public void execute(Runnable command) {
-      jobs.addLast(command);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
deleted file mode 100644
index ff3fb12270..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.net.SocketException;
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HeldCertificate;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class ClientAuthTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private HeldCertificate serverRootCa;
-  private HeldCertificate serverIntermediateCa;
-  private HeldCertificate serverCert;
-  private HeldCertificate clientRootCa;
-  private HeldCertificate clientIntermediateCa;
-  private HeldCertificate clientCert;
-
-  @Before
-  public void setUp() {
-    serverRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    serverIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName("Local Host")
-        .addSubjectAlternativeName(server.getHostName())
-        .build();
-
-    clientRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    clientIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    clientCert = new HeldCertificate.Builder()
-        .signedBy(clientIntermediateCa)
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .addSubjectAlternativeName("jethrowillis.com")
-        .build();
-  }
-
-  @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
-  }
-
-  @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
-  }
-
-  @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.noClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
-  }
-
-  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
-  }
-
-  @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
-    } catch (SocketException expected) {
-      assertEquals("jdk9", getPlatform());
-    }
-  }
-
-  @Test public void commonNameIsNotTrusted() throws Exception {
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .addSubjectAlternativeName("different-host.com")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void invalidClientAuthFails() throws Throwable {
-    HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert2);
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      // javax.net.ssl.SSLException: readRecord
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
-    } catch (SocketException expected) {
-      assertEquals("jdk9", getPlatform());
-    }
-  }
-
-  private OkHttpClient buildClient(
-      HeldCertificate heldCertificate, X509Certificate... intermediates) {
-    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverRootCa.certificate());
-
-    if (heldCertificate != null) {
-      builder.heldCertificate(heldCertificate, intermediates);
-    }
-
-    HandshakeCertificates handshakeCertificates = builder.build();
-    return defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-  }
-
-  private SSLSocketFactory buildServerSslSocketFactory() {
-    // The test uses JDK default SSL Context instead of the Platform provided one
-    // as Conscrypt seems to have some differences, we only want to test client side here.
-    try {
-      X509KeyManager keyManager = newKeyManager(
-          null, serverCert, serverIntermediateCa.certificate());
-      X509TrustManager trustManager = newTrustManager(
-          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
-          new SecureRandom());
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 0bd07c596c..dfa5336cc4 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -36,6 +36,58 @@
 
   <build>
     <plugins>
+			<plugin>
+				<groupId>org.openclover</groupId>
+				<artifactId>clover-maven-plugin</artifactId>
+				<version>4.2.0</version>
+				<configuration>
+					<generateXml>true</generateXml>
+					<generateHtml>false</generateHtml>
+					<generatePdf>false</generatePdf>
+					<generateJson>false</generateJson>
+				</configuration>
+				<executions>
+					<execution>
+						<phase>site</phase>
+						<goals>
+							<goal>instrument</goal>
+							<goal>clover</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-surefire-plugin</artifactId>
+          <version>2.21.0</version>
+          <configuration>
+            <systemPropertyVariables>
+              <okhttp.platform>${okhttp.platform}</okhttp.platform>
+            </systemPropertyVariables>
+			<systemPropertyVariables>
+						<CORONA_HOME>${project.parent.basedir}/analyser/src/main</CORONA_HOME>
+			</systemPropertyVariables>
+            <redirectTestOutputToFile>true</redirectTestOutputToFile>
+            <properties>
+              <!--
+                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
+                tests. Every test must have a <scope>test</scope> dependency on
+                okhttp-testing-support.
+                -->
+              <property>
+                <name>listener</name>
+                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
+              </property>
+            </properties>
+          </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.21.0</version>
+            </dependency>
+          </dependencies>
+        </plugin>
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>templating-maven-plugin</artifactId>
diff --git a/pom.xml b/pom.xml
index c9f70dc54e..c213cce81b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,9 +20,9 @@
 
   <modules>
     <module>okhttp</module>
-    <module>okhttp-tests</module>
+  <module>okhttp-tests</module>
 
-    <module>okhttp-android-support</module>
+     <!--  <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
     <module>okhttp-sse</module>
@@ -37,7 +37,7 @@
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
-    <module>benchmarks</module>
+    <module>benchmarks</module> -->
   </modules>
 
   <properties>
@@ -180,6 +180,9 @@
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
             </systemPropertyVariables>
+			<systemPropertyVariables>
+						<CORONA_HOME>${project.parent.basedir}/analyser/src/main</CORONA_HOME>
+			</systemPropertyVariables>
             <redirectTestOutputToFile>true</redirectTestOutputToFile>
             <properties>
               <!--
@@ -201,7 +204,6 @@
             </dependency>
           </dependencies>
         </plugin>
-
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
@@ -211,6 +213,29 @@
     </pluginManagement>
 
     <plugins>
+	
+	<plugin>
+				<groupId>org.openclover</groupId>
+				<artifactId>clover-maven-plugin</artifactId>
+				<version>4.2.0</version>
+				<configuration>
+					<generateXml>true</generateXml>
+					<generateHtml>false</generateHtml>
+					<generatePdf>false</generatePdf>
+					<generateJson>false</generateJson>
+				</configuration>
+				<executions>
+					<execution>
+						<phase>site</phase>
+						<goals>
+							<goal>instrument</goal>
+							<goal>clover</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			
+	
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
