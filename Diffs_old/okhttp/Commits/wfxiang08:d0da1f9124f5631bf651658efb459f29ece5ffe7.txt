diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 6ed941b8f2..47d17b677b 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -139,6 +139,7 @@
   private static final int ENTRY_BODY = 1;
   private static final int ENTRY_COUNT = 2;
 
+  // InternalCache做什么呢?
   final InternalCache internalCache = new InternalCache() {
     @Override public Response get(Request request) throws IOException {
       return Cache.this.get(request);
@@ -179,15 +180,20 @@ public Cache(File directory, long maxSize) {
   }
 
   Cache(File directory, long maxSize, FileSystem fileSystem) {
+    // 目录，文件系统，大小
     this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
+  // 这个需要做一些修改
   public static String key(HttpUrl url) {
     return ByteString.encodeUtf8(url.toString()).md5().hex();
   }
 
   Response get(Request request) {
+    // TODO: request.url()可以优化，例如: hls等可以去掉Expires/token之类的参数，也可以无限cache
     String key = key(request.url());
+
+    // 1. 获取snapshot
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -207,8 +213,10 @@ Response get(Request request) {
       return null;
     }
 
+    // 2. 根据entry获取Response
     Response response = entry.response(snapshot);
 
+    // 3. 如何match resquest和response呢?
     if (!entry.matches(request, response)) {
       Util.closeQuietly(response.body());
       return null;
@@ -217,9 +225,11 @@ Response get(Request request) {
     return response;
   }
 
+  // 如何缓存Response呢？
   CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
+    // 删除缓存
     if (HttpMethod.invalidatesCache(response.request().method())) {
       try {
         remove(response.request());
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 39972c4bfb..cf703373de 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -68,7 +68,7 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.mustRevalidate = false;
     this.maxStaleSeconds = builder.maxStaleSeconds;
     this.minFreshSeconds = builder.minFreshSeconds;
-    this.onlyIfCached = builder.onlyIfCached;
+    this.onlyIfCached = builder.onlyIfCached; // 只读取缓存，没有就失败
     this.noTransform = builder.noTransform;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad21..2cf7c17cf0 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -26,6 +26,7 @@
   Request request();
 
   /**
+   * 如何Block呢? 外部外部如何等待呢？
    * Invokes the request immediately, and blocks until the response can be processed or is in
    * error.
    *
@@ -45,6 +46,7 @@
    * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
    * Response.
    *
+   * 传输层，应用层的关系?
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
    * unhappy HTTP response code like 404 or 500.
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d6f90bb3ac..c59af0af55 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -124,6 +124,7 @@ public synchronized void setIdleCallback(Runnable idleCallback) {
   }
 
   synchronized void enqueue(AsyncCall call) {
+    // 添加异步任务
     if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
       runningAsyncCalls.add(call);
       executorService().execute(call);
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index a2e6db591c..1616cde8df 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -34,6 +34,7 @@
    * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
    */
   Dns SYSTEM = new Dns() {
+    // 系统的DNS实现
     @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
       if (hostname == null) throw new UnknownHostException("hostname == null");
       return Arrays.asList(InetAddress.getAllByName(hostname));
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 6565b9fcd9..31778067ed 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -37,6 +37,7 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
@@ -51,21 +52,22 @@
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
  * responses.
- *
+ * <p>
  * <h3>OkHttpClients should be shared</h3>
- *
+ * <p>
  * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
  * all of your HTTP calls. This is because each client holds its own connection pool and thread
  * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
  * client for each request wastes resources on idle pools.
- *
+ * <p>
+ * 创建共享的Instance
  * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
  * <pre>   {@code
  *
  *   // The singleton HTTP client.
  *   public final OkHttpClient client = new OkHttpClient();
  * }</pre>
- *
+ * <p>
  * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
  * <pre>   {@code
  *
@@ -75,46 +77,46 @@
  *       .cache(new Cache(cacheDir, cacheSize))
  *       .build();
  * }</pre>
- *
+ * <p>
  * <h3>Customize your client with newBuilder()</h3>
- *
+ * <p>
  * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
  * client that shares the same connection pool, thread pools, and configuration. Use the builder
  * methods to configure the derived client for a specific purpose.
- *
+ * <p>
  * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
+ * <p>
  *   OkHttpClient eagerClient = client.newBuilder()
  *       .readTimeout(500, TimeUnit.MILLISECONDS)
  *       .build();
  *   Response response = eagerClient.newCall(request).execute();
  * }</pre>
- *
+ * <p>
  * <h3>Shutdown isn't necessary</h3>
- *
+ * <p>
  * <p>The threads and connections that are held will be released automatically if they remain idle.
  * But if you are writing a application that needs to aggressively release unused resources you may
  * do so.
- *
+ * <p>
  * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
  * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
+ * <p>
  *     client.dispatcher().executorService().shutdown();
  * }</pre>
- *
+ * <p>
  * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
  * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
+ * <p>
  *     client.connectionPool().evictAll();
  * }</pre>
- *
+ * <p>
  * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
  * create calls against a cache that is closed, and doing so will cause the call to crash.
  * <pre>   {@code
  *
  *     client.cache().close();
  * }</pre>
- *
+ * <p>
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
@@ -126,43 +128,53 @@
       ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
+    // 注意这个模块的实现
     Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
+      @Override
+      public void addLenient(Headers.Builder builder, String line) {
         builder.addLenient(line);
       }
 
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+      @Override
+      public void addLenient(Headers.Builder builder, String name, String value) {
         builder.addLenient(name, value);
       }
 
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+      @Override
+      public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
         builder.setInternalCache(internalCache);
       }
 
-      @Override public boolean connectionBecameIdle(
+      @Override
+      public boolean connectionBecameIdle(
           ConnectionPool pool, RealConnection connection) {
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public RealConnection get(
+      @Override
+      public RealConnection get(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
         return pool.get(address, streamAllocation);
       }
 
-      @Override public Closeable deduplicate(
+      @Override
+      public Closeable deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
         return pool.deduplicate(address, streamAllocation);
       }
 
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
+      @Override
+      public void put(ConnectionPool pool, RealConnection connection) {
         pool.put(connection);
       }
 
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+      @Override
+      public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
         return connectionPool.routeDatabase;
       }
 
-      @Override public int code(Response.Builder responseBuilder) {
+      @Override
+      public int code(Response.Builder responseBuilder) {
         return responseBuilder.code;
       }
 
@@ -171,16 +183,19 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         tlsConfiguration.apply(sslSocket, isFallback);
       }
 
-      @Override public HttpUrl getHttpUrlChecked(String url)
+      @Override
+      public HttpUrl getHttpUrlChecked(String url)
           throws MalformedURLException, UnknownHostException {
         return HttpUrl.getChecked(url);
       }
 
-      @Override public StreamAllocation streamAllocation(Call call) {
+      @Override
+      public StreamAllocation streamAllocation(Call call) {
         return ((RealCall) call).streamAllocation();
       }
 
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+      @Override
+      public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return new RealCall(client, originalRequest, true);
       }
     };
@@ -227,7 +242,10 @@ public OkHttpClient() {
     this.proxySelector = builder.proxySelector;
     this.cookieJar = builder.cookieJar;
     this.cache = builder.cache;
+
+    // 这是一个修改cache的机会
     this.internalCache = builder.internalCache;
+
     this.socketFactory = builder.socketFactory;
 
     boolean isTLS = false;
@@ -235,6 +253,7 @@ public OkHttpClient() {
       isTLS = isTLS || spec.isTls();
     }
 
+    // sslSocketFactory的管理
     if (builder.sslSocketFactory != null || !isTLS) {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
@@ -247,6 +266,7 @@ public OkHttpClient() {
     this.hostnameVerifier = builder.hostnameVerifier;
     this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
         certificateChainCleaner);
+
     this.proxyAuthenticator = builder.proxyAuthenticator;
     this.authenticator = builder.authenticator;
     this.connectionPool = builder.connectionPool;
@@ -260,6 +280,7 @@ public OkHttpClient() {
     this.pingInterval = builder.pingInterval;
   }
 
+  // 获取默认的TrustManager
   private X509TrustManager systemDefaultTrustManager() {
     try {
       TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
@@ -279,29 +300,37 @@ private X509TrustManager systemDefaultTrustManager() {
   private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
     try {
       SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslContext.init(null, new TrustManager[]{trustManager}, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
       throw new AssertionError(); // The system has no TLS. Just give up.
     }
   }
 
-  /** Default connect timeout (in milliseconds). */
+  /**
+   * Default connect timeout (in milliseconds).
+   */
   public int connectTimeoutMillis() {
     return connectTimeout;
   }
 
-  /** Default read timeout (in milliseconds). */
+  /**
+   * Default read timeout (in milliseconds).
+   */
   public int readTimeoutMillis() {
     return readTimeout;
   }
 
-  /** Default write timeout (in milliseconds). */
+  /**
+   * Default write timeout (in milliseconds).
+   */
   public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
-  /** Web socket ping interval (in milliseconds). */
+  /**
+   * Web socket ping interval (in milliseconds).
+   */
   public int pingIntervalMillis() {
     return pingInterval;
   }
@@ -322,6 +351,7 @@ public Cache cache() {
     return cache;
   }
 
+  // 这是一个修改OkHttpClient的机会
   InternalCache internalCache() {
     return cache != null ? cache.internalCache : internalCache;
   }
@@ -403,14 +433,17 @@ public Dispatcher dispatcher() {
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
-  @Override public Call newCall(Request request) {
+  @Override
+  public Call newCall(Request request) {
+    // 如何创建一个网络请求呢?
     return new RealCall(this, request, false /* for web socket */);
   }
 
   /**
    * Uses {@code request} to connect a new web socket.
    */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+  @Override
+  public WebSocket newWebSocket(Request request, WebSocketListener listener) {
     RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
     webSocket.connect(this);
     return webSocket;
@@ -470,6 +503,7 @@ public Builder() {
       pingInterval = 0;
     }
 
+    // 从: OkHttpClient创建Builder
     Builder(OkHttpClient okHttpClient) {
       this.dispatcher = okHttpClient.dispatcher;
       this.proxy = okHttpClient.proxy;
@@ -532,7 +566,7 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
      * automatically send web socket ping frames until either the web socket fails or it is closed.
      * This keeps the connection alive and may detect connectivity failures early. No timeouts are
      * enforced on the acknowledging pongs.
-     *
+     * <p>
      * <p>The default value of 0 disables client-initiated pings.
      */
     public Builder pingInterval(long interval, TimeUnit unit) {
@@ -563,7 +597,7 @@ public Builder proxy(Proxy proxy) {
      * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
      * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
      * in sequence until a successful connection is established.
-     *
+     * <p>
      * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
      * be used.
      */
@@ -575,7 +609,7 @@ public Builder proxySelector(ProxySelector proxySelector) {
     /**
      * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
      * outgoing HTTP requests.
-     *
+     * <p>
      * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
      */
     public Builder cookieJar(CookieJar cookieJar) {
@@ -584,13 +618,20 @@ public Builder cookieJar(CookieJar cookieJar) {
       return this;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
+    // 这两个似乎冲突呀?
+    // internalCache vs. cache
+
+    /**
+     * Sets the response cache to be used to read and write cached responses.
+     */
     void setInternalCache(InternalCache internalCache) {
       this.internalCache = internalCache;
       this.cache = null;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
+    /**
+     * Sets the response cache to be used to read and write cached responses.
+     */
     public Builder cache(Cache cache) {
       this.cache = cache;
       this.internalCache = null;
@@ -599,11 +640,14 @@ public Builder cache(Cache cache) {
 
     /**
      * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
+     * <p>
      * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
      */
     public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
+      // 如何通过DNS来优化网络请求呢？
+      if (dns == null) {
+        throw new NullPointerException("dns == null");
+      }
       this.dns = dns;
       return this;
     }
@@ -612,12 +656,14 @@ public Builder dns(Dns dns) {
      * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
      * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
      * this method, e. g., allows the socket to be bound to a specific local address.
-     *
+     * <p>
      * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
      * be used.
      */
     public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      if (socketFactory == null) {
+        throw new NullPointerException("socketFactory == null");
+      }
       this.socketFactory = socketFactory;
       return this;
     }
@@ -627,12 +673,14 @@ public Builder socketFactory(SocketFactory socketFactory) {
      * be used.
      *
      * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+     * a field that OkHttp needs to build a clean certificate chain. This method instead must
+     * use reflection to extract the trust manager. Applications should prefer to call {@link
+     * #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
      */
     public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      if (sslSocketFactory == null) {
+        throw new NullPointerException("sslSocketFactory == null");
+      }
       X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
       if (trustManager == null) {
         throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
@@ -646,12 +694,12 @@ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
     /**
      * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
      * system defaults will be used.
-     *
+     * <p>
      * <p>Most applications should not call this method, and instead use the system defaults. Those
      * classes include special optimizations that can be lost if the implementations are decorated.
-     *
+     * <p>
      * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
+     * <p>
      * <pre>   {@code
      *
      *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
@@ -685,11 +733,15 @@ public Builder sslSocketFactory(
     /**
      * Sets the verifier used to confirm that response certificates apply to requested hostnames for
      * HTTPS connections.
-     *
+     * <p>
      * <p>If unset, a default hostname verifier will be used.
      */
     public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+      // 如何验证: hostname?
+      // 这个地方是可以做性能优化的!!!!
+      if (hostnameVerifier == null) {
+        throw new NullPointerException("hostnameVerifier == null");
+      }
       this.hostnameVerifier = hostnameVerifier;
       return this;
     }
@@ -700,6 +752,7 @@ public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
      * Pinning certificates avoids the need to trust certificate authorities.
      */
     public Builder certificatePinner(CertificatePinner certificatePinner) {
+      // 这个也似乎很牛逼!!!
       if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
       this.certificatePinner = certificatePinner;
       return this;
@@ -708,10 +761,11 @@ public Builder certificatePinner(CertificatePinner certificatePinner) {
     /**
      * Sets the authenticator used to respond to challenges from origin servers. Use {@link
      * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
+     * <p>
      * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
      */
     public Builder authenticator(Authenticator authenticator) {
+      // 是否需要认证? 如何需要认证，该做什么呢?
       if (authenticator == null) throw new NullPointerException("authenticator == null");
       this.authenticator = authenticator;
       return this;
@@ -720,7 +774,7 @@ public Builder authenticator(Authenticator authenticator) {
     /**
      * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
      * #authenticator} to set the authenticator for origin servers.
-     *
+     * <p>
      * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
      */
     public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
@@ -731,10 +785,11 @@ public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
 
     /**
      * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
+     * <p>
      * <p>If unset, a new connection pool will be used.
      */
     public Builder connectionPool(ConnectionPool connectionPool) {
+      // 连接池的管理
       if (connectionPool == null) throw new NullPointerException("connectionPool == null");
       this.connectionPool = connectionPool;
       return this;
@@ -742,7 +797,7 @@ public Builder connectionPool(ConnectionPool connectionPool) {
 
     /**
      * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
+     * <p>
      * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
      * HttpURLConnection}'s default.
      */
@@ -751,7 +806,9 @@ public Builder followSslRedirects(boolean followProtocolRedirects) {
       return this;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
+    /**
+     * Configure this client to follow redirects. If unset, redirects will be followed.
+     */
     public Builder followRedirects(boolean followRedirects) {
       this.followRedirects = followRedirects;
       return this;
@@ -760,18 +817,18 @@ public Builder followRedirects(boolean followRedirects) {
     /**
      * Configure this client to retry or not when a connectivity problem is encountered. By default,
      * this client silently recovers from the following problems:
-     *
+     * <p>
      * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
+     * <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     * failure to reach any individual IP address doesn't fail the overall request. This can
+     * increase availability of multi-homed services.
+     * <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     * to decrease request latency, but these connections will occasionally time out.
+     * <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     * attempt multiple proxy servers in sequence, eventually falling back to a direct
+     * connection.
      * </ul>
-     *
+     * <p>
      * Set this to false to avoid retrying requests when doing so is destructive. In this case the
      * calling application should do its own recovery of connectivity failures.
      */
@@ -794,27 +851,27 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * this client will prefer the most efficient transport available, falling back to more
      * ubiquitous protocols. Applications should only call this method to avoid specific
      * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
+     * <p>
      * <p>The following protocols are currently supported:
-     *
+     * <p>
      * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     * <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
      * </ul>
-     *
+     * <p>
      * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
      * protocols. The http/1.1 transport will never be dropped.
-     *
+     * <p>
      * <p>If multiple protocols are specified, <a
      * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
      * negotiate a transport.
-     *
+     * <p>
      * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
      * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
      * Response#protocol()}.
      *
      * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     *                  Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
       // Create a private copy of the list.
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index ab3ddb088f..a7db1820f0 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -31,10 +32,13 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
+  // 基于OKHttpClient的Call实现
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
 
-  /** The application's original request unadulterated by redirects or auth headers. */
+  /**
+   * The application's original request unadulterated by redirects or auth headers.
+   */
   final Request originalRequest;
   final boolean forWebSocket;
 
@@ -48,20 +52,31 @@
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
-  @Override public Request request() {
+  @Override
+  public Request request() {
     return originalRequest;
   }
 
-  @Override public Response execute() throws IOException {
+  // 使用模式: 创建RealCall(xxx)之后，立即调用: execute
+  @Override
+  public Response execute() throws IOException {
     synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
+      if (executed) {
+        throw new IllegalStateException("Already Executed");
+      }
       executed = true;
     }
+
     captureCallStackTrace();
     try {
+      // 通过: dispatch来执行自己
+      // 同步网络请求
       client.dispatcher().executed(this);
+
       Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
+      if (result == null) {
+        throw new IOException("Canceled");
+      }
       return result;
     } finally {
       client.dispatcher().finished(this);
@@ -73,29 +88,38 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
-  @Override public void enqueue(Callback responseCallback) {
+  @Override
+  public void enqueue(Callback responseCallback) {
     synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
+      if (executed) {
+        throw new IllegalStateException("Already Executed");
+      }
       executed = true;
     }
     captureCallStackTrace();
+
+    // 添加到client中，通过callback异步通知caller
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
-  @Override public void cancel() {
+  @Override
+  public void cancel() {
     retryAndFollowUpInterceptor.cancel();
   }
 
-  @Override public synchronized boolean isExecuted() {
+  @Override
+  public synchronized boolean isExecuted() {
     return executed;
   }
 
-  @Override public boolean isCanceled() {
+  @Override
+  public boolean isCanceled() {
     return retryAndFollowUpInterceptor.isCanceled();
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
+  @Override
+  public RealCall clone() {
     return new RealCall(client, originalRequest, forWebSocket);
   }
 
@@ -123,7 +147,8 @@ RealCall get() {
       return RealCall.this;
     }
 
-    @Override protected void execute() {
+    @Override
+    protected void execute() {
       boolean signalledCallback = false;
       try {
         Response response = getResponseWithInterceptorChain();
@@ -164,18 +189,23 @@ String redactedUrl() {
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
+
+    // 这些Interceptors是如何工作的呢?
     interceptors.addAll(client.interceptors());
     interceptors.add(retryAndFollowUpInterceptor);
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
+    interceptors.add(new CacheInterceptor(client.internalCache())); // 缓存的管理
     interceptors.add(new ConnectInterceptor(client));
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
+    // 将全部的Interceptors构成一个Chain
     Interceptor.Chain chain = new RealInterceptorChain(
         interceptors, null, null, null, 0, originalRequest);
+
+    // 开始处理整个Chain
     return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
index ff9729e2af..0eccf50d15 100644
--- a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
@@ -25,7 +25,8 @@ public NamedRunnable(String format, Object... args) {
     this.name = Util.format(format, args);
   }
 
-  @Override public final void run() {
+  @Override
+  public final void run() {
     String oldName = Thread.currentThread().getName();
     Thread.currentThread().setName(name);
     try {
@@ -35,5 +36,7 @@ public NamedRunnable(String format, Object... args) {
     }
   }
 
+  // Runnable， Thread有名字
+  // 执行execute
   protected abstract void execute();
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 18d4fd9813..485c3b8c4a 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -49,13 +49,16 @@ public CacheInterceptor(InternalCache cache) {
     this.cache = cache;
   }
 
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
+  @Override
+  public Response intercept(Chain chain) throws IOException {
+    // 如何通过Inteceptor实现Cache操作呢?
+
+    // 1. cache
+    Response cacheCandidate = cache != null  ? cache.get(chain.request()) : null;
 
     long now = System.currentTimeMillis();
 
+    // 2. 通过CacheStrategy来处理cacheResponse
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
@@ -70,6 +73,7 @@ public CacheInterceptor(InternalCache cache) {
 
     // If we're forbidden from using the network and the cache is insufficient, fail.
     if (networkRequest == null && cacheResponse == null) {
+      // 只读取缓存，报告失败
       return new Response.Builder()
           .request(chain.request())
           .protocol(Protocol.HTTP_1_1)
@@ -83,11 +87,14 @@ public CacheInterceptor(InternalCache cache) {
 
     // If we don't need the network, we're done.
     if (networkRequest == null) {
+      // 不需要网络请求，直接返回结果
       return cacheResponse.newBuilder()
           .cacheResponse(stripBody(cacheResponse))
           .build();
     }
 
+
+    // 本地缓存无用，请求网络
     Response networkResponse = null;
     try {
       networkResponse = chain.proceed(networkRequest);
@@ -99,8 +106,10 @@ public CacheInterceptor(InternalCache cache) {
     }
 
     // If we have a cache response too, then we're doing a conditional get.
+    // 304, Etag， ModifySince
     if (cacheResponse != null) {
       if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+        // Etag, Modify Since必须是要求: 数据在本地有缓存，否则傻逼了
         Response response = cacheResponse.newBuilder()
             .headers(combine(cacheResponse.headers(), networkResponse.headers()))
             .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
@@ -112,6 +121,7 @@ public CacheInterceptor(InternalCache cache) {
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
+        // 更新统计数据
         cache.trackConditionalCacheHit();
         cache.update(cacheResponse, response);
         return response;
@@ -120,12 +130,14 @@ public CacheInterceptor(InternalCache cache) {
       }
     }
 
+    // 普通的请求
     Response response = networkResponse.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .networkResponse(stripBody(networkResponse))
         .build();
 
     if (HttpHeaders.hasBody(response)) {
+      // 普通的请求是否需要Cache
       CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
       response = cacheWritingResponse(cacheRequest, response);
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index dae556bb98..3eb9e8f892 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -47,6 +47,7 @@
  * potentially stale).
  */
 public final class CacheStrategy {
+  // 注意两个参数的意义：返回的缓存，或者继续？？？
   /** The request to send on the network, or null if this call doesn't use the network. */
   public final Request networkRequest;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index ad9759acce..83109c4a9c 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -16,12 +16,15 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 import okio.Sink;
 
-/** Encodes HTTP requests and decodes HTTP responses. */
+/**
+ * Encodes HTTP requests and decodes HTTP responses.
+ */
 public interface HttpCodec {
   /**
    * The timeout to use while discarding a stream of input data. Since this is used for connection
@@ -30,27 +33,37 @@
    */
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
-  /** Returns an output stream where the request body can be streamed. */
+  /**
+   * Returns an output stream where the request body can be streamed.
+   */
   Sink createRequestBody(Request request, long contentLength);
 
-  /** This should update the HTTP engine's sentRequestMillis field. */
+  /**
+   * This should update the HTTP engine's sentRequestMillis field.
+   */
   void writeRequestHeaders(Request request) throws IOException;
 
-  /** Flush the request to the underlying socket. */
+  /**
+   * Flush the request to the underlying socket.
+   */
   void flushRequest() throws IOException;
 
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
+  /**
+   * Flush the request to the underlying socket and signal no more bytes will be transmitted.
+   */
   void finishRequest() throws IOException;
 
   /**
    * Parses bytes of a response header from an HTTP transport.
    *
    * @param expectContinue true to return null if this is an intermediate response with a "100"
-   *     response code. Otherwise this method never returns null.
+   *                       response code. Otherwise this method never returns null.
    */
   Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
-  /** Returns a stream that reads the response body. */
+  /**
+   * Returns a stream that reads the response body.
+   */
   ResponseBody openResponseBody(Response response) throws IOException;
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index d5326c64f5..d6cd94b4e4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Connection;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
@@ -38,7 +39,7 @@
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, Connection connection, int index, Request request) {
+                              HttpCodec httpCodec, Connection connection, int index, Request request) {
     this.interceptors = interceptors;
     this.connection = connection;
     this.streamAllocation = streamAllocation;
@@ -47,7 +48,8 @@ public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation str
     this.request = request;
   }
 
-  @Override public Connection connection() {
+  @Override
+  public Connection connection() {
     return connection;
   }
 
@@ -55,21 +57,28 @@ public StreamAllocation streamAllocation() {
     return streamAllocation;
   }
 
+  // Http编解码
   public HttpCodec httpStream() {
     return httpCodec;
   }
 
-  @Override public Request request() {
+  @Override
+  public Request request() {
     return request;
   }
 
-  @Override public Response proceed(Request request) throws IOException {
+  // Chain如何处理请求呢?
+  @Override
+  public Response proceed(Request request) throws IOException {
     return proceed(request, streamAllocation, httpCodec, connection);
   }
 
   public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      Connection connection) throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
+                          Connection connection) throws IOException {
+    // 从指定的位置: index 开始执行 interceptors
+    if (index >= interceptors.size()) {
+      throw new AssertionError();
+    }
 
     calls++;
 
@@ -88,7 +97,13 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     // Call the next interceptor in the chain.
     RealInterceptorChain next = new RealInterceptorChain(
         interceptors, streamAllocation, httpCodec, connection, index + 1, request);
+
+    // 执行当前的Interceptor, 然后call下一个?
+    // Chain和 interceptors的关系?
+    // interceptors通过Chain来实现这种往下传递的关系
     Interceptor interceptor = interceptors.get(index);
+
+    // 执行当前的interceptor, 然后再处理下一个
     Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..e44f47ff21 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -26,6 +26,7 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
@@ -77,7 +78,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
    * Immediately closes the socket connection if it's currently held. Use this to interrupt an
    * in-flight request from any thread. It's the caller's responsibility to close the request body
    * and response body streams; otherwise resources may be leaked.
-   *
+   * <p>
    * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
    * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
    * Otherwise if a socket connection is being established, that is terminated.
@@ -100,7 +101,8 @@ public StreamAllocation streamAllocation() {
     return streamAllocation;
   }
 
-  @Override public Response intercept(Chain chain) throws IOException {
+  @Override
+  public Response intercept(Chain chain) throws IOException {
     Request request = chain.request();
 
     streamAllocation = new StreamAllocation(
@@ -144,8 +146,8 @@ public StreamAllocation streamAllocation() {
       if (priorResponse != null) {
         response = response.newBuilder()
             .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
+                .body(null)
+                .build())
             .build();
       }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index befd80983c..bef00700ec 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -19,6 +19,7 @@
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.Set;
+
 import okhttp3.CertificatePinner;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -26,13 +27,23 @@
 import okhttp3.Response;
 
 public final class CheckHandshake {
-  /** Rejects otherwise-trusted certificates. */
+
+  /**
+   * Rejects otherwise-trusted certificates.
+   */
   private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
     Set<String> blacklist = Collections.singleton(
         "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
 
-    @Override public Response intercept(Chain chain) throws IOException {
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+      // Interceptor工作模式:
+      // 1. 抛出异常
+      // 2. 直接返回
+      // 3. 继续处理原始的请求
+      //
       for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
+        // 获取，检查certificate的pin, 没有被禁用，则让下一个Chain处理
         String pin = CertificatePinner.pin(certificate);
         if (blacklist.contains(pin)) {
           throw new IOException("Blacklisted peer certificate: " + pin);
