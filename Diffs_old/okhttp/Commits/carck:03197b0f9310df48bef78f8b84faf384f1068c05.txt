diff --git a/CHANGELOG.md b/CHANGELOG.md
index 57820a45c4..f52d93ada6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,25 @@
 Change Log
 ==========
 
+Version 1.3.0 *(2014-01-11)*
+----------------------------
+
+ * New: Support for "PATCH" HTTP method in client and MockWebServer.
+ * Fix: Drop `Content-Length` header when redirected from POST to GET.
+ * Fix: Correctly read cached header entries with malformed header names.
+ * Fix: Do not directly support any authentication schemes other than "Basic".
+ * Fix: Respect read timeouts on recycled connections.
+ * Fix: Transmit multiple cookie values as a single header with delimiter.
+ * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
+ * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
+ * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
+ * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
+ * Fix: Support SPDY header blocks with trailing bytes.
+ * Fix: Allow `;` as separator for `Cache-Control` header.
+ * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
+ * Fix: Honor read timeout when parsing SPDY headers.
+
+
 Version 1.2.1 *(2013-08-23)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 7b62596189..90a0f0e900 100644
--- a/README.md
+++ b/README.md
@@ -45,10 +45,11 @@ Java 6, otherwise the test class will be silently omitted from the `.dex` file.
 mvn clean
 mvn package -DskipTests
 vogar \
-    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.47/bcprov-jdk15on-1.47.jar \
-    --classpath ~/.m2/repository/com/google/mockwebserver/mockwebserver/20130122/mockwebserver-20130122.jar \
-    --classpath target/okhttp-0.9-SNAPSHOT.jar \
-    ./src/test/java
+    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar \
+    --classpath mockwebserver/target/mockwebserver-2.0.0-SNAPSHOT.jar \
+    --classpath okhttp-protocols/target/okhttp-protocols-2.0.0-SNAPSHOT.jar \
+    --classpath okhttp/target/okhttp-2.0.0-SNAPSHOT.jar \
+    okhttp/src/test
 ```
 
 MockWebServer
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index f33f156ea1..b935acbc68 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -35,18 +35,23 @@
   </dependencies>
 
   <build>
-    <!-- Don't restrict test code to Java 1.5 APIs. -->
     <plugins>
       <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
         <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.0</version>
-          </signature>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
         </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 74e6db01a6..beb4adb36f 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -24,6 +24,7 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
@@ -37,10 +38,14 @@
   /** The response body content, or null if {@code body} is set. */
   private InputStream bodyStream;
 
-  private int bytesPerSecond = Integer.MAX_VALUE;
+  private int throttleBytesPerPeriod = Integer.MAX_VALUE;
+  private long throttlePeriod = 1;
+  private TimeUnit throttleUnit = TimeUnit.SECONDS;
+
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
 
   private int bodyDelayTimeMs = 0;
+
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
     setBody(new byte[0]);
@@ -205,18 +210,30 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
     return this;
   }
 
-  public int getBytesPerSecond() {
-    return bytesPerSecond;
-  }
-
   /**
-   * Set simulated network speed, in bytes per second. This applies to the
-   * response body only; response headers are not throttled.
+   * Throttles the response body writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
+   * network behavior.
    */
-  public MockResponse setBytesPerSecond(int bytesPerSecond) {
-    this.bytesPerSecond = bytesPerSecond;
+  public MockResponse throttleBody(int bytesPerPeriod, long period, TimeUnit unit) {
+    this.throttleBytesPerPeriod = bytesPerPeriod;
+    this.throttlePeriod = period;
+    this.throttleUnit = unit;
     return this;
   }
+
+  public int getThrottleBytesPerPeriod() {
+    return throttleBytesPerPeriod;
+  }
+
+  public long getThrottlePeriod() {
+    return throttlePeriod;
+  }
+
+  public TimeUnit getThrottleUnit() {
+    return throttleUnit;
+  }
+
   /**
    * Set the delayed time of the response body to {@code delay}. This applies to the
    * response body only; response headers are not affected.
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 06dca6a1c8..35dac4dcf3 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -18,6 +18,7 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
@@ -240,13 +241,13 @@ public void play() throws IOException {
    */
   public void play(int port) throws IOException {
     if (executor != null) throw new IllegalStateException("play() already called");
-    executor = Executors.newCachedThreadPool();
+    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     serverSocket = new ServerSocket(port);
     serverSocket.setReuseAddress(true);
 
     this.port = serverSocket.getLocalPort();
-    executor.execute(namedRunnable("MockWebServer-accept-" + port, new Runnable() {
-      public void run() {
+    executor.execute(new NamedRunnable("MockWebServer %s", port) {
+      @Override protected void execute() {
         try {
           acceptConnections();
         } catch (Throwable e) {
@@ -285,7 +286,7 @@ private void acceptConnections() throws Exception {
           }
         }
       }
-    }));
+    });
   }
 
   public void shutdown() throws IOException {
@@ -295,11 +296,10 @@ public void shutdown() throws IOException {
   }
 
   private void serveConnection(final Socket raw) {
-    String name = "MockWebServer-" + raw.getRemoteSocketAddress();
-    executor.execute(namedRunnable(name, new Runnable() {
+    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
 
-      public void run() {
+      @Override protected void execute() {
         try {
           processConnection();
         } catch (Exception e) {
@@ -420,7 +420,7 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         sequenceNumber++;
         return true;
       }
-    }));
+    });
   }
 
   private void processHandshakeFailure(Socket raw) throws Exception {
@@ -536,28 +536,25 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
 
     InputStream in = response.getBodyStream();
     if (in == null) return;
-    int bytesPerSecond = response.getBytesPerSecond();
-
-    // Stream data in MTU-sized increments, with a minimum of one packet per second.
-    byte[] buffer = bytesPerSecond >= 1452 ? new byte[1452] : new byte[bytesPerSecond];
-    long delayMs = bytesPerSecond == Integer.MAX_VALUE
-        ? 0
-        : (1000 * buffer.length) / bytesPerSecond;
-
-    int read;
-    long sinceDelay = 0;
-    while ((read = in.read(buffer)) != -1) {
-      out.write(buffer, 0, read);
-      out.flush();
 
-      sinceDelay += read;
-      if (sinceDelay >= buffer.length && delayMs > 0) {
-        sinceDelay %= buffer.length;
-        try {
-          Thread.sleep(delayMs);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
+    // Stream data in MTU-sized increments, sleeping every bytesPerPeriod bytes.
+    byte[] buffer = new byte[1452];
+    while (true) {
+      int bytesPerPeriod = response.getThrottleBytesPerPeriod();
+      for (int b = 0; b < bytesPerPeriod; ) {
+        int read = in.read(buffer, 0, Math.min(buffer.length, bytesPerPeriod - b));
+        if (read == -1) return;
+
+        out.write(buffer, 0, read);
+        out.flush();
+        b += read;
+      }
+
+      try {
+        long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
+        if (delayMs != 0) Thread.sleep(delayMs);
+      } catch (InterruptedException e) {
+        throw new AssertionError();
       }
     }
   }
@@ -628,20 +625,6 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  private static Runnable namedRunnable(final String name, final Runnable runnable) {
-    return new Runnable() {
-      public void run() {
-        String originalName = Thread.currentThread().getName();
-        Thread.currentThread().setName(name);
-        try {
-          runnable.run();
-        } finally {
-          Thread.currentThread().setName(originalName);
-        }
-      }
-    };
-  }
-
   /** Processes HTTP requests layered over SPDY/3. */
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index f8fa6a4a2d..14eb349b8d 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-protocols/pom.xml b/okhttp-protocols/pom.xml
index 0ecb915146..190af43cf3 100644
--- a/okhttp-protocols/pom.xml
+++ b/okhttp-protocols/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-protocols</artifactId>
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index d5884b1848..33c120d163 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -41,11 +41,25 @@
 /**
  * Access to Platform-specific features necessary for SPDY and advanced TLS.
  *
- * <h3>SPDY</h3>
- * SPDY requires a TLS extension called NPN (Next Protocol Negotiation) that's
- * available in Android 4.1+ and OpenJDK 7+ (with the npn-boot extension). It
- * also requires a recent version of {@code DeflaterOutputStream} that is
- * public API in Java 7 and callable via reflection in Android 4.1+.
+ * <h3>ALPN and NPN</h3>
+ * This class uses TLS extensions ALPN and NPN to negotiate the upgrade from
+ * HTTP/1.1 (the default protocol to use with TLS on port 443) to either SPDY
+ * or HTTP/2.0.
+ *
+ * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
+ * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
+ * Jetty NPN-boot library).
+ *
+ * <p>ALPN (Application Layer Protocol Negotiation) is the successor to NPN. It
+ * has some technical advantages over NPN. We support it on Android (4.4+) only.
+ *
+ * <p>On platforms that support both extensions, OkHttp will use both,
+ * preferring ALPN's result. Future versions of OkHttp will drop support NPN.
+ *
+ * <h3>Deflater Sync Flush</h3>
+ * SPDY header compression requires a recent version of {@code
+ * DeflaterOutputStream} that is public API in Java 7 and callable via
+ * reflection in Android 4.1+.
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -153,14 +167,23 @@ private static Platform findPlatform() {
       setHostname = openSslSocketClass.getMethod("setHostname", String.class);
 
       // Attempt to find Android 4.1+ APIs.
+      Method setNpnProtocols = null;
+      Method getNpnSelectedProtocol = null;
+      Method setAlpnProtocols = null;
+      Method getAlpnSelectedProtocol = null;
       try {
-        Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
-        Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(openSslSocketClass, setUseSessionTickets, setHostname,
-            setNpnProtocols, getNpnSelectedProtocol);
+        setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
+        getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
+        try {
+          setAlpnProtocols = openSslSocketClass.getMethod("setAlpnProtocols", byte[].class);
+          getAlpnSelectedProtocol = openSslSocketClass.getMethod("getAlpnSelectedProtocol");
+        } catch (NoSuchMethodException ignored) {
+        }
       } catch (NoSuchMethodException ignored) {
-        return new Android23(openSslSocketClass, setUseSessionTickets, setHostname);
       }
+
+      return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
+          getNpnSelectedProtocol, setAlpnProtocols, getAlpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     } catch (NoSuchMethodException ignored) {
@@ -187,17 +210,35 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
-  /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Platform {
+  /**
+   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
+   * name indication (SNI). Versions 4.1 supports NPN.
+   */
+  private static class Android extends Platform {
+    // Non-null.
     protected final Class<?> openSslSocketClass;
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
-    private Android23(
-        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname) {
+    // Non-null on Android 4.1+.
+    private final Method setNpnProtocols;
+    private final Method getNpnSelectedProtocol;
+
+    // Non-null on Android 4.4+.
+    private final Method setAlpnProtocols;
+    private final Method getAlpnSelectedProtocol;
+
+    private Android(
+        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol, Method setAlpnProtocols,
+        Method getAlpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
+      this.setNpnProtocols = setNpnProtocols;
+      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
+      this.setAlpnProtocols = setAlpnProtocols;
+      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -215,38 +256,26 @@ private Android23(
 
     @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
       super.enableTlsExtensions(socket, uriHost);
-      if (openSslSocketClass.isInstance(socket)) {
-        // This is Android: use reflection on OpenSslSocketImpl.
-        try {
-          setUseSessionTickets.invoke(socket, true);
-          setHostname.invoke(socket, uriHost);
-        } catch (InvocationTargetException e) {
-          throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
-          throw new AssertionError(e);
-        }
+      if (!openSslSocketClass.isInstance(socket)) return;
+      try {
+        setUseSessionTickets.invoke(socket, true);
+        setHostname.invoke(socket, uriHost);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
       }
     }
-  }
-
-  /** Android version 4.1 and newer support NPN. */
-  private static class Android41 extends Android23 {
-    private final Method setNpnProtocols;
-    private final Method getNpnSelectedProtocol;
-
-    private Android41(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
-        Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(openSslSocketClass, setUseSessionTickets, setHostname);
-      this.setNpnProtocols = setNpnProtocols;
-      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-    }
 
     @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return;
-      }
+      if (setNpnProtocols == null) return;
+      if (!openSslSocketClass.isInstance(socket)) return;
       try {
-        setNpnProtocols.invoke(socket, new Object[] {npnProtocols});
+        Object[] parameters = { npnProtocols };
+        if (setAlpnProtocols != null) {
+          setAlpnProtocols.invoke(socket, parameters);
+        }
+        setNpnProtocols.invoke(socket, parameters);
       } catch (IllegalAccessException e) {
         throw new AssertionError(e);
       } catch (InvocationTargetException e) {
@@ -255,10 +284,14 @@ private Android41(Class<?> openSslSocketClass, Method setUseSessionTickets, Meth
     }
 
     @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return null;
-      }
+      if (getNpnSelectedProtocol == null) return null;
+      if (!openSslSocketClass.isInstance(socket)) return null;
       try {
+        if (getAlpnSelectedProtocol != null) {
+          // Prefer ALPN's result if it is present.
+          byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
+          if (alpnResult != null) return alpnResult;
+        }
         return (byte[]) getNpnSelectedProtocol.invoke(socket);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index c5bb07eaa6..93fc2f03e1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -28,6 +28,7 @@
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.nio.ByteOrder;
@@ -41,6 +42,8 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
@@ -262,12 +265,6 @@ public static String readFully(Reader reader) throws IOException {
     }
   }
 
-  public static void skipAll(InputStream in) throws IOException {
-    do {
-      in.skip(Long.MAX_VALUE);
-    } while (in.read() != -1);
-  }
-
   /**
    * Call {@code in.read()} repeatedly until either the stream is exhausted or
    * {@code byteCount} bytes have been read.
@@ -278,9 +275,16 @@ public static void skipAll(InputStream in) throws IOException {
    * other threads. A thread-local buffer is also insufficient because some
    * streams may call other streams in their skip() method, also clobbering the
    * buffer.
+   *
+   * <p>This method throws a SocketTimeoutException if {@code timeoutMillis}
+   * elapses before the bytes can be skipped.
+   *
+   * @param timeoutMillis the maximum time to wait, or 0 to wait indefinitely.
    */
-  public static long skipByReading(InputStream in, long byteCount) throws IOException {
+  public static long skipByReading(InputStream in, long byteCount, long timeoutMillis)
+      throws IOException {
     if (byteCount == 0) return 0L;
+    long startNanos = timeoutMillis != 0 ? System.nanoTime() : 0;
 
     // acquire the shared skip buffer.
     byte[] buffer = skipBuffer.getAndSet(null);
@@ -292,12 +296,11 @@ public static long skipByReading(InputStream in, long byteCount) throws IOExcept
     while (skipped < byteCount) {
       int toRead = (int) Math.min(byteCount - skipped, buffer.length);
       int read = in.read(buffer, 0, toRead);
-      if (read == -1) {
-        break;
-      }
+      if (read == -1) break;
       skipped += read;
-      if (read < toRead) {
-        break;
+      if (timeoutMillis != 0
+          && NANOSECONDS.toMillis(System.nanoTime() - startNanos) > timeoutMillis) {
+        throw new SocketTimeoutException("Timed out after reading " + skipped + " of " + byteCount);
       }
     }
 
@@ -307,6 +310,10 @@ public static long skipByReading(InputStream in, long byteCount) throws IOExcept
     return skipped;
   }
 
+  public static long skipByReading(InputStream in, long byteCount) throws IOException {
+    return skipByReading(in, byteCount, 0);
+  }
+
   /**
    * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
    * Returns the total number of bytes transferred.
@@ -383,11 +390,11 @@ private static String bytesToHexString(byte[] bytes) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
-  public static ThreadFactory daemonThreadFactory(final String name) {
+  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
         Thread result = new Thread(runnable, name);
-        result.setDaemon(true);
+        result.setDaemon(daemon);
         return result;
       }
     };
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 80065e4866..63a504624f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,6 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.Util;
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -115,6 +116,8 @@ private HpackDraft05() {
   // TODO: huffman encoding!
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
   static class Reader {
+    private final Huffman.Codec huffmanCodec;
+
     private final DataInputStream in;
     private final List<ByteString> emittedHeaders = new ArrayList<ByteString>();
     private long bytesLeft = 0;
@@ -140,7 +143,8 @@ private HpackDraft05() {
     int headerTableByteCount = 0;
     int maxHeaderTableByteCount = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
 
-    Reader(DataInputStream in) {
+    Reader(boolean client, DataInputStream in) {
+      this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.in = in;
     }
 
@@ -371,7 +375,10 @@ public ByteString readString() throws IOException {
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
         length &= ~0x80;
-        // TODO: actually decode huffman!
+        byte[] buff = new byte[length];
+        Util.readFully(in, buff);
+        bytesLeft -= length;
+        return ByteString.of(huffmanCodec.decode(buff));
       }
       bytesLeft -= length;
       return ByteString.read(in, length);
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 1cfb93fd59..b124338681 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -83,7 +83,7 @@
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
       this.client = client;
-      this.hpackReader = new HpackDraft05.Reader(this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, this.in);
     }
 
     @Override public void readConnectionHeader() throws IOException {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
new file mode 100644
index 0000000000..a7768d0ae3
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class was originally composed from the following classes in
+ * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * <ul>
+ * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ * </ul>
+ */
+class Huffman {
+  enum Codec {
+    REQUEST(REQUEST_CODES, REQUEST_CODE_LENGTHS),
+    RESPONSE(RESPONSE_CODES, RESPONSE_CODE_LENGTHS);
+
+    private final Node root = new Node();
+    private final int[] codes;
+    private final byte[] lengths;
+
+    /**
+     * @param codes Index designates the symbol this code represents.
+     * @param lengths Index designates the symbol this code represents.
+     */
+    Codec(int[] codes, byte[] lengths) {
+      buildTree(codes, lengths);
+      this.codes = codes;
+      this.lengths = lengths;
+    }
+
+    void encode(byte[] data, OutputStream out) throws IOException {
+      long current = 0;
+      int n = 0;
+
+      for (int i = 0; i < data.length; i++) {
+        int b = data[i] & 0xFF;
+        int code = codes[b];
+        int nbits = lengths[b];
+
+        current <<= nbits;
+        current |= code;
+        n += nbits;
+
+        while (n >= 8) {
+          n -= 8;
+          out.write(((int) (current >> n)));
+        }
+      }
+
+      if (n > 0) {
+        current <<= (8 - n);
+        current |= (0xFF >>> n);
+        out.write((int) current);
+      }
+    }
+
+    int encodedLength(byte[] bytes) {
+      long len = 0;
+
+      for (int i = 0; i < bytes.length; i++) {
+        int b = bytes[i] & 0xFF;
+        len += lengths[b];
+      }
+
+      return (int) ((len + 7) >> 3);
+    }
+
+    byte[] decode(byte[] buf) throws IOException {
+      // FIXME
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      Node node = root;
+      int current = 0;
+      int nbits = 0;
+      for (int i = 0; i < buf.length; i++) {
+        int b = buf[i] & 0xFF;
+        current = (current << 8) | b;
+        nbits += 8;
+        while (nbits >= 8) {
+          int c = (current >>> (nbits - 8)) & 0xFF;
+          node = node.children[c];
+          if (node.children == null) {
+            // terminal node
+            baos.write(node.symbol);
+            nbits -= node.terminalBits;
+            node = root;
+          } else {
+            // non-terminal node
+            nbits -= 8;
+          }
+        }
+      }
+
+      while (nbits > 0) {
+        int c = (current << (8 - nbits)) & 0xFF;
+        node = node.children[c];
+        if (node.children != null || node.terminalBits > nbits) {
+          break;
+        }
+        baos.write(node.symbol);
+        nbits -= node.terminalBits;
+        node = root;
+      }
+
+      return baos.toByteArray();
+    }
+
+    private void buildTree(int[] codes, byte[] lengths) {
+      for (int i = 0; i < lengths.length; i++) {
+        addCode(i, codes[i], lengths[i]);
+      }
+    }
+
+    private void addCode(int sym, int code, byte len) {
+      Node terminal = new Node(sym, len);
+
+      Node current = root;
+      while (len > 8) {
+        len -= 8;
+        int i = ((code >>> len) & 0xFF);
+        if (current.children == null) {
+          throw new IllegalStateException("invalid dictionary: prefix not unique");
+        }
+        if (current.children[i] == null) {
+          current.children[i] = new Node();
+        }
+        current = current.children[i];
+      }
+
+      int shift = 8 - len;
+      int start = (code << shift) & 0xFF;
+      int end = 1 << shift;
+      for (int i = start; i < start + end; i++) {
+        current.children[i] = terminal;
+      }
+    }
+  }
+
+  private static final class Node {
+
+    // Null if terminal.
+    private final Node[] children;
+
+    // Terminal nodes have a symbol.
+    private final int symbol;
+
+    // Number of bits represented in the terminal node.
+    private final int terminalBits;
+
+    /** Construct an internal node. */
+    Node() {
+      this.children = new Node[256];
+      this.symbol = 0; // Not read.
+      this.terminalBits = 0; // Not read.
+    }
+
+    /**
+     * Construct a terminal node.
+     *
+     * @param symbol symbol the node represents
+     * @param bits length of Huffman code in bits
+     */
+    Node(int symbol, int bits) {
+      this.children = null;
+      this.symbol = symbol;
+      int b = bits & 0x07;
+      this.terminalBits = b == 0 ? 8 : b;
+    }
+  }
+
+  // Appendix C: Huffman Codes For Requests
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-C
+  private static final int[] REQUEST_CODES = {
+      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
+      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
+      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
+      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
+      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
+      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
+      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
+      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
+      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
+      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
+      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
+      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
+      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
+      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
+      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
+      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
+      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
+      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
+      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
+      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
+      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
+      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
+      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
+      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
+      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
+      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
+      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
+  };
+
+  private static final byte[] REQUEST_CODE_LENGTHS = {
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
+      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
+      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
+      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26
+  };
+
+  // Appendix D: Huffman Codes For Responses
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-D
+  private static final int[] RESPONSE_CODES = {
+      0x1ffffbc, 0x1ffffbd, 0x1ffffbe, 0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3,
+      0x1ffffc4, 0x1ffffc5, 0x1ffffc6, 0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb,
+      0x1ffffcc, 0x1ffffcd, 0x1ffffce, 0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3,
+      0x1ffffd4, 0x1ffffd5, 0x1ffffd6, 0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb, 0x0,
+      0xffa, 0x6a, 0x1ffa, 0x3ffc, 0x1ec, 0x3f8, 0x1ffb, 0x1ed, 0x1ee, 0xffb, 0x7fa, 0x22, 0x23,
+      0x24, 0x6b, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0x25, 0x26, 0xb, 0xc, 0xd, 0x1ef, 0xfffa, 0x6c,
+      0x1ffc, 0xffc, 0xfffb, 0x6d, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x27, 0x1f0, 0xef, 0xf0, 0x3f9,
+      0x1f1, 0x28, 0xf1, 0xf2, 0x1f2, 0x3fa, 0x1f3, 0x29, 0xe, 0x1f4, 0x1f5, 0xf3, 0x3fb, 0x1f6,
+      0x3fc, 0x7fb, 0x1ffd, 0x7fc, 0x7ffc, 0x1f7, 0x1fffe, 0xf, 0x6e, 0x2a, 0x2b, 0x10, 0x6f, 0x70,
+      0x71, 0x2c, 0x1f8, 0x1f9, 0x72, 0x2d, 0x2e, 0x2f, 0x30, 0x1fa, 0x31, 0x32, 0x33, 0x34, 0x73,
+      0xf4, 0x74, 0xf5, 0x1fb, 0xfffc, 0x3ffd, 0xfffd, 0xfffe, 0x1ffffdc, 0x1ffffdd, 0x1ffffde,
+      0x1ffffdf, 0x1ffffe0, 0x1ffffe1, 0x1ffffe2, 0x1ffffe3, 0x1ffffe4, 0x1ffffe5, 0x1ffffe6,
+      0x1ffffe7, 0x1ffffe8, 0x1ffffe9, 0x1ffffea, 0x1ffffeb, 0x1ffffec, 0x1ffffed, 0x1ffffee,
+      0x1ffffef, 0x1fffff0, 0x1fffff1, 0x1fffff2, 0x1fffff3, 0x1fffff4, 0x1fffff5, 0x1fffff6,
+      0x1fffff7, 0x1fffff8, 0x1fffff9, 0x1fffffa, 0x1fffffb, 0x1fffffc, 0x1fffffd, 0x1fffffe,
+      0x1ffffff, 0xffff80, 0xffff81, 0xffff82, 0xffff83, 0xffff84, 0xffff85, 0xffff86, 0xffff87,
+      0xffff88, 0xffff89, 0xffff8a, 0xffff8b, 0xffff8c, 0xffff8d, 0xffff8e, 0xffff8f, 0xffff90,
+      0xffff91, 0xffff92, 0xffff93, 0xffff94, 0xffff95, 0xffff96, 0xffff97, 0xffff98, 0xffff99,
+      0xffff9a, 0xffff9b, 0xffff9c, 0xffff9d, 0xffff9e, 0xffff9f, 0xffffa0, 0xffffa1, 0xffffa2,
+      0xffffa3, 0xffffa4, 0xffffa5, 0xffffa6, 0xffffa7, 0xffffa8, 0xffffa9, 0xffffaa, 0xffffab,
+      0xffffac, 0xffffad, 0xffffae, 0xffffaf, 0xffffb0, 0xffffb1, 0xffffb2, 0xffffb3, 0xffffb4,
+      0xffffb5, 0xffffb6, 0xffffb7, 0xffffb8, 0xffffb9, 0xffffba, 0xffffbb, 0xffffbc, 0xffffbd,
+      0xffffbe, 0xffffbf, 0xffffc0, 0xffffc1, 0xffffc2, 0xffffc3, 0xffffc4, 0xffffc5, 0xffffc6,
+      0xffffc7, 0xffffc8, 0xffffc9, 0xffffca, 0xffffcb, 0xffffcc, 0xffffcd, 0xffffce, 0xffffcf,
+      0xffffd0, 0xffffd1, 0xffffd2, 0xffffd3, 0xffffd4, 0xffffd5, 0xffffd6, 0xffffd7, 0xffffd8,
+      0xffffd9, 0xffffda, 0xffffdb, 0xffffdc
+  };
+
+  private static final byte[] RESPONSE_CODE_LENGTHS = {
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 4, 12, 7, 13, 14, 9, 10, 13, 9, 9, 12, 11, 6, 6, 6, 7, 4,
+      4, 4, 5, 5, 5, 6, 6, 5, 5, 5, 9, 16, 7, 13, 12, 16, 7, 8, 8, 8, 8, 8, 6, 9, 8, 8, 10, 9, 6, 8,
+      8, 9, 10, 9, 6, 5, 9, 9, 8, 10, 9, 10, 11, 13, 11, 15, 9, 17, 5, 7, 6, 6, 5, 7, 7, 7, 6, 9, 9,
+      7, 6, 6, 6, 6, 9, 6, 6, 6, 6, 7, 8, 7, 8, 9, 16, 14, 16, 16, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24
+  };
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 8b09f09b68..aefa0819fa 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -58,7 +58,7 @@
 
   private static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp SpdyConnection"));
+      Util.threadFactory("OkHttp SpdyConnection", true));
 
   /** The protocol variant, like SPDY/3 or HTTP-draft-09/2.0. */
   final Variant variant;
@@ -101,7 +101,7 @@ private SpdyConnection(Builder builder) {
 
     hostName = builder.hostName;
 
-    new Thread(new Reader(), "Spdy Reader " + hostName).start();
+    new Thread(new Reader()).start(); // Not a daemon thread.
   }
 
   /**
@@ -201,7 +201,7 @@ public void writeData(int streamId, boolean outFinished, byte[] buffer, int offs
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
@@ -216,7 +216,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           writeWindowUpdate(streamId, deltaWindowSize);
@@ -252,7 +252,7 @@ public Ping ping() throws IOException {
 
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s ping %08x%08x",
+    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostName, payload1, payload2) {
       @Override public void execute() {
         try {
@@ -438,8 +438,12 @@ public SpdyConnection build() {
     }
   }
 
-  private class Reader implements Runnable, FrameReader.Handler {
-    @Override public void run() {
+  private class Reader extends NamedRunnable implements FrameReader.Handler {
+    private Reader() {
+      super("OkHttp %s", hostName);
+    }
+
+    @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
@@ -500,7 +504,7 @@ public SpdyConnection build() {
               inFinished, priority, nameValueBlock, settings);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp Callback %s stream %d", hostName, streamId) {
+          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
                 handler.receive(newStream);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 7397042500..2ddb84315f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -39,7 +39,7 @@
   private HpackDraft05.Reader hpackReader;
 
   @Before public void resetReader() {
-    hpackReader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+    hpackReader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
   }
 
   /**
@@ -171,12 +171,10 @@
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
-    // this will change when we decode huffman
-    assertEquals(48, hpackReader.headerTableByteCount);
+    assertEquals(52, hpackReader.headerTableByteCount);
 
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
-    // TODO: huffman bytes are not what we want!
-    checkEntry(entry, ":path", new String(huffmanBytes, "UTF-8"), 48);
+    checkEntry(entry, ":path", "www.example.com", 52);
     assertHeaderReferenced(headerTableLength() - 1);
   }
 
@@ -472,17 +470,237 @@ private void checkThirdRequestWithoutHuffman() {
         "custom-key", "custom-value"), hpackReader.getAndReset());
   }
 
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
+   */
+  @Test public void decodeRequestExamplesWithHuffman() throws IOException {
+    ByteArrayOutputStream out = firstRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkFirstRequestWithHuffman();
+
+    out = secondRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkSecondRequestWithHuffman();
+
+    out = thirdRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkThirdRequestWithHuffman();
+  }
+
+  private ByteArrayOutputStream firstRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    out.write(0x87); // == Indexed - Add ==
+                     // idx = 7 -> :scheme: http
+    out.write(0x86); // == Indexed - Add ==
+                     // idx = 6 -> :path: /
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :authority
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkFirstRequestWithHuffman() {
+    assertEquals(4, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  2] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  3] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  4] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 180
+    assertEquals(180, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream secondRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x1b); // == Literal indexed ==
+                     // Indexed name (idx = 27) -> cache-control
+    out.write(0x86); // Literal value Huffman encoded 6 bytes
+                     // decodes to no-cache which is length 8
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
+        (byte) 0x98, (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkSecondRequestWithHuffman() {
+    assertEquals(5, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  3] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  4] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  5] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 233
+    assertEquals(233, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream thirdRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x80); // == Empty reference set ==
+    out.write(0x85); // == Indexed - Add ==
+                     // idx = 5 -> :method: GET
+    out.write(0x8c); // == Indexed - Add ==
+                     // idx = 12 -> :scheme: https
+    out.write(0x8b); // == Indexed - Add ==
+                     // idx = 11 -> :path: /index.html
+    out.write(0x84); // == Indexed - Add ==
+                     // idx = 4 -> :authority: www.example.com
+    out.write(0x00); // Literal indexed
+    out.write(0x88); // Literal name Huffman encoded 8 bytes
+                     // decodes to custom-key which is length 10
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+    out.write(0x89); // Literal value Huffman encoded 6 bytes
+                     // decodes to custom-value which is length 12
+    huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
+        (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkThirdRequestWithHuffman() {
+    assertEquals(8, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
+
+    // [  2] (s =  48) :path: /index.html
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
+
+    // [  3] (s =  44) :scheme: https
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
+
+    // [  4] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
+
+    // [  5] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  6] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
+
+    // [  7] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
+
+    // [  8] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 379
+    assertEquals(379, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":authority", "www.example.com",
+        ":scheme", "https",
+        ":path", "/index.html",
+        "custom-key", "custom-value"), hpackReader.getAndReset());
+  }
+
   private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
   private final HpackDraft05.Writer hpackWriter =
       new HpackDraft05.Writer(new DataOutputStream(bytesOut));
 
   @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(10, 31));
-    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(0xe0 | 10, 31));
+    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(10, 31));
+    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(0xe0 | 10, 31));
   }
 
   @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new HpackDraft05.Reader(byteStream(154, 10)).readInt(31, 31));
+    assertEquals(1337, new HpackDraft05.Reader(false, byteStream(154, 10)).readInt(31, 31));
   }
 
   @Test public void writeSingleByteInt() throws IOException {
@@ -503,44 +721,44 @@ private void checkThirdRequestWithoutHuffman() {
     hpackWriter.writeInt(0x7fffffff, 31, 0);
     assertBytes(31, 224, 255, 255, 255, 7);
     assertEquals(0x7fffffff,
-        new HpackDraft05.Reader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+        new HpackDraft05.Reader(false, byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
   }
 
   @Test public void prefixMask() throws IOException {
     hpackWriter.writeInt(31, 31, 0);
     assertBytes(31, 0);
-    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
   }
 
   @Test public void prefixMaskMinusOne() throws IOException {
     hpackWriter.writeInt(30, 31, 0);
     assertBytes(30);
-    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
   }
 
   @Test public void zero() throws IOException {
     hpackWriter.writeInt(0, 31, 0);
     assertBytes(0);
-    assertEquals(0, new HpackDraft05.Reader(byteStream()).readInt(0, 31));
+    assertEquals(0, new HpackDraft05.Reader(false, byteStream()).readInt(0, 31));
   }
 
   @Test public void headerName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
     assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new HpackDraft05.Reader(byteStream(3, 'f', 'o', 'o')).readString().utf8());
+    assertEquals("foo", new HpackDraft05.Reader(false, byteStream(3, 'f', 'o', 'o')).readString().utf8());
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals("", new HpackDraft05.Reader(byteStream(0)).readString().utf8());
+    assertEquals("", new HpackDraft05.Reader(false, byteStream(0)).readString().utf8());
   }
 
   @Test public void headersRoundTrip() throws IOException {
     List<ByteString> sentHeaders = byteStringList("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+    HpackDraft05.Reader reader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
     reader.readHeaders(bytesOut.size());
     reader.emitReferenceSet();
     List<ByteString> receivedHeaders = reader.getAndReset();
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
new file mode 100644
index 0000000000..6206b7efbd
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
+ */
+public class HuffmanTest {
+
+  @Test public void roundTripForRequestAndResponse() throws IOException {
+    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+    for (int i = 0; i < s.length(); i++) {
+      assertRoundTrip(s.substring(0, i).getBytes());
+    }
+
+    Random random = new Random(123456789L);
+    byte[] buf = new byte[4096];
+    random.nextBytes(buf);
+    assertRoundTrip(buf);
+  }
+
+  private void assertRoundTrip(byte[] buf) throws IOException {
+    assertRoundTrip(Huffman.Codec.REQUEST, buf);
+    assertRoundTrip(Huffman.Codec.RESPONSE, buf);
+  }
+
+  private static void assertRoundTrip(Huffman.Codec codec, byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    DataOutputStream dos = new DataOutputStream(baos);
+
+    codec.encode(buf, dos);
+    assertEquals(baos.size(), codec.encodedLength(buf));
+
+    byte[] decodedBytes = codec.decode(baos.toByteArray());
+    assertTrue(Arrays.equals(buf, decodedBytes));
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 5828fe65c9..c90a593f0a 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -33,8 +33,6 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 
-import static java.util.concurrent.Executors.defaultThreadFactory;
-
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
@@ -44,7 +42,8 @@
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
-  private final Executor executor = Executors.newCachedThreadPool(defaultThreadFactory());
+  private final Executor executor = Executors.newCachedThreadPool(
+      Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 9bad03d309..17f4cdac20 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
new file mode 100644
index 0000000000..dc944e4f60
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -0,0 +1,176 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.http.HeaderParser;
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These
+ * directives set policy on what responses can be stored, and which requests can
+ * be satisfied by those stored responses.
+ *
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
+ * 2616, 14.9</a>.
+ */
+public final class CacheControl {
+  private final boolean noCache;
+  private final boolean noStore;
+  private final int maxAgeSeconds;
+  private final int sMaxAgeSeconds;
+  private final boolean isPublic;
+  private final boolean mustRevalidate;
+  private final int maxStaleSeconds;
+  private final int minFreshSeconds;
+  private final boolean onlyIfCached;
+
+  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+      boolean isPublic, boolean mustRevalidate, int maxStaleSeconds, int minFreshSeconds,
+      boolean onlyIfCached) {
+    this.noCache = noCache;
+    this.noStore = noStore;
+    this.maxAgeSeconds = maxAgeSeconds;
+    this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPublic = isPublic;
+    this.mustRevalidate = mustRevalidate;
+    this.maxStaleSeconds = maxStaleSeconds;
+    this.minFreshSeconds = minFreshSeconds;
+    this.onlyIfCached = onlyIfCached;
+  }
+
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't
+   * prevent us from caching the response; it only means we have to validate the
+   * response with the origin server before returning it. We can do this with a
+   * conditional GET.
+   *
+   * <p>In a request, it means do not use a cache to satisfy the request.
+   */
+  public boolean noCache() {
+    return noCache;
+  }
+
+  /** If true, this response should not be cached. */
+  public boolean noStore() {
+    return noStore;
+  }
+
+  /**
+   * The duration past the response's served date that it can be served without
+   * validation.
+   */
+  public int maxAgeSeconds() {
+    return maxAgeSeconds;
+  }
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be
+   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+   * this directive is not honored by this cache.
+   */
+  public int sMaxAgeSeconds() {
+    return sMaxAgeSeconds;
+  }
+
+  public boolean isPublic() {
+    return isPublic;
+  }
+
+  public boolean mustRevalidate() {
+    return mustRevalidate;
+  }
+
+  public int maxStaleSeconds() {
+    return maxStaleSeconds;
+  }
+
+  public int minFreshSeconds() {
+    return minFreshSeconds;
+  }
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do
+   * not use the network". It is set by a client who only wants to make a
+   * request if it can be fully satisfied by the cache. Cached responses that
+   * would require validation (ie. conditional gets) are not permitted if this
+   * header is set.
+   */
+  public boolean onlyIfCached() {
+    return onlyIfCached;
+  }
+
+  /**
+   * Returns the cache directives of {@code headers}. This honors both
+   * Cache-Control and Pragma headers if they are present.
+   */
+  public static CacheControl parse(Headers headers) {
+    boolean noCache = false;
+    boolean noStore = false;
+    int maxAgeSeconds = -1;
+    int sMaxAgeSeconds = -1;
+    boolean isPublic = false;
+    boolean mustRevalidate = false;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached = false;
+
+    for (int i = 0; i < headers.size(); i++) {
+      if (!headers.name(i).equalsIgnoreCase("Cache-Control")
+          && !headers.name(i).equalsIgnoreCase("Pragma")) {
+        continue;
+      }
+
+      String string = headers.value(i);
+      int pos = 0;
+      while (pos < string.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(string, pos, "=,;");
+        String directive = string.substring(tokenStart, pos).trim();
+        String parameter;
+
+        if (pos == string.length() || string.charAt(pos) == ',' || string.charAt(pos) == ';') {
+          pos++; // consume ',' or ';' (if necessary)
+          parameter = null;
+        } else {
+          pos++; // consume '='
+          pos = HeaderParser.skipWhitespace(string, pos);
+
+          // quoted string
+          if (pos < string.length() && string.charAt(pos) == '\"') {
+            pos++; // consume '"' open quote
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, "\"");
+            parameter = string.substring(parameterStart, pos);
+            pos++; // consume '"' close quote (if necessary)
+
+            // unquoted string
+          } else {
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, ",;");
+            parameter = string.substring(parameterStart, pos).trim();
+          }
+        }
+
+        if ("no-cache".equalsIgnoreCase(directive)) {
+          noCache = true;
+        } else if ("no-store".equalsIgnoreCase(directive)) {
+          noStore = true;
+        } else if ("max-age".equalsIgnoreCase(directive)) {
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("s-maxage".equalsIgnoreCase(directive)) {
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("public".equalsIgnoreCase(directive)) {
+          isPublic = true;
+        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+          mustRevalidate = true;
+        } else if ("max-stale".equalsIgnoreCase(directive)) {
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("min-fresh".equalsIgnoreCase(directive)) {
+          minFreshSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+          onlyIfCached = true;
+        }
+      }
+    }
+
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index b9341328d2..5eb4874aa4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -82,7 +82,7 @@
   /** We use a single background thread to cleanup expired connections. */
   private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
       60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp ConnectionPool"));
+      Util.threadFactory("OkHttp ConnectionPool", true));
   private final Callable<Void> connectionsCleanupCallable = new Callable<Void>() {
     @Override public Void call() throws Exception {
       List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 9868b165bd..198fd4ea80 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -53,9 +53,8 @@ public Dispatcher() {
 
   public synchronized Executor getExecutor() {
     if (executor == null) {
-      // TODO: name these threads, either here or in the job.
       executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>());
+          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
     return executor;
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
index b5c69c6e01..51ee2eae34 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
@@ -17,9 +17,6 @@
 
 /**
  * A failure attempting to retrieve an HTTP response.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Failure {
   private final Request request;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index a9286adfb7..1a860dfdda 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
@@ -34,7 +35,7 @@
 import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
-final class Job implements Runnable {
+final class Job extends NamedRunnable {
   private final Dispatcher dispatcher;
   private final OkHttpClient client;
   private final Response.Receiver responseReceiver;
@@ -48,6 +49,7 @@
 
   public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
+    super("OkHttp %s", request.urlString());
     this.dispatcher = dispatcher;
     this.client = client;
     this.request = request;
@@ -66,11 +68,9 @@ Object tag() {
     return request.tag();
   }
 
-  @Override public void run() {
-    String oldName = Thread.currentThread().getName();
-    Thread.currentThread().setName("OkHttp " + request.urlString());
+  @Override protected void execute() {
     try {
-      Response response = execute();
+      Response response = getResponse();
       if (response != null && !canceled) {
         responseReceiver.onResponse(response);
       }
@@ -81,7 +81,6 @@ Object tag() {
           .build());
     } finally {
       engine.release(true); // Release the connection if it isn't already released.
-      Thread.currentThread().setName(oldName);
       dispatcher.finished(this);
     }
   }
@@ -90,42 +89,55 @@ Object tag() {
    * Performs the request and returns the response. May return null if this job
    * was canceled.
    */
-  private Response execute() throws IOException {
-    Connection connection = null;
+  private Response getResponse() throws IOException {
     Response redirectedBy = null;
 
+    // Copy body metadata to the appropriate request headers.
+    Request.Body body = request.body();
+    if (body != null) {
+      MediaType contentType = body.contentType();
+      if (contentType == null) throw new IllegalStateException("contentType == null");
+
+      Request.Builder requestBuilder = request.newBuilder();
+      requestBuilder.header("Content-Type", contentType.toString());
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, null, null, null);
+
     while (true) {
       if (canceled) return null;
 
-      Request.Body body = request.body();
-      if (body != null) {
-        MediaType contentType = body.contentType();
-        if (contentType == null) throw new IllegalStateException("contentType == null");
-
-        Request.Builder requestBuilder = request.newBuilder();
-        requestBuilder.header("Content-Type", contentType.toString());
-
-        long contentLength = body.contentLength();
-        if (contentLength != -1) {
-          requestBuilder.header("Content-Length", Long.toString(contentLength));
-          requestBuilder.removeHeader("Transfer-Encoding");
-        } else {
-          requestBuilder.header("Transfer-Encoding", "chunked");
-          requestBuilder.removeHeader("Content-Length");
-        }
+      try {
+        engine.sendRequest();
 
-        request = requestBuilder.build();
-      }
+        if (body != null) {
+          body.writeTo(engine.getRequestBody());
+        }
 
-      engine = new HttpEngine(client, request, false, connection, null);
-      engine.sendRequest();
+        engine.readResponse();
+      } catch (IOException e) {
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
 
-      if (body != null) {
-        body.writeTo(engine.getRequestBody());
+        // Give up; recovery is not possible.
+        throw e;
       }
 
-      engine.readResponse();
-
       Response response = engine.getResponse();
       Request redirect = processResponse(engine, response);
 
@@ -142,9 +154,10 @@ private Response execute() throws IOException {
       }
 
       engine.release(false);
-      connection = engine.getConnection();
+      Connection connection = engine.getConnection();
       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = redirect;
+      engine = new HttpEngine(client, request, false, connection, null, null);
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index c388c18c09..ef934328d3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -342,10 +342,14 @@ public OkHttpClient setTransports(List<String> transports) {
   }
 
   /**
-   * Schedules {@code request} to be executed.
+   * Schedules {@code request} to be executed at some point in the future. The
+   * {@link #getDispatcher dispatcher} defines when the request will run:
+   * usually immediately unless there are several other requests currently being
+   * executed.
    *
-   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
-   * This method is in beta. APIs are subject to change!
+   * <p>This client will later call back {@code responseReceiver} with either an
+   * HTTP response or a failure exception. If you {@link #cancel} a request
+   * before it completes the receiver will not be called back.
    */
   public void enqueue(Request request, Response.Receiver responseReceiver) {
     dispatcher.enqueue(this, request, responseReceiver);
@@ -353,10 +357,7 @@ public void enqueue(Request request, Response.Receiver responseReceiver) {
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
-   * in flight might not be canceled.
-   *
-   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
-   * This method is in beta. APIs are subject to change!
+   * complete cannot be canceled.
    */
   public void cancel(Object tag) {
     dispatcher.cancel(tag);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
index 1ddeb9a53e..05460f5ada 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
@@ -21,9 +21,6 @@
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
  * interface supports conditional caching and statistics.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
   Response get(Request request) throws IOException;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 5866af0f21..af90db1527 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -17,7 +17,6 @@
 
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HeaderParser;
 import com.squareup.okhttp.internal.http.HttpDate;
 import java.io.File;
 import java.io.FileInputStream;
@@ -35,9 +34,6 @@
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Request {
   private final URL url;
@@ -48,6 +44,7 @@
 
   private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
   private volatile URI uri; // Lazily initialized.
+  private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
     this.url = builder.url;
@@ -106,26 +103,6 @@ public Headers getHeaders() {
     return headers;
   }
 
-  public boolean getNoCache() {
-    return parsedHeaders().noCache;
-  }
-
-  public int getMaxAgeSeconds() {
-    return parsedHeaders().maxAgeSeconds;
-  }
-
-  public int getMaxStaleSeconds() {
-    return parsedHeaders().maxStaleSeconds;
-  }
-
-  public int getMinFreshSeconds() {
-    return parsedHeaders().minFreshSeconds;
-  }
-
-  public boolean getOnlyIfCached() {
-    return parsedHeaders().onlyIfCached;
-  }
-
   public String getUserAgent() {
     return parsedHeaders().userAgent;
   }
@@ -139,57 +116,29 @@ private ParsedHeaders parsedHeaders() {
     return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
   }
 
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
   public boolean isHttps() {
     return url().getProtocol().equals("https");
   }
 
   /** Parsed request headers, computed on-demand and cached. */
   private static class ParsedHeaders {
-    /** Don't use a cache to satisfy this request. */
-    private boolean noCache;
-    private int maxAgeSeconds = -1;
-    private int maxStaleSeconds = -1;
-    private int minFreshSeconds = -1;
-
-    /**
-     * This field's name "only-if-cached" is misleading. It actually means "do
-     * not use the network". It is set by a client who only wants to make a
-     * request if it can be fully satisfied by the cache. Cached responses that
-     * would require validation (ie. conditional gets) are not permitted if this
-     * header is set.
-     */
-    private boolean onlyIfCached;
-
     private String userAgent;
     private String proxyAuthorization;
 
     public ParsedHeaders(Headers headers) {
-      HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-        @Override public void handle(String directive, String parameter) {
-          if ("no-cache".equalsIgnoreCase(directive)) {
-            noCache = true;
-          } else if ("max-age".equalsIgnoreCase(directive)) {
-            maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-          } else if ("max-stale".equalsIgnoreCase(directive)) {
-            maxStaleSeconds = HeaderParser.parseSeconds(parameter);
-          } else if ("min-fresh".equalsIgnoreCase(directive)) {
-            minFreshSeconds = HeaderParser.parseSeconds(parameter);
-          } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-            onlyIfCached = true;
-          }
-        }
-      };
-
       for (int i = 0; i < headers.size(); i++) {
         String fieldName = headers.name(i);
         String value = headers.value(i);
-        if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-          HeaderParser.parseCacheControl(value, handler);
-        } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-          if ("no-cache".equalsIgnoreCase(value)) {
-            noCache = true;
-          }
-        } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
+        if ("User-Agent".equalsIgnoreCase(fieldName)) {
           userAgent = value;
         } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
           proxyAuthorization = value;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 8026a78f66..0110f3e19c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -41,9 +41,6 @@
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
  * are immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Response {
   private final Request request;
@@ -54,6 +51,7 @@
   private final Response redirectedBy;
 
   private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+  private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Response(Builder builder) {
     this.request = builder.request;
@@ -151,30 +149,6 @@ public Date getExpires() {
     return parsedHeaders().expires;
   }
 
-  public boolean isNoCache() {
-    return parsedHeaders().noCache;
-  }
-
-  public boolean isNoStore() {
-    return parsedHeaders().noStore;
-  }
-
-  public int getMaxAgeSeconds() {
-    return parsedHeaders().maxAgeSeconds;
-  }
-
-  public int getSMaxAgeSeconds() {
-    return parsedHeaders().sMaxAgeSeconds;
-  }
-
-  public boolean isPublic() {
-    return parsedHeaders().isPublic;
-  }
-
-  public boolean isMustRevalidate() {
-    return parsedHeaders().mustRevalidate;
-  }
-
   public String getEtag() {
     return parsedHeaders().etag;
   }
@@ -322,6 +296,15 @@ private ParsedHeaders parsedHeaders() {
     return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
   }
 
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
   /** Parsed response headers, computed on-demand and cached. */
   private static class ParsedHeaders {
     /** The server's time when this response was served, if known. */
@@ -348,73 +331,17 @@ private ParsedHeaders parsedHeaders() {
      */
     long receivedResponseMillis;
 
-    /**
-     * In the response, this field's name "no-cache" is misleading. It doesn't
-     * prevent us from caching the response; it only means we have to validate
-     * the response with the origin server before returning it. We can do this
-     * with a conditional get.
-     */
-    boolean noCache;
-
-    /** If true, this response should not be cached. */
-    boolean noStore;
-
-    /**
-     * The duration past the response's served date that it can be served
-     * without validation.
-     */
-    int maxAgeSeconds = -1;
-
-    /**
-     * The "s-maxage" directive is the max age for shared caches. Not to be
-     * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-     * this directive is not honored by this cache.
-     */
-    int sMaxAgeSeconds = -1;
-
-    /**
-     * This request header field's name "only-if-cached" is misleading. It
-     * actually means "do not use the network". It is set by a client who only
-     * wants to make a request if it can be fully satisfied by the cache.
-     * Cached responses that would require validation (ie. conditional gets) are
-     * not permitted if this header is set.
-     */
-    boolean isPublic;
-    boolean mustRevalidate;
     String etag;
     int ageSeconds = -1;
 
     /** Case-insensitive set of field names. */
     private Set<String> varyFields = Collections.emptySet();
 
-    private long contentLength = -1;
-    private String contentType;
-
     private ParsedHeaders(Headers headers) {
-      HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-        @Override public void handle(String directive, String parameter) {
-          if ("no-cache".equalsIgnoreCase(directive)) {
-            noCache = true;
-          } else if ("no-store".equalsIgnoreCase(directive)) {
-            noStore = true;
-          } else if ("max-age".equalsIgnoreCase(directive)) {
-            maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-          } else if ("s-maxage".equalsIgnoreCase(directive)) {
-            sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
-          } else if ("public".equalsIgnoreCase(directive)) {
-            isPublic = true;
-          } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-            mustRevalidate = true;
-          }
-        }
-      };
-
       for (int i = 0; i < headers.size(); i++) {
         String fieldName = headers.name(i);
         String value = headers.value(i);
-        if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-          HeaderParser.parseCacheControl(value, handler);
-        } else if ("Date".equalsIgnoreCase(fieldName)) {
+        if ("Date".equalsIgnoreCase(fieldName)) {
           servedDate = HttpDate.parse(value);
         } else if ("Expires".equalsIgnoreCase(fieldName)) {
           expires = HttpDate.parse(value);
@@ -422,10 +349,6 @@ private ParsedHeaders(Headers headers) {
           lastModified = HttpDate.parse(value);
         } else if ("ETag".equalsIgnoreCase(fieldName)) {
           etag = value;
-        } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-          if ("no-cache".equalsIgnoreCase(value)) {
-            noCache = true;
-          }
         } else if ("Age".equalsIgnoreCase(fieldName)) {
           ageSeconds = HeaderParser.parseSeconds(value);
         } else if ("Vary".equalsIgnoreCase(fieldName)) {
@@ -436,13 +359,6 @@ private ParsedHeaders(Headers headers) {
           for (String varyField : value.split(",")) {
             varyFields.add(varyField.trim());
           }
-        } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-          try {
-            contentLength = Long.parseLong(value);
-          } catch (NumberFormatException ignored) {
-          }
-        } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
-          contentType = value;
         } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
           sentRequestMillis = Long.parseLong(value);
         } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 69f3c31563..19e4cee61f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -158,8 +158,8 @@
   private long nextSequenceNumber = 0;
 
   /** This cache uses a single background thread to evict entries. */
-  final ThreadPoolExecutor executorService =
-      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
   private final Callable<Void> cleanupCallable = new Callable<Void>() {
     public Void call() throws Exception {
       synchronized (DiskLruCache.this) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 459f3ad7a8..b8c1d5155b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.CacheControl;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
@@ -7,9 +8,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
-import java.util.concurrent.TimeUnit;
 
 import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
  * Given a request and cached response, this figures out whether to use the
@@ -64,7 +65,7 @@ private static long computeAge(Response response, long nowMillis) {
         ? Math.max(0, response.getReceivedResponseMillis() - response.getServedDate().getTime())
         : 0;
     long receivedAge = response.getAgeSeconds() != -1
-        ? Math.max(apparentReceivedAge, TimeUnit.SECONDS.toMillis(response.getAgeSeconds()))
+        ? Math.max(apparentReceivedAge, SECONDS.toMillis(response.getAgeSeconds()))
         : apparentReceivedAge;
     long responseDuration = response.getReceivedResponseMillis() - response.getSentRequestMillis();
     long residentDuration = nowMillis - response.getReceivedResponseMillis();
@@ -76,8 +77,9 @@ private static long computeAge(Response response, long nowMillis) {
    * starting from the served date.
    */
   private static long computeFreshnessLifetime(Response response) {
-    if (response.getMaxAgeSeconds() != -1) {
-      return TimeUnit.SECONDS.toMillis(response.getMaxAgeSeconds());
+    CacheControl responseCaching = response.cacheControl();
+    if (responseCaching.maxAgeSeconds() != -1) {
+      return SECONDS.toMillis(responseCaching.maxAgeSeconds());
     } else if (response.getExpires() != null) {
       long servedMillis = response.getServedDate() != null
           ? response.getServedDate().getTime()
@@ -104,7 +106,8 @@ private static long computeFreshnessLifetime(Response response) {
    * to attach a warning.
    */
   private static boolean isFreshnessLifetimeHeuristic(Response response) {
-    return response.getMaxAgeSeconds() == -1 && response.getExpires() == null;
+    return response.cacheControl().maxAgeSeconds() == -1
+        && response.getExpires() == null;
   }
 
   /**
@@ -125,14 +128,15 @@ public static boolean isCacheable(Response response, Request request) {
 
     // Responses to authorized requests aren't cacheable unless they include
     // a 'public', 'must-revalidate' or 's-maxage' directive.
+    CacheControl responseCaching = response.cacheControl();
     if (request.header("Authorization") != null
-        && !response.isPublic()
-        && !response.isMustRevalidate()
-        && response.getSMaxAgeSeconds() == -1) {
+        && !responseCaching.isPublic()
+        && !responseCaching.mustRevalidate()
+        && responseCaching.sMaxAgeSeconds() == -1) {
       return false;
     }
 
-    if (response.isNoStore()) {
+    if (responseCaching.noStore()) {
       return false;
     }
 
@@ -146,7 +150,7 @@ public static boolean isCacheable(Response response, Request request) {
   public static CacheStrategy get(long nowMillis, Response response, Request request) {
     CacheStrategy candidate = getCandidate(nowMillis, response, request);
 
-    if (candidate.source != ResponseSource.CACHE && request.getOnlyIfCached()) {
+    if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
       // We're forbidden from using the network, but the cache is insufficient.
       Response noneResponse = new Response.Builder()
           .request(candidate.request)
@@ -179,28 +183,30 @@ private static CacheStrategy getCandidate(long nowMillis, Response response, Req
       return new CacheStrategy(request, response, ResponseSource.NETWORK);
     }
 
-    if (request.getNoCache() || hasConditions(request)) {
+    CacheControl requestCaching = request.cacheControl();
+    if (requestCaching.noCache() || hasConditions(request)) {
       return new CacheStrategy(request, response, ResponseSource.NETWORK);
     }
 
     long ageMillis = computeAge(response, nowMillis);
     long freshMillis = computeFreshnessLifetime(response);
 
-    if (request.getMaxAgeSeconds() != -1) {
-      freshMillis = Math.min(freshMillis, TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));
+    if (requestCaching.maxAgeSeconds() != -1) {
+      freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
     }
 
     long minFreshMillis = 0;
-    if (request.getMinFreshSeconds() != -1) {
-      minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());
+    if (requestCaching.minFreshSeconds() != -1) {
+      minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
     }
 
     long maxStaleMillis = 0;
-    if (!response.isMustRevalidate() && request.getMaxStaleSeconds() != -1) {
-      maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());
+    CacheControl responseCaching = response.cacheControl();
+    if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+      maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
     }
 
-    if (!response.isNoCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+    if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
       Response.Builder builder = response.newBuilder()
           .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
       if (ageMillis + minFreshMillis >= freshMillis) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index c8a7119ae9..e9af13026c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -17,49 +17,6 @@
 package com.squareup.okhttp.internal.http;
 
 public final class HeaderParser {
-
-  public interface CacheControlHandler {
-    void handle(String directive, String parameter);
-  }
-
-  /** Parse a comma-separated list of cache control header values. */
-  public static void parseCacheControl(String value, CacheControlHandler handler) {
-    int pos = 0;
-    while (pos < value.length()) {
-      int tokenStart = pos;
-      pos = skipUntil(value, pos, "=,;");
-      String directive = value.substring(tokenStart, pos).trim();
-
-      if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
-        pos++; // consume ',' or ';' (if necessary)
-        handler.handle(directive, null);
-        continue;
-      }
-
-      pos++; // consume '='
-      pos = skipWhitespace(value, pos);
-
-      String parameter;
-
-      // quoted string
-      if (pos < value.length() && value.charAt(pos) == '\"') {
-        pos++; // consume '"' open quote
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, "\"");
-        parameter = value.substring(parameterStart, pos);
-        pos++; // consume '"' close quote (if necessary)
-
-        // unquoted string
-      } else {
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, ",;");
-        parameter = value.substring(parameterStart, pos).trim();
-      }
-
-      handler.handle(directive, parameter);
-    }
-  }
-
   /**
    * Returns the next index in {@code input} at or after {@code pos} that
    * contains a character from {@code characters}. Returns the input length if
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 96a401984a..4545e6e79b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -33,12 +33,15 @@
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.CookieHandler;
+import java.net.ProtocolException;
 import java.net.URL;
 import java.net.UnknownHostException;
+import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
@@ -74,8 +77,8 @@
 public class HttpEngine {
   final OkHttpClient client;
 
-  Connection connection;
-  RouteSelector routeSelector;
+  private Connection connection;
+  private RouteSelector routeSelector;
   private Route route;
 
   private Transport transport;
@@ -134,13 +137,17 @@
    *     immediately prior to this request/response pair, such as a same-host
    *     redirect. This engine assumes ownership of the connection and must
    *     release it when it is unneeded.
+   * @param routeSelector the route selector used for a failed attempt
+   *     immediately preceding this attempt, or null if this request doesn't
+   *     recover from a failure.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RetryableOutputStream requestBodyOut) throws IOException {
+      Connection connection, RouteSelector routeSelector, RetryableOutputStream requestBodyOut) {
     this.client = client;
     this.request = request;
     this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
+    this.routeSelector = routeSelector;
     this.route = connection != null ? connection.getRoute() : null;
     this.requestBodyOut = requestBodyOut;
   }
@@ -239,7 +246,7 @@ private void connect() throws IOException {
       client.getConnectionPool().maybeShare(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
     } else if (!connection.isSpdy()) {
-        connection.updateReadTimeout(client.getReadTimeout());
+      connection.updateReadTimeout(client.getReadTimeout());
     }
 
     route = connection.getRoute();
@@ -298,6 +305,41 @@ public final Connection getConnection() {
     return connection;
   }
 
+  /**
+   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
+   * that should be used for the retry if {@code e} is recoverable, or null if
+   * the failure is permanent.
+   */
+  public HttpEngine recover(IOException e) {
+    if (routeSelector != null && connection != null) {
+      routeSelector.connectFailed(connection, e);
+    }
+
+    boolean canRetryRequestBody = requestBodyOut == null
+        || requestBodyOut instanceof RetryableOutputStream;
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)
+        || !canRetryRequestBody) {
+      return null;
+    }
+
+    release(true);
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, request, bufferRequestBody, null, routeSelector,
+        (RetryableOutputStream) requestBodyOut);
+  }
+
+  private boolean isRecoverable(IOException e) {
+    // If the problem was a CertificateException from the X509TrustManager,
+    // do not retry, we didn't have an abrupt server initiated exception.
+    boolean sslFailure =
+        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
+    boolean protocolFailure = e instanceof ProtocolException;
+    return !sslFailure && !protocolFailure;
+  }
+
   /**
    * Returns the route used to retrieve the response. Null if we haven't
    * connected yet, or if no connection was necessary.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index 4a166dcc38..d2fe8910cb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -123,8 +123,8 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
   public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(request,
-        httpEngine.connection.getRoute().getProxy().type(),
-        httpEngine.connection.getHttpMinorVersion());
+        httpEngine.getConnection().getRoute().getProxy().type(),
+        httpEngine.getConnection().getHttpMinorVersion());
     writeRequest(requestOut, request.getHeaders(), requestLine);
   }
 
@@ -208,7 +208,7 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
    * reuse.
    */
   private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.connection;
+    Connection connection = httpEngine.getConnection();
     if (connection == null) return false;
     Socket socket = connection.getSocket();
     if (socket == null) return false;
@@ -216,7 +216,7 @@ private static boolean discardStream(HttpEngine httpEngine, InputStream response
       int socketTimeout = socket.getSoTimeout();
       socket.setSoTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
       try {
-        Util.skipAll(responseBodyIn);
+        Util.skipByReading(responseBodyIn, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
         return true;
       } finally {
         socket.setSoTimeout(socketTimeout);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index c54de7a00a..246d2710f8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -37,14 +37,12 @@
 import java.net.SocketPermission;
 import java.net.URL;
 import java.security.Permission;
-import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLHandshakeException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
@@ -277,7 +275,7 @@ private void initHttpEngine() throws IOException {
   }
 
   private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableOutputStream requestBody) throws IOException {
+      RetryableOutputStream requestBody) {
     Request.Builder builder = new Request.Builder()
         .url(getURL())
         .method(method, null /* No body; that's passed separately. */);
@@ -305,7 +303,7 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setOkResponseCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, requestBody);
+    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody);
   }
 
   /**
@@ -377,50 +375,16 @@ private boolean execute(boolean readResponse) throws IOException {
 
       return true;
     } catch (IOException e) {
-      if (handleFailure(e)) {
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
         return false;
-      } else {
-        throw e;
       }
-    }
-  }
 
-  /**
-   * Report and attempt to recover from {@code e}. Returns true if the HTTP
-   * engine was replaced and the request should be retried. Otherwise the
-   * failure is permanent.
-   */
-  private boolean handleFailure(IOException e) throws IOException {
-    RouteSelector routeSelector = httpEngine.routeSelector;
-    if (routeSelector != null && httpEngine.connection != null) {
-      routeSelector.connectFailed(httpEngine.connection, e);
-    }
-
-    OutputStream requestBody = httpEngine.getRequestBody();
-    boolean canRetryRequestBody = requestBody == null
-        || requestBody instanceof RetryableOutputStream;
-    if (routeSelector == null && httpEngine.connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
+      // Give up; recovery is not possible.
       httpEngineFailure = e;
-      return false;
+      throw e;
     }
-
-    httpEngine.release(true);
-    RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
-    httpEngine = newHttpEngine(method, null, retryableOutputStream);
-    httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
-    return true;
-  }
-
-  private boolean isRecoverable(IOException e) {
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
-    boolean sslFailure =
-        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
-    boolean protocolFailure = e instanceof ProtocolException;
-    return !sslFailure && !protocolFailure;
   }
 
   enum Retry {
@@ -435,8 +399,9 @@ private boolean isRecoverable(IOException e) {
    * prepare for a follow up request.
    */
   private Retry processResponseHeaders() throws IOException {
-    Proxy selectedProxy = httpEngine.connection != null
-        ? httpEngine.connection.getRoute().getProxy()
+    Connection connection = httpEngine.getConnection();
+    Proxy selectedProxy = connection != null
+        ? connection.getRoute().getProxy()
         : client.getProxy();
     final int responseCode = getResponseCode();
     switch (responseCode) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 0eea6770b9..07bb90e795 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -64,7 +64,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     httpEngine.writingRequestHeaders();
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.connection.getHttpMinorVersion());
+    String version = RequestLine.version(httpEngine.getConnection().getHttpMinorVersion());
     stream = spdyConnection.newStream(
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index bf4ee23410..a3dcf5c332 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -114,6 +115,23 @@
     receiver.await(request.url()).assertHandshake();
   }
 
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(request.url()).assertBody("abc");
+  }
+
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
@@ -318,4 +336,36 @@
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
   }
+
+  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("Moved to /b !"));
+    server.enqueue(new MockResponse()
+        .setBody("This is b."));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/b"))
+        .assertCode(200)
+        .assertBody("This is b.");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("body!", request1.getUtf8Body());
+    assertEquals("5", request1.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("body!", request2.getUtf8Body());
+    assertEquals("5", request2.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
+    assertEquals(1, request2.getSequenceNumber());
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index 483f3cd963..36d54668ed 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -38,6 +38,7 @@ public static void main(String[] args) throws Exception {
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
+    System.out.println(connection.getHeaderFields());
 
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 91dfcd1f28..40a35e7e31 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -564,7 +564,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
   private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
     // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().setBytesPerSecond(6);
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 125c34cd03..b1abccd97e 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -80,6 +80,8 @@
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -1130,6 +1132,33 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
   }
 
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new byte[10000])
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    long startNanos = System.nanoTime();
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in = connection1.getInputStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
   @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
     server.play();
diff --git a/pom.xml b/pom.xml
index 0391107ec0..bc32950e10 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>1.2.2-SNAPSHOT</version>
+  <version>2.0.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index dc0633c751..61e58756a1 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/pom.xml b/samples/pom.xml
index 2462fd09d7..b212e99d99 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 990152b227..93657e2f2f 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index f98e5b5b78..70188c725c 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
