diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..d86e1ed8 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -138,8 +138,10 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        // 查找订阅者类中相应的订阅方法
         Class<?> subscriberClass = subscriber.getClass();
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+        // 订阅
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
@@ -151,6 +153,7 @@ public void register(Object subscriber) {
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        // 获取eventType对应的订阅列表
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,6 +165,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 根据订阅优先级，加入订阅列表中
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -170,6 +174,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 注册订阅者订阅的事件类型
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -177,12 +182,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        // 如果是订阅sticky的事件，立即向相应订阅投递事件
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
                 // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                // 如果事件是允许继承的，需要向父事件订阅者投递事件
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
@@ -192,6 +199,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                     }
                 }
             } else {
+                // 如果事件是不允许继承的，只需要向本事件订阅者投递事件
                 Object stickyEvent = stickyEvents.get(eventType);
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
@@ -222,11 +230,13 @@ public synchronized boolean isRegistered(Object subscriber) {
 
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+        // 找出对事件eventType的所有订阅
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
+                // 找出属于subscriber订阅者的订阅，并取消订阅
                 if (subscription.subscriber == subscriber) {
                     subscription.active = false;
                     subscriptions.remove(i);
@@ -239,11 +249,14 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
 
     /** Unregisters the given subscriber from all event classes. */
     public synchronized void unregister(Object subscriber) {
+        // 找出订阅者subscriber所订阅的所有事件
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
+            // 取消subscriber对所有事件的订阅
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
+            // 移除该订阅者subscriber
             typesBySubscriber.remove(subscriber);
         } else {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
@@ -252,11 +265,13 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        // 获取本线程中的postingState对象，将事件放入事件队列中
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
         if (!postingState.isPosting) {
+            // 目前不处于发布中，进入事件发布流程
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
             if (postingState.canceled) {
@@ -264,6 +279,7 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    // 事件队列不为空的话，就一直发布事件
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -379,6 +395,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            // 如果事件是允许继承的，那么需要向父类、接口的订阅者投递事件
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -386,6 +403,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            // 如果事件是不允许继承的，那么只需要向本事件的订阅者投递事件
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
@@ -401,6 +419,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
 
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
+        // 查找出事件对应的所有订阅
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
@@ -410,6 +429,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 向订阅发布事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..31ae47a4 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,25 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 从缓存中查找订阅者中的订阅方法
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
+        // 缓存中不存在再从订阅者中找出订阅方法
         if (ignoreGeneratedIndex) {
+            // 使用反射的方式在运行时查找订阅方法
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 从编译时生成的订阅方法信息中查找订阅方法
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            // 将查找结果放入缓存中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -75,16 +80,20 @@
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
+        // 向上检查整个类层级树
         while (findState.clazz != null) {
+            // 获取订阅者信息
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
+                    // 检查订阅方法
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                         findState.subscriberMethods.add(subscriberMethod);
                     }
                 }
             } else {
+                // 如果无法找到订阅者信息，使用反射方式寻找订阅方法
                 findUsingReflectionInSingleClass(findState);
             }
             findState.moveToSuperclass();
@@ -126,6 +135,7 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
                 return superclassInfo;
             }
         }
+        // 从生成的SubscriberInfoIndex类中寻找
         if (subscriberInfoIndexes != null) {
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
@@ -141,9 +151,11 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 向上检查整个类层级树
             findUsingReflectionInSingleClass(findState);
             findState.moveToSuperclass();
         }
+        // 返回查找结果，并释放FindState
         return getMethodsAndRelease(findState);
     }
 
@@ -151,21 +163,29 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            // 获取该类自身声明的方法
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+            // 获取该类所有public的方法，包括继承的方法
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                // 忽略非public的方法，忽略abstract、static和桥接方法
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                // 参数个数为1
                 if (parameterTypes.length == 1) {
+                    // 获取Subscribe注解
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        // 获取订阅方法关注的事件类型
                         Class<?> eventType = parameterTypes[0];
+                        // 检查是否应该添加到查找结果中
                         if (findState.checkAdd(method, eventType)) {
+                            // 添加到查找结果列表中
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
@@ -216,19 +236,26 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        // 检查是否应该将方法添加入查找结果列表中
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            // 双层检查：第一层检查是否有订阅相同事件类型的重复对象
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
+                // 没有重复对象
                 return true;
             } else {
+                // 有重复对象
                 if (existing instanceof Method) {
+                    // 已有的订阅者是方法，通过方法签名检查已有的方法
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
+                        // 已经添加的查询结果经过方法签名检查发现不应添加入查询结果，报异常
                         throw new IllegalStateException();
                     }
                     // Put any non-Method object to "consume" the existing Method
+                    // 下次就不用重新检查已有的方法，直接检查即将添加的方法
                     anyMethodByEventType.put(eventType, this);
                 }
                 return checkAddWithMethodSignature(method, eventType);
@@ -245,9 +272,11 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                 // Only add if not already found in a sub class
+                // 如果在子类中未找到相同签名的方法，则需要添加到查找结果中
                 return true;
             } else {
                 // Revert the put, old class is further down the class hierarchy
+                // 如果在子类中找到相同签名的方法，则无需要添加到查找结果中
                 subscriberClassByMethodKey.put(methodKey, methodClassOld);
                 return false;
             }
