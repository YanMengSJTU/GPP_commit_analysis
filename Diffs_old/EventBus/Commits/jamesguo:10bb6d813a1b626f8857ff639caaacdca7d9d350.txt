diff --git a/.gitignore b/.gitignore
index 4a8da3bc..36573eee 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,14 @@
-.gradle
\ No newline at end of file
+.settings/
+
+*.iml
+.idea
+
+gen/
+bin/
+release/
+build/
+
+.gradle/
+gradle.properties
+
+local.properties
diff --git a/.travis.yml b/.travis.yml
index 84748701..e086ce10 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,3 +1,24 @@
-language: java
+language: android
 jdk:
-  - openjdk6
\ No newline at end of file
+  - openjdk6
+  - oraclejdk7
+
+# http://docs.travis-ci.com/user/languages/android/
+android:
+  components:
+    - build-tools-21.1.2
+    - android-10
+
+before_script:
+  - chmod +x gradlew
+#  - echo no | android create avd --force -n test -t android-10 --abi armeabi
+#  - emulator -avd test -no-skin -no-audio -no-window &
+#  - android-wait-for-emulator
+#  - adb shell input keyevent 82 &
+
+# Currently connectedCheck fails, so don't run unit test on Emulator for now. Issue:
+# com.android.builder.testing.ConnectedDevice > hasTests[test(AVD) - 2.3.3] FAILED
+# No tests found.
+
+script:
+    - TERM=dumb ./gradlew check
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..1db6f10c
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,69 @@
+### V2.x.x (2015-0x-xx) Future release
+* Registering for sticky events now considers sticky events of subclasses, not just the exact same event type. This makes the semantic consistent to posting events. Note, that this may lead to subscribers being called more than once if matching sticky events of event type subclasses are available.
+
+### V2.4.0 (2014-11-11) Clean up release
+* Removed deprecated APIs: A year ago in Version 2.2.0, a couple of EventBus methods were deprecated and flagged to be removed in a future release. Well, version 2.4.0 is that release. Clean ups like this one keep the API concise and simple.
+
+**Note:** No new feature were added since 2.3.0. Use this release if you do not rely on deprecated APIs.
+
+### V2.3.0 (2014-11-11) Feature release: EventBusBuilder and performance fix
+* New EventBusBuilder to configure EventBus instances (including the getDefault() instance, #124)
+* Added configuration to disable "No subscribers registered for event" logs (EventBusBuilder, #107, #117)
+* Added configuration to disable sending SubscriberExceptionEvent and NoSubscriberEvent (EventBusBuilder)
+* Added configuration to fail when subscribers throw exceptions (EventBusBuilder, #55)
+* Added configuration to use an existing thread pool (EventBusBuilder, #115)
+* Added configuration to disable event inheritance improving performance for apps with high event rates (EventBusBuilder)
+* Fixed performance regression sneaked into V2.2.x affecting (first time) registration of subscribers
+* Updated to Gradle 2.1, using wrapper
+* EventBusTest and EventBusPerformance use Gradle to build
+* Added hasSubscriberForEvent to check if currently subscribers exist registered to a given event type
+* Improved README.md and extracted an extended HOWTO.md and CHANGELOG.md from it
+* Ignore compiler generated methods (#76)
+* Various small code improvements (#120 among many others)
+
+**Note:** This is your last chance to use APIs that were deprecated in V2.2.0. It's recommended to switch to Version 2.4.0 (or above) at your earliest convenience.
+
+### V2.2.1 (2014-05-21) Bug fix release
+* Fixed an issue with AsyncExecutor and execution scope
+
+### V2.2.0 (2013-11-18) Feature release, subscriber priority
+* Register subscribers with a priority to to influence the order of event delivery (per delivery thread)
+* Event delivery can be canceled by subscribers so subsequent subscribers will not receive the event
+* Added "isRegistered" and "removeAllStickyEvents" methods
+* Deprecated registration methods with custom method names and event class filters
+* Starting with EventBus 2.2 we enforced methods to be public
+* Fixed a race conditions with subscriber registration
+* Fixed NoSubscriberEvent delivery after unregister
+
+### V2.1.0 (2013-11-15) Bug fix release, experimental util package
+* Experimental: AsyncExecutor executes RunnableEx and wraps exceptions into FailureEvents
+* Experimental: exception to UI mapping (for now based on dialogs)
+* Fixed race condition with queued events that were delivered after subscription was unregistered. This is important for main thread events tied to application life cycle.
+* Fixed typos and improved readme (#17, #22, #37, #39)
+* Make getStickyEvent and removeStickyEvent generic (#45)
+* Fixed bug in SubscriberMethod.equals() (#38)
+
+### V2.0.2 (2013-03-02) Bug fix release
+* Fixed build dependencies, are "provided" now
+
+### V2.0.1 (2013-02-25) Bug fix release, Gradle and Maven Central
+* Fixed #15: removeStickyEvent(...) does not remove event the first time
+* Introduced Gradle build scripts for main project
+* Maven artifacts are pushed to Maven Central starting with this version
+* Added Travis CI
+
+### V2.0.0 (2012-10-23) Major feature release
+* Event methods define for themselves in which thread they get called. This is done by providing "modifiers" to the method name, e.g. onEventMainThread is called by the main thread without further configuration. Have a look at the JavaDoc of the enum ThreadMode for all available thread modes.
+* The event method modifiers replace registerForMainThread methods. Moving this information to the method itself should make things clearer.
+* Using event method modifiers, subscribers can receive the same event type in different threads if they choose to.
+* New "BackgroundThread" modifier for onEvent handler methods ensures that event handler methods are called in a background thread. If an event is posted from a non-main thread, handler methods will be called directly. If posted from the main thread, EventBus will use a background thread to call the handler methods.
+* New "Async" modifier for onEvent handler methods ensures that each event handler method is called completely asynchronously.
+* Better performance: Delivery of multiple events in the main thread got significantly faster.
+* Added sticky events, which are inspired by sticky broadcasts of the Android system. EventBus keeps the most recent sticky events in memory. Subscribers registering with the new method registerSticky, will receive sticky events right away. You can also query and remove sticky events (methods getStickyEvent and removeStickyEvent).
+* By listening to SubscriberExceptionEvent, it is possible to react to Exceptions occuring in subscribers.
+* Bug fixes, and internal refactorings
+
+### V1.0.1 (2012-07-31): Important bug fix release
+Please update! Now, EventBus.unregister releases all internal references to the subscriber.
+
+### V1.0.0 (2012-07-16): First public release
diff --git a/COMPARISON.md b/COMPARISON.md
new file mode 100644
index 00000000..1ba60ccd
--- /dev/null
+++ b/COMPARISON.md
@@ -0,0 +1,98 @@
+EventBus Comparison
+===================
+
+Comparison with Square's Otto
+-----------------------------
+Otto is another event bus library for Android; actually it's a fork of Guava's EventBus. greenrobot's EventBus and Otto share some basic semantics (register, post, unregister, ...), but there are differences which the following table summarizes:
+<table>
+    <tr>
+        <th></th>
+        <th>EventBus</th>
+        <th>Otto</th>
+    </tr>
+    <tr>
+        <th>Declare event handling methods</th>
+        <td>Name conventions</td>
+        <td>Annotations</td>
+    </tr>	
+    <tr>
+        <th>Event inheritance</th>
+        <td>Yes</td>
+        <td>Yes</td>
+    </tr>	
+    <tr>
+        <th>Subscriber inheritance</th>
+        <td>Yes</td>
+        <td>No</td>
+    </tr>
+    <tr>
+        <th>Cache most recent events</th>
+        <td>Yes, sticky events</td>
+        <td>No</td>
+    </tr>
+    <tr>
+        <th>Event producers (e.g. for coding cached events)</th>
+        <td>No</td>
+        <td>Yes</td>
+    </tr>
+    <tr>
+        <th>Event delivery in posting thread</th>
+        <td>Yes (Default)</td>
+        <td>Yes</td>
+    </tr>	
+    <tr>
+        <th>Event delivery in main thread</th>
+        <td>Yes</td>
+        <td>No</td>
+    </tr>	
+    <tr>
+        <th>Event delivery in background thread</th>
+        <td>Yes</td>
+        <td>No</td>
+    </tr>	
+    <tr>
+        <th>Aynchronous event delivery</th>
+        <td>Yes</td>
+        <td>No</td>
+    </tr>
+</table>
+
+Besides features, performance is another differentiator. To compare performance, we created an Android application, which is also part of this repository (EventBusPerformance). You can also run the app on your phone to benchmark different scenarios.
+
+Benchmark results indicate that EventBus is significantly faster in almost every scenario:
+<table>
+    <tr>
+        <th></th>
+        <th>EventBus</th>
+        <th>Otto</th>
+    </tr>
+    <tr>
+        <th>Posting 1000 events, Android 2.3 emulator</th>
+        <td>~70% faster</td>
+        <td></td>
+    </tr>
+	<tr>
+        <th>Posting 1000 events, S3 Android 4.0</th>
+        <td>~110% faster</td>
+        <td></td>
+    </tr>
+    <tr>
+        <th>Register 1000 subscribers, Android 2.3 emulator</th>
+        <td>~10% faster</td>
+        <td></td>
+    </tr>
+    <tr>
+        <th>Register 1000 subscribers, S3 Android 4.0</th>
+        <td>~70% faster</td>
+        <td></td>
+    </tr>
+    <tr>
+        <th>Register subscribers cold start, Android 2.3 emulator</th>
+        <td>~350% faster</td>
+        <td></td>
+    </tr>	
+    <tr>
+        <th>Register subscribers cold start, S3 Android 4.0</th>
+        <td colspan="2">About the same</td>
+    </tr>	
+</table>
diff --git a/EventBus-Publish-Subscribe.png b/EventBus-Publish-Subscribe.png
new file mode 100644
index 00000000..82d3ecef
Binary files /dev/null and b/EventBus-Publish-Subscribe.png differ
diff --git a/EventBus/.classpath b/EventBus/.classpath
index a4f1e405..7bc01d9a 100644
--- a/EventBus/.classpath
+++ b/EventBus/.classpath
@@ -1,8 +1,9 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/EventBus/.gitignore b/EventBus/.gitignore
deleted file mode 100644
index c0a7b4b5..00000000
--- a/EventBus/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-/gen
-/bin
-/release
-/build
-/.gradle
-/gradle.properties
diff --git a/EventBus/build.gradle b/EventBus/build.gradle
index 63b16dc3..b377bf64 100644
--- a/EventBus/build.gradle
+++ b/EventBus/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '2.0.2'
+version = '2.4.1-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -18,10 +18,11 @@ repositories {
     mavenCentral()
 }
 
-// provided is not supported in Gradle 1.4, see http://issues.gradle.org/browse/GRADLE-784
+// Still unsupported, see http://issues.gradle.org/browse/GRADLE-784
 // Like this, it won't appear at all in the POM
 configurations {
     provided
+    deployerJars
 }
 
 dependencies {
@@ -29,6 +30,8 @@ dependencies {
     provided 'com.google.android:android-test:4.1.1.4'
     provided 'com.google.android:annotations:4.1.1.4'
     provided 'com.google.android:support-v4:r7'
+    // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
+    deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
 
 sourceSets {
@@ -36,7 +39,7 @@ sourceSets {
         compileClasspath += configurations.provided
         java {
             srcDir 'src'
-            exclude 'de/greenrobot/event/util/**'
+            // exclude 'de/greenrobot/event/util/**'
         }
     }
 }
@@ -44,7 +47,7 @@ sourceSets {
 javadoc {
     classpath += configurations.provided
     title = "EventBus ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2013 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2014 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
@@ -75,8 +78,13 @@ signing {
 uploadArchives {
     repositories {
         mavenDeployer {
-            // We must check if authentication info is available
-            if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+            if(project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername') 
+                && project.hasProperty('preferedPassword')) {
+                configuration = configurations.deployerJars
+                repository(url: preferedRepo) {
+                    authentication(userName: preferedUsername, password: preferedPassword)
+                }
+            } else if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
                 repository(url: sonatypeRepositoryUrl) {
                     authentication(userName: sonatypeUsername, password: sonatypePassword)
@@ -85,11 +93,12 @@ uploadArchives {
                 println "Settings sonatypeUsername/sonatypePassword missing/incomplete for ${project.name}"
             }
 
+            pom.artifactId = 'eventbus'
             pom.project {
                name 'EventBus'
                packaging 'jar'
-               description 'EventBus is an Android optimized publish/subscribe event bus.'
-               url 'https://plus.google.com/b/114381455741141514652/communities/114594359857596138845/stream/2f784373-19d9-4a0d-840f-787794a410bc'
+               description 'EventBus is a publish/subscribe event bus optimized for Android .'
+               url 'https://github.com/greenrobot/EventBus'
 
                scm {
                    url 'https://github.com/greenrobot/EventBus'
@@ -116,7 +125,7 @@ uploadArchives {
                    system 'GitHub Issues'
                    url 'https://github.com/greenrobot/EventBus/issues'
                }
-               
+
                organization {
                    name 'greenrobot'
                    url 'http://greenrobot.de'
diff --git a/EventBus/src/de/greenrobot/event/AsyncPoster.java b/EventBus/src/de/greenrobot/event/AsyncPoster.java
index 4d7f54c0..936527b7 100644
--- a/EventBus/src/de/greenrobot/event/AsyncPoster.java
+++ b/EventBus/src/de/greenrobot/event/AsyncPoster.java
@@ -1,50 +1,49 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-
-/**
- * Posts events in background.
- * 
- * @author Markus
- */
-class AsyncPoster implements Runnable {
-
-    private final PendingPostQueue queue;
-
-    private final EventBus eventBus;
-
-    AsyncPoster(EventBus eventBus) {
-        this.eventBus = eventBus;
-        queue = new PendingPostQueue();
-    }
-
-    public void enqueue(Subscription subscription, Object event) {
-        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
-        queue.enqueue(pendingPost);
-        EventBus.executorService.execute(this);
-    }
-
-    @Override
-    public void run() {
-        PendingPost pendingPost = queue.poll();
-        if(pendingPost == null) {
-            throw new IllegalStateException("No pending post available");
-        }
-        eventBus.invokeSubscriber(pendingPost);
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+
+/**
+ * Posts events in background.
+ * 
+ * @author Markus
+ */
+class AsyncPoster implements Runnable {
+
+    private final PendingPostQueue queue;
+    private final EventBus eventBus;
+
+    AsyncPoster(EventBus eventBus) {
+        this.eventBus = eventBus;
+        queue = new PendingPostQueue();
+    }
+
+    public void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        queue.enqueue(pendingPost);
+        eventBus.getExecutorService().execute(this);
+    }
+
+    @Override
+    public void run() {
+        PendingPost pendingPost = queue.poll();
+        if(pendingPost == null) {
+            throw new IllegalStateException("No pending post available");
+        }
+        eventBus.invokeSubscriber(pendingPost);
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/BackgroundPoster.java b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
index 75d4c301..00e9ee54 100644
--- a/EventBus/src/de/greenrobot/event/BackgroundPoster.java
+++ b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
@@ -1,74 +1,74 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-import android.util.Log;
-
-/**
- * Posts events in background.
- * 
- * @author Markus
- */
-final class BackgroundPoster implements Runnable {
-
-    private final PendingPostQueue queue;
-    private volatile boolean executorRunning;
-
-    private final EventBus eventBus;
-
-    BackgroundPoster(EventBus eventBus) {
-        this.eventBus = eventBus;
-        queue = new PendingPostQueue();
-    }
-
-    public void enqueue(Subscription subscription, Object event) {
-        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
-        synchronized (this) {
-            queue.enqueue(pendingPost);
-            if (!executorRunning) {
-                executorRunning = true;
-                EventBus.executorService.execute(this);
-            }
-        }
-    }
-
-    @Override
-    public void run() {
-        try {
-            try {
-                while (true) {
-                    PendingPost pendingPost = queue.poll(1000);
-                    if (pendingPost == null) {
-                        synchronized (this) {
-                            // Check again, this time in synchronized
-                            pendingPost = queue.poll();
-                            if (pendingPost == null) {
-                                executorRunning = false;
-                                return;
-                            }
-                        }
-                    }
-                    eventBus.invokeSubscriber(pendingPost);
-                }
-            } catch (InterruptedException e) {
-                Log.w("Event", Thread.currentThread().getName() + " was interruppted", e);
-            }
-        } finally {
-            executorRunning = false;
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.util.Log;
+
+/**
+ * Posts events in background.
+ * 
+ * @author Markus
+ */
+final class BackgroundPoster implements Runnable {
+
+    private final PendingPostQueue queue;
+    private final EventBus eventBus;
+
+    private volatile boolean executorRunning;
+
+    BackgroundPoster(EventBus eventBus) {
+        this.eventBus = eventBus;
+        queue = new PendingPostQueue();
+    }
+
+    public void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        synchronized (this) {
+            queue.enqueue(pendingPost);
+            if (!executorRunning) {
+                executorRunning = true;
+                eventBus.getExecutorService().execute(this);
+            }
+        }
+    }
+
+    @Override
+    public void run() {
+        try {
+            try {
+                while (true) {
+                    PendingPost pendingPost = queue.poll(1000);
+                    if (pendingPost == null) {
+                        synchronized (this) {
+                            // Check again, this time in synchronized
+                            pendingPost = queue.poll();
+                            if (pendingPost == null) {
+                                executorRunning = false;
+                                return;
+                            }
+                        }
+                    }
+                    eventBus.invokeSubscriber(pendingPost);
+                }
+            } catch (InterruptedException e) {
+                Log.w("Event", Thread.currentThread().getName() + " was interruppted", e);
+            }
+        } finally {
+            executorRunning = false;
+        }
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index f4833308..95863ade 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -15,65 +15,62 @@
  */
 package de.greenrobot.event;
 
+import android.os.Looper;
+import android.util.Log;
+
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import android.os.Looper;
-import android.util.Log;
 
 /**
- * EventBus is a central publish/subscribe event system for Android. Events are posted ({@link #post(Object)} to the
- * bus, which delivers it to subscribers that have matching handler methods for the event type. To receive events,
- * subscribers must register themselves to the bus using the {@link #register(Object)} method. Once registered,
- * subscribers receive events until the call of {@link #unregister(Object)}. By default, subscribers will handle events
- * in methods named "onEvent".
- * 
+ * EventBus is a central publish/subscribe event system for Android. Events are posted ({@link #post(Object)}) to the
+ * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,
+ * subscribers must register themselves to the bus using {@link #register(Object)}. Once registered,
+ * subscribers receive events until {@link #unregister(Object)} is called. By convention, event handling methods must
+ * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event).
+ *
  * @author Markus Junginger, greenrobot
  */
 public class EventBus {
-    static ExecutorService executorService = Executors.newCachedThreadPool();
 
     /** Log tag, apps may override it. */
     public static String TAG = "Event";
 
-    private static volatile EventBus defaultInstance;
+    static volatile EventBus defaultInstance;
 
+    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();
 
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
-    private final ThreadLocal<List<Object>> currentThreadEventQueue = new ThreadLocal<List<Object>>() {
-        @Override
-        protected List<Object> initialValue() {
-            return new ArrayList<Object>();
-        }
-    };
-
-    private final ThreadLocal<BooleanWrapper> currentThreadIsPosting = new ThreadLocal<BooleanWrapper>() {
+    private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
-        protected BooleanWrapper initialValue() {
-            return new BooleanWrapper();
+        protected PostingThreadState initialValue() {
+            return new PostingThreadState();
         }
     };
 
-    private String defaultMethodName = "onEvent";
 
     private final HandlerPoster mainThreadPoster;
     private final BackgroundPoster backgroundPoster;
     private final AsyncPoster asyncPoster;
     private final SubscriberMethodFinder subscriberMethodFinder;
+    private final ExecutorService executorService;
 
-    private boolean subscribed;
-    private boolean logSubscriberExceptions;
+    private final boolean throwSubscriberException;
+    private final boolean logSubscriberExceptions;
+    private final boolean logNoSubscriberMessages;
+    private final boolean sendSubscriberExceptionEvent;
+    private final boolean sendNoSubscriberEvent;
+    private final boolean eventInheritance;
 
     /** Convenience singleton for apps using a process-wide EventBus instance. */
     public static EventBus getDefault() {
@@ -87,55 +84,46 @@ public static EventBus getDefault() {
         return defaultInstance;
     }
 
+    public static EventBusBuilder builder() {
+        return new EventBusBuilder();
+    }
+
     /** For unit test primarily. */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
     }
 
-    /**
-     * Method name verification is done for methods starting with onEvent to avoid typos; using this method you can
-     * exclude subscriber classes from this check.
-     */
-    public static void skipMethodNameVerificationFor(Class<?> clazz) {
-        SubscriberMethodFinder.skipMethodNameVerificationFor(clazz);
-    }
-
-    /** For unit test primarily. */
-    public static void clearSkipMethodNameVerifications() {
-        SubscriberMethodFinder.clearSkipMethodNameVerifications();
-    }
-
     /**
      * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
      * central bus, consider {@link #getDefault()}.
      */
     public EventBus() {
+        this(DEFAULT_BUILDER);
+    }
+
+    EventBus(EventBusBuilder builder) {
         subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();
         typesBySubscriber = new HashMap<Object, List<Class<?>>>();
         stickyEvents = new ConcurrentHashMap<Class<?>, Object>();
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
-        subscriberMethodFinder = new SubscriberMethodFinder();
-        logSubscriberExceptions = true;
+        subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses);
+        logSubscriberExceptions = builder.logSubscriberExceptions;
+        logNoSubscriberMessages = builder.logNoSubscriberMessages;
+        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
+        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
+        throwSubscriberException = builder.throwSubscriberException;
+        eventInheritance = builder.eventInheritance;
+        executorService = builder.executorService;
     }
 
-    /**
-     * Before registering any subscribers, use this method to configure if EventBus should log exceptions thrown by
-     * subscribers (default: true).
-     */
-    public void configureLogSubscriberExceptions(boolean logSubscriberExceptions) {
-        if (subscribed) {
-            throw new EventBusException("This method must be called before any registration");
-        }
-        this.logSubscriberExceptions = logSubscriberExceptions;
-    }
 
     /**
-     * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they are
-     * no longer interested in receiving events.
-     * 
+     * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
+     * are no longer interested in receiving events.
+     * <p/>
      * Subscribers have event handling methods that are identified by their name, typically called "onEvent". Event
      * handling methods must have exactly one parameter, the event. If the event handling method is to be called in a
      * specific thread, a modifier is appended to the method name. Valid modifiers match one of the {@link ThreadMode}
@@ -143,14 +131,17 @@ public void configureLogSubscriberExceptions(boolean logSubscriberExceptions) {
      * "onEventMainThread".
      */
     public void register(Object subscriber) {
-        register(subscriber, defaultMethodName, false);
+        register(subscriber, false, 0);
     }
 
     /**
-     * Like {@link #register(Object)}, but allows to define a custom method name for event handler methods.
+     * Like {@link #register(Object)} with an additional subscriber priority to influence the order of event delivery.
+     * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before
+     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
+     * delivery among subscribers with different {@link ThreadMode}s!
      */
-    public void register(Object subscriber, String methodName) {
-        register(subscriber, methodName, false);
+    public void register(Object subscriber, int priority) {
+        register(subscriber, false, priority);
     }
 
     /**
@@ -158,92 +149,49 @@ public void register(Object subscriber, String methodName) {
      * {@link #postSticky(Object)}) to the given subscriber.
      */
     public void registerSticky(Object subscriber) {
-        register(subscriber, defaultMethodName, true);
+        register(subscriber, true, 0);
     }
 
     /**
-     * Like {@link #registerSticky(Object)}, but allows to define a custom method name for event handler methods.
-     */
-    public void registerSticky(Object subscriber, String methodName) {
-        register(subscriber, methodName, true);
-    }
-
-    private void register(Object subscriber, String methodName, boolean sticky) {
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass(),
-                methodName);
-        for (SubscriberMethod subscriberMethod : subscriberMethods) {
-            subscribe(subscriber, subscriberMethod, sticky);
-        }
-    }
-
-    /**
-     * Like {@link #register(Object)}, but only registers the subscriber for the given event types.
-     */
-    public void register(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, defaultMethodName, false, eventType, moreEventTypes);
-    }
-
-    /**
-     * Like {@link #register(Object, String)}, but only registers the subscriber for the given event types.
-     */
-    public synchronized void register(Object subscriber, String methodName, Class<?> eventType,
-            Class<?>... moreEventTypes) {
-        register(subscriber, methodName, false, eventType, moreEventTypes);
-    }
-
-    /**
-     * Like {@link #registerSticky(Object)}, but only registers the subscriber for the given event types.
-     */
-    public void registerSticky(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, defaultMethodName, true, eventType, moreEventTypes);
-    }
-
-    /**
-     * Like {@link #registerSticky(Object, String)}, but only registers the subscriber for the given event types.
+     * Like {@link #register(Object, int)}, but also triggers delivery of the most recent sticky event (posted with
+     * {@link #postSticky(Object)}) to the given subscriber.
      */
-    public synchronized void registerSticky(Object subscriber, String methodName, Class<?> eventType,
-            Class<?>... moreEventTypes) {
-        register(subscriber, methodName, true, eventType, moreEventTypes);
+    public void registerSticky(Object subscriber, int priority) {
+        register(subscriber, true, priority);
     }
 
-    private synchronized void register(Object subscriber, String methodName, boolean sticky, Class<?> eventType,
-            Class<?>... moreEventTypes) {
-        Class<?> subscriberClass = subscriber.getClass();
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass,
-                methodName);
+    private synchronized void register(Object subscriber, boolean sticky, int priority) {
+        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());
         for (SubscriberMethod subscriberMethod : subscriberMethods) {
-            if (eventType == subscriberMethod.eventType) {
-                subscribe(subscriber, subscriberMethod, sticky);
-            } else if (moreEventTypes != null) {
-                for (Class<?> eventType2 : moreEventTypes) {
-                    if (eventType2 == subscriberMethod.eventType) {
-                        subscribe(subscriber, subscriberMethod, sticky);
-                        break;
-                    }
-                }
-            }
+            subscribe(subscriber, subscriberMethod, sticky, priority);
         }
     }
 
-    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky) {
-        subscribed = true;
+    // Must be called in synchronized block
+    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {
         Class<?> eventType = subscriberMethod.eventType;
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
-        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<Subscription>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
-            for (Subscription subscription : subscriptions) {
-                if (subscription.equals(newSubscription)) {
-                    throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
-                            + eventType);
-                }
+            if (subscriptions.contains(newSubscription)) {
+                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
+                        + eventType);
             }
         }
 
-        subscriberMethod.method.setAccessible(true);
-        subscriptions.add(newSubscription);
+        // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+        // subscriberMethod.method.setAccessible(true);
+
+        int size = subscriptions.size();
+        for (int i = 0; i <= size; i++) {
+            if (i == size || newSubscription.priority > subscriptions.get(i).priority) {
+                subscriptions.add(i, newSubscription);
+                break;
+            }
+        }
 
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
@@ -253,42 +201,47 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boo
         subscribedEvents.add(eventType);
 
         if (sticky) {
-            Object stickyEvent;
-            synchronized (stickyEvents) {
-                stickyEvent = stickyEvents.get(eventType);
-            }
-            if (stickyEvent != null) {
-                postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
+            if (eventInheritance) {
+                // Existing sticky events of all subclasses of eventType have to be considered.
+                // Note: Iterating over all events may be inefficient with lots of sticky events,
+                // thus data structure should be changed to allow a more efficient lookup
+                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
+                for (Map.Entry<Class<?>, Object> entry : entries) {
+                    Class<?> candidateEventType = entry.getKey();
+                    if (eventType.isAssignableFrom(candidateEventType)) {
+                        Object stickyEvent = entry.getValue();
+                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
+                    }
+                }
+            } else {
+                Object stickyEvent = stickyEvents.get(eventType);
+                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
     }
 
-    /** Unregisters the given subscriber for the given event classes. */
-    public synchronized void unregister(Object subscriber, Class<?>... eventTypes) {
-        if (eventTypes.length == 0) {
-            throw new IllegalArgumentException("Provide at least one event class");
-        }
-        List<Class<?>> subscribedClasses = typesBySubscriber.get(subscriber);
-        if (subscribedClasses != null) {
-            for (Class<?> eventType : eventTypes) {
-                unubscribeByEventType(subscriber, eventType);
-                subscribedClasses.remove(eventType);
-            }
-            if (subscribedClasses.isEmpty()) {
-                typesBySubscriber.remove(subscriber);
-            }
-        } else {
-            Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
+    private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
+        if (stickyEvent != null) {
+            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
+            // --> Strange corner case, which we don't take care of here.
+            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
         }
     }
 
+    public synchronized boolean isRegistered(Object subscriber) {
+        return typesBySubscriber.containsKey(subscriber);
+    }
+
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
     private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
-                if (subscriptions.get(i).subscriber == subscriber) {
+                Subscription subscription = subscriptions.get(i);
+                if (subscription.subscriber == subscriber) {
+                    subscription.active = false;
                     subscriptions.remove(i);
                     i--;
                     size--;
@@ -312,25 +265,50 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
-        List<Object> eventQueue = currentThreadEventQueue.get();
+        PostingThreadState postingState = currentPostingThreadState.get();
+        List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
-        BooleanWrapper isPosting = currentThreadIsPosting.get();
-        if (isPosting.value) {
-            return;
-        } else {
-            boolean isMainThread = Looper.getMainLooper() == Looper.myLooper();
-            isPosting.value = true;
+        if (!postingState.isPosting) {
+            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
+            postingState.isPosting = true;
+            if (postingState.canceled) {
+                throw new EventBusException("Internal error. Abort state was not reset");
+            }
             try {
                 while (!eventQueue.isEmpty()) {
-                    postSingleEvent(eventQueue.remove(0), isMainThread);
+                    postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
-                isPosting.value = false;
+                postingState.isPosting = false;
+                postingState.isMainThread = false;
             }
         }
     }
 
+    /**
+     * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
+     * subscribers
+     * won't receive the event. Events are usually canceled by higher priority subscribers (see
+     * {@link #register(Object, int)}). Canceling is restricted to event handling methods running in posting thread
+     * {@link ThreadMode#PostThread}.
+     */
+    public void cancelEventDelivery(Object event) {
+        PostingThreadState postingState = currentPostingThreadState.get();
+        if (!postingState.isPosting) {
+            throw new EventBusException(
+                    "This method may only be called from inside event handling methods on the posting thread");
+        } else if (event == null) {
+            throw new EventBusException("Event may not be null");
+        } else if (postingState.event != event) {
+            throw new EventBusException("Only the currently handled event may be aborted");
+        } else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.PostThread) {
+            throw new EventBusException(" event handlers may only abort the incoming event");
+        }
+
+        postingState.canceled = true;
+    }
+
     /**
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access. This can be {@link #registerSticky(Object)} or
@@ -346,34 +324,34 @@ public void postSticky(Object event) {
 
     /**
      * Gets the most recent sticky event for the given type.
-     * 
+     *
      * @see #postSticky(Object)
      */
-    public Object getStickyEvent(Class<?> eventType) {
+    public <T> T getStickyEvent(Class<T> eventType) {
         synchronized (stickyEvents) {
-            return stickyEvents.get(eventType);
+            return eventType.cast(stickyEvents.get(eventType));
         }
     }
 
     /**
-     * Remove and gets the recent sticky event for the given type.
-     * 
+     * Remove and gets the recent sticky event for the given event type.
+     *
      * @see #postSticky(Object)
      */
-    public Object removeStickyEvent(Class<?> eventType) {
+    public <T> T removeStickyEvent(Class<T> eventType) {
         synchronized (stickyEvents) {
-            return stickyEvents.remove(eventType);
+            return eventType.cast(stickyEvents.remove(eventType));
         }
     }
 
     /**
      * Removes the sticky event if it equals to the given event.
-     * 
+     *
      * @return true if the events matched and the sticky event was removed.
      */
     public boolean removeStickyEvent(Object event) {
         synchronized (stickyEvents) {
-            Class<? extends Object> eventType = event.getClass();
+            Class<?> eventType = event.getClass();
             Object existingEvent = stickyEvents.get(eventType);
             if (event.equals(existingEvent)) {
                 stickyEvents.remove(eventType);
@@ -384,61 +362,113 @@ public boolean removeStickyEvent(Object event) {
         }
     }
 
-    private void postSingleEvent(Object event, boolean isMainThread) throws Error {
-        Class<? extends Object> eventClass = event.getClass();
-        List<Class<?>> eventTypes = findEventTypes(eventClass);
-        boolean subscriptionFound = false;
-        int countTypes = eventTypes.size();
-        for (int h = 0; h < countTypes; h++) {
-            Class<?> clazz = eventTypes.get(h);
-            CopyOnWriteArrayList<Subscription> subscriptions;
-            synchronized (this) {
-                subscriptions = subscriptionsByEventType.get(clazz);
-            }
-            if (subscriptions != null) {
-                for (Subscription subscription : subscriptions) {
-                    postToSubscription(subscription, event, isMainThread);
+    /**
+     * Removes all sticky events.
+     */
+    public void removeAllStickyEvents() {
+        synchronized (stickyEvents) {
+            stickyEvents.clear();
+        }
+    }
+
+    public boolean hasSubscriberForEvent(Class<?> eventClass) {
+        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+        if (eventTypes != null) {
+            int countTypes = eventTypes.size();
+            for (int h = 0; h < countTypes; h++) {
+                Class<?> clazz = eventTypes.get(h);
+                CopyOnWriteArrayList<Subscription> subscriptions;
+                synchronized (this) {
+                    subscriptions = subscriptionsByEventType.get(clazz);
                 }
-                subscriptionFound = true;
+                if (subscriptions != null && !subscriptions.isEmpty()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+        Class<?> eventClass = event.getClass();
+        boolean subscriptionFound = false;
+        if (eventInheritance) {
+            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+            int countTypes = eventTypes.size();
+            for (int h = 0; h < countTypes; h++) {
+                Class<?> clazz = eventTypes.get(h);
+                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
+        } else {
+            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
-            Log.d(TAG, "No subscripers registered for event " + eventClass);
-            if (eventClass != NoSubscriberEvent.class && eventClass != SubscriberExceptionEvent.class) {
+            if (logNoSubscriberMessages) {
+                Log.d(TAG, "No subscribers registered for event " + eventClass);
+            }
+            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
+                    eventClass != SubscriberExceptionEvent.class) {
                 post(new NoSubscriberEvent(this, event));
             }
         }
     }
 
+    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
+        CopyOnWriteArrayList<Subscription> subscriptions;
+        synchronized (this) {
+            subscriptions = subscriptionsByEventType.get(eventClass);
+        }
+        if (subscriptions != null && !subscriptions.isEmpty()) {
+            for (Subscription subscription : subscriptions) {
+                postingState.event = event;
+                postingState.subscription = subscription;
+                boolean aborted = false;
+                try {
+                    postToSubscription(subscription, event, postingState.isMainThread);
+                    aborted = postingState.canceled;
+                } finally {
+                    postingState.event = null;
+                    postingState.subscription = null;
+                    postingState.canceled = false;
+                }
+                if (aborted) {
+                    break;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
-        case PostThread:
-            invokeSubscriber(subscription, event);
-            break;
-        case MainThread:
-            if (isMainThread) {
-                invokeSubscriber(subscription, event);
-            } else {
-                mainThreadPoster.enqueue(subscription, event);
-            }
-            break;
-        case BackgroundThread:
-            if (isMainThread) {
-                backgroundPoster.enqueue(subscription, event);
-            } else {
+            case PostThread:
                 invokeSubscriber(subscription, event);
-            }
-            break;
-        case Async:
-            asyncPoster.enqueue(subscription, event);
-            break;
-        default:
-            throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
+                break;
+            case MainThread:
+                if (isMainThread) {
+                    invokeSubscriber(subscription, event);
+                } else {
+                    mainThreadPoster.enqueue(subscription, event);
+                }
+                break;
+            case BackgroundThread:
+                if (isMainThread) {
+                    backgroundPoster.enqueue(subscription, event);
+                } else {
+                    invokeSubscriber(subscription, event);
+                }
+                break;
+            case Async:
+                asyncPoster.enqueue(subscription, event);
+                break;
+            default:
+                throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
         }
     }
 
-    /** Finds all Class objects including super classes and interfaces. */
-    private List<Class<?>> findEventTypes(Class<?> eventClass) {
+    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    private List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
             if (eventTypes == null) {
@@ -465,42 +495,69 @@ static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         }
     }
 
+    /**
+     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
+     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
+     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
+     * live cycle of an Activity or Fragment.
+     */
     void invokeSubscriber(PendingPost pendingPost) {
         Object event = pendingPost.event;
         Subscription subscription = pendingPost.subscription;
         PendingPost.releasePendingPost(pendingPost);
-        invokeSubscriber(subscription, event);
+        if (subscription.active) {
+            invokeSubscriber(subscription, event);
+        }
     }
 
-    void invokeSubscriber(Subscription subscription, Object event) throws Error {
+    void invokeSubscriber(Subscription subscription, Object event) {
         try {
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
-            Throwable cause = e.getCause();
-            if (event instanceof SubscriberExceptionEvent) {
+            handleSubscriberException(subscription, event, e.getCause());
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException("Unexpected exception", e);
+        }
+    }
+
+    private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
+        if (event instanceof SubscriberExceptionEvent) {
+            if (logSubscriberExceptions) {
                 // Don't send another SubscriberExceptionEvent to avoid infinite event recursion, just log
                 Log.e(TAG, "SubscriberExceptionEvent subscriber " + subscription.subscriber.getClass()
                         + " threw an exception", cause);
                 SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;
                 Log.e(TAG, "Initial event " + exEvent.causingEvent + " caused exception in "
                         + exEvent.causingSubscriber, exEvent.throwable);
-            } else {
-                if (logSubscriberExceptions) {
-                    Log.e(TAG, "Could not dispatch event: " + event.getClass() + " to subscribing class "
-                            + subscription.subscriber.getClass(), cause);
-                }
+            }
+        } else {
+            if (throwSubscriberException) {
+                throw new EventBusException("Invoking subscriber failed", cause);
+            }
+            if (logSubscriberExceptions) {
+                Log.e(TAG, "Could not dispatch event: " + event.getClass() + " to subscribing class "
+                        + subscription.subscriber.getClass(), cause);
+            }
+            if (sendSubscriberExceptionEvent) {
                 SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,
                         subscription.subscriber);
                 post(exEvent);
             }
-        } catch (IllegalAccessException e) {
-            throw new IllegalStateException("Unexpected exception", e);
         }
     }
 
-    /** For ThreadLocal, much faster to set than storing a new Boolean. */
-    final static class BooleanWrapper {
-        boolean value;
+    /** For ThreadLocal, much faster to set (and get multiple values). */
+    final static class PostingThreadState {
+        final List<Object> eventQueue = new ArrayList<Object>();
+        boolean isPosting;
+        boolean isMainThread;
+        Subscription subscription;
+        Object event;
+        boolean canceled;
+    }
+
+    ExecutorService getExecutorService() {
+        return executorService;
     }
 
     // Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...
diff --git a/EventBus/src/de/greenrobot/event/EventBusBuilder.java b/EventBus/src/de/greenrobot/event/EventBusBuilder.java
new file mode 100644
index 00000000..06350609
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/EventBusBuilder.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2014 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Creates EventBus instances with custom parameters and also allows to install a custom default EventBus instance.
+ * Create a new builder using {@link EventBus#builder()}.
+ */
+public class EventBusBuilder {
+    private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
+
+    boolean logSubscriberExceptions = true;
+    boolean logNoSubscriberMessages = true;
+    boolean sendSubscriberExceptionEvent = true;
+    boolean sendNoSubscriberEvent = true;
+    boolean throwSubscriberException;
+    boolean eventInheritance = true;
+    ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
+    List<Class<?>> skipMethodVerificationForClasses;
+
+    EventBusBuilder() {
+    }
+
+    /** Default: true */
+    public EventBusBuilder logSubscriberExceptions(boolean logSubscriberExceptions) {
+        this.logSubscriberExceptions = logSubscriberExceptions;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder logNoSubscriberMessages(boolean logNoSubscriberMessages) {
+        this.logNoSubscriberMessages = logNoSubscriberMessages;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent) {
+        this.sendSubscriberExceptionEvent = sendSubscriberExceptionEvent;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder sendNoSubscriberEvent(boolean sendNoSubscriberEvent) {
+        this.sendNoSubscriberEvent = sendNoSubscriberEvent;
+        return this;
+    }
+
+    /**
+     * Fails if an subscriber throws an exception (default: false).
+     * <p/>
+     * Tip: Use this with BuildConfig.DEBUG to let the app crash in DEBUG mode (only). This way, you won't miss
+     * exceptions during development.
+     */
+    public EventBusBuilder throwSubscriberException(boolean throwSubscriberException) {
+        this.throwSubscriberException = throwSubscriberException;
+        return this;
+    }
+
+    /**
+     * By default, EventBus considers the event class hierarchy (subscribers to super classes will be notified).
+     * Switching this feature off will improve posting of events. For simple event classes extending Object directly,
+     * we measured a speed up of 20% for event posting. For more complex event hierarchies, the speed up should be
+     * >20%.
+     * <p/>
+     * However, keep in mind that event posting usually consumes just a small proportion of CPU time inside an app,
+     * unless it is posting at high rates, e.g. hundreds/thousands of events per second.
+     */
+    public EventBusBuilder eventInheritance(boolean eventInheritance) {
+        this.eventInheritance = eventInheritance;
+        return this;
+    }
+
+
+    /**
+     * Provide a custom thread pool to EventBus used for async and background event delivery. This is an advanced
+     * setting to that can break things: ensure the given ExecutorService won't get stuck to avoid undefined behavior.
+     */
+    public EventBusBuilder executorService(ExecutorService executorService) {
+        this.executorService = executorService;
+        return this;
+    }
+
+    /**
+     * Method name verification is done for methods starting with onEvent to avoid typos; using this method you can
+     * exclude subscriber classes from this check. Also disables checks for method modifiers (public, not static nor
+     * abstract).
+     */
+    public EventBusBuilder skipMethodVerificationFor(Class<?> clazz) {
+        if (skipMethodVerificationForClasses == null) {
+            skipMethodVerificationForClasses = new ArrayList<Class<?>>();
+        }
+        skipMethodVerificationForClasses.add(clazz);
+        return this;
+    }
+
+    /**
+     * Installs the default EventBus returned by {@link EventBus#getDefault()} using this builders' values. Must be
+     * done only once before the first usage of the default EventBus.
+     *
+     * @throws EventBusException if there's already a default EventBus instance in place
+     */
+    public EventBus installDefaultEventBus() {
+        synchronized (EventBus.class) {
+            if (EventBus.defaultInstance != null) {
+                throw new EventBusException("Default instance already exists." +
+                        " It may be only set once before it's used the first time to ensure consistent behavior.");
+            }
+            EventBus.defaultInstance = build();
+            return EventBus.defaultInstance;
+        }
+    }
+
+    /** Builds an EventBus based on the current configuration. */
+    public EventBus build() {
+        return new EventBus(this);
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/EventBusException.java b/EventBus/src/de/greenrobot/event/EventBusException.java
index 4bf7c48c..80c51f86 100644
--- a/EventBus/src/de/greenrobot/event/EventBusException.java
+++ b/EventBus/src/de/greenrobot/event/EventBusException.java
@@ -1,40 +1,40 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-/**
- * An {@link RuntimeException} thrown in cases something went wrong inside EventBus.
- * 
- * @author Markus
- * 
- */
-public class EventBusException extends RuntimeException {
-
-    private static final long serialVersionUID = -2912559384646531479L;
-
-    public EventBusException(String detailMessage) {
-        super(detailMessage);
-    }
-
-    public EventBusException(Throwable throwable) {
-        super(throwable);
-    }
-
-    public EventBusException(String detailMessage, Throwable throwable) {
-        super(detailMessage, throwable);
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * An {@link RuntimeException} thrown in cases something went wrong inside EventBus.
+ * 
+ * @author Markus
+ * 
+ */
+public class EventBusException extends RuntimeException {
+
+    private static final long serialVersionUID = -2912559384646531479L;
+
+    public EventBusException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    public EventBusException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public EventBusException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/HandlerPoster.java b/EventBus/src/de/greenrobot/event/HandlerPoster.java
index 94be5ee5..c1c44608 100644
--- a/EventBus/src/de/greenrobot/event/HandlerPoster.java
+++ b/EventBus/src/de/greenrobot/event/HandlerPoster.java
@@ -1,81 +1,81 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.os.SystemClock;
-
-final class HandlerPoster extends Handler {
-
-    private final PendingPostQueue queue;
-    private final int maxMillisInsideHandleMessage;
-    private final EventBus eventBus;
-    private boolean handlerActive;
-
-    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
-        super(looper);
-        this.eventBus = eventBus;
-        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
-        queue = new PendingPostQueue();
-    }
-
-    void enqueue(Subscription subscription, Object event) {
-        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
-        synchronized (this) {
-            queue.enqueue(pendingPost);
-            if (!handlerActive) {
-                handlerActive = true;
-                if (!sendMessage(obtainMessage())) {
-                    throw new EventBusException("Could not send handler message");
-                }
-            }
-        }
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-        boolean rescheduled = false;
-        try {
-            long started = SystemClock.uptimeMillis();
-            while (true) {
-                PendingPost pendingPost = queue.poll();
-                if (pendingPost == null) {
-                    synchronized (this) {
-                        // Check again, this time in synchronized
-                        pendingPost = queue.poll();
-                        if (pendingPost == null) {
-                            handlerActive = false;
-                            return;
-                        }
-                    }
-                }
-                eventBus.invokeSubscriber(pendingPost);
-                long timeInMethod = SystemClock.uptimeMillis() - started;
-                if (timeInMethod >= maxMillisInsideHandleMessage) {
-                    if (!sendMessage(obtainMessage())) {
-                        throw new EventBusException("Could not send handler message");
-                    }
-                    rescheduled = true;
-                    return;
-                }
-            }
-        } finally {
-            handlerActive = rescheduled;
-        }
-    }
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.SystemClock;
+
+final class HandlerPoster extends Handler {
+
+    private final PendingPostQueue queue;
+    private final int maxMillisInsideHandleMessage;
+    private final EventBus eventBus;
+    private boolean handlerActive;
+
+    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
+        super(looper);
+        this.eventBus = eventBus;
+        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
+        queue = new PendingPostQueue();
+    }
+
+    void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        synchronized (this) {
+            queue.enqueue(pendingPost);
+            if (!handlerActive) {
+                handlerActive = true;
+                if (!sendMessage(obtainMessage())) {
+                    throw new EventBusException("Could not send handler message");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        boolean rescheduled = false;
+        try {
+            long started = SystemClock.uptimeMillis();
+            while (true) {
+                PendingPost pendingPost = queue.poll();
+                if (pendingPost == null) {
+                    synchronized (this) {
+                        // Check again, this time in synchronized
+                        pendingPost = queue.poll();
+                        if (pendingPost == null) {
+                            handlerActive = false;
+                            return;
+                        }
+                    }
+                }
+                eventBus.invokeSubscriber(pendingPost);
+                long timeInMethod = SystemClock.uptimeMillis() - started;
+                if (timeInMethod >= maxMillisInsideHandleMessage) {
+                    if (!sendMessage(obtainMessage())) {
+                        throw new EventBusException("Could not send handler message");
+                    }
+                    rescheduled = true;
+                    return;
+                }
+            }
+        } finally {
+            handlerActive = rescheduled;
+        }
+    }
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java b/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
index cbab594e..a7378ae8 100644
--- a/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
+++ b/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
@@ -1,35 +1,35 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-/**
- * This Event is posted by EventBus when no subscriber is found for a posted event.
- * 
- * @author Markus
- */
-public final class NoSubscriberEvent {
-    /** The {@link EventBus} instance to with the original event was posted to. */
-    public final EventBus eventBus;
-
-    /** The original event that could not be delivered to any subscriber. */
-    public final Object originalEvent;
-
-    public NoSubscriberEvent(EventBus eventBus, Object originalEvent) {
-        this.eventBus = eventBus;
-        this.originalEvent = originalEvent;
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * This Event is posted by EventBus when no subscriber is found for a posted event.
+ * 
+ * @author Markus
+ */
+public final class NoSubscriberEvent {
+    /** The {@link EventBus} instance to with the original event was posted to. */
+    public final EventBus eventBus;
+
+    /** The original event that could not be delivered to any subscriber. */
+    public final Object originalEvent;
+
+    public NoSubscriberEvent(EventBus eventBus, Object originalEvent) {
+        this.eventBus = eventBus;
+        this.originalEvent = originalEvent;
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/PendingPost.java b/EventBus/src/de/greenrobot/event/PendingPost.java
index 325e574d..0bd5a2ec 100644
--- a/EventBus/src/de/greenrobot/event/PendingPost.java
+++ b/EventBus/src/de/greenrobot/event/PendingPost.java
@@ -1,59 +1,59 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-import java.util.ArrayList;
-import java.util.List;
-
-final class PendingPost {
-    private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
-
-    Object event;
-    Subscription subscription;
-    PendingPost next;
-
-    private PendingPost(Object event, Subscription subscription) {
-        this.event = event;
-        this.subscription = subscription;
-    }
-
-    static PendingPost obtainPendingPost(Subscription subscription, Object event) {
-        synchronized (pendingPostPool) {
-            int size = pendingPostPool.size();
-            if (size > 0) {
-                PendingPost pendingPost = pendingPostPool.remove(size - 1);
-                pendingPost.event = event;
-                pendingPost.subscription = subscription;
-                pendingPost.next = null;
-                return pendingPost;
-            }
-        }
-        return new PendingPost(event, subscription);
-    }
-
-    static void releasePendingPost(PendingPost pendingPost) {
-        pendingPost.event = null;
-        pendingPost.subscription = null;
-        pendingPost.next = null;
-        synchronized (pendingPostPool) {
-            // Don't let the pool grow indefinitely
-            if (pendingPostPool.size() < 10000) {
-                pendingPostPool.add(pendingPost);
-            }
-        }
-    }
-
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.util.ArrayList;
+import java.util.List;
+
+final class PendingPost {
+    private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
+
+    Object event;
+    Subscription subscription;
+    PendingPost next;
+
+    private PendingPost(Object event, Subscription subscription) {
+        this.event = event;
+        this.subscription = subscription;
+    }
+
+    static PendingPost obtainPendingPost(Subscription subscription, Object event) {
+        synchronized (pendingPostPool) {
+            int size = pendingPostPool.size();
+            if (size > 0) {
+                PendingPost pendingPost = pendingPostPool.remove(size - 1);
+                pendingPost.event = event;
+                pendingPost.subscription = subscription;
+                pendingPost.next = null;
+                return pendingPost;
+            }
+        }
+        return new PendingPost(event, subscription);
+    }
+
+    static void releasePendingPost(PendingPost pendingPost) {
+        pendingPost.event = null;
+        pendingPost.subscription = null;
+        pendingPost.next = null;
+        synchronized (pendingPostPool) {
+            // Don't let the pool grow indefinitely
+            if (pendingPostPool.size() < 10000) {
+                pendingPostPool.add(pendingPost);
+            }
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/PendingPostQueue.java b/EventBus/src/de/greenrobot/event/PendingPostQueue.java
index c80ad40b..5440559b 100644
--- a/EventBus/src/de/greenrobot/event/PendingPostQueue.java
+++ b/EventBus/src/de/greenrobot/event/PendingPostQueue.java
@@ -1,40 +1,40 @@
-package de.greenrobot.event;
-
-final class PendingPostQueue {
-    private PendingPost head;
-    private PendingPost tail;
-
-    synchronized void enqueue(PendingPost pendingPost) {
-        if (pendingPost == null) {
-            throw new NullPointerException("null cannot be enqueued");
-        }
-        if (tail != null) {
-            tail.next = pendingPost;
-            tail = pendingPost;
-        } else if (head == null) {
-            head = tail = pendingPost;
-        } else {
-            throw new IllegalStateException("Head present, but no tail");
-        }
-        notifyAll();
-    }
-
-    synchronized PendingPost poll() {
-        PendingPost pendingPost = head;
-        if (head != null) {
-            head = head.next;
-            if (head == null) {
-                tail = null;
-            }
-        }
-        return pendingPost;
-    }
-
-    synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
-        if (head == null) {
-            wait(maxMillisToWait);
-        }
-        return poll();
-    }
-
-}
+package de.greenrobot.event;
+
+final class PendingPostQueue {
+    private PendingPost head;
+    private PendingPost tail;
+
+    synchronized void enqueue(PendingPost pendingPost) {
+        if (pendingPost == null) {
+            throw new NullPointerException("null cannot be enqueued");
+        }
+        if (tail != null) {
+            tail.next = pendingPost;
+            tail = pendingPost;
+        } else if (head == null) {
+            head = tail = pendingPost;
+        } else {
+            throw new IllegalStateException("Head present, but no tail");
+        }
+        notifyAll();
+    }
+
+    synchronized PendingPost poll() {
+        PendingPost pendingPost = head;
+        if (head != null) {
+            head = head.next;
+            if (head == null) {
+                tail = null;
+            }
+        }
+        return pendingPost;
+    }
+
+    synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
+        if (head == null) {
+            wait(maxMillisToWait);
+        }
+        return poll();
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/SubscriberExceptionEvent.java b/EventBus/src/de/greenrobot/event/SubscriberExceptionEvent.java
index 0cbbd49a..5d3b9b55 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberExceptionEvent.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberExceptionEvent.java
@@ -1,44 +1,44 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-/**
- * This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.
- * 
- * @author Markus
- */
-public final class SubscriberExceptionEvent {
-    /** The {@link EventBus} instance to with the original event was posted to. */
-    public final EventBus eventBus;
-
-    /** The Throwable thrown by a subscriber. */
-    public final Throwable throwable;
-
-    /** The original event that could not be delivered to any subscriber. */
-    public final Object causingEvent;
-
-    /** The subscriber that threw the Throwable. */
-    public final Object causingSubscriber;
-
-    public SubscriberExceptionEvent(EventBus eventBus, Throwable throwable, Object causingEvent,
-            Object causingSubscriber) {
-        this.eventBus = eventBus;
-        this.throwable = throwable;
-        this.causingEvent = causingEvent;
-        this.causingSubscriber = causingSubscriber;
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.
+ * 
+ * @author Markus
+ */
+public final class SubscriberExceptionEvent {
+    /** The {@link EventBus} instance to with the original event was posted to. */
+    public final EventBus eventBus;
+
+    /** The Throwable thrown by a subscriber. */
+    public final Throwable throwable;
+
+    /** The original event that could not be delivered to any subscriber. */
+    public final Object causingEvent;
+
+    /** The subscriber that threw the Throwable. */
+    public final Object causingSubscriber;
+
+    public SubscriberExceptionEvent(EventBus eventBus, Throwable throwable, Object causingEvent,
+            Object causingSubscriber) {
+        this.eventBus = eventBus;
+        this.throwable = throwable;
+        this.causingEvent = causingEvent;
+        this.causingSubscriber = causingSubscriber;
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethod.java b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
index 119534f4..5e0df398 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethod.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
@@ -1,59 +1,61 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-import java.lang.reflect.Method;
-
-final class SubscriberMethod {
-    final Method method;
-    final ThreadMode threadMode;
-    final Class<?> eventType;
-    /** Used for efficient comparison */
-    String methodString;
-
-    SubscriberMethod(Method method, ThreadMode threadMode, Class<?> eventType) {
-        this.method = method;
-        this.threadMode = threadMode;
-        this.eventType = eventType;
-    }
-
-    @Override
-    public boolean equals(Object other) {
-        if (other instanceof SubscriberMethod) {
-            checkMethodString();
-            // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
-            return methodString.equals(((SubscriberMethod) other).methodString);
-        } else {
-            return false;
-        }
-    }
-
-    private synchronized void checkMethodString() {
-        if (methodString == null) {
-            // Method.toString has more overhead, just take relevant parts of the method
-            StringBuilder builder = new StringBuilder(64);
-            builder.append(method.getDeclaringClass().getName());
-            builder.append('#').append(method.getName());
-            builder.append('(').append(eventType.getName());
-            methodString = builder.toString();
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return method.hashCode();
-    }
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.lang.reflect.Method;
+
+final class SubscriberMethod {
+    final Method method;
+    final ThreadMode threadMode;
+    final Class<?> eventType;
+    /** Used for efficient comparison */
+    String methodString;
+
+    SubscriberMethod(Method method, ThreadMode threadMode, Class<?> eventType) {
+        this.method = method;
+        this.threadMode = threadMode;
+        this.eventType = eventType;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof SubscriberMethod) {
+            checkMethodString();
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            otherSubscriberMethod.checkMethodString();
+            // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
+            return methodString.equals(otherSubscriberMethod.methodString);
+        } else {
+            return false;
+        }
+    }
+
+    private synchronized void checkMethodString() {
+        if (methodString == null) {
+            // Method.toString has more overhead, just take relevant parts of the method
+            StringBuilder builder = new StringBuilder(64);
+            builder.append(method.getDeclaringClass().getName());
+            builder.append('#').append(method.getName());
+            builder.append('(').append(eventType.getName());
+            methodString = builder.toString();
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return method.hashCode();
+    }
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 4be3873b..823cb0ec 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -1,111 +1,135 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-class SubscriberMethodFinder {
-    private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
-    private static final Map<Class<?>, Class<?>> skipMethodNameVerificationForClasses = new ConcurrentHashMap<Class<?>, Class<?>>();
-
-    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass, String eventMethodName) {
-        String key = subscriberClass.getName() + '.' + eventMethodName;
-        List<SubscriberMethod> subscriberMethods;
-        synchronized (methodCache) {
-            subscriberMethods = methodCache.get(key);
-        }
-        if (subscriberMethods != null) {
-            return subscriberMethods;
-        }
-        subscriberMethods = new ArrayList<SubscriberMethod>();
-        Class<?> clazz = subscriberClass;
-        HashSet<String> eventTypesFound = new HashSet<String>();
-        StringBuilder methodKeyBuilder = new StringBuilder();
-        while (clazz != null) {
-            String name = clazz.getName();
-            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
-                // Skip system classes, this just degrades performance
-                break;
-            }
-
-            Method[] methods = clazz.getDeclaredMethods();
-            for (Method method : methods) {
-                String methodName = method.getName();
-                if (methodName.startsWith(eventMethodName)) {
-                    Class<?>[] parameterTypes = method.getParameterTypes();
-                    if (parameterTypes.length == 1) {
-                        String modifierString = methodName.substring(eventMethodName.length());
-                        ThreadMode threadMode;
-                        if (modifierString.length() == 0) {
-                            threadMode = ThreadMode.PostThread;
-                        } else if (modifierString.equals("MainThread")) {
-                            threadMode = ThreadMode.MainThread;
-                        } else if (modifierString.equals("BackgroundThread")) {
-                            threadMode = ThreadMode.BackgroundThread;
-                        } else if (modifierString.equals("Async")) {
-                            threadMode = ThreadMode.Async;
-                        } else {
-                            if (skipMethodNameVerificationForClasses.containsKey(clazz)) {
-                                continue;
-                            } else {
-                                throw new EventBusException("Illegal onEvent method, check for typos: " + method);
-                            }
-                        }
-                        Class<?> eventType = parameterTypes[0];
-                        methodKeyBuilder.setLength(0);
-                        methodKeyBuilder.append(methodName);
-                        methodKeyBuilder.append('>').append(eventType.getName());
-                        String methodKey = methodKeyBuilder.toString();
-                        if (eventTypesFound.add(methodKey)) {
-                            // Only add if not already found in a sub class
-                            subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
-                        }
-                    }
-                }
-            }
-            clazz = clazz.getSuperclass();
-        }
-        if (subscriberMethods.isEmpty()) {
-            throw new EventBusException("Subscriber " + subscriberClass + " has no methods called " + eventMethodName);
-        } else {
-            synchronized (methodCache) {
-                methodCache.put(key, subscriberMethods);
-            }
-            return subscriberMethods;
-        }
-    }
-
-    static void clearCaches() {
-        methodCache.clear();
-    }
-
-    static void skipMethodNameVerificationFor(Class<?> clazz) {
-        if (!methodCache.isEmpty()) {
-            throw new IllegalStateException("This method must be called before registering anything");
-        }
-        skipMethodNameVerificationForClasses.put(clazz, clazz);
-    }
-
-    public static void clearSkipMethodNameVerifications() {
-        skipMethodNameVerificationForClasses.clear();
-    }
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.util.Log;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+class SubscriberMethodFinder {
+    private static final String ON_EVENT_METHOD_NAME = "onEvent";
+
+    /*
+     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
+     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
+     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
+     */
+    private static final int BRIDGE = 0x40;
+    private static final int SYNTHETIC = 0x1000;
+
+    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+    private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
+
+    private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
+
+    SubscriberMethodFinder(List<Class<?>> skipMethodVerificationForClassesList) {
+        skipMethodVerificationForClasses = new ConcurrentHashMap<Class<?>, Class<?>>();
+        if (skipMethodVerificationForClassesList != null) {
+            for (Class<?> clazz : skipMethodVerificationForClassesList) {
+                skipMethodVerificationForClasses.put(clazz, clazz);
+            }
+        }
+    }
+
+    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        String key = subscriberClass.getName();
+        List<SubscriberMethod> subscriberMethods;
+        synchronized (methodCache) {
+            subscriberMethods = methodCache.get(key);
+        }
+        if (subscriberMethods != null) {
+            return subscriberMethods;
+        }
+        subscriberMethods = new ArrayList<SubscriberMethod>();
+        Class<?> clazz = subscriberClass;
+        HashSet<String> eventTypesFound = new HashSet<String>();
+        StringBuilder methodKeyBuilder = new StringBuilder();
+        while (clazz != null) {
+            String name = clazz.getName();
+            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
+                // Skip system classes, this just degrades performance
+                break;
+            }
+
+            // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+            Method[] methods = clazz.getDeclaredMethods();
+            for (Method method : methods) {
+                String methodName = method.getName();
+                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
+                    int modifiers = method.getModifiers();
+                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                        Class<?>[] parameterTypes = method.getParameterTypes();
+                        if (parameterTypes.length == 1) {
+                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
+                            ThreadMode threadMode;
+                            if (modifierString.length() == 0) {
+                                threadMode = ThreadMode.PostThread;
+                            } else if (modifierString.equals("MainThread")) {
+                                threadMode = ThreadMode.MainThread;
+                            } else if (modifierString.equals("BackgroundThread")) {
+                                threadMode = ThreadMode.BackgroundThread;
+                            } else if (modifierString.equals("Async")) {
+                                threadMode = ThreadMode.Async;
+                            } else {
+                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
+                                    continue;
+                                } else {
+                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
+                                }
+                            }
+                            Class<?> eventType = parameterTypes[0];
+                            methodKeyBuilder.setLength(0);
+                            methodKeyBuilder.append(methodName);
+                            methodKeyBuilder.append('>').append(eventType.getName());
+                            String methodKey = methodKeyBuilder.toString();
+                            if (eventTypesFound.add(methodKey)) {
+                                // Only add if not already found in a sub class
+                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                            }
+                        }
+                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
+                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
+                                + methodName);
+                    }
+                }
+            }
+            clazz = clazz.getSuperclass();
+        }
+        if (subscriberMethods.isEmpty()) {
+            throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
+                    + ON_EVENT_METHOD_NAME);
+        } else {
+            synchronized (methodCache) {
+                methodCache.put(key, subscriberMethods);
+            }
+            return subscriberMethods;
+        }
+    }
+
+    static void clearCaches() {
+        synchronized (methodCache) {
+            methodCache.clear();
+        }
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/Subscription.java b/EventBus/src/de/greenrobot/event/Subscription.java
index 5bbe5aa3..6c84c440 100644
--- a/EventBus/src/de/greenrobot/event/Subscription.java
+++ b/EventBus/src/de/greenrobot/event/Subscription.java
@@ -1,41 +1,50 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-final class Subscription {
-    final Object subscriber;
-    final SubscriberMethod subscriberMethod;
-    
-    Subscription(Object subscriber, SubscriberMethod subscriberMethod) {
-        this.subscriber = subscriber;
-        this.subscriberMethod = subscriberMethod;
-    }
-
-    @Override
-    public boolean equals(Object other) {
-        if (other instanceof Subscription) {
-            Subscription otherSubscription = (Subscription) other;
-            return subscriber == otherSubscription.subscriber && subscriberMethod.equals(otherSubscription.subscriberMethod);
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return subscriber.hashCode() + subscriberMethod.methodString.hashCode();
-    }
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+final class Subscription {
+    final Object subscriber;
+    final SubscriberMethod subscriberMethod;
+    final int priority;
+    /**
+     * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
+     * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions.
+     */
+    volatile boolean active;
+
+    Subscription(Object subscriber, SubscriberMethod subscriberMethod, int priority) {
+        this.subscriber = subscriber;
+        this.subscriberMethod = subscriberMethod;
+        this.priority = priority;
+        active = true;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof Subscription) {
+            Subscription otherSubscription = (Subscription) other;
+            return subscriber == otherSubscription.subscriber
+                    && subscriberMethod.equals(otherSubscription.subscriberMethod);
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return subscriber.hashCode() + subscriberMethod.methodString.hashCode();
+    }
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/ThreadMode.java b/EventBus/src/de/greenrobot/event/ThreadMode.java
index 7840cad6..4022ace5 100644
--- a/EventBus/src/de/greenrobot/event/ThreadMode.java
+++ b/EventBus/src/de/greenrobot/event/ThreadMode.java
@@ -1,57 +1,57 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event;
-
-/**
- * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
- * EventBus takes care of threading independently from the posting thread.
- * 
- * @see EventBus#register(Object)
- * @author Markus
- */
-public enum ThreadMode {
-    /**
-     * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
-     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
-     * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
-     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
-     */
-    PostThread,
-
-    /**
-     * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
-     * the main thread, event handler methods will be called directly. Event handlers using this mode must return
-     * quickly to avoid blocking the main thread.
-     */
-    MainThread,
-
-    /**
-     * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
-     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
-     * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
-     * return quickly to avoid blocking the background thread.
-     */
-    BackgroundThread,
-
-    /**
-     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
-     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
-     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
-     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
-     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
-     */
-    Async
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
+ * EventBus takes care of threading independently from the posting thread.
+ * 
+ * @see EventBus#register(Object)
+ * @author Markus
+ */
+public enum ThreadMode {
+    /**
+     * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
+     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
+     * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
+     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
+     */
+    PostThread,
+
+    /**
+     * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
+     * the main thread, event handler methods will be called directly. Event handlers using this mode must return
+     * quickly to avoid blocking the main thread.
+     */
+    MainThread,
+
+    /**
+     * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
+     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
+     * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
+     * return quickly to avoid blocking the background thread.
+     */
+    BackgroundThread,
+
+    /**
+     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
+     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
+     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
+     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
+     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+     */
+    Async
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/util/AsyncExecutor.java b/EventBus/src/de/greenrobot/event/util/AsyncExecutor.java
index 38794076..71048a43 100644
--- a/EventBus/src/de/greenrobot/event/util/AsyncExecutor.java
+++ b/EventBus/src/de/greenrobot/event/util/AsyncExecutor.java
@@ -1,119 +1,133 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.util;
-
-import java.lang.reflect.Constructor;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-import android.util.Log;
-import de.greenrobot.event.EventBus;
-
-/**
- * Executes an {@link RunnableEx} using a thread pool. Thrown exceptions are propagated by posting failure events of any
- * given type (default is {@link ThrowableFailureEvent}).
- * 
- * @author Markus
- */
-public class AsyncExecutor {
-
-    public static class Builder {
-        private Executor threadPool;
-        private Class<?> failureEventType;
-        private EventBus eventBus;
-
-        private Builder() {
-        }
-
-        public Builder threadPool(Executor threadPool) {
-            this.threadPool = threadPool;
-            return this;
-        }
-
-        public Builder failureEventType(Class<?> failureEventType) {
-            this.failureEventType = failureEventType;
-            return this;
-        }
-
-        public Builder eventBus(EventBus eventBus) {
-            this.eventBus = eventBus;
-            return this;
-        }
-
-        public AsyncExecutor build() {
-            if (eventBus == null) {
-                eventBus = EventBus.getDefault();
-            }
-            if (threadPool == null) {
-                threadPool = Executors.newCachedThreadPool();
-            }
-            if (failureEventType == null) {
-                failureEventType = ThrowableFailureEvent.class;
-            }
-            return new AsyncExecutor(threadPool, eventBus, failureEventType);
-        }
-    }
-
-    /** Like {@link Runnable}, but the run method may throw an exception. */
-    public interface RunnableEx {
-        void run() throws Exception;
-    }
-
-    public static Builder builder() {
-        return new Builder();
-    }
-
-    public static AsyncExecutor create() {
-        return new Builder().build();
-    }
-
-    private final Executor threadPool;
-    private final Constructor<?> failureEventConstructor;
-    private final EventBus eventBus;
-
-    private AsyncExecutor(Executor threadPool, EventBus eventBus, Class<?> failureEventType) {
-        this.threadPool = threadPool;
-        this.eventBus = eventBus;
-        try {
-            failureEventConstructor = failureEventType.getConstructor(Throwable.class);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException(
-                    "Failure event class must have a constructor with one parameter of type Throwable", e);
-        }
-    }
-
-    /** Posts an failure event if the given {@link RunnableEx} throws an Exception. */
-    public void execute(final RunnableEx runnable) {
-        threadPool.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    runnable.run();
-                } catch (Exception e) {
-                    Object event;
-                    try {
-                        event = failureEventConstructor.newInstance(e);
-                    } catch (Exception e1) {
-                        Log.e(EventBus.TAG, "Original exception:", e);
-                        throw new RuntimeException("Could not create failure event", e1);
-                    }
-                    eventBus.post(event);
-                }
-            }
-        });
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.util;
+
+import java.lang.reflect.Constructor;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import android.app.Activity;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+/**
+ * Executes an {@link RunnableEx} using a thread pool. Thrown exceptions are propagated by posting failure events of any
+ * given type (default is {@link ThrowableFailureEvent}).
+ * 
+ * @author Markus
+ */
+public class AsyncExecutor {
+
+    public static class Builder {
+        private Executor threadPool;
+        private Class<?> failureEventType;
+        private EventBus eventBus;
+
+        private Builder() {
+        }
+
+        public Builder threadPool(Executor threadPool) {
+            this.threadPool = threadPool;
+            return this;
+        }
+
+        public Builder failureEventType(Class<?> failureEventType) {
+            this.failureEventType = failureEventType;
+            return this;
+        }
+
+        public Builder eventBus(EventBus eventBus) {
+            this.eventBus = eventBus;
+            return this;
+        }
+
+        public AsyncExecutor build() {
+            return buildForScope(null);
+        }
+
+        public AsyncExecutor buildForActivityScope(Activity activity) {
+            return buildForScope(activity.getClass());
+        }
+        
+        public AsyncExecutor buildForScope(Object executionContext) {
+            if (eventBus == null) {
+                eventBus = EventBus.getDefault();
+            }
+            if (threadPool == null) {
+                threadPool = Executors.newCachedThreadPool();
+            }
+            if (failureEventType == null) {
+                failureEventType = ThrowableFailureEvent.class;
+            }
+            return new AsyncExecutor(threadPool, eventBus, failureEventType, executionContext);
+        }
+    }
+
+    /** Like {@link Runnable}, but the run method may throw an exception. */
+    public interface RunnableEx {
+        void run() throws Exception;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static AsyncExecutor create() {
+        return new Builder().build();
+    }
+
+    private final Executor threadPool;
+    private final Constructor<?> failureEventConstructor;
+    private final EventBus eventBus;
+    private final Object scope;
+
+    private AsyncExecutor(Executor threadPool, EventBus eventBus, Class<?> failureEventType, Object scope) {
+        this.threadPool = threadPool;
+        this.eventBus = eventBus;
+        this.scope = scope;
+        try {
+            failureEventConstructor = failureEventType.getConstructor(Throwable.class);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(
+                    "Failure event class must have a constructor with one parameter of type Throwable", e);
+        }
+    }
+
+    /** Posts an failure event if the given {@link RunnableEx} throws an Exception. */
+    public void execute(final RunnableEx runnable) {
+        threadPool.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    runnable.run();
+                } catch (Exception e) {
+                    Object event;
+                    try {
+                        event = failureEventConstructor.newInstance(e);
+                    } catch (Exception e1) {
+                        Log.e(EventBus.TAG, "Original exception:", e);
+                        throw new RuntimeException("Could not create failure event", e1);
+                    }
+                    if (event instanceof HasExecutionScope) {
+                        ((HasExecutionScope) event).setExecutionScope(scope);
+                    }
+                    eventBus.post(event);
+                }
+            }
+        });
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/util/ErrorDialogConfig.java b/EventBus/src/de/greenrobot/event/util/ErrorDialogConfig.java
index 0bbf9450..25432631 100644
--- a/EventBus/src/de/greenrobot/event/util/ErrorDialogConfig.java
+++ b/EventBus/src/de/greenrobot/event/util/ErrorDialogConfig.java
@@ -1,65 +1,65 @@
-package de.greenrobot.event.util;
-
-import android.content.res.Resources;
-import android.util.Log;
-import de.greenrobot.event.EventBus;
-
-public class ErrorDialogConfig {
-    final Resources resources;
-    final int defaultTitleId;
-    final int defaultErrorMsgId;
-    final ExceptionToResourceMapping mapping;
-
-    EventBus eventBus;
-    boolean logExceptions = true;
-    String tagForLoggingExceptions;
-    int defaultDialogIconId;
-    Class<?> defaultEventTypeOnDialogClosed;
-
-    public ErrorDialogConfig(Resources resources, int defaultTitleId, int defaultMsgId) {
-        this.resources = resources;
-        this.defaultTitleId = defaultTitleId;
-        this.defaultErrorMsgId = defaultMsgId;
-        mapping = new ExceptionToResourceMapping();
-    }
-
-    public ErrorDialogConfig addMapping(Class<? extends Throwable> clazz, int msgId) {
-        mapping.addMapping(clazz, msgId);
-        return this;
-    }
-
-    public int getMessageIdForThrowable(final Throwable throwable) {
-        Integer resId = mapping.mapThrowable(throwable);
-        if (resId != null) {
-            return resId;
-        } else {
-            Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
-            return defaultErrorMsgId;
-        }
-    }
-
-    public void setDefaultDialogIconId(int defaultDialogIconId) {
-        this.defaultDialogIconId = defaultDialogIconId;
-    }
-
-    public void setDefaultEventTypeOnDialogClosed(Class<?> defaultEventTypeOnDialogClosed) {
-        this.defaultEventTypeOnDialogClosed = defaultEventTypeOnDialogClosed;
-    }
-
-    public void disableExceptionLogging() {
-        logExceptions = false;
-    }
-
-    public void setTagForLoggingExceptions(String tagForLoggingExceptions) {
-        this.tagForLoggingExceptions = tagForLoggingExceptions;
-    }
-
-    public void setEventBus(EventBus eventBus) {
-        this.eventBus = eventBus;
-    }
-
-    /** eventBus!=null ? eventBus: EventBus.getDefault() */
-    EventBus getEventBus() {
-        return eventBus!=null ? eventBus: EventBus.getDefault();
-    }
+package de.greenrobot.event.util;
+
+import android.content.res.Resources;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+public class ErrorDialogConfig {
+    final Resources resources;
+    final int defaultTitleId;
+    final int defaultErrorMsgId;
+    final ExceptionToResourceMapping mapping;
+
+    EventBus eventBus;
+    boolean logExceptions = true;
+    String tagForLoggingExceptions;
+    int defaultDialogIconId;
+    Class<?> defaultEventTypeOnDialogClosed;
+
+    public ErrorDialogConfig(Resources resources, int defaultTitleId, int defaultMsgId) {
+        this.resources = resources;
+        this.defaultTitleId = defaultTitleId;
+        this.defaultErrorMsgId = defaultMsgId;
+        mapping = new ExceptionToResourceMapping();
+    }
+
+    public ErrorDialogConfig addMapping(Class<? extends Throwable> clazz, int msgId) {
+        mapping.addMapping(clazz, msgId);
+        return this;
+    }
+
+    public int getMessageIdForThrowable(final Throwable throwable) {
+        Integer resId = mapping.mapThrowable(throwable);
+        if (resId != null) {
+            return resId;
+        } else {
+            Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
+            return defaultErrorMsgId;
+        }
+    }
+
+    public void setDefaultDialogIconId(int defaultDialogIconId) {
+        this.defaultDialogIconId = defaultDialogIconId;
+    }
+
+    public void setDefaultEventTypeOnDialogClosed(Class<?> defaultEventTypeOnDialogClosed) {
+        this.defaultEventTypeOnDialogClosed = defaultEventTypeOnDialogClosed;
+    }
+
+    public void disableExceptionLogging() {
+        logExceptions = false;
+    }
+
+    public void setTagForLoggingExceptions(String tagForLoggingExceptions) {
+        this.tagForLoggingExceptions = tagForLoggingExceptions;
+    }
+
+    public void setEventBus(EventBus eventBus) {
+        this.eventBus = eventBus;
+    }
+
+    /** eventBus!=null ? eventBus: EventBus.getDefault() */
+    EventBus getEventBus() {
+        return eventBus!=null ? eventBus: EventBus.getDefault();
+    }
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/util/ErrorDialogFragmentFactory.java b/EventBus/src/de/greenrobot/event/util/ErrorDialogFragmentFactory.java
index eb3846f0..47b693b6 100644
--- a/EventBus/src/de/greenrobot/event/util/ErrorDialogFragmentFactory.java
+++ b/EventBus/src/de/greenrobot/event/util/ErrorDialogFragmentFactory.java
@@ -1,101 +1,98 @@
-package de.greenrobot.event.util;
-
-import android.annotation.TargetApi;
-import android.os.Build;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-
-/**
- * Factory to allow injecting a more complex exception mapping; typically you would subclass one of {@link Honeycomb} or
- * {@link Support}.
- */
-public abstract class ErrorDialogFragmentFactory<T> {
-    protected final ErrorDialogConfig config;
-
-    protected ErrorDialogFragmentFactory(ErrorDialogConfig config) {
-        this.config = config;
-    }
-
-    /**
-     * Prepares the fragment's arguments and creates the fragment. May be overridden to provide custom error fragments.
-     * 
-     * @param argumentsForErrorDialog
-     * @param finishAfterDialog
-     */
-    protected T prepareErrorFragment(ThrowableFailureEvent event, boolean finishAfterDialog,
-            Bundle argumentsForErrorDialog) {
-        if (event.isSuppressErrorUi()) {
-            // Show nothing by default
-            return null;
-        }
-        Bundle bundle;
-        if (argumentsForErrorDialog != null) {
-            bundle = (Bundle) argumentsForErrorDialog.clone();
-        } else {
-            bundle = new Bundle();
-        }
-
-        if (!bundle.containsKey(ErrorDialogManager.KEY_TITLE)) {
-            String title = getTitleFor(event, bundle);
-            bundle.putString(ErrorDialogManager.KEY_TITLE, title);
-        }
-        if (!bundle.containsKey(ErrorDialogManager.KEY_MESSAGE)) {
-            String message = getMessageFor(event, bundle);
-            bundle.putString(ErrorDialogManager.KEY_MESSAGE, message);
-        }
-        if (!bundle.containsKey(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG)) {
-            bundle.putBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, finishAfterDialog);
-        }
-        if (!bundle.containsKey(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE)
-                && config.defaultEventTypeOnDialogClosed != null) {
-            bundle.putSerializable(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE, config.defaultEventTypeOnDialogClosed);
-        }
-        if (!bundle.containsKey(ErrorDialogManager.KEY_ICON_ID) && config.defaultDialogIconId != 0) {
-            bundle.putInt(ErrorDialogManager.KEY_ICON_ID, config.defaultDialogIconId);
-        }
-        return createErrorFragment(event, bundle);
-    }
-
-    /** Returns either a new Honeycomb+ or a new support library DialogFragment. */
-    protected abstract T createErrorFragment(ThrowableFailureEvent event, Bundle arguments);
-
-    /** May be overridden to provide custom error title. */
-    protected String getTitleFor(ThrowableFailureEvent event, Bundle arguments) {
-        return config.resources.getString(config.defaultTitleId);
-    }
-
-    /** May be overridden to provide custom error messages. */
-    protected String getMessageFor(ThrowableFailureEvent event, Bundle arguments) {
-        int msgResId = config.getMessageIdForThrowable(event.throwable);
-        return config.resources.getString(msgResId);
-    }
-
-    public static class Support extends ErrorDialogFragmentFactory<Fragment> {
-
-        public Support(ErrorDialogConfig config) {
-            super(config);
-        }
-
-        protected Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
-            ErrorDialogFragments.Support errorFragment = new ErrorDialogFragments.Support();
-            errorFragment.setArguments(arguments);
-            return errorFragment;
-        }
-
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public static class Honeycomb extends ErrorDialogFragmentFactory<android.app.Fragment> {
-
-        public Honeycomb(ErrorDialogConfig config) {
-            super(config);
-        }
-
-        protected android.app.Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
-            ErrorDialogFragments.Honeycomb errorFragment = new ErrorDialogFragments.Honeycomb();
-            errorFragment.setArguments(arguments);
-            return errorFragment;
-        }
-
-    }
+package de.greenrobot.event.util;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+/**
+ * Factory to allow injecting a more complex exception mapping; typically you would subclass one of {@link Honeycomb} or
+ * {@link Support}.
+ */
+public abstract class ErrorDialogFragmentFactory<T> {
+    protected final ErrorDialogConfig config;
+
+    protected ErrorDialogFragmentFactory(ErrorDialogConfig config) {
+        this.config = config;
+    }
+
+    /**
+     * Prepares the fragment's arguments and creates the fragment. May be overridden to provide custom error fragments.
+     */
+    protected T prepareErrorFragment(ThrowableFailureEvent event, boolean finishAfterDialog,
+            Bundle argumentsForErrorDialog) {
+        if (event.isSuppressErrorUi()) {
+            // Show nothing by default
+            return null;
+        }
+        Bundle bundle;
+        if (argumentsForErrorDialog != null) {
+            bundle = (Bundle) argumentsForErrorDialog.clone();
+        } else {
+            bundle = new Bundle();
+        }
+
+        if (!bundle.containsKey(ErrorDialogManager.KEY_TITLE)) {
+            String title = getTitleFor(event, bundle);
+            bundle.putString(ErrorDialogManager.KEY_TITLE, title);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_MESSAGE)) {
+            String message = getMessageFor(event, bundle);
+            bundle.putString(ErrorDialogManager.KEY_MESSAGE, message);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG)) {
+            bundle.putBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, finishAfterDialog);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE)
+                && config.defaultEventTypeOnDialogClosed != null) {
+            bundle.putSerializable(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE, config.defaultEventTypeOnDialogClosed);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_ICON_ID) && config.defaultDialogIconId != 0) {
+            bundle.putInt(ErrorDialogManager.KEY_ICON_ID, config.defaultDialogIconId);
+        }
+        return createErrorFragment(event, bundle);
+    }
+
+    /** Returns either a new Honeycomb+ or a new support library DialogFragment. */
+    protected abstract T createErrorFragment(ThrowableFailureEvent event, Bundle arguments);
+
+    /** May be overridden to provide custom error title. */
+    protected String getTitleFor(ThrowableFailureEvent event, Bundle arguments) {
+        return config.resources.getString(config.defaultTitleId);
+    }
+
+    /** May be overridden to provide custom error messages. */
+    protected String getMessageFor(ThrowableFailureEvent event, Bundle arguments) {
+        int msgResId = config.getMessageIdForThrowable(event.throwable);
+        return config.resources.getString(msgResId);
+    }
+
+    public static class Support extends ErrorDialogFragmentFactory<Fragment> {
+
+        public Support(ErrorDialogConfig config) {
+            super(config);
+        }
+
+        protected Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
+            ErrorDialogFragments.Support errorFragment = new ErrorDialogFragments.Support();
+            errorFragment.setArguments(arguments);
+            return errorFragment;
+        }
+
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static class Honeycomb extends ErrorDialogFragmentFactory<android.app.Fragment> {
+
+        public Honeycomb(ErrorDialogConfig config) {
+            super(config);
+        }
+
+        protected android.app.Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
+            ErrorDialogFragments.Honeycomb errorFragment = new ErrorDialogFragments.Honeycomb();
+            errorFragment.setArguments(arguments);
+            return errorFragment;
+        }
+
+    }
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/util/ErrorDialogFragments.java b/EventBus/src/de/greenrobot/event/util/ErrorDialogFragments.java
index 50f23392..04002df2 100644
--- a/EventBus/src/de/greenrobot/event/util/ErrorDialogFragments.java
+++ b/EventBus/src/de/greenrobot/event/util/ErrorDialogFragments.java
@@ -1,74 +1,74 @@
-package de.greenrobot.event.util;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.DialogInterface.OnClickListener;
-import android.os.Build;
-import android.os.Bundle;
-import android.support.v4.app.DialogFragment;
-import de.greenrobot.event.EventBus;
-
-public class ErrorDialogFragments {
-    /** TODO Use config:  Icon res ID to use for all error dialogs. May be configured by each app (optional). */
-    public static int ERROR_DIALOG_ICON = 0;
-
-    /** TODO Use config:  Event class to be fired on dismissing the dialog by the user. May be configured by each app. */
-    public static Class<?> EVENT_TYPE_ON_CLICK;
-
-    public static Dialog createDialog(Context context, Bundle arguments, OnClickListener onClickListener) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setTitle(arguments.getString(ErrorDialogManager.KEY_TITLE));
-        builder.setMessage(arguments.getString(ErrorDialogManager.KEY_MESSAGE));
-        if (ERROR_DIALOG_ICON != 0) {
-            builder.setIcon(ERROR_DIALOG_ICON);
-        }
-        builder.setPositiveButton(android.R.string.ok, onClickListener);
-        return builder.create();
-    }
-
-    public static void handleOnClick(DialogInterface dialog, int which, Activity activity, Bundle arguments) {
-        if (EVENT_TYPE_ON_CLICK != null) {
-            Object event;
-            try {
-                event = EVENT_TYPE_ON_CLICK.newInstance();
-            } catch (Exception e) {
-                throw new RuntimeException("Event cannot be constructed", e);
-            }
-            EventBus eventBus = ErrorDialogManager.factory.config.getEventBus();
-            eventBus.post(event);
-        }
-        boolean finish = arguments.getBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, false);
-        if (finish && activity != null) {
-            activity.finish();
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public static class Honeycomb extends android.app.DialogFragment implements OnClickListener {
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            return createDialog(getActivity(), getArguments(), this);
-        }
-
-        @Override
-        public void onClick(DialogInterface dialog, int which) {
-            handleOnClick(dialog, which, getActivity(), getArguments());
-        }
-    }
-
-    public static class Support extends DialogFragment implements OnClickListener {
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            return createDialog(getActivity(), getArguments(), this);
-        }
-
-        @Override
-        public void onClick(DialogInterface dialog, int which) {
-            handleOnClick(dialog, which, getActivity(), getArguments());
-        }
-    }
-}
+package de.greenrobot.event.util;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import de.greenrobot.event.EventBus;
+
+public class ErrorDialogFragments {
+    /** TODO Use config:  Icon res ID to use for all error dialogs. May be configured by each app (optional). */
+    public static int ERROR_DIALOG_ICON = 0;
+
+    /** TODO Use config:  Event class to be fired on dismissing the dialog by the user. May be configured by each app. */
+    public static Class<?> EVENT_TYPE_ON_CLICK;
+
+    public static Dialog createDialog(Context context, Bundle arguments, OnClickListener onClickListener) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        builder.setTitle(arguments.getString(ErrorDialogManager.KEY_TITLE));
+        builder.setMessage(arguments.getString(ErrorDialogManager.KEY_MESSAGE));
+        if (ERROR_DIALOG_ICON != 0) {
+            builder.setIcon(ERROR_DIALOG_ICON);
+        }
+        builder.setPositiveButton(android.R.string.ok, onClickListener);
+        return builder.create();
+    }
+
+    public static void handleOnClick(DialogInterface dialog, int which, Activity activity, Bundle arguments) {
+        if (EVENT_TYPE_ON_CLICK != null) {
+            Object event;
+            try {
+                event = EVENT_TYPE_ON_CLICK.newInstance();
+            } catch (Exception e) {
+                throw new RuntimeException("Event cannot be constructed", e);
+            }
+            EventBus eventBus = ErrorDialogManager.factory.config.getEventBus();
+            eventBus.post(event);
+        }
+        boolean finish = arguments.getBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, false);
+        if (finish && activity != null) {
+            activity.finish();
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static class Honeycomb extends android.app.DialogFragment implements OnClickListener {
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            return createDialog(getActivity(), getArguments(), this);
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            handleOnClick(dialog, which, getActivity(), getArguments());
+        }
+    }
+
+    public static class Support extends DialogFragment implements OnClickListener {
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            return createDialog(getActivity(), getArguments(), this);
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            handleOnClick(dialog, which, getActivity(), getArguments());
+        }
+    }
+}
diff --git a/EventBus/src/de/greenrobot/event/util/ErrorDialogManager.java b/EventBus/src/de/greenrobot/event/util/ErrorDialogManager.java
index cf834802..cee7c6a5 100644
--- a/EventBus/src/de/greenrobot/event/util/ErrorDialogManager.java
+++ b/EventBus/src/de/greenrobot/event/util/ErrorDialogManager.java
@@ -33,6 +33,7 @@
         protected Bundle argumentsForErrorDialog;
         private EventBus eventBus;
         private boolean skipRegisterOnNextResume;
+        private Object executionScope;
 
         @Override
         public void onCreate(Bundle savedInstanceState) {
@@ -61,6 +62,9 @@ public void onPause() {
         }
 
         public void onEventMainThread(ThrowableFailureEvent event) {
+            if (!isInExecutionScope(executionScope, event)) {
+                return;
+            }
             checkLogException(event);
             // Execute pending commits before finding to avoid multiple error fragments being shown
             FragmentManager fm = getFragmentManager();
@@ -79,7 +83,8 @@ public void onEventMainThread(ThrowableFailureEvent event) {
             }
         }
 
-        public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+        public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog,
+                Bundle argumentsForErrorDialog) {
             FragmentManager fm = ((FragmentActivity) activity).getSupportFragmentManager();
             SupportManagerFragment fragment = (SupportManagerFragment) fm.findFragmentByTag(TAG_ERROR_DIALOG_MANAGER);
             if (fragment == null) {
@@ -89,6 +94,7 @@ public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle
             }
             fragment.finishAfterDialog = finishAfterDialog;
             fragment.argumentsForErrorDialog = argumentsForErrorDialog;
+            fragment.executionScope = executionScope;
         }
     }
 
@@ -97,6 +103,7 @@ public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle
         protected boolean finishAfterDialog;
         protected Bundle argumentsForErrorDialog;
         private EventBus eventBus;
+        private Object executionScope;
 
         @Override
         public void onResume() {
@@ -112,6 +119,9 @@ public void onPause() {
         }
 
         public void onEventMainThread(ThrowableFailureEvent event) {
+            if (!isInExecutionScope(executionScope, event)) {
+                return;
+            }
             checkLogException(event);
 
             // Execute pending commits before finding to avoid multiple error fragments being shown
@@ -132,7 +142,7 @@ public void onEventMainThread(ThrowableFailureEvent event) {
             }
         }
 
-        public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+        public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
             android.app.FragmentManager fm = activity.getFragmentManager();
             HoneycombManagerFragment fragment = (HoneycombManagerFragment) fm
                     .findFragmentByTag(TAG_ERROR_DIALOG_MANAGER);
@@ -143,6 +153,7 @@ public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle
             }
             fragment.finishAfterDialog = finishAfterDialog;
             fragment.argumentsForErrorDialog = argumentsForErrorDialog;
+            fragment.executionScope = executionScope;
         }
     }
 
@@ -158,22 +169,30 @@ public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle
     public static final String KEY_ICON_ID = "de.greenrobot.eventbus.errordialog.icon_id";
     public static final String KEY_EVENT_TYPE_ON_CLOSE = "de.greenrobot.eventbus.errordialog.event_type_on_close";
 
+    /** Scope is limited to the activity's class. */
     public static void attachTo(Activity activity) {
         attachTo(activity, false, null);
     }
 
+    /** Scope is limited to the activity's class. */
     public static void attachTo(Activity activity, boolean finishAfterDialog) {
         attachTo(activity, finishAfterDialog, null);
     }
 
+    /** Scope is limited to the activity's class. */
     public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+        Object executionScope = activity.getClass();
+        attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
+    }
+    
+    public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
         if (factory == null) {
             throw new RuntimeException("You must set the static factory field to configure error dialogs for your app.");
         }
         if (isSupportActivity(activity)) {
-            SupportManagerFragment.attachTo(activity, finishAfterDialog, argumentsForErrorDialog);
+            SupportManagerFragment.attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
         } else {
-            HoneycombManagerFragment.attachTo(activity, finishAfterDialog, argumentsForErrorDialog);
+            HoneycombManagerFragment.attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
         }
     }
 
@@ -212,4 +231,15 @@ protected static void checkLogException(ThrowableFailureEvent event) {
         }
     }
 
+    private static boolean isInExecutionScope(Object executionScope, ThrowableFailureEvent event) {
+        if (event != null) {
+            Object eventExecutionScope = event.getExecutionScope();
+            if (eventExecutionScope != null && !eventExecutionScope.equals(executionScope)) {
+                // Event not in our scope, do nothing
+                return false;
+            }
+        }
+        return true;
+    }
+
 }
diff --git a/EventBus/src/de/greenrobot/event/util/ExceptionToResourceMapping.java b/EventBus/src/de/greenrobot/event/util/ExceptionToResourceMapping.java
index 99c5e9a0..d3286175 100644
--- a/EventBus/src/de/greenrobot/event/util/ExceptionToResourceMapping.java
+++ b/EventBus/src/de/greenrobot/event/util/ExceptionToResourceMapping.java
@@ -1,73 +1,73 @@
-package de.greenrobot.event.util;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-
-import android.util.Log;
-import de.greenrobot.event.EventBus;
-
-
-/**
- * Maps throwables to texts for error dialogs. Use Config to configure the mapping.
- * 
- * @author Markus
- */
-public class ExceptionToResourceMapping {
-
-    public final Map<Class<? extends Throwable>, Integer> throwableToMsgIdMap;
-
-    public ExceptionToResourceMapping() {
-        throwableToMsgIdMap = new HashMap<Class<? extends Throwable>, Integer>();
-    }
-
-    /** Looks at the exception and its causes trying to find an ID. */
-    public Integer mapThrowable(final Throwable throwable) {
-        Throwable throwableToCheck = throwable;
-        int depthToGo = 20;
-
-        while (true) {
-            Integer resId = mapThrowableFlat(throwableToCheck);
-            if (resId != null) {
-                return resId;
-            } else {
-                throwableToCheck = throwableToCheck.getCause();
-                depthToGo--;
-                if (depthToGo <= 0 || throwableToCheck == throwable || throwableToCheck == null) {
-                    Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
-                    // return config.defaultErrorMsgId;
-                    return null;
-                }
-            }
-        }
-
-    }
-
-    /** Mapping without checking the cause (done in mapThrowable). */
-    protected Integer mapThrowableFlat(Throwable throwable) {
-        Class<? extends Throwable> throwableClass = throwable.getClass();
-        Integer resId = throwableToMsgIdMap.get(throwableClass);
-        if (resId == null) {
-            Class<? extends Throwable> closestClass = null;
-            Set<Entry<Class<? extends Throwable>, Integer>> mappings = throwableToMsgIdMap.entrySet();
-            for (Entry<Class<? extends Throwable>, Integer> mapping : mappings) {
-                Class<? extends Throwable> candidate = mapping.getKey();
-                if (candidate.isAssignableFrom(throwableClass)) {
-                    if (closestClass == null || closestClass.isAssignableFrom(candidate)) {
-                        closestClass = candidate;
-                        resId = mapping.getValue();
-                    }
-                }
-            }
-
-        }
-        return resId;
-    }
-
-    public ExceptionToResourceMapping addMapping(Class<? extends Throwable> clazz, int msgId) {
-        throwableToMsgIdMap.put(clazz, msgId);
-        return this;
-    }
-
-}
+package de.greenrobot.event.util;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+
+/**
+ * Maps throwables to texts for error dialogs. Use Config to configure the mapping.
+ * 
+ * @author Markus
+ */
+public class ExceptionToResourceMapping {
+
+    public final Map<Class<? extends Throwable>, Integer> throwableToMsgIdMap;
+
+    public ExceptionToResourceMapping() {
+        throwableToMsgIdMap = new HashMap<Class<? extends Throwable>, Integer>();
+    }
+
+    /** Looks at the exception and its causes trying to find an ID. */
+    public Integer mapThrowable(final Throwable throwable) {
+        Throwable throwableToCheck = throwable;
+        int depthToGo = 20;
+
+        while (true) {
+            Integer resId = mapThrowableFlat(throwableToCheck);
+            if (resId != null) {
+                return resId;
+            } else {
+                throwableToCheck = throwableToCheck.getCause();
+                depthToGo--;
+                if (depthToGo <= 0 || throwableToCheck == throwable || throwableToCheck == null) {
+                    Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
+                    // return config.defaultErrorMsgId;
+                    return null;
+                }
+            }
+        }
+
+    }
+
+    /** Mapping without checking the cause (done in mapThrowable). */
+    protected Integer mapThrowableFlat(Throwable throwable) {
+        Class<? extends Throwable> throwableClass = throwable.getClass();
+        Integer resId = throwableToMsgIdMap.get(throwableClass);
+        if (resId == null) {
+            Class<? extends Throwable> closestClass = null;
+            Set<Entry<Class<? extends Throwable>, Integer>> mappings = throwableToMsgIdMap.entrySet();
+            for (Entry<Class<? extends Throwable>, Integer> mapping : mappings) {
+                Class<? extends Throwable> candidate = mapping.getKey();
+                if (candidate.isAssignableFrom(throwableClass)) {
+                    if (closestClass == null || closestClass.isAssignableFrom(candidate)) {
+                        closestClass = candidate;
+                        resId = mapping.getValue();
+                    }
+                }
+            }
+
+        }
+        return resId;
+    }
+
+    public ExceptionToResourceMapping addMapping(Class<? extends Throwable> clazz, int msgId) {
+        throwableToMsgIdMap.put(clazz, msgId);
+        return this;
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/util/HasExecutionScope.java b/EventBus/src/de/greenrobot/event/util/HasExecutionScope.java
new file mode 100644
index 00000000..d759d2c2
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/util/HasExecutionScope.java
@@ -0,0 +1,8 @@
+package de.greenrobot.event.util;
+
+public interface HasExecutionScope {
+    Object getExecutionScope();
+
+    void setExecutionScope(Object executionScope);
+
+}
diff --git a/EventBus/src/de/greenrobot/event/util/ThrowableFailureEvent.java b/EventBus/src/de/greenrobot/event/util/ThrowableFailureEvent.java
index 09f0fbbd..7c6c07fa 100644
--- a/EventBus/src/de/greenrobot/event/util/ThrowableFailureEvent.java
+++ b/EventBus/src/de/greenrobot/event/util/ThrowableFailureEvent.java
@@ -1,48 +1,57 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.util;
-
-/**
- * A generic failure event, which can be used by apps to propagate thrown exceptions. Also used in conjunction with
- * {@link ErrorDialogManager}.
- */
-public class ThrowableFailureEvent {
-    protected final Throwable throwable;
-    protected final boolean suppressErrorUi;
-
-    public ThrowableFailureEvent(Throwable throwable) {
-        this.throwable = throwable;
-        suppressErrorUi = false;
-    }
-
-    /**
-     * @param suppressErrorUi
-     *            true indicates to the receiver that no error UI (e.g. dialog) should now displayed.
-     */
-    public ThrowableFailureEvent(Throwable throwable, boolean suppressErrorUi) {
-        this.throwable = throwable;
-        this.suppressErrorUi = suppressErrorUi;
-    }
-
-    public Throwable getThrowable() {
-        return throwable;
-    }
-
-    public boolean isSuppressErrorUi() {
-        return suppressErrorUi;
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.util;
+
+/**
+ * A generic failure event, which can be used by apps to propagate thrown exceptions. Also used in conjunction with
+ * {@link ErrorDialogManager}.
+ */
+public class ThrowableFailureEvent implements HasExecutionScope {
+    protected final Throwable throwable;
+    protected final boolean suppressErrorUi;
+    private Object executionContext;
+
+    public ThrowableFailureEvent(Throwable throwable) {
+        this.throwable = throwable;
+        suppressErrorUi = false;
+    }
+
+    /**
+     * @param suppressErrorUi
+     *            true indicates to the receiver that no error UI (e.g. dialog) should now displayed.
+     */
+    public ThrowableFailureEvent(Throwable throwable, boolean suppressErrorUi) {
+        this.throwable = throwable;
+        this.suppressErrorUi = suppressErrorUi;
+    }
+
+    public Throwable getThrowable() {
+        return throwable;
+    }
+
+    public boolean isSuppressErrorUi() {
+        return suppressErrorUi;
+    }
+
+    public Object getExecutionScope() {
+        return executionContext;
+    }
+
+    public void setExecutionScope(Object executionContext) {
+        this.executionContext = executionContext;
+    }
+    
+}
diff --git a/EventBusPerformance/.classpath b/EventBusPerformance/.classpath
index a4763d1e..7bc01d9a 100644
--- a/EventBusPerformance/.classpath
+++ b/EventBusPerformance/.classpath
@@ -3,6 +3,7 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/EventBusPerformance/AndroidManifest.xml b/EventBusPerformance/AndroidManifest.xml
index 91f7ec3b..4967dc56 100644
--- a/EventBusPerformance/AndroidManifest.xml
+++ b/EventBusPerformance/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="de.greenrobot.eventperf"
-    android:versionCode="2"
-    android:versionName="1.0.1" >
+    android:versionCode="3"
+    android:versionName="1.1.0" >
 
     <uses-sdk
         android:minSdkVersion="7"
@@ -27,7 +27,7 @@
         <activity
             android:name=".TestRunnerActivity"
             android:label="@string/app_name"
-            android:process="test.runner" >
+            android:process="de.greenrobot.eventperf.benchmark" >
         </activity>
     </application>
 
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
new file mode 100644
index 00000000..570c64b0
--- /dev/null
+++ b/EventBusPerformance/build.gradle
@@ -0,0 +1,35 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.1.0'
+    }
+}
+
+apply plugin: 'com.android.application'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    compile project(':EventBus')
+    compile 'com.squareup:otto:1.3.5'
+}
+
+android {
+    buildToolsVersion '21.1.2'
+    compileSdkVersion 19
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            res.srcDirs = ['res']
+        }
+
+    }
+
+}
diff --git a/EventBusPerformance/libs/android-support-v4.jar b/EventBusPerformance/libs/android-support-v4.jar
deleted file mode 100644
index feaf44f8..00000000
Binary files a/EventBusPerformance/libs/android-support-v4.jar and /dev/null differ
diff --git a/EventBusPerformance/libs/eventbus.jar b/EventBusPerformance/libs/eventbus.jar
deleted file mode 100644
index d633bf0c..00000000
Binary files a/EventBusPerformance/libs/eventbus.jar and /dev/null differ
diff --git a/EventBusPerformance/libs/square-otto-1.3.1.jar b/EventBusPerformance/libs/square-otto-1.3.1.jar
deleted file mode 100644
index 6d900ffe..00000000
Binary files a/EventBusPerformance/libs/square-otto-1.3.1.jar and /dev/null differ
diff --git a/EventBusPerformance/res/layout/activity_setuptests.xml b/EventBusPerformance/res/layout/activity_setuptests.xml
index 9c661657..da77afe6 100644
--- a/EventBusPerformance/res/layout/activity_setuptests.xml
+++ b/EventBusPerformance/res/layout/activity_setuptests.xml
@@ -1,125 +1,137 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/LinearLayout1"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:focusableInTouchMode="true"
-    android:orientation="vertical" >
-
-    <Spinner
-        android:id="@+id/spinnerTestToRun"
-        android:layout_width="fill_parent"
-        android:layout_height="wrap_content"
-        android:layout_margin="14dp"
-        android:entries="@array/spinnerTestsToRun" />
-
-    <ScrollView
-        android:id="@+id/scrollViewSettings"
-        android:layout_width="fill_parent"
-        android:layout_height="0dp"
-        android:layout_weight="1" >
-
-        <LinearLayout
-            android:id="@+id/LinearLayout2"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"
-            android:paddingLeft="16dp"
-            android:paddingRight="16dp" >
-
-            <CheckBox
-                android:id="@+id/checkBoxEventBus"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:checked="true"
-                android:onClick="checkEventBus"
-                android:text="@string/test_eventBus" />
-
-            <Spinner
-                android:id="@+id/spinnerThread"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:layout_margin="0dp"
-                android:entries="@array/spinnerThreadModes" />
-
-            <CheckBox
-                android:id="@+id/checkBoxOtto"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:checked="true"
-                android:text="@string/test_otto" />
-
-            <CheckBox
-                android:id="@+id/checkBoxBroadcast"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="@string/test_broadcast"
-                android:visibility="gone" />
-
-            <CheckBox
-                android:id="@+id/checkBoxLocalBroadcast"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_marginBottom="32dp"
-                android:text="@string/test_localBroadcast"
-                android:visibility="gone" />
-
-            <RelativeLayout
-                android:id="@+id/relativeLayoutForEvents"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent"
-                android:layout_marginBottom="18dp" >
-
-                <EditText
-                    android:id="@+id/editTextEvent"
-                    android:layout_width="90dp"
-                    android:layout_height="wrap_content"
-                    android:layout_alignParentRight="true"
-                    android:inputType="number"
-                    android:text="1000" />
-
-                <TextView
-                    android:id="@+id/eventView"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:layout_alignBaseline="@+id/editTextEvent"
-                    android:layout_alignParentLeft="true"
-                    android:layout_toLeftOf="@+id/editTextEvent"
-                    android:text="@string/eventViewText" />
-            </RelativeLayout>
-
-            <RelativeLayout
-                android:id="@+id/relativeLayoutForSubscribers"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent"
-                android:layout_marginBottom="8dp" >
-
-                <EditText
-                    android:id="@+id/editTextSubscribe"
-                    android:layout_width="90dp"
-                    android:layout_height="wrap_content"
-                    android:layout_alignParentRight="true"
-                    android:inputType="number"
-                    android:text="1" />
-
-                <TextView
-                    android:id="@+id/subscribe"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:layout_alignBaseline="@+id/editTextSubscribe"
-                    android:layout_alignParentLeft="true"
-                    android:layout_toLeftOf="@+id/editTextSubscribe"
-                    android:text="@string/subscriberViewText" />
-            </RelativeLayout>
-        </LinearLayout>
-    </ScrollView>
-
-    <Button
-        android:id="@+id/buttonStart"
-        android:layout_width="fill_parent"
-        android:layout_height="50dp"
-        android:layout_margin="16dp"
-        android:onClick="startClick"
-        android:text="@string/buttonStartText" />
-
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/LinearLayout1"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:focusableInTouchMode="true"
+    android:orientation="vertical" >
+
+    <Spinner
+        android:id="@+id/spinnerTestToRun"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="14dp"
+        android:entries="@array/spinnerTestsToRun" />
+
+    <ScrollView
+        android:id="@+id/scrollViewSettings"
+        android:layout_width="fill_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1" >
+
+        <LinearLayout
+            android:id="@+id/LinearLayout2"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:paddingLeft="16dp"
+            android:paddingRight="16dp" >
+
+            <CheckBox
+                android:id="@+id/checkBoxEventBus"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:onClick="checkEventBus"
+                android:text="@string/test_eventBus" />
+
+            <Spinner
+                android:id="@+id/spinnerThread"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="48dp"
+                android:entries="@array/spinnerThreadModes" />
+
+            <CheckBox
+                android:id="@+id/checkBoxEventBusEventHierarchy"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:onClick="checkEventBus"
+                android:layout_marginLeft="48dp"
+                android:text="@string/test_eventBusEventHierarchy" />
+
+            <CheckBox
+                android:id="@+id/checkBoxOtto"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:layout_marginTop="16dp"
+                android:text="@string/test_otto" />
+
+
+            <CheckBox
+                android:id="@+id/checkBoxBroadcast"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/test_broadcast"
+                android:visibility="gone" />
+
+
+            <CheckBox
+                android:id="@+id/checkBoxLocalBroadcast"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="32dp"
+                android:text="@string/test_localBroadcast"
+                android:visibility="gone" />
+
+            <RelativeLayout
+                android:id="@+id/relativeLayoutForEvents"
+                android:layout_width="fill_parent"
+                android:layout_height="fill_parent"
+                android:layout_marginBottom="18dp" >
+
+                <EditText
+                    android:id="@+id/editTextEvent"
+                    android:layout_width="90dp"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentRight="true"
+                    android:inputType="number"
+                    android:text="1000" />
+
+                <TextView
+                    android:id="@+id/eventView"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignBaseline="@+id/editTextEvent"
+                    android:layout_alignParentLeft="true"
+                    android:layout_toLeftOf="@+id/editTextEvent"
+                    android:text="@string/eventViewText" />
+            </RelativeLayout>
+
+            <RelativeLayout
+                android:id="@+id/relativeLayoutForSubscribers"
+                android:layout_width="fill_parent"
+                android:layout_height="fill_parent"
+                android:layout_marginBottom="8dp" >
+
+                <EditText
+                    android:id="@+id/editTextSubscribe"
+                    android:layout_width="90dp"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentRight="true"
+                    android:inputType="number"
+                    android:text="1" />
+
+                <TextView
+                    android:id="@+id/subscribe"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignBaseline="@+id/editTextSubscribe"
+                    android:layout_alignParentLeft="true"
+                    android:layout_toLeftOf="@+id/editTextSubscribe"
+                    android:text="@string/subscriberViewText" />
+            </RelativeLayout>
+        </LinearLayout>
+    </ScrollView>
+
+    <Button
+        android:id="@+id/buttonStart"
+        android:layout_width="fill_parent"
+        android:layout_height="50dp"
+        android:layout_margin="16dp"
+        android:onClick="startClick"
+        android:text="@string/buttonStartText" />
+
 </LinearLayout>
\ No newline at end of file
diff --git a/EventBusPerformance/res/values/strings.xml b/EventBusPerformance/res/values/strings.xml
index e590ea5e..bdb09805 100644
--- a/EventBusPerformance/res/values/strings.xml
+++ b/EventBusPerformance/res/values/strings.xml
@@ -3,6 +3,7 @@
 
     <string name="app_name">Event Performance</string>
     <string name="test_eventBus">EventBus</string>
+    <string name="test_eventBusEventHierarchy">Event Inheritance</string>
     <string name="test_otto">OttoBus</string>
     <string name="test_broadcast">Broadcast</string>
     <string name="test_localBroadcast">Local Broadcast</string>
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java b/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
index 2f2b8d93..1cebfec2 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
@@ -12,6 +12,7 @@
     private int subscriberCount;
     private int publisherCount;
     private ThreadMode threadMode;
+    private boolean eventInheritance;
     private int testNumber;
     private ArrayList<Class<? extends Test>> testClasses;
 
@@ -47,6 +48,14 @@ public void setThreadMode(ThreadMode threadMode) {
         this.threadMode = threadMode;
     }
 
+    public boolean isEventInheritance() {
+        return eventInheritance;
+    }
+
+    public void setEventInheritance(boolean eventInheritance) {
+        this.eventInheritance = eventInheritance;
+    }
+
     public ArrayList<Class<? extends Test>> getTestClasses() {
         return testClasses;
     }
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/TestSetupActivity.java b/EventBusPerformance/src/de/greenrobot/eventperf/TestSetupActivity.java
index 20332dd8..2b018b41 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/TestSetupActivity.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/TestSetupActivity.java
@@ -1,7 +1,5 @@
 package de.greenrobot.eventperf;
 
-import java.util.ArrayList;
-
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
@@ -11,21 +9,23 @@
 import android.widget.EditText;
 import android.widget.Spinner;
 import de.greenrobot.event.ThreadMode;
-import de.greenrobot.eventperf.testsubject.PerfTestOtto;
 import de.greenrobot.eventperf.testsubject.PerfTestEventBus;
+import de.greenrobot.eventperf.testsubject.PerfTestOtto;
+
+import java.util.ArrayList;
 
 public class TestSetupActivity extends Activity {
 
     @SuppressWarnings("rawtypes")
-    static final Class[] TEST_CLASSES_EVENTBUS = { PerfTestEventBus.Post.class,//
+    static final Class[] TEST_CLASSES_EVENTBUS = {PerfTestEventBus.Post.class,//
             PerfTestEventBus.RegisterOneByOne.class,//
             PerfTestEventBus.RegisterAll.class, //
-            PerfTestEventBus.RegisterFirstTime.class };
+            PerfTestEventBus.RegisterFirstTime.class};
 
-    static final Class[] TEST_CLASSES_OTTO = { PerfTestOtto.Post.class,//
+    static final Class[] TEST_CLASSES_OTTO = {PerfTestOtto.Post.class,//
             PerfTestOtto.RegisterOneByOne.class,//
             PerfTestOtto.RegisterAll.class, //
-            PerfTestOtto.RegisterFirstTime.class };
+            PerfTestOtto.RegisterFirstTime.class};
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -60,6 +60,8 @@ public void startClick(View v) {
         ThreadMode threadMode = ThreadMode.valueOf(threadModeStr);
         params.setThreadMode(threadMode);
 
+        params.setEventInheritance(((CheckBox) findViewById(R.id.checkBoxEventBusEventHierarchy)).isChecked());
+
         EditText editTextEvent = (EditText) findViewById(R.id.editTextEvent);
         params.setEventCount(Integer.parseInt(editTextEvent.getText().toString()));
 
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
index 54f0bb70..16920dc3 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
@@ -20,7 +20,7 @@
 
     public PerfTestEventBus(Context context, TestParams params) {
         super(context, params);
-        eventBus = new EventBus();
+        eventBus = EventBus.builder().eventInheritance(params.isEventInheritance()).build();
         subscribers = new ArrayList<Object>();
         eventCount = params.getEventCount();
         expectedEventCount = eventCount * params.getSubscriberCount();
@@ -42,16 +42,16 @@ public void prepareTest() {
 
     private Class<?> getSubscriberClassForThreadMode() {
         switch (params.getThreadMode()) {
-        case MainThread:
-            return SubscribeClassEventBusMain.class;
-        case BackgroundThread:
-            return SubscribeClassEventBusBackground.class;
-        case Async:
-            return SubscriberClassEventBusAsync.class;
-        case PostThread:
-            return SubscribeClassEventBusDefault.class;
-        default:
-            throw new RuntimeException("Unknown: " + params.getThreadMode());
+            case MainThread:
+                return SubscribeClassEventBusMain.class;
+            case BackgroundThread:
+                return SubscribeClassEventBusBackground.class;
+            case Async:
+                return SubscriberClassEventBusAsync.class;
+            case PostThread:
+                return SubscribeClassEventBusDefault.class;
+            default:
+                throw new RuntimeException("Unknown: " + params.getThreadMode());
         }
     }
 
@@ -67,9 +67,10 @@ public void prepareTest() {
         }
 
         public void runTest() {
+            TestEvent event = new TestEvent();
             long timeStart = System.nanoTime();
             for (int i = 0; i < super.eventCount; i++) {
-                super.eventBus.post(new TestEvent());
+                super.eventBus.post(event);
                 if (canceled) {
                     break;
                 }
@@ -88,7 +89,8 @@ public void runTest() {
 
         @Override
         public String getDisplayName() {
-            return "EventBus Post Events, " + params.getThreadMode();
+            String inheritance = params.isEventInheritance() ? ", event inheritance" : ", no event inheritance";
+            return "EventBus Post Events, " + params.getThreadMode() + inheritance;
         }
     }
 
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestOtto.java b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestOtto.java
index c61d2c7d..8e68adde 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestOtto.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestOtto.java
@@ -61,9 +61,10 @@ public void prepareTest() {
         }
 
         public void runTest() {
+            TestEvent event = new TestEvent();
             long timeStart = System.nanoTime();
             for (int i = 0; i < super.eventCount; i++) {
-                super.eventBus.post(new TestEvent());
+                super.eventBus.post(event);
                 if (canceled) {
                     break;
                 }
diff --git a/EventBusTest/.classpath b/EventBusTest/.classpath
index ebb402d1..2b16fe8e 100644
--- a/EventBusTest/.classpath
+++ b/EventBusTest/.classpath
@@ -1,9 +1,10 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/EventBus"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/EventBus"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/EventBusTest/.gitignore b/EventBusTest/.gitignore
deleted file mode 100644
index a02fbbe0..00000000
--- a/EventBusTest/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/gen
-/bin
diff --git a/EventBusTest/AndroidManifest.xml b/EventBusTest/AndroidManifest.xml
index 75fdd44a..9695813a 100644
--- a/EventBusTest/AndroidManifest.xml
+++ b/EventBusTest/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="de.greenrobot.event.test"
+    package="de.greenrobot.event.testapp"
     android:versionCode="1"
     android:versionName="1.0" >
 
@@ -12,7 +12,8 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application
-        android:label="@string/app_name" >
+        android:allowBackup="false"
+        android:label="EventBus Test" >
         <uses-library android:name="android.test.runner" />
     </application>
 
diff --git a/EventBusTest/build.gradle b/EventBusTest/build.gradle
new file mode 100644
index 00000000..2f48f9c5
--- /dev/null
+++ b/EventBusTest/build.gradle
@@ -0,0 +1,39 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.1.0'
+    }
+}
+
+apply plugin: 'com.android.application'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    androidTestCompile project(':EventBus')
+}
+
+android {
+    buildToolsVersion '21.1.2'
+    compileSdkVersion 19
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+        }
+
+        androidTest {
+            java.srcDirs = ['src']
+        }
+    }
+
+    defaultConfig {
+        testApplicationId "de.greenrobot.event.test"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+}
diff --git a/EventBusTest/res/values/strings.xml b/EventBusTest/res/values/strings.xml
deleted file mode 100644
index cb90cb81..00000000
--- a/EventBusTest/res/values/strings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">EventBus Test</string>
-
-</resources>
\ No newline at end of file
diff --git a/EventBusTest/src/de/greenrobot/event/test/AbstractEventBusTest.java b/EventBusTest/src/de/greenrobot/event/test/AbstractEventBusTest.java
index f5d25e5c..2d997620 100644
--- a/EventBusTest/src/de/greenrobot/event/test/AbstractEventBusTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/AbstractEventBusTest.java
@@ -1,117 +1,135 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import android.annotation.SuppressLint;
-import android.app.Application;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.test.ApplicationTestCase;
-import de.greenrobot.event.EventBus;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class AbstractEventBusTest extends ApplicationTestCase<Application> {
-
-    protected EventBus eventBus;
-
-    protected final AtomicInteger eventCount = new AtomicInteger();
-    protected final List<Object> eventsReceived;
-
-    protected volatile Object lastEvent;
-    protected volatile Thread lastThread;
-
-    private EventPostHandler mainPoster;
-
-    public AbstractEventBusTest() {
-        this(false);
-    }
-
-    public AbstractEventBusTest(boolean collectEventsReceived) {
-        super(Application.class);
-        if (collectEventsReceived) {
-            eventsReceived = new CopyOnWriteArrayList<Object>();
-        } else {
-            eventsReceived = null;
-        }
-    }
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        EventBus.clearCaches();
-        EventBus.clearSkipMethodNameVerifications();
-        eventBus = new EventBus();
-        mainPoster = new EventPostHandler(Looper.getMainLooper());
-        assertFalse(Looper.getMainLooper().getThread().equals(Thread.currentThread()));
-    }
-
-    protected void postInMainThread(Object event) {
-        mainPoster.post(event);
-    }
-
-    protected void waitForEventCount(int expectedCount, int maxMillis) throws InterruptedException {
-        for (int i = 0; i < maxMillis; i++) {
-            int currentCount = eventCount.get();
-            if (currentCount == expectedCount) {
-                break;
-            } else if (currentCount > expectedCount) {
-                fail("Current count (" + currentCount + ") is already higher than expected count (" + expectedCount
-                        + ")");
-            } else {
-                Thread.sleep(1);
-            }
-        }
-        assertEquals(expectedCount, eventCount.get());
-    }
-
-    protected void trackEvent(Object event) {
-        lastEvent = event;
-        lastThread = Thread.currentThread();
-        if (eventsReceived != null) {
-            eventsReceived.add(event);
-        }
-        // Must the the last one because we wait for this
-        eventCount.incrementAndGet();
-    }
-
-    @SuppressLint("HandlerLeak")
-    class EventPostHandler extends Handler {
-        public EventPostHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            eventBus.post(msg.obj);
-        }
-
-        void post(Object event) {
-            sendMessage(obtainMessage(0, event));
-        }
-
-    }
-    
-    protected void assertEventCount(int expectedEventCount) {
-        assertEquals(expectedEventCount, eventCount.intValue());
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import junit.framework.TestCase;
+import android.annotation.SuppressLint;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import de.greenrobot.event.EventBus;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class AbstractEventBusTest extends TestCase {
+    /** Activates long(er) running tests e.g. testing multi-threading more throughly.  */
+    protected static final boolean LONG_TESTS = false;
+
+    protected EventBus eventBus;
+
+    protected final AtomicInteger eventCount = new AtomicInteger();
+    protected final List<Object> eventsReceived;
+
+    protected volatile Object lastEvent;
+    protected volatile Thread lastThread;
+
+    private EventPostHandler mainPoster;
+
+    public AbstractEventBusTest() {
+        this(false);
+    }
+
+    public AbstractEventBusTest(boolean collectEventsReceived) {
+        if (collectEventsReceived) {
+            eventsReceived = new CopyOnWriteArrayList<Object>();
+        } else {
+            eventsReceived = null;
+        }
+    }
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        EventBus.clearCaches();
+        eventBus = new EventBus();
+        mainPoster = new EventPostHandler(Looper.getMainLooper());
+        assertFalse(Looper.getMainLooper().getThread().equals(Thread.currentThread()));
+    }
+
+    protected void postInMainThread(Object event) {
+        mainPoster.post(event);
+    }
+
+    protected void waitForEventCount(int expectedCount, int maxMillis) {
+        for (int i = 0; i < maxMillis; i++) {
+            int currentCount = eventCount.get();
+            if (currentCount == expectedCount) {
+                break;
+            } else if (currentCount > expectedCount) {
+                fail("Current count (" + currentCount + ") is already higher than expected count (" + expectedCount
+                        + ")");
+            } else {
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        assertEquals(expectedCount, eventCount.get());
+    }
+
+    protected void trackEvent(Object event) {
+        lastEvent = event;
+        lastThread = Thread.currentThread();
+        if (eventsReceived != null) {
+            eventsReceived.add(event);
+        }
+        // Must the the last one because we wait for this
+        eventCount.incrementAndGet();
+    }
+
+    @SuppressLint("HandlerLeak")
+    class EventPostHandler extends Handler {
+        public EventPostHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            eventBus.post(msg.obj);
+        }
+
+        void post(Object event) {
+            sendMessage(obtainMessage(0, event));
+        }
+
+    }
+    
+    protected void assertEventCount(int expectedEventCount) {
+        assertEquals(expectedEventCount, eventCount.intValue());
+    }
+    
+    protected void countDownAndAwaitLatch(CountDownLatch latch, long seconds) {
+        latch.countDown();
+        awaitLatch(latch, seconds);
+    }
+
+    protected void awaitLatch(CountDownLatch latch, long seconds) {
+        try {
+            assertTrue(latch.await(seconds, TimeUnit.SECONDS));
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
index 6d364c24..888b37d5 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
@@ -1,47 +1,47 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import android.os.Looper;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusBackgroundThreadTest extends AbstractEventBusTest {
-
-    public void testPostInCurrentThread() throws InterruptedException {
-        eventBus.register(this);
-        eventBus.post("Hello");
-        waitForEventCount(1, 1000);
-
-        assertEquals("Hello", lastEvent);
-        assertEquals(Thread.currentThread(), lastThread);
-    }
-
-    public void testPostFromMain() throws InterruptedException {
-        eventBus.register(this, "onEvent");
-        postInMainThread("Hello");
-        waitForEventCount(1, 1000);
-        assertEquals("Hello", lastEvent);
-        assertFalse(lastThread.equals(Thread.currentThread()));
-        assertFalse(lastThread.equals(Looper.getMainLooper().getThread()));
-    }
-
-    public void onEventBackgroundThread(String event) {
-        trackEvent(event);
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import android.os.Looper;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusBackgroundThreadTest extends AbstractEventBusTest {
+
+    public void testPostInCurrentThread() throws InterruptedException {
+        eventBus.register(this);
+        eventBus.post("Hello");
+        waitForEventCount(1, 1000);
+
+        assertEquals("Hello", lastEvent);
+        assertEquals(Thread.currentThread(), lastThread);
+    }
+
+    public void testPostFromMain() throws InterruptedException {
+        eventBus.register(this);
+        postInMainThread("Hello");
+        waitForEventCount(1, 1000);
+        assertEquals("Hello", lastEvent);
+        assertFalse(lastThread.equals(Thread.currentThread()));
+        assertFalse(lastThread.equals(Looper.getMainLooper().getThread()));
+    }
+
+    public void onEventBackgroundThread(String event) {
+        trackEvent(event);
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
index 6f1d7f67..c34feb38 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
@@ -1,267 +1,266 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import java.lang.ref.WeakReference;
-
-import junit.framework.TestCase;
-import android.app.Activity;
-import android.util.Log;
-import de.greenrobot.event.EventBus;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusBasicTest extends TestCase {
-
-    private EventBus eventBus;
-    private String lastStringEvent;
-    private int countStringEvent;
-    private int countIntEvent;
-    private int lastIntEvent;
-    private int countMyEventExtended;
-    private int countMyEvent;
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        eventBus = new EventBus();
-    }
-
-    public void testRegisterForEventTypeAndPost() {
-        // Use an activity to test real life performance
-        TestActivity testActivity = new TestActivity();
-        String event = "Hello";
-
-        long start = System.currentTimeMillis();
-        eventBus.register(testActivity, String.class);
-        long time = System.currentTimeMillis() - start;
-        Log.d(EventBus.TAG, "Registered for event class in " + time + "ms");
-
-        eventBus.post(event);
-
-        assertEquals(event, testActivity.lastStringEvent);
-    }
-
-    public void testRegisterAndPost() {
-        // Use an activity to test real life performance
-        TestActivity testActivity = new TestActivity();
-        String event = "Hello";
-
-        long start = System.currentTimeMillis();
-        eventBus.register(testActivity);
-        long time = System.currentTimeMillis() - start;
-        Log.d(EventBus.TAG, "Registered in " + time + "ms");
-
-        eventBus.post(event);
-
-        assertEquals(event, testActivity.lastStringEvent);
-    }
-
-    public void testPostWithoutSubscriber() {
-        eventBus.post("Hello");
-    }
-
-    public void testUnregisterWithoutRegister() {
-        // Results in a warning without throwing
-        eventBus.unregister(this);
-        eventBus.unregister(this, String.class);
-    }
-
-    public void testUnregisterNotLeaking() {
-        EventBusBasicTest subscriber = new EventBusBasicTest();
-        eventBus.register(subscriber);
-        eventBus.unregister(subscriber);
-
-        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);
-        subscriber = null;
-        assertSubscriberNotReferenced(ref);
-    }
-
-    public void testUnregisterForClassNotLeaking() {
-        EventBusBasicTest subscriber = new EventBusBasicTest();
-        eventBus.register(subscriber, String.class);
-        eventBus.unregister(subscriber, String.class);
-
-        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);
-        subscriber = null;
-        assertSubscriberNotReferenced(ref);
-    }
-
-    private void assertSubscriberNotReferenced(WeakReference<EventBusBasicTest> ref) {
-        EventBusBasicTest subscriberTest = new EventBusBasicTest();
-        WeakReference<EventBusBasicTest> refTest = new WeakReference<EventBusBasicTest>(subscriberTest);
-        subscriberTest = null;
-
-        // Yeah, in theory is is questionable (in practice just fine so far...)
-        System.gc();
-
-        assertNull(refTest.get());
-        assertNull(ref.get());
-    }
-
-    public void testRegisterTwice() {
-        eventBus.register(this, String.class);
-        try {
-            eventBus.register(this, String.class);
-            fail("Did not throw");
-        } catch (RuntimeException expected) {
-            // OK
-        }
-    }
-
-    public void testPostWithTwoSubscriber() {
-        EventBusBasicTest test2 = new EventBusBasicTest();
-        eventBus.register(this, String.class);
-        eventBus.register(test2, String.class);
-        String event = "Hello";
-        eventBus.post(event);
-        assertEquals(event, lastStringEvent);
-        assertEquals(event, test2.lastStringEvent);
-    }
-
-    public void testPostMultipleTimes() {
-        eventBus.register(this, MyEvent.class);
-        MyEvent event = new MyEvent();
-        int count = 1000;
-        long start = System.currentTimeMillis();
-        // Debug.startMethodTracing("testPostMultipleTimes" + count);
-        for (int i = 0; i < count; i++) {
-            eventBus.post(event);
-        }
-        // Debug.stopMethodTracing();
-        long time = System.currentTimeMillis() - start;
-        Log.d(EventBus.TAG, "Posted " + count + " events in " + time + "ms");
-        assertEquals(count, countMyEvent);
-    }
-
-    public void testPostAfterUnregister() {
-        eventBus.register(this, String.class);
-        eventBus.unregister(this, String.class);
-        eventBus.post("Hello");
-        assertNull(lastStringEvent);
-    }
-
-    public void testPostAfterUnregisterForAllEventClasses() {
-        eventBus.register(this, String.class);
-        eventBus.unregister(this);
-        eventBus.post("Hello");
-        assertNull(lastStringEvent);
-    }
-
-    public void testRegisterForOtherTypeThanPosted() {
-        eventBus.register(this, String.class);
-        eventBus.post(42);
-        assertEquals(0, countIntEvent);
-    }
-
-    public void testRegisterAndPostTwoTypes() {
-        eventBus.register(this);
-        eventBus.post(42);
-        eventBus.post("Hello");
-        assertEquals(1, countIntEvent);
-        assertEquals(1, countStringEvent);
-        assertEquals(42, lastIntEvent);
-        assertEquals("Hello", lastStringEvent);
-    }
-
-    public void testRegisterAndPostTwoTypesExplicit() {
-        eventBus.register(this, String.class, Integer.class);
-        eventBus.post(42);
-        eventBus.post("Hello");
-        assertEquals(1, countIntEvent);
-        assertEquals(1, countStringEvent);
-        assertEquals(42, lastIntEvent);
-        assertEquals("Hello", lastStringEvent);
-    }
-
-    public void testRegisterUnregisterAndPostTwoTypes() {
-        eventBus.register(this);
-        eventBus.unregister(this, String.class);
-        eventBus.post(42);
-        eventBus.post("Hello");
-        assertEquals(1, countIntEvent);
-        assertEquals(42, lastIntEvent);
-        assertEquals(0, countStringEvent);
-    }
-
-    public void testPostOnDifferentEventBus() {
-        eventBus.register(this);
-        new EventBus().post("Hello");
-        assertEquals(0, countStringEvent);
-    }
-
-    public void testPostInEventHandler() {
-        RepostInteger reposter = new RepostInteger();
-        eventBus.register(reposter);
-        eventBus.register(this);
-        eventBus.post(1);
-        assertEquals(10, countIntEvent);
-        assertEquals(10, lastIntEvent);
-        assertEquals(10, reposter.countEvent);
-        assertEquals(10, reposter.lastEvent);
-    }
-
-    public void onEvent(String event) {
-        lastStringEvent = event;
-        countStringEvent++;
-    }
-
-    public void onEvent(Integer event) {
-        lastIntEvent = event;
-        countIntEvent++;
-    }
-
-    public void onEvent(MyEvent event) {
-        countMyEvent++;
-    }
-
-    public void onEvent(MyEventExtended event) {
-        countMyEventExtended++;
-    }
-
-    static class TestActivity extends Activity {
-        public String lastStringEvent;
-
-        public void onEvent(String event) {
-            lastStringEvent = event;
-        }
-    }
-
-    class MyEvent {
-    }
-
-    class MyEventExtended extends MyEvent {
-    }
-
-    class RepostInteger {
-        public int lastEvent;
-        public int countEvent;
-
-        public void onEvent(Integer event) {
-            lastEvent = event;
-            countEvent++;
-            assertEquals(countEvent, event.intValue());
-
-            if (event < 10) {
-                int countIntEventBefore = countEvent;
-                eventBus.post(event + 1);
-                // All our post calls will just enqueue the event, so check count is unchanged
-                assertEquals(countIntEventBefore, countIntEventBefore);
-            }
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import android.app.Activity;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+import junit.framework.TestCase;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusBasicTest extends TestCase {
+
+    private EventBus eventBus;
+    private String lastStringEvent;
+    private int countStringEvent;
+    private int countIntEvent;
+    private int lastIntEvent;
+    private int countMyEventExtended;
+    private int countMyEvent;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        eventBus = new EventBus();
+    }
+
+    public void testRegisterAndPost() {
+        // Use an activity to test real life performance
+        TestActivity testActivity = new TestActivity();
+        String event = "Hello";
+
+        long start = System.currentTimeMillis();
+        eventBus.register(testActivity);
+        long time = System.currentTimeMillis() - start;
+        Log.d(EventBus.TAG, "Registered in " + time + "ms");
+
+        eventBus.post(event);
+
+        assertEquals(event, testActivity.lastStringEvent);
+    }
+
+    public void testPostWithoutSubscriber() {
+        eventBus.post("Hello");
+    }
+
+    public void testUnregisterWithoutRegister() {
+        // Results in a warning without throwing
+        eventBus.unregister(this);
+    }
+
+    public void testUnregisterNotLeaking() {
+        EventBusBasicTest subscriber = new EventBusBasicTest();
+        eventBus.register(subscriber);
+        eventBus.unregister(subscriber);
+
+        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);
+        subscriber = null;
+        assertSubscriberNotReferenced(ref);
+    }
+
+    private void assertSubscriberNotReferenced(WeakReference<EventBusBasicTest> ref) {
+        EventBusBasicTest subscriberTest = new EventBusBasicTest();
+        WeakReference<EventBusBasicTest> refTest = new WeakReference<EventBusBasicTest>(subscriberTest);
+        subscriberTest = null;
+
+        // Yeah, in theory is is questionable (in practice just fine so far...)
+        System.gc();
+
+        assertNull(refTest.get());
+        assertNull(ref.get());
+    }
+
+    public void testRegisterTwice() {
+        eventBus.register(this);
+        try {
+            eventBus.register(this);
+            fail("Did not throw");
+        } catch (RuntimeException expected) {
+            // OK
+        }
+    }
+
+    public void testIsRegistered() {
+        assertFalse(eventBus.isRegistered(this));
+        eventBus.register(this);
+        assertTrue(eventBus.isRegistered(this));
+        eventBus.unregister(this);
+        assertFalse(eventBus.isRegistered(this));
+    }
+
+    public void testPostWithTwoSubscriber() {
+        EventBusBasicTest test2 = new EventBusBasicTest();
+        eventBus.register(this);
+        eventBus.register(test2);
+        String event = "Hello";
+        eventBus.post(event);
+        assertEquals(event, lastStringEvent);
+        assertEquals(event, test2.lastStringEvent);
+    }
+
+    public void testPostMultipleTimes() {
+        eventBus.register(this);
+        MyEvent event = new MyEvent();
+        int count = 1000;
+        long start = System.currentTimeMillis();
+        // Debug.startMethodTracing("testPostMultipleTimes" + count);
+        for (int i = 0; i < count; i++) {
+            eventBus.post(event);
+        }
+        // Debug.stopMethodTracing();
+        long time = System.currentTimeMillis() - start;
+        Log.d(EventBus.TAG, "Posted " + count + " events in " + time + "ms");
+        assertEquals(count, countMyEvent);
+    }
+
+    public void testPostAfterUnregister() {
+        eventBus.register(this);
+        eventBus.unregister(this);
+        eventBus.post("Hello");
+        assertNull(lastStringEvent);
+    }
+
+    public void testRegisterAndPostTwoTypes() {
+        eventBus.register(this);
+        eventBus.post(42);
+        eventBus.post("Hello");
+        assertEquals(1, countIntEvent);
+        assertEquals(1, countStringEvent);
+        assertEquals(42, lastIntEvent);
+        assertEquals("Hello", lastStringEvent);
+    }
+
+    public void testRegisterUnregisterAndPostTwoTypes() {
+        eventBus.register(this);
+        eventBus.unregister(this);
+        eventBus.post(42);
+        eventBus.post("Hello");
+        assertEquals(0, countIntEvent);
+        assertEquals(0, lastIntEvent);
+        assertEquals(0, countStringEvent);
+    }
+
+    public void testPostOnDifferentEventBus() {
+        eventBus.register(this);
+        new EventBus().post("Hello");
+        assertEquals(0, countStringEvent);
+    }
+
+    public void testPostInEventHandler() {
+        RepostInteger reposter = new RepostInteger();
+        eventBus.register(reposter);
+        eventBus.register(this);
+        eventBus.post(1);
+        assertEquals(10, countIntEvent);
+        assertEquals(10, lastIntEvent);
+        assertEquals(10, reposter.countEvent);
+        assertEquals(10, reposter.lastEvent);
+    }
+
+    public void testHasSubscriberForEvent() {
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+
+        eventBus.register(this);
+        assertTrue(eventBus.hasSubscriberForEvent(String.class));
+
+        eventBus.unregister(this);
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+    }
+
+    public void testHasSubscriberForEventSuperclass() {
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+
+        Object subscriber = new Object() {
+            public void onEvent(Object event) {
+            }
+        };
+        eventBus.register(subscriber);
+        assertTrue(eventBus.hasSubscriberForEvent(String.class));
+
+        eventBus.unregister(subscriber);
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+    }
+
+    public void testHasSubscriberForEventImplementedInterface() {
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+
+        Object subscriber = new Object() {
+            public void onEvent(CharSequence event) {
+            }
+        };
+        eventBus.register(subscriber);
+        assertTrue(eventBus.hasSubscriberForEvent(CharSequence.class));
+        assertTrue(eventBus.hasSubscriberForEvent(String.class));
+
+        eventBus.unregister(subscriber);
+        assertFalse(eventBus.hasSubscriberForEvent(CharSequence.class));
+        assertFalse(eventBus.hasSubscriberForEvent(String.class));
+    }
+
+    public void onEvent(String event) {
+        lastStringEvent = event;
+        countStringEvent++;
+    }
+
+    public void onEvent(Integer event) {
+        lastIntEvent = event;
+        countIntEvent++;
+    }
+
+    public void onEvent(MyEvent event) {
+        countMyEvent++;
+    }
+
+    public void onEvent(MyEventExtended event) {
+        countMyEventExtended++;
+    }
+
+    static class TestActivity extends Activity {
+        public String lastStringEvent;
+
+        public void onEvent(String event) {
+            lastStringEvent = event;
+        }
+    }
+
+    class MyEvent {
+    }
+
+    class MyEventExtended extends MyEvent {
+    }
+
+    class RepostInteger {
+        public int lastEvent;
+        public int countEvent;
+
+        public void onEvent(Integer event) {
+            lastEvent = event;
+            countEvent++;
+            assertEquals(countEvent, event.intValue());
+
+            if (event < 10) {
+                int countIntEventBefore = countEvent;
+                eventBus.post(event + 1);
+                // All our post calls will just enqueue the event, so check count is unchanged
+                assertEquals(countIntEventBefore, countIntEventBefore);
+            }
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java
new file mode 100644
index 00000000..58b6bc8d
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import de.greenrobot.event.EventBus;
+import de.greenrobot.event.EventBusBuilder;
+import de.greenrobot.event.EventBusException;
+import de.greenrobot.event.NoSubscriberEvent;
+import de.greenrobot.event.SubscriberExceptionEvent;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusBuilderTest extends AbstractEventBusTest {
+
+    public void testThrowSubscriberException() {
+        eventBus = EventBus.builder().throwSubscriberException(true).build();
+        eventBus.register(new SubscriberExceptionEventTracker());
+        eventBus.register(new ThrowingSubscriber());
+        try {
+            eventBus.post("Foo");
+            fail("Should have thrown");
+        } catch (EventBusException e) {
+            // Expected
+        }
+    }
+
+    public void testDoNotSendSubscriberExceptionEvent() {
+        eventBus = EventBus.builder().logSubscriberExceptions(false).sendSubscriberExceptionEvent(false).build();
+        eventBus.register(new SubscriberExceptionEventTracker());
+        eventBus.register(new ThrowingSubscriber());
+        eventBus.post("Foo");
+        assertEventCount(0);
+    }
+
+    public void testDoNotSendNoSubscriberEvent() {
+        eventBus = EventBus.builder().logNoSubscriberMessages(false).sendNoSubscriberEvent(false).build();
+        eventBus.register(new NoSubscriberEventTracker());
+        eventBus.post("Foo");
+        assertEventCount(0);
+    }
+
+    public void testInstallDefaultEventBus() {
+        EventBusBuilder builder = EventBus.builder();
+        try {
+            // Either this should throw when another unit test got the default event bus...
+            eventBus = builder.installDefaultEventBus();
+            assertEquals(eventBus, EventBus.getDefault());
+
+            // ...or this should throw
+            eventBus = builder.installDefaultEventBus();
+            fail("Should have thrown");
+        } catch (EventBusException e) {
+            // Expected
+        }
+    }
+
+    public void testEventInheritance() {
+        eventBus = EventBus.builder().eventInheritance(false).build();
+        eventBus.register(new ThrowingSubscriber());
+        eventBus.post("Foo");
+    }
+
+    class SubscriberExceptionEventTracker {
+        public void onEvent(SubscriberExceptionEvent event) {
+            trackEvent(event);
+        }
+    }
+
+    class NoSubscriberEventTracker {
+        public void onEvent(NoSubscriberEvent event) {
+            trackEvent(event);
+        }
+    }
+
+    class ThrowingSubscriber {
+        public void onEvent(Object event) {
+            throw new RuntimeException();
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java
new file mode 100644
index 00000000..027d74f9
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.concurrent.CountDownLatch;
+
+import android.test.UiThreadTest;
+import de.greenrobot.event.EventBusException;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusCancelEventDeliveryTest extends AbstractEventBusTest {
+
+    private Throwable failed;
+
+    public void testCancel() {
+        Subscriber canceler = new Subscriber(true);
+        eventBus.register(new Subscriber(false));
+        eventBus.register(canceler, 1);
+        eventBus.register(new Subscriber(false));
+        eventBus.post("42");
+        assertEquals(1, eventCount.intValue());
+
+        eventBus.unregister(canceler);
+        eventBus.post("42");
+        assertEquals(1 + 2, eventCount.intValue());
+    }
+
+    public void testCancelInBetween() {
+        Subscriber canceler = new Subscriber(true);
+        eventBus.register(canceler, 2);
+        eventBus.register(new Subscriber(false), 1);
+        eventBus.register(new Subscriber(false), 3);
+        eventBus.post("42");
+        assertEquals(2, eventCount.intValue());
+    }
+
+    public void testCancelOutsideEventHandler() {
+        try {
+            eventBus.cancelEventDelivery(this);
+            fail("Should have thrown");
+        } catch (EventBusException e) {
+            // Expected
+        }
+    }
+
+    public void testCancelWrongEvent() {
+        eventBus.register(new SubscriberCancelOtherEvent());
+        eventBus.post("42");
+        assertEquals(0, eventCount.intValue());
+        assertNotNull(failed);
+    }
+
+    @UiThreadTest
+    public void testCancelInMainThread() {
+        SubscriberMainThread subscriber = new SubscriberMainThread();
+        eventBus.register(subscriber);
+        eventBus.post("42");
+        awaitLatch(subscriber.done, 10);
+        assertEquals(0, eventCount.intValue());
+        assertNotNull(failed);
+    }
+
+    class Subscriber {
+        private final boolean cancel;
+
+        public Subscriber(boolean cancel) {
+            this.cancel = cancel;
+        }
+
+        public void onEvent(String event) {
+            trackEvent(event);
+            if (cancel) {
+                eventBus.cancelEventDelivery(event);
+            }
+        }
+    }
+
+    class SubscriberCancelOtherEvent {
+        public void onEvent(String event) {
+            try {
+                eventBus.cancelEventDelivery(this);
+            } catch (EventBusException e) {
+                failed = e;
+            }
+        }
+    }
+
+    class SubscriberMainThread {
+        final CountDownLatch done = new CountDownLatch(1);
+
+        public void onEventMainThread(String event) {
+            try {
+                eventBus.cancelEventDelivery(event);
+            } catch (EventBusException e) {
+                failed = e;
+            }
+            done.countDown();
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java
new file mode 100644
index 00000000..43aaf467
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import de.greenrobot.event.EventBus;
+import junit.framework.TestCase;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusInheritanceDisabledTest extends TestCase {
+
+    private EventBus eventBus;
+
+    protected int countMyEventExtended;
+    protected int countMyEvent;
+    protected int countObjectEvent;
+    private int countMyEventInterface;
+    private int countMyEventInterfaceExtended;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        eventBus = EventBus.builder().eventInheritance(false).build();
+    }
+
+    public void testEventClassHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post("Hello");
+        assertEquals(0, countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(0, countObjectEvent);
+        assertEquals(1, countMyEvent);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(0, countObjectEvent);
+        assertEquals(1, countMyEvent);
+        assertEquals(1, countMyEventExtended);
+    }
+
+    public void testEventClassHierarchySticky() {
+        eventBus.postSticky("Hello");
+        eventBus.postSticky(new MyEvent());
+        eventBus.postSticky(new MyEventExtended());
+        eventBus.registerSticky(this);
+        assertEquals(1, countMyEventExtended);
+        assertEquals(1, countMyEvent);
+        assertEquals(0, countObjectEvent);
+    }
+
+    public void testEventInterfaceHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post(new MyEvent());
+        assertEquals(0, countMyEventInterface);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(0, countMyEventInterface);
+        assertEquals(0, countMyEventInterfaceExtended);
+    }
+
+    public void testEventSuperInterfaceHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post(new MyEventInterfaceExtended() {
+        });
+        assertEquals(0, countMyEventInterface);
+        assertEquals(0, countMyEventInterfaceExtended);
+    }
+
+    public void testSubscriberClassHierarchy() {
+        SubscriberExtended subscriber = new SubscriberExtended();
+        eventBus.register(subscriber);
+
+        eventBus.post("Hello");
+        assertEquals(0, subscriber.countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(0, subscriber.countObjectEvent);
+        assertEquals(0, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventOverwritten);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(0, subscriber.countObjectEvent);
+        assertEquals(0, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventExtended);
+        assertEquals(1, subscriber.countMyEventOverwritten);
+    }
+
+    public void testSubscriberClassHierarchyWithoutNewSubscriberMethod() {
+        SubscriberExtendedWithoutNewSubscriberMethod subscriber = new SubscriberExtendedWithoutNewSubscriberMethod();
+        eventBus.register(subscriber);
+
+        eventBus.post("Hello");
+        assertEquals(0, subscriber.countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(0, subscriber.countObjectEvent);
+        assertEquals(1, subscriber.countMyEvent);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(0, subscriber.countObjectEvent);
+        assertEquals(1, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventExtended);
+    }
+
+    public void onEvent(Object event) {
+        countObjectEvent++;
+    }
+
+    public void onEvent(MyEvent event) {
+        countMyEvent++;
+    }
+
+    public void onEvent(MyEventExtended event) {
+        countMyEventExtended++;
+    }
+
+    public void onEvent(MyEventInterface event) {
+        countMyEventInterface++;
+    }
+
+    public void onEvent(MyEventInterfaceExtended event) {
+        countMyEventInterfaceExtended++;
+    }
+
+    static interface MyEventInterface {
+    }
+
+    static class MyEvent implements MyEventInterface {
+    }
+
+    static interface MyEventInterfaceExtended extends MyEventInterface {
+    }
+
+    static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
+    }
+
+    static class SubscriberExtended extends EventBusInheritanceDisabledTest {
+        private int countMyEventOverwritten;
+
+        public void onEvent(MyEvent event) {
+            countMyEventOverwritten++;
+        }
+    }
+
+    static class SubscriberExtendedWithoutNewSubscriberMethod extends EventBusInheritanceDisabledTest {
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
index 94096eb9..10384951 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
@@ -1,134 +1,164 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import junit.framework.TestCase;
-import de.greenrobot.event.EventBus;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusInheritanceTest extends TestCase {
-
-    private EventBus eventBus;
-
-    protected int countMyEventExtended;
-    protected int countMyEvent;
-    protected int countObjectEvent;
-    private int countMyEventInterface;
-    private int countMyEventInterfaceExtended;
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        eventBus = new EventBus();
-    }
-
-    public void testEventClassHierarchy() {
-        eventBus.register(this);
-
-        eventBus.post("Hello");
-        assertEquals(1, countObjectEvent);
-
-        eventBus.post(new MyEvent());
-        assertEquals(2, countObjectEvent);
-        assertEquals(1, countMyEvent);
-
-        eventBus.post(new MyEventExtended());
-        assertEquals(3, countObjectEvent);
-        assertEquals(2, countMyEvent);
-        assertEquals(1, countMyEventExtended);
-    }
-
-    public void testEventInterfaceHierarchy() {
-        eventBus.register(this);
-
-        eventBus.post(new MyEvent());
-        assertEquals(1, countMyEventInterface);
-
-        eventBus.post(new MyEventExtended());
-        assertEquals(2, countMyEventInterface);
-        assertEquals(1, countMyEventInterfaceExtended);
-    }
-
-    public void testEventSuperInterfaceHierarchy() {
-        eventBus.register(this);
-
-        eventBus.post(new MyEventInterfaceExtended() {
-        });
-        assertEquals(1, countMyEventInterface);
-        assertEquals(1, countMyEventInterfaceExtended);
-    }
-
-    public void testSubscriberClassHierarchy() {
-        SubscriberExtended subscriber = new SubscriberExtended();
-        eventBus.register(subscriber);
-
-        eventBus.post("Hello");
-        assertEquals(1, subscriber.countObjectEvent);
-
-        eventBus.post(new MyEvent());
-        assertEquals(2, subscriber.countObjectEvent);
-        assertEquals(0, subscriber.countMyEvent);
-        assertEquals(1, subscriber.countMyEventOverwritten);
-
-        eventBus.post(new MyEventExtended());
-        assertEquals(3, subscriber.countObjectEvent);
-        assertEquals(0, subscriber.countMyEvent);
-        assertEquals(1, subscriber.countMyEventExtended);
-        assertEquals(2, subscriber.countMyEventOverwritten);
-    }
-
-    public void onEvent(Object event) {
-        countObjectEvent++;
-    }
-
-    public void onEvent(MyEvent event) {
-        countMyEvent++;
-    }
-
-    public void onEvent(MyEventExtended event) {
-        countMyEventExtended++;
-    }
-
-    public void onEvent(MyEventInterface event) {
-        countMyEventInterface++;
-    }
-
-    public void onEvent(MyEventInterfaceExtended event) {
-        countMyEventInterfaceExtended++;
-    }
-
-    static interface MyEventInterface {
-    }
-
-    static class MyEvent implements MyEventInterface {
-    }
-
-    static interface MyEventInterfaceExtended extends MyEventInterface {
-    }
-
-    static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
-    }
-
-    static class SubscriberExtended extends EventBusInheritanceTest {
-        private int countMyEventOverwritten;
-
-        public void onEvent(MyEvent event) {
-            countMyEventOverwritten++;
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import junit.framework.TestCase;
+import de.greenrobot.event.EventBus;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusInheritanceTest extends TestCase {
+
+    private EventBus eventBus;
+
+    protected int countMyEventExtended;
+    protected int countMyEvent;
+    protected int countObjectEvent;
+    private int countMyEventInterface;
+    private int countMyEventInterfaceExtended;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        eventBus = new EventBus();
+    }
+
+    public void testEventClassHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post("Hello");
+        assertEquals(1, countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(2, countObjectEvent);
+        assertEquals(1, countMyEvent);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(3, countObjectEvent);
+        assertEquals(2, countMyEvent);
+        assertEquals(1, countMyEventExtended);
+    }
+
+    public void testEventClassHierarchySticky() {
+        eventBus.postSticky("Hello");
+        eventBus.postSticky(new MyEvent());
+        eventBus.postSticky(new MyEventExtended());
+        eventBus.registerSticky(this);
+        assertEquals(1, countMyEventExtended);
+        assertEquals(2, countMyEvent);
+        assertEquals(3, countObjectEvent);
+    }
+
+    public void testEventInterfaceHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post(new MyEvent());
+        assertEquals(1, countMyEventInterface);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(2, countMyEventInterface);
+        assertEquals(1, countMyEventInterfaceExtended);
+    }
+
+    public void testEventSuperInterfaceHierarchy() {
+        eventBus.register(this);
+
+        eventBus.post(new MyEventInterfaceExtended() {
+        });
+        assertEquals(1, countMyEventInterface);
+        assertEquals(1, countMyEventInterfaceExtended);
+    }
+
+    public void testSubscriberClassHierarchy() {
+        SubscriberExtended subscriber = new SubscriberExtended();
+        eventBus.register(subscriber);
+
+        eventBus.post("Hello");
+        assertEquals(1, subscriber.countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(2, subscriber.countObjectEvent);
+        assertEquals(0, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventOverwritten);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(3, subscriber.countObjectEvent);
+        assertEquals(0, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventExtended);
+        assertEquals(2, subscriber.countMyEventOverwritten);
+    }
+
+    public void testSubscriberClassHierarchyWithoutNewSubscriberMethod() {
+        SubscriberExtendedWithoutNewSubscriberMethod subscriber = new SubscriberExtendedWithoutNewSubscriberMethod();
+        eventBus.register(subscriber);
+
+        eventBus.post("Hello");
+        assertEquals(1, subscriber.countObjectEvent);
+
+        eventBus.post(new MyEvent());
+        assertEquals(2, subscriber.countObjectEvent);
+        assertEquals(1, subscriber.countMyEvent);
+
+        eventBus.post(new MyEventExtended());
+        assertEquals(3, subscriber.countObjectEvent);
+        assertEquals(2, subscriber.countMyEvent);
+        assertEquals(1, subscriber.countMyEventExtended);
+    }
+
+    public void onEvent(Object event) {
+        countObjectEvent++;
+    }
+
+    public void onEvent(MyEvent event) {
+        countMyEvent++;
+    }
+
+    public void onEvent(MyEventExtended event) {
+        countMyEventExtended++;
+    }
+
+    public void onEvent(MyEventInterface event) {
+        countMyEventInterface++;
+    }
+
+    public void onEvent(MyEventInterfaceExtended event) {
+        countMyEventInterfaceExtended++;
+    }
+
+    static interface MyEventInterface {
+    }
+
+    static class MyEvent implements MyEventInterface {
+    }
+
+    static interface MyEventInterfaceExtended extends MyEventInterface {
+    }
+
+    static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
+    }
+
+    static class SubscriberExtended extends EventBusInheritanceTest {
+        private int countMyEventOverwritten;
+
+        public void onEvent(MyEvent event) {
+            countMyEventOverwritten++;
+        }
+    }
+
+    static class SubscriberExtendedWithoutNewSubscriberMethod extends EventBusInheritanceTest {
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java
new file mode 100644
index 00000000..0b3ac3a8
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+
+import android.os.Handler;
+import android.os.Looper;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusMainThreadRacingTest extends AbstractEventBusTest {
+
+    private static final int ITERATIONS = LONG_TESTS ? 100000 : 1000;
+
+    protected boolean unregistered;
+    private CountDownLatch startLatch;
+    private volatile RuntimeException failed;
+
+    public void testRacingThreads() throws InterruptedException {
+        Runnable register = new Runnable() {
+            @Override
+            public void run() {
+                eventBus.register(EventBusMainThreadRacingTest.this);
+                unregistered = false;
+            }
+        };
+
+        Runnable unregister = new Runnable() {
+            @Override
+            public void run() {
+                eventBus.unregister(EventBusMainThreadRacingTest.this);
+                unregistered = true;
+            }
+        };
+
+        startLatch = new CountDownLatch(2);
+        BackgroundPoster backgroundPoster = new BackgroundPoster();
+        backgroundPoster.start();
+        try {
+            Handler handler = new Handler(Looper.getMainLooper());
+            Random random = new Random();
+            countDownAndAwaitLatch(startLatch, 10);
+            for (int i = 0; i < ITERATIONS; i++) {
+                handler.post(register);
+                Thread.sleep(0, random.nextInt(300)); // Sleep just some nanoseconds, timing is crucial here
+                handler.post(unregister);
+                if (failed != null) {
+                    throw new RuntimeException("Failed in iteration " + i, failed);
+                }
+                // Don't let the queue grow to avoid out-of-memory scenarios
+                waitForHandler(handler);
+            }
+        } finally {
+            backgroundPoster.running = false;
+            backgroundPoster.join();
+        }
+    }
+
+    protected void waitForHandler(Handler handler) {
+        final CountDownLatch doneLatch = new CountDownLatch(1);
+        handler.post(new Runnable() {
+
+            @Override
+            public void run() {
+                doneLatch.countDown();
+            }
+        });
+        awaitLatch(doneLatch, 10);
+    }
+
+    public void onEventMainThread(String event) {
+        trackEvent(event);
+        if (unregistered) {
+            failed = new RuntimeException("Main thread event delivered while unregistered on received event #"
+                    + eventCount);
+        }
+    }
+
+    class BackgroundPoster extends Thread {
+        volatile boolean running = true;
+
+        public BackgroundPoster() {
+            super("BackgroundPoster");
+        }
+
+        @Override
+        public void run() {
+            countDownAndAwaitLatch(startLatch, 10);
+            while (running) {
+                eventBus.post("Posted in background");
+                if (Math.random() > 0.9f) {
+                    // Single cores would take very long without yielding
+                    Thread.yield();
+                }
+            }
+        }
+
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
index 795a0bb1..41b6302b 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
@@ -1,127 +1,128 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.os.Looper;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusMainThreadTest extends AbstractEventBusTest {
-
-    private BackgroundPoster backgroundPoster;
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        backgroundPoster = new BackgroundPoster();
-        backgroundPoster.start();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        backgroundPoster.shutdown();
-        backgroundPoster.join();
-        super.tearDown();
-    }
-
-    public void testPost() throws InterruptedException {
-        eventBus.register(this);
-        eventBus.post("Hello");
-        waitForEventCount(1, 1000);
-
-        assertEquals("Hello", lastEvent);
-        assertEquals(Looper.getMainLooper().getThread(), lastThread);
-    }
-
-    public void testPostInBackgroundThread() throws InterruptedException {
-        eventBus.register(this);
-        backgroundPoster.post("Hello");
-        waitForEventCount(1, 1000);
-        assertEquals("Hello", lastEvent);
-        assertEquals(Looper.getMainLooper().getThread(), lastThread);
-    }
-
-    public void onEventMainThread(String event) {
-        trackEvent(event);
-    }
-
-    class BackgroundPoster extends Thread {
-        private boolean running = true;
-        private List<Object> eventQ = new ArrayList<Object>();
-        private List<Object> eventsDone = new ArrayList<Object>();
-
-        public BackgroundPoster() {
-            super("BackgroundPoster");
-        }
-
-        @Override
-        public void run() {
-            while (running) {
-                Object event = pollEvent();
-                if (event != null) {
-                    eventBus.post(event);
-                    synchronized (eventsDone) {
-                        eventsDone.add(event);
-                        eventsDone.notifyAll();
-                    }
-                }
-            }
-        }
-
-        private synchronized Object pollEvent() {
-            Object event = null;
-            synchronized (eventQ) {
-                if (eventQ.isEmpty()) {
-                    try {
-                        eventQ.wait();
-                    } catch (InterruptedException e) {
-                    }
-                } else {
-                    event = eventQ.remove(0);
-                }
-            }
-            return event;
-        }
-
-        void shutdown() {
-            running = false;
-            synchronized (eventQ) {
-                eventQ.notifyAll();
-            }
-        }
-
-        void post(Object event) {
-            synchronized (eventQ) {
-                eventQ.add(event);
-                eventQ.notifyAll();
-            }
-            synchronized (eventsDone) {
-                while (eventsDone.remove(event)) {
-                    try {
-                        eventsDone.wait();
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            }
-        }
-
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.os.Looper;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusMainThreadTest extends AbstractEventBusTest {
+
+    private BackgroundPoster backgroundPoster;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        backgroundPoster = new BackgroundPoster();
+        backgroundPoster.start();
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        backgroundPoster.shutdown();
+        backgroundPoster.join();
+        super.tearDown();
+    }
+
+    public void testPost() throws InterruptedException {
+        eventBus.register(this);
+        eventBus.post("Hello");
+        waitForEventCount(1, 1000);
+
+        assertEquals("Hello", lastEvent);
+        assertEquals(Looper.getMainLooper().getThread(), lastThread);
+    }
+
+    public void testPostInBackgroundThread() throws InterruptedException {
+        eventBus.register(this);
+        backgroundPoster.post("Hello");
+        waitForEventCount(1, 1000);
+        assertEquals("Hello", lastEvent);
+        assertEquals(Looper.getMainLooper().getThread(), lastThread);
+    }
+
+    public void onEventMainThread(String event) {
+        trackEvent(event);
+    }
+
+    class BackgroundPoster extends Thread {
+        volatile boolean running = true;
+        private final List<Object> eventQ = new ArrayList<Object>();
+        private final List<Object> eventsDone = new ArrayList<Object>();
+
+        public BackgroundPoster() {
+            super("BackgroundPoster");
+        }
+
+        @Override
+        public void run() {
+            while (running) {
+                Object event = pollEvent();
+                if (event != null) {
+                    eventBus.post(event);
+                    synchronized (eventsDone) {
+                        eventsDone.add(event);
+                        eventsDone.notifyAll();
+                    }
+                }
+            }
+        }
+
+        private synchronized Object pollEvent() {
+            Object event = null;
+            synchronized (eventQ) {
+                if (eventQ.isEmpty()) {
+                    try {
+                        eventQ.wait(1000);
+                    } catch (InterruptedException e) {
+                    }
+                }
+                if(!eventQ.isEmpty()) {
+                    event = eventQ.remove(0);
+                }
+            }
+            return event;
+        }
+
+        void shutdown() {
+            running = false;
+            synchronized (eventQ) {
+                eventQ.notifyAll();
+            }
+        }
+
+        void post(Object event) {
+            synchronized (eventQ) {
+                eventQ.add(event);
+                eventQ.notifyAll();
+            }
+            synchronized (eventsDone) {
+                while (eventsDone.remove(event)) {
+                    try {
+                        eventsDone.wait();
+                    } catch (InterruptedException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+        }
+
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
index 92d827c3..6d664b9c 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
@@ -1,77 +1,77 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import android.os.Looper;
-import de.greenrobot.event.EventBus;
-import de.greenrobot.event.EventBusException;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusMethodModifiersTest extends AbstractEventBusTest {
-
-    public void testRegisterForEventTypeAndPost() throws InterruptedException {
-        eventBus.register(this);
-        String event = "Hello";
-        eventBus.post(event);
-        waitForEventCount(4, 1000);
-    }
-
-    public void testIllegalMethodNameThrow() {
-        try {
-            eventBus.register(new IllegalEventMethodName());
-            fail("Illegal name registered");
-        } catch (EventBusException ex) {
-            // OK, expected
-        }
-    }
-
-    public void testIllegalMethodNameSkip() {
-        EventBus.skipMethodNameVerificationFor(IllegalEventMethodName.class);
-        eventBus.register(new IllegalEventMethodName());
-        eventBus.post(new Object());
-    }
-
-    public void onEvent(String event) {
-        trackEvent(event);
-        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-    }
-
-    public void onEventMainThread(String event) {
-        trackEvent(event);
-        assertSame(Looper.getMainLooper(), Looper.myLooper());
-    }
-
-    public void onEventBackgroundThread(String event) {
-        trackEvent(event);
-        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-    }
-
-    public void onEventAsync(String event) {
-        trackEvent(event);
-        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-    }
-
-    public static class IllegalEventMethodName {
-        public void onEventIllegalName(Object event) {
-            fail("onEventIllegalName got called");
-        }
-
-        public void onEvent(IntTestEvent event) {
-        }
-    }
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import android.os.Looper;
+import de.greenrobot.event.EventBus;
+import de.greenrobot.event.EventBusException;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusMethodModifiersTest extends AbstractEventBusTest {
+
+    public void testRegisterForEventTypeAndPost() throws InterruptedException {
+        eventBus.register(this);
+        String event = "Hello";
+        eventBus.post(event);
+        waitForEventCount(4, 1000);
+    }
+
+    public void testIllegalMethodNameThrow() {
+        try {
+            eventBus.register(new IllegalEventMethodName());
+            fail("Illegal name registered");
+        } catch (EventBusException ex) {
+            // OK, expected
+        }
+    }
+
+    public void testIllegalMethodNameSkip() {
+        eventBus=EventBus.builder().skipMethodVerificationFor(IllegalEventMethodName.class).build();
+        eventBus.register(new IllegalEventMethodName());
+        eventBus.post(new Object());
+    }
+
+    public void onEvent(String event) {
+        trackEvent(event);
+        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+    }
+
+    public void onEventMainThread(String event) {
+        trackEvent(event);
+        assertSame(Looper.getMainLooper(), Looper.myLooper());
+    }
+
+    public void onEventBackgroundThread(String event) {
+        trackEvent(event);
+        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+    }
+
+    public void onEventAsync(String event) {
+        trackEvent(event);
+        assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+    }
+
+    public static class IllegalEventMethodName {
+        public void onEventIllegalName(Object event) {
+            fail("onEventIllegalName got called");
+        }
+
+        public void onEvent(IntTestEvent event) {
+        }
+    }
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
index b68e86b9..be68fd12 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
@@ -1,264 +1,259 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import android.os.Looper;
-import android.util.Log;
-import de.greenrobot.event.EventBus;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusMultithreadedTest extends AbstractEventBusTest {
-
-    /**
-     * Iteration count per test (will be divided by number of threads); run with 1000 for quick testing, and with 10000
-     * from time to time.
-     */
-    private static final int COUNT = 1000;
-
-    private final AtomicInteger countStringEvent = new AtomicInteger();
-    private final AtomicInteger countIntegerEvent = new AtomicInteger();
-    private final AtomicInteger countObjectEvent = new AtomicInteger();
-    private final AtomicInteger countIntTestEvent = new AtomicInteger();
-
-    private String lastStringEvent;
-    private Integer lastIntegerEvent;
-
-    private IntTestEvent lastIntTestEvent;
-
-    public void testPost01Thread() throws InterruptedException {
-        runThreadsSingleEventType(1);
-    }
-
-    public void testPost04Threads() throws InterruptedException {
-        runThreadsSingleEventType(4);
-    }
-
-    public void testPost40Threads() throws InterruptedException {
-        runThreadsSingleEventType(40);
-    }
-
-    public void testPostMixedEventType01Thread() throws InterruptedException {
-        runThreadsMixedEventType(1);
-    }
-
-    public void testPostMixedEventType04Threads() throws InterruptedException {
-        runThreadsMixedEventType(4);
-    }
-
-    public void testPostMixedEventType40Threads() throws InterruptedException {
-        runThreadsMixedEventType(40);
-    }
-
-    public void testSubscribeUnSubscribeAndPostMixedEventType() throws InterruptedException {
-        List<SubscribeUnsubscribeThread> threads = new ArrayList<SubscribeUnsubscribeThread>();
-
-        // Debug.startMethodTracing("testSubscribeUnSubscribeAndPostMixedEventType");
-        for (int i = 0; i < 5; i++) {
-            SubscribeUnsubscribeThread thread = new SubscribeUnsubscribeThread();
-            thread.start();
-            threads.add(thread);
-        }
-        // This test takes a bit longer, so just use fraction the regular count
-        runThreadsMixedEventType(COUNT / 4, 5);
-        for (SubscribeUnsubscribeThread thread : threads) {
-            thread.shutdown();
-        }
-        for (SubscribeUnsubscribeThread thread : threads) {
-            thread.join();
-        }
-        // Debug.stopMethodTracing();
-    }
-
-    private void runThreadsSingleEventType(int threadCount) throws InterruptedException {
-        int iterations = COUNT / threadCount;
-        eventBus.register(this);
-
-        CountDownLatch latch = new CountDownLatch(threadCount + 1);
-        List<PosterThread> threads = startThreads(latch, threadCount, iterations, "Hello");
-        long time = triggerAndWaitForThreads(threads, latch);
-
-        Log.d(EventBus.TAG, threadCount + " threads posted " + iterations + " events each in " + time + "ms");
-
-        waitForEventCount(COUNT * 2, 5000);
-
-        assertEquals("Hello", lastStringEvent);
-        int expectedCount = threadCount * iterations;
-        assertEquals(expectedCount, countStringEvent.intValue());
-        assertEquals(expectedCount, countObjectEvent.intValue());
-    }
-
-    private void runThreadsMixedEventType(int threadCount) throws InterruptedException {
-        runThreadsMixedEventType(COUNT, threadCount);
-    }
-
-    private void runThreadsMixedEventType(int count, int threadCount) throws InterruptedException {
-        eventBus.register(this);
-        int eventTypeCount = 3;
-        int iterations = count / threadCount / eventTypeCount;
-
-        CountDownLatch latch = new CountDownLatch(eventTypeCount * threadCount + 1);
-        List<PosterThread> threadsString = startThreads(latch, threadCount, iterations, "Hello");
-        List<PosterThread> threadsInteger = startThreads(latch, threadCount, iterations, 42);
-        List<PosterThread> threadsIntTestEvent = startThreads(latch, threadCount, iterations, new IntTestEvent(7));
-
-        List<PosterThread> threads = new ArrayList<PosterThread>();
-        threads.addAll(threadsString);
-        threads.addAll(threadsInteger);
-        threads.addAll(threadsIntTestEvent);
-        long time = triggerAndWaitForThreads(threads, latch);
-
-        Log.d(EventBus.TAG, threadCount * eventTypeCount + " mixed threads posted " + iterations + " events each in "
-                + time + "ms");
-
-        int expectedCountEach = threadCount * iterations;
-        int expectedCountTotal = expectedCountEach * eventTypeCount * 2;
-        waitForEventCount(expectedCountTotal, 5000);
-
-        assertEquals("Hello", lastStringEvent);
-        assertEquals(42, lastIntegerEvent.intValue());
-        assertEquals(7, lastIntTestEvent.value);
-
-        assertEquals(expectedCountEach, countStringEvent.intValue());
-        assertEquals(expectedCountEach, countIntegerEvent.intValue());
-        assertEquals(expectedCountEach, countIntTestEvent.intValue());
-
-        assertEquals(expectedCountEach * eventTypeCount, countObjectEvent.intValue());
-    }
-
-    private long triggerAndWaitForThreads(List<PosterThread> threads, CountDownLatch latch) throws InterruptedException {
-        while (latch.getCount() != 1) {
-            // Let all threads prepare
-            Thread.sleep(1);
-        }
-        long start = System.currentTimeMillis();
-        latch.countDown();
-        for (PosterThread thread : threads) {
-            thread.join();
-        }
-        return System.currentTimeMillis() - start;
-    }
-
-    private List<PosterThread> startThreads(CountDownLatch latch, int threadCount, int iterations, Object eventToPost)
-            throws InterruptedException {
-        List<PosterThread> threads = new ArrayList<PosterThread>(threadCount);
-        for (int i = 0; i < threadCount; i++) {
-            PosterThread thread = new PosterThread(latch, iterations, eventToPost);
-            thread.start();
-            threads.add(thread);
-        }
-        return threads;
-    }
-
-    public void onEventBackgroundThread(String event) {
-        lastStringEvent = event;
-        countStringEvent.incrementAndGet();
-        trackEvent(event);
-    }
-
-    public void onEventMainThread(Integer event) {
-        lastIntegerEvent = event;
-        countIntegerEvent.incrementAndGet();
-        trackEvent(event);
-    }
-
-    public void onEventAsync(IntTestEvent event) {
-        countIntTestEvent.incrementAndGet();
-        lastIntTestEvent = event;
-        trackEvent(event);
-    }
-
-    public void onEvent(Object event) {
-        countObjectEvent.incrementAndGet();
-        trackEvent(event);
-    }
-
-    class PosterThread extends Thread {
-
-        private final CountDownLatch startLatch;
-        private final int iterations;
-        private final Object eventToPost;
-
-        public PosterThread(CountDownLatch latch, int iterations, Object eventToPost) {
-            this.startLatch = latch;
-            this.iterations = iterations;
-            this.eventToPost = eventToPost;
-        }
-
-        @Override
-        public void run() {
-            startLatch.countDown();
-            try {
-                startLatch.await();
-            } catch (InterruptedException e) {
-                Log.w(EventBus.TAG, "Unexpeced interrupt", e);
-            }
-
-            for (int i = 0; i < iterations; i++) {
-                eventBus.post(eventToPost);
-            }
-        }
-    }
-
-    class SubscribeUnsubscribeThread extends Thread {
-        boolean running = true;
-
-        public void shutdown() {
-            running = false;
-        }
-
-        @Override
-        public void run() {
-            try {
-                while (running) {
-                    eventBus.register(this);
-                    double random = Math.random();
-                    if (random > 0.6d) {
-                        Thread.sleep(1);
-                    } else if (random > 0.3d) {
-                        Thread.yield();
-                    }
-                    eventBus.unregister(this);
-                }
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        public void onEventMainThread(String event) {
-            assertSame(Looper.getMainLooper(), Looper.myLooper());
-        }
-
-        public void onEventBackgroundThread(Integer event) {
-            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-        }
-
-        public void onEvent(Object event) {
-            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-        }
-
-        public void onEventAsync(Object event) {
-            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import android.os.Looper;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusMultithreadedTest extends AbstractEventBusTest {
+
+    private static final int COUNT = LONG_TESTS ? 100000 : 1000;
+
+    private final AtomicInteger countStringEvent = new AtomicInteger();
+    private final AtomicInteger countIntegerEvent = new AtomicInteger();
+    private final AtomicInteger countObjectEvent = new AtomicInteger();
+    private final AtomicInteger countIntTestEvent = new AtomicInteger();
+
+    private String lastStringEvent;
+    private Integer lastIntegerEvent;
+
+    private IntTestEvent lastIntTestEvent;
+
+    public void testPost01Thread() throws InterruptedException {
+        runThreadsSingleEventType(1);
+    }
+
+    public void testPost04Threads() throws InterruptedException {
+        runThreadsSingleEventType(4);
+    }
+
+    public void testPost40Threads() throws InterruptedException {
+        runThreadsSingleEventType(40);
+    }
+
+    public void testPostMixedEventType01Thread() throws InterruptedException {
+        runThreadsMixedEventType(1);
+    }
+
+    public void testPostMixedEventType04Threads() throws InterruptedException {
+        runThreadsMixedEventType(4);
+    }
+
+    public void testPostMixedEventType40Threads() throws InterruptedException {
+        runThreadsMixedEventType(40);
+    }
+
+    public void testSubscribeUnSubscribeAndPostMixedEventType() throws InterruptedException {
+        List<SubscribeUnsubscribeThread> threads = new ArrayList<SubscribeUnsubscribeThread>();
+
+        // Debug.startMethodTracing("testSubscribeUnSubscribeAndPostMixedEventType");
+        for (int i = 0; i < 5; i++) {
+            SubscribeUnsubscribeThread thread = new SubscribeUnsubscribeThread();
+            thread.start();
+            threads.add(thread);
+        }
+        // This test takes a bit longer, so just use fraction the regular count
+        runThreadsMixedEventType(COUNT / 4, 5);
+        for (SubscribeUnsubscribeThread thread : threads) {
+            thread.shutdown();
+        }
+        for (SubscribeUnsubscribeThread thread : threads) {
+            thread.join();
+        }
+        // Debug.stopMethodTracing();
+    }
+
+    private void runThreadsSingleEventType(int threadCount) throws InterruptedException {
+        int iterations = COUNT / threadCount;
+        eventBus.register(this);
+
+        CountDownLatch latch = new CountDownLatch(threadCount + 1);
+        List<PosterThread> threads = startThreads(latch, threadCount, iterations, "Hello");
+        long time = triggerAndWaitForThreads(threads, latch);
+
+        Log.d(EventBus.TAG, threadCount + " threads posted " + iterations + " events each in " + time + "ms");
+
+        waitForEventCount(COUNT * 2, 5000);
+
+        assertEquals("Hello", lastStringEvent);
+        int expectedCount = threadCount * iterations;
+        assertEquals(expectedCount, countStringEvent.intValue());
+        assertEquals(expectedCount, countObjectEvent.intValue());
+    }
+
+    private void runThreadsMixedEventType(int threadCount) throws InterruptedException {
+        runThreadsMixedEventType(COUNT, threadCount);
+    }
+
+    private void runThreadsMixedEventType(int count, int threadCount) throws InterruptedException {
+        eventBus.register(this);
+        int eventTypeCount = 3;
+        int iterations = count / threadCount / eventTypeCount;
+
+        CountDownLatch latch = new CountDownLatch(eventTypeCount * threadCount + 1);
+        List<PosterThread> threadsString = startThreads(latch, threadCount, iterations, "Hello");
+        List<PosterThread> threadsInteger = startThreads(latch, threadCount, iterations, 42);
+        List<PosterThread> threadsIntTestEvent = startThreads(latch, threadCount, iterations, new IntTestEvent(7));
+
+        List<PosterThread> threads = new ArrayList<PosterThread>();
+        threads.addAll(threadsString);
+        threads.addAll(threadsInteger);
+        threads.addAll(threadsIntTestEvent);
+        long time = triggerAndWaitForThreads(threads, latch);
+
+        Log.d(EventBus.TAG, threadCount * eventTypeCount + " mixed threads posted " + iterations + " events each in "
+                + time + "ms");
+
+        int expectedCountEach = threadCount * iterations;
+        int expectedCountTotal = expectedCountEach * eventTypeCount * 2;
+        waitForEventCount(expectedCountTotal, 5000);
+
+        assertEquals("Hello", lastStringEvent);
+        assertEquals(42, lastIntegerEvent.intValue());
+        assertEquals(7, lastIntTestEvent.value);
+
+        assertEquals(expectedCountEach, countStringEvent.intValue());
+        assertEquals(expectedCountEach, countIntegerEvent.intValue());
+        assertEquals(expectedCountEach, countIntTestEvent.intValue());
+
+        assertEquals(expectedCountEach * eventTypeCount, countObjectEvent.intValue());
+    }
+
+    private long triggerAndWaitForThreads(List<PosterThread> threads, CountDownLatch latch) throws InterruptedException {
+        while (latch.getCount() != 1) {
+            // Let all other threads prepare and ensure this one is the last 
+            Thread.sleep(1);
+        }
+        long start = System.currentTimeMillis();
+        latch.countDown();
+        for (PosterThread thread : threads) {
+            thread.join();
+        }
+        return System.currentTimeMillis() - start;
+    }
+
+    private List<PosterThread> startThreads(CountDownLatch latch, int threadCount, int iterations, Object eventToPost) {
+        List<PosterThread> threads = new ArrayList<PosterThread>(threadCount);
+        for (int i = 0; i < threadCount; i++) {
+            PosterThread thread = new PosterThread(latch, iterations, eventToPost);
+            thread.start();
+            threads.add(thread);
+        }
+        return threads;
+    }
+
+    public void onEventBackgroundThread(String event) {
+        lastStringEvent = event;
+        countStringEvent.incrementAndGet();
+        trackEvent(event);
+    }
+
+    public void onEventMainThread(Integer event) {
+        lastIntegerEvent = event;
+        countIntegerEvent.incrementAndGet();
+        trackEvent(event);
+    }
+
+    public void onEventAsync(IntTestEvent event) {
+        countIntTestEvent.incrementAndGet();
+        lastIntTestEvent = event;
+        trackEvent(event);
+    }
+
+    public void onEvent(Object event) {
+        countObjectEvent.incrementAndGet();
+        trackEvent(event);
+    }
+
+    class PosterThread extends Thread {
+
+        private final CountDownLatch startLatch;
+        private final int iterations;
+        private final Object eventToPost;
+
+        public PosterThread(CountDownLatch latch, int iterations, Object eventToPost) {
+            this.startLatch = latch;
+            this.iterations = iterations;
+            this.eventToPost = eventToPost;
+        }
+
+        @Override
+        public void run() {
+            startLatch.countDown();
+            try {
+                startLatch.await();
+            } catch (InterruptedException e) {
+                Log.w(EventBus.TAG, "Unexpeced interrupt", e);
+            }
+
+            for (int i = 0; i < iterations; i++) {
+                eventBus.post(eventToPost);
+            }
+        }
+    }
+
+    class SubscribeUnsubscribeThread extends Thread {
+        boolean running = true;
+
+        public void shutdown() {
+            running = false;
+        }
+
+        @Override
+        public void run() {
+            try {
+                while (running) {
+                    eventBus.register(this);
+                    double random = Math.random();
+                    if (random > 0.6d) {
+                        Thread.sleep(0, (int) (1000000 * Math.random()));
+                    } else if (random > 0.3d) {
+                        Thread.yield();
+                    }
+                    eventBus.unregister(this);
+                }
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        public void onEventMainThread(String event) {
+            assertSame(Looper.getMainLooper(), Looper.myLooper());
+        }
+
+        public void onEventBackgroundThread(Integer event) {
+            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+        }
+
+        public void onEvent(Object event) {
+            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+        }
+
+        public void onEventAsync(Object event) {
+            assertNotSame(Looper.getMainLooper(), Looper.myLooper());
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
index 1c1751ba..ffe48f10 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
@@ -1,62 +1,74 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import de.greenrobot.event.NoSubscriberEvent;
-import de.greenrobot.event.SubscriberExceptionEvent;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusNoSubscriberEventTest extends AbstractEventBusTest {
-
-    public void testNoSubscriberEvent() {
-        eventBus.register(this);
-        eventBus.post("Foo");
-        assertEventCount(1);
-        assertEquals(NoSubscriberEvent.class, lastEvent.getClass());
-        NoSubscriberEvent noSub = (NoSubscriberEvent) lastEvent;
-        assertEquals("Foo", noSub.originalEvent);
-        assertSame(eventBus, noSub.eventBus);
-    }
-
-    public void testBadNoSubscriberSubscriber() {
-        eventBus.configureLogSubscriberExceptions(false);
-        eventBus.register(this);
-        eventBus.register(new BadNoSubscriberSubscriber());
-        eventBus.post("Foo");
-        assertEventCount(2);
-
-        assertEquals(SubscriberExceptionEvent.class, lastEvent.getClass());
-        NoSubscriberEvent noSub = (NoSubscriberEvent) ((SubscriberExceptionEvent) lastEvent).causingEvent;
-        assertEquals("Foo", noSub.originalEvent);
-    }
-
-    public void onEvent(NoSubscriberEvent event) {
-        trackEvent(event);
-    }
-
-    public void onEvent(SubscriberExceptionEvent event) {
-        trackEvent(event);
-    }
-
-    class BadNoSubscriberSubscriber {
-        public void onEvent(NoSubscriberEvent event) {
-            throw new RuntimeException("I'm bad");
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import de.greenrobot.event.EventBus;
+import de.greenrobot.event.NoSubscriberEvent;
+import de.greenrobot.event.SubscriberExceptionEvent;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusNoSubscriberEventTest extends AbstractEventBusTest {
+
+    public void testNoSubscriberEvent() {
+        eventBus.register(this);
+        eventBus.post("Foo");
+        assertEventCount(1);
+        assertEquals(NoSubscriberEvent.class, lastEvent.getClass());
+        NoSubscriberEvent noSub = (NoSubscriberEvent) lastEvent;
+        assertEquals("Foo", noSub.originalEvent);
+        assertSame(eventBus, noSub.eventBus);
+    }
+
+    public void testNoSubscriberEventAfterUnregister() {
+        Object subscriber = new Object() {
+            @SuppressWarnings("unused")
+            public void onEvent(String dummy) {
+            }
+        };
+        eventBus.register(subscriber);
+        eventBus.unregister(subscriber);
+        testNoSubscriberEvent();
+    }
+
+    public void testBadNoSubscriberSubscriber() {
+        eventBus = EventBus.builder().logNoSubscriberMessages(false).build();
+        eventBus.register(this);
+        eventBus.register(new BadNoSubscriberSubscriber());
+        eventBus.post("Foo");
+        assertEventCount(2);
+
+        assertEquals(SubscriberExceptionEvent.class, lastEvent.getClass());
+        NoSubscriberEvent noSub = (NoSubscriberEvent) ((SubscriberExceptionEvent) lastEvent).causingEvent;
+        assertEquals("Foo", noSub.originalEvent);
+    }
+
+    public void onEvent(NoSubscriberEvent event) {
+        trackEvent(event);
+    }
+
+    public void onEvent(SubscriberExceptionEvent event) {
+        trackEvent(event);
+    }
+
+    class BadNoSubscriberSubscriber {
+        public void onEvent(NoSubscriberEvent event) {
+            throw new RuntimeException("I'm bad");
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java
new file mode 100644
index 00000000..0cb794ac
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.event.EventBus;
+import android.util.Log;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusOrderedSubscriptionsTest extends AbstractEventBusTest {
+
+    int lastPrio = Integer.MAX_VALUE;
+    final List<PrioSubscriber> registered = new ArrayList<PrioSubscriber>();
+    private String fail;
+
+    public void testOrdered() {
+        runTestOrdered("42", false);
+    }
+
+    public void testOrderedMainThread() {
+        runTestOrdered(new IntTestEvent(42), false);
+    }
+
+    public void testOrderedBackgroundThread() {
+        runTestOrdered(Integer.valueOf(42), false);
+    }
+    
+    public void testOrderedSticky() {
+        runTestOrdered("42", true);
+    }
+
+    public void testOrderedMainThreadSticky() {
+        runTestOrdered(new IntTestEvent(42), true);
+    }
+
+    public void testOrderedBackgroundThreadSticky() {
+        runTestOrdered(Integer.valueOf(42), true);
+    }
+
+    protected void runTestOrdered(Object event, boolean sticky) {
+        register(1, sticky);
+        register(-1, sticky);
+        register(10, sticky);
+        register(0, sticky);
+        register(-100, sticky);
+        assertEquals(5, registered.size());
+
+        eventBus.post(event);
+
+        waitForEventCount(5, 10000);
+        assertEquals(null, fail);
+
+        unregisterAll();
+    }
+
+    private void unregisterAll() {
+        for (PrioSubscriber subscriber : registered) {
+            eventBus.unregister(subscriber);
+        }
+    }
+
+    protected PrioSubscriber register(int priority, boolean sticky) {
+        PrioSubscriber subscriber = new PrioSubscriber(priority);
+        if (sticky) {
+            eventBus.registerSticky(subscriber, priority);
+        } else {
+            eventBus.register(subscriber, priority);
+        }
+        registered.add(subscriber);
+        return subscriber;
+    }
+
+    private final class PrioSubscriber {
+
+        final int prio;
+
+        public PrioSubscriber(int prio) {
+            this.prio = prio;
+            // TODO Auto-generated constructor stub
+        }
+
+        public void onEvent(String event) {
+            handleEvent(event);
+        }
+
+        public void onEventMainThread(IntTestEvent event) {
+            handleEvent(event);
+        }
+
+        public void onEventBackgroundThread(Integer event) {
+            handleEvent(event);
+        }
+
+        protected void handleEvent(Object event) {
+            if (prio > lastPrio) {
+                fail = "Called prio " + prio + " after " + lastPrio;
+            }
+            lastPrio = prio;
+
+            Log.d(EventBus.TAG, "Subscriber " + prio + " got: " + event);
+            trackEvent(event);
+        }
+
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java
new file mode 100644
index 00000000..41808dc7
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusRegistrationRacingTest extends AbstractEventBusTest {
+
+    // On a Nexus 5, bad synchronization always failed on the first iteration or went well completely.
+    // So a high number of iterations do not guarantee a better probability of finding bugs.
+    private static final int ITERATIONS = LONG_TESTS ? 1000 : 10;
+    private static final int THREAD_COUNT = 16;
+
+    volatile CountDownLatch startLatch;
+    volatile CountDownLatch registeredLatch;
+    volatile CountDownLatch canUnregisterLatch;
+    volatile CountDownLatch unregisteredLatch;
+    
+    final Executor threadPool = Executors.newCachedThreadPool();
+
+    public void testRacingRegistrations() throws InterruptedException {
+        for (int i = 0; i < ITERATIONS; i++) {
+            startLatch = new CountDownLatch(THREAD_COUNT);
+            registeredLatch = new CountDownLatch(THREAD_COUNT);
+            canUnregisterLatch = new CountDownLatch(1);
+            unregisteredLatch = new CountDownLatch(THREAD_COUNT);
+            
+            List<SubscriberThread> threads = startThreads();
+            registeredLatch.await();
+            eventBus.post("42");
+            canUnregisterLatch.countDown();
+            for (int t = 0; t < THREAD_COUNT; t++) {
+                int eventCount = threads.get(t).eventCount;
+                if (eventCount != 1) {
+                    fail("Failed in iteration " + i + ": thread #" + t + " has event count of " + eventCount);
+                }
+            }
+            // Wait for threads to be done
+            unregisteredLatch.await();
+        }
+    }
+
+    private List<SubscriberThread> startThreads() {
+        List<SubscriberThread> threads = new ArrayList<SubscriberThread>(THREAD_COUNT);
+        for (int i = 0; i < THREAD_COUNT; i++) {
+            SubscriberThread thread = new SubscriberThread();
+            threadPool.execute(thread);
+            threads.add(thread);
+        }
+        return threads;
+    }
+
+    class SubscriberThread implements Runnable {
+        volatile int eventCount;
+
+        @Override
+        public void run() {
+            countDownAndAwaitLatch(startLatch, 10);
+            eventBus.register(this);
+            registeredLatch.countDown();
+            try {
+                canUnregisterLatch.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            eventBus.unregister(this);
+            unregisteredLatch.countDown();
+        }
+
+        public void onEvent(String event) {
+            eventCount++;
+        }
+
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
index 334a4158..04be4d91 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
@@ -34,20 +34,6 @@ public void testPostStickyTwoEvents() throws InterruptedException {
         assertEquals(2, eventCount.intValue());
     }
 
-    public void testPostStickyTwoEventsRegisterEventTypes() throws InterruptedException {
-        eventBus.postSticky("Sticky");
-        eventBus.postSticky(new IntTestEvent(7));
-        eventBus.registerSticky(this, String.class, IntTestEvent.class);
-        assertEquals(2, eventCount.intValue());
-    }
-
-    public void testPostStickyRegisterForType() throws InterruptedException {
-        eventBus.postSticky("Sticky");
-        eventBus.registerSticky(this, String.class);
-        assertEquals("Sticky", lastEvent);
-        assertEquals(Thread.currentThread(), lastThread);
-    }
-
     public void testPostStickyRegisterNonSticky() throws InterruptedException {
         eventBus.postSticky("Sticky");
         eventBus.register(this);
@@ -119,6 +105,17 @@ public void testPostStickyRemoveEvent() throws InterruptedException {
         assertEquals(0, eventCount.intValue());
     }
 
+    public void testPostStickyRemoveAll() throws InterruptedException {
+        eventBus.postSticky("Sticky");
+        eventBus.postSticky(new IntTestEvent(77));
+        eventBus.removeAllStickyEvents();
+        assertNull(eventBus.getStickyEvent(String.class));
+        assertNull(eventBus.getStickyEvent(IntTestEvent.class));
+        eventBus.registerSticky(this);
+        assertNull(lastEvent);
+        assertEquals(0, eventCount.intValue());
+    }
+
     public void testRemoveStickyEventInSubscriber() throws InterruptedException {
         eventBus.registerSticky(new Object() {
             @SuppressWarnings("unused")
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
index 202af52a..f9acaa7e 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
@@ -1,59 +1,60 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.event.test;
-
-import de.greenrobot.event.SubscriberExceptionEvent;
-
-/**
- * @author Markus Junginger, greenrobot
- */
-public class EventBusSubscriberExceptionTest extends AbstractEventBusTest {
-
-    public void testSubscriberExceptionEvent() {
-        eventBus.configureLogSubscriberExceptions(false);
-        eventBus.register(this);
-        eventBus.post("Foo");
-        assertEventCount(1);
-        assertEquals(SubscriberExceptionEvent.class, lastEvent.getClass());
-        SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) lastEvent;
-        assertEquals("Foo", exEvent.causingEvent);
-        assertSame(this, exEvent.causingSubscriber);
-        assertEquals("Bar", exEvent.throwable.getMessage());
-    }
-
-    public void testBadExceptionSubscriber() {
-        eventBus.configureLogSubscriberExceptions(false);
-        eventBus.register(this);
-        eventBus.register(new BadExceptionSubscriber());
-        eventBus.post("Foo");
-        assertEventCount(1);
-    }
-
-    public void onEvent(String event) {
-        throw new RuntimeException("Bar");
-    }
-
-    public void onEvent(SubscriberExceptionEvent event) {
-        trackEvent(event);
-    }
-
-    class BadExceptionSubscriber {
-        public void onEvent(SubscriberExceptionEvent event) {
-            throw new RuntimeException("Bad");
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import de.greenrobot.event.EventBus;
+import de.greenrobot.event.SubscriberExceptionEvent;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusSubscriberExceptionTest extends AbstractEventBusTest {
+
+    public void testSubscriberExceptionEvent() {
+        eventBus = EventBus.builder().logSubscriberExceptions(false).build();
+        eventBus.register(this);
+        eventBus.post("Foo");
+        assertEventCount(1);
+        assertEquals(SubscriberExceptionEvent.class, lastEvent.getClass());
+        SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) lastEvent;
+        assertEquals("Foo", exEvent.causingEvent);
+        assertSame(this, exEvent.causingSubscriber);
+        assertEquals("Bar", exEvent.throwable.getMessage());
+    }
+
+    public void testBadExceptionSubscriber() {
+        eventBus = EventBus.builder().logSubscriberExceptions(false).build();
+        eventBus.register(this);
+        eventBus.register(new BadExceptionSubscriber());
+        eventBus.post("Foo");
+        assertEventCount(1);
+    }
+
+    public void onEvent(String event) {
+        throw new RuntimeException("Bar");
+    }
+
+    public void onEvent(SubscriberExceptionEvent event) {
+        trackEvent(event);
+    }
+
+    class BadExceptionSubscriber {
+        public void onEvent(SubscriberExceptionEvent event) {
+            throw new RuntimeException("Bad");
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java
new file mode 100644
index 00000000..ee435219
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.test;
+
+import de.greenrobot.event.EventBusException;
+
+/**
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBusSubscriberLegalTest extends AbstractEventBusTest {
+
+    public void testSubscriberLegal() {
+        eventBus.register(this);
+        eventBus.post("42");
+        eventBus.unregister(this);
+        assertEquals(1, eventCount.intValue());
+    }
+
+    public void testSubscriberNotPublic() {
+        try {
+            eventBus.register(new NotPublic());
+            fail("Registration of ilegal subscriber successful");
+        } catch (EventBusException e) {
+            // Expected
+        }
+    }
+
+    public void testSubscriberStatic() {
+        try {
+            eventBus.register(new Static());
+            fail("Registration of ilegal subscriber successful");
+        } catch (EventBusException e) {
+            // Expected
+        }
+    }
+
+    public void testSubscriberLegalAbstract() {
+        eventBus.register(new Abstract() {
+
+            @Override
+            public void onEvent(String event) {
+                trackEvent(event);
+            }
+
+        });
+
+        eventBus.post("42");
+        assertEquals(1, eventCount.intValue());
+    }
+
+    public void onEvent(String event) {
+        trackEvent(event);
+    }
+
+    static class NotPublic {
+        void onEvent(String event) {
+        }
+    }
+
+    static abstract class Abstract {
+        public abstract void onEvent(String event);
+    }
+
+    static class Static {
+        public static void onEvent(String event) {
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/IntTestEvent.java b/EventBusTest/src/de/greenrobot/event/test/IntTestEvent.java
index 77ccd8df..dc829b89 100644
--- a/EventBusTest/src/de/greenrobot/event/test/IntTestEvent.java
+++ b/EventBusTest/src/de/greenrobot/event/test/IntTestEvent.java
@@ -1,29 +1,29 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Simple event storing an int value. More efficient than Integer because of the its flat hierarchy. 
- */
-package de.greenrobot.event.test;
-
-public class IntTestEvent {
-    public final int value;
-
-    public IntTestEvent(int value) {
-        this.value = value;
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Simple event storing an int value. More efficient than Integer because of the its flat hierarchy. 
+ */
+package de.greenrobot.event.test;
+
+public class IntTestEvent {
+    public final int value;
+
+    public IntTestEvent(int value) {
+        this.value = value;
+    }
+
+}
diff --git a/HOWTO.md b/HOWTO.md
new file mode 100644
index 00000000..8661770c
--- /dev/null
+++ b/HOWTO.md
@@ -0,0 +1,247 @@
+EventBus How-To
+===============
+In the [README file](README.md), you got to know EventBus, and some of its basic principles. You also saw how to add EventBus to your project using Maven Central. Great, now let's dive deeper!
+
+General usage and API
+---------------------
+Here we pick up on the 3 steps of the README and expand a bit on the code.
+### 1: Define events ###
+Events are POJO (plain old Java object) without any specific requirements.
+
+```java
+public class MessageEvent {
+    public final String message;
+
+    public MessageEvent(String message) {
+        this.message = message;
+    }
+}
+```
+### 2: Prepare subscribers ###
+
+Subscribers implement event handling `onEvent` methods that will be called when an event is received. They also need to register and unregister themselves to the bus.
+
+```java
+    @Override
+    public void onStart() {
+        super.onStart();
+        EventBus.getDefault().register(this);
+    }
+
+    @Override
+    public void onStop() {
+        EventBus.getDefault().unregister(this);
+        super.onStop();
+    }
+    
+    // This method will be called when a MessageEvent is posted
+    public void onEvent(MessageEvent event){
+        Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();
+    }
+    
+    // This method will be called when a SomeOtherEvent is posted
+    public void onEvent(SomeOtherEvent event){
+        doSomethingWith(event);
+    }
+    
+```
+### 3: Post events ###
+Post an event from any part of your code. All subscribers matching the event type will receive it.
+
+```java
+    EventBus.getDefault().post(new MessageEvent("Hello everyone!"));
+```
+
+Delivery threads and ThreadModes
+--------------------------------
+EventBus can handle threading for you: events can be posted in threads different from the posting thread. 
+
+A common use case is dealing with UI changes. In Android, UI changes must be done in the UI (main) thread. On the other hand, networking, or any time consuming task, must not run on the main thread. EventBus helps you to deal with those tasks and synchronize with the UI thread (without having to delve into thread transitions, using AsyncTask, etc).
+
+In EventBus, you may define the thread that will call the event handling method `onEvent` by using a **ThreadMode**:
+* **PostThread:** Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers using this mode should return quickly to avoid blocking the posting thread, which may be the main thread.
+Example:
+```java
+    // Called in the same thread (default)
+    public void onEvent(MessageEvent event) {
+        log(event.message);
+    }
+```
+* **MainThread:** Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is the main thread, event handler methods will be called directly. Event handlers using this mode must return quickly to avoid blocking the main thread.
+Example:
+```java
+    // Called in Android UI's main thread
+    public void onEventMainThread(MessageEvent event) {
+        textField.setText(event.message);
+    }
+```
+* **BackgroundThread:** Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single background thread that will deliver all its events sequentially. Event handlers using this mode should try to return quickly to avoid blocking the background thread.
+```java
+    // Called in the background thread
+    public void onEventBackgroundThread(MessageEvent event){
+        saveToDisk(event.message);
+    }
+```
+* **Async:** Event handler methods are called in a separate thread. This is always independent from the posting thread and the main thread. Posting events never wait for event handler methods using this mode. Event handler methods should use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+```java
+    // Called in a separate thread
+    public void onEventAsync(MessageEvent event){
+        backend.send(event.message);
+    }
+```
+
+*Note:* EventBus takes care of calling the `onEvent` method in the proper thread depending on its name (onEvent, onEventAsync, etc.).
+
+Subscriber priorities and ordered event delivery
+------------------------------------------------
+You may change the order of event delivery by providing a priority to the subscriber during registration.
+
+```java
+    int priority = 1;
+    EventBus.getDefault().register(this, priority);
+```
+
+Within the same delivery thread (ThreadMode), higher priority subscribers will receive events before others with a lower priority. The default priority is 0. 
+
+*Note*: the priority does *NOT* affect the order of delivery among subscribers with different [ThreadModes](#delivery-threads-and-threadmodes)!
+
+Configure EventBus using EventBusBuilder
+----------------------------------------
+EventBus 2.3 added EventBusBuilder to configure various aspects of EventBus. For example, here's how to build an EventBus that keeps quiet in case a posted event has no subscribers:
+
+```java
+    EventBus eventBus = EventBus.builder().logNoSubscriberMessages(false).sendNoSubscriberEvent(false).build();
+```
+
+Another example is to fail when a subscriber throws an exception. Note: by default, EventBus catches exceptions thrown from onEvent methods and sends a SubscriberExceptionEvent that may but do not have to be handled.
+
+```java
+    EventBus eventBus = EventBus.builder().throwSubscriberException(true).build();
+```
+
+Check the EventBusBuilder class and its JavaDoc for all possible configuration possibilities.
+
+### Configure the default EventBus instance ###
+Using EventBus.getDefault() is a simple way to get a shared EventBus instance. EventBusBuilder also allows to configure this default instance using the method <code>installDefaultEventBus()</code>.
+
+For example, it's possible to configure the default EventBus instance to rethrow exceptions, which occurred in onEvent methods. But let's to this only for DEBUG builds, because this will likely crash the app on exceptions:
+
+```java
+EventBus.builder().throwSubscriberException(BuildConfig.DEBUG).installDefaultEventBus();
+```
+
+Note: this can be done only once before the the default EventBus instance is used the first time. This ensures consistent behavior in your app. Your Application class is a good place to configure the default EventBus instance before its used.
+
+Cancelling event delivery
+-------------------------
+You may cancel the event delivery process by calling `cancelEventDelivery(Object event)` from a subscriber's event handling method. 
+Any further event delivery will be cancelled: subsequent subscribers won't receive the event.
+```java
+    // Called in the same thread (default)
+    public void onEvent(MessageEvent event){
+    	// Process the event 
+    	...
+    	
+    	EventBus.getDefault().cancelEventDelivery(event) ;
+    }
+```
+
+Events are usually cancelled by higher priority subscribers. Cancelling is restricted to event handling methods running in posting thread [ThreadMode.PostThread](#delivery-threads-and-threadmodes).
+
+Sticky Events
+-------------
+Some events carry information that is of interest after the event is posted. For example, this could be an event signalizing that some initialization is complete. Or if you have some sensor or location data and you want to hold on the most recent values. Instead of implementing your own caching, you can use sticky events. EventBus keeps the last sticky event of a certain type in memory. The sticky event can be delivered to subscribers or queried explicitly. Thus, you don't need any special logic to consider already available data.
+
+Let's say, a sticky event was posted some time ago:
+```java
+    EventBus.getDefault().postSticky(new MessageEvent("Hello everyone!"));
+```
+
+After that, a new Activity gets started. During registration using registerSticky, it will immediately get the previously posted sticky event:
+```java
+    @Override
+    public void onStart() {
+        super.onStart();
+        EventBus.getDefault().registerSticky(this);
+    }
+
+    public void onEventMainThread(MessageEvent event) {
+        textField.setText(event.message);
+    }
+
+    @Override
+    public void onStop() {
+        EventBus.getDefault().unregister(this);
+        super.onStop();
+    }
+```
+
+You may also get the last sticky event of a certain type with:
+```java
+    EventBus.getDefault().getStickyEvent(Class<?> eventType)
+```
+
+It's also possible to remove previously posted sticky events using one of the removeStickyEvent methods. They take either a concrete event object, or an event class. Like this it's possible to create consumable events. Keep in mind though that that only the last event of an event type is kept.
+
+ProGuard configuration
+----------------------
+ProGuard obfuscates method names. However, the onEvent methods must not renamed because they are accessed using reflection. Use the following snip in your ProGuard configuration file (proguard.cfg):
+
+```
+-keepclassmembers class ** {
+    public void onEvent*(**);
+}
+
+# Only required if you use AsyncExecutor
+-keepclassmembers class * extends de.greenrobot.event.util.ThrowableFailureEvent {
+    <init>(java.lang.Throwable);
+}
+```
+
+
+AsyncExecutor
+-------------
+_Disclaimer:_ AsyncExecutor is a non-core utility class. It might save you some code with error handling in background threads, but it's not a core EventBus class.
+
+AsyncExecutor is like a thread pool, but with failure handling. Failures are thrown exceptions, which get are wrapped inside an event, which is posted automatically by AsyncExecutor.
+
+Usually, you call AsyncExecutor.create() to create an instance and keep it in Application scope. To execute something, implement the RunnableEx interface and pass it to the execute method of the AsyncExecutor. Unlike Runnable, RunnableEx may throw an Exception.
+
+If the RunnableEx implementation throws an exception, it will be catched and wrapped into a ThrowableFailureEvent, which will be posted.
+
+Code example for execution:
+
+```java
+AsyncExecutor.create().execute(
+  new RunnableEx {
+    public void run throws LoginException {
+      remote.login();
+      EventBus.getDefault().postSticky(new LoggedInEvent());
+      // No need to catch Exception
+    }
+  }
+}
+```
+
+Code example for the receiving part:
+
+```java
+public void onEventMainThread(LoggedInEvent event) {
+  // Change some UI
+}
+
+public void onEventMainThread(ThrowableFailureEvent event) {
+  // Show error in UI
+}
+```
+
+AsyncExecutor Builder
+---------------------
+If you want to customize your AsyncExecutor instance, call the static method AsyncExecutor.builder(). It will return a builder which lets you customize the EventBus instance, the thread pool, and the class of the failure event.
+
+Another customization options is the execution scope, which gives failure events context information. For example, a failure event may be relevant only to a specific Activity instance or class. If your custom failure event class implements the HasExecutionScope interface, AsyncExecutor will set the execution scope automatically. Like this, your subscriber can query the failure event for its execution scope and react depending on it.
+
+
+Comparison with Square's Otto
+-----------------------------
+Check the [COMPARISON.md](COMPARISON.md)
\ No newline at end of file
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 00000000..d6456956
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/README.md b/README.md
index a4cb6b3a..e7c6975b 100644
--- a/README.md
+++ b/README.md
@@ -1,204 +1,85 @@
 EventBus
 ========
-EventBus is an Android optimized publish/subscribe event bus. A typical use case for Android apps is gluing Activities, Fragments, and background threads together. Conventional wiring of those elements often introduces complex and error-prone dependencies and life cycle issues. With EventBus propagating listeners through all participants (e.g. background service -> activity -> multiple fragments or helper classes) becomes deprecated. EventBus decouples event senders and receivers and thus simplifies communication between app components. Less code, better quality. And you don't need to implement a single interface!
-
-General Usage and API
----------------------
-In EventBus, subscribers implement event handling methods and register themselves to the bus. Posted events are delivered to matching event handling methods based on their event type (the Java class/interfaces implemented by the event).
-
-Using EventBus takes four simple steps:
-
-1. Implement any number of event handling methods in the subscriber:<br/>
-<code>public void onEvent(AnyEventType event) {}</code>
-2. Register subscribers:<br/>
-<code>eventBus.register(this);</code>
-3. Post events to the bus:<br/>
+EventBus is publish/subscribe event bus optimized for Android.<br/>
+<img src="EventBus-Publish-Subscribe.png" width="500" height="187"/>
+
+EventBus...
+
+ * simplifies the communication between components
+    * decouples event senders and receivers
+    * performs well with Activities, Fragments, and background threads
+    * avoids complex and error-prone dependencies and life cycle issues
+ * makes your code simpler
+ * is fast
+ * is tiny (<50k jar)
+ * is proven in practice by apps with 100,000,000+ installs
+ * has advanced features like delivery threads, subscriber priorities, etc.
+
+ [![Build Status](https://travis-ci.org/greenrobot/EventBus.svg?branch=master)](https://travis-ci.org/greenrobot/EventBus)
+
+EventBus in 3 steps
+-------------------
+1. Define events:<br/>
+<code>public class MessageEvent { /* Additional fields if needed */ }</code><br/><br/>
+2. Prepare subscribers:<br/>
+<code>eventBus.register(this);</code><br/>
+<code>public void onEvent(AnyEventType event) {/* Do something */};</code><br/><br/>
+3. Post events:<br/>
 <code>eventBus.post(event);</code>
-4. Unregister subscriber:<br/>
-<code>eventBus.unregister(this);</code>
 
 Add EventBus to your project
 ----------------------------
-Starting with version 2.0.1, EventBus is pushed to [Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22) repository, so you can simply add a dependency (group ID "de.greenrobot" and arifact ID "eventbus"). If you do not use Maven or Gradle, download the jar from [Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22) and copy it into the libs folder of your Android project.
+EventBus is available on Maven Central. Please ensure that you are using the latest version by [checking here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22)
 
-Delivery Threads
-----------------
-EventBus can deliver events in other threads independently from the posting thread. Threading is crucial to all Android apps, and EventBus will make threading easier. In Android development, UI changes must be done in the UI thread, while networking is forbidden here. If you want to do both networking and UI using standard Android API, you will need to take care of thread transistions, e.g. by using AsyncTask. If you use an event-based approach using EventBus, this gets simpler.
+Gradle:
+```
+    compile 'de.greenrobot:eventbus:2.4.0'
+```
 
-In EventBus, each event handling method is associated with a thread mode (have a look at the ThreadMode enum). The thread mode defines in which thread the event handling mehtod is called:
-* **PostThread:** Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
-* **MainThread:** Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is the main thread, event handler methods will be called directly. Event handlers using this mode must return quickly to avoid blocking the main thread.
-* **BackgroundThread:** Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single background thread that will deliver all its events sequentially. Event handlers using this mode should try to return quickly to avoid blocking the background thread.
-* **Async:** Event handler methods are called in a separate thread. This is always independent from the posting thread and the main thread. Posting events never wait for event handler methods using this mode. Event handler methods should use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+Maven:
+```
+<dependency>
+    <groupId>de.greenrobot</groupId>
+    <artifactId>eventbus</artifactId>
+    <version>2.4.0</version>
+</dependency>
+```
 
-*Example:* Consider your subscriber updates the UI, but the triggering event is posted by a background thread (using eventBus.post(event)). The name of the event handling method should be onEventMainThread. EventBus takes care of calling the method in the main thread without any further code required
+[Or download EventBus from Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22)
 
-Sticky Events
--------------
-Some events carry information that is of interest after the event is posted. For example, this could be an event signalizing that some initialization is complete. Or if you have some sensor or location data and you want to hold on the most recent values. Instead of implementing your own caching, you can use sticky events. EventBus keeps the last sticky event of a certain type in memory. The sticky event can be delivered to subscribers or queried explicitly. Thus, you don't need any special logic to consider already available data.
+How-to, Developer Documentation
+-------------------------------
+Details on EventBus and its API are available in the [HOWTO document](HOWTO.md).
 
-API-wise events are made sticky by using postSticky(Object event) instead of post(Object event). Subscribers that want to get previously posted sticky events, use registerSticky(...) instead of register(...). Alternatively, the last sticky event of a certain event type can be queried by using getStickyEvent(Class<?> eventType).
+How does EventBus compare to other solutions, like Otto from Square? Check this [comparison](COMPARISON.md).
 
 Additional Features and Notes
 -----------------------------
 
-* **NOT based on annotations:** Querying annotations are slow on Android, especially before Android 4.0. Have a look at this [Android bug report](http://code.google.com/p/android/issues/detail?id=7811)
-* **Based on conventions:** Event handling methods are called "onEvent" (you could supply different names, but this is not encouraged).
-* **Performanced optimized:** It's probably the fastest event bus for Android.
-* **Tiny:** The jar is less than 30 KBytes.
+* **NOT based on annotations:** Querying annotations are slow on Android, especially before Android 4.0. Have a look at this [Android bug report](http://code.google.com/p/android/issues/detail?id=7811).
+* **Based on conventions:** Event handling methods are called "onEvent".
+* **Performance optimized:** It's probably the fastest event bus for Android.
 * **Convenience singleton:** You can get a process wide event bus instance by calling EventBus.getDefault(). You can still call new EventBus() to create any number of local busses.
 * **Subscriber and event inheritance:** Event handler methods may be defined in super classes, and events are posted to handlers of the event's super classes including any implemented interfaces. For example, subscriber may register to events of the type Object to receive all events posted on the event bus.
-* **Selective registration:** It's possible to register only for specific event types. This also allows subscribers to register only some of their event handling methods for main thread event delivery.
-
-Comparison with Square's Otto
------------------------------
-Otto is another event bus library for Android; actually it's a fork of Guava's EventBus. greenrobot's EventBus and Otto share some basic semantics (register, post, unregister, ...), but there are differences which the following table summarizes:
-<table>
-    <tr>
-        <th></th>
-        <th>EventBus</th>
-        <th>Otto</th>
-    </tr>
-    <tr>
-        <th>Declare event handling methods</th>
-        <td>Name conventions</td>
-        <td>Annotations</td>
-    </tr>	
-    <tr>
-        <th>Event inheritance</th>
-        <td>Yes</td>
-        <td>Yes</td>
-    </tr>	
-    <tr>
-        <th>Subscriber inheritance</th>
-        <td>Yes</td>
-        <td>No</td>
-    </tr>
-    <tr>
-        <th>Cache most recent events</th>
-        <td>Yes, sticky events</td>
-        <td>No</td>
-    </tr>
-    <tr>
-        <th>Event producers (e.g. for coding cached events)</th>
-        <td>No</td>
-        <td>Yes</td>
-    </tr>
-    <tr>
-        <th>Event delivery in posting thread</th>
-        <td>Yes (Default)</td>
-        <td>Yes</td>
-    </tr>	
-    <tr>
-        <th>Event delivery in main thread</th>
-        <td>Yes</td>
-        <td>No</td>
-    </tr>	
-    <tr>
-        <th>Event delivery in background thread</th>
-        <td>Yes</td>
-        <td>No</td>
-    </tr>	
-    <tr>
-        <th>Aynchronous event delivery</th>
-        <td>Yes</td>
-        <td>No</td>
-    </tr>
-</table>
-
-Besides features, performance is another differentiator. To compare performance, we created an Android application, which is also part of this repository (EventBusPerformance). You can also run the app on your phone to benchmark different scenarios.
-
-Benchmark results indicate that EventBus is significantly faster in almost every scenario:
-<table>
-    <tr>
-        <th></th>
-        <th>EventBus</th>
-        <th>Otto</th>
-    </tr>
-    <tr>
-        <th>Posting 1000 events, Android 2.3 emulator</th>
-        <td>~70% faster</td>
-        <td></td>
-    </tr>
-	<tr>
-        <th>Posting 1000 events, S3 Android 4.0</th>
-        <td>~110% faster</td>
-        <td></td>
-    </tr>
-    <tr>
-        <th>Register 1000 subscribers, Android 2.3 emulator</th>
-        <td>~10% faster</td>
-        <td></td>
-    </tr>
-    <tr>
-        <th>Register 1000 subscribers, S3 Android 4.0</th>
-        <td>~70% faster</td>
-        <td></td>
-    </tr>
-    <tr>
-        <th>Register subscribers cold start, Android 2.3 emulator</th>
-        <td>~350% faster</td>
-        <td></td>
-    </tr>	
-    <tr>
-        <th>Register subscribers cold start, S3 Android 4.0</th>
-        <td colspan="2">About the same</td>
-    </tr>	
-</table>
-
-ProGuard configuration
-----------------------
-ProGuard obfuscates method names. However, the onEvent methods must not renamed because they are accessed using reflection. Use the following snip in your ProGuard configuration file (proguard.cfg):
-<pre><code>-keepclassmembers class ** {
-    public void onEvent*(**);
-}
-</code></pre>
-
-Example
--------
-TODO
 
 FAQ
 ---
-**Q:** How's EventBus different to Android's BroadcastReceiver/Intent system?<br/>
-**A:** Unlike Android's BroadcastReceiver/Intent system, EventBus uses standard Java classes as events and offers a more convenient API. EventBus is intended for a lot more uses cases where you wouldn't want to go through the hassle of setting up Intents, preparing Intent extras, implementing broadcast receivers, and extracting Intent extras again. Also, EventBus comes with a much lower overhead. 
-
-Release History
----------------
-### V2.0.1 (2013-02-25) Bug fix release, Gradle and Maven Central
-* Fixed #15: removeStickyEvent(...) does not remove event the first time
-* Introduced Gradle build scripts for main project
-* Maven artifacts are pushed to Maven Central starting with this version
-* Added Travis CI
-
-### V2.0.0 (2012-10-23) Major feature release
-* Event methods define for themselves in which thread they get called. This is done by providing "modifiers" to the method name, e.g. onEventMainThread is called by the main thread without further configuration. Have a look at the JavaDoc of the enum ThreadMode for all available thread modes.
-* The event method modifiers replace registerForMainThread methods. Moving this information to the method itself should make things clearer.
-* Using event method modifiers, subscribers can receive the same event type in different threads if they choose to.
-* New "BackgroundThread" modifier for onEvent handler methods ensures that event handler methods are called in a background thread. If an event is posted from a non-main thread, handler methods will be called directly. If posted from the main thread, EventBus will use a background thread to call the handler methods.
-* New "Async" modifier for onEvent handler methods ensures that each event handler method is called completely asynchronously.
-* Better performance: Delivery of multiple events in the main thread got significantly faster.
-* Added sticky events, which are inspired by sticky broadcasts of the Android system. EventBus keeps the most recent sticky events in memory. Subscribers registering with the new method registerSticky, will receive sticky events right away. You can also query and remove sticky events (methods getStickyEvent and removeStickyEvent).
-* By listening to SubscriberExceptionEvent, it is possible to react to Exceptions occuring in subscribers.
-* Bug fixes, and internal refactorings
-
-### V1.0.1 (2012-07-31): Important bug fix release
-Please update! Now, EventBus.unregister releases all internal references to the subscriber.
-
-### V1.0.0 (2012-07-16): First public release
-
-License
--------
-Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-  http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+**Q:** How is EventBus different to Android's BroadcastReceiver/Intent system?<br/>
+**A:** Unlike Android's BroadcastReceiver/Intent system, EventBus uses standard Java classes as events and offers a more convenient API. EventBus is intended for a lot more uses cases where you wouldn't want to go through the hassle of setting up Intents, preparing Intent extras, implementing broadcast receivers, and extracting Intent extras again. Also, EventBus comes with a much lower overhead.
+
+ **Q:** How to do pull requests?<br/>
+ **A:** Ensure good code quality and consistent formatting. EventBus has a good test coverage: if you propose a new feature or fix a bug, please add a unit test.
+
+Release History, License
+------------------------
+[CHANGELOG](CHANGELOG.md)
+
+EventBus binaries and source code can be used according to the [Apache License, Version 2.0](LICENSE).
+
+More Open Source by greenrobot
+==============================
+[__greenrobot-common__](https://github.com/greenrobot/greenrobot-common) is a set of utility classes and hash functions for Android & Java projects.
+
+[__greenDAO__](https://github.com/greenrobot/greenDAO) is an ORM optimized for Android: it maps database tables to Java objects and uses code generation for optimal speed.
+
+[Follow us on Google+](https://plus.google.com/b/114381455741141514652/+GreenrobotDe/posts) to stay up to date.
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..c97a8bdb
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..c8dcd502
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Sun Feb 22 14:20:02 CET 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..8a0b282a
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/settings.gradle b/settings.gradle
index e060990c..76c570b0 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1,3 @@
-include 'EventBus'
\ No newline at end of file
+include 'EventBus'
+include 'EventBusTest'
+include 'EventBusPerformance'
