diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 558dc8ae..5f4b6de2 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -18,6 +18,7 @@
 import android.text.TextUtils;
 
 import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -145,18 +146,23 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
-        Class<?> subscriberClass = subscriber.getClass();
+        Class<?> subscriberClass;
         // harryguo add start. shall end with "// harryguo add end"
         // 允许调用者注册静态函数类型的订阅者
         if (subscriber instanceof Class<?>)
             subscriberClass = (Class<?>) subscriber;
+        else
+            subscriberClass = subscriber.getClass();
         // harryguo add end. shall begin with "// harryguo add start"
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 // harryguo add start. shall end with "// harryguo add end"
                 // subscribe(subscriber, subscriberMethod);
-                // 如果是排他性的订阅者，那就要把已经注册了该事件的其他订阅者先删除掉
+                // 如果register的是类class（XXX.class），而非类的实例(XXX xxx = new XXX())，也行，但这种注册方式里，仅支持注册静态函数（因为没有实例，无法调用非静态函数）
+                if (subscriber instanceof Class<?> && (subscriberMethod.method.getModifiers() & Modifier.STATIC) == 0)
+                    continue;
+                    // 如果是排他性的订阅者，那就要把已经注册了该事件的其他订阅者先删除掉
                 // 将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
                 if (subscriberMethod.exclusive) {
                     if (!TextUtils.isEmpty(subscriberMethod.eventId))
@@ -286,7 +292,7 @@ public synchronized void unregister(Object subscriber) {
 
         // harryguo add start. shall end with "// harryguo add end"
         List<String> subscribedIds = idsBySubscriber.get(subscriber);
-        if (subscribedTypes != null) {
+        if (subscribedIds != null) {
             for (String eventId : subscribedIds) {
                 unsubscribeByEventId(subscriber, eventId);
             }
@@ -709,81 +715,48 @@ public boolean hasSubscriberForEvent(String eventId) {
         return false;
     }
 
+    public Object process(Object eventContent) {
+        return process(eventContent, null);
+    }
+
     public Object process(Object eventContent, int eventId) {
         return process(eventContent, String.valueOf(eventId));
     }
 
     public Object process(Object eventContent, String eventId) {
         Object retValue = null;
-        if (TextUtils.isEmpty(eventId)) {
-            // 支持EventBus的原始调用方式（无eventId，只有eventContent的方式）
-            retValue = process(eventContent);
-        }
-        else {
-            boolean subscriptionFound = false;
-            CopyOnWriteArrayList<Subscription> subscriptions;
-            synchronized (this) {
-                subscriptions = subscriptionsByEventId.get(eventId);
-            }
-            // 只调用一个处理者
-            if (subscriptions != null && !subscriptions.isEmpty()) {
-                Subscription subscription = subscriptions.get(0);
-                Class<?> eventType = subscription.subscriberMethod.eventType;
-                if (eventContent == null || (eventType != null && eventType.isInstance(eventContent))) {
-                    try {
-                        retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, eventContent);
-                    } catch (InvocationTargetException e) {
-                        handleSubscriberException(subscription, eventContent, e.getCause());
-                    } catch (IllegalAccessException e) {
-                        throw new IllegalStateException("Unexpected exception", e);
-                    }
-                    subscriptionFound = true;
-                }
+        boolean subscriptionFound = false;
+        CopyOnWriteArrayList<Subscription> subscriptions;
+        synchronized (this) {
+            if (TextUtils.isEmpty(eventId)) {
+                // 支持EventBus的原始调用方式（无eventId，只有eventContent的方式）
+                subscriptions = subscriptionsByEventType.get(eventContent.getClass());
             }
-            if (!subscriptionFound) {
-                if (logNoSubscriberMessages) {
-                    logger.log(Level.FINE, "No subscribers registered for event " + eventId);
-                }
-                if (sendNoSubscriberEvent) {
-                    post(new NoSubscriberEvent(this, eventContent));
-                }
+            else {
+                subscriptions = subscriptionsByEventId.get(eventId);
             }
         }
-        return retValue;
-    }
-
-    /**
-     * 默认process
-     * 调用订阅者，并获得返回值（关键在于：只调用第一个订阅者，其他的订阅者直接忽略。程序设计之初就假定这种订阅者只有一个，多了那是程序失误）
-     */
-    public Object process(Object event) {
-        Object retValue = null;
-        {
-            Class<?> eventClass = event.getClass();
-            boolean subscriptionFound = false;
-
-            CopyOnWriteArrayList<Subscription> subscriptions;
-            synchronized (this) {
-                subscriptions = subscriptionsByEventType.get(eventClass);
-            }
-            if (subscriptions != null && !subscriptions.isEmpty()) {
-                Subscription subscription = subscriptions.get(0);
+        // 只调用一个处理者
+        if (subscriptions != null && !subscriptions.isEmpty()) {
+            Subscription subscription = subscriptions.get(0);
+            Class<?> eventType = subscription.subscriberMethod.eventType;
+            if (eventContent == null || (eventType != null && eventType.isInstance(eventContent))) {
                 try {
-                    retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
+                    retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, eventContent);
                 } catch (InvocationTargetException e) {
-                    handleSubscriberException(subscription, event, e.getCause());
+                    handleSubscriberException(subscription, eventContent, e.getCause());
                 } catch (IllegalAccessException e) {
                     throw new IllegalStateException("Unexpected exception", e);
                 }
                 subscriptionFound = true;
             }
-            if (!subscriptionFound) {
-                if (logNoSubscriberMessages) {
-                    logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
-                }
-                if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class && eventClass != SubscriberExceptionEvent.class) {
-                    post(new NoSubscriberEvent(this, event));
-                }
+        }
+        if (!subscriptionFound) {
+            if (logNoSubscriberMessages) {
+                logger.log(Level.FINE, "No subscribers registered for event " + eventId);
+            }
+            if (sendNoSubscriberEvent) {
+                post(new NoSubscriberEvent(this, eventContent));
             }
         }
         return retValue;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 5fdd9fbb..efd6d173 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -183,7 +183,7 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                 String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                 throw new EventBusException(methodName +
-                        " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
+                        " is a illegal @Subscribe method: must be public, and non-abstract");
             }
         }
     }
