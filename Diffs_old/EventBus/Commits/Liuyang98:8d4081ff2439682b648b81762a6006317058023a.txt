diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..44296f9d 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -38,7 +38,9 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
@@ -76,7 +78,13 @@ protected PostingThreadState initialValue() {
     private final int indexCount;
     private final Logger logger;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Ly__获取默认实例， 单例
+     * 模式,也可以通过构造方法创建。
+     * <p>
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
+
     public static EventBus getDefault() {
         EventBus instance = defaultInstance;
         if (instance == null) {
@@ -94,7 +102,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -130,6 +140,8 @@ public EventBus() {
     }
 
     /**
+     * //注册，将一个对象注册到事件总线中
+     * <p>
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
      * are no longer interested in receiving events.
      * <p/>
@@ -138,8 +150,11 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        //获取对象的类型
         Class<?> subscriberClass = subscriber.getClass();
+        //获得 订阅封装类 List
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+//       遍历订阅封装类，逐个调用subscribe订阅
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
@@ -148,9 +163,18 @@ public void register(Object subscriber) {
     }
 
     // Must be called in synchronized block
+
+    /**
+     *
+     * @param subscriber
+     * @param subscriberMethod
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+//      获取到订阅的事件类型（通过Class类区分）
         Class<?> eventType = subscriberMethod.eventType;
+//       将订阅封装类和订阅对象 再次封装
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+//        从MAP中获取该事件类型的订阅列表，如果没有，则创建，并添加到MAP中
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,6 +186,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+//    按优先级将 新订阅封装类添加到该事件类型的订阅列表中。
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -170,13 +195,17 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+//      通过订阅对象，获取该订阅对象所对应的订阅事件列表。 如果没有，则创建，并添加到MAP中
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
+
+//      将该事件加入订阅
         subscribedEvents.add(eventType);
 
+//        判断是否粘性事件
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
@@ -187,6 +216,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
                     if (eventType.isAssignableFrom(candidateEventType)) {
+//                       从stickyEvent中获取对应的事件交给当前事件订阅者处理
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
@@ -220,7 +250,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -237,7 +269,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -250,12 +284,15 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
+        //获取当前线程状态和事件列表，并且将事件加入列表中。
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
-
+//      如果不是在posting中，则执行
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
@@ -264,9 +301,11 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+//                    开始一个个post 分发列表中的事件
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
+//              posting完后，取消标记
                 postingState.isPosting = false;
                 postingState.isMainThread = false;
             }
@@ -388,6 +427,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         } else {
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
+//        如果没有事件，则会发布一个NoSubscriberEvent
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
                 logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
@@ -399,20 +439,32 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     *
+     * @param event
+     * @param postingState
+     * @param eventClass
+     * @return 是否有事件
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
+//      获取到该事件对应的订阅列表（存着订阅封装类）
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
+//        遍历订阅封装类，进行下发
         if (subscriptions != null && !subscriptions.isEmpty()) {
             for (Subscription subscription : subscriptions) {
+//              将post的参数传给postingState
                 postingState.event = event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+//                   进行具体下发事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
+//             一个post完后，清除 postingState中的数据
                     postingState.event = null;
                     postingState.subscription = null;
                     postingState.canceled = false;
@@ -426,6 +478,12 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 开始下发事件，并且根据ThreadMode作不同的下发处理
+     * @param subscription
+     * @param event
+     * @param isMainThread
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -461,7 +519,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -479,7 +539,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -540,7 +602,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..7e6fbb3d 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -41,7 +41,7 @@
     private List<SubscriberInfoIndex> subscriberInfoIndexes;
     private final boolean strictMethodVerification;
     private final boolean ignoreGeneratedIndex;
-
+    //   缓存大小
     private static final int POOL_SIZE = 4;
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
 
@@ -53,11 +53,12 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+//      判断是否有缓存，有的话直接返回缓存信息
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+//        无缓存，则开始遍历类中的方法，生成订阅封装类的列表。
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
@@ -67,14 +68,30 @@
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+//            将遍历生成的订阅封装类，缓存在MAP中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
     }
 
+    private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        //获取一个FindState
+        FindState findState = prepareFindState();
+        //传入当前类
+        findState.initForSubscriber(subscriberClass);
+        //循环遍历，子类遍历完后，继续检查父类中的方法
+        while (findState.clazz != null) {
+            findUsingReflectionInSingleClass(findState);
+            findState.moveToSuperclass();
+        }
+        return getMethodsAndRelease(findState);
+    }
+
+    //    3.0新加，比反射快，编译期完成的注册，不是运行期
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
+        //用于循环遍历，子类遍历完后，继续遍历父类
         while (findState.clazz != null) {
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
@@ -92,9 +109,17 @@
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 获取FindState中的订阅封装类 列表，并且返回给调用者
+     * @param findState
+     * @return
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+//        获取FindState中 封装好的 SubscriberMethod类 的列表
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
+//        清除FindState类中的信息
         findState.recycle();
+        //遍历，如果有位置，则将FindState放入（缓存），配合prepareFindState
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
                 if (FIND_STATE_POOL[i] == null) {
@@ -106,6 +131,7 @@
         return subscriberMethods;
     }
 
+    //    尝试获取FindState对象，如果获取不到，则创建一个对象。避免重复new
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
@@ -137,16 +163,10 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
-    private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
-        findState.initForSubscriber(subscriberClass);
-        while (findState.clazz != null) {
-            findUsingReflectionInSingleClass(findState);
-            findState.moveToSuperclass();
-        }
-        return getMethodsAndRelease(findState);
-    }
-
+    /**
+     * 开始遍历类中的方法
+     * @param findState
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
@@ -157,16 +177,22 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+        //开始遍历所有方法
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            //判断是否public，检查修饰符
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                //获取参数列表
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                //要求参数仅为1个
                 if (parameterTypes.length == 1) {
+                    //通过注解，获取信息
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            //将注解等数据封装成 SubscriberMethod 类，然后加到findState中的List里
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
