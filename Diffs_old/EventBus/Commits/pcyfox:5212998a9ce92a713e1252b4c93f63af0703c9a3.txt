diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..8cff7022 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -138,7 +138,9 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        //获取了订阅者的class对象
         Class<?> subscriberClass = subscriber.getClass();
+        //找出注册的类中所有订阅的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -151,7 +153,9 @@ public void register(Object subscriber) {
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
@@ -163,6 +167,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
 
         int size = subscriptions.size();
+        //将优先级高的家在前面
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
@@ -171,13 +176,16 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
 
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
+
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
+
         subscribedEvents.add(eventType);
 
         if (subscriberMethod.sticky) {
+            //初始化时默认eventInheritance=true
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -442,6 +450,7 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 if (mainThreadPoster != null) {
                     mainThreadPoster.enqueue(subscription, event);
                 } else {
+                    //如果mainThreadPoster==null即在非主线程中，就会直接调用注册的方法
                     // temporary: technically not correct as poster not decoupled from subscriber
                     invokeSubscriber(subscription, event);
                 }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..3892ad7b 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,16 +53,19 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //先从缓存池中获取，METHOD_CACHE是一个数组
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //默认为false
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //默认执行这里
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
@@ -73,8 +76,9 @@
     }
 
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
+        FindState findState = prepareFindState();//与subscriberMethods一样，先从缓存获取，没有就创建
         findState.initForSubscriber(subscriberClass);
+
         while (findState.clazz != null) {
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
@@ -87,8 +91,10 @@
             } else {
                 findUsingReflectionInSingleClass(findState);
             }
+            //当skipSuperClasses=true或遇到系统相关的类时clazz = null，退出循环;
             findState.moveToSuperclass();
         }
+        //将findState添加至FIND_STATE_POOL，并返回findState。
         return getMethodsAndRelease(findState);
     }
 
@@ -119,6 +125,7 @@ private FindState prepareFindState() {
         return new FindState();
     }
 
+    //初始化的时候，findState.subscriberInfo和subscriberInfoIndexes为空，所以这里直接返回null
     private SubscriberInfo getSubscriberInfo(FindState findState) {
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
@@ -147,16 +154,18 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return getMethodsAndRelease(findState);
     }
 
+    //通过反射或methods，找到有相关注解的方法.
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
-            methods = findState.clazz.getDeclaredMethods();
+            methods = findState.clazz.getDeclaredMethods();//获得所有方法，但不包括继承的方法（执行速度快）
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
-            methods = findState.clazz.getMethods();
+            methods = findState.clazz.getMethods();//获取所有公有方法，包括所有继承的。（继承层次深，速度就慢）
             findState.skipSuperClasses = true;
         }
+
         for (Method method : methods) {
             int modifiers = method.getModifiers();
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
@@ -164,9 +173,10 @@ private void findUsingReflectionInSingleClass(FindState findState) {
                 if (parameterTypes.length == 1) {
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
-                        Class<?> eventType = parameterTypes[0];
+                        Class<?> eventType = parameterTypes[0];//方法注册的Class
                         if (findState.checkAdd(method, eventType)) {
-                            ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            ThreadMode threadMode = subscribeAnnotation.threadMode();//获取线程模式
+                            //构建SubscriberMethod并添加至findState
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
