diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..528753b9 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -40,7 +40,9 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
@@ -74,7 +76,9 @@ protected PostingThreadState initialValue() {
 
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -90,7 +94,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -126,14 +132,21 @@ public EventBus() {
     /**
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
      * are no longer interested in receiving events.
-     * <p/>
+     * <p>
      * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
      */
+    /**
+     * @param subscriber 需要参与订阅的独享，可以是Activity，Fragment.
+     * subscriber里需要有处理事件的@Subscribe注解方法，注解参数有threadMode处理线程，sticky是否延迟事件，priority优先级
+     *
+     */
     public void register(Object subscriber) {
+        //获取订阅者类类型.class
         Class<?> subscriberClass = subscriber.getClass();
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+        //获取订阅者类里的注解订阅方法
+        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);//进入方法>>>
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
@@ -143,19 +156,23 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        //获取订阅方法的返回类型
         Class<?> eventType = subscriberMethod.eventType;
+        //创建订阅协议
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        //Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        //如果没有该事件类型的订阅协议则创建该事件类型的集合容器
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
-        } else {
-            if (subscriptions.contains(newSubscription)) {
+        } else {//如果有该事件类型的集合容器
+            if (subscriptions.contains(newSubscription)) {//如果事件协议里已经有该协议则提示已经存在
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
             }
         }
-
+        //存在该事件类型的事件协议集合，则遍历优先级，如果优先级高则插入前面
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -163,14 +180,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 break;
             }
         }
-
+        //按点阅者添加事件类型
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
         subscribedEvents.add(eventType);
-
+        //如果是sticky事件
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
@@ -204,7 +221,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -221,7 +240,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -234,7 +255,9 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
@@ -247,6 +270,7 @@ public void post(Object event) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                //如果队里里有事件，则一直发送
                 while (!eventQueue.isEmpty()) {
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
@@ -394,6 +418,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    //发送给订阅者
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -412,9 +437,18 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
+
+            /**
+             *PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI
+             * 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；
+             */
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
+            /**
+             * MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler
+             * 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；
+             */
             case MAIN:
                 if (isMainThread) {
                     invokeSubscriber(subscription, event);
@@ -422,6 +456,12 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
+            /**
+             * BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，
+             * 否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，
+             * 因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的
+             * 轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；
+             */
             case BACKGROUND:
                 if (isMainThread) {
                     backgroundPoster.enqueue(subscription, event);
@@ -429,6 +469,10 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     invokeSubscriber(subscription, event);
                 }
                 break;
+            /**
+             * Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程
+             * 是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。
+             */
             case ASYNC:
                 asyncPoster.enqueue(subscription, event);
                 break;
@@ -437,7 +481,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -455,7 +501,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -516,7 +564,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..71e6fee2 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,25 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //根据private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
+        // 得知METHOD_CACHE 是以订阅者类类型为键，订阅者订阅方法容器为值得缓存容器。
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
+        //如果在缓存容器里找到缓存方法集合则直接返回
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //没有缓存，执行
+        //利用反射查找注解，动态加载
         if (ignoreGeneratedIndex) {
-            subscriberMethods = findUsingReflection(subscriberClass);
-        } else {
+            subscriberMethods = findUsingReflection(subscriberClass);//进入方法>>>
+        } else {//利用注解器查找注解，静态加载
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //找到注解方法后存入缓存
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -137,7 +142,13 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 用反射方式获取订阅方法
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        //从FindState池里取一个FindState
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
@@ -159,8 +170,10 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            //订阅方法只能是public修饰
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                //订阅方法只能有1个事件参书
                 if (parameterTypes.length == 1) {
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/KingJATestActviity.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/KingJATestActviity.java
new file mode 100644
index 00000000..15d67e61
--- /dev/null
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/KingJATestActviity.java
@@ -0,0 +1,20 @@
+package org.greenrobot.eventbusperf.testsubject;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+import org.greenrobot.eventbus.EventBus;
+
+/**
+ * Description:TODO
+ * Create Time:2017/4/10 13:39
+ * Author:KingJA
+ * Email:kingjavip@gmail.com
+ */
+public class KingJATestActviity extends Activity {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        EventBus.getDefault().register(this);
+    }
+}
