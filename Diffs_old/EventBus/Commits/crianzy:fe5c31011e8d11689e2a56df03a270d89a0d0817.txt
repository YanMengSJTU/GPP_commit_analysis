diff --git a/EventBus/build.gradle b/EventBus/build.gradle
index 50637de7..b1acbb3d 100644
--- a/EventBus/build.gradle
+++ b/EventBus/build.gradle
@@ -28,11 +28,14 @@ configurations {
 }
 
 dependencies {
+    // 这些provided 编译时需要 但是 别人引用我这 moduel 的时候 不会引用这些
     provided 'com.google.android:android:4.1.1.4'
     provided 'com.google.android:android-test:4.1.1.4'
     provided 'com.google.android:annotations:4.1.1.4'
     provided 'com.google.android:support-v4:r7'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
+    // maven 上传 需要用到的
+    // https://docs.gradle.org/current/userguide/maven_plugin.html
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
index a56f4ebf..68234b7c 100644
--- a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
@@ -34,6 +34,7 @@
     public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         queue.enqueue(pendingPost);
+        // 每次 都在线程池中执行
         eventBus.getExecutorService().execute(this);
     }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 2a5319d0..cc60335b 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -19,7 +19,11 @@
 
 /**
  * Posts events in background.
- * 
+ *
+ * 如果 发送事件的  不是主线程 那么 就和 发送事件的线程一直
+ * 如果 发送事件的  是主线程 那么 会使用一个独立的线
+ *
+ * 执行的订阅方法不能耗时 , 不然会阻塞 其他事件的发送
  * @author Markus
  */
 final class BackgroundPoster implements Runnable {
@@ -27,6 +31,7 @@
     private final PendingPostQueue queue;
     private final EventBus eventBus;
 
+    // 线程是否在执行
     private volatile boolean executorRunning;
 
     BackgroundPoster(EventBus eventBus) {
@@ -39,6 +44,7 @@ public void enqueue(Subscription subscription, Object event) {
         synchronized (this) {
             queue.enqueue(pendingPost);
             if (!executorRunning) {
+                // 如果不在执行的话
                 executorRunning = true;
                 eventBus.getExecutorService().execute(this);
             }
@@ -49,6 +55,7 @@ public void enqueue(Subscription subscription, Object event) {
     public void run() {
         try {
             try {
+                // 这里循环 是为了保证 在一个线程中 就能发送挖 所有的事件
                 while (true) {
                     PendingPost pendingPost = queue.poll(1000);
                     if (pendingPost == null) {
@@ -61,6 +68,7 @@ public void run() {
                             }
                         }
                     }
+                    // 执行订阅方法
                     eventBus.invokeSubscriber(pendingPost);
                 }
             } catch (InterruptedException e) {
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..599ab639 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,12 +46,21 @@
     static volatile EventBus defaultInstance;
 
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+
+    // 这个是考虑事件 继承关系的时候 会用到,  就是 一个 事件 类型  对应 它的所有的父类 和 接口
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    // 一个事件类型 对应所有的 Subscription 观察者集合
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+    // 一个 观察者 对应所有的 它订阅的事件类型
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+
+    // 一个保存粘性事件 类型 和 对应的粘性事件对象
     private final Map<Class<?>, Object> stickyEvents;
 
+    // 这个是 表示 一个 线程都有个字独立的 PostingThreadState 线程之间互相不影响
+    // 这里是 每个线程的状态 都是独立的
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -59,22 +68,75 @@ protected PostingThreadState initialValue() {
         }
     };
 
+    /**
+     * 给主线程 发送 事件用的 Handler
+     */
     private final HandlerPoster mainThreadPoster;
+
+    /**
+     * 给哈欧泰线程 发送用的 Handler
+     */
     private final BackgroundPoster backgroundPoster;
+
+    /**
+     * 给异步线程用的, 不同于 主线程 也不同于 事件发送线程
+     */
     private final AsyncPoster asyncPoster;
+
+    /**
+     * 寻找订阅方法的工具类
+     */
     private final SubscriberMethodFinder subscriberMethodFinder;
+
+    /**
+     * 线程池
+     */
     private final ExecutorService executorService;
 
+    /**
+     * 出错时 是否发送 异常事件
+     */
     private final boolean throwSubscriberException;
+
+    /**
+     * 是否打印 异常事件
+     */
     private final boolean logSubscriberExceptions;
+
+    /**
+     * 是否 打印 没有订阅者的日志
+     */
     private final boolean logNoSubscriberMessages;
+
+    /**
+     * 当出现异常时 是否发送 异常事件
+     */
     private final boolean sendSubscriberExceptionEvent;
+
+    /**
+     * 当没有 订阅者的时候 是否发送一个 没有订阅者的事件
+     */
     private final boolean sendNoSubscriberEvent;
+
+    /**
+     * 是否需要考虑的 事件的 继承关系
+     * 即 如果 post 了事件 A
+     * 但是 A 是继承 B
+     *
+     * 如果这个 设置为true
+     * 那么 订阅B 的订阅者  也能接收到 事件A
+     *
+     */
     private final boolean eventInheritance;
 
+    /**
+     * 索引数量
+     */
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /** Convenience singleton for apps using a process-wide EventBus instance.
+     * 单例
+     * */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -86,6 +148,9 @@ public static EventBus getDefault() {
         return defaultInstance;
     }
 
+    /**
+     * 获取一个 EventBusBuilder
+     */
     public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
@@ -99,11 +164,17 @@ public static void clearCaches() {
     /**
      * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
      * central bus, consider {@link #getDefault()}.
+     *
+     * 可以自己 直接 new 一个EventBus  不过建议使用 getDefault  单例模式
      */
     public EventBus() {
         this(DEFAULT_BUILDER);
     }
 
+    /**
+     * 通过build 设置相关参数
+     * @param builder
+     */
     EventBus(EventBusBuilder builder) {
         subscriptionsByEventType = new HashMap<>();
         typesBySubscriber = new HashMap<>();
@@ -130,9 +201,12 @@ public EventBus() {
      * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
+     *
+     * 注册
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        // 找到所有 加了注解的 订阅方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -143,13 +217,19 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        // 事件的类
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+
+        // subscriptionsByEventType 是一个 事件类型 和 订阅者集合 的 HashMap
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        // 寻找 这个事件 类型的  这个 subscriber 是否已经注册了
         if (subscriptions == null) {
+            // 说明没有被注册
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            // 注册了 抛出异常
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
@@ -159,39 +239,64 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
+                // 把订阅者 加入到列表中去
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
 
+        // 更具订阅者 找到 事件类型的集合
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
+        //该订阅者的事件集合 中 加入该事件类型
         subscribedEvents.add(eventType);
 
         if (subscriberMethod.sticky) {
+            // 如果是粘性的
             if (eventInheritance) {
+                // 这里是考虑 粘性事件的父类
+                /// 是这样, 如果已经存在粘性事件 A
+                // 然后这里 订阅了一个 粘性事件B 但是 A 继承于B  B 是 A 的父类 理论上 订阅在 也能接收事件A
+                // 但是此时粘性事件 的集合中 是没有B  只有A
+                // 但是由于这集考虑了 事件的继承关系
+                // 所以 这里 这里 会吧A 事件 发送给订阅者
+
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
                 // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
+                    // 遍历所有的粘性 事件类型
                     Class<?> candidateEventType = entry.getKey();
                     if (eventType.isAssignableFrom(candidateEventType)) {
+                        // 这里 eventType.isAssignableFrom(candidateEventType) 的意思是 eventType 是是否是 candidateEventType 父类
+
+                        // 如果当前 的 事件类型  是 刚刚遍历出来的事件类型 的父类的话  或者 类名一样就是好本身
+                        // 那么就 发送这个事件类型
                         Object stickyEvent = entry.getValue();
+                        // 这里发送的是 粘性事件 集合中的 事件,  可能不是刚刚 等于的事件
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
                 }
             } else {
+                // 获取粘性事件对象
                 Object stickyEvent = stickyEvents.get(eventType);
+                // 然后把这个 粘性事件 发送出去 ,  记住 这时候 没有 post发送事件
+                // 这是 粘性事件的特性,  你只要丁雨晴粘性事件 然后 这个粘性事件 还没死 那么 你就能立马 收到事件
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
     }
 
+    /**
+     * 检查并发送  粘性事件
+     * @param newSubscription
+     * @param stickyEvent
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
@@ -204,7 +309,11 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     * 解注册 观察者
+     * 主需要吧 该对象
+     * 从 Map<Class, CopyOnWriteArrayList<Subscription>> 事件类型 对应的 观察集者结婚
+     * */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -221,26 +330,40 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /** Unregisters the given subscriber from all event classes.
+     *
+     * 解注册 观察者
+     *
+     * 主需要吧 该对象 从相关集合中移除即可
+     * */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
+            // Map<Object, List<Class<?>>> typesBySubscriber;  观察者 对应的 事件类型集合
             typesBySubscriber.remove(subscriber);
         } else {
             Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /** Posts the given event to the event bus.
+     *  发送事件
+     * */
     public void post(Object event) {
+        // 获取当前线程状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        // 获取当前线程的事件队列
         List<Object> eventQueue = postingState.eventQueue;
+        // 队列中加入事件
         eventQueue.add(event);
 
         if (!postingState.isPosting) {
+            // 如果不在 Posting状态
+
+            // 更新状态
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             postingState.isPosting = true;
             if (postingState.canceled) {
@@ -248,6 +371,7 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    // 发送事件
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -283,6 +407,8 @@ public void cancelEventDelivery(Object event) {
     /**
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
+     *
+     * 这里除了把粘性事件 发送出去 还会 保存一份
      */
     public void postSticky(Object event) {
         synchronized (stickyEvents) {
@@ -359,33 +485,53 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 发送事件
+     * @param event
+     * @param postingState
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            // 如果考虑 继承关系的话
+            // 找到该事件类型的 所有父类 接口集合
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
                 Class<?> clazz = eventTypes.get(h);
+                // 发送事件
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            //不考虑继承关系  只发送 做一个 类型 的事件
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
+            // 没找到订阅者
             if (logNoSubscriberMessages) {
                 Log.d(TAG, "No subscribers registered for event " + eventClass);
             }
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
+                // 发送一个 NoSubscriberEvent  表示没有订阅者
                 post(new NoSubscriberEvent(this, event));
             }
         }
     }
 
+    /**
+     * 发送 单一事件类型的 事件 不考虑 父类
+     * @param event
+     * @param postingState
+     * @param eventClass
+     * @return
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            // 获取所有的订阅者
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
@@ -394,7 +540,9 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 发送的具体方法
                     postToSubscription(subscription, event, postingState.isMainThread);
+                    // 检查是否终端
                     aborted = postingState.canceled;
                 } finally {
                     postingState.event = null;
@@ -410,6 +558,9 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 具体 吧事件 发送到 订阅者的分发方法
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -424,8 +575,10 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 break;
             case BACKGROUND:
                 if (isMainThread) {
+                    //  这里做了判断 如果是主线 那么就是用 backgroundPoster
                     backgroundPoster.enqueue(subscription, event);
                 } else {
+                    // 否则 直接执行
                     invokeSubscriber(subscription, event);
                 }
                 break;
@@ -437,13 +590,17 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     *
+     * 更具 一个事件类型  找到 它所有的 父类 接口类型集合
+     * */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
             if (eventTypes == null) {
                 eventTypes = new ArrayList<>();
                 Class<?> clazz = eventClass;
+                // 吧所有的父类 接口 都加入到集合
                 while (clazz != null) {
                     eventTypes.add(clazz);
                     addInterfaces(eventTypes, clazz.getInterfaces());
@@ -455,7 +612,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /** Recurses through super interfaces.
+     * 回调加入所有的接口
+     * */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -480,16 +639,30 @@ void invokeSubscriber(PendingPost pendingPost) {
         }
     }
 
+    /**
+     * 执行 订阅方法
+     * @param subscription
+     * @param event
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            // 发射执行方法
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
+            // 不知 执行方法时的异常
             handleSubscriberException(subscription, event, e.getCause());
         } catch (IllegalAccessException e) {
             throw new IllegalStateException("Unexpected exception", e);
         }
     }
 
+    /**
+     * 处理 异常情况 打印 一些 信息
+     * 如果事件 不是 SubscriberExceptionEvent 事件 那么 这个方法 会一个 SubscriberExceptionEvent 事件
+     * @param subscription
+     * @param event
+     * @param cause
+     */
     private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
         if (event instanceof SubscriberExceptionEvent) {
             if (logSubscriberExceptions) {
@@ -516,7 +689,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /** For ThreadLocal, much faster to set (and get multiple values).
+     * 当前 线程状态?
+     * */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
index e212750e..385bf425 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
@@ -35,8 +35,11 @@
     boolean sendNoSubscriberEvent = true;
     boolean throwSubscriberException;
     boolean eventInheritance = true;
+
+
     boolean ignoreGeneratedIndex;
     boolean strictMethodVerification;
+
     ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
     List<Class<?>> skipMethodVerificationForClasses;
     List<SubscriberInfoIndex> subscriberInfoIndexes;
@@ -87,6 +90,10 @@ public EventBusBuilder throwSubscriberException(boolean throwSubscriberException
      * <p/>
      * However, keep in mind that event posting usually consumes just a small proportion of CPU time inside an app,
      * unless it is posting at high rates, e.g. hundreds/thousands of events per second.
+     *
+     * 设置是否考虑事件的继承  即父类 是否被通知到  默认是
+     *
+     * 如果设置成 false 那么父类将得不到事件  但是 事件 接收速度回忆 快 20%
      */
     public EventBusBuilder eventInheritance(boolean eventInheritance) {
         this.eventInheritance = eventInheritance;
@@ -116,7 +123,9 @@ public EventBusBuilder skipMethodVerificationFor(Class<?> clazz) {
         return this;
     }
 
-    /** Forces the use of reflection even if there's a generated index (default: false). */
+    /** Forces the use of reflection even if there's a generated index (default: false).
+     * TODO 亲自使用反射 即使只有一个 生成 的index  默认是false 不适用反射?
+     * */
     public EventBusBuilder ignoreGeneratedIndex(boolean ignoreGeneratedIndex) {
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
         return this;
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusException.java b/EventBus/src/org/greenrobot/eventbus/EventBusException.java
index 20d50e6b..54630137 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusException.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusException.java
@@ -17,7 +17,8 @@
 
 /**
  * An {@link RuntimeException} thrown in cases something went wrong inside EventBus.
- * 
+ *
+ * 异常
  * @author Markus
  * 
  */
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 3247be53..b8e1a050 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -20,13 +20,24 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+/**
+ * UI 线程的Handler
+ */
 final class HandlerPoster extends Handler {
 
+    /**
+     * 待处理的 事件 队列
+     */
     private final PendingPostQueue queue;
+
+    /**
+     * 最大的处理消息的时间
+     */
     private final int maxMillisInsideHandleMessage;
     private final EventBus eventBus;
     private boolean handlerActive;
 
+    // 这里需要 主线的Looer
     HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
         super(looper);
         this.eventBus = eventBus;
@@ -35,41 +46,57 @@
     }
 
     void enqueue(Subscription subscription, Object event) {
+        //生成一个  待发送任务
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
+            // 入队
             queue.enqueue(pendingPost);
             if (!handlerActive) {
                 handlerActive = true;
-                if (!sendMessage(obtainMessage())) {
+                if (!sendMessage(obtainMessage())) {// 发送消息
+                    // 发送失败 抛出异常
                     throw new EventBusException("Could not send handler message");
                 }
             }
         }
     }
 
+    /**
+     * 这里获取消息
+     * @param msg
+     */
     @Override
     public void handleMessage(Message msg) {
         boolean rescheduled = false;
         try {
+            // 开始时间
             long started = SystemClock.uptimeMillis();
+            // 这里死循环
             while (true) {
+                // 获取 队头的任务
                 PendingPost pendingPost = queue.poll();
                 if (pendingPost == null) {
                     synchronized (this) {
                         // Check again, this time in synchronized
+                        // 如果没有获取到 再次检查一遍
                         pendingPost = queue.poll();
                         if (pendingPost == null) {
+                            // 再没有 就 退出
                             handlerActive = false;
                             return;
                         }
                     }
                 }
+                // 执行 订阅者 方法
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
+                    // 如果这次 耗时 超过做了最大 时间
+                    // 重新 发送时间 , 重新 进入循环
                     if (!sendMessage(obtainMessage())) {
                         throw new EventBusException("Could not send handler message");
                     }
+                    // 重新安排
                     rescheduled = true;
                     return;
                 }
diff --git a/EventBus/src/org/greenrobot/eventbus/NoSubscriberEvent.java b/EventBus/src/org/greenrobot/eventbus/NoSubscriberEvent.java
index e4da4757..e3fa0bff 100644
--- a/EventBus/src/org/greenrobot/eventbus/NoSubscriberEvent.java
+++ b/EventBus/src/org/greenrobot/eventbus/NoSubscriberEvent.java
@@ -17,7 +17,8 @@
 
 /**
  * This Event is posted by EventBus when no subscriber is found for a posted event.
- * 
+ *
+ * 没有订阅者 事件
  * @author Markus
  */
 public final class NoSubscriberEvent {
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..d1b49793 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -18,11 +18,18 @@
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * 待发送事件的 一个封装
+ */
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
 
+    //事件
     Object event;
+    // 订阅者
     Subscription subscription;
+
+    // 下一个指针
     PendingPost next;
 
     private PendingPost(Object event, Subscription subscription) {
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..adb888f7 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -16,8 +16,13 @@
 
 package org.greenrobot.eventbus;
 
+/**
+ * 待发送队列
+ */
 final class PendingPostQueue {
+    // 队列头部
     private PendingPost head;
+    // 队列尾部
     private PendingPost tail;
 
     synchronized void enqueue(PendingPost pendingPost) {
@@ -35,6 +40,7 @@ synchronized void enqueue(PendingPost pendingPost) {
         notifyAll();
     }
 
+    // 获取头部
     synchronized PendingPost poll() {
         PendingPost pendingPost = head;
         if (head != null) {
@@ -46,6 +52,7 @@ synchronized PendingPost poll() {
         return pendingPost;
     }
 
+    // 获取头部, 如果没有 则 等一会 有新的事件进来 则会继续执行  入队的哪里 调用了  notifyAll();
     synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
         if (head == null) {
             wait(maxMillisToWait);
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscribe.java b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
index ed0b8c82..854a2779 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscribe.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
@@ -32,13 +32,25 @@
     /**
      * If true, delivers the most recent sticky event (posted with
      * {@link EventBus#postSticky(Object)}) to this subscriber (if event available).
+     *
+     * 这个是 接收粘性事件
+     *
+     * 粘性事件的大致是这么个东西:
+     * 如果 EventBus 发送了一个粘性事件, 太会吧这个事件保存下来
+     *
+     * 然后我们订阅了粘性事件, 如果之前保存的粘性事件集合中 恰好有这个类型的事件
+     * 那么 在一订阅的时候, 就会立马收到 粘性事件
+     *
      */
     boolean sticky() default false;
 
     /** Subscriber priority to influence the order of event delivery.
      * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before
      * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
-     * delivery among subscribers with different {@link ThreadMode}s! */
+     * delivery among subscribers with different {@link ThreadMode}s!
+     * 权重等级
+     * 影响事件发送 排序
+     * */
     int priority() default 0;
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberExceptionEvent.java b/EventBus/src/org/greenrobot/eventbus/SubscriberExceptionEvent.java
index ff69f05a..dccb37ac 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberExceptionEvent.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberExceptionEvent.java
@@ -17,7 +17,8 @@
 
 /**
  * This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.
- * 
+ *
+ * 订阅异常
  * @author Markus
  */
 public final class SubscriberExceptionEvent {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..43e52c18 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,14 +17,25 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/** Used internally by EventBus and generated subscriber indexes.
+ *
+ * 订阅方法的封装类
+ *
+ * */
 public class SubscriberMethod {
+    // 方式
     final Method method;
+    // 执行时的线程模式
     final ThreadMode threadMode;
+    // 事件类型
     final Class<?> eventType;
+    // 权重
     final int priority;
+    // 是否是耐耐心
     final boolean sticky;
-    /** Used for efficient comparison */
+    /** Used for efficient comparison
+     * 方法名 主要用于 equals 比较
+     * */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
@@ -44,6 +55,8 @@ public boolean equals(Object other) {
             SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
+            // 如果使用 method.equals 很耗事件
+            //1000 calls to method1.equals(method2) takes 600+ ms on my box with 200+ms of 4 GC cycles
             return methodString.equals(otherSubscriberMethod.methodString);
         } else {
             return false;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..48b2718b 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -26,245 +26,355 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
+/**
+ * 订阅方法 寻找的help 类
+ */
 class SubscriberMethodFinder {
-    /*
-     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
-     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
-     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
-     */
-    private static final int BRIDGE = 0x40;
-    private static final int SYNTHETIC = 0x1000;
-
-    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
-
-    private List<SubscriberInfoIndex> subscriberInfoIndexes;
-    private final boolean strictMethodVerification;
-    private final boolean ignoreGeneratedIndex;
-
-    private static final int POOL_SIZE = 4;
-    private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
-
-    SubscriberMethodFinder(List<SubscriberInfoIndex> subscriberInfoIndexes, boolean strictMethodVerification,
-                           boolean ignoreGeneratedIndex) {
-        this.subscriberInfoIndexes = subscriberInfoIndexes;
-        this.strictMethodVerification = strictMethodVerification;
-        this.ignoreGeneratedIndex = ignoreGeneratedIndex;
-    }
-
-    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
-        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
-        if (subscriberMethods != null) {
-            return subscriberMethods;
-        }
-
-        if (ignoreGeneratedIndex) {
-            subscriberMethods = findUsingReflection(subscriberClass);
-        } else {
-            subscriberMethods = findUsingInfo(subscriberClass);
-        }
-        if (subscriberMethods.isEmpty()) {
-            throw new EventBusException("Subscriber " + subscriberClass
-                    + " and its super classes have no public methods with the @Subscribe annotation");
-        } else {
-            METHOD_CACHE.put(subscriberClass, subscriberMethods);
-            return subscriberMethods;
-        }
-    }
-
-    private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
-        findState.initForSubscriber(subscriberClass);
-        while (findState.clazz != null) {
-            findState.subscriberInfo = getSubscriberInfo(findState);
-            if (findState.subscriberInfo != null) {
-                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
-                for (SubscriberMethod subscriberMethod : array) {
-                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
-                        findState.subscriberMethods.add(subscriberMethod);
-                    }
-                }
-            } else {
-                findUsingReflectionInSingleClass(findState);
-            }
-            findState.moveToSuperclass();
-        }
-        return getMethodsAndRelease(findState);
-    }
-
-    private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
-        List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
-        findState.recycle();
-        synchronized (FIND_STATE_POOL) {
-            for (int i = 0; i < POOL_SIZE; i++) {
-                if (FIND_STATE_POOL[i] == null) {
-                    FIND_STATE_POOL[i] = findState;
-                    break;
-                }
-            }
-        }
-        return subscriberMethods;
-    }
-
-    private FindState prepareFindState() {
-        synchronized (FIND_STATE_POOL) {
-            for (int i = 0; i < POOL_SIZE; i++) {
-                FindState state = FIND_STATE_POOL[i];
-                if (state != null) {
-                    FIND_STATE_POOL[i] = null;
-                    return state;
-                }
-            }
-        }
-        return new FindState();
-    }
-
-    private SubscriberInfo getSubscriberInfo(FindState findState) {
-        if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
-            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
-            if (findState.clazz == superclassInfo.getSubscriberClass()) {
-                return superclassInfo;
-            }
-        }
-        if (subscriberInfoIndexes != null) {
-            for (SubscriberInfoIndex index : subscriberInfoIndexes) {
-                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
-                if (info != null) {
-                    return info;
-                }
-            }
-        }
-        return null;
-    }
-
-    private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
-        findState.initForSubscriber(subscriberClass);
-        while (findState.clazz != null) {
-            findUsingReflectionInSingleClass(findState);
-            findState.moveToSuperclass();
-        }
-        return getMethodsAndRelease(findState);
-    }
-
-    private void findUsingReflectionInSingleClass(FindState findState) {
-        Method[] methods;
-        try {
-            // This is faster than getMethods, especially when subscribers are fat classes like Activities
-            methods = findState.clazz.getDeclaredMethods();
-        } catch (Throwable th) {
-            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
-            methods = findState.clazz.getMethods();
-            findState.skipSuperClasses = true;
-        }
-        for (Method method : methods) {
-            int modifiers = method.getModifiers();
-            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                Class<?>[] parameterTypes = method.getParameterTypes();
-                if (parameterTypes.length == 1) {
-                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
-                    if (subscribeAnnotation != null) {
-                        Class<?> eventType = parameterTypes[0];
-                        if (findState.checkAdd(method, eventType)) {
-                            ThreadMode threadMode = subscribeAnnotation.threadMode();
-                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
-                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
-                        }
-                    }
-                } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
-                    String methodName = method.getDeclaringClass().getName() + "." + method.getName();
-                    throw new EventBusException("@Subscribe method " + methodName +
-                            "must have exactly 1 parameter but has " + parameterTypes.length);
-                }
-            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
-                String methodName = method.getDeclaringClass().getName() + "." + method.getName();
-                throw new EventBusException(methodName +
-                        " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
-            }
-        }
-    }
-
-    static void clearCaches() {
-        METHOD_CACHE.clear();
-    }
-
-    static class FindState {
-        final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
-        final Map<Class, Object> anyMethodByEventType = new HashMap<>();
-        final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
-        final StringBuilder methodKeyBuilder = new StringBuilder(128);
-
-        Class<?> subscriberClass;
-        Class<?> clazz;
-        boolean skipSuperClasses;
-        SubscriberInfo subscriberInfo;
-
-        void initForSubscriber(Class<?> subscriberClass) {
-            this.subscriberClass = clazz = subscriberClass;
-            skipSuperClasses = false;
-            subscriberInfo = null;
-        }
-
-        void recycle() {
-            subscriberMethods.clear();
-            anyMethodByEventType.clear();
-            subscriberClassByMethodKey.clear();
-            methodKeyBuilder.setLength(0);
-            subscriberClass = null;
-            clazz = null;
-            skipSuperClasses = false;
-            subscriberInfo = null;
-        }
-
-        boolean checkAdd(Method method, Class<?> eventType) {
-            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
-            // Usually a subscriber doesn't have methods listening to the same event type.
-            Object existing = anyMethodByEventType.put(eventType, method);
-            if (existing == null) {
-                return true;
-            } else {
-                if (existing instanceof Method) {
-                    if (!checkAddWithMethodSignature((Method) existing, eventType)) {
-                        // Paranoia check
-                        throw new IllegalStateException();
-                    }
-                    // Put any non-Method object to "consume" the existing Method
-                    anyMethodByEventType.put(eventType, this);
-                }
-                return checkAddWithMethodSignature(method, eventType);
-            }
-        }
-
-        private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
-            methodKeyBuilder.setLength(0);
-            methodKeyBuilder.append(method.getName());
-            methodKeyBuilder.append('>').append(eventType.getName());
-
-            String methodKey = methodKeyBuilder.toString();
-            Class<?> methodClass = method.getDeclaringClass();
-            Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
-            if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
-                // Only add if not already found in a sub class
-                return true;
-            } else {
-                // Revert the put, old class is further down the class hierarchy
-                subscriberClassByMethodKey.put(methodKey, methodClassOld);
-                return false;
-            }
-        }
-
-        void moveToSuperclass() {
-            if (skipSuperClasses) {
-                clazz = null;
-            } else {
-                clazz = clazz.getSuperclass();
-                String clazzName = clazz.getName();
-                /** Skip system classes, this just degrades performance. */
-                if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
-                    clazz = null;
-                }
-            }
-        }
-    }
+	/*
+	 * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
+	 * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
+	 * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
+	 */
+	private static final int BRIDGE = 0x40;
+	private static final int SYNTHETIC = 0x1000;
+
+	private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+
+	private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
+
+	private List<SubscriberInfoIndex> subscriberInfoIndexes;
+	private final boolean strictMethodVerification;
+	private final boolean ignoreGeneratedIndex;
+
+	private static final int POOL_SIZE = 4;
+	private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
+
+	/**
+	 * @param subscriberInfoIndexes    订阅者信息索引
+	 * @param strictMethodVerification 粘性方法 验证
+	 * @param ignoreGeneratedIndex     是否忽略生成的索引
+	 */
+	SubscriberMethodFinder(List<SubscriberInfoIndex> subscriberInfoIndexes, boolean strictMethodVerification,
+						   boolean ignoreGeneratedIndex) {
+		this.subscriberInfoIndexes = subscriberInfoIndexes;
+		this.strictMethodVerification = strictMethodVerification;
+		this.ignoreGeneratedIndex = ignoreGeneratedIndex;
+	}
+
+	/**
+	 * 寻找订阅方法
+	 *
+	 * @param subscriberClass
+	 * @return
+	 */
+	List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+		// 现在缓存中寻找
+		List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
+		if (subscriberMethods != null) {
+			return subscriberMethods;
+		}
+
+		if (ignoreGeneratedIndex) {
+			// 如果忽略生成的索引的话 使用反射
+			subscriberMethods = findUsingReflection(subscriberClass);
+		} else {
+			// 如果不忽略生成的索引的话 更具索引 来寻找方法
+			subscriberMethods = findUsingInfo(subscriberClass);
+		}
+		if (subscriberMethods.isEmpty()) {
+			throw new EventBusException("Subscriber " + subscriberClass
+					+ " and its super classes have no public methods with the @Subscribe annotation");
+		} else {
+			METHOD_CACHE.put(subscriberClass, subscriberMethods);
+			return subscriberMethods;
+		}
+	}
+
+	/**
+	 * 通过 apt 生成的index 找寻方法
+	 *
+	 * @param subscriberClass
+	 * @return
+	 */
+	private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
+
+		//FindState 初始化
+		FindState findState = prepareFindState();
+		findState.initForSubscriber(subscriberClass);
+
+		while (findState.clazz != null) {
+			// 循环向上 寻找匪类
+			// 从索引 或 findState 中获取 订阅细细
+			findState.subscriberInfo = getSubscriberInfo(findState);
+			if (findState.subscriberInfo != null) {
+				SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
+				for (SubscriberMethod subscriberMethod : array) {
+					if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
+						findState.subscriberMethods.add(subscriberMethod);
+					}
+				}
+			} else {
+				// 没找到 用反射找
+				findUsingReflectionInSingleClass(findState);
+			}
+			findState.moveToSuperclass();
+		}
+		// 返回订阅信息列表 并 release FindState
+		return getMethodsAndRelease(findState);
+	}
+
+	/**
+	 * 返回订阅信息列表 并 release FindState
+	 *
+	 * @param findState
+	 * @return
+	 */
+	private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+		List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
+		findState.recycle();
+		synchronized (FIND_STATE_POOL) {
+			for (int i = 0; i < POOL_SIZE; i++) {
+				if (FIND_STATE_POOL[i] == null) {
+					FIND_STATE_POOL[i] = findState;
+					break;
+				}
+			}
+		}
+		return subscriberMethods;
+	}
+
+	/**
+	 * 准备 FindState 对象
+	 *
+	 * @return
+	 */
+	private FindState prepareFindState() {
+		synchronized (FIND_STATE_POOL) {
+			// 先从 FindState 池中获取
+			for (int i = 0; i < POOL_SIZE; i++) {
+				FindState state = FIND_STATE_POOL[i];
+				if (state != null) {
+					FIND_STATE_POOL[i] = null;
+					return state;
+				}
+			}
+		}
+		// 没有获取到则  new 一个新的
+		return new FindState();
+	}
+
+
+	/**
+	 * 从 findState 中 获取 subscriberInfoIndexes 中获取 订阅信息
+	 *
+	 * @param findState
+	 * @return
+	 */
+	private SubscriberInfo getSubscriberInfo(FindState findState) {
+		if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
+			SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
+			if (findState.clazz == superclassInfo.getSubscriberClass()) {
+				return superclassInfo;
+			}
+		}
+		if (subscriberInfoIndexes != null) {
+			for (SubscriberInfoIndex index : subscriberInfoIndexes) {
+				SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
+				if (info != null) {
+					return info;
+				}
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * 通过反射来寻找 订阅方法
+	 *
+	 * @param subscriberClass
+	 * @return
+	 */
+	private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+		// 获取 FindState 并初始化
+		FindState findState = prepareFindState();
+		findState.initForSubscriber(subscriberClass);
+		while (findState.clazz != null) {
+			// 循环 向上寻找父类 并找出其中的订阅  并放到 findState 对象中
+			findUsingReflectionInSingleClass(findState);
+			findState.moveToSuperclass();
+		}
+		return getMethodsAndRelease(findState);
+	}
+
+	/**
+	 * 反射 寻找订阅方法
+	 * @param findState
+	 */
+	private void findUsingReflectionInSingleClass(FindState findState) {
+		Method[] methods;
+		try {
+			// 获取该类的方法 getDeclaredMethods 比 getMethods 方法快
+			// This is faster than getMethods, especially when subscribers are fat classes like Activities
+			methods = findState.clazz.getDeclaredMethods();
+		} catch (Throwable th) {
+			// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+			// getMethods 会寻找 父类方法 但是只能找到 public 方法
+			methods = findState.clazz.getMethods();
+			// 走了这个方法 就不需要在循环向上 寻找父类的方法了
+			findState.skipSuperClasses = true;
+		}
+		for (Method method : methods) {
+			int modifiers = method.getModifiers();
+			if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+				// public 方法  且 不是这些 方法   Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+				Class<?>[] parameterTypes = method.getParameterTypes();
+				if (parameterTypes.length == 1) {
+					// 参数只能是一个
+					Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
+					if (subscribeAnnotation != null) {
+						// 且 有 Subscribe注解
+						Class<?> eventType = parameterTypes[0];
+						// 加入这个方法 并检查这个方法
+						if (findState.checkAdd(method, eventType)) {
+							ThreadMode threadMode = subscribeAnnotation.threadMode();
+							// 向订阅者 方法列表中 正式 加入这个订阅信息
+							findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
+									subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
+						}
+					}
+				} else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+					// 两个参数 抛出异常
+					String methodName = method.getDeclaringClass().getName() + "." + method.getName();
+					throw new EventBusException("@Subscribe method " + methodName +
+							"must have exactly 1 parameter but has " + parameterTypes.length);
+				}
+			} else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+				// 不是public 的方法 抛出异常
+				String methodName = method.getDeclaringClass().getName() + "." + method.getName();
+				throw new EventBusException(methodName +
+						" is a illegal @Subscribe method: must be public, non-static, and non-abstract");
+			}
+		}
+	}
+
+	static void clearCaches() {
+		METHOD_CACHE.clear();
+	}
+
+	static class FindState {
+		/**
+		 * 订阅方法列表 这个才是主要的
+		 */
+		final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+
+		/**
+		 * 所有 符合类型的 方法
+		 */
+		final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+
+		/**
+		 * 订阅方法 key  对应 订阅类
+		 */
+		final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
+		final StringBuilder methodKeyBuilder = new StringBuilder(128);
+
+		Class<?> subscriberClass;
+		Class<?> clazz;
+		boolean skipSuperClasses;
+		SubscriberInfo subscriberInfo;
+
+		void initForSubscriber(Class<?> subscriberClass) {
+			this.subscriberClass = clazz = subscriberClass;
+			skipSuperClasses = false;
+			subscriberInfo = null;
+		}
+
+		void recycle() {
+			subscriberMethods.clear();
+			anyMethodByEventType.clear();
+			subscriberClassByMethodKey.clear();
+			methodKeyBuilder.setLength(0);
+			subscriberClass = null;
+			clazz = null;
+			skipSuperClasses = false;
+			subscriberInfo = null;
+		}
+
+		/**
+		 * 加入订阅 方法
+		 *
+		 * @param method
+		 * @param eventType
+		 * @return
+		 */
+		boolean checkAdd(Method method, Class<?> eventType) {
+			// 2 level check:
+			// 1st level with event type only (fast),
+			// 2nd level with complete signature when required.
+			// Usually a subscriber doesn't have methods listening to the same event type.
+			// 2 级验证
+			// 1 更具类型来验证
+			// 2 更具方法名来验证
+			// 同城情况下, 不会出现 在一个雷总  有多个方法 监听一个事件
+
+
+			Object existing = anyMethodByEventType.put(eventType, method);
+			// 这里要注意 map的put 方法 返回的, 是这个key 对应的以前的字
+			if (existing == null) {
+				// 原来的map 没有 对应 eventType  的值 那么直接返回true 验证通过
+				return true;
+			} else {
+				if (existing instanceof Method) {
+					// anyMethodByEventType  中对应的 eventType 有值 且 是方法
+					// 再根据方法名去检查
+					if (!checkAddWithMethodSignature((Method) existing, eventType)) {
+						// 检查不通过  已经保存了一个 一样的方法, 抛出异常
+						// Paranoia check
+						throw new IllegalStateException();
+					}
+					// Put any non-Method object to "consume" the existing Method
+					// 这里是为了 把之前加进去的  methon 去掉?
+					anyMethodByEventType.put(eventType, this);
+				}
+				// 上面如果通过的话, 这次校验 也肯定通过 如果不是方法 也应该通过
+				return checkAddWithMethodSignature(method, eventType);
+			}
+		}
+
+		//TODO 这里的校验方式 还得再看看 有点意思
+		private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
+			methodKeyBuilder.setLength(0);
+			methodKeyBuilder.append(method.getName());
+			methodKeyBuilder.append('>').append(eventType.getName());
+			// method>EventType
+
+			String methodKey = methodKeyBuilder.toString();
+			Class<?> methodClass = method.getDeclaringClass();
+			Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
+			if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
+				// 没找到 这个key 对应的方法
+				// Only add if not already found in a sub class
+				return true;
+			} else {
+				// 再到了 那么把 原来的 methodClassOld 方法 放回去 返回false 表示检查不通过
+				// Revert the put, old class is further down the class hierarchy
+				subscriberClassByMethodKey.put(methodKey, methodClassOld);
+				return false;
+			}
+		}
+
+		void moveToSuperclass() {
+			if (skipSuperClasses) {
+				clazz = null;
+			} else {
+				clazz = clazz.getSuperclass();
+				String clazzName = clazz.getName();
+				/** Skip system classes, this just degrades performance. */
+				if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
+					clazz = null;
+				}
+			}
+		}
+	}
 
 }
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..1975b3d1 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,6 +15,12 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 订阅者 信息
+ *
+ * 一个订阅者  对应的需要  一个 订阅方法  一个有该方法的对象
+ *
+ */
 final class Subscription {
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index 79d5dc43..36ad8035 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -18,40 +18,63 @@
 /**
  * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
  * EventBus takes care of threading independently from the posting thread.
- * 
- * @see EventBus#register(Object)
+ * <p>
+ * 这个事 接收事件的方法在哪个线程 执行
+ *
  * @author Markus
+ * @see EventBus#register(Object)
  */
 public enum ThreadMode {
-    /**
-     * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
-     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
-     * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
-     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
-     */
-    POSTING,
+	/**
+	 * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
+	 * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
+	 * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
+	 * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
+	 *
+	 * 和事件发送的线程 是一个线程
+	 * 这种模式 开销最小 , 不用切换线程
+	 *
+	 * 执行的订阅方法不能耗时 , 不然会阻塞 其他事件的发送
+	 * 还可以阻塞UI 因为这可能是主线程
+	 */
+	POSTING,
 
-    /**
-     * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
-     * the main thread, event handler methods will be called directly. Event handlers using this mode must return
-     * quickly to avoid blocking the main thread.
-     */
-    MAIN,
+	/**
+	 * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
+	 * the main thread, event handler methods will be called directly. Event handlers using this mode must return
+	 * quickly to avoid blocking the main thread.
+	 *
+	 * 如果发送事件的方法 是主线程的话, 那么将直接执行 订阅方法
+	 *
+	 * 在主线程中执行
+	 *  执行的订阅方法不能耗时 不然会阻塞UI
+	 */
+	MAIN,
 
-    /**
-     * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
-     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
-     * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
-     * return quickly to avoid blocking the background thread.
-     */
-    BACKGROUND,
+	/**
+	 * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
+	 * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
+	 * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
+	 * return quickly to avoid blocking the background thread.
+	 *
+	 * 如果 发送事件的  不是主线程 那么 就和 发送事件的线程一直
+	 * 如果 发送事件的  是主线程 那么 会使用一个独立的线
+	 *
+	 * 执行的订阅方法不能耗时 , 不然会阻塞 其他事件的发送
+	 *
+	 */
+	BACKGROUND,
 
-    /**
-     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
-     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
-     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
-     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
-     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
-     */
-    ASYNC
+	/**
+	 * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
+	 * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
+	 * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
+	 * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
+	 * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+	 *
+	 *
+	 * 执行订阅方法的线程  与 发送事件的线程 和主线程 都不同
+	 * 在这种模式可 可以执行 一些比较耗时的操作
+	 */
+	ASYNC
 }
\ No newline at end of file
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
index b68de63a..a5de72a1 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
@@ -21,8 +21,12 @@
 
 import java.lang.reflect.Method;
 
-/** Base class for generated subscriber meta info classes created by annotation processing. */
+/** Base class for generated subscriber meta info classes created by annotation processing.
+ * 订阅者信息的base类
+ *
+ * */
 public abstract class AbstractSubscriberInfo implements SubscriberInfo {
+    // 订阅者的类
     private final Class subscriberClass;
     private final Class<? extends SubscriberInfo> superSubscriberInfoClass;
     private final boolean shouldCheckSuperclass;
@@ -64,6 +68,15 @@ protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> ev
         return createSubscriberMethod(methodName, eventType, threadMode, 0, false);
     }
 
+    /**
+     * 创建 订阅者 方法类
+     * @param methodName 方法名
+     * @param eventType 事件类型
+     * @param threadMode 线程模式
+     * @param priority 权重
+     * @param sticky 是否是粘性
+     * @return
+     */
     protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType, ThreadMode threadMode,
                                                       int priority, boolean sticky) {
         try {
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
index 3ee4442d..93192362 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
@@ -19,6 +19,13 @@
 
 /**
  * Uses {@link SubscriberMethodInfo} objects to create {@link org.greenrobot.eventbus.SubscriberMethod} objects on demand.
+ *
+ * 订阅者的基本信息
+ * 主要包含方法信息
+ *
+ * 这个对象 是在 apt 的时候回用到
+ *
+ * EventBus 中会自己反射生成
  */
 public class SimpleSubscriberInfo extends AbstractSubscriberInfo {
 
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfo.java
index 83c1e741..73501105 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfo.java
@@ -17,7 +17,9 @@
 
 import org.greenrobot.eventbus.SubscriberMethod;
 
-/** Base class for generated index classes created by annotation processing. */
+/** Base class for generated index classes created by annotation processing.
+ * 订阅者 信息接口
+ * */
 public interface SubscriberInfo {
     Class<?> getSubscriberClass();
 
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
index 9fc65f6f..7be8bcbb 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
@@ -17,6 +17,11 @@
 
 /**
  * Interface for generated indexes.
+ *
+ * 订阅者信息索引接口
+ *
+ * 实现类 在编译的过程 会通过APT 生成
+ * 但是 默认的好像 没有
  */
 public interface SubscriberInfoIndex {
     SubscriberInfo getSubscriberInfo(Class<?> subscriberClass);
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
index 2152554c..9eb86a85 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
@@ -17,11 +17,16 @@
 
 import org.greenrobot.eventbus.ThreadMode;
 
+/**
+ * 订阅者的方法信息
+ */
 public class SubscriberMethodInfo {
     final String methodName;
     final ThreadMode threadMode;
     final Class<?> eventType;
+    // 权重
     final int priority;
+    // 是否是粘性
     final boolean sticky;
 
     public SubscriberMethodInfo(String methodName, Class<?> eventType, ThreadMode threadMode,
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index c37c18a5..ce540207 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -46,6 +46,9 @@
 
 import de.greenrobot.common.ListMap;
 
+
+// 这个 是 apt 一个特性 这个类的方法会自动执行
+
 @SupportedAnnotationTypes("org.greenrobot.eventbus.Subscribe")
 @SupportedOptions(value = {"eventBusIndex", "verbose"})
 public class EventBusAnnotationProcessor extends AbstractProcessor {
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
index 3d554a84..493d1dd9 100644
--- a/EventBusPerformance/build.gradle
+++ b/EventBusPerformance/build.gradle
@@ -10,6 +10,7 @@ buildscript {
 }
 
 apply plugin: 'com.android.application'
+// 这里使用了 apt 插件
 apply plugin: 'com.neenbedankt.android-apt'
 
 repositories {
@@ -22,6 +23,7 @@ dependencies {
     compile 'com.squareup:otto:1.3.8'
 }
 
+// 这里 ap 标明 会自动生成一个类
 apt {
     arguments {
         eventBusIndex "org.greenrobot.eventbusperf.MyEventBusIndex"
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunner.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunner.java
index 4c0f941f..f3832c2b 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunner.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunner.java
@@ -35,10 +35,12 @@
     public TestRunner(Context context, TestParams testParams, EventBus controlBus) {
         this.controlBus = controlBus;
         tests = new ArrayList<Test>();
+        // 测试类
         for (Class<? extends Test> testClazz : testParams.getTestClasses()) {
             try {
                 Constructor<?>[] constructors = testClazz.getConstructors();
                 Constructor<? extends Test> constructor = testClazz.getConstructor(Context.class, TestParams.class);
+                // 反射出相应的 测试类
                 Test test = constructor.newInstance(context, testParams);
                 tests.add(test);
             } catch (Exception e) {
@@ -52,6 +54,7 @@ public void run() {
         int idx = 0;
         for (Test test : tests) {
             // Clean up and let the main thread calm down
+            // 这里 GC 和 sleep 是为了 让主线程 冷静闲置下来
             System.gc();
             try {
                 Thread.sleep(300);
@@ -60,8 +63,10 @@ public void run() {
             } catch (InterruptedException e) {
             }
 
+            // 测试准备
             test.prepareTest();
             if (!canceled) {
+                // 测试 执行
                 test.runTest();
             }
             if (!canceled) {
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
index e22631c1..2a5e108b 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
@@ -43,6 +43,7 @@ public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_runtests);
         textViewResult = (TextView) findViewById(R.id.textViewResult);
+        // event bus 注册
         controlBus = new EventBus();
         controlBus.register(this);
     }
@@ -52,6 +53,7 @@ protected void onResume() {
         super.onResume();
         if (testRunner == null) {
             TestParams testParams = (TestParams) getIntent().getSerializableExtra("params");
+            // 创建 并执行  testRunner 线程
             testRunner = new TestRunner(getApplicationContext(), testParams, controlBus);
 
             if (testParams.getTestNumber() == 1) {
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestSetupActivity.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestSetupActivity.java
index 3488b8da..e9f82284 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestSetupActivity.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestSetupActivity.java
@@ -73,23 +73,37 @@ public void checkEventBus(View v) {
 
     public void startClick(View v) {
         TestParams params = new TestParams();
+
+        // 确定选择的线程 模式
         Spinner spinnerThread = (Spinner) findViewById(R.id.spinnerThread);
         String threadModeStr = spinnerThread.getSelectedItem().toString();
         ThreadMode threadMode = ThreadMode.valueOf(threadModeStr);
         params.setThreadMode(threadMode);
 
+        // 设置时间 继承?
         params.setEventInheritance(((CheckBox) findViewById(R.id.checkBoxEventBusEventHierarchy)).isChecked());
+        // 设置 是否 忽略 生成的索引
         params.setIgnoreGeneratedIndex(((CheckBox) findViewById(R.id.checkBoxEventBusIgnoreGeneratedIndex)).isChecked());
 
         EditText editTextEvent = (EditText) findViewById(R.id.editTextEvent);
+        // 设置 时间数量
         params.setEventCount(Integer.parseInt(editTextEvent.getText().toString()));
 
+        // 设置 接收者的数量
         EditText editTextSubscriber = (EditText) findViewById(R.id.editTextSubscribe);
         params.setSubscriberCount(Integer.parseInt(editTextSubscriber.getText().toString()));
 
+//        <string-array name="spinnerTestsToRun">
+//        <item>Post Events</item>
+//        <item>Register Subscribers</item>
+//        <item>Register Subscribers, no unregister</item>
+//        <item>Register Subscribers, 1. time</item>
+//        </string-array>
         Spinner spinnerTestToRun = (Spinner) findViewById(R.id.spinnerTestToRun);
         int testPos = spinnerTestToRun.getSelectedItemPosition();
+        // 获取选中位置
         params.setTestNumber(testPos + 1);
+        // 获取选中的 对应类 List  有两种 一种是 EVentBus  还有一种是 otto 的
         ArrayList<Class<? extends Test>> testClasses = initTestClasses(testPos);
         params.setTestClasses(testClasses);
 
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestEventBus.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestEventBus.java
index 7ceb8e6d..58723989 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestEventBus.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestEventBus.java
@@ -31,6 +31,9 @@
 import org.greenrobot.eventbusperf.TestEvent;
 import org.greenrobot.eventbusperf.TestParams;
 
+/**
+ * EventBus 的事件发送类
+ */
 public abstract class PerfTestEventBus extends Test {
 
     private final EventBus eventBus;
@@ -41,17 +44,27 @@
 
     public PerfTestEventBus(Context context, TestParams params) {
         super(context, params);
-        eventBus = EventBus.builder().eventInheritance(params.isEventInheritance()).addIndex(new MyEventBusIndex())
-                .ignoreGeneratedIndex(params.isIgnoreGeneratedIndex()).build();
+        // 重新build 一个 EventBus
+        eventBus = EventBus.builder()
+                .eventInheritance(params.isEventInheritance())
+                .addIndex(new MyEventBusIndex())
+                .ignoreGeneratedIndex(params.isIgnoreGeneratedIndex())
+                .build();
+
+
+		// 订阅者
         subscribers = new ArrayList<Object>();
         eventCount = params.getEventCount();
+		// 实际上 上事件数量
         expectedEventCount = eventCount * params.getSubscriberCount();
+		// 获取相应的 订阅者的类
         subscriberClass = getSubscriberClassForThreadMode();
     }
 
     @Override
     public void prepareTest() {
         try {
+			//这里吧 订阅者 构建出来
             Constructor<?> constructor = subscriberClass.getConstructor(PerfTestEventBus.class);
             for (int i = 0; i < params.getSubscriberCount(); i++) {
                 Object subscriber = constructor.newInstance(this);
@@ -84,6 +97,9 @@ private static String getDisplayModifier(TestParams params) {
     }
 
 
+	/**
+	 * 这个是一个个的 psot
+	 */
     public static class Post extends PerfTestEventBus {
         public Post(Context context, TestParams params) {
             super(context, params);
@@ -99,6 +115,7 @@ public void runTest() {
             TestEvent event = new TestEvent();
             long timeStart = System.nanoTime();
             for (int i = 0; i < super.eventCount; i++) {
+				// 循环 一个个的发送事件
                 super.eventBus.post(event);
                 if (canceled) {
                     break;
@@ -129,6 +146,7 @@ public RegisterAll(Context context, TestParams params) {
         }
 
         public void runTest() {
+			// 让订阅者 先解除订阅 后又马上订阅
             super.registerUnregisterOneSubscribers();
             long timeNanos = super.registerSubscribers();
             primaryResultMicros = timeNanos / 1000;
@@ -141,6 +159,9 @@ public String getDisplayName() {
         }
     }
 
+	/**
+	 * 一个一个的注册
+	 */
     public static class RegisterOneByOne extends PerfTestEventBus {
         protected Method clearCachesMethod;
 
@@ -285,6 +306,9 @@ private long registerSubscribers() {
         return time;
     }
 
+	/**
+	 * // 让订阅者 先注册 后有马上 解注册
+	 */
     private void registerUnregisterOneSubscribers() {
         if (!subscribers.isEmpty()) {
             Object subscriber = subscribers.get(0);
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestOtto.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestOtto.java
index 646256ed..ff4be6f5 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestOtto.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/PerfTestOtto.java
@@ -33,6 +33,9 @@
 import org.greenrobot.eventbusperf.TestEvent;
 import org.greenrobot.eventbusperf.TestParams;
 
+/**
+ * otto 的事件 发送类
+ */
 public abstract class PerfTestOtto extends Test {
 
     private final Bus eventBus;
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/SubscribeClassEventBusDefault.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/SubscribeClassEventBusDefault.java
index 54a11423..7698f6af 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/SubscribeClassEventBusDefault.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/testsubject/SubscribeClassEventBusDefault.java
@@ -27,6 +27,7 @@ public SubscribeClassEventBusDefault(PerfTestEventBus perfTestEventBus) {
         this.perfTestEventBus = perfTestEventBus;
     }
 
+    // 这里接收时间
     @Subscribe
     public void onEvent(TestEvent event) {
         perfTestEventBus.eventsReceivedCount.incrementAndGet();
diff --git a/build.gradle b/build.gradle
index c8d56ea1..d38d8e8c 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,5 +7,5 @@ if (JavaVersion.current().isJava8Compatible()) {
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.10'
+    gradleVersion = '2.8'
 }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 47511d78..dc171882 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Mon Feb 01 22:19:59 CET 2016
+#Fri Mar 18 17:39:51 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-all.zip
