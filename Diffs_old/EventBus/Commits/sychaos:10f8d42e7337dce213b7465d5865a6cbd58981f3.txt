diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..f0d8dd33 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -40,7 +40,9 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
@@ -74,7 +76,10 @@ protected PostingThreadState initialValue() {
 
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
+    // 单了个例
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -90,7 +95,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -121,6 +128,10 @@ public EventBus() {
         throwSubscriberException = builder.throwSubscriberException;
         eventInheritance = builder.eventInheritance;
         executorService = builder.executorService;
+
+        ArrayList<String> arrayList = new ArrayList<>();
+        arrayList.add("sa");
+        arrayList.remove("sa");
     }
 
     /**
@@ -132,9 +143,12 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        //  先获取了订阅者类的class
         Class<?> subscriberClass = subscriber.getClass();
+        //  人如其名，找订阅的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            //  开启疯狂订阅模式
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
@@ -143,14 +157,19 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        // eventType其实是 订阅的class
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        //subscriptionsByEventType是以event(即事件类)为key，以订阅列表(Subscription)为value，
+        //事件发送之后，在这里寻找订阅者,而Subscription又是一个CopyOnWriteArrayList，这是一个线程安全的容器
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        //为空的话就new一个然后add
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
             if (subscriptions.contains(newSubscription)) {
+                //  如果本已存在 throw EventBusException 一个类只能订阅一次
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
             }
@@ -158,12 +177,15 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
+            //  遍历整个subscriptions 当前subscriberMethod优先级最大或者遍历结束 进行add
+            //  i为优先级，i绝对不会重复
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
 
+        //  typesBySubscriber是以订阅者类为key，以event事件类为value，在进行register或unregister操作的时候，会操作这个map
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -171,6 +193,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        //  sticky 应该是置顶操作 TODO
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
@@ -204,11 +227,16 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+        //  subscriptionsByEventType是以event(即事件类)为key，以订阅列表(Subscription)为value，
+        //  事件发送之后，在这里寻找订阅者,而Subscription又是一个CopyOnWriteArrayList，这是一个线程安全的容器
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
+            //  遍历整个subscriptions 找到相应的EventType 然后干掉
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
                 if (subscription.subscriber == subscriber) {
@@ -221,36 +249,51 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
+        // typesBySubscriber是以订阅者类为key，以event事件类为value，在进行register或unregister操作的时候，会操作这个map
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
+        // 疯狂解绑
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
+            //  最终解绑
             typesBySubscriber.remove(subscriber);
         } else {
             Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
+        //  获取当前的状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        //  获取当前的消息队列
         List<Object> eventQueue = postingState.eventQueue;
+        //  添加该事件
         eventQueue.add(event);
 
+        //  不在发送状态时进入
         if (!postingState.isPosting) {
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
+            //  锁死
             postingState.isPosting = true;
+            //  异常处理
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                //  队列里还有东西就一直pop第一条
                 while (!eventQueue.isEmpty()) {
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
+                //  双关
                 postingState.isPosting = false;
                 postingState.isMainThread = false;
             }
@@ -359,9 +402,11 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    //  发送单个事件
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
+        //  eventInheritance 在builder里的设置 一般为false
         if (eventInheritance) {
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
@@ -370,8 +415,10 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            // 通过EventType发送事件
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
+        // 没找到subscription的log
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
                 Log.d(TAG, "No subscribers registered for event " + eventClass);
@@ -383,11 +430,15 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    //  通过EventType发送事件
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            //  subscriptionsByEventType是以event(即事件类)为key，以订阅列表(Subscription)为value，
+            //  事件发送之后，在这里寻找订阅者,而Subscription又是一个CopyOnWriteArrayList，这是一个线程安全的容器
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
+        //  疯狂发送事件并返回成功
         if (subscriptions != null && !subscriptions.isEmpty()) {
             for (Subscription subscription : subscriptions) {
                 postingState.event = event;
@@ -437,7 +488,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -455,7 +508,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -516,7 +571,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..64a62d1c 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,25 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //  先看缓存里有没有当前的subscriberClass 有则直接返回
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
         if (ignoreGeneratedIndex) {
+            // 用反射获取方法
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 不知道是啥 TODO
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+        //  找不到就GG
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            // 缓存中添加
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ee2c6b4d..9e35fa65 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.5-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
