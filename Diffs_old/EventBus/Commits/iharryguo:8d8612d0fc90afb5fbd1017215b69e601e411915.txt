diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 2530b438..558dc8ae 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -15,6 +15,8 @@
  */
 package org.greenrobot.eventbus;
 
+import android.text.TextUtils;
+
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -50,6 +52,11 @@
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
+    // harryguo add start. shall end with "// harryguo add end"
+    private final Map<String, CopyOnWriteArrayList<Subscription>> subscriptionsByEventId = new HashMap<>();
+    private final Map<Object, List<String>> idsBySubscriber = new HashMap<>();
+    // harryguo add end. shall begin with "// harryguo add start"
+
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -140,20 +147,35 @@ public EventBus() {
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
         // harryguo add start. shall end with "// harryguo add end"
-        // 注册静态函数类型的订阅者
+        // 允许调用者注册静态函数类型的订阅者
         if (subscriber instanceof Class<?>)
             subscriberClass = (Class<?>) subscriber;
         // harryguo add end. shall begin with "// harryguo add start"
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
-                subscribe(subscriber, subscriberMethod);
+                // harryguo add start. shall end with "// harryguo add end"
+                // subscribe(subscriber, subscriberMethod);
+                // 如果是排他性的订阅者，那就要把已经注册了该事件的其他订阅者先删除掉
+                // 将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
+                if (subscriberMethod.exclusive) {
+                    if (!TextUtils.isEmpty(subscriberMethod.eventId))
+                        unsubscribeByEventId(null, subscriberMethod.eventId);
+                    else
+                        unsubscribeByEventType(null, subscriberMethod.eventType);
+                }
+                // 允许调用者注册带eventId的订阅者
+                if (!TextUtils.isEmpty(subscriberMethod.eventId))
+                    subscribeByEventId(subscriber, subscriberMethod);
+                else
+                    subscribeByEventType(subscriber, subscriberMethod);
+                // harryguo add end. shall begin with "// harryguo add start"
             }
         }
     }
 
     // Must be called in synchronized block
-    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+    private void subscribeByEventType(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
@@ -222,7 +244,7 @@ private boolean isMainThread() {
     }
 
     public synchronized boolean isRegistered(Object subscriber) {
-        return typesBySubscriber.containsKey(subscriber);
+        return typesBySubscriber.containsKey(subscriber) || idsBySubscriber.containsKey(subscriber);
     }
 
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
@@ -232,13 +254,23 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
-                if (subscription.subscriber == subscriber) {
+                if (subscriber == null || subscription.subscriber == subscriber) {
                     subscription.active = false;
                     subscriptions.remove(i);
                     i--;
                     size--;
+                    // harryguo：idsBySubscriber里的数据也要清一下
+                    List<Class<?>> subscribedTypes = typesBySubscriber.get(subscription.subscriber);
+                    if (subscribedTypes != null) {
+                        subscribedTypes.remove(eventType);
+                        if (subscribedTypes.isEmpty())
+                            typesBySubscriber.remove(subscription.subscriber);
+                    }
                 }
             }
+            // harryguo: 如果订阅者都已经被删光了，那这个EventType的记录就可以整体被删掉了
+            if (subscriptions.isEmpty())
+                subscriptionsByEventType.remove(eventType);
         }
     }
 
@@ -250,7 +282,20 @@ public synchronized void unregister(Object subscriber) {
                 unsubscribeByEventType(subscriber, eventType);
             }
             typesBySubscriber.remove(subscriber);
-        } else {
+        }
+
+        // harryguo add start. shall end with "// harryguo add end"
+        List<String> subscribedIds = idsBySubscriber.get(subscriber);
+        if (subscribedTypes != null) {
+            for (String eventId : subscribedIds) {
+                unsubscribeByEventId(subscriber, eventId);
+            }
+            idsBySubscriber.remove(subscriber);
+        }
+        // harryguo add end. shall begin with "// harryguo add start"
+
+        if (subscribedTypes == null && subscribedIds == null)
+        {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
@@ -258,8 +303,8 @@ public synchronized void unregister(Object subscriber) {
     /** Posts the given event to the event bus. */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
-        List<Object> eventQueue = postingState.eventQueue;
-        eventQueue.add(event);
+        List<PostingThreadState.EventMessage> eventQueue = postingState.eventQueue;
+        eventQueue.add(new PostingThreadState.EventMessage(event));
 
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
@@ -380,18 +425,24 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
-    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+    private void postSingleEvent(PostingThreadState.EventMessage eventMsg, PostingThreadState postingState) throws Error {
+        Object event = eventMsg.event;
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
-        if (eventInheritance) {
+        // harryguo add. 这里如果eventId不为空，那就只根据eventId，忽略eventType。eventId优先级高于eventType
+        if (!TextUtils.isEmpty(eventMsg.eventId))
+        {
+            subscriptionFound = postSingleEventForEventId(eventMsg, postingState);
+        }
+        else if (eventInheritance) {
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
                 Class<?> clazz = eventTypes.get(h);
-                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
+                subscriptionFound |= postSingleEventForEventType(eventMsg, postingState, clazz);
             }
         } else {
-            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
+            subscriptionFound = postSingleEventForEventType(eventMsg, postingState, eventClass);
         }
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
@@ -404,18 +455,18 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
-    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
+    private boolean postSingleEventForEventType(PostingThreadState.EventMessage eventMsg, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
             for (Subscription subscription : subscriptions) {
-                postingState.event = event;
+                postingState.event = eventMsg.event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
-                    postToSubscription(subscription, event, postingState.isMainThread);
+                    postToSubscription(subscription, eventMsg.event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
                     postingState.event = null;
@@ -547,7 +598,21 @@ private void handleSubscriberException(Subscription subscription, Object event,
 
     /** For ThreadLocal, much faster to set (and get multiple values). */
     final static class PostingThreadState {
-        final List<Object> eventQueue = new ArrayList<>();
+        final static private class EventMessage {
+            Object event;
+            String eventId;
+
+            EventMessage(Object event) {
+                this(event, null);
+            }
+
+            EventMessage(Object event, String eventId) {
+                this.event = event;
+                this.eventId = eventId;
+            }
+        }
+
+        final List<EventMessage> eventQueue = new ArrayList<>();
         boolean isPosting;
         boolean isMainThread;
         Subscription subscription;
@@ -577,7 +642,118 @@ public String toString() {
     }
 
     // harryguo start。以下全是harryguo的代码，有harryguo end做结束：
+    // Must be called in synchronized block
+    private void subscribeByEventId(Object subscriber, SubscriberMethod subscriberMethod) {
+        String eventId = subscriberMethod.eventId;
+        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventId.get(eventId);
+        if (subscriptions == null) {
+            subscriptions = new CopyOnWriteArrayList<>();
+            subscriptionsByEventId.put(eventId, subscriptions);
+        } else {
+            if (subscriptions.contains(newSubscription)) {
+                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventId);
+            }
+        }
+
+        int size = subscriptions.size();
+        for (int i = 0; i <= size; i++) {
+            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
+                subscriptions.add(i, newSubscription);
+                break;
+            }
+        }
+
+        List<String> subscribedEvents = idsBySubscriber.get(subscriber);
+        if (subscribedEvents == null) {
+            subscribedEvents = new ArrayList<>();
+            idsBySubscriber.put(subscriber, subscribedEvents);
+        }
+        subscribedEvents.add(eventId);
+    }
+
+    private void unsubscribeByEventId(Object subscriber, String eventId) {
+        List<Subscription> subscriptions = subscriptionsByEventId.get(eventId);
+        if (subscriptions != null) {
+            int size = subscriptions.size();
+            for (int i = 0; i < size; i++) {
+                Subscription subscription = subscriptions.get(i);
+                if (subscriber == null || subscription.subscriber == subscriber) {
+                    subscription.active = false;
+                    subscriptions.remove(i);
+                    i--;
+                    size--;
+                    // harryguo：idsBySubscriber里的数据也要清一下
+                    List<String> subscribedIds = idsBySubscriber.get(subscription.subscriber);
+                    if (subscribedIds != null) {
+                        subscribedIds.remove(eventId);
+                        if (subscribedIds.isEmpty())
+                            idsBySubscriber.remove(subscription.subscriber);
+                    }
+                }
+            }
+            // harryguo: 如果订阅者都已经被删光了，那这个EventId的记录就可以整体被删掉了
+            if (subscriptions.isEmpty())
+                subscriptionsByEventId.remove(eventId);
+        }
+    }
+
+    public boolean hasSubscriberForEvent(String eventId) {
+        CopyOnWriteArrayList<Subscription> subscriptions;
+        synchronized (this) {
+            subscriptions = subscriptionsByEventId.get(eventId);
+        }
+        if (subscriptions != null && !subscriptions.isEmpty()) {
+            return true;
+        }
+        return false;
+    }
+
+    public Object process(Object eventContent, int eventId) {
+        return process(eventContent, String.valueOf(eventId));
+    }
+
+    public Object process(Object eventContent, String eventId) {
+        Object retValue = null;
+        if (TextUtils.isEmpty(eventId)) {
+            // 支持EventBus的原始调用方式（无eventId，只有eventContent的方式）
+            retValue = process(eventContent);
+        }
+        else {
+            boolean subscriptionFound = false;
+            CopyOnWriteArrayList<Subscription> subscriptions;
+            synchronized (this) {
+                subscriptions = subscriptionsByEventId.get(eventId);
+            }
+            // 只调用一个处理者
+            if (subscriptions != null && !subscriptions.isEmpty()) {
+                Subscription subscription = subscriptions.get(0);
+                Class<?> eventType = subscription.subscriberMethod.eventType;
+                if (eventContent == null || (eventType != null && eventType.isInstance(eventContent))) {
+                    try {
+                        retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, eventContent);
+                    } catch (InvocationTargetException e) {
+                        handleSubscriberException(subscription, eventContent, e.getCause());
+                    } catch (IllegalAccessException e) {
+                        throw new IllegalStateException("Unexpected exception", e);
+                    }
+                    subscriptionFound = true;
+                }
+            }
+            if (!subscriptionFound) {
+                if (logNoSubscriberMessages) {
+                    logger.log(Level.FINE, "No subscribers registered for event " + eventId);
+                }
+                if (sendNoSubscriberEvent) {
+                    post(new NoSubscriberEvent(this, eventContent));
+                }
+            }
+        }
+        return retValue;
+    }
+
     /**
+     * 默认process
      * 调用订阅者，并获得返回值（关键在于：只调用第一个订阅者，其他的订阅者直接忽略。程序设计之初就假定这种订阅者只有一个，多了那是程序失误）
      */
     public Object process(Object event) {
@@ -612,5 +788,60 @@ public Object process(Object event) {
         }
         return retValue;
     }
+
+    /** Posts the given event to the event bus, with event id. */
+
+    public void post(Object event, int eventId) {
+        post(event, String.valueOf(eventId));
+    }
+
+    public void post(Object event, String eventId) {
+        PostingThreadState postingState = currentPostingThreadState.get();
+        List<PostingThreadState.EventMessage> eventQueue = postingState.eventQueue;
+        eventQueue.add(new PostingThreadState.EventMessage(event, eventId));
+
+        if (!postingState.isPosting) {
+            postingState.isMainThread = isMainThread();
+            postingState.isPosting = true;
+            if (postingState.canceled) {
+                throw new EventBusException("Internal error. Abort state was not reset");
+            }
+            try {
+                while (!eventQueue.isEmpty()) {
+                    postSingleEvent(eventQueue.remove(0), postingState);
+                }
+            } finally {
+                postingState.isPosting = false;
+                postingState.isMainThread = false;
+            }
+        }
+    }
+
+    private boolean postSingleEventForEventId(PostingThreadState.EventMessage eventMsg, PostingThreadState postingState) {
+        CopyOnWriteArrayList<Subscription> subscriptions;
+        synchronized (this) {
+            subscriptions = subscriptionsByEventId.get(eventMsg.eventId);
+        }
+        if (subscriptions != null && !subscriptions.isEmpty()) {
+            for (Subscription subscription : subscriptions) {
+                postingState.event = eventMsg.event;
+                postingState.subscription = subscription;
+                boolean aborted = false;
+                try {
+                    postToSubscription(subscription, eventMsg.event, postingState.isMainThread);
+                    aborted = postingState.canceled;
+                } finally {
+                    postingState.event = null;
+                    postingState.subscription = null;
+                    postingState.canceled = false;
+                }
+                if (aborted) {
+                    break;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
     // harryguo end。以上全是harryguo的代码，有harryguo start做开始。
 }
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscribe.java b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
index ed0b8c82..4dbf2f42 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscribe.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
@@ -40,5 +40,11 @@
      * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
      * delivery among subscribers with different {@link ThreadMode}s! */
     int priority() default 0;
+
+    // 相当于一个filter，指定只有这种事件才接收，忽略参数的class type
+    String eventId() default "";
+
+    // 排他性的，谨慎指定！会将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
+    boolean exclusive() default false;
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..deeb053c 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -24,15 +24,19 @@
     final Class<?> eventType;
     final int priority;
     final boolean sticky;
+    final String eventId;
+    final boolean exclusive;
     /** Used for efficient comparison */
     String methodString;
 
-    public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
+    public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky, String eventId, boolean exclusive) {
         this.method = method;
         this.threadMode = threadMode;
         this.eventType = eventType;
         this.priority = priority;
         this.sticky = sticky;
+        this.eventId = eventId;
+        this.exclusive = exclusive;
     }
 
     @Override
@@ -57,6 +61,7 @@ private synchronized void checkMethodString() {
             builder.append(method.getDeclaringClass().getName());
             builder.append('#').append(method.getName());
             builder.append('(').append(eventType.getName());
+            builder.append(eventId).append(exclusive);
             methodString = builder.toString();
         }
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 8d613678..5fdd9fbb 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -169,8 +169,10 @@ private void findUsingReflectionInSingleClass(FindState findState) {
                         Class<?> eventType = parameterTypes[0];
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            String  eventId = subscribeAnnotation.eventId();
+                            boolean  exclusive = subscribeAnnotation.exclusive();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
-                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
+                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky(), eventId, exclusive));
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
index 9020c24b..8bf2e7d1 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
@@ -59,18 +59,18 @@ public boolean shouldCheckSuperclass() {
     }
 
     protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType) {
-        return createSubscriberMethod(methodName, eventType, ThreadMode.POSTING, 0, false);
+        return createSubscriberMethod(methodName, eventType, ThreadMode.POSTING, 0, false, null, false);
     }
 
     protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType, ThreadMode threadMode) {
-        return createSubscriberMethod(methodName, eventType, threadMode, 0, false);
+        return createSubscriberMethod(methodName, eventType, threadMode, 0, false, null, false);
     }
 
     protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType, ThreadMode threadMode,
-                                                      int priority, boolean sticky) {
+                                                      int priority, boolean sticky, String eventId, boolean exclusive) {
         try {
             Method method = subscriberClass.getDeclaredMethod(methodName, eventType);
-            return new SubscriberMethod(method, eventType, threadMode, priority, sticky);
+            return new SubscriberMethod(method, eventType, threadMode, priority, sticky, eventId, exclusive);
         } catch (NoSuchMethodException e) {
             throw new EventBusException("Could not find subscriber method in " + subscriberClass +
                     ". Maybe a missing ProGuard rule?", e);
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
index 3ee4442d..8296e9c1 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
@@ -36,7 +36,7 @@ public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass
         for (int i = 0; i < length; i++) {
             SubscriberMethodInfo info = methodInfos[i];
             methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,
-                    info.priority, info.sticky);
+                    info.priority, info.sticky, info.eventId, info.exclusive);
         }
         return methods;
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
index 2152554c..35e00351 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
@@ -23,22 +23,27 @@
     final Class<?> eventType;
     final int priority;
     final boolean sticky;
+    // harryguo add. accordingto @Subscribe
+    final String eventId;
+    final boolean exclusive;
 
     public SubscriberMethodInfo(String methodName, Class<?> eventType, ThreadMode threadMode,
-                                int priority, boolean sticky) {
+                                int priority, boolean sticky, String eventId, boolean exclusive) {
         this.methodName = methodName;
         this.threadMode = threadMode;
         this.eventType = eventType;
         this.priority = priority;
         this.sticky = sticky;
+        this.eventId = eventId;
+        this.exclusive = exclusive;
     }
 
     public SubscriberMethodInfo(String methodName, Class<?> eventType) {
-        this(methodName, eventType, ThreadMode.POSTING, 0, false);
+        this(methodName, eventType, ThreadMode.POSTING, 0, false, null, false);
     }
 
     public SubscriberMethodInfo(String methodName, Class<?> eventType, ThreadMode threadMode) {
-        this(methodName, eventType, threadMode, 0, false);
+        this(methodName, eventType, threadMode, 0, false, null, false);
     }
 
 }
\ No newline at end of file
