diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 2812a126..5dfec227 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -61,59 +61,49 @@
             return subscriberMethods;
         }
         subscriberMethods = new ArrayList<SubscriberMethod>();
-        Class<?> clazz = subscriberClass;
         HashSet<String> eventTypesFound = new HashSet<String>();
         StringBuilder methodKeyBuilder = new StringBuilder();
-        while (clazz != null) {
-            String name = clazz.getName();
-            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
-                // Skip system classes, this just degrades performance
-                break;
-            }
-
-            // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
-            Method[] methods = clazz.getMethods();
-            for (Method method : methods) {
-                String methodName = method.getName();
-                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
-                    int modifiers = method.getModifiers();
-                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                        Class<?>[] parameterTypes = method.getParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
-                            ThreadMode threadMode;
-                            if (modifierString.length() == 0) {
-                                threadMode = ThreadMode.PostThread;
-                            } else if (modifierString.equals("MainThread")) {
-                                threadMode = ThreadMode.MainThread;
-                            } else if (modifierString.equals("BackgroundThread")) {
-                                threadMode = ThreadMode.BackgroundThread;
-                            } else if (modifierString.equals("Async")) {
-                                threadMode = ThreadMode.Async;
+        // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+        Method[] methods = subscriberClass.getMethods();
+        for (Method method : methods) {
+            String methodName = method.getName();
+            if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
+                int modifiers = method.getModifiers();
+                if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                    Class<?>[] parameterTypes = method.getParameterTypes();
+                    if (parameterTypes.length == 1) {
+                        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
+                        ThreadMode threadMode;
+                        if (modifierString.length() == 0) {
+                            threadMode = ThreadMode.PostThread;
+                        } else if (modifierString.equals("MainThread")) {
+                            threadMode = ThreadMode.MainThread;
+                        } else if (modifierString.equals("BackgroundThread")) {
+                            threadMode = ThreadMode.BackgroundThread;
+                        } else if (modifierString.equals("Async")) {
+                            threadMode = ThreadMode.Async;
+                        } else {
+                            if (skipMethodVerificationForClasses.containsKey(subscriberClass)) {
+                                continue;
                             } else {
-                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
-                                    continue;
-                                } else {
-                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
-                                }
-                            }
-                            Class<?> eventType = parameterTypes[0];
-                            methodKeyBuilder.setLength(0);
-                            methodKeyBuilder.append(methodName);
-                            methodKeyBuilder.append('>').append(eventType.getName());
-                            String methodKey = methodKeyBuilder.toString();
-                            if (eventTypesFound.add(methodKey)) {
-                                // Only add if not already found in a sub class
-                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                                throw new EventBusException("Illegal onEvent method, check for typos: " + method);
                             }
                         }
-                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
-                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
-                                + methodName);
+                        Class<?> eventType = parameterTypes[0];
+                        methodKeyBuilder.setLength(0);
+                        methodKeyBuilder.append(methodName);
+                        methodKeyBuilder.append('>').append(eventType.getName());
+                        String methodKey = methodKeyBuilder.toString();
+                        if (eventTypesFound.add(methodKey)) {
+                            // Only add if not already found in a sub class
+                            subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                        }
                     }
+                } else if (!skipMethodVerificationForClasses.containsKey(subscriberClass)) {
+                    Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + subscriberClass + "."
+                            + methodName);
                 }
             }
-            clazz = clazz.getSuperclass();
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
