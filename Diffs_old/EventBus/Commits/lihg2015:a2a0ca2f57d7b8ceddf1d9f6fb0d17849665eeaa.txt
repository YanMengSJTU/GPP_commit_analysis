diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..37112b72 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -21,8 +21,11 @@
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
@@ -180,6 +183,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
+                    //如果注册事件的类型在粘性事件的缓存里面执行checkPostStickyEventToSubscription
                     if (eventType.isAssignableFrom(candidateEventType)) {
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
@@ -237,8 +241,9 @@ public synchronized void unregister(Object subscriber) {
     /** Posts the given event to the event bus. */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
-        List<Object> eventQueue = postingState.eventQueue;
-        eventQueue.add(event);
+
+        Queue<Object> eventQueue = postingState.eventQueue;
+        eventQueue.offer(event);//添加事件
 
         if (!postingState.isPosting) {
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
@@ -246,9 +251,11 @@ public void post(Object event) {
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
+
             try {
-                while (!eventQueue.isEmpty()) {
-                    postSingleEvent(eventQueue.remove(0), postingState);
+                Object temp ;
+                while ((temp = eventQueue.poll())!=null) {
+                    postSingleEvent(temp, postingState);
                 }
             } finally {
                 postingState.isPosting = false;
@@ -446,7 +453,7 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 Class<?> clazz = eventClass;
                 while (clazz != null) {
                     eventTypes.add(clazz);
-                    addInterfaces(eventTypes, clazz.getInterfaces());
+                    addInterfaces(eventTypes, clazz.getInterfaces());//添加所有父类接口类型
                     clazz = clazz.getSuperclass();
                 }
                 eventTypesCache.put(eventClass, eventTypes);
@@ -518,7 +525,8 @@ private void handleSubscriberException(Subscription subscription, Object event,
 
     /** For ThreadLocal, much faster to set (and get multiple values). */
     final static class PostingThreadState {
-        final List<Object> eventQueue = new ArrayList<Object>();
+        //事件对象
+        final Queue<Object> eventQueue = new LinkedList<>();
         boolean isPosting;
         boolean isMainThread;
         Subscription subscription;
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 3247be53..48e5ccbc 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -35,11 +35,15 @@
     }
 
     void enqueue(Subscription subscription, Object event) {
+        //缓存获取发送对象
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
+            //加入到执行队列里面
             queue.enqueue(pendingPost);
+            //是否正在执行
             if (!handlerActive) {
                 handlerActive = true;
+                //发送主线程消息
                 if (!sendMessage(obtainMessage())) {
                     throw new EventBusException("Could not send handler message");
                 }
@@ -49,7 +53,7 @@ void enqueue(Subscription subscription, Object event) {
 
     @Override
     public void handleMessage(Message msg) {
-        boolean rescheduled = false;
+        boolean rescheduled = false;//是否执行超时
         try {
             long started = SystemClock.uptimeMillis();
             while (true) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..edf5f586 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -34,39 +34,49 @@
      */
     private static final int BRIDGE = 0x40;
     private static final int SYNTHETIC = 0x1000;
-
+    //忽略方法
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+    //订阅者的class为key，所有的订阅方法对象集合为value的缓存
     private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
-
+    //索引集合，暂时不关心他的结构
     private List<SubscriberInfoIndex> subscriberInfoIndexes;
+    //是否方法严格校验
     private final boolean strictMethodVerification;
+    //是否忽略索引
     private final boolean ignoreGeneratedIndex;
-
+    //对象池个数
     private static final int POOL_SIZE = 4;
+    //对象池
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
-
+    //默认构造函数
     SubscriberMethodFinder(List<SubscriberInfoIndex> subscriberInfoIndexes, boolean strictMethodVerification,
                            boolean ignoreGeneratedIndex) {
         this.subscriberInfoIndexes = subscriberInfoIndexes;
         this.strictMethodVerification = strictMethodVerification;
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
-
+    //核心方法:
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
-        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
+        //从缓存中查找
+        List<SubscriberMethod> subscriberMethods = null;//METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //从缓存中没有找到
         if (ignoreGeneratedIndex) {
+            //忽略索引
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //使用索引
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+
         if (subscriberMethods.isEmpty()) {
+            //没有找到订阅方法　抛出异常
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //增加到缓存并返回集合
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -138,7 +148,9 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
     }
 
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        //获取查找对象
         FindState findState = prepareFindState();
+        //初始化
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
             findUsingReflectionInSingleClass(findState);
@@ -189,9 +201,13 @@ static void clearCaches() {
     }
 
     static class FindState {
+        //所有订阅方法的集合
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+        //事件类型是已经存在的标识map
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+        //方法key和方法所属的类组成的标识map
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
+        //产生方法key的builder
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
         Class<?> subscriberClass;
@@ -219,11 +235,15 @@ void recycle() {
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            //当前事件类型和方法是否已经添加了
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
+                //没有添加,返回true
                 return true;
             } else {
+                //已经添加了,判断前一个添加的标识对象是不是方法对象
                 if (existing instanceof Method) {
+                    //是否已经添加了
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
index e22631c1..c81967d9 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
@@ -80,6 +80,25 @@ public void onEventMainThread(TestFinishedEvent event) {
         }
     }
 
+    @Subscribe(threadMode = ThreadMode.MAIN)
+    public void asasasdasd(TestFinishedEvent event) {
+        Test test = event.test;
+        String text = "<b>" + test.getDisplayName() + "</b><br/>" + //
+                test.getPrimaryResultMicros() + " micro seconds<br/>" + //
+                ((int) test.getPrimaryResultRate()) + "/s<br/>";
+        if (test.getOtherTestResults() != null) {
+            text += test.getOtherTestResults();
+        }
+        text += "<br/>----------------<br/>";
+        textViewResult.append(Html.fromHtml(text));
+        if (event.isLastEvent) {
+            findViewById(R.id.buttonCancel).setVisibility(View.GONE);
+            findViewById(R.id.textViewTestRunning).setVisibility(View.GONE);
+            findViewById(R.id.buttonKillProcess).setVisibility(View.VISIBLE);
+        }
+    }
+
+
     public void onClickCancel(View view) {
         // Cancel asap
         if (testRunner != null) {
