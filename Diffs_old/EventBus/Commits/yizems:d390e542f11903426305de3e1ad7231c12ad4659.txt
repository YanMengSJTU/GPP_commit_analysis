diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..75e0a199 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -40,16 +40,31 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
-
+    /**
+     * 单例对象
+     */
     static volatile EventBus defaultInstance;
-
+    /**
+     * 默认的EventBus构建者
+     */
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+    /**
+     * 事件类型缓存???
+     */
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**
+     * 类和订阅者存储,第一个为创建的Event对象,第二个为订阅者
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    /**
+     * 主要完成的是事情就是保存sticky 标记的类,可以将附带的信息保存起来,在需要的时候可以再取出来
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -74,7 +89,11 @@ protected PostingThreadState initialValue() {
 
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * 单例创建一个默认的实例
+     * 还是double check lock 方式
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -86,11 +105,18 @@ public static EventBus getDefault() {
         return defaultInstance;
     }
 
+    /**
+     * 创建一个构建者
+     * @return
+     */
     public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * 主要用于单元测试?
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -104,6 +130,10 @@ public EventBus() {
         this(DEFAULT_BUILDER);
     }
 
+    /**
+     * 通过构建者 构建EventBus
+     * @param builder
+     */
     EventBus(EventBusBuilder builder) {
         subscriptionsByEventType = new HashMap<>();
         typesBySubscriber = new HashMap<>();
@@ -204,7 +234,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -221,7 +253,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -234,7 +268,9 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
@@ -437,7 +473,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -455,7 +493,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -516,7 +556,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
index e212750e..6bf38276 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
@@ -27,6 +27,9 @@
  * Create a new builder using {@link EventBus#builder()}.
  */
 public class EventBusBuilder {
+    /**
+     * 默认线程池
+     */
     private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
 
     boolean logSubscriberExceptions = true;
@@ -44,31 +47,44 @@
     EventBusBuilder() {
     }
 
-    /** Default: true */
+    /**
+     * Log
+     * Default: true
+     */
     public EventBusBuilder logSubscriberExceptions(boolean logSubscriberExceptions) {
         this.logSubscriberExceptions = logSubscriberExceptions;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * 没有订阅者时 打印log
+     * Default: true
+     */
     public EventBusBuilder logNoSubscriberMessages(boolean logNoSubscriberMessages) {
         this.logNoSubscriberMessages = logNoSubscriberMessages;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * 发送广播异常log
+     * Default: true
+     */
     public EventBusBuilder sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent) {
         this.sendSubscriberExceptionEvent = sendSubscriberExceptionEvent;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * 发送的时候没有订阅者时是否log
+     * Default: true
+     */
     public EventBusBuilder sendNoSubscriberEvent(boolean sendNoSubscriberEvent) {
         this.sendNoSubscriberEvent = sendNoSubscriberEvent;
         return this;
     }
 
     /**
+     * 发送广播失败时抛出异常
      * Fails if an subscriber throws an exception (default: false).
      * <p/>
      * Tip: Use this with BuildConfig.DEBUG to let the app crash in DEBUG mode (only). This way, you won't miss
@@ -80,6 +96,8 @@ public EventBusBuilder throwSubscriberException(boolean throwSubscriberException
     }
 
     /**
+     * 事件类层次结构??不太明白<br/>
+     * 关闭这个会提高效率,大概20%左右吧,但是对于系统来说,这个并不会占用太多的时间,只是一个相对的优化<br/>
      * By default, EventBus considers the event class hierarchy (subscribers to super classes will be notified).
      * Switching this feature off will improve posting of events. For simple event classes extending Object directly,
      * we measured a speed up of 20% for event posting. For more complex event hierarchies, the speed up should be
@@ -95,6 +113,7 @@ public EventBusBuilder eventInheritance(boolean eventInheritance) {
 
 
     /**
+     * 提供一个自定义的线程池
      * Provide a custom thread pool to EventBus used for async and background event delivery. This is an advanced
      * setting to that can break things: ensure the given ExecutorService won't get stuck to avoid undefined behavior.
      */
@@ -104,6 +123,12 @@ public EventBusBuilder executorService(ExecutorService executorService) {
     }
 
     /**
+     * 不太明白
+     *
+     * 对于以onEvent开头的方法，方法名称的验证是为了避免拼写错误;
+     * 使用此方法，您可以从此检查中排除订阅类。
+     * 还禁用检查方法修饰符（public，not static或abstract）
+     *
      * Method name verification is done for methods starting with onEvent to avoid typos; using this method you can
      * exclude subscriber classes from this check. Also disables checks for method modifiers (public, not static nor
      * abstract).
@@ -116,21 +141,33 @@ public EventBusBuilder skipMethodVerificationFor(Class<?> clazz) {
         return this;
     }
 
-    /** Forces the use of reflection even if there's a generated index (default: false). */
+    /**
+     * 强制使用反射即使有生成的索引
+     * 默认:false
+     * Forces the use of reflection even if there's a generated index (default: false).
+     */
     public EventBusBuilder ignoreGeneratedIndex(boolean ignoreGeneratedIndex) {
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
         return this;
     }
 
-    /** Enables strict method verification (default: false). */
+    /**
+     * 是否使用严格的方法验证方式
+     * 默认:false
+     * Enables strict method verification (default: false).
+     */
     public EventBusBuilder strictMethodVerification(boolean strictMethodVerification) {
         this.strictMethodVerification = strictMethodVerification;
         return this;
     }
 
-    /** Adds an index generated by EventBus' annotation preprocessor. */
+    /**
+     * 简单来说,就是预先将事件类添加到EventBus中
+     * {@link SubscriberInfoIndex}
+     * Adds an index generated by EventBus' annotation preprocessor.
+     */
     public EventBusBuilder addIndex(SubscriberInfoIndex index) {
-        if(subscriberInfoIndexes == null) {
+        if (subscriberInfoIndexes == null) {
             subscriberInfoIndexes = new ArrayList<>();
         }
         subscriberInfoIndexes.add(index);
@@ -154,7 +191,10 @@ public EventBus installDefaultEventBus() {
         }
     }
 
-    /** Builds an EventBus based on the current configuration. */
+    /**
+     * 构建一个EventBus
+     * Builds an EventBus based on the current configuration.
+     */
     public EventBus build() {
         return new EventBus(this);
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscribe.java b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
index ed0b8c82..a575f066 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscribe.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
@@ -30,15 +30,19 @@
     ThreadMode threadMode() default ThreadMode.POSTING;
 
     /**
+     * 参照:<a href="http://greenrobot.org/eventbus/documentation/configuration/sticky-events/">sticky文档<a/><br></>
      * If true, delivers the most recent sticky event (posted with
      * {@link EventBus#postSticky(Object)}) to this subscriber (if event available).
      */
     boolean sticky() default false;
 
-    /** Subscriber priority to influence the order of event delivery.
+    /**
+     * 优先级
+     * Subscriber priority to influence the order of event delivery.
      * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before
      * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
-     * delivery among subscribers with different {@link ThreadMode}s! */
+     * delivery among subscribers with different {@link ThreadMode}s!
+     */
     int priority() default 0;
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..1fa43645 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,14 +17,35 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/**
+ * Used internally by EventBus and generated subscriber indexes.
+ * 订阅方法类
+ */
 public class SubscriberMethod {
+    /**
+     * 方法
+     */
     final Method method;
+    /**
+     * 线程类型
+     */
     final ThreadMode threadMode;
+    /**
+     * 事件类型,其实就是Event.post(new Object.class);
+     */
     final Class<?> eventType;
+    /**
+     * 优先级
+     */
     final int priority;
+    /**
+     * !!!
+     */
     final boolean sticky;
-    /** Used for efficient comparison */
+    /**
+     * 用于高效的比较?不知道啥意思
+     * Used for efficient comparison
+     */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
@@ -35,21 +56,33 @@ public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode
         this.sticky = sticky;
     }
 
+    /**
+     * 比较
+     *
+     * @param other
+     * @return
+     */
     @Override
     public boolean equals(Object other) {
         if (other == this) {
             return true;
         } else if (other instanceof SubscriberMethod) {
             checkMethodString();
-            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod) other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
+            //之所以不使用Method.equals,是因为该方法会浪费大量的时间
+            //所以采用拼接方法字符串的方法来完成对比
             return methodString.equals(otherSubscriberMethod.methodString);
         } else {
             return false;
         }
     }
 
+    /**
+     * 拼接方法信息<br/>
+     * className#methodName(eventTypeName)
+     */
     private synchronized void checkMethodString() {
         if (methodString == null) {
             // Method.toString has more overhead, just take relevant parts of the method
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..29588610 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,8 +15,17 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 订阅者包装类,类,方法
+ */
 final class Subscription {
+    /**
+     * 订阅者
+     */
     final Object subscriber;
+    /**
+     * 订阅的方法
+     */
     final SubscriberMethod subscriberMethod;
     /**
      * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
@@ -24,12 +33,21 @@
      */
     volatile boolean active;
 
+    /**
+     * @param subscriber 订阅者
+     * @param subscriberMethod 订阅的方法
+     */
     Subscription(Object subscriber, SubscriberMethod subscriberMethod) {
         this.subscriber = subscriber;
         this.subscriberMethod = subscriberMethod;
         active = true;
     }
 
+    /**
+     * 订阅者对比,类一样,方法名一样
+     * @param other
+     * @return
+     */
     @Override
     public boolean equals(Object other) {
         if (other instanceof Subscription) {
@@ -41,6 +59,10 @@ public boolean equals(Object other) {
         }
     }
 
+    /**
+     * 订阅者hascode和订阅方法的hascode
+     * @return
+     */
     @Override
     public int hashCode() {
         return subscriber.hashCode() + subscriberMethod.methodString.hashCode();
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index 79d5dc43..1e7f99f9 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -18,12 +18,13 @@
 /**
  * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
  * EventBus takes care of threading independently from the posting thread.
- * 
- * @see EventBus#register(Object)
+ *
  * @author Markus
+ * @see EventBus#register(Object)
  */
 public enum ThreadMode {
     /**
+     * 同一个线程
      * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
      * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
      * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
@@ -32,6 +33,7 @@
     POSTING,
 
     /**
+     * Android 主线程
      * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
      * the main thread, event handler methods will be called directly. Event handlers using this mode must return
      * quickly to avoid blocking the main thread.
@@ -39,6 +41,7 @@
     MAIN,
 
     /**
+     * 后台线程,如果不是主线程,那么还在当前线程执行
      * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
      * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
      * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
@@ -47,6 +50,7 @@
     BACKGROUND,
 
     /**
+     * 重新创建一个线程
      * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
      * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
      * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
index 9fc65f6f..aa26eade 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
@@ -17,6 +17,7 @@
 
 /**
  * Interface for generated indexes.
+ * <a href="http://greenrobot.org/eventbus/documentation/subscriber-index/" > 参考官方文档<a/>
  */
 public interface SubscriberInfoIndex {
     SubscriberInfo getSubscriberInfo(Class<?> subscriberClass);
