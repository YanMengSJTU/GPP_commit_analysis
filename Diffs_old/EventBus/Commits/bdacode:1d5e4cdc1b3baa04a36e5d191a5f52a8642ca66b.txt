diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index 057f8b42..20ccc454 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -15,6 +15,9 @@
  */
 package de.greenrobot.event;
 
+import android.os.Looper;
+import android.util.Log;
+
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -25,32 +28,31 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import android.os.Looper;
-import android.util.Log;
-
 /**
  * EventBus is a central publish/subscribe event system for Android. Events are posted ({@link #post(Object)} to the
  * bus, which delivers it to subscribers that have matching handler methods for the event type. To receive events,
  * subscribers must register themselves to the bus using the {@link #register(Object)} method. Once registered,
  * subscribers receive events until the call of {@link #unregister(Object)}. By convention, event handling methods must
  * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event).
- * 
+ *
  * @author Markus Junginger, greenrobot
  */
 public class EventBus {
     static ExecutorService executorService = Executors.newCachedThreadPool();
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "Event";
 
     private static volatile EventBus defaultInstance;
 
-    private static final String DEFAULT_METHOD_NAME = "onEvent";
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();
 
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
+    private final ConcurrentHashMap<Class<?>, ConcurrentHashMap<Class<?>, String>> stickyEventsReadMarks;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
@@ -59,6 +61,7 @@ protected PostingThreadState initialValue() {
         }
     };
 
+    private String defaultMethodName = "onEvent";
 
     private final HandlerPoster mainThreadPoster;
     private final BackgroundPoster backgroundPoster;
@@ -68,7 +71,9 @@ protected PostingThreadState initialValue() {
     private boolean subscribed;
     private boolean logSubscriberExceptions;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -80,7 +85,9 @@ public static EventBus getDefault() {
         return defaultInstance;
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -95,7 +102,9 @@ public static void skipMethodVerificationFor(Class<?> clazz) {
         SubscriberMethodFinder.skipMethodVerificationFor(clazz);
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearSkipMethodNameVerifications() {
         SubscriberMethodFinder.clearSkipMethodVerifications();
     }
@@ -108,6 +117,7 @@ public EventBus() {
         subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();
         typesBySubscriber = new HashMap<Object, List<Class<?>>>();
         stickyEvents = new ConcurrentHashMap<Class<?>, Object>();
+        stickyEventsReadMarks = new ConcurrentHashMap<Class<?>, ConcurrentHashMap<Class<?>, String>>();
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
@@ -129,7 +139,7 @@ public void configureLogSubscriberExceptions(boolean logSubscriberExceptions) {
     /**
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they are
      * no longer interested in receiving events.
-     * 
+     * <p/>
      * Subscribers have event handling methods that are identified by their name, typically called "onEvent". Event
      * handling methods must have exactly one parameter, the event. If the event handling method is to be called in a
      * specific thread, a modifier is appended to the method name. Valid modifiers match one of the {@link ThreadMode}
@@ -137,7 +147,7 @@ public void configureLogSubscriberExceptions(boolean logSubscriberExceptions) {
      * "onEventMainThread".
      */
     public void register(Object subscriber) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, 0);
+        register(subscriber, defaultMethodName, false, 0);
     }
 
     /**
@@ -147,7 +157,7 @@ public void register(Object subscriber) {
      * delivery among subscribers with different {@link ThreadMode}s!
      */
     public void register(Object subscriber, int priority) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, priority);
+        register(subscriber, defaultMethodName, false, priority);
     }
 
     /**
@@ -163,15 +173,15 @@ public void register(Object subscriber, String methodName) {
      * {@link #postSticky(Object)}) to the given subscriber.
      */
     public void registerSticky(Object subscriber) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, 0);
+        register(subscriber, defaultMethodName, true, 0);
     }
 
     /**
-     * Like {@link #register(Object,int)}, but also triggers delivery of the most recent sticky event (posted with
+     * Like {@link #register(Object, int)}, but also triggers delivery of the most recent sticky event (posted with
      * {@link #postSticky(Object)}) to the given subscriber.
      */
     public void registerSticky(Object subscriber, int priority) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, priority);
+        register(subscriber, defaultMethodName, true, priority);
     }
 
     /**
@@ -195,7 +205,7 @@ private synchronized void register(Object subscriber, String methodName, boolean
      */
     @Deprecated
     public void register(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, eventType, moreEventTypes);
+        register(subscriber, defaultMethodName, false, eventType, moreEventTypes);
     }
 
     /**
@@ -211,7 +221,7 @@ public void register(Object subscriber, String methodName, Class<?> eventType, C
      */
     @Deprecated
     public void registerSticky(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, eventType, moreEventTypes);
+        register(subscriber, defaultMethodName, true, eventType, moreEventTypes);
     }
 
     /**
@@ -223,7 +233,7 @@ public void registerSticky(Object subscriber, String methodName, Class<?> eventT
     }
 
     private synchronized void register(Object subscriber, String methodName, boolean sticky, Class<?> eventType,
-            Class<?>... moreEventTypes) {
+                                       Class<?>... moreEventTypes) {
         Class<?> subscriberClass = subscriber.getClass();
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass,
                 methodName);
@@ -283,9 +293,12 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boo
                 stickyEvent = stickyEvents.get(eventType);
             }
             if (stickyEvent != null) {
-                // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
-                // --> Strange corner case, which we don't take care of here.
-                postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
+                // if event is not marked as processed
+                if (!stickyEventsReadMarks.containsKey(eventType) || !stickyEventsReadMarks.get(eventType).containsKey(subscriber.getClass())) {
+                    // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
+                    // --> Strange corner case, which we don't take care of here.
+                    postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
+                }
             }
         }
     }
@@ -316,7 +329,9 @@ public synchronized void unregister(Object subscriber, Class<?>... eventTypes) {
         }
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -333,7 +348,9 @@ private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -346,7 +363,9 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
@@ -400,6 +419,7 @@ public void cancelEventDelivery(Object event) {
      */
     public void postSticky(Object event) {
         synchronized (stickyEvents) {
+            stickyEventsReadMarks.remove(event.getClass());
             stickyEvents.put(event.getClass(), event);
         }
         // Should be posted after it is putted, in case the subscriber wants to remove immediately
@@ -408,7 +428,7 @@ public void postSticky(Object event) {
 
     /**
      * Gets the most recent sticky event for the given type.
-     * 
+     *
      * @see #postSticky(Object)
      */
     public <T> T getStickyEvent(Class<T> eventType) {
@@ -419,23 +439,25 @@ public void postSticky(Object event) {
 
     /**
      * Remove and gets the recent sticky event for the given event type.
-     * 
+     *
      * @see #postSticky(Object)
      */
     public <T> T removeStickyEvent(Class<T> eventType) {
         synchronized (stickyEvents) {
+            stickyEventsReadMarks.remove(eventType);
             return eventType.cast(stickyEvents.remove(eventType));
         }
     }
 
     /**
      * Removes the sticky event if it equals to the given event.
-     * 
+     *
      * @return true if the events matched and the sticky event was removed.
      */
     public boolean removeStickyEvent(Object event) {
         synchronized (stickyEvents) {
             Class<? extends Object> eventType = event.getClass();
+            stickyEventsReadMarks.remove(eventType);
             Object existingEvent = stickyEvents.get(eventType);
             if (event.equals(existingEvent)) {
                 stickyEvents.remove(eventType);
@@ -446,6 +468,26 @@ public boolean removeStickyEvent(Object event) {
         }
     }
 
+
+    /**
+     * Removes the sticky event if it equals to the given event only for subscribers of the specific class.
+     *
+     * @return true if the events matched and the sticky event was removed.
+     */
+    public void consumeStickyEvent(Class<?> subscriberClass, Object event) {
+        synchronized (stickyEventsReadMarks) {
+
+            ConcurrentHashMap<Class<?>, String> classStringConcurrentHashMap;
+            if (stickyEventsReadMarks.containsKey(event.getClass())) {
+                classStringConcurrentHashMap = stickyEventsReadMarks.get(event.getClass());
+            } else {
+                classStringConcurrentHashMap = new ConcurrentHashMap<Class<?>, String>();
+            }
+            classStringConcurrentHashMap.put(subscriberClass, "read");
+            stickyEventsReadMarks.put(event.getClass(), classStringConcurrentHashMap);
+        }
+    }
+
     /**
      * Removes all sticky events.
      */
@@ -496,32 +538,34 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
-        case PostThread:
-            invokeSubscriber(subscription, event);
-            break;
-        case MainThread:
-            if (isMainThread) {
+            case PostThread:
                 invokeSubscriber(subscription, event);
-            } else {
-                mainThreadPoster.enqueue(subscription, event);
-            }
-            break;
-        case BackgroundThread:
-            if (isMainThread) {
-                backgroundPoster.enqueue(subscription, event);
-            } else {
-                invokeSubscriber(subscription, event);
-            }
-            break;
-        case Async:
-            asyncPoster.enqueue(subscription, event);
-            break;
-        default:
-            throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
+                break;
+            case MainThread:
+                if (isMainThread) {
+                    invokeSubscriber(subscription, event);
+                } else {
+                    mainThreadPoster.enqueue(subscription, event);
+                }
+                break;
+            case BackgroundThread:
+                if (isMainThread) {
+                    backgroundPoster.enqueue(subscription, event);
+                } else {
+                    invokeSubscriber(subscription, event);
+                }
+                break;
+            case Async:
+                asyncPoster.enqueue(subscription, event);
+                break;
+            default:
+                throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
         }
     }
 
-    /** Finds all Class objects including super classes and interfaces. */
+    /**
+     * Finds all Class objects including super classes and interfaces.
+     */
     private List<Class<?>> findEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -539,7 +583,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -590,7 +636,9 @@ void invokeSubscriber(Subscription subscription, Object event) throws Error {
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
@@ -604,5 +652,4 @@ void invokeSubscriber(Subscription subscription, Object event) throws Error {
     /* public */interface PostCallback {
         void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
     }
-
-}
+}
\ No newline at end of file
