diff --git a/EventBus/src/de/greenrobot/event/AsyncPoster.java b/EventBus/src/de/greenrobot/event/AsyncPoster.java
index 936527b7..8a73806a 100644
--- a/EventBus/src/de/greenrobot/event/AsyncPoster.java
+++ b/EventBus/src/de/greenrobot/event/AsyncPoster.java
@@ -18,7 +18,10 @@
 
 /**
  * Posts events in background.
- * 
+ * <br/>
+ * <br/>
+ * 事件异步线程处理，对应ThreadMode.Async，继承自 Runnable。enqueue 函数将事件放到队列中，并调用线程池执行当前任务，
+ * 在 run 函数从队列中取事件，invoke 事件响应函数处理。
  * @author Markus
  */
 class AsyncPoster implements Runnable {
diff --git a/EventBus/src/de/greenrobot/event/BackgroundPoster.java b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
index 00e9ee54..afcbc035 100644
--- a/EventBus/src/de/greenrobot/event/BackgroundPoster.java
+++ b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
@@ -19,7 +19,11 @@
 
 /**
  * Posts events in background.
- * 
+ * <br/>
+ * <br/>
+ * 事件 Background 处理，对应ThreadMode.BackgroundThread，继承自 Runnable。enqueue 函数将事件放到队列中，
+ * 并调用线程池执行当前任务，在 run 函数从队列中取事件，invoke 事件响应函数处理。与 AsyncPoster.java 不同的是，
+ * BackgroundPoster 中的任务只在同一个线程中依次执行，而不是并发执行。
  * @author Markus
  */
 final class BackgroundPoster implements Runnable {
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index 95863ade..551d31d0 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -35,6 +35,8 @@
  * subscribers receive events until {@link #unregister(Object)} is called. By convention, event handling methods must
  * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event).
  *
+ *
+ *
  * @author Markus Junginger, greenrobot
  */
 public class EventBus {
@@ -42,15 +44,41 @@
     /** Log tag, apps may override it. */
     public static String TAG = "Event";
 
-    static volatile EventBus defaultInstance;
+    static volatile EventBus defaultInstance;//默认的 EventBus 实例
+
+    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();//默认的 EventBus Builder。
 
-    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+
+    /**
+     * 事件对应类型及其父类和实现的接口的缓存，以 eventType 为 key，元素为 Object 的 ArrayList 为 Value，Object 对象为 eventType 的父类或接口。
+     */
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();
 
+
+
+    /**
+     * 事件订阅者的保存队列，以 eventType 为 key，元素为Subscription的 ArrayList 为 Value，
+     * <br/>
+     * 其中Subscription为订阅者信息，由 subscriber, subscriberMethod, priority 构成。
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+
+    /**
+     * 订阅者订阅的事件的保存队列，以 subscriber 为 key，元素为 eventType 的 ArrayList 为 Value。
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+
+
+    /**
+     * Sticky 事件保存队列，以 eventType 为 key，event 为元素，由此可以看出对于同一个 eventType 最多只会有一个 event 存在。
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
+
+    /**
+     * 当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消。
+     */
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -59,18 +87,18 @@ protected PostingThreadState initialValue() {
     };
 
 
-    private final HandlerPoster mainThreadPoster;
-    private final BackgroundPoster backgroundPoster;
-    private final AsyncPoster asyncPoster;
-    private final SubscriberMethodFinder subscriberMethodFinder;
-    private final ExecutorService executorService;
+    private final HandlerPoster mainThreadPoster;//事件主线程处理者
+    private final BackgroundPoster backgroundPoster;//事件 Background 处理者
+    private final AsyncPoster asyncPoster;//事件异步处理者。
+    private final SubscriberMethodFinder subscriberMethodFinder;//订阅者响应函数信息存储和查找类。
+    private final ExecutorService executorService;//异步和 BackGround 处理方式的线程池。
 
-    private final boolean throwSubscriberException;
-    private final boolean logSubscriberExceptions;
-    private final boolean logNoSubscriberMessages;
-    private final boolean sendSubscriberExceptionEvent;
-    private final boolean sendNoSubscriberEvent;
-    private final boolean eventInheritance;
+    private final boolean throwSubscriberException;//当调用事件处理函数异常时是否抛出异常，默认为 false，建议通过EventBus.builder().throwSubscriberException(true).installDefaultEventBus()打开。
+    private final boolean logSubscriberExceptions;//当调用事件处理函数异常时是否打印异常信息，默认为 true。
+    private final boolean logNoSubscriberMessages;//当没有订阅者订阅该事件时是否打印日志，默认为 true。
+    private final boolean sendSubscriberExceptionEvent;//当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件，若此开关打开，订阅者可通过public void onEvent(SubscriberExceptionEvent event)订阅该事件进行处理，默认为 true。
+    private final boolean sendNoSubscriberEvent;//当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件，若此开关打开，订阅者可通过public void onEvent(NoSubscriberEvent event)订阅该事件进行处理，默认为 true。
+    private final boolean eventInheritance;//是否支持事件继承，默认为 true。
 
     /** Convenience singleton for apps using a process-wide EventBus instance. */
     public static EventBus getDefault() {
@@ -129,6 +157,13 @@ public EventBus() {
      * specific thread, a modifier is appended to the method name. Valid modifiers match one of the {@link ThreadMode}
      * enums. For example, if a method is to be called in the UI/main thread by EventBus, it would be called
      * "onEventMainThread".
+     *<p/>
+     * 注册订阅者以接收新事件，当订阅者不再对接收事件感兴趣时，订阅者必须调用{@link #unregister(Object)}。
+     * <p/>
+     * 订阅者必须具备处理事件的响应方法，这些方法以方法名做标志，通常叫做"onEvent"。处理方法必须只包含一个参数，事件参数。
+     * 如果处理方法需要在一个指定的线程中调用，就在onEvent方法明上加一个修饰词。有效的修饰词已经在{@link ThreadMode}中定义。
+     * 比如：一个方法要求在主线程中调用，那么该方法需要声明为"onEventMainThread"。
+     *
      */
     public void register(Object subscriber) {
         register(subscriber, false, 0);
@@ -160,7 +195,7 @@ public void registerSticky(Object subscriber, int priority) {
         register(subscriber, true, priority);
     }
 
-    private synchronized void register(Object subscriber, boolean sticky, int priority) {
+    private synchronized void  register(Object subscriber, boolean sticky, int priority) {
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());
         for (SubscriberMethod subscriberMethod : subscriberMethods) {
             subscribe(subscriber, subscriberMethod, sticky, priority);
@@ -169,9 +204,17 @@ private synchronized void register(Object subscriber, boolean sticky, int priori
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {
-        Class<?> eventType = subscriberMethod.eventType;
+
+        /**
+         * 第一步：根据eventType建立或维护该eventType对应的订阅者列表（subscriptions）。
+         */
+
+        Class<?> eventType = subscriberMethod.eventType;//从订阅方法中拿到订阅事件的类型
+        //通过订阅事件类型，找到所有的订阅（Subscription）,订阅中包含了订阅者，订阅方法
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        //创建一个新的订阅
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);
+        //将新建的订阅加入到这个事件类型对应的所有订阅列表
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<Subscription>();
             subscriptionsByEventType.put(eventType, subscriptions);
@@ -186,22 +229,28 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boo
         // subscriberMethod.method.setAccessible(true);
 
         int size = subscriptions.size();
-        for (int i = 0; i <= size; i++) {
+        for (int i = 0; i <= size; i++) {//便利该eventType对应的订阅者，判断优先级，插入到合适的地方。
             if (i == size || newSubscription.priority > subscriptions.get(i).priority) {
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
+        /**
+         * 第二步：根据订阅者的类，建立或维护该类中包含的eventType列表，
+         */
 
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
-        if (subscribedEvents == null) {
+        if (subscribedEvents == null) {//若还没有初始化过，新建并添加
             subscribedEvents = new ArrayList<Class<?>>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
-        subscribedEvents.add(eventType);
+        subscribedEvents.add(eventType);//初始化后加入对应的eventType。
 
+        /**
+         * 其他：如果是sticky的，
+         */
         if (sticky) {
-            if (eventInheritance) {
+            if (eventInheritance) {//如果事件允许继承
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
@@ -263,20 +312,22 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /** Posts the given event to the event bus.
+     * 发送所给事件到event bus。
+     * */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
-        List<Object> eventQueue = postingState.eventQueue;
-        eventQueue.add(event);
+        List<Object> eventQueue = postingState.eventQueue;//当前线程下的事件队列。
+        eventQueue.add(event);//添加到事件队列中
 
-        if (!postingState.isPosting) {
+        if (!postingState.isPosting) {//当前线程下的事件们是否处于发送中状态，如果没有，则执行以下操作
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
-                while (!eventQueue.isEmpty()) {
+                while (!eventQueue.isEmpty()) {//循环发送事件。
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -389,10 +440,16 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 发送单一的一个Event。这个时候还没有确定该Event的EventType，EventType有可能就是该Event，也有可能是他的父类
+     * @param event 事件
+     * @param postingState 发送状态
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
-        boolean subscriptionFound = false;
-        if (eventInheritance) {
+        boolean subscriptionFound = false;//是否有订阅者
+        if (eventInheritance) {//如果允许继承
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -408,23 +465,30 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
             }
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
-                post(new NoSubscriberEvent(this, event));
+                post(new NoSubscriberEvent(this, event));//发送没有订阅者的Event
             }
         }
     }
 
+    /**
+     * 发送已经确定EventType的单一的一个Event。
+     * @param event 事件
+     * @param postingState 发送状态
+     * @param eventClass 已确定的EventType
+     * @return
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
-            subscriptions = subscriptionsByEventType.get(eventClass);
+            subscriptions = subscriptionsByEventType.get(eventClass);//得到该EventType的所有订阅者
         }
-        if (subscriptions != null && !subscriptions.isEmpty()) {
+        if (subscriptions != null && !subscriptions.isEmpty()) {//如果订阅者不为空
             for (Subscription subscription : subscriptions) {
                 postingState.event = event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
-                    postToSubscription(subscription, event, postingState.isMainThread);
+                    postToSubscription(subscription, event, postingState.isMainThread);//发送事件给订阅者
                     aborted = postingState.canceled;
                 } finally {
                     postingState.event = null;
@@ -440,8 +504,14 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 发送事件给相应的订阅者
+     * @param subscription 订阅者
+     * @param event 事件
+     * @param isMainThread 发布者是否在主线程
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
-        switch (subscription.subscriberMethod.threadMode) {
+        switch (subscription.subscriberMethod.threadMode) {//根据订阅者的ThreadMode，在不同线程中调用订阅者的事件响应函数
             case PostThread:
                 invokeSubscriber(subscription, event);
                 break;
@@ -467,7 +537,10 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     * <br/>
+     * 找到该EventType所对应的所有父类EventTypes。
+     * */
     private List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -510,6 +583,11 @@ void invokeSubscriber(PendingPost pendingPost) {
         }
     }
 
+    /**
+     * 调用订阅者方法
+     * @param subscription 订阅信息
+     * @param event 一个事件
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
diff --git a/EventBus/src/de/greenrobot/event/EventBusBuilder.java b/EventBus/src/de/greenrobot/event/EventBusBuilder.java
index 06350609..17d7ed6f 100644
--- a/EventBus/src/de/greenrobot/event/EventBusBuilder.java
+++ b/EventBus/src/de/greenrobot/event/EventBusBuilder.java
@@ -23,6 +23,10 @@
 /**
  * Creates EventBus instances with custom parameters and also allows to install a custom default EventBus instance.
  * Create a new builder using {@link EventBus#builder()}.
+ *
+ * <br></>
+ * 跟一般 Builder 类似，用于在需要设置参数过多时构造 EventBus。包含的属性也是 EventBus 的一些设置参数，意义见4.2.1 EventBus.java的介绍，
+ * build 函数用于新建 EventBus 对象，installDefaultEventBus 函数将当前设置应用于 Default EventBus。
  */
 public class EventBusBuilder {
     private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
@@ -32,7 +36,7 @@
     boolean sendSubscriberExceptionEvent = true;
     boolean sendNoSubscriberEvent = true;
     boolean throwSubscriberException;
-    boolean eventInheritance = true;
+    boolean eventInheritance = true;//是否支持事件继承，默认为 true。
     ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
     List<Class<?>> skipMethodVerificationForClasses;
 
diff --git a/EventBus/src/de/greenrobot/event/EventBusException.java b/EventBus/src/de/greenrobot/event/EventBusException.java
index 80c51f86..73ca6ac8 100644
--- a/EventBus/src/de/greenrobot/event/EventBusException.java
+++ b/EventBus/src/de/greenrobot/event/EventBusException.java
@@ -17,7 +17,9 @@
 
 /**
  * An {@link RuntimeException} thrown in cases something went wrong inside EventBus.
- * 
+ *
+ * <br/>
+ * 封装于 RuntimeException 之上的 Exception，只是覆盖构造函数，相当于一个标记，标记是属于 EventBus 的 Exception。
  * @author Markus
  * 
  */
diff --git a/EventBus/src/de/greenrobot/event/HandlerPoster.java b/EventBus/src/de/greenrobot/event/HandlerPoster.java
index c1c44608..38e70821 100644
--- a/EventBus/src/de/greenrobot/event/HandlerPoster.java
+++ b/EventBus/src/de/greenrobot/event/HandlerPoster.java
@@ -20,6 +20,8 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+//事件主线程处理，对应ThreadMode.MainThread。继承自 Handler，enqueue 函数将事件放到队列中，
+// 并利用 handler 发送 message，handleMessage 函数从队列中取事件，invoke 事件响应函数处理。
 final class HandlerPoster extends Handler {
 
     private final PendingPostQueue queue;
diff --git a/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java b/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
index a7378ae8..a8ca2ba8 100644
--- a/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
+++ b/EventBus/src/de/greenrobot/event/NoSubscriberEvent.java
@@ -17,7 +17,9 @@
 
 /**
  * This Event is posted by EventBus when no subscriber is found for a posted event.
- * 
+ *
+ * <br/>
+ * 当没有事件处理函数对事件处理时发送的 EventBus 内部自定义事件，通过 post 发送，订阅者可自行订阅这类事件进行处理。
  * @author Markus
  */
 public final class NoSubscriberEvent {
diff --git a/EventBus/src/de/greenrobot/event/PendingPost.java b/EventBus/src/de/greenrobot/event/PendingPost.java
index 0bd5a2ec..60127575 100644
--- a/EventBus/src/de/greenrobot/event/PendingPost.java
+++ b/EventBus/src/de/greenrobot/event/PendingPost.java
@@ -18,6 +18,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * 订阅者和事件信息实体类，并含有同一队列中指向下一个对象的指针。通过缓存存储不用的对象，减少下次创建的性能消耗。
+ */
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
 
diff --git a/EventBus/src/de/greenrobot/event/PendingPostQueue.java b/EventBus/src/de/greenrobot/event/PendingPostQueue.java
index 5440559b..ec0b0cea 100644
--- a/EventBus/src/de/greenrobot/event/PendingPostQueue.java
+++ b/EventBus/src/de/greenrobot/event/PendingPostQueue.java
@@ -1,5 +1,9 @@
 package de.greenrobot.event;
 
+/**
+ * 通过 head 和 tail 指针维护一个PendingPost队列。HandlerPoster、AsyncPoster、BackgroundPoster
+ * 都包含一个此队列实例，表示各自的订阅者及事件信息队列，在事件到来时进入队列，处理时从队列中取出一个元素进行处理。
+ */
 final class PendingPostQueue {
     private PendingPost head;
     private PendingPost tail;
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethod.java b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
index 5e0df398..2b52c22b 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethod.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
@@ -17,6 +17,10 @@
 
 import java.lang.reflect.Method;
 
+/**
+ *订阅者事件响应函数信息，包括响应方法、线程 Mode、事件类型以及一个用来比较 SubscriberMethod是否相等的特征值
+ * methodString 共四个变量，其中methodString 由${methodClassName}#${methodName}(${eventTypeClassName}组合而成。
+ */
 final class SubscriberMethod {
     final Method method;
     final ThreadMode threadMode;
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 823cb0ec..e98808dd 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -38,8 +38,15 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+
+    /**
+     * 每个类对应的响应函数列表，因为类一般不会变，所以保留缓存
+     */
     private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
 
+    /**
+     * 属性表示跳过哪些类中非法以 onEvent 开头的函数检查，若不跳过则会抛出异常。
+     */
     private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
 
     SubscriberMethodFinder(List<Class<?>> skipMethodVerificationForClassesList) {
@@ -51,13 +58,20 @@
         }
     }
 
+    /**
+     * 先根据订阅者类名查找当前订阅者所有事件响应函数
+     * @param subscriberClass 订阅者类
+     * @return 订阅者类里面包含的响应方法
+     */
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         String key = subscriberClass.getName();
-        List<SubscriberMethod> subscriberMethods;
+        List<SubscriberMethod> subscriberMethods;//要返回的订阅者的所有响应参数
         synchronized (methodCache) {
+            //从缓存列表里面尝试获得缓存
             subscriberMethods = methodCache.get(key);
         }
         if (subscriberMethods != null) {
+            //判断是否有缓存，有缓存则直接返回
             return subscriberMethods;
         }
         subscriberMethods = new ArrayList<SubscriberMethod>();
@@ -67,19 +81,23 @@
         while (clazz != null) {
             String name = clazz.getName();
             if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
-                // Skip system classes, this just degrades performance
+                // Skip system classes, this just degrades performance,过滤掉系统类
                 break;
             }
 
             // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+            //通过反射，获得订阅者类的所有方法。
             Method[] methods = clazz.getDeclaredMethods();
             for (Method method : methods) {
                 String methodName = method.getName();
                 if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
                     int modifiers = method.getModifiers();
                     if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                        Class<?>[] parameterTypes = method.getParameterTypes();
-                        if (parameterTypes.length == 1) {
+                        //订阅者响应方法只能是public的，并且不能被abstract、static等修饰
+
+
+                        Class<?>[] parameterTypes = method.getParameterTypes();//获得参数类型列表
+                        if (parameterTypes.length == 1) {//订阅者响应方法里面只能有一个参数
                             String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
                             ThreadMode threadMode;
                             if (modifierString.length() == 0) {
@@ -97,13 +115,15 @@
                                     throw new EventBusException("Illegal onEvent method, check for typos: " + method);
                                 }
                             }
-                            Class<?> eventType = parameterTypes[0];
+                            //获取参数类型，其实就是接收事件的类型
+                            Class<?> eventType = parameterTypes[0];//第一个参数
                             methodKeyBuilder.setLength(0);
                             methodKeyBuilder.append(methodName);
                             methodKeyBuilder.append('>').append(eventType.getName());
                             String methodKey = methodKeyBuilder.toString();
                             if (eventTypesFound.add(methodKey)) {
                                 // Only add if not already found in a sub class
+                                //先循环子类的响应方法，再循环父类的响应方法，如果子类中已经添加过了，那么父类的会被忽略掉。
                                 subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
                             }
                         }
@@ -113,13 +133,13 @@
                     }
                 }
             }
-            clazz = clazz.getSuperclass();
+            clazz = clazz.getSuperclass();//再遍历父类的所有方法
         }
-        if (subscriberMethods.isEmpty()) {
+        if (subscriberMethods.isEmpty()) {//没有相应的响应函数
             throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
                     + ON_EVENT_METHOD_NAME);
         } else {
-            synchronized (methodCache) {
+            synchronized (methodCache) {//该方法执行一次后，将结果放入缓存中，再次调用时候直接从缓存列表拿
                 methodCache.put(key, subscriberMethods);
             }
             return subscriberMethods;
diff --git a/EventBus/src/de/greenrobot/event/Subscription.java b/EventBus/src/de/greenrobot/event/Subscription.java
index 6c84c440..5fb5ca3d 100644
--- a/EventBus/src/de/greenrobot/event/Subscription.java
+++ b/EventBus/src/de/greenrobot/event/Subscription.java
@@ -15,9 +15,21 @@
  */
 package de.greenrobot.event;
 
+/**
+ * 订阅者相关信息,包括 subscriber 对象、事件响应方法 SubscriberMethod、优先级 priority。
+ */
 final class Subscription {
+    /**
+     * 订阅者
+     */
     final Object subscriber;
+    /**
+     * 订阅者方法相关信息
+     */
     final SubscriberMethod subscriberMethod;
+    /**
+     * 优先级
+     */
     final int priority;
     /**
      * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
diff --git a/EventBus/src/de/greenrobot/event/ThreadMode.java b/EventBus/src/de/greenrobot/event/ThreadMode.java
index 4022ace5..5f78750c 100644
--- a/EventBus/src/de/greenrobot/event/ThreadMode.java
+++ b/EventBus/src/de/greenrobot/event/ThreadMode.java
@@ -18,7 +18,9 @@
 /**
  * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
  * EventBus takes care of threading independently from the posting thread.
- * 
+ * <br/>
+ * 线程 Mode 枚举类，表示事件响应函数执行线程信息，包括ThreadMode.PostThread、ThreadMode.MainThread、ThreadMode.BackgroundThread、ThreadMode.Async四种。
+ *
  * @see EventBus#register(Object)
  * @author Markus
  */
@@ -28,6 +30,12 @@
      * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
      * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
      * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
+     *
+     * <p/>
+     * 默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。
+     * 当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。
+     * <br/>
+     * 适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；
      */
     PostThread,
 
@@ -35,6 +43,9 @@
      * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
      * the main thread, event handler methods will be called directly. Event handlers using this mode must return
      * quickly to avoid blocking the main thread.
+     * <p/>
+     * 在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。
+     * 显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；
      */
     MainThread,
 
@@ -43,6 +54,12 @@
      * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
      * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
      * return quickly to avoid blocking the background thread.
+     * <p/>
+     * 在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。
+     * 由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，
+     * 但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。
+     * <p/>
+     * 适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；
      */
     BackgroundThread,
 
@@ -52,6 +69,11 @@
      * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
      * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
      * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+     *<p/>
+     * 不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。
+     * <p/>
+     * 适用场景：长耗时操作，例如网络访问。
+     *
      */
     Async
 }
\ No newline at end of file
diff --git a/README.md b/README.md
index e7c6975b..a35a72d7 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,17 @@
+EventBus中文注释
+======
+嗨，本项目只是再代码中加入了中文注释，并且引用一篇还不错的源码分析文章。
+
+文章合源码一起看，一定会对你分析EventBus的实现原理有很大帮助。
+
+如有哪里不准确的，欢迎指出。
+
+[源码分析文章](http://www.codekk.com/open-source-project-analysis/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90).
+
+
+
+
+
 EventBus
 ========
 EventBus is publish/subscribe event bus optimized for Android.<br/>
