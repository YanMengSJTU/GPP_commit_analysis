diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..46a915a0 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,7 +46,9 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**核心字段, key:Event类类型, value:订阅信息数组*/
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    /**map, key:订阅者实例, value:订阅方法的class集合*/
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
@@ -136,25 +138,38 @@ public EventBus() {
      * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
+     *
+     * 注册目标对象(订阅者),以接收events.目标对象必须明确的调用unregister()以注销.
+     * 订阅者必须拥有@Subscribe注解标记的方法.
+     * @param subscriber 注册的类(通常为XXActivity)
      */
     public void register(Object subscriber) {
+        /**根据注册类的实例得到对应的Class类*/
         Class<?> subscriberClass = subscriber.getClass();
+        /**通过SubscriberMethodFinder#findSubscriberMethods()
+         * 查找注册类中的订阅方法*/
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            /**遍历注册方法,注册*/
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
         }
     }
 
+    /**订阅
+     * @param subscriber 注册类
+     * @param subscriberMethod 注册类中使用@Subscribe标记的方法*/
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        /**获取订阅方法中形参XXEvent的class类型*/
         Class<?> eventType = subscriberMethod.eventType;
+
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
-            subscriptionsByEventType.put(eventType, subscriptions);
+            subscriptionsByEventType.put(eventType, subscriptions);//
         } else {
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
@@ -162,6 +177,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        /**根据优先级将事件依次放入*/
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -237,25 +253,34 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /** Unregisters the given subscriber from all event classes.
+     *
+     *  注销订阅者
+     *  @param subscriber 订阅者实例(XXActivity)*/
     public synchronized void unregister(Object subscriber) {
-        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
+        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);//获取订阅者的所有@Subscribe方法
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
-                unsubscribeByEventType(subscriber, eventType);
+                unsubscribeByEventType(subscriber, eventType);//移除订阅者--订阅方法关联
             }
-            typesBySubscriber.remove(subscriber);
+            typesBySubscriber.remove(subscriber);//移除订阅者
         } else {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /** Posts the given event to the event bus.
+     *
+     * 将指定事件发送到EventBus*/
     public void post(Object event) {
+        /**获取当前发送事件的线程
+         * 根据当前线程得到事件队列
+         * 将事件入列*/
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
+        /**确保不会被调用多次*/
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
@@ -264,6 +289,8 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    /**post()的核心方法
+                     * 移除当前线程的队列头*/
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -375,6 +402,9 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**发送一个事件
+     * @param event 事件类(XXEvent)
+     * @param postingState 发送事件的线程的信息*/
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
@@ -399,9 +429,11 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**根据事件类型发送单一事件*/
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            /**通过事件类型获取订阅该事件的订阅表*/
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
@@ -410,6 +442,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    /**将订阅信息, 事件类型, 线程类型传入*/
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -426,6 +459,12 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**将事件发送到订阅者
+     *
+     * 核心方法是invokeSubscriber() || enqueue()
+     * invokeSubscriber()会直接调用注册方法.
+     * enqueue()会将事件入列.
+     * 通过反射执行订阅方法*/
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -504,6 +543,7 @@ void invokeSubscriber(PendingPost pendingPost) {
         }
     }
 
+    /**执行订阅方法*/
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..a0026dc6 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,11 +17,13 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/** Used internally by EventBus and generated subscriber indexes.
+ *
+ * EventBus内部使用,负责生成订阅索引*/
 public class SubscriberMethod {
     final Method method;
     final ThreadMode threadMode;
-    final Class<?> eventType;
+    final Class<?> eventType;//Event类的类型
     final int priority;
     final boolean sticky;
     /** Used for efficient comparison */
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..7e1d63ae 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -36,6 +36,10 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+
+    /**方法缓存.
+     * key:注册的类
+     * value:该类中,所有用@Subscribe标记的订阅方法*/
     private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
 
     private List<SubscriberInfoIndex> subscriberInfoIndexes;
@@ -52,13 +56,17 @@
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
 
+    /**根据注册的类,寻找其订阅方法
+     * @param subscriberClass XXActivity的class类型
+     * @return 注册类的订阅方法集合*/
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
-        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
+        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);//从缓存读取
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
         if (ignoreGeneratedIndex) {
+            /**使用反射获取注册类的订阅方法*/
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
             subscriberMethods = findUsingInfo(subscriberClass);
@@ -67,6 +75,7 @@
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            /**写入缓存*/
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -137,16 +146,21 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**根据注册的类的class类型对象,使用反射获取其用@Subscribe标记的订阅方法*/
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            /**通过反射获取@Subscribe标记的订阅方法*/
             findUsingReflectionInSingleClass(findState);
+            /**查找父类中@Subscribe*/
             findState.moveToSuperclass();
         }
+        /**重置FindState*/
         return getMethodsAndRelease(findState);
     }
 
+    /**查找FindState中的@Subscribe方法*/
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..5fe7607e 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -16,6 +16,9 @@
 package org.greenrobot.eventbus;
 
 final class Subscription {
+
+    /**Object subscriber: 注册的类(Activity etc.)
+     * SubscriberMethod: 订阅方法*/
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
     /**
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index 3c69b7d7..a02c6332 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -34,6 +34,7 @@
      * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
      *
      * 订阅方法会在事件发布的线程直接调用.(默认选项)
+     * POSTING标记的订阅方法不能执行耗时操作, 因为可能在主线程(否则会阻塞主线程).
      */
     POSTING,
 
@@ -44,6 +45,7 @@
      * If not on Android, behaves the same as {@link #POSTING}.
      *
      * 订阅方法会在Android的主线程(UI线程)调用.
+     * MAIN编辑的订阅方法同样不能执行耗时操作.理由同上.
      */
     MAIN,
 
@@ -53,6 +55,7 @@
      *
      * 和Main类似,在订阅方法在主线程调用
      * 与Main不同:MAIN_ORDERED保证不会阻塞
+     * 因为MAIN_ORDERED标记的方法会被扔到MessageQueue中.
      */
     MAIN_ORDERED,
 
@@ -77,6 +80,7 @@
      *
      * 订阅方法会在一个独立的线程调用.
      * 该线程既不是发送事件的线程,又不是主线程.
+     * 常用于耗时操作
      */
     ASYNC
 }
\ No newline at end of file
