diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 25940507..231b0815 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,8 +46,15 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    //以订阅事件类型分类的订阅信息的Map集合
+    //保存的是某个事件被哪些订阅者的订阅方法订阅
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+    //以订阅者分类的订阅事件类型的Map集合
+    //保存的是某个订阅者订阅了哪些事件
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+
+    //粘性事件集合
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -140,8 +147,10 @@ public EventBus() {
     public void register(Object subscriber) {
         //获取订阅者的Class对象
         Class<?> subscriberClass = subscriber.getClass();
+        //查找订阅者的所有订阅方法，并封装成SubscriberMethod集合
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            //对每个订阅方法进行注册保存处理
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
@@ -150,6 +159,7 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        //构造订阅信息Subscription，并根据订阅事件的Class进行分类保存
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
@@ -163,6 +173,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        //按优先级插入订阅信息
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -171,6 +182,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        //保存订阅者，都订阅了哪些类型的事件
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -178,8 +190,11 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        //如果是粘性订阅方法
         if (subscriberMethod.sticky) {
+            //根据是否开启事件继承，进行粘性事件的匹配和通知
             if (eventInheritance) {
+                //如果开启事件继承，就要查找所有该类型及其子类型的粘性事件，进行通知
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
@@ -193,12 +208,18 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                     }
                 }
             } else {
+                //如果没有开启事件继承，直接查找对应类型的粘性事件，进行通知
                 Object stickyEvent = stickyEvents.get(eventType);
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
     }
 
+    /**
+     * 进行粘性事件通知的方法
+     * @param newSubscription
+     * @param stickyEvent
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
