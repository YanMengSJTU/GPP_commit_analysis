diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..95958566 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -78,6 +78,7 @@ protected PostingThreadState initialValue() {
 
     /** Convenience singleton for apps using a process-wide EventBus instance. */
     public static EventBus getDefault() {
+        //常规的双重锁单例模式
         EventBus instance = defaultInstance;
         if (instance == null) {
             synchronized (EventBus.class) {
@@ -90,6 +91,7 @@ public static EventBus getDefault() {
         return instance;
     }
 
+    //可以通过构造者构建，不同的EventBus之间不相互干扰
     public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
@@ -138,6 +140,7 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        //获得订阅者对应的Class,MainActivity.class
         Class<?> subscriberClass = subscriber.getClass();
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
@@ -150,12 +153,16 @@ public void register(Object subscriber) {
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
+        //new了一个Subscription对象
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        //判断是否有以Event.class为key
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
+            //new 一个
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            //注册过，就不要重复注册
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
@@ -165,6 +172,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
+                //按优先级加入
                 subscriptions.add(i, newSubscription);
                 break;
             }
@@ -179,6 +187,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
+                //是否设置了事件继承，默认是true
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
@@ -187,12 +196,15 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
                     if (eventType.isAssignableFrom(candidateEventType)) {
+                        //事件class和事件对象相同，或是子类
                         Object stickyEvent = entry.getValue();
+                        //通过反射发送粘性事件
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
                 }
             } else {
                 Object stickyEvent = stickyEvents.get(eventType);
+                //通过反射发送粘性事件
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
@@ -239,6 +251,7 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
 
     /** Unregisters the given subscriber from all event classes. */
     public synchronized void unregister(Object subscriber) {
+        //找到订阅者订阅的所有事件类型，也就是MainActivity中所有的Event
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
@@ -254,6 +267,7 @@ public synchronized void unregister(Object subscriber) {
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
+        // 将事件添加进当前线程的事件队列
         eventQueue.add(event);
 
         if (!postingState.isPosting) {
@@ -264,6 +278,7 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    //发送消息
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -379,6 +394,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            //找到类和它的父类
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -386,6 +402,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            //直接发送当前类
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
@@ -402,6 +419,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            //获得所有注册该事件的订阅者
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
@@ -410,6 +428,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    //反射发送事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -469,8 +488,11 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 eventTypes = new ArrayList<>();
                 Class<?> clazz = eventClass;
                 while (clazz != null) {
+                    //加入当前类
                     eventTypes.add(clazz);
+                    //加入当前类的所有接口
                     addInterfaces(eventTypes, clazz.getInterfaces());
+                    //加入当前的父类
                     clazz = clazz.getSuperclass();
                 }
                 eventTypesCache.put(eventClass, eventTypes);
@@ -506,6 +528,7 @@ void invokeSubscriber(PendingPost pendingPost) {
 
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            //通过反射执行粘性事件
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..f5cd2145 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -44,6 +44,7 @@ public boolean equals(Object other) {
             SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
+            //MainActivity#onEventMain(AEvent
             return methodString.equals(otherSubscriberMethod.methodString);
         } else {
             return false;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..5f2503fc 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,24 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //Cache中存在则直接从Cache中获取
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
         if (ignoreGeneratedIndex) {
+            //运行是通过反射拿到
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //编译期获得
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //放入缓存
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -93,6 +97,7 @@
     }
 
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+        //为了复用FindState,将FindState中保存的方法集复制一份，然后将FindState重置缓存
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
         synchronized (FIND_STATE_POOL) {
@@ -107,6 +112,7 @@
     }
 
     private FindState prepareFindState() {
+        //有点简单粗暴都意思。。。
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
                 FindState state = FIND_STATE_POOL[i];
@@ -138,12 +144,16 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
     }
 
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        //缓存中获取，默认大小为4都数组，没有就new
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            //findState保存注册的订阅者中的方法相关信息
             findUsingReflectionInSingleClass(findState);
+            //向上继续遍历
             findState.moveToSuperclass();
         }
+        //返回方法集
         return getMethodsAndRelease(findState);
     }
 
@@ -151,6 +161,8 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            //通过注释其实也可以看到EventBus团队对于反射性能都考虑，所以用getDeclaredMethods而不是getMethods
+            //获取都不包括父类和接口都方法，包括私有都，
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
@@ -159,14 +171,22 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            //方法必须是Public，不能是static,abstract，生成索引时会出问题
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                //获取方法都参数
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                //参数个数=1
                 if (parameterTypes.length == 1) {
+                    //方法是用@Subscribe注解
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        //获取第一个参数都Class,也就是事件类都class
                         Class<?> eventType = parameterTypes[0];
+                        // 检查eventType决定是否订阅，通常订阅者不能有多个eventType相同的订阅方法
                         if (findState.checkAdd(method, eventType)) {
+                            //获得Thread类型
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            //ArrayList加入一个SubscriberMethod对象
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
@@ -219,15 +239,18 @@ void recycle() {
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            //HashMap,一般一个Event只有一个方法
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
                 return true;
             } else {
                 if (existing instanceof Method) {
+                    //存在多个方法都能接受Event,比如一个接受子类，一个接受父类，会返回True
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
                     }
+                    //所以也能接收
                     // Put any non-Method object to "consume" the existing Method
                     anyMethodByEventType.put(eventType, this);
                 }
@@ -244,6 +267,7 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             Class<?> methodClass = method.getDeclaringClass();
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
+                //返回true
                 // Only add if not already found in a sub class
                 return true;
             } else {
@@ -254,6 +278,7 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
         }
 
         void moveToSuperclass() {
+            //如果配置忽略父类方法则不检查父类方法
             if (skipSuperClasses) {
                 clazz = null;
             } else {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..5d6cf923 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -34,6 +34,7 @@
     public boolean equals(Object other) {
         if (other instanceof Subscription) {
             Subscription otherSubscription = (Subscription) other;
+            //订阅者类相同
             return subscriber == otherSubscription.subscriber
                     && subscriberMethod.equals(otherSubscription.subscriberMethod);
         } else {
