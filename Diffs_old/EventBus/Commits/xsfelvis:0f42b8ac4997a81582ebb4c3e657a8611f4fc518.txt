diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..97e2c97f 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -42,14 +42,20 @@
 
     /** Log tag, apps may override it. */
     public static String TAG = "EventBus";
-
+    //使用volatile的单例模式
     static volatile EventBus defaultInstance;
 
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
-
+    //以事件类为Key，订阅者的回调方法为value的映射关系表
+    //即EventBus在收到一个事件时，就可以根据这个事件的类型，在该map中找到该事件的订阅者及处理事件的回调方法
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    //每个订阅者所监听的事件类型表，在取消注册时可以通过该表中保存的信息，快速删除subscriptionsByEventType
+    //中订阅者的信息，避免遍历查找
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    //注册事件、发送事件、注销都是围绕以上两个核心数据结构展开，其中Subscription可以理解为每个订阅者与
+    // 回调方法(SubscriptionMethod)关系，在其他模块发送事件时，就会通过这个关系，让订阅者执行回调方法
+
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -108,9 +114,11 @@ public EventBus() {
         subscriptionsByEventType = new HashMap<>();
         typesBySubscriber = new HashMap<>();
         stickyEvents = new ConcurrentHashMap<>();
+        //=====不同线程模式的处理=========
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
+        //=============================
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
@@ -131,11 +139,17 @@ public EventBus() {
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
      */
+    /**
+     * 注册对象是Object
+     */
     public void register(Object subscriber) {
+        //获取class
         Class<?> subscriberClass = subscriber.getClass();
+        //根据class查找相应的回调方法(3.0版本优化的重点！加入了索引加速)
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
+                //处理订阅对象的方法 注册的（对象+每个方法）
                 subscribe(subscriber, subscriberMethod);
             }
         }
@@ -144,10 +158,14 @@ public void register(Object subscriber) {
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
+        //把每个回调方法和订阅者封装成Subscription(订阅对象)
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+
+        //此处写法有点意思，明明想添加却先get然后通过空值判断再进行实际操作，更加安全
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
+            //加入到Map中统一管理
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
             if (subscriptions.contains(newSubscription)) {
@@ -157,13 +175,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
 
         int size = subscriptions.size();
+        //根据优先级(priority)/同级(i==size) (此处效率还是很低的)
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
-
+        //与上面一样对map的处理
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -236,18 +255,24 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        //获得到当前线程的信息
         PostingThreadState postingState = currentPostingThreadState.get();
+        //获取到当前事件的eventQueue
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
         if (!postingState.isPosting) {
+            //当前状态没有正在被post，则为安全
+            //检查当前状态是否是主线程
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
+            //重置posting状态为正在post状态
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    //当前事件队列不为空
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -359,10 +384,17 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     *
+     * @param event
+     * @param postingState
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            //获得事件所有父类并遍历
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -409,7 +441,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         }
         return false;
     }
-
+    //根据不同的poster，在对应的线程中通过反射
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -517,6 +549,7 @@ private void handleSubscriberException(Subscription subscription, Object event,
     }
 
     /** For ThreadLocal, much faster to set (and get multiple values). */
+    //post的线程的状态
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
index e212750e..6ca63261 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
@@ -129,6 +129,7 @@ public EventBusBuilder strictMethodVerification(boolean strictMethodVerification
     }
 
     /** Adds an index generated by EventBus' annotation preprocessor. */
+    //传入的索引信息会保存在 subscriberInfoIndexes这个list中
     public EventBusBuilder addIndex(SubscriberInfoIndex index) {
         if(subscriberInfoIndexes == null) {
             subscriberInfoIndexes = new ArrayList<>();
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..ab91be28 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -16,15 +16,23 @@
 package org.greenrobot.eventbus;
 
 import java.lang.reflect.Method;
+/**
+ * 保存需要反射invoke方法时各种参数，如优先级、是否接受黏性事件、所在线程等信息
+ * 而生成这些封装好的方法需要SubscriberMethodFinder
+ */
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/**
+ * Used internally by EventBus and generated subscriber indexes.
+ */
 public class SubscriberMethod {
     final Method method;
     final ThreadMode threadMode;
     final Class<?> eventType;
     final int priority;
     final boolean sticky;
-    /** Used for efficient comparison */
+    /**
+     * Used for efficient comparison
+     */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
@@ -41,7 +49,7 @@ public boolean equals(Object other) {
             return true;
         } else if (other instanceof SubscriberMethod) {
             checkMethodString();
-            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod) other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
             return methodString.equals(otherSubscriberMethod.methodString);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..950dbe87 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -32,6 +32,13 @@
      * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
      * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
      */
+    /**
+     * 主要用来为SubscriberMethod封装方法
+     * 这里使用到了索引加速器！！！
+     * 在register时得到订阅者的所有回调方法，并封装返回给EventBus。
+     * 而加速索引模块是为了提高SubscriberMethodFinder的效率
+     */
+
     private static final int BRIDGE = 0x40;
     private static final int SYNTHETIC = 0x1000;
 
@@ -55,43 +62,68 @@
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
-            return subscriberMethods;
+            return subscriberMethods;//方法缓存
         }
-
-        if (ignoreGeneratedIndex) {
+        //================查找核心================
+        if (ignoreGeneratedIndex) { //是否忽略设置的索引
+            //使用最原始的注解+反射
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //去索引中查找订阅者的方法
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+        //========================================
+
+        //查找方法 如果找到则存到方法缓存中，否则直接抛出异常
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //把找到的方法保存到METHOD_CACHE中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
     }
 
+    /**
+     * 在索引中查找订阅者的回调方法
+     * 索引实际是一个以
+     * 注册类为Key，SimpleSubscribeInfo(封装了注解标识的方法信息包括方法名、方法类型等信息)
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
-        findState.initForSubscriber(subscriberClass);
-        while (findState.clazz != null) {
-            findState.subscriberInfo = getSubscriberInfo(findState);
-            if (findState.subscriberInfo != null) {
+        //寻找方法时所需要的临时变量都被封装到了FindState这个静态内部类中
+        FindState findState = prepareFindState();//到对象池去取得上下文，避免频繁创造对象，这个设计很棒！
+        findState.initForSubscriber(subscriberClass);//初始化寻找方法的上下文
+
+        while (findState.clazz != null) { //子类找完了，会继续去父类中寻找
+            //===========================索引查找核心================================
+            findState.subscriberInfo = getSubscriberInfo(findState);//获得订阅者类的信息
+            //=======================================================================
+            if (findState.subscriberInfo != null) {//上一步能拿到相关信息的话，就开始把方法数组封装成List
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
+                        //checkAdd是为了避免在父类中找到的方法是被子类重写的，此时应保证回调时执行子类的方法
                         findState.subscriberMethods.add(subscriberMethod);
                     }
                 }
             } else {
+                //索引中找不到，降级成运行时通过注解和反射
                 findUsingReflectionInSingleClass(findState);
             }
-            findState.moveToSuperclass();
+            findState.moveToSuperclass();//上下文切换为父类,可见EventBus支持继承回调
         }
-        return getMethodsAndRelease(findState);
+
+        return getMethodsAndRelease(findState);//寻找完成之后，释放FindState进对象池并返回找到的回调方法
     }
 
+    /**
+     * 查找完成后释放FindState进对象池并返回找到的回调方法
+     * @param findState
+     * @return
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
@@ -119,16 +151,25 @@ private FindState prepareFindState() {
         return new FindState();
     }
 
+    /**
+     * 通过索引查找回调的核心函数
+     * @param findState
+     * @return
+     */
     private SubscriberInfo getSubscriberInfo(FindState findState) {
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
+            //findState.subscriberInfo已有实例，证明本次查找需要查找上次找到过的类的父类
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
+                //确定是所需查找的类
                 return superclassInfo;
             }
         }
-        if (subscriberInfoIndexes != null) {
+        if (subscriberInfoIndexes != null) {//从我们传入的subscriberInfoIndexes中获取相应的订阅者信息
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
+                //==========getSubscriberInfo是我们使用APT生成的代码里面的索引加速======
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
+                //==================================================================
                 if (info != null) {
                     return info;
                 }
@@ -147,6 +188,9 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 降级成注解和反射模式去处理
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
@@ -164,7 +208,7 @@ private void findUsingReflectionInSingleClass(FindState findState) {
                 if (parameterTypes.length == 1) {
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
-                        Class<?> eventType = parameterTypes[0];
+                        Class<?> eventType = parameterTypes[0];//从这里可以看出eventType只有一个参数
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
@@ -188,6 +232,9 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 寻找方法时所需要的临时变量都被封装到了FindState这个静态内部类中
+     */
     static class FindState {
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..51600dfd 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,6 +15,10 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 负责将订阅者和回调方法封装成Subscription(订阅对象)
+ */
+
 final class Subscription {
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
@@ -22,7 +26,7 @@
      * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
      * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions.
      */
-    volatile boolean active;
+    volatile boolean active; //原子性操作
 
     Subscription(Object subscriber, SubscriberMethod subscriberMethod) {
         this.subscriber = subscriber;
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
index 9fc65f6f..d2747343 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberInfoIndex.java
@@ -19,5 +19,6 @@
  * Interface for generated indexes.
  */
 public interface SubscriberInfoIndex {
+    //可见索引只需要执行一件事件就是拿到订阅者的信息
     SubscriberInfo getSubscriberInfo(Class<?> subscriberClass);
 }
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index c37c18a5..abb67bad 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -70,7 +70,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         Messager messager = processingEnv.getMessager();
         try {
             String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
-            if (index == null) {
+            if (index == null) { //如果没有在gradle中配置apt的argument，编译就会报错
                 messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
                         " passed to annotation processor");
                 return false;
@@ -99,11 +99,11 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 messager.printMessage(Diagnostic.Kind.ERROR,
                         "Unexpected processing state: annotations still available after writing.");
             }
-            collectSubscribers(annotations, env, messager);
-            checkForSubscribersToSkip(messager, indexPackage);
+            collectSubscribers(annotations, env, messager);//根据注解拿到所有订阅者的回调方法信息
+            checkForSubscribersToSkip(messager, indexPackage);//筛选掉不符合规则的订阅者
 
             if (!methodsByClass.isEmpty()) {
-                createInfoIndexFile(index);
+                createInfoIndexFile(index);//生成索引类
             } else {
                 messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
             }
@@ -116,6 +116,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         return true;
     }
 
+    // 遍历annotations，找出所有被注解标识的方法，以初始化methodsByClass
     private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
         for (TypeElement annotation : annotations) {
             Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
@@ -132,7 +133,7 @@ private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnv
             }
         }
     }
-
+    // 过滤掉static，非public和参数大于1的方法
     private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
         if (element.getModifiers().contains(Modifier.STATIC)) {
             messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must not be static", element);
@@ -155,6 +156,7 @@ private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
     /**
      * Subscriber classes should be skipped if their class or any involved event class are not visible to the index.
      */
+    // 检查methodsByClass中的各个类，是否存在非public的父类和方法参数
     private void checkForSubscribersToSkip(Messager messager, String myPackage) {
         for (TypeElement skipCandidate : methodsByClass.keySet()) {
             TypeElement subscriberClass = skipCandidate;
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
index 53180e6e..ff176b13 100644
--- a/EventBusPerformance/build.gradle
+++ b/EventBusPerformance/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.1'
+        classpath 'com.android.tools.build:gradle:2.2.2'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
     }
 }
diff --git a/EventBusTest/build.gradle b/EventBusTest/build.gradle
index a1d04468..0892c63e 100644
--- a/EventBusTest/build.gradle
+++ b/EventBusTest/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.1'
+        classpath 'com.android.tools.build:gradle:2.2.2'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
     }
 }
