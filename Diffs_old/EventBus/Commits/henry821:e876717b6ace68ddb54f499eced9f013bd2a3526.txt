diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..239e11bc 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,7 +46,9 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+	//key：事件类型class对象，value：处理该事件类型的方法列表
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+	//key：订阅者，value：该订阅者处理的所有事件类型列表
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
@@ -136,9 +138,15 @@ public EventBus() {
      * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
+     *
+     * 注册给定的订阅者来接收事件。一旦订阅者不再对接收事件感兴趣则必须调用unregister方法
+     * 订阅者持有的处理事件方法必须由Subscribe注解修饰
+     * Subscribe注解也允许其他配置，例如线程模式(ThreadMode)和优先级
      */
     public void register(Object subscriber) {
+    	//获得订阅者(例:MainActivity)的class对象(例:MainActivity.class)
         Class<?> subscriberClass = subscriber.getClass();
+		//从当前订阅者里找到所有处理事件的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -149,8 +157,13 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+    	//得到该方法处理的事件类型
         Class<?> eventType = subscriberMethod.eventType;
+		//实例化一个Subscription对象，Subscription持有订阅者和一个处理事件的方法
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+		//根据事件类型取出处理该事件的方法列表
+		//如果列表为null，则new出一个，把实例化出来的方法放入列表
+		//如果列表不为null且包含刚刚实例化出来的方法，说明处理事件的类相同、方法名相同且处理的事件相同(参数类型相同)，所以抛出异常(判断逻辑看Subscription类的equals方法)
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,8 +175,10 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+		//如果列表不为空，则遍历此列表
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
+			//按照优先级(priority)排序，优先级大的排在前面
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
@@ -222,11 +237,14 @@ public synchronized boolean isRegistered(Object subscriber) {
 
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+    	//根据事件类型得到处理该事件的方法列表
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
+			//遍历处理该事件的方法列表
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
+				//如果找到同一个订阅者，则将其从列表中移除
                 if (subscription.subscriber == subscriber) {
                     subscription.active = false;
                     subscriptions.remove(i);
@@ -239,8 +257,10 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
 
     /** Unregisters the given subscriber from all event classes. */
     public synchronized void unregister(Object subscriber) {
+    	//得到该订阅者处理的事件列表
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
+			//遍历事件列表
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
@@ -252,10 +272,13 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+    	//ThreadLocal类型，线程单例，不同线程互不干扰
         PostingThreadState postingState = currentPostingThreadState.get();
+		//将事件添加到当前线程的事件队列
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
+		//如果当前正在发送消息，则不向下执行，反之进入方法体执行逻辑
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
@@ -264,6 +287,7 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+					//从队列头部取出消息发送出去
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -376,9 +400,11 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
     }
 
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+    	//得到发送事件的类对象
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+			//返回一个包含当前类和当前类所有接口和其父类的列表
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -386,6 +412,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+        	//直接发送当前类
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
@@ -402,14 +429,17 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+			//获得处理该事件的所有方法列表
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
+			//遍历方法列表
             for (Subscription subscription : subscriptions) {
                 postingState.event = event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+					//反射发送事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -506,6 +536,7 @@ void invokeSubscriber(PendingPost pendingPost) {
 
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+			//通过反射调用订阅者的处理事件方法
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..ddeaece4 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -35,6 +35,11 @@ public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode
         this.sticky = sticky;
     }
 
+	/**
+	 * 1.如果两个方法是同一个对象(内存地址相同)，则返回true
+	 * 2.如果两个方法的所属类名称、方法名称、参数类型名称全部一致，则返回true
+	 * 3.以上两条不满足则返回false
+	 */
     @Override
     public boolean equals(Object other) {
         if (other == this) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..e101ee30 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,25 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+    	//如果Cache中存在则直接从Cache中获取
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
         if (ignoreGeneratedIndex) {
+			//运行时反射得到
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+        	//编译期获得
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+		//如果订阅者类中没有处理事件方法，则抛出异常
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+			//把订阅者类对象及其处理事件方法的列表放入缓存
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -138,12 +143,17 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
     }
 
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+    	//从FIND_STATE_POOL数组缓存中获取，取到则返回，取不到则创建一个新FindState对象
         FindState findState = prepareFindState();
+		//findState对其内部变量做初始化操作
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+			//findState保存注册的订阅者中的方法相关信息
             findUsingReflectionInSingleClass(findState);
+			//如果此类有父类(除java或javax或android开头的系统类)，则继续向上遍历其父类
             findState.moveToSuperclass();
         }
+		//从findState中拿到处理事件的方法集合并返回，同时把findState清空并放入缓存数组中
         return getMethodsAndRelease(findState);
     }
 
@@ -159,14 +169,26 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+			//方法必须是public，不能是static、abstract，否则生成索引时会出问题
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+				//获取方法参数类型集合
                 Class<?>[] parameterTypes = method.getParameterTypes();
+				//参数个数为1
                 if (parameterTypes.length == 1) {
+					//获取Subscribe注解
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
+					//能够获取到
                     if (subscribeAnnotation != null) {
+						//获取第一个参数类型，即事件的类对象
                         Class<?> eventType = parameterTypes[0];
+						//此处判断为了解决以下两种写法问题：
+						//1.一个类中存在两个方法名不同，但是处理同一个事件的订阅方法
+						//2.子类和父类存在相同方法名和Event类型的订阅方法
+						//如果能够判断通过，则往下执行
                         if (findState.checkAdd(method, eventType)) {
+							//获得线程模式
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+							//把当前方法包装成SubscriberMethod对象并加入findState的列表中
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
@@ -190,7 +212,9 @@ static void clearCaches() {
 
     static class FindState {
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+		//key：事件类型，value：处理事件方法
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+		//key：方法生成的唯一标识 value：订阅者类型(例:MainActivity.class)
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
@@ -219,11 +243,15 @@ void recycle() {
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            // 两层检查：第一层检查只检查事件类型(快速)，第二层检查在需要的时候绘检查完整的签名
+            // 一般情况下一个订阅者不会有不同方法监听处理同一个事件类型
             Object existing = anyMethodByEventType.put(eventType, method);
+			// 如果事件类型和处理事件方法放入map中返回值为null，说明处理此事件的方法是一个新方法，可以直接返回true
             if (existing == null) {
                 return true;
             } else {
                 if (existing instanceof Method) {
+					//如果存在处理同一事件的不同方法，可能方法名不同(同一个类中)，也可能方法名相同(子类重写父类方法)，所以进行进一步检查，检查不通过则抛出异常
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
@@ -240,20 +268,28 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             methodKeyBuilder.append(method.getName());
             methodKeyBuilder.append('>').append(eventType.getName());
 
+			//生成方法的唯一标识："method>eventType"
             String methodKey = methodKeyBuilder.toString();
+			//获得该方法所属的类
             Class<?> methodClass = method.getDeclaringClass();
+			//将前两步的变量放入map
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
+			//如果methodClassOld为null，说明是同一个类中有两个不同名的方法处理同一事件，是被允许的情况，返回true
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                 // Only add if not already found in a sub class
                 return true;
             } else {
                 // Revert the put, old class is further down the class hierarchy
+                // 走到此处条件说明是当前方法已经被放入过map，则是子类重写父类方法的情况
+                // 由于检查是由子类向父类遍历检查，所以先放入的methodClassOld是子类，后放入的methodClass是父类
+                // 最后保留的是子类处理事件的方法
                 subscriberClassByMethodKey.put(methodKey, methodClassOld);
                 return false;
             }
         }
 
         void moveToSuperclass() {
+        	//如果配置了忽略父类方法则不检查父类方法
             if (skipSuperClasses) {
                 clazz = null;
             } else {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..cd08ad42 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -34,6 +34,8 @@
     public boolean equals(Object other) {
         if (other instanceof Subscription) {
             Subscription otherSubscription = (Subscription) other;
+			//1.订阅者的内存地址是否一样(一个栈内存在两个MainActivity，内存地址不一样)
+			//2.判断SubscriberMethod的equals是否一样
             return subscriber == otherSubscription.subscriber
                     && subscriberMethod.equals(otherSubscription.subscriberMethod);
         } else {
