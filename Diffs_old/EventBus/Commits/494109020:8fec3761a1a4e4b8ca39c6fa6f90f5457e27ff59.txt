diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..5e9868ba 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -40,16 +40,21 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
 
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+    // key-事件类型 value-该类型的所有父类以及接口类型
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
-
+    // key-订阅事件的类型 value-订阅者和订阅方法封装成的对象
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    // key-订阅者 value-订阅事件的类型列表
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    // key-订阅事件的类型 value-事件
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -74,7 +79,9 @@ protected PostingThreadState initialValue() {
 
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
@@ -90,7 +97,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -144,6 +153,7 @@ public void register(Object subscriber) {
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
+        // 保存事件类型对应的所有方法信息的列表
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
@@ -155,7 +165,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                         + eventType);
             }
         }
-
+        // 按优先级插入
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -163,7 +173,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 break;
             }
         }
-
+        // 保存订阅事件至订阅者订阅的订阅事件列表
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -172,7 +182,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         subscribedEvents.add(eventType);
 
         if (subscriberMethod.sticky) {
-            if (eventInheritance) {
+            if (eventInheritance) {// 可继承事件
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
@@ -180,7 +190,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
-                    if (eventType.isAssignableFrom(candidateEventType)) {
+                    if (eventType.isAssignableFrom(candidateEventType)) {// 是该粘性事件类型的超类或者接口
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
@@ -194,6 +204,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
+            // 这里无法按照优先级打断。因为这不是post事件
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
             // --> Strange corner case, which we don't take care of here.
             postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
@@ -204,7 +215,10 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     * 取消某个订阅者的某个订阅事件
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -221,7 +235,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -234,20 +250,25 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     * 发布
+     */
     public void post(Object event) {
+        // 得到当前线程的发布状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        // 当前线程的事件队列
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
-        if (!postingState.isPosting) {
+        if (!postingState.isPosting) {// 如果不在发布中的状态
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
-                while (!eventQueue.isEmpty()) {
+                while (!eventQueue.isEmpty()) {// 不为空，持续发布
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -258,6 +279,7 @@ public void post(Object event) {
     }
 
     /**
+     * 取消事件分发
      * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
      * subscribers
      * won't receive the event. Events are usually canceled by higher priority subscribers (see
@@ -281,6 +303,8 @@ public void cancelEventDelivery(Object event) {
     }
 
     /**
+     * 发布粘性事件。
+     * 注意：新发的粘性事件会替代旧的同一类型的粘性事件
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
      */
@@ -293,6 +317,7 @@ public void postSticky(Object event) {
     }
 
     /**
+     * 得到当前的粘性事件。
      * Gets the most recent sticky event for the given type.
      *
      * @see #postSticky(Object)
@@ -304,6 +329,7 @@ public void postSticky(Object event) {
     }
 
     /**
+     * 根据事件类型来移除粘性事件。
      * Remove and gets the recent sticky event for the given event type.
      *
      * @see #postSticky(Object)
@@ -315,6 +341,7 @@ public void postSticky(Object event) {
     }
 
     /**
+     * 移除具体的粘性事件
      * Removes the sticky event if it equals to the given event.
      *
      * @return true if the events matched and the sticky event was removed.
@@ -333,6 +360,7 @@ public boolean removeStickyEvent(Object event) {
     }
 
     /**
+     * 清空粘性事件
      * Removes all sticky events.
      */
     public void removeAllStickyEvents() {
@@ -341,6 +369,9 @@ public void removeAllStickyEvents() {
         }
     }
 
+    /**
+     * 是否有订阅了该事件类型的订阅者
+     */
     public boolean hasSubscriberForEvent(Class<?> eventClass) {
         List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
         if (eventTypes != null) {
@@ -359,10 +390,19 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 发布事件
+     *
+     * @param event        事件
+     * @param postingState 发布状态
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
+        // 是否有相关的订阅信息
         boolean subscriptionFound = false;
-        if (eventInheritance) {
+        if (eventInheritance) {// 可继承事件
+            // 通过该事件得到所有的可能的事件(原事件的超类，实现的接口)
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -372,7 +412,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         } else {
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
-        if (!subscriptionFound) {
+        if (!subscriptionFound) {// 没找到
             if (logNoSubscriberMessages) {
                 Log.d(TAG, "No subscribers registered for event " + eventClass);
             }
@@ -383,6 +423,14 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     * 发布事件
+     *
+     * @param event        事件
+     * @param postingState 发布状态
+     * @param eventClass   事件类型
+     * @return 是否发布成功
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
@@ -410,26 +458,33 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 发布
+     *
+     * @param subscription 订阅信息
+     * @param event        订阅事件
+     * @param isMainThread 是否在主线程
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
-            case POSTING:
+            case POSTING:// 在当前线程执行
                 invokeSubscriber(subscription, event);
                 break;
-            case MAIN:
+            case MAIN:// 在主线程执行
                 if (isMainThread) {
                     invokeSubscriber(subscription, event);
                 } else {
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
-            case BACKGROUND:
+            case BACKGROUND:// 在非主线程执行
                 if (isMainThread) {
                     backgroundPoster.enqueue(subscription, event);
                 } else {
                     invokeSubscriber(subscription, event);
                 }
                 break;
-            case ASYNC:
+            case ASYNC:// 异步执行
                 asyncPoster.enqueue(subscription, event);
                 break;
             default:
@@ -437,7 +492,10 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * 该事件的所有实现接口，超类
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -446,26 +504,30 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 Class<?> clazz = eventClass;
                 while (clazz != null) {
                     eventTypes.add(clazz);
-                    addInterfaces(eventTypes, clazz.getInterfaces());
-                    clazz = clazz.getSuperclass();
+                    addInterfaces(eventTypes, clazz.getInterfaces());//添加接口
+                    clazz = clazz.getSuperclass();// 超类
                 }
-                eventTypesCache.put(eventClass, eventTypes);
+                eventTypesCache.put(eventClass, eventTypes);// 缓存
             }
             return eventTypes;
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * 添加所有的接口
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
                 eventTypes.add(interfaceClass);
-                addInterfaces(eventTypes, interfaceClass.getInterfaces());
+                addInterfaces(eventTypes, interfaceClass.getInterfaces());// 递归添加
             }
         }
     }
 
     /**
+     * 调用订阅者的方法
      * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
      * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
      * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
@@ -475,11 +537,17 @@ void invokeSubscriber(PendingPost pendingPost) {
         Object event = pendingPost.event;
         Subscription subscription = pendingPost.subscription;
         PendingPost.releasePendingPost(pendingPost);
-        if (subscription.active) {
+        if (subscription.active) {// 还在订阅该事件
             invokeSubscriber(subscription, event);
         }
     }
 
+    /**
+     * 通过反射调用订阅者的订阅方法
+     *
+     * @param subscription 订阅信息
+     * @param event        订阅事件
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
@@ -490,6 +558,9 @@ void invokeSubscriber(Subscription subscription, Object event) {
         }
     }
 
+    /**
+     * 处理异常
+     */
     private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
         if (event instanceof SubscriberExceptionEvent) {
             if (logSubscriberExceptions) {
@@ -516,7 +587,10 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     * 当前线程的发布状态
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<Object>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
index e212750e..b61786fb 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
@@ -44,25 +44,33 @@
     EventBusBuilder() {
     }
 
-    /** Default: true */
+    /**
+     * Default: true
+     */
     public EventBusBuilder logSubscriberExceptions(boolean logSubscriberExceptions) {
         this.logSubscriberExceptions = logSubscriberExceptions;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * Default: true
+     */
     public EventBusBuilder logNoSubscriberMessages(boolean logNoSubscriberMessages) {
         this.logNoSubscriberMessages = logNoSubscriberMessages;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * Default: true
+     */
     public EventBusBuilder sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent) {
         this.sendSubscriberExceptionEvent = sendSubscriberExceptionEvent;
         return this;
     }
 
-    /** Default: true */
+    /**
+     * Default: true
+     */
     public EventBusBuilder sendNoSubscriberEvent(boolean sendNoSubscriberEvent) {
         this.sendNoSubscriberEvent = sendNoSubscriberEvent;
         return this;
@@ -116,21 +124,27 @@ public EventBusBuilder skipMethodVerificationFor(Class<?> clazz) {
         return this;
     }
 
-    /** Forces the use of reflection even if there's a generated index (default: false). */
+    /**
+     * Forces the use of reflection even if there's a generated index (default: false).
+     */
     public EventBusBuilder ignoreGeneratedIndex(boolean ignoreGeneratedIndex) {
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
         return this;
     }
 
-    /** Enables strict method verification (default: false). */
+    /**
+     * Enables strict method verification (default: false).
+     */
     public EventBusBuilder strictMethodVerification(boolean strictMethodVerification) {
         this.strictMethodVerification = strictMethodVerification;
         return this;
     }
 
-    /** Adds an index generated by EventBus' annotation preprocessor. */
+    /**
+     * Adds an index generated by EventBus' annotation preprocessor.
+     */
     public EventBusBuilder addIndex(SubscriberInfoIndex index) {
-        if(subscriberInfoIndexes == null) {
+        if (subscriberInfoIndexes == null) {
             subscriberInfoIndexes = new ArrayList<>();
         }
         subscriberInfoIndexes.add(index);
@@ -154,7 +168,9 @@ public EventBus installDefaultEventBus() {
         }
     }
 
-    /** Builds an EventBus based on the current configuration. */
+    /**
+     * Builds an EventBus based on the current configuration.
+     */
     public EventBus build() {
         return new EventBus(this);
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..47ddb3e6 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,14 +17,18 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/**
+ * Used internally by EventBus and generated subscriber indexes.
+ */
 public class SubscriberMethod {
-    final Method method;
-    final ThreadMode threadMode;
-    final Class<?> eventType;
-    final int priority;
-    final boolean sticky;
-    /** Used for efficient comparison */
+    final Method method;// 方法
+    final ThreadMode threadMode;// 执行线程
+    final Class<?> eventType;// 事件类型
+    final int priority;// 优先级
+    final boolean sticky;// 是否粘性
+    /**
+     * Used for efficient comparison
+     */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
@@ -41,7 +45,7 @@ public boolean equals(Object other) {
             return true;
         } else if (other instanceof SubscriberMethod) {
             checkMethodString();
-            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod) other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
             return methodString.equals(otherSubscriberMethod.methodString);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..fe66a30f 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -52,22 +52,30 @@
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
 
+    /**
+     * 找到订阅方法
+     *
+     * @param subscriberClass
+     * @return
+     */
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //是否忽略注解器生成的MyEventBusIndex，默认是false
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //通过注解器生成的MyEventBusIndex信息获取subscriberMethods,
+            //如果没有配置MyEventBusIndex，依然通过通过反射获取subscriberMethods
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
-            METHOD_CACHE.put(subscriberClass, subscriberMethods);
+            METHOD_CACHE.put(subscriberClass, subscriberMethods);// 缓存
             return subscriberMethods;
         }
     }
@@ -85,6 +93,7 @@
                     }
                 }
             } else {
+                //一般走这里
                 findUsingReflectionInSingleClass(findState);
             }
             findState.moveToSuperclass();
@@ -92,7 +101,14 @@
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 得到方法集合，并释放资源
+     *
+     * @param findState
+     * @return
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+        // 重新构造一个方法集合，释放FindState回对象池
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
         synchronized (FIND_STATE_POOL) {
@@ -158,14 +174,14 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             findState.skipSuperClasses = true;
         }
         for (Method method : methods) {
-            int modifiers = method.getModifiers();
-            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+            int modifiers = method.getModifiers();// 获取修饰符
+            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {// 必须是public，且不能是MODIFIERS_IGNORE这几种
                 Class<?>[] parameterTypes = method.getParameterTypes();
-                if (parameterTypes.length == 1) {
+                if (parameterTypes.length == 1) {// 必须只有一个参数
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
-                    if (subscribeAnnotation != null) {
+                    if (subscribeAnnotation != null) {// 有@Subscribe注解的方法
                         Class<?> eventType = parameterTypes[0];
-                        if (findState.checkAdd(method, eventType)) {
+                        if (findState.checkAdd(method, eventType)) {// 检查，防止重复添加
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
@@ -190,7 +206,13 @@ static void clearCaches() {
 
     static class FindState {
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+        /**
+         * 某一事件类型所对应的方法
+         */
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+        /**
+         * 方法名称以及参数类型所生成的key和声明了该方法的class
+         */
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
@@ -216,6 +238,13 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        /**
+         * 检查
+         *
+         * @param method    方法
+         * @param eventType 该方法接收事件的参数类型
+         * @return 是否通过验证
+         */
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
@@ -241,13 +270,15 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             methodKeyBuilder.append('>').append(eventType.getName());
 
             String methodKey = methodKeyBuilder.toString();
-            Class<?> methodClass = method.getDeclaringClass();
+            Class<?> methodClass = method.getDeclaringClass();// 得到声明此方法的类
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                 // Only add if not already found in a sub class
+                // 只有  没在子类中找到的情况下才可以添加
                 return true;
             } else {
                 // Revert the put, old class is further down the class hierarchy
+                // 新值不是旧值的子类，则恢复之前的key-value。。。。why？
                 subscriberClassByMethodKey.put(methodKey, methodClassOld);
                 return false;
             }
@@ -259,7 +290,7 @@ void moveToSuperclass() {
             } else {
                 clazz = clazz.getSuperclass();
                 String clazzName = clazz.getName();
-                /** Skip system classes, this just degrades performance. */
+                /** Skip system classes, this just degrades performance.忽略系统的类 */
                 if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
                     clazz = null;
                 }
