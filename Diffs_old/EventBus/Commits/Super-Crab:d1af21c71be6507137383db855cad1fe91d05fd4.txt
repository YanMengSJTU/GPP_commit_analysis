diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..466c5aaa 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -110,14 +110,21 @@ public EventBus() {
 
     EventBus(EventBusBuilder builder) {
         logger = builder.getLogger();
+//        key：订阅的事件，value：订阅这个事件的所有订阅者集合
         subscriptionsByEventType = new HashMap<>();
+//        key：订阅者对象，value：这个订阅者订阅的事件集合
         typesBySubscriber = new HashMap<>();
+//        key：粘性事件的class对象 value：事件对象
         stickyEvents = new ConcurrentHashMap<>();
         mainThreadSupport = builder.getMainThreadSupport();
+        //        事件主线程处理
         mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
-        backgroundPoster = new BackgroundPoster(this);
+//        事件background处理
+        backgroundPoster =  new BackgroundPoster(this);
+//        事件异步线程处理
         asyncPoster = new AsyncPoster(this);
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
+//        订阅者响应函数信息存储和查找类
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
         logSubscriberExceptions = builder.logSubscriberExceptions;
@@ -125,6 +132,7 @@ public EventBus() {
         sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
         sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
         throwSubscriberException = builder.throwSubscriberException;
+//        是否支持事件继承
         eventInheritance = builder.eventInheritance;
         executorService = builder.executorService;
     }
@@ -138,7 +146,10 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+//        首先获得继承者的class对象
         Class<?> subscriberClass = subscriber.getClass();
+//        通过findSubscriberMethods 来找到订阅者订阅了哪些事件，返回SubscriberMethod的列表
+//        subscriberMethods 中包含这个方法的method对象，以及响应在哪个线程的ThreadMode，订阅的事件类型eventType，订阅的优先级priority，是否接受粘性sticky事件的Boolean值
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..d275fb32 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,25 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+//        从METHOD_CACHE 取看是否有缓存，key：订阅类的类名，value：类中订阅的方法数据
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+//      是否忽略注解器生成的Index 具体可参照EventBusIndexTest，默认为false
         if (ignoreGeneratedIndex) {
+//            利用反射来读取订阅类中的订阅方法信息
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+//            通过注解获取订阅类的订阅方法信息
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+//        遇到一次坑，因为代码加了混淆，没有设置默认的混淆，结果一直crash，找不到对应的方法
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+//            将获取的保存到缓存中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -138,17 +143,22 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
     }
 
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+//        FindState用来做订阅方法的校验和保存
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+//            通过反射来获取订阅方法信息
             findUsingReflectionInSingleClass(findState);
+//            查找父类的订阅方法
             findState.moveToSuperclass();
         }
+//        获取findState中的SubscriberMethod(也就是订阅方法List)并返回
         return getMethodsAndRelease(findState);
     }
 
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
+//        通过反射获取方法数组
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             methods = findState.clazz.getDeclaredMethods();
@@ -157,16 +167,21 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+//        遍历Method
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+//            必须是public方法
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
+//                方法必须只有一个参数
                 if (parameterTypes.length == 1) {
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
+//                        检验是否添加改方法
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+//                            实例化SubscriberMethod对象并添加
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
