diff --git a/EventBus/src/main/AndroidManifest.xml b/EventBus/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..ecbdae7b
--- /dev/null
+++ b/EventBus/src/main/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.event"
+    android:versionCode="1"
+    android:versionName="1.0">
+
+    <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17" />
+
+    <application >
+
+    </application>
+
+</manifest>
diff --git a/EventBus/src/main/java/de/greenrobot/event/AsyncPoster.java b/EventBus/src/main/java/de/greenrobot/event/AsyncPoster.java
new file mode 100644
index 00000000..936527b7
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/AsyncPoster.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+
+/**
+ * Posts events in background.
+ * 
+ * @author Markus
+ */
+class AsyncPoster implements Runnable {
+
+    private final PendingPostQueue queue;
+    private final EventBus eventBus;
+
+    AsyncPoster(EventBus eventBus) {
+        this.eventBus = eventBus;
+        queue = new PendingPostQueue();
+    }
+
+    public void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        queue.enqueue(pendingPost);
+        eventBus.getExecutorService().execute(this);
+    }
+
+    @Override
+    public void run() {
+        PendingPost pendingPost = queue.poll();
+        if(pendingPost == null) {
+            throw new IllegalStateException("No pending post available");
+        }
+        eventBus.invokeSubscriber(pendingPost);
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/BackgroundPoster.java b/EventBus/src/main/java/de/greenrobot/event/BackgroundPoster.java
new file mode 100644
index 00000000..00e9ee54
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/BackgroundPoster.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.util.Log;
+
+/**
+ * Posts events in background.
+ * 
+ * @author Markus
+ */
+final class BackgroundPoster implements Runnable {
+
+    private final PendingPostQueue queue;
+    private final EventBus eventBus;
+
+    private volatile boolean executorRunning;
+
+    BackgroundPoster(EventBus eventBus) {
+        this.eventBus = eventBus;
+        queue = new PendingPostQueue();
+    }
+
+    public void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        synchronized (this) {
+            queue.enqueue(pendingPost);
+            if (!executorRunning) {
+                executorRunning = true;
+                eventBus.getExecutorService().execute(this);
+            }
+        }
+    }
+
+    @Override
+    public void run() {
+        try {
+            try {
+                while (true) {
+                    PendingPost pendingPost = queue.poll(1000);
+                    if (pendingPost == null) {
+                        synchronized (this) {
+                            // Check again, this time in synchronized
+                            pendingPost = queue.poll();
+                            if (pendingPost == null) {
+                                executorRunning = false;
+                                return;
+                            }
+                        }
+                    }
+                    eventBus.invokeSubscriber(pendingPost);
+                }
+            } catch (InterruptedException e) {
+                Log.w("Event", Thread.currentThread().getName() + " was interruppted", e);
+            }
+        } finally {
+            executorRunning = false;
+        }
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/EventBus.java b/EventBus/src/main/java/de/greenrobot/event/EventBus.java
new file mode 100644
index 00000000..95863ade
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/EventBus.java
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.os.Looper;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * EventBus is a central publish/subscribe event system for Android. Events are posted ({@link #post(Object)}) to the
+ * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,
+ * subscribers must register themselves to the bus using {@link #register(Object)}. Once registered,
+ * subscribers receive events until {@link #unregister(Object)} is called. By convention, event handling methods must
+ * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event).
+ *
+ * @author Markus Junginger, greenrobot
+ */
+public class EventBus {
+
+    /** Log tag, apps may override it. */
+    public static String TAG = "Event";
+
+    static volatile EventBus defaultInstance;
+
+    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+    private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();
+
+    private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    private final Map<Object, List<Class<?>>> typesBySubscriber;
+    private final Map<Class<?>, Object> stickyEvents;
+
+    private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
+        @Override
+        protected PostingThreadState initialValue() {
+            return new PostingThreadState();
+        }
+    };
+
+
+    private final HandlerPoster mainThreadPoster;
+    private final BackgroundPoster backgroundPoster;
+    private final AsyncPoster asyncPoster;
+    private final SubscriberMethodFinder subscriberMethodFinder;
+    private final ExecutorService executorService;
+
+    private final boolean throwSubscriberException;
+    private final boolean logSubscriberExceptions;
+    private final boolean logNoSubscriberMessages;
+    private final boolean sendSubscriberExceptionEvent;
+    private final boolean sendNoSubscriberEvent;
+    private final boolean eventInheritance;
+
+    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    public static EventBus getDefault() {
+        if (defaultInstance == null) {
+            synchronized (EventBus.class) {
+                if (defaultInstance == null) {
+                    defaultInstance = new EventBus();
+                }
+            }
+        }
+        return defaultInstance;
+    }
+
+    public static EventBusBuilder builder() {
+        return new EventBusBuilder();
+    }
+
+    /** For unit test primarily. */
+    public static void clearCaches() {
+        SubscriberMethodFinder.clearCaches();
+        eventTypesCache.clear();
+    }
+
+    /**
+     * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
+     * central bus, consider {@link #getDefault()}.
+     */
+    public EventBus() {
+        this(DEFAULT_BUILDER);
+    }
+
+    EventBus(EventBusBuilder builder) {
+        subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();
+        typesBySubscriber = new HashMap<Object, List<Class<?>>>();
+        stickyEvents = new ConcurrentHashMap<Class<?>, Object>();
+        mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
+        backgroundPoster = new BackgroundPoster(this);
+        asyncPoster = new AsyncPoster(this);
+        subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses);
+        logSubscriberExceptions = builder.logSubscriberExceptions;
+        logNoSubscriberMessages = builder.logNoSubscriberMessages;
+        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
+        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
+        throwSubscriberException = builder.throwSubscriberException;
+        eventInheritance = builder.eventInheritance;
+        executorService = builder.executorService;
+    }
+
+
+    /**
+     * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
+     * are no longer interested in receiving events.
+     * <p/>
+     * Subscribers have event handling methods that are identified by their name, typically called "onEvent". Event
+     * handling methods must have exactly one parameter, the event. If the event handling method is to be called in a
+     * specific thread, a modifier is appended to the method name. Valid modifiers match one of the {@link ThreadMode}
+     * enums. For example, if a method is to be called in the UI/main thread by EventBus, it would be called
+     * "onEventMainThread".
+     */
+    public void register(Object subscriber) {
+        register(subscriber, false, 0);
+    }
+
+    /**
+     * Like {@link #register(Object)} with an additional subscriber priority to influence the order of event delivery.
+     * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before
+     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
+     * delivery among subscribers with different {@link ThreadMode}s!
+     */
+    public void register(Object subscriber, int priority) {
+        register(subscriber, false, priority);
+    }
+
+    /**
+     * Like {@link #register(Object)}, but also triggers delivery of the most recent sticky event (posted with
+     * {@link #postSticky(Object)}) to the given subscriber.
+     */
+    public void registerSticky(Object subscriber) {
+        register(subscriber, true, 0);
+    }
+
+    /**
+     * Like {@link #register(Object, int)}, but also triggers delivery of the most recent sticky event (posted with
+     * {@link #postSticky(Object)}) to the given subscriber.
+     */
+    public void registerSticky(Object subscriber, int priority) {
+        register(subscriber, true, priority);
+    }
+
+    private synchronized void register(Object subscriber, boolean sticky, int priority) {
+        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());
+        for (SubscriberMethod subscriberMethod : subscriberMethods) {
+            subscribe(subscriber, subscriberMethod, sticky, priority);
+        }
+    }
+
+    // Must be called in synchronized block
+    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {
+        Class<?> eventType = subscriberMethod.eventType;
+        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);
+        if (subscriptions == null) {
+            subscriptions = new CopyOnWriteArrayList<Subscription>();
+            subscriptionsByEventType.put(eventType, subscriptions);
+        } else {
+            if (subscriptions.contains(newSubscription)) {
+                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
+                        + eventType);
+            }
+        }
+
+        // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+        // subscriberMethod.method.setAccessible(true);
+
+        int size = subscriptions.size();
+        for (int i = 0; i <= size; i++) {
+            if (i == size || newSubscription.priority > subscriptions.get(i).priority) {
+                subscriptions.add(i, newSubscription);
+                break;
+            }
+        }
+
+        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
+        if (subscribedEvents == null) {
+            subscribedEvents = new ArrayList<Class<?>>();
+            typesBySubscriber.put(subscriber, subscribedEvents);
+        }
+        subscribedEvents.add(eventType);
+
+        if (sticky) {
+            if (eventInheritance) {
+                // Existing sticky events of all subclasses of eventType have to be considered.
+                // Note: Iterating over all events may be inefficient with lots of sticky events,
+                // thus data structure should be changed to allow a more efficient lookup
+                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
+                for (Map.Entry<Class<?>, Object> entry : entries) {
+                    Class<?> candidateEventType = entry.getKey();
+                    if (eventType.isAssignableFrom(candidateEventType)) {
+                        Object stickyEvent = entry.getValue();
+                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
+                    }
+                }
+            } else {
+                Object stickyEvent = stickyEvents.get(eventType);
+                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
+            }
+        }
+    }
+
+    private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
+        if (stickyEvent != null) {
+            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
+            // --> Strange corner case, which we don't take care of here.
+            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
+        }
+    }
+
+    public synchronized boolean isRegistered(Object subscriber) {
+        return typesBySubscriber.containsKey(subscriber);
+    }
+
+    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
+        List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        if (subscriptions != null) {
+            int size = subscriptions.size();
+            for (int i = 0; i < size; i++) {
+                Subscription subscription = subscriptions.get(i);
+                if (subscription.subscriber == subscriber) {
+                    subscription.active = false;
+                    subscriptions.remove(i);
+                    i--;
+                    size--;
+                }
+            }
+        }
+    }
+
+    /** Unregisters the given subscriber from all event classes. */
+    public synchronized void unregister(Object subscriber) {
+        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
+        if (subscribedTypes != null) {
+            for (Class<?> eventType : subscribedTypes) {
+                unubscribeByEventType(subscriber, eventType);
+            }
+            typesBySubscriber.remove(subscriber);
+        } else {
+            Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
+        }
+    }
+
+    /** Posts the given event to the event bus. */
+    public void post(Object event) {
+        PostingThreadState postingState = currentPostingThreadState.get();
+        List<Object> eventQueue = postingState.eventQueue;
+        eventQueue.add(event);
+
+        if (!postingState.isPosting) {
+            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
+            postingState.isPosting = true;
+            if (postingState.canceled) {
+                throw new EventBusException("Internal error. Abort state was not reset");
+            }
+            try {
+                while (!eventQueue.isEmpty()) {
+                    postSingleEvent(eventQueue.remove(0), postingState);
+                }
+            } finally {
+                postingState.isPosting = false;
+                postingState.isMainThread = false;
+            }
+        }
+    }
+
+    /**
+     * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
+     * subscribers
+     * won't receive the event. Events are usually canceled by higher priority subscribers (see
+     * {@link #register(Object, int)}). Canceling is restricted to event handling methods running in posting thread
+     * {@link ThreadMode#PostThread}.
+     */
+    public void cancelEventDelivery(Object event) {
+        PostingThreadState postingState = currentPostingThreadState.get();
+        if (!postingState.isPosting) {
+            throw new EventBusException(
+                    "This method may only be called from inside event handling methods on the posting thread");
+        } else if (event == null) {
+            throw new EventBusException("Event may not be null");
+        } else if (postingState.event != event) {
+            throw new EventBusException("Only the currently handled event may be aborted");
+        } else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.PostThread) {
+            throw new EventBusException(" event handlers may only abort the incoming event");
+        }
+
+        postingState.canceled = true;
+    }
+
+    /**
+     * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
+     * event of an event's type is kept in memory for future access. This can be {@link #registerSticky(Object)} or
+     * {@link #getStickyEvent(Class)}.
+     */
+    public void postSticky(Object event) {
+        synchronized (stickyEvents) {
+            stickyEvents.put(event.getClass(), event);
+        }
+        // Should be posted after it is putted, in case the subscriber wants to remove immediately
+        post(event);
+    }
+
+    /**
+     * Gets the most recent sticky event for the given type.
+     *
+     * @see #postSticky(Object)
+     */
+    public <T> T getStickyEvent(Class<T> eventType) {
+        synchronized (stickyEvents) {
+            return eventType.cast(stickyEvents.get(eventType));
+        }
+    }
+
+    /**
+     * Remove and gets the recent sticky event for the given event type.
+     *
+     * @see #postSticky(Object)
+     */
+    public <T> T removeStickyEvent(Class<T> eventType) {
+        synchronized (stickyEvents) {
+            return eventType.cast(stickyEvents.remove(eventType));
+        }
+    }
+
+    /**
+     * Removes the sticky event if it equals to the given event.
+     *
+     * @return true if the events matched and the sticky event was removed.
+     */
+    public boolean removeStickyEvent(Object event) {
+        synchronized (stickyEvents) {
+            Class<?> eventType = event.getClass();
+            Object existingEvent = stickyEvents.get(eventType);
+            if (event.equals(existingEvent)) {
+                stickyEvents.remove(eventType);
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    /**
+     * Removes all sticky events.
+     */
+    public void removeAllStickyEvents() {
+        synchronized (stickyEvents) {
+            stickyEvents.clear();
+        }
+    }
+
+    public boolean hasSubscriberForEvent(Class<?> eventClass) {
+        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+        if (eventTypes != null) {
+            int countTypes = eventTypes.size();
+            for (int h = 0; h < countTypes; h++) {
+                Class<?> clazz = eventTypes.get(h);
+                CopyOnWriteArrayList<Subscription> subscriptions;
+                synchronized (this) {
+                    subscriptions = subscriptionsByEventType.get(clazz);
+                }
+                if (subscriptions != null && !subscriptions.isEmpty()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+        Class<?> eventClass = event.getClass();
+        boolean subscriptionFound = false;
+        if (eventInheritance) {
+            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+            int countTypes = eventTypes.size();
+            for (int h = 0; h < countTypes; h++) {
+                Class<?> clazz = eventTypes.get(h);
+                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
+            }
+        } else {
+            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
+        }
+        if (!subscriptionFound) {
+            if (logNoSubscriberMessages) {
+                Log.d(TAG, "No subscribers registered for event " + eventClass);
+            }
+            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
+                    eventClass != SubscriberExceptionEvent.class) {
+                post(new NoSubscriberEvent(this, event));
+            }
+        }
+    }
+
+    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
+        CopyOnWriteArrayList<Subscription> subscriptions;
+        synchronized (this) {
+            subscriptions = subscriptionsByEventType.get(eventClass);
+        }
+        if (subscriptions != null && !subscriptions.isEmpty()) {
+            for (Subscription subscription : subscriptions) {
+                postingState.event = event;
+                postingState.subscription = subscription;
+                boolean aborted = false;
+                try {
+                    postToSubscription(subscription, event, postingState.isMainThread);
+                    aborted = postingState.canceled;
+                } finally {
+                    postingState.event = null;
+                    postingState.subscription = null;
+                    postingState.canceled = false;
+                }
+                if (aborted) {
+                    break;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        switch (subscription.subscriberMethod.threadMode) {
+            case PostThread:
+                invokeSubscriber(subscription, event);
+                break;
+            case MainThread:
+                if (isMainThread) {
+                    invokeSubscriber(subscription, event);
+                } else {
+                    mainThreadPoster.enqueue(subscription, event);
+                }
+                break;
+            case BackgroundThread:
+                if (isMainThread) {
+                    backgroundPoster.enqueue(subscription, event);
+                } else {
+                    invokeSubscriber(subscription, event);
+                }
+                break;
+            case Async:
+                asyncPoster.enqueue(subscription, event);
+                break;
+            default:
+                throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
+        }
+    }
+
+    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    private List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
+        synchronized (eventTypesCache) {
+            List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
+            if (eventTypes == null) {
+                eventTypes = new ArrayList<Class<?>>();
+                Class<?> clazz = eventClass;
+                while (clazz != null) {
+                    eventTypes.add(clazz);
+                    addInterfaces(eventTypes, clazz.getInterfaces());
+                    clazz = clazz.getSuperclass();
+                }
+                eventTypesCache.put(eventClass, eventTypes);
+            }
+            return eventTypes;
+        }
+    }
+
+    /** Recurses through super interfaces. */
+    static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
+        for (Class<?> interfaceClass : interfaces) {
+            if (!eventTypes.contains(interfaceClass)) {
+                eventTypes.add(interfaceClass);
+                addInterfaces(eventTypes, interfaceClass.getInterfaces());
+            }
+        }
+    }
+
+    /**
+     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
+     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
+     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
+     * live cycle of an Activity or Fragment.
+     */
+    void invokeSubscriber(PendingPost pendingPost) {
+        Object event = pendingPost.event;
+        Subscription subscription = pendingPost.subscription;
+        PendingPost.releasePendingPost(pendingPost);
+        if (subscription.active) {
+            invokeSubscriber(subscription, event);
+        }
+    }
+
+    void invokeSubscriber(Subscription subscription, Object event) {
+        try {
+            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
+        } catch (InvocationTargetException e) {
+            handleSubscriberException(subscription, event, e.getCause());
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException("Unexpected exception", e);
+        }
+    }
+
+    private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
+        if (event instanceof SubscriberExceptionEvent) {
+            if (logSubscriberExceptions) {
+                // Don't send another SubscriberExceptionEvent to avoid infinite event recursion, just log
+                Log.e(TAG, "SubscriberExceptionEvent subscriber " + subscription.subscriber.getClass()
+                        + " threw an exception", cause);
+                SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;
+                Log.e(TAG, "Initial event " + exEvent.causingEvent + " caused exception in "
+                        + exEvent.causingSubscriber, exEvent.throwable);
+            }
+        } else {
+            if (throwSubscriberException) {
+                throw new EventBusException("Invoking subscriber failed", cause);
+            }
+            if (logSubscriberExceptions) {
+                Log.e(TAG, "Could not dispatch event: " + event.getClass() + " to subscribing class "
+                        + subscription.subscriber.getClass(), cause);
+            }
+            if (sendSubscriberExceptionEvent) {
+                SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,
+                        subscription.subscriber);
+                post(exEvent);
+            }
+        }
+    }
+
+    /** For ThreadLocal, much faster to set (and get multiple values). */
+    final static class PostingThreadState {
+        final List<Object> eventQueue = new ArrayList<Object>();
+        boolean isPosting;
+        boolean isMainThread;
+        Subscription subscription;
+        Object event;
+        boolean canceled;
+    }
+
+    ExecutorService getExecutorService() {
+        return executorService;
+    }
+
+    // Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...
+    /* public */interface PostCallback {
+        void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/EventBusBuilder.java b/EventBus/src/main/java/de/greenrobot/event/EventBusBuilder.java
new file mode 100644
index 00000000..06350609
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/EventBusBuilder.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2014 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Creates EventBus instances with custom parameters and also allows to install a custom default EventBus instance.
+ * Create a new builder using {@link EventBus#builder()}.
+ */
+public class EventBusBuilder {
+    private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
+
+    boolean logSubscriberExceptions = true;
+    boolean logNoSubscriberMessages = true;
+    boolean sendSubscriberExceptionEvent = true;
+    boolean sendNoSubscriberEvent = true;
+    boolean throwSubscriberException;
+    boolean eventInheritance = true;
+    ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
+    List<Class<?>> skipMethodVerificationForClasses;
+
+    EventBusBuilder() {
+    }
+
+    /** Default: true */
+    public EventBusBuilder logSubscriberExceptions(boolean logSubscriberExceptions) {
+        this.logSubscriberExceptions = logSubscriberExceptions;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder logNoSubscriberMessages(boolean logNoSubscriberMessages) {
+        this.logNoSubscriberMessages = logNoSubscriberMessages;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent) {
+        this.sendSubscriberExceptionEvent = sendSubscriberExceptionEvent;
+        return this;
+    }
+
+    /** Default: true */
+    public EventBusBuilder sendNoSubscriberEvent(boolean sendNoSubscriberEvent) {
+        this.sendNoSubscriberEvent = sendNoSubscriberEvent;
+        return this;
+    }
+
+    /**
+     * Fails if an subscriber throws an exception (default: false).
+     * <p/>
+     * Tip: Use this with BuildConfig.DEBUG to let the app crash in DEBUG mode (only). This way, you won't miss
+     * exceptions during development.
+     */
+    public EventBusBuilder throwSubscriberException(boolean throwSubscriberException) {
+        this.throwSubscriberException = throwSubscriberException;
+        return this;
+    }
+
+    /**
+     * By default, EventBus considers the event class hierarchy (subscribers to super classes will be notified).
+     * Switching this feature off will improve posting of events. For simple event classes extending Object directly,
+     * we measured a speed up of 20% for event posting. For more complex event hierarchies, the speed up should be
+     * >20%.
+     * <p/>
+     * However, keep in mind that event posting usually consumes just a small proportion of CPU time inside an app,
+     * unless it is posting at high rates, e.g. hundreds/thousands of events per second.
+     */
+    public EventBusBuilder eventInheritance(boolean eventInheritance) {
+        this.eventInheritance = eventInheritance;
+        return this;
+    }
+
+
+    /**
+     * Provide a custom thread pool to EventBus used for async and background event delivery. This is an advanced
+     * setting to that can break things: ensure the given ExecutorService won't get stuck to avoid undefined behavior.
+     */
+    public EventBusBuilder executorService(ExecutorService executorService) {
+        this.executorService = executorService;
+        return this;
+    }
+
+    /**
+     * Method name verification is done for methods starting with onEvent to avoid typos; using this method you can
+     * exclude subscriber classes from this check. Also disables checks for method modifiers (public, not static nor
+     * abstract).
+     */
+    public EventBusBuilder skipMethodVerificationFor(Class<?> clazz) {
+        if (skipMethodVerificationForClasses == null) {
+            skipMethodVerificationForClasses = new ArrayList<Class<?>>();
+        }
+        skipMethodVerificationForClasses.add(clazz);
+        return this;
+    }
+
+    /**
+     * Installs the default EventBus returned by {@link EventBus#getDefault()} using this builders' values. Must be
+     * done only once before the first usage of the default EventBus.
+     *
+     * @throws EventBusException if there's already a default EventBus instance in place
+     */
+    public EventBus installDefaultEventBus() {
+        synchronized (EventBus.class) {
+            if (EventBus.defaultInstance != null) {
+                throw new EventBusException("Default instance already exists." +
+                        " It may be only set once before it's used the first time to ensure consistent behavior.");
+            }
+            EventBus.defaultInstance = build();
+            return EventBus.defaultInstance;
+        }
+    }
+
+    /** Builds an EventBus based on the current configuration. */
+    public EventBus build() {
+        return new EventBus(this);
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/EventBusException.java b/EventBus/src/main/java/de/greenrobot/event/EventBusException.java
new file mode 100644
index 00000000..80c51f86
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/EventBusException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * An {@link RuntimeException} thrown in cases something went wrong inside EventBus.
+ * 
+ * @author Markus
+ * 
+ */
+public class EventBusException extends RuntimeException {
+
+    private static final long serialVersionUID = -2912559384646531479L;
+
+    public EventBusException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    public EventBusException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public EventBusException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/HandlerPoster.java b/EventBus/src/main/java/de/greenrobot/event/HandlerPoster.java
new file mode 100644
index 00000000..c1c44608
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/HandlerPoster.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.SystemClock;
+
+final class HandlerPoster extends Handler {
+
+    private final PendingPostQueue queue;
+    private final int maxMillisInsideHandleMessage;
+    private final EventBus eventBus;
+    private boolean handlerActive;
+
+    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
+        super(looper);
+        this.eventBus = eventBus;
+        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
+        queue = new PendingPostQueue();
+    }
+
+    void enqueue(Subscription subscription, Object event) {
+        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        synchronized (this) {
+            queue.enqueue(pendingPost);
+            if (!handlerActive) {
+                handlerActive = true;
+                if (!sendMessage(obtainMessage())) {
+                    throw new EventBusException("Could not send handler message");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        boolean rescheduled = false;
+        try {
+            long started = SystemClock.uptimeMillis();
+            while (true) {
+                PendingPost pendingPost = queue.poll();
+                if (pendingPost == null) {
+                    synchronized (this) {
+                        // Check again, this time in synchronized
+                        pendingPost = queue.poll();
+                        if (pendingPost == null) {
+                            handlerActive = false;
+                            return;
+                        }
+                    }
+                }
+                eventBus.invokeSubscriber(pendingPost);
+                long timeInMethod = SystemClock.uptimeMillis() - started;
+                if (timeInMethod >= maxMillisInsideHandleMessage) {
+                    if (!sendMessage(obtainMessage())) {
+                        throw new EventBusException("Could not send handler message");
+                    }
+                    rescheduled = true;
+                    return;
+                }
+            }
+        } finally {
+            handlerActive = rescheduled;
+        }
+    }
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/NoSubscriberEvent.java b/EventBus/src/main/java/de/greenrobot/event/NoSubscriberEvent.java
new file mode 100644
index 00000000..a7378ae8
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/NoSubscriberEvent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * This Event is posted by EventBus when no subscriber is found for a posted event.
+ * 
+ * @author Markus
+ */
+public final class NoSubscriberEvent {
+    /** The {@link EventBus} instance to with the original event was posted to. */
+    public final EventBus eventBus;
+
+    /** The original event that could not be delivered to any subscriber. */
+    public final Object originalEvent;
+
+    public NoSubscriberEvent(EventBus eventBus, Object originalEvent) {
+        this.eventBus = eventBus;
+        this.originalEvent = originalEvent;
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/PendingPost.java b/EventBus/src/main/java/de/greenrobot/event/PendingPost.java
new file mode 100644
index 00000000..0bd5a2ec
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/PendingPost.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.util.ArrayList;
+import java.util.List;
+
+final class PendingPost {
+    private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
+
+    Object event;
+    Subscription subscription;
+    PendingPost next;
+
+    private PendingPost(Object event, Subscription subscription) {
+        this.event = event;
+        this.subscription = subscription;
+    }
+
+    static PendingPost obtainPendingPost(Subscription subscription, Object event) {
+        synchronized (pendingPostPool) {
+            int size = pendingPostPool.size();
+            if (size > 0) {
+                PendingPost pendingPost = pendingPostPool.remove(size - 1);
+                pendingPost.event = event;
+                pendingPost.subscription = subscription;
+                pendingPost.next = null;
+                return pendingPost;
+            }
+        }
+        return new PendingPost(event, subscription);
+    }
+
+    static void releasePendingPost(PendingPost pendingPost) {
+        pendingPost.event = null;
+        pendingPost.subscription = null;
+        pendingPost.next = null;
+        synchronized (pendingPostPool) {
+            // Don't let the pool grow indefinitely
+            if (pendingPostPool.size() < 10000) {
+                pendingPostPool.add(pendingPost);
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/PendingPostQueue.java b/EventBus/src/main/java/de/greenrobot/event/PendingPostQueue.java
new file mode 100644
index 00000000..5440559b
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/PendingPostQueue.java
@@ -0,0 +1,40 @@
+package de.greenrobot.event;
+
+final class PendingPostQueue {
+    private PendingPost head;
+    private PendingPost tail;
+
+    synchronized void enqueue(PendingPost pendingPost) {
+        if (pendingPost == null) {
+            throw new NullPointerException("null cannot be enqueued");
+        }
+        if (tail != null) {
+            tail.next = pendingPost;
+            tail = pendingPost;
+        } else if (head == null) {
+            head = tail = pendingPost;
+        } else {
+            throw new IllegalStateException("Head present, but no tail");
+        }
+        notifyAll();
+    }
+
+    synchronized PendingPost poll() {
+        PendingPost pendingPost = head;
+        if (head != null) {
+            head = head.next;
+            if (head == null) {
+                tail = null;
+            }
+        }
+        return pendingPost;
+    }
+
+    synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
+        if (head == null) {
+            wait(maxMillisToWait);
+        }
+        return poll();
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/SubscriberExceptionEvent.java b/EventBus/src/main/java/de/greenrobot/event/SubscriberExceptionEvent.java
new file mode 100644
index 00000000..5d3b9b55
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/SubscriberExceptionEvent.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.
+ * 
+ * @author Markus
+ */
+public final class SubscriberExceptionEvent {
+    /** The {@link EventBus} instance to with the original event was posted to. */
+    public final EventBus eventBus;
+
+    /** The Throwable thrown by a subscriber. */
+    public final Throwable throwable;
+
+    /** The original event that could not be delivered to any subscriber. */
+    public final Object causingEvent;
+
+    /** The subscriber that threw the Throwable. */
+    public final Object causingSubscriber;
+
+    public SubscriberExceptionEvent(EventBus eventBus, Throwable throwable, Object causingEvent,
+            Object causingSubscriber) {
+        this.eventBus = eventBus;
+        this.throwable = throwable;
+        this.causingEvent = causingEvent;
+        this.causingSubscriber = causingSubscriber;
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/SubscriberMethod.java b/EventBus/src/main/java/de/greenrobot/event/SubscriberMethod.java
new file mode 100644
index 00000000..5e0df398
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/SubscriberMethod.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.lang.reflect.Method;
+
+final class SubscriberMethod {
+    final Method method;
+    final ThreadMode threadMode;
+    final Class<?> eventType;
+    /** Used for efficient comparison */
+    String methodString;
+
+    SubscriberMethod(Method method, ThreadMode threadMode, Class<?> eventType) {
+        this.method = method;
+        this.threadMode = threadMode;
+        this.eventType = eventType;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof SubscriberMethod) {
+            checkMethodString();
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            otherSubscriberMethod.checkMethodString();
+            // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
+            return methodString.equals(otherSubscriberMethod.methodString);
+        } else {
+            return false;
+        }
+    }
+
+    private synchronized void checkMethodString() {
+        if (methodString == null) {
+            // Method.toString has more overhead, just take relevant parts of the method
+            StringBuilder builder = new StringBuilder(64);
+            builder.append(method.getDeclaringClass().getName());
+            builder.append('#').append(method.getName());
+            builder.append('(').append(eventType.getName());
+            methodString = builder.toString();
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return method.hashCode();
+    }
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/main/java/de/greenrobot/event/SubscriberMethodFinder.java
new file mode 100644
index 00000000..823cb0ec
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/SubscriberMethodFinder.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import android.util.Log;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+class SubscriberMethodFinder {
+    private static final String ON_EVENT_METHOD_NAME = "onEvent";
+
+    /*
+     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
+     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
+     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
+     */
+    private static final int BRIDGE = 0x40;
+    private static final int SYNTHETIC = 0x1000;
+
+    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+    private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
+
+    private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
+
+    SubscriberMethodFinder(List<Class<?>> skipMethodVerificationForClassesList) {
+        skipMethodVerificationForClasses = new ConcurrentHashMap<Class<?>, Class<?>>();
+        if (skipMethodVerificationForClassesList != null) {
+            for (Class<?> clazz : skipMethodVerificationForClassesList) {
+                skipMethodVerificationForClasses.put(clazz, clazz);
+            }
+        }
+    }
+
+    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        String key = subscriberClass.getName();
+        List<SubscriberMethod> subscriberMethods;
+        synchronized (methodCache) {
+            subscriberMethods = methodCache.get(key);
+        }
+        if (subscriberMethods != null) {
+            return subscriberMethods;
+        }
+        subscriberMethods = new ArrayList<SubscriberMethod>();
+        Class<?> clazz = subscriberClass;
+        HashSet<String> eventTypesFound = new HashSet<String>();
+        StringBuilder methodKeyBuilder = new StringBuilder();
+        while (clazz != null) {
+            String name = clazz.getName();
+            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
+                // Skip system classes, this just degrades performance
+                break;
+            }
+
+            // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
+            Method[] methods = clazz.getDeclaredMethods();
+            for (Method method : methods) {
+                String methodName = method.getName();
+                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
+                    int modifiers = method.getModifiers();
+                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                        Class<?>[] parameterTypes = method.getParameterTypes();
+                        if (parameterTypes.length == 1) {
+                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
+                            ThreadMode threadMode;
+                            if (modifierString.length() == 0) {
+                                threadMode = ThreadMode.PostThread;
+                            } else if (modifierString.equals("MainThread")) {
+                                threadMode = ThreadMode.MainThread;
+                            } else if (modifierString.equals("BackgroundThread")) {
+                                threadMode = ThreadMode.BackgroundThread;
+                            } else if (modifierString.equals("Async")) {
+                                threadMode = ThreadMode.Async;
+                            } else {
+                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
+                                    continue;
+                                } else {
+                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
+                                }
+                            }
+                            Class<?> eventType = parameterTypes[0];
+                            methodKeyBuilder.setLength(0);
+                            methodKeyBuilder.append(methodName);
+                            methodKeyBuilder.append('>').append(eventType.getName());
+                            String methodKey = methodKeyBuilder.toString();
+                            if (eventTypesFound.add(methodKey)) {
+                                // Only add if not already found in a sub class
+                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                            }
+                        }
+                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
+                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
+                                + methodName);
+                    }
+                }
+            }
+            clazz = clazz.getSuperclass();
+        }
+        if (subscriberMethods.isEmpty()) {
+            throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
+                    + ON_EVENT_METHOD_NAME);
+        } else {
+            synchronized (methodCache) {
+                methodCache.put(key, subscriberMethods);
+            }
+            return subscriberMethods;
+        }
+    }
+
+    static void clearCaches() {
+        synchronized (methodCache) {
+            methodCache.clear();
+        }
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/Subscription.java b/EventBus/src/main/java/de/greenrobot/event/Subscription.java
new file mode 100644
index 00000000..6c84c440
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/Subscription.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+final class Subscription {
+    final Object subscriber;
+    final SubscriberMethod subscriberMethod;
+    final int priority;
+    /**
+     * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
+     * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions.
+     */
+    volatile boolean active;
+
+    Subscription(Object subscriber, SubscriberMethod subscriberMethod, int priority) {
+        this.subscriber = subscriber;
+        this.subscriberMethod = subscriberMethod;
+        this.priority = priority;
+        active = true;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof Subscription) {
+            Subscription otherSubscription = (Subscription) other;
+            return subscriber == otherSubscription.subscriber
+                    && subscriberMethod.equals(otherSubscription.subscriberMethod);
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return subscriber.hashCode() + subscriberMethod.methodString.hashCode();
+    }
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/ThreadMode.java b/EventBus/src/main/java/de/greenrobot/event/ThreadMode.java
new file mode 100644
index 00000000..4022ace5
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/ThreadMode.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+/**
+ * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.
+ * EventBus takes care of threading independently from the posting thread.
+ * 
+ * @see EventBus#register(Object)
+ * @author Markus
+ */
+public enum ThreadMode {
+    /**
+     * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
+     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
+     * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
+     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
+     */
+    PostThread,
+
+    /**
+     * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
+     * the main thread, event handler methods will be called directly. Event handlers using this mode must return
+     * quickly to avoid blocking the main thread.
+     */
+    MainThread,
+
+    /**
+     * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
+     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
+     * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
+     * return quickly to avoid blocking the background thread.
+     */
+    BackgroundThread,
+
+    /**
+     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
+     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
+     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
+     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
+     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
+     */
+    Async
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/AsyncExecutor.java b/EventBus/src/main/java/de/greenrobot/event/util/AsyncExecutor.java
new file mode 100644
index 00000000..71048a43
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/AsyncExecutor.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.util;
+
+import java.lang.reflect.Constructor;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import android.app.Activity;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+/**
+ * Executes an {@link RunnableEx} using a thread pool. Thrown exceptions are propagated by posting failure events of any
+ * given type (default is {@link ThrowableFailureEvent}).
+ * 
+ * @author Markus
+ */
+public class AsyncExecutor {
+
+    public static class Builder {
+        private Executor threadPool;
+        private Class<?> failureEventType;
+        private EventBus eventBus;
+
+        private Builder() {
+        }
+
+        public Builder threadPool(Executor threadPool) {
+            this.threadPool = threadPool;
+            return this;
+        }
+
+        public Builder failureEventType(Class<?> failureEventType) {
+            this.failureEventType = failureEventType;
+            return this;
+        }
+
+        public Builder eventBus(EventBus eventBus) {
+            this.eventBus = eventBus;
+            return this;
+        }
+
+        public AsyncExecutor build() {
+            return buildForScope(null);
+        }
+
+        public AsyncExecutor buildForActivityScope(Activity activity) {
+            return buildForScope(activity.getClass());
+        }
+        
+        public AsyncExecutor buildForScope(Object executionContext) {
+            if (eventBus == null) {
+                eventBus = EventBus.getDefault();
+            }
+            if (threadPool == null) {
+                threadPool = Executors.newCachedThreadPool();
+            }
+            if (failureEventType == null) {
+                failureEventType = ThrowableFailureEvent.class;
+            }
+            return new AsyncExecutor(threadPool, eventBus, failureEventType, executionContext);
+        }
+    }
+
+    /** Like {@link Runnable}, but the run method may throw an exception. */
+    public interface RunnableEx {
+        void run() throws Exception;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static AsyncExecutor create() {
+        return new Builder().build();
+    }
+
+    private final Executor threadPool;
+    private final Constructor<?> failureEventConstructor;
+    private final EventBus eventBus;
+    private final Object scope;
+
+    private AsyncExecutor(Executor threadPool, EventBus eventBus, Class<?> failureEventType, Object scope) {
+        this.threadPool = threadPool;
+        this.eventBus = eventBus;
+        this.scope = scope;
+        try {
+            failureEventConstructor = failureEventType.getConstructor(Throwable.class);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(
+                    "Failure event class must have a constructor with one parameter of type Throwable", e);
+        }
+    }
+
+    /** Posts an failure event if the given {@link RunnableEx} throws an Exception. */
+    public void execute(final RunnableEx runnable) {
+        threadPool.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    runnable.run();
+                } catch (Exception e) {
+                    Object event;
+                    try {
+                        event = failureEventConstructor.newInstance(e);
+                    } catch (Exception e1) {
+                        Log.e(EventBus.TAG, "Original exception:", e);
+                        throw new RuntimeException("Could not create failure event", e1);
+                    }
+                    if (event instanceof HasExecutionScope) {
+                        ((HasExecutionScope) event).setExecutionScope(scope);
+                    }
+                    eventBus.post(event);
+                }
+            }
+        });
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogConfig.java b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogConfig.java
new file mode 100644
index 00000000..25432631
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogConfig.java
@@ -0,0 +1,65 @@
+package de.greenrobot.event.util;
+
+import android.content.res.Resources;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+public class ErrorDialogConfig {
+    final Resources resources;
+    final int defaultTitleId;
+    final int defaultErrorMsgId;
+    final ExceptionToResourceMapping mapping;
+
+    EventBus eventBus;
+    boolean logExceptions = true;
+    String tagForLoggingExceptions;
+    int defaultDialogIconId;
+    Class<?> defaultEventTypeOnDialogClosed;
+
+    public ErrorDialogConfig(Resources resources, int defaultTitleId, int defaultMsgId) {
+        this.resources = resources;
+        this.defaultTitleId = defaultTitleId;
+        this.defaultErrorMsgId = defaultMsgId;
+        mapping = new ExceptionToResourceMapping();
+    }
+
+    public ErrorDialogConfig addMapping(Class<? extends Throwable> clazz, int msgId) {
+        mapping.addMapping(clazz, msgId);
+        return this;
+    }
+
+    public int getMessageIdForThrowable(final Throwable throwable) {
+        Integer resId = mapping.mapThrowable(throwable);
+        if (resId != null) {
+            return resId;
+        } else {
+            Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
+            return defaultErrorMsgId;
+        }
+    }
+
+    public void setDefaultDialogIconId(int defaultDialogIconId) {
+        this.defaultDialogIconId = defaultDialogIconId;
+    }
+
+    public void setDefaultEventTypeOnDialogClosed(Class<?> defaultEventTypeOnDialogClosed) {
+        this.defaultEventTypeOnDialogClosed = defaultEventTypeOnDialogClosed;
+    }
+
+    public void disableExceptionLogging() {
+        logExceptions = false;
+    }
+
+    public void setTagForLoggingExceptions(String tagForLoggingExceptions) {
+        this.tagForLoggingExceptions = tagForLoggingExceptions;
+    }
+
+    public void setEventBus(EventBus eventBus) {
+        this.eventBus = eventBus;
+    }
+
+    /** eventBus!=null ? eventBus: EventBus.getDefault() */
+    EventBus getEventBus() {
+        return eventBus!=null ? eventBus: EventBus.getDefault();
+    }
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragmentFactory.java b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragmentFactory.java
new file mode 100644
index 00000000..47b693b6
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragmentFactory.java
@@ -0,0 +1,98 @@
+package de.greenrobot.event.util;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+/**
+ * Factory to allow injecting a more complex exception mapping; typically you would subclass one of {@link Honeycomb} or
+ * {@link Support}.
+ */
+public abstract class ErrorDialogFragmentFactory<T> {
+    protected final ErrorDialogConfig config;
+
+    protected ErrorDialogFragmentFactory(ErrorDialogConfig config) {
+        this.config = config;
+    }
+
+    /**
+     * Prepares the fragment's arguments and creates the fragment. May be overridden to provide custom error fragments.
+     */
+    protected T prepareErrorFragment(ThrowableFailureEvent event, boolean finishAfterDialog,
+            Bundle argumentsForErrorDialog) {
+        if (event.isSuppressErrorUi()) {
+            // Show nothing by default
+            return null;
+        }
+        Bundle bundle;
+        if (argumentsForErrorDialog != null) {
+            bundle = (Bundle) argumentsForErrorDialog.clone();
+        } else {
+            bundle = new Bundle();
+        }
+
+        if (!bundle.containsKey(ErrorDialogManager.KEY_TITLE)) {
+            String title = getTitleFor(event, bundle);
+            bundle.putString(ErrorDialogManager.KEY_TITLE, title);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_MESSAGE)) {
+            String message = getMessageFor(event, bundle);
+            bundle.putString(ErrorDialogManager.KEY_MESSAGE, message);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG)) {
+            bundle.putBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, finishAfterDialog);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE)
+                && config.defaultEventTypeOnDialogClosed != null) {
+            bundle.putSerializable(ErrorDialogManager.KEY_EVENT_TYPE_ON_CLOSE, config.defaultEventTypeOnDialogClosed);
+        }
+        if (!bundle.containsKey(ErrorDialogManager.KEY_ICON_ID) && config.defaultDialogIconId != 0) {
+            bundle.putInt(ErrorDialogManager.KEY_ICON_ID, config.defaultDialogIconId);
+        }
+        return createErrorFragment(event, bundle);
+    }
+
+    /** Returns either a new Honeycomb+ or a new support library DialogFragment. */
+    protected abstract T createErrorFragment(ThrowableFailureEvent event, Bundle arguments);
+
+    /** May be overridden to provide custom error title. */
+    protected String getTitleFor(ThrowableFailureEvent event, Bundle arguments) {
+        return config.resources.getString(config.defaultTitleId);
+    }
+
+    /** May be overridden to provide custom error messages. */
+    protected String getMessageFor(ThrowableFailureEvent event, Bundle arguments) {
+        int msgResId = config.getMessageIdForThrowable(event.throwable);
+        return config.resources.getString(msgResId);
+    }
+
+    public static class Support extends ErrorDialogFragmentFactory<Fragment> {
+
+        public Support(ErrorDialogConfig config) {
+            super(config);
+        }
+
+        protected Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
+            ErrorDialogFragments.Support errorFragment = new ErrorDialogFragments.Support();
+            errorFragment.setArguments(arguments);
+            return errorFragment;
+        }
+
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static class Honeycomb extends ErrorDialogFragmentFactory<android.app.Fragment> {
+
+        public Honeycomb(ErrorDialogConfig config) {
+            super(config);
+        }
+
+        protected android.app.Fragment createErrorFragment(ThrowableFailureEvent event, Bundle arguments) {
+            ErrorDialogFragments.Honeycomb errorFragment = new ErrorDialogFragments.Honeycomb();
+            errorFragment.setArguments(arguments);
+            return errorFragment;
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragments.java b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragments.java
new file mode 100644
index 00000000..04002df2
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogFragments.java
@@ -0,0 +1,74 @@
+package de.greenrobot.event.util;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import de.greenrobot.event.EventBus;
+
+public class ErrorDialogFragments {
+    /** TODO Use config:  Icon res ID to use for all error dialogs. May be configured by each app (optional). */
+    public static int ERROR_DIALOG_ICON = 0;
+
+    /** TODO Use config:  Event class to be fired on dismissing the dialog by the user. May be configured by each app. */
+    public static Class<?> EVENT_TYPE_ON_CLICK;
+
+    public static Dialog createDialog(Context context, Bundle arguments, OnClickListener onClickListener) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        builder.setTitle(arguments.getString(ErrorDialogManager.KEY_TITLE));
+        builder.setMessage(arguments.getString(ErrorDialogManager.KEY_MESSAGE));
+        if (ERROR_DIALOG_ICON != 0) {
+            builder.setIcon(ERROR_DIALOG_ICON);
+        }
+        builder.setPositiveButton(android.R.string.ok, onClickListener);
+        return builder.create();
+    }
+
+    public static void handleOnClick(DialogInterface dialog, int which, Activity activity, Bundle arguments) {
+        if (EVENT_TYPE_ON_CLICK != null) {
+            Object event;
+            try {
+                event = EVENT_TYPE_ON_CLICK.newInstance();
+            } catch (Exception e) {
+                throw new RuntimeException("Event cannot be constructed", e);
+            }
+            EventBus eventBus = ErrorDialogManager.factory.config.getEventBus();
+            eventBus.post(event);
+        }
+        boolean finish = arguments.getBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, false);
+        if (finish && activity != null) {
+            activity.finish();
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static class Honeycomb extends android.app.DialogFragment implements OnClickListener {
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            return createDialog(getActivity(), getArguments(), this);
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            handleOnClick(dialog, which, getActivity(), getArguments());
+        }
+    }
+
+    public static class Support extends DialogFragment implements OnClickListener {
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            return createDialog(getActivity(), getArguments(), this);
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            handleOnClick(dialog, which, getActivity(), getArguments());
+        }
+    }
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogManager.java b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogManager.java
new file mode 100644
index 00000000..cee7c6a5
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ErrorDialogManager.java
@@ -0,0 +1,245 @@
+package de.greenrobot.event.util;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.Application;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+/**
+ * Central class for app that want to use event based error dialogs.<br/>
+ * <br/>
+ * How to use:
+ * <ol>
+ * <li>Set the {@link #factory} to configure dialogs for your app, typically in {@link Application#onCreate()}</li>
+ * <li>Use one of {@link #attachTo(Activity)}, {@link #attachTo(Activity, boolean)} or
+ * {@link #attachTo(Activity, boolean, Bundle)} in your Activity, typically in onCreate.</li>
+ * </ol>
+ * 
+ * For more complex mappings, you can supply your own {@link ErrorDialogFragmentFactory}.
+ * 
+ * @author Markus
+ */
+public class ErrorDialogManager {
+
+    public static class SupportManagerFragment extends Fragment {
+        protected boolean finishAfterDialog;
+        protected Bundle argumentsForErrorDialog;
+        private EventBus eventBus;
+        private boolean skipRegisterOnNextResume;
+        private Object executionScope;
+
+        @Override
+        public void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            eventBus = ErrorDialogManager.factory.config.getEventBus();
+            eventBus.register(this);
+            skipRegisterOnNextResume = true;
+        }
+
+        @Override
+        public void onResume() {
+            super.onResume();
+            if (skipRegisterOnNextResume) {
+                // registered in onCreate, skip registration in this run
+                skipRegisterOnNextResume = false;
+            } else {
+                eventBus = ErrorDialogManager.factory.config.getEventBus();
+                eventBus.register(this);
+            }
+        }
+
+        @Override
+        public void onPause() {
+            eventBus.unregister(this);
+            super.onPause();
+        }
+
+        public void onEventMainThread(ThrowableFailureEvent event) {
+            if (!isInExecutionScope(executionScope, event)) {
+                return;
+            }
+            checkLogException(event);
+            // Execute pending commits before finding to avoid multiple error fragments being shown
+            FragmentManager fm = getFragmentManager();
+            fm.executePendingTransactions();
+
+            DialogFragment existingFragment = (DialogFragment) fm.findFragmentByTag(TAG_ERROR_DIALOG);
+            if (existingFragment != null) {
+                // Just show the latest error
+                existingFragment.dismiss();
+            }
+
+            android.support.v4.app.DialogFragment errorFragment = (android.support.v4.app.DialogFragment) factory
+                    .prepareErrorFragment(event, finishAfterDialog, argumentsForErrorDialog);
+            if (errorFragment != null) {
+                errorFragment.show(fm, TAG_ERROR_DIALOG);
+            }
+        }
+
+        public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog,
+                Bundle argumentsForErrorDialog) {
+            FragmentManager fm = ((FragmentActivity) activity).getSupportFragmentManager();
+            SupportManagerFragment fragment = (SupportManagerFragment) fm.findFragmentByTag(TAG_ERROR_DIALOG_MANAGER);
+            if (fragment == null) {
+                fragment = new SupportManagerFragment();
+                fm.beginTransaction().add(fragment, TAG_ERROR_DIALOG_MANAGER).commit();
+                fm.executePendingTransactions();
+            }
+            fragment.finishAfterDialog = finishAfterDialog;
+            fragment.argumentsForErrorDialog = argumentsForErrorDialog;
+            fragment.executionScope = executionScope;
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static class HoneycombManagerFragment extends android.app.Fragment {
+        protected boolean finishAfterDialog;
+        protected Bundle argumentsForErrorDialog;
+        private EventBus eventBus;
+        private Object executionScope;
+
+        @Override
+        public void onResume() {
+            super.onResume();
+            eventBus = ErrorDialogManager.factory.config.getEventBus();
+            eventBus.register(this);
+        }
+
+        @Override
+        public void onPause() {
+            eventBus.unregister(this);
+            super.onPause();
+        }
+
+        public void onEventMainThread(ThrowableFailureEvent event) {
+            if (!isInExecutionScope(executionScope, event)) {
+                return;
+            }
+            checkLogException(event);
+
+            // Execute pending commits before finding to avoid multiple error fragments being shown
+            android.app.FragmentManager fm = getFragmentManager();
+            fm.executePendingTransactions();
+
+            android.app.DialogFragment existingFragment = (android.app.DialogFragment) fm
+                    .findFragmentByTag(TAG_ERROR_DIALOG);
+            if (existingFragment != null) {
+                // Just show the latest error
+                existingFragment.dismiss();
+            }
+
+            android.app.DialogFragment errorFragment = (android.app.DialogFragment) factory.prepareErrorFragment(event,
+                    finishAfterDialog, argumentsForErrorDialog);
+            if (errorFragment != null) {
+                errorFragment.show(fm, TAG_ERROR_DIALOG);
+            }
+        }
+
+        public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+            android.app.FragmentManager fm = activity.getFragmentManager();
+            HoneycombManagerFragment fragment = (HoneycombManagerFragment) fm
+                    .findFragmentByTag(TAG_ERROR_DIALOG_MANAGER);
+            if (fragment == null) {
+                fragment = new HoneycombManagerFragment();
+                fm.beginTransaction().add(fragment, TAG_ERROR_DIALOG_MANAGER).commit();
+                fm.executePendingTransactions();
+            }
+            fragment.finishAfterDialog = finishAfterDialog;
+            fragment.argumentsForErrorDialog = argumentsForErrorDialog;
+            fragment.executionScope = executionScope;
+        }
+    }
+
+    /** Must be set by the application. */
+    public static ErrorDialogFragmentFactory<?> factory;
+
+    protected static final String TAG_ERROR_DIALOG = "de.greenrobot.eventbus.error_dialog";
+    protected static final String TAG_ERROR_DIALOG_MANAGER = "de.greenrobot.eventbus.error_dialog_manager";
+
+    public static final String KEY_TITLE = "de.greenrobot.eventbus.errordialog.title";
+    public static final String KEY_MESSAGE = "de.greenrobot.eventbus.errordialog.message";
+    public static final String KEY_FINISH_AFTER_DIALOG = "de.greenrobot.eventbus.errordialog.finish_after_dialog";
+    public static final String KEY_ICON_ID = "de.greenrobot.eventbus.errordialog.icon_id";
+    public static final String KEY_EVENT_TYPE_ON_CLOSE = "de.greenrobot.eventbus.errordialog.event_type_on_close";
+
+    /** Scope is limited to the activity's class. */
+    public static void attachTo(Activity activity) {
+        attachTo(activity, false, null);
+    }
+
+    /** Scope is limited to the activity's class. */
+    public static void attachTo(Activity activity, boolean finishAfterDialog) {
+        attachTo(activity, finishAfterDialog, null);
+    }
+
+    /** Scope is limited to the activity's class. */
+    public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+        Object executionScope = activity.getClass();
+        attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
+    }
+    
+    public static void attachTo(Activity activity, Object executionScope, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {
+        if (factory == null) {
+            throw new RuntimeException("You must set the static factory field to configure error dialogs for your app.");
+        }
+        if (isSupportActivity(activity)) {
+            SupportManagerFragment.attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
+        } else {
+            HoneycombManagerFragment.attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);
+        }
+    }
+
+    private static boolean isSupportActivity(Activity activity) {
+        boolean isSupport = false;
+        for (Class<?> c = activity.getClass().getSuperclass();; c = c.getSuperclass()) {
+            if (c == null) {
+                throw new RuntimeException("Illegal activity type: " + activity.getClass());
+            }
+            String name = c.getName();
+            if (name.equals("android.support.v4.app.FragmentActivity")) {
+                isSupport = true;
+                break;
+            } else if (name.startsWith("com.actionbarsherlock.app")
+                    && (name.endsWith(".SherlockActivity") || name.endsWith(".SherlockListActivity") || name
+                            .endsWith(".SherlockPreferenceActivity"))) {
+                throw new RuntimeException("Please use SherlockFragmentActivity. Illegal activity: " + name);
+            } else if (name.equals("android.app.Activity")) {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+                    throw new RuntimeException(
+                            "Illegal activity without fragment support. Either use Android 3.0+ or android.support.v4.app.FragmentActivity.");
+                }
+                break;
+            }
+        }
+        return isSupport;
+    }
+
+    protected static void checkLogException(ThrowableFailureEvent event) {
+        if (factory.config.logExceptions) {
+            String tag = factory.config.tagForLoggingExceptions;
+            if (tag == null) {
+                tag = EventBus.TAG;
+            }
+            Log.i(tag, "Error dialog manager received exception", event.throwable);
+        }
+    }
+
+    private static boolean isInExecutionScope(Object executionScope, ThrowableFailureEvent event) {
+        if (event != null) {
+            Object eventExecutionScope = event.getExecutionScope();
+            if (eventExecutionScope != null && !eventExecutionScope.equals(executionScope)) {
+                // Event not in our scope, do nothing
+                return false;
+            }
+        }
+        return true;
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ExceptionToResourceMapping.java b/EventBus/src/main/java/de/greenrobot/event/util/ExceptionToResourceMapping.java
new file mode 100644
index 00000000..d3286175
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ExceptionToResourceMapping.java
@@ -0,0 +1,73 @@
+package de.greenrobot.event.util;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import android.util.Log;
+import de.greenrobot.event.EventBus;
+
+
+/**
+ * Maps throwables to texts for error dialogs. Use Config to configure the mapping.
+ * 
+ * @author Markus
+ */
+public class ExceptionToResourceMapping {
+
+    public final Map<Class<? extends Throwable>, Integer> throwableToMsgIdMap;
+
+    public ExceptionToResourceMapping() {
+        throwableToMsgIdMap = new HashMap<Class<? extends Throwable>, Integer>();
+    }
+
+    /** Looks at the exception and its causes trying to find an ID. */
+    public Integer mapThrowable(final Throwable throwable) {
+        Throwable throwableToCheck = throwable;
+        int depthToGo = 20;
+
+        while (true) {
+            Integer resId = mapThrowableFlat(throwableToCheck);
+            if (resId != null) {
+                return resId;
+            } else {
+                throwableToCheck = throwableToCheck.getCause();
+                depthToGo--;
+                if (depthToGo <= 0 || throwableToCheck == throwable || throwableToCheck == null) {
+                    Log.d(EventBus.TAG, "No specific message ressource ID found for " + throwable);
+                    // return config.defaultErrorMsgId;
+                    return null;
+                }
+            }
+        }
+
+    }
+
+    /** Mapping without checking the cause (done in mapThrowable). */
+    protected Integer mapThrowableFlat(Throwable throwable) {
+        Class<? extends Throwable> throwableClass = throwable.getClass();
+        Integer resId = throwableToMsgIdMap.get(throwableClass);
+        if (resId == null) {
+            Class<? extends Throwable> closestClass = null;
+            Set<Entry<Class<? extends Throwable>, Integer>> mappings = throwableToMsgIdMap.entrySet();
+            for (Entry<Class<? extends Throwable>, Integer> mapping : mappings) {
+                Class<? extends Throwable> candidate = mapping.getKey();
+                if (candidate.isAssignableFrom(throwableClass)) {
+                    if (closestClass == null || closestClass.isAssignableFrom(candidate)) {
+                        closestClass = candidate;
+                        resId = mapping.getValue();
+                    }
+                }
+            }
+
+        }
+        return resId;
+    }
+
+    public ExceptionToResourceMapping addMapping(Class<? extends Throwable> clazz, int msgId) {
+        throwableToMsgIdMap.put(clazz, msgId);
+        return this;
+    }
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/HasExecutionScope.java b/EventBus/src/main/java/de/greenrobot/event/util/HasExecutionScope.java
new file mode 100644
index 00000000..d759d2c2
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/HasExecutionScope.java
@@ -0,0 +1,8 @@
+package de.greenrobot.event.util;
+
+public interface HasExecutionScope {
+    Object getExecutionScope();
+
+    void setExecutionScope(Object executionScope);
+
+}
diff --git a/EventBus/src/main/java/de/greenrobot/event/util/ThrowableFailureEvent.java b/EventBus/src/main/java/de/greenrobot/event/util/ThrowableFailureEvent.java
new file mode 100644
index 00000000..7c6c07fa
--- /dev/null
+++ b/EventBus/src/main/java/de/greenrobot/event/util/ThrowableFailureEvent.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.util;
+
+/**
+ * A generic failure event, which can be used by apps to propagate thrown exceptions. Also used in conjunction with
+ * {@link ErrorDialogManager}.
+ */
+public class ThrowableFailureEvent implements HasExecutionScope {
+    protected final Throwable throwable;
+    protected final boolean suppressErrorUi;
+    private Object executionContext;
+
+    public ThrowableFailureEvent(Throwable throwable) {
+        this.throwable = throwable;
+        suppressErrorUi = false;
+    }
+
+    /**
+     * @param suppressErrorUi
+     *            true indicates to the receiver that no error UI (e.g. dialog) should now displayed.
+     */
+    public ThrowableFailureEvent(Throwable throwable, boolean suppressErrorUi) {
+        this.throwable = throwable;
+        this.suppressErrorUi = suppressErrorUi;
+    }
+
+    public Throwable getThrowable() {
+        return throwable;
+    }
+
+    public boolean isSuppressErrorUi() {
+        return suppressErrorUi;
+    }
+
+    public Object getExecutionScope() {
+        return executionContext;
+    }
+
+    public void setExecutionScope(Object executionContext) {
+        this.executionContext = executionContext;
+    }
+    
+}
diff --git a/EventBus/src/main/res/values/strings.xml b/EventBus/src/main/res/values/strings.xml
new file mode 100644
index 00000000..85420055
--- /dev/null
+++ b/EventBus/src/main/res/values/strings.xml
@@ -0,0 +1,2 @@
+<resources>
+</resources>
diff --git a/EventBusPerformance/src/main/AndroidManifest.xml b/EventBusPerformance/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..beb7f7ca
--- /dev/null
+++ b/EventBusPerformance/src/main/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.eventperf"
+    android:versionCode="3"
+    android:versionName="1.1.0" >
+
+    <uses-sdk
+        android:minSdkVersion="7"
+        android:targetSdkVersion="17" />
+
+    <uses-feature
+        android:name="android.hardware.touchscreen"
+        android:required="false" />
+
+    <application
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name" >
+        <activity
+            android:name=".TestSetupActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+            android:name=".TestRunnerActivity"
+            android:label="@string/app_name"
+            android:process="de.greenrobot.eventperf.benchmark" >
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/Test.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/Test.java
new file mode 100644
index 00000000..8c52d9aa
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/Test.java
@@ -0,0 +1,56 @@
+package de.greenrobot.eventperf;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+import android.content.Context;
+
+public abstract class Test {
+    protected final Context context;
+    protected final TestParams params;
+    protected AtomicLong eventsReceivedCount = new AtomicLong();
+    protected long primaryResultMicros;
+    protected int primaryResultCount;
+    protected String otherTestResults;
+
+    protected boolean canceled;
+
+    public Test(Context context, TestParams params) {
+        this.context = context;
+        this.params = params;
+    }
+
+    public void cancel() {
+        canceled = true;
+    }
+
+    /** prepares the test, all things which are not relevant for test results */
+    public abstract void prepareTest();
+
+    public abstract void runTest();
+
+    /** returns the display name of the test. e.g. EventBus */
+    public abstract String getDisplayName();
+
+    protected void waitForReceivedEventCount(int expectedEventCount) {
+        while (eventsReceivedCount.get() < expectedEventCount) {
+            try {
+                Thread.sleep(1);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public long getPrimaryResultMicros() {
+        return primaryResultMicros;
+    }
+
+    public double getPrimaryResultRate() {
+        return primaryResultCount / (primaryResultMicros / 1000000d);
+    }
+
+    public String getOtherTestResults() {
+        return otherTestResults;
+    }
+
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestEvent.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestEvent.java
new file mode 100644
index 00000000..b90be773
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestEvent.java
@@ -0,0 +1,6 @@
+package de.greenrobot.eventperf;
+
+/** Used by otto and EventBus */
+public class TestEvent {
+
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestFinishedEvent.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestFinishedEvent.java
new file mode 100644
index 00000000..b3a6264c
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestFinishedEvent.java
@@ -0,0 +1,12 @@
+package de.greenrobot.eventperf;
+
+public class TestFinishedEvent {
+
+    public final Test test;
+    public final boolean isLastEvent;
+
+    public TestFinishedEvent(Test test, boolean isLastEvent) {
+        this.test = test;
+        this.isLastEvent = isLastEvent;
+    }
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestParams.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestParams.java
new file mode 100644
index 00000000..1cebfec2
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestParams.java
@@ -0,0 +1,75 @@
+package de.greenrobot.eventperf;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+
+import de.greenrobot.event.ThreadMode;
+
+public class TestParams implements Serializable {
+    private static final long serialVersionUID = -2739435088947740809L;
+
+    private int eventCount;
+    private int subscriberCount;
+    private int publisherCount;
+    private ThreadMode threadMode;
+    private boolean eventInheritance;
+    private int testNumber;
+    private ArrayList<Class<? extends Test>> testClasses;
+
+    public int getEventCount() {
+        return eventCount;
+    }
+
+    public void setEventCount(int iterations) {
+        this.eventCount = iterations;
+    }
+
+    public int getSubscriberCount() {
+        return subscriberCount;
+    }
+
+    public void setSubscriberCount(int subscriberCount) {
+        this.subscriberCount = subscriberCount;
+    }
+
+    public int getPublisherCount() {
+        return publisherCount;
+    }
+
+    public void setPublisherCount(int publisherCount) {
+        this.publisherCount = publisherCount;
+    }
+
+    public ThreadMode getThreadMode() {
+        return threadMode;
+    }
+
+    public void setThreadMode(ThreadMode threadMode) {
+        this.threadMode = threadMode;
+    }
+
+    public boolean isEventInheritance() {
+        return eventInheritance;
+    }
+
+    public void setEventInheritance(boolean eventInheritance) {
+        this.eventInheritance = eventInheritance;
+    }
+
+    public ArrayList<Class<? extends Test>> getTestClasses() {
+        return testClasses;
+    }
+
+    public void setTestClasses(ArrayList<Class<? extends Test>> testClasses) {
+        this.testClasses = testClasses;
+    }
+
+    public int getTestNumber() {
+        return testNumber;
+    }
+
+    public void setTestNumber(int testNumber) {
+        this.testNumber = testNumber;
+    }
+
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunner.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunner.java
new file mode 100644
index 00000000..e593c8e3
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunner.java
@@ -0,0 +1,69 @@
+package de.greenrobot.eventperf;
+
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+
+import android.content.Context;
+import de.greenrobot.event.EventBus;
+
+/**
+ * This thread initialize all selected tests and runs them through. Also the thread skips the tests, when it is canceled
+ */
+public class TestRunner extends Thread {
+    private List<Test> tests;
+    private volatile boolean canceled;
+    private final EventBus controlBus;
+
+    public TestRunner(Context context, TestParams testParams, EventBus controlBus) {
+        this.controlBus = controlBus;
+        tests = new ArrayList<Test>();
+        for (Class<? extends Test> testClazz : testParams.getTestClasses()) {
+            try {
+                Constructor<?>[] constructors = testClazz.getConstructors();
+                Constructor<? extends Test> constructor = testClazz.getConstructor(Context.class, TestParams.class);
+                Test test = constructor.newInstance(context, testParams);
+                tests.add(test);
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public void run() {
+
+        int idx = 0;
+        for (Test test : tests) {
+            // Clean up and let the main thread calm down
+            System.gc();
+            try {
+                Thread.sleep(300);
+                System.gc();
+                Thread.sleep(300);
+            } catch (InterruptedException e) {
+            }
+
+            test.prepareTest();
+            if (!canceled) {
+                test.runTest();
+            }
+            if (!canceled) {
+                boolean isLastEvent = idx == tests.size() - 1;
+                controlBus.post(new TestFinishedEvent(test, isLastEvent));
+            }
+            idx++;
+        }
+
+    }
+
+    public List<Test> getTests() {
+        return tests;
+    }
+
+    public void cancel() {
+        canceled = true;
+        for (Test test : tests) {
+            test.cancel();
+        }
+    }
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunnerActivity.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunnerActivity.java
new file mode 100644
index 00000000..127d528b
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestRunnerActivity.java
@@ -0,0 +1,83 @@
+package de.greenrobot.eventperf;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.os.Process;
+import android.text.Html;
+import android.view.View;
+import android.widget.TextView;
+import de.greenrobot.event.EventBus;
+
+/**
+ * This activity gets the information from the activity before, sets up the test and starts the test. After it watchs
+ * after that, if a test is finished. When a test is finished, the activity appends it on the textview analyse. If all
+ * test are finished, it cancels the timer.
+ */
+public class TestRunnerActivity extends Activity {
+
+    private TestRunner testRunner;
+    private EventBus controlBus;
+    private TextView textViewResult;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_runtests);
+        textViewResult = (TextView) findViewById(R.id.textViewResult);
+        controlBus = new EventBus();
+        controlBus.register(this);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        if (testRunner == null) {
+            TestParams testParams = (TestParams) getIntent().getSerializableExtra("params");
+            testRunner = new TestRunner(getApplicationContext(), testParams, controlBus);
+
+            if (testParams.getTestNumber() == 1) {
+                textViewResult.append("Events: " + testParams.getEventCount() + "\n");
+            }
+            textViewResult.append("Subscribers: " + testParams.getSubscriberCount() + "\n\n");
+            testRunner.start();
+        }
+    }
+
+    public void onEventMainThread(TestFinishedEvent event) {
+        Test test = event.test;
+        String text = "<b>" + test.getDisplayName() + "</b><br/>" + //
+                test.getPrimaryResultMicros() + " micro seconds<br/>" + //
+                ((int) test.getPrimaryResultRate()) + "/s<br/>";
+        if (test.getOtherTestResults() != null) {
+            text += test.getOtherTestResults();
+        }
+        text += "<br/>----------------<br/>";
+        textViewResult.append(Html.fromHtml(text));
+        if (event.isLastEvent) {
+            findViewById(R.id.buttonCancel).setVisibility(View.GONE);
+            findViewById(R.id.textViewTestRunning).setVisibility(View.GONE);
+            findViewById(R.id.buttonKillProcess).setVisibility(View.VISIBLE);
+        }
+    }
+
+    public void onClickCancel(View view) {
+        // Cancel asap
+        if (testRunner != null) {
+            testRunner.cancel();
+            testRunner = null;
+        }
+        finish();
+    }
+
+    public void onClickKillProcess(View view) {
+        Process.killProcess(Process.myPid());
+    }
+
+    public void onDestroy() {
+        if (testRunner != null) {
+            testRunner.cancel();
+        }
+        controlBus.unregister(this);
+        super.onDestroy();
+    }
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestSetupActivity.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestSetupActivity.java
new file mode 100644
index 00000000..2b018b41
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/TestSetupActivity.java
@@ -0,0 +1,104 @@
+package de.greenrobot.eventperf;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.CheckBox;
+import android.widget.EditText;
+import android.widget.Spinner;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.eventperf.testsubject.PerfTestEventBus;
+import de.greenrobot.eventperf.testsubject.PerfTestOtto;
+
+import java.util.ArrayList;
+
+public class TestSetupActivity extends Activity {
+
+    @SuppressWarnings("rawtypes")
+    static final Class[] TEST_CLASSES_EVENTBUS = {PerfTestEventBus.Post.class,//
+            PerfTestEventBus.RegisterOneByOne.class,//
+            PerfTestEventBus.RegisterAll.class, //
+            PerfTestEventBus.RegisterFirstTime.class};
+
+    static final Class[] TEST_CLASSES_OTTO = {PerfTestOtto.Post.class,//
+            PerfTestOtto.RegisterOneByOne.class,//
+            PerfTestOtto.RegisterAll.class, //
+            PerfTestOtto.RegisterFirstTime.class};
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_setuptests);
+
+        Spinner spinnerRun = (Spinner) findViewById(R.id.spinnerTestToRun);
+        spinnerRun.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+
+            public void onItemSelected(AdapterView<?> adapter, View v, int pos, long lng) {
+                int eventsVisibility = pos == 0 ? View.VISIBLE : View.GONE;
+                findViewById(R.id.relativeLayoutForEvents).setVisibility(eventsVisibility);
+                findViewById(R.id.spinnerThread).setVisibility(eventsVisibility);
+            }
+
+            public void onNothingSelected(AdapterView<?> arg0) {
+            }
+        });
+    }
+
+    public void checkEventBus(View v) {
+        Spinner spinnerThread = (Spinner) findViewById(R.id.spinnerThread);
+        CheckBox checkBoxEventBus = (CheckBox) findViewById(R.id.checkBoxEventBus);
+        int visibility = checkBoxEventBus.isChecked() ? View.VISIBLE : View.GONE;
+        spinnerThread.setVisibility(visibility);
+    }
+
+    public void startClick(View v) {
+        TestParams params = new TestParams();
+        Spinner spinnerThread = (Spinner) findViewById(R.id.spinnerThread);
+        String threadModeStr = spinnerThread.getSelectedItem().toString();
+        ThreadMode threadMode = ThreadMode.valueOf(threadModeStr);
+        params.setThreadMode(threadMode);
+
+        params.setEventInheritance(((CheckBox) findViewById(R.id.checkBoxEventBusEventHierarchy)).isChecked());
+
+        EditText editTextEvent = (EditText) findViewById(R.id.editTextEvent);
+        params.setEventCount(Integer.parseInt(editTextEvent.getText().toString()));
+
+        EditText editTextSubscriber = (EditText) findViewById(R.id.editTextSubscribe);
+        params.setSubscriberCount(Integer.parseInt(editTextSubscriber.getText().toString()));
+
+        Spinner spinnerTestToRun = (Spinner) findViewById(R.id.spinnerTestToRun);
+        int testPos = spinnerTestToRun.getSelectedItemPosition();
+        params.setTestNumber(testPos + 1);
+        ArrayList<Class<? extends Test>> testClasses = initTestClasses(testPos);
+        params.setTestClasses(testClasses);
+
+        Intent intent = new Intent();
+        intent.setClass(this, TestRunnerActivity.class);
+        intent.putExtra("params", params);
+        startActivity(intent);
+    }
+
+    @SuppressWarnings("unchecked")
+    private ArrayList<Class<? extends Test>> initTestClasses(int testPos) {
+        ArrayList<Class<? extends Test>> testClasses = new ArrayList<Class<? extends Test>>();
+        // the attributes are putted in the intent (eventbus, otto, broadcast, local broadcast)
+        final CheckBox checkBoxEventBus = (CheckBox) findViewById(R.id.checkBoxEventBus);
+        final CheckBox checkBoxOtto = (CheckBox) findViewById(R.id.checkBoxOtto);
+        final CheckBox checkBoxBroadcast = (CheckBox) findViewById(R.id.checkBoxBroadcast);
+        final CheckBox checkBoxLocalBroadcast = (CheckBox) findViewById(R.id.checkBoxLocalBroadcast);
+        if (checkBoxEventBus.isChecked()) {
+            testClasses.add(TEST_CLASSES_EVENTBUS[testPos]);
+        }
+        if (checkBoxOtto.isChecked()) {
+            testClasses.add(TEST_CLASSES_OTTO[testPos]);
+        }
+        if (checkBoxBroadcast.isChecked()) {
+        }
+        if (checkBoxLocalBroadcast.isChecked()) {
+        }
+
+        return testClasses;
+    }
+}
\ No newline at end of file
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
new file mode 100644
index 00000000..16920dc3
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
@@ -0,0 +1,282 @@
+package de.greenrobot.eventperf.testsubject;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+
+import android.content.Context;
+import de.greenrobot.event.EventBus;
+import de.greenrobot.eventperf.Test;
+import de.greenrobot.eventperf.TestEvent;
+import de.greenrobot.eventperf.TestParams;
+
+public abstract class PerfTestEventBus extends Test {
+
+    private final EventBus eventBus;
+    private final ArrayList<Object> subscribers;
+    private final Class<?> subscriberClass;
+    private final int eventCount;
+    private final int expectedEventCount;
+
+    public PerfTestEventBus(Context context, TestParams params) {
+        super(context, params);
+        eventBus = EventBus.builder().eventInheritance(params.isEventInheritance()).build();
+        subscribers = new ArrayList<Object>();
+        eventCount = params.getEventCount();
+        expectedEventCount = eventCount * params.getSubscriberCount();
+        subscriberClass = getSubscriberClassForThreadMode();
+    }
+
+    @Override
+    public void prepareTest() {
+        try {
+            Constructor<?> constructor = subscriberClass.getConstructor(PerfTestEventBus.class);
+            for (int i = 0; i < params.getSubscriberCount(); i++) {
+                Object subscriber = constructor.newInstance(this);
+                subscribers.add(subscriber);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Class<?> getSubscriberClassForThreadMode() {
+        switch (params.getThreadMode()) {
+            case MainThread:
+                return SubscribeClassEventBusMain.class;
+            case BackgroundThread:
+                return SubscribeClassEventBusBackground.class;
+            case Async:
+                return SubscriberClassEventBusAsync.class;
+            case PostThread:
+                return SubscribeClassEventBusDefault.class;
+            default:
+                throw new RuntimeException("Unknown: " + params.getThreadMode());
+        }
+    }
+
+    public static class Post extends PerfTestEventBus {
+        public Post(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        @Override
+        public void prepareTest() {
+            super.prepareTest();
+            super.registerSubscribers();
+        }
+
+        public void runTest() {
+            TestEvent event = new TestEvent();
+            long timeStart = System.nanoTime();
+            for (int i = 0; i < super.eventCount; i++) {
+                super.eventBus.post(event);
+                if (canceled) {
+                    break;
+                }
+            }
+            long timeAfterPosting = System.nanoTime();
+            waitForReceivedEventCount(super.expectedEventCount);
+            long timeAllReceived = System.nanoTime();
+
+            primaryResultMicros = (timeAfterPosting - timeStart) / 1000;
+            primaryResultCount = super.expectedEventCount;
+            long deliveredMicros = (timeAllReceived - timeStart) / 1000;
+            int deliveryRate = (int) (primaryResultCount / (deliveredMicros / 1000000d));
+            otherTestResults = "Post and delivery time: " + deliveredMicros + " micros<br/>" + //
+                    "Post and delivery rate: " + deliveryRate + "/s";
+        }
+
+        @Override
+        public String getDisplayName() {
+            String inheritance = params.isEventInheritance() ? ", event inheritance" : ", no event inheritance";
+            return "EventBus Post Events, " + params.getThreadMode() + inheritance;
+        }
+    }
+
+    public static class RegisterAll extends PerfTestEventBus {
+        public RegisterAll(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        public void runTest() {
+            super.registerUnregisterOneSubscribers();
+            long timeNanos = super.registerSubscribers();
+            primaryResultMicros = timeNanos / 1000;
+            primaryResultCount = params.getSubscriberCount();
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "EventBus Register, no unregister";
+        }
+    }
+
+    public static class RegisterOneByOne extends PerfTestEventBus {
+        protected Method clearCachesMethod;
+
+        public RegisterOneByOne(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        public void runTest() {
+            long time = 0;
+            if (clearCachesMethod == null) {
+                // Skip first registration unless just the first registration is tested
+                super.registerUnregisterOneSubscribers();
+            }
+            for (Object subscriber : super.subscribers) {
+                if (clearCachesMethod != null) {
+                    try {
+                        clearCachesMethod.invoke(null);
+                    } catch (Exception e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+                long beforeRegister = System.nanoTime();
+                super.eventBus.register(subscriber);
+                long timeRegister = System.nanoTime() - beforeRegister;
+                time += timeRegister;
+                super.eventBus.unregister(subscriber);
+                if (canceled) {
+                    return;
+                }
+            }
+
+            primaryResultMicros = time / 1000;
+            primaryResultCount = params.getSubscriberCount();
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "EventBus Register";
+        }
+    }
+
+    public static class RegisterFirstTime extends RegisterOneByOne {
+
+        public RegisterFirstTime(Context context, TestParams params) {
+            super(context, params);
+            try {
+                Class<?> clazz = Class.forName("de.greenrobot.event.SubscriberMethodFinder");
+                clearCachesMethod = clazz.getDeclaredMethod("clearCaches");
+                clearCachesMethod.setAccessible(true);
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "EventBus Register, first time";
+        }
+
+    }
+
+    public class SubscribeClassEventBusDefault {
+        public void onEvent(TestEvent event) {
+            eventsReceivedCount.incrementAndGet();
+        }
+
+        public void dummy() {
+        }
+
+        public void dummy2() {
+        }
+
+        public void dummy3() {
+        }
+
+        public void dummy4() {
+        }
+
+        public void dummy5() {
+        }
+    }
+
+    public class SubscribeClassEventBusMain {
+        public void onEventMainThread(TestEvent event) {
+            eventsReceivedCount.incrementAndGet();
+        }
+
+        public void dummy() {
+        }
+
+        public void dummy2() {
+        }
+
+        public void dummy3() {
+        }
+
+        public void dummy4() {
+        }
+
+        public void dummy5() {
+        }
+    }
+
+    public class SubscribeClassEventBusBackground {
+        public void onEventBackgroundThread(TestEvent event) {
+            eventsReceivedCount.incrementAndGet();
+        }
+
+        public void dummy() {
+        }
+
+        public void dummy2() {
+        }
+
+        public void dummy3() {
+        }
+
+        public void dummy4() {
+        }
+
+        public void dummy5() {
+        }
+    }
+
+    public class SubscriberClassEventBusAsync {
+        public void onEventAsync(TestEvent event) {
+            eventsReceivedCount.incrementAndGet();
+        }
+
+        public void dummy() {
+        }
+
+        public void dummy2() {
+        }
+
+        public void dummy3() {
+        }
+
+        public void dummy4() {
+        }
+
+        public void dummy5() {
+        }
+    }
+
+    private long registerSubscribers() {
+        long time = 0;
+        for (Object subscriber : subscribers) {
+            long timeStart = System.nanoTime();
+            eventBus.register(subscriber);
+            long timeEnd = System.nanoTime();
+            time += timeEnd - timeStart;
+            if (canceled) {
+                return 0;
+            }
+        }
+        return time;
+    }
+
+    private void registerUnregisterOneSubscribers() {
+        if (!subscribers.isEmpty()) {
+            Object subscriber = subscribers.get(0);
+            eventBus.register(subscriber);
+            eventBus.unregister(subscriber);
+        }
+    }
+
+}
diff --git a/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestOtto.java b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestOtto.java
new file mode 100644
index 00000000..8e68adde
--- /dev/null
+++ b/EventBusPerformance/src/main/java/de/greenrobot/eventperf/testsubject/PerfTestOtto.java
@@ -0,0 +1,213 @@
+package de.greenrobot.eventperf.testsubject;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Looper;
+
+import com.squareup.otto.Bus;
+import com.squareup.otto.Subscribe;
+import com.squareup.otto.ThreadEnforcer;
+
+import de.greenrobot.eventperf.Test;
+import de.greenrobot.eventperf.TestEvent;
+import de.greenrobot.eventperf.TestParams;
+
+public abstract class PerfTestOtto extends Test {
+
+    private final Bus eventBus;
+    private final ArrayList<Object> subscribers;
+    private final Class<?> subscriberClass;
+    private final int eventCount;
+    private final int expectedEventCount;
+
+    public PerfTestOtto(Context context, TestParams params) {
+        super(context, params);
+        eventBus = new Bus(ThreadEnforcer.ANY);
+        subscribers = new ArrayList<Object>();
+        eventCount = params.getEventCount();
+        expectedEventCount = eventCount * params.getSubscriberCount();
+        subscriberClass = Subscriber.class;
+    }
+
+    @Override
+    public void prepareTest() {
+        Looper.prepare();
+
+        try {
+            Constructor<?> constructor = subscriberClass.getConstructor(PerfTestOtto.class);
+            for (int i = 0; i < params.getSubscriberCount(); i++) {
+                Object subscriber = constructor.newInstance(this);
+                subscribers.add(subscriber);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static class Post extends PerfTestOtto {
+        public Post(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        @Override
+        public void prepareTest() {
+            super.prepareTest();
+            super.registerSubscribers();
+        }
+
+        public void runTest() {
+            TestEvent event = new TestEvent();
+            long timeStart = System.nanoTime();
+            for (int i = 0; i < super.eventCount; i++) {
+                super.eventBus.post(event);
+                if (canceled) {
+                    break;
+                }
+            }
+            long timeAfterPosting = System.nanoTime();
+            waitForReceivedEventCount(super.expectedEventCount);
+
+            primaryResultMicros = (timeAfterPosting - timeStart) / 1000;
+            primaryResultCount = super.expectedEventCount;
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "Otto Post Events";
+        }
+    }
+
+    public static class RegisterAll extends PerfTestOtto {
+        public RegisterAll(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        public void runTest() {
+            super.registerUnregisterOneSubscribers();
+            long timeNanos = super.registerSubscribers();
+            primaryResultMicros = timeNanos / 1000;
+            primaryResultCount = params.getSubscriberCount();
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "Otto Register, no unregister";
+        }
+    }
+
+    public static class RegisterOneByOne extends PerfTestOtto {
+        protected Field cacheField;
+
+        public RegisterOneByOne(Context context, TestParams params) {
+            super(context, params);
+        }
+
+        @SuppressWarnings("rawtypes")
+        public void runTest() {
+            long time = 0;
+            if (cacheField == null) {
+                // Skip first registration unless just the first registration is tested
+                super.registerUnregisterOneSubscribers();
+            }
+            for (Object subscriber : super.subscribers) {
+                if (cacheField != null) {
+                    try {
+                        cacheField.set(null, new HashMap());
+                    } catch (Exception e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+                long beforeRegister = System.nanoTime();
+                super.eventBus.register(subscriber);
+                long timeRegister = System.nanoTime() - beforeRegister;
+                time += timeRegister;
+                super.eventBus.unregister(subscriber);
+                if (canceled) {
+                    return;
+                }
+            }
+
+            primaryResultMicros = time / 1000;
+            primaryResultCount = params.getSubscriberCount();
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "Otto Register";
+        }
+    }
+
+    public static class RegisterFirstTime extends RegisterOneByOne {
+
+        public RegisterFirstTime(Context context, TestParams params) {
+            super(context, params);
+            try {
+                Class<?> clazz = Class.forName("com.squareup.otto.AnnotatedHandlerFinder");
+                cacheField = clazz.getDeclaredField("SUBSCRIBERS_CACHE");
+                cacheField.setAccessible(true);
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public String getDisplayName() {
+            return "Otto Register, first time";
+        }
+
+    }
+
+    public class Subscriber extends Activity {
+        public Subscriber() {
+        }
+
+        @Subscribe
+        public void onEvent(TestEvent event) {
+            eventsReceivedCount.incrementAndGet();
+        }
+
+        public void dummy() {
+        }
+
+        public void dummy2() {
+        }
+
+        public void dummy3() {
+        }
+
+        public void dummy4() {
+        }
+
+        public void dummy5() {
+        }
+
+    }
+
+    private long registerSubscribers() {
+        long time = 0;
+        for (Object subscriber : subscribers) {
+            long timeStart = System.nanoTime();
+            eventBus.register(subscriber);
+            long timeEnd = System.nanoTime();
+            time += timeEnd - timeStart;
+            if (canceled) {
+                return 0;
+            }
+        }
+        return time;
+    }
+
+    private void registerUnregisterOneSubscribers() {
+        if (!subscribers.isEmpty()) {
+            Object subscriber = subscribers.get(0);
+            eventBus.register(subscriber);
+            eventBus.unregister(subscriber);
+        }
+    }
+
+}
diff --git a/EventBusPerformance/src/main/res/drawable-hdpi/ic_launcher.png b/EventBusPerformance/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 00000000..96a442e5
Binary files /dev/null and b/EventBusPerformance/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/EventBusPerformance/src/main/res/drawable-ldpi/ic_launcher.png b/EventBusPerformance/src/main/res/drawable-ldpi/ic_launcher.png
new file mode 100644
index 00000000..99238729
Binary files /dev/null and b/EventBusPerformance/src/main/res/drawable-ldpi/ic_launcher.png differ
diff --git a/EventBusPerformance/src/main/res/drawable-mdpi/ic_launcher.png b/EventBusPerformance/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 00000000..359047df
Binary files /dev/null and b/EventBusPerformance/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/EventBusPerformance/src/main/res/drawable-xhdpi/ic_launcher.png b/EventBusPerformance/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..71c6d760
Binary files /dev/null and b/EventBusPerformance/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/EventBusPerformance/src/main/res/layout/activity_runtests.xml b/EventBusPerformance/src/main/res/layout/activity_runtests.xml
new file mode 100644
index 00000000..13656a86
--- /dev/null
+++ b/EventBusPerformance/src/main/res/layout/activity_runtests.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <TextView
+        android:id="@+id/textViewTestRunning"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:background="#88333333"
+        android:gravity="center"
+        android:padding="15dp"
+        android:text="@string/testIsRunning"
+        android:textColor="#ffffff"
+        android:textSize="30sp"
+        android:textStyle="bold" />
+
+    <ScrollView
+        android:id="@+id/scrollViewResults"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:layout_above="@+id/buttonCancel"
+        android:fillViewport="true" >
+
+        <TextView
+            android:id="@+id/textViewResult"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:textSize="16sp" />
+    </ScrollView>
+
+    <Button
+        android:id="@+id/buttonCancel"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_above="@+id/buttonKillProcess"
+        android:layout_alignWithParentIfMissing="true"
+        android:layout_margin="16dp"
+        android:onClick="onClickCancel"
+        android:text="@string/buttonCancel" />
+
+    <Button
+        android:id="@+id/buttonKillProcess"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:layout_margin="16dp"
+        android:onClick="onClickKillProcess"
+        android:text="@string/buttonKillProcess"
+        android:visibility="gone" />
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/EventBusPerformance/src/main/res/layout/activity_setuptests.xml b/EventBusPerformance/src/main/res/layout/activity_setuptests.xml
new file mode 100644
index 00000000..da77afe6
--- /dev/null
+++ b/EventBusPerformance/src/main/res/layout/activity_setuptests.xml
@@ -0,0 +1,137 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/LinearLayout1"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:focusableInTouchMode="true"
+    android:orientation="vertical" >
+
+    <Spinner
+        android:id="@+id/spinnerTestToRun"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="14dp"
+        android:entries="@array/spinnerTestsToRun" />
+
+    <ScrollView
+        android:id="@+id/scrollViewSettings"
+        android:layout_width="fill_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1" >
+
+        <LinearLayout
+            android:id="@+id/LinearLayout2"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:paddingLeft="16dp"
+            android:paddingRight="16dp" >
+
+            <CheckBox
+                android:id="@+id/checkBoxEventBus"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:onClick="checkEventBus"
+                android:text="@string/test_eventBus" />
+
+            <Spinner
+                android:id="@+id/spinnerThread"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="48dp"
+                android:entries="@array/spinnerThreadModes" />
+
+            <CheckBox
+                android:id="@+id/checkBoxEventBusEventHierarchy"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:onClick="checkEventBus"
+                android:layout_marginLeft="48dp"
+                android:text="@string/test_eventBusEventHierarchy" />
+
+            <CheckBox
+                android:id="@+id/checkBoxOtto"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:checked="true"
+                android:layout_marginTop="16dp"
+                android:text="@string/test_otto" />
+
+
+            <CheckBox
+                android:id="@+id/checkBoxBroadcast"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/test_broadcast"
+                android:visibility="gone" />
+
+
+            <CheckBox
+                android:id="@+id/checkBoxLocalBroadcast"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="32dp"
+                android:text="@string/test_localBroadcast"
+                android:visibility="gone" />
+
+            <RelativeLayout
+                android:id="@+id/relativeLayoutForEvents"
+                android:layout_width="fill_parent"
+                android:layout_height="fill_parent"
+                android:layout_marginBottom="18dp" >
+
+                <EditText
+                    android:id="@+id/editTextEvent"
+                    android:layout_width="90dp"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentRight="true"
+                    android:inputType="number"
+                    android:text="1000" />
+
+                <TextView
+                    android:id="@+id/eventView"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignBaseline="@+id/editTextEvent"
+                    android:layout_alignParentLeft="true"
+                    android:layout_toLeftOf="@+id/editTextEvent"
+                    android:text="@string/eventViewText" />
+            </RelativeLayout>
+
+            <RelativeLayout
+                android:id="@+id/relativeLayoutForSubscribers"
+                android:layout_width="fill_parent"
+                android:layout_height="fill_parent"
+                android:layout_marginBottom="8dp" >
+
+                <EditText
+                    android:id="@+id/editTextSubscribe"
+                    android:layout_width="90dp"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentRight="true"
+                    android:inputType="number"
+                    android:text="1" />
+
+                <TextView
+                    android:id="@+id/subscribe"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignBaseline="@+id/editTextSubscribe"
+                    android:layout_alignParentLeft="true"
+                    android:layout_toLeftOf="@+id/editTextSubscribe"
+                    android:text="@string/subscriberViewText" />
+            </RelativeLayout>
+        </LinearLayout>
+    </ScrollView>
+
+    <Button
+        android:id="@+id/buttonStart"
+        android:layout_width="fill_parent"
+        android:layout_height="50dp"
+        android:layout_margin="16dp"
+        android:onClick="startClick"
+        android:text="@string/buttonStartText" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/EventBusPerformance/src/main/res/values/strings.xml b/EventBusPerformance/src/main/res/values/strings.xml
new file mode 100644
index 00000000..bdb09805
--- /dev/null
+++ b/EventBusPerformance/src/main/res/values/strings.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Event Performance</string>
+    <string name="test_eventBus">EventBus</string>
+    <string name="test_eventBusEventHierarchy">Event Inheritance</string>
+    <string name="test_otto">OttoBus</string>
+    <string name="test_broadcast">Broadcast</string>
+    <string name="test_localBroadcast">Local Broadcast</string>
+    <string name="eventViewText">Events:</string>
+    <string name="subscriberViewText">Subscribers:</string>
+    <string name="buttonStartText">Start</string>
+
+    <string-array name="spinnerTestsToRun">
+        <item>Post Events</item>
+        <item>Register Subscribers</item>
+        <item>Register Subscribers, no unregister</item>
+        <item>Register Subscribers, 1. time</item>
+    </string-array>
+    <string-array name="spinnerThreadModes">
+        <item>PostThread</item>
+        <item>MainThread</item>
+        <item>BackgroundThread</item>
+        <item>Async</item>
+    </string-array>
+
+    <string name="testIsRunning">Test Is \nRunning!</string>
+    <string name="buttonCancel">Cancel</string>
+    <string name="buttonKillProcess">Kill Process</string>
+    
+</resources>
\ No newline at end of file
diff --git a/import-summary.txt b/import-summary.txt
new file mode 100644
index 00000000..05f33d49
--- /dev/null
+++ b/import-summary.txt
@@ -0,0 +1,46 @@
+ECLIPSE ANDROID PROJECT IMPORT SUMMARY
+======================================
+
+Manifest Merging:
+-----------------
+Your project uses libraries that provide manifests, and your Eclipse
+project did not explicitly turn on manifest merging. In Android Gradle
+projects, manifests are always merged (meaning that contents from your
+libraries' manifests will be merged into the app manifest. If you had
+manually copied contents from library manifests into your app manifest
+you may need to remove these for the app to build correctly.
+
+Replaced Jars with Dependencies:
+--------------------------------
+The importer recognized the following .jar files as third party
+libraries and replaced them with Gradle dependencies instead. This has
+the advantage that more explicit version information is known, and the
+libraries can be updated automatically. However, it is possible that
+the .jar file in your project was of an older version than the
+dependency we picked, which could render the project not compileable.
+You can disable the jar replacement in the import wizard and try again:
+
+android-support-v4.jar => com.android.support:support-v4:18.+
+
+Moved Files:
+------------
+Android Gradle projects use a different directory structure than ADT
+Eclipse projects. Here's how the projects were restructured:
+
+* AndroidManifest.xml => EventBusTest\src\main\AndroidManifest.xml
+* src\ => EventBusTest\src\main\java\
+
+Next Steps:
+-----------
+You can now build the project. The Gradle project needs network
+connectivity to download dependencies.
+
+Bugs:
+-----
+If for some reason your project does not build, and you determine that
+it is due to a bug or limitation of the Eclipse to Gradle importer,
+please file a bug at http://b.android.com with category
+Component-Tools.
+
+(This import summary is for your information only, and can be deleted
+after import once you are satisfied with the results.)
