diff --git a/EventBus/.classpath b/EventBus/.classpath
index 7bc01d9a..51769745 100644
--- a/EventBus/.classpath
+++ b/EventBus/.classpath
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 823cb0ec..9b5a892c 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package de.greenrobot.event;
 
 import android.util.Log;
@@ -30,14 +31,17 @@
     private static final String ON_EVENT_METHOD_NAME = "onEvent";
 
     /*
-     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
-     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
-     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
+     * In newer class files, compilers may add methods. Those are called bridge
+     * or synthetic methods. EventBus must ignore both. There modifiers are not
+     * public but defined in the Java class file format:
+     * http://docs.oracle.com/javase
+     * /specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
      */
     private static final int BRIDGE = 0x40;
     private static final int SYNTHETIC = 0x1000;
 
-    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
+    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE
+            | SYNTHETIC;
     private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
 
     private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
@@ -62,61 +66,20 @@
         }
         subscriberMethods = new ArrayList<SubscriberMethod>();
         Class<?> clazz = subscriberClass;
-        HashSet<String> eventTypesFound = new HashSet<String>();
-        StringBuilder methodKeyBuilder = new StringBuilder();
         while (clazz != null) {
-            String name = clazz.getName();
-            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
+            if (isSystemCalss(clazz.getName())) {
                 // Skip system classes, this just degrades performance
                 break;
             }
 
-            // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
-            Method[] methods = clazz.getDeclaredMethods();
-            for (Method method : methods) {
-                String methodName = method.getName();
-                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
-                    int modifiers = method.getModifiers();
-                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                        Class<?>[] parameterTypes = method.getParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
-                            ThreadMode threadMode;
-                            if (modifierString.length() == 0) {
-                                threadMode = ThreadMode.PostThread;
-                            } else if (modifierString.equals("MainThread")) {
-                                threadMode = ThreadMode.MainThread;
-                            } else if (modifierString.equals("BackgroundThread")) {
-                                threadMode = ThreadMode.BackgroundThread;
-                            } else if (modifierString.equals("Async")) {
-                                threadMode = ThreadMode.Async;
-                            } else {
-                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
-                                    continue;
-                                } else {
-                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
-                                }
-                            }
-                            Class<?> eventType = parameterTypes[0];
-                            methodKeyBuilder.setLength(0);
-                            methodKeyBuilder.append(methodName);
-                            methodKeyBuilder.append('>').append(eventType.getName());
-                            String methodKey = methodKeyBuilder.toString();
-                            if (eventTypesFound.add(methodKey)) {
-                                // Only add if not already found in a sub class
-                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
-                            }
-                        }
-                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
-                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
-                                + methodName);
-                    }
-                }
-            }
+            // Starting with EventBus 2.2 we enforced methods to be public
+            // (might change with annotations again)
+            findAllOnEventMethods(clazz, subscriberMethods);
             clazz = clazz.getSuperclass();
         }
         if (subscriberMethods.isEmpty()) {
-            throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
+            throw new EventBusException("Subscriber " + subscriberClass
+                    + " has no public methods called "
                     + ON_EVENT_METHOD_NAME);
         } else {
             synchronized (methodCache) {
@@ -126,6 +89,93 @@
         }
     }
 
+    private void findAllOnEventMethods(Class<?> clazz, List<SubscriberMethod> subscriberMethods) {
+        Method[] methods = clazz.getDeclaredMethods();
+        for (Method method : methods) {
+            String methodName = method.getName();
+            if (isTheMethodValid(method)) {
+                String modifierString = methodName.substring(ON_EVENT_METHOD_NAME
+                        .length());
+                ThreadMode threadMode = parseThreadMode(modifierString);
+                if (threadMode == null) {
+                    if (skipMethodVerificationForClasses.containsKey(clazz)) {
+                        continue;
+                    } else {
+                        throw new EventBusException(
+                                "Illegal onEvent method, check for typos: " + method);
+                    }
+                }
+
+                // construct a SubscriberMethod
+                SubscriberMethod newSubscriberMethod = constructScriberMethod(method,
+                        threadMode);
+                if (newSubscriberMethod != null) {
+                    subscriberMethods.add(newSubscriberMethod);
+                }
+            } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
+                Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): "
+                        + clazz + "."
+                        + methodName);
+            }
+        }
+    }
+
+    private ThreadMode parseThreadMode(String modifierString) {
+        ThreadMode threadMode = null;
+        if (modifierString.length() == 0) {
+            threadMode = ThreadMode.PostThread;
+        } else if (modifierString.equals("MainThread")) {
+            threadMode = ThreadMode.MainThread;
+        } else if (modifierString.equals("BackgroundThread")) {
+            threadMode = ThreadMode.BackgroundThread;
+        } else if (modifierString.equals("Async")) {
+            threadMode = ThreadMode.Async;
+        }
+        return threadMode;
+    }
+
+    private SubscriberMethod constructScriberMethod(Method method, ThreadMode threadMode) {
+        StringBuilder methodKeyBuilder = new StringBuilder();
+        HashSet<String> eventTypesFound = new HashSet<String>();
+
+        Class<?> eventType = method.getParameterTypes()[0];
+        methodKeyBuilder.setLength(0);
+        methodKeyBuilder.append(method.getName());
+        methodKeyBuilder.append('>').append(eventType.getName());
+        String methodKey = methodKeyBuilder.toString();
+        if (eventTypesFound.add(methodKey)) {
+            // Only add if not already found in a sub class
+            return new SubscriberMethod(method, threadMode,
+                    eventType);
+        }
+        return null;
+    }
+
+    /**
+     * a public method start with "onEvent" and just has only one param is
+     * valid.
+     * 
+     * @param method the target method
+     * @return
+     */
+    private boolean isTheMethodValid(Method method) {
+        return method.getName().startsWith(ON_EVENT_METHOD_NAME)
+                && isPublicMethod(method.getModifiers())
+                && isOnlyOneParam(method);
+    }
+
+    private boolean isPublicMethod(int modifiers) {
+        return (modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0;
+    }
+
+    private boolean isOnlyOneParam(Method method) {
+        return method.getParameterTypes().length == 1;
+    }
+
+    private boolean isSystemCalss(String name) {
+        return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
+    }
+
     static void clearCaches() {
         synchronized (methodCache) {
             methodCache.clear();
diff --git a/EventBusPerformance/.classpath b/EventBusPerformance/.classpath
index 7bc01d9a..51769745 100644
--- a/EventBusPerformance/.classpath
+++ b/EventBusPerformance/.classpath
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java b/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
index 1cebfec2..b4f6f08b 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/TestParams.java
@@ -3,8 +3,6 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 
-import de.greenrobot.event.ThreadMode;
-
 public class TestParams implements Serializable {
     private static final long serialVersionUID = -2739435088947740809L;
 
diff --git a/EventBusTest/.classpath b/EventBusTest/.classpath
index 2b16fe8e..cfb2c9f9 100644
--- a/EventBusTest/.classpath
+++ b/EventBusTest/.classpath
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/EventBus"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
