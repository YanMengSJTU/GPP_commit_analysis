diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e6869151..a073b1d8 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -48,9 +48,10 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    private final Map<Class<?>, Object> stickyEvents;
+
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
     private final Map<Object, List<Class<?>>> typesBySubscriber;
-    private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
@@ -204,6 +205,7 @@ private void checkPostStickyEventToSubscription(Subscription newSubscription, Ob
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
             // --> Strange corner case, which we don't take care of here.
+            // 根据不同的 ThreadMode 进行分发
             postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
         }
     }
@@ -230,6 +232,7 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
     }
 
     /** Unregisters the given subscriber from all event classes. */
+
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -241,7 +244,6 @@ public synchronized void unregister(Object subscriber) {
             Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
-
     /** Posts the given event to the event bus. */
     public void post(Object event) {
         // 中 ThreadLocal 中获取一个 PostingThreadState,  使用 ThreadLocal 传递对象，对整个 post 过程传递数据，不受不同线程的影响
@@ -250,7 +252,7 @@ public void post(Object event) {
         eventQueue.add(event);   // 添加到列表中
 
         if (!postingState.isPosting) {
-            // 线程
+            // 是否为主线程
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             // post 的状态
             postingState.isPosting = true;
@@ -374,7 +376,7 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
-        if (eventInheritance) {  // 默认是 false
+        if (eventInheritance) {  // 默认是 false，开启索引之后才会调用
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -442,14 +444,14 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
-            case BACKGROUND:
+            case BACKGROUND:    // 后台
                 if (isMainThread) {
                     backgroundPoster.enqueue(subscription, event);
                 } else {
                     invokeSubscriber(subscription, event);
                 }
                 break;
-            case ASYNC:
+            case ASYNC:     // 异步
                 asyncPoster.enqueue(subscription, event);
                 break;
             default:
@@ -541,12 +543,13 @@ private void handleSubscriberException(Subscription subscription, Object event,
 
     /** For ThreadLocal, much faster to set (and get multiple values). */
     final static class PostingThreadState {
+        // 存放 postEvent 事件列表
         final List<Object> eventQueue = new ArrayList<Object>();
-        boolean isPosting;
-        boolean isMainThread;
-        Subscription subscription;
+        boolean isPosting;      // 是否处于 posting 状态
+        boolean isMainThread;   //  是否为主线程
+        Subscription subscription;      // 订阅信息
         Object event;
-        boolean canceled;
+        boolean canceled;      // 是否被取消
     }
 
     ExecutorService getExecutorService() {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 76e65248..c65b99d7 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -36,12 +36,15 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
 
     private List<SubscriberInfoIndex> subscriberInfoIndexes;
     private final boolean strictMethodVerification;
-    private final boolean ignoreGeneratedIndex;
 
+    // 是否忽略生成的 index
+    private final boolean ignoreGeneratedIndex;
+    // 订阅缓存池
+    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
+    // FindState 缓存池
     private static final int POOL_SIZE = 4;
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
 
@@ -102,31 +105,31 @@
         return getMethodsAndRelease(findState);
     }
 
-    private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
-        List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
-        findState.recycle();
+    private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
-                if (FIND_STATE_POOL[i] == null) {
-                    FIND_STATE_POOL[i] = findState;
-                    break;
+                FindState state = FIND_STATE_POOL[i];
+                if (state != null) {
+                    FIND_STATE_POOL[i] = null;
+                    return state;
                 }
             }
         }
-        return subscriberMethods;
+        return new FindState();
     }
 
-    private FindState prepareFindState() {
+    private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+        List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
+        findState.recycle();
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
-                FindState state = FIND_STATE_POOL[i];
-                if (state != null) {
-                    FIND_STATE_POOL[i] = null;
-                    return state;
+                if (FIND_STATE_POOL[i] == null) {
+                    FIND_STATE_POOL[i] = findState;
+                    break;
                 }
             }
         }
-        return new FindState();
+        return subscriberMethods;
     }
 
     private SubscriberInfo getSubscriberInfo(FindState findState) {
@@ -137,7 +140,8 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
                 return superclassInfo;
             }
         }
-        if (subscriberInfoIndexes != null) {   // 默认是空的
+        // 默认是空的，是由使用了索引时，才会调用
+        if (subscriberInfoIndexes != null) {
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
                 if (info != null) {
@@ -210,6 +214,7 @@ static void clearCaches() {
     }
 
     static class FindState {
+        // 订阅方法
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
