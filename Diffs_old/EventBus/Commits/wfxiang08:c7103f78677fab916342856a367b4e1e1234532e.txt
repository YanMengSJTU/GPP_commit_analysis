diff --git a/EventBus/build.gradle b/EventBus/build.gradle
index 50637de7..99780a48 100644
--- a/EventBus/build.gradle
+++ b/EventBus/build.gradle
@@ -10,10 +10,10 @@ sourceCompatibility = 1.7
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
 def sonatypeRepositoryUrl
-if(isSnapshot) {
-	sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+if (isSnapshot) {
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
 } else {
-	sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
 }
 
 repositories {
@@ -56,7 +56,7 @@ javadoc {
     failOnError = false
     classpath += configurations.provided
     title = "EventBus ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2016 <a href="http://greenrobot.org">greenrobot.org</a>. All Rights Reserved.</i>'
+    options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2016 <a href="http://greenrobot.org">greenrobot.org</a>. All Rights Reserved.</i>'
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
@@ -76,8 +76,8 @@ artifacts {
 }
 
 signing {
-    if(project.hasProperty('signing.keyId') && project.hasProperty('signing.password') &&
-    project.hasProperty('signing.secretKeyRingFile')) {
+    if (project.hasProperty('signing.keyId') && project.hasProperty('signing.password') &&
+            project.hasProperty('signing.secretKeyRingFile')) {
         sign configurations.archives
     } else {
         println "Signing information missing/incomplete for ${project.name}"
@@ -87,13 +87,13 @@ signing {
 uploadArchives {
     repositories {
         mavenDeployer {
-            if(project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername') 
-                && project.hasProperty('preferedPassword')) {
+            if (project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername')
+                    && project.hasProperty('preferedPassword')) {
                 configuration = configurations.deployerJars
                 repository(url: preferedRepo) {
                     authentication(userName: preferedUsername, password: preferedPassword)
                 }
-            } else if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+            } else if (project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
                 repository(url: sonatypeRepositoryUrl) {
                     authentication(userName: sonatypeUsername, password: sonatypePassword)
@@ -102,42 +102,42 @@ uploadArchives {
                 println "Settings sonatypeUsername/sonatypePassword missing/incomplete for ${project.name}"
             }
             pom.project {
-               name 'EventBus'
-               packaging 'jar'
-               description 'EventBus is a publish/subscribe event bus optimized for Android .'
-               url 'http://greenrobot.org/eventbus/'
-
-               scm {
-                   url 'https://github.com/greenrobot/EventBus'
-                   connection 'scm:git@github.com:greenrobot/EventBus.git'
-                   developerConnection 'scm:git@github.com:greenrobot/EventBus.git'
-               }
-
-               licenses {
-                   license {
-                       name 'The Apache Software License, Version 2.0'
-                       url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
-                       distribution 'repo'
-                   }
-               }
-
-               developers {
-                   developer {
-                       id 'greenrobot'
-                       name 'greenrobot'
-                   }
-               }
-               
-               issueManagement {
-                   system 'GitHub Issues'
-                   url 'https://github.com/greenrobot/EventBus/issues'
-               }
-
-               organization {
-                   name 'greenrobot'
-                   url 'http://greenrobot.org'
-               }
-           }
+                name 'EventBus'
+                packaging 'jar'
+                description 'EventBus is a publish/subscribe event bus optimized for Android .'
+                url 'http://greenrobot.org/eventbus/'
+
+                scm {
+                    url 'https://github.com/greenrobot/EventBus'
+                    connection 'scm:git@github.com:greenrobot/EventBus.git'
+                    developerConnection 'scm:git@github.com:greenrobot/EventBus.git'
+                }
+
+                licenses {
+                    license {
+                        name 'The Apache Software License, Version 2.0'
+                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                        distribution 'repo'
+                    }
+                }
+
+                developers {
+                    developer {
+                        id 'greenrobot'
+                        name 'greenrobot'
+                    }
+                }
+
+                issueManagement {
+                    system 'GitHub Issues'
+                    url 'https://github.com/greenrobot/EventBus/issues'
+                }
+
+                organization {
+                    name 'greenrobot'
+                    url 'http://greenrobot.org'
+                }
+            }
         }
     }
 }
diff --git a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
index a56f4ebf..e06f1a83 100644
--- a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
@@ -18,7 +18,7 @@
 
 /**
  * Posts events in background.
- * 
+ *
  * @author Markus
  */
 class AsyncPoster implements Runnable {
@@ -33,14 +33,20 @@
 
     public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+
+        // 异步执行动作
         queue.enqueue(pendingPost);
+
+        // 通过: eventBus的 thread pool来执行动作
+        // 每调度一次，queue中的post就消费一个
+        // 和BackgroundPoster的不一样的地方: 后者一次执行一批请求
         eventBus.getExecutorService().execute(this);
     }
 
     @Override
     public void run() {
         PendingPost pendingPost = queue.poll();
-        if(pendingPost == null) {
+        if (pendingPost == null) {
             throw new IllegalStateException("No pending post available");
         }
         eventBus.invokeSubscriber(pendingPost);
diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 2a5319d0..1ee004e8 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -38,6 +38,8 @@ public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
             queue.enqueue(pendingPost);
+
+            //
             if (!executorRunning) {
                 executorRunning = true;
                 eventBus.getExecutorService().execute(this);
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..b3148e09 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -40,15 +40,38 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
+    //
+    // Android的进程模型?
+    //
     static volatile EventBus defaultInstance;
 
+    public static EventBus getDefault() {
+        if (defaultInstance == null) {
+            synchronized (EventBus.class) {
+                if (defaultInstance == null) {
+                    defaultInstance = new EventBus();
+                }
+            }
+        }
+        return defaultInstance;
+    }
+
+
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    //
+    // Event --> Subscription List
+    // 同一个Event有哪些subscription呢?
+    //
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
@@ -62,6 +85,7 @@ protected PostingThreadState initialValue() {
     private final HandlerPoster mainThreadPoster;
     private final BackgroundPoster backgroundPoster;
     private final AsyncPoster asyncPoster;
+
     private final SubscriberMethodFinder subscriberMethodFinder;
     private final ExecutorService executorService;
 
@@ -74,23 +98,14 @@ protected PostingThreadState initialValue() {
 
     private final int indexCount;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
-    public static EventBus getDefault() {
-        if (defaultInstance == null) {
-            synchronized (EventBus.class) {
-                if (defaultInstance == null) {
-                    defaultInstance = new EventBus();
-                }
-            }
-        }
-        return defaultInstance;
-    }
 
     public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -108,9 +123,16 @@ public EventBus() {
         subscriptionsByEventType = new HashMap<>();
         typesBySubscriber = new HashMap<>();
         stickyEvents = new ConcurrentHashMap<>();
+
+        // 主线程
+        // 如何通过 Looper 来实现异步操作呢?
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
+        // Background
         backgroundPoster = new BackgroundPoster(this);
+        // 异步
+        // 和: Background 的区别，就是: BackgroundPoster可以
         asyncPoster = new AsyncPoster(this);
+
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
@@ -119,8 +141,8 @@ public EventBus() {
         sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
         sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
         throwSubscriberException = builder.throwSubscriberException;
-        eventInheritance = builder.eventInheritance;
-        executorService = builder.executorService;
+        eventInheritance = builder.eventInheritance; // 默认考虑Event的继承关系
+        executorService = builder.executorService;  // 默认: Executors.newCachedThreadPool()
     }
 
     /**
@@ -133,8 +155,11 @@ public EventBus() {
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+
+        // 1. 主动找到所有的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            // 2. 注册每一个可能的方法
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
@@ -146,24 +171,30 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+
+        // 1. 将subscriber添加到: eventType对应的列表中
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            // 1.1. 防止重复添加
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
             }
         }
 
+        // 2. 优先级大的放在前面
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
+                // 在指定的位置插入元素
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
 
+        // 3. 对象监听哪些Event?
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -171,12 +202,16 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+
+        // 4. 如何处理Stick Event呢?
+        // 就是系统保留最后一个Event, 然后所有的Subscribe在订阅的时候就能获取到最后一个Event的信息
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
                 // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                // 如果考虑Event的继承关系，则需要遍历: // STOPSHIP: 16/4/30
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
@@ -192,6 +227,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
     }
 
+    // 调度Event, 判断: stickEvent是否为空
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
@@ -204,7 +240,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -221,7 +259,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -234,12 +274,17 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
+
+        // 2. 将event添加到队列中
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
+        // 如果正在 Posting, 则队列中的event会自动被处理
         if (!postingState.isPosting) {
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             postingState.isPosting = true;
@@ -362,6 +407,8 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
+
+        // 不考虑Event继承
         if (eventInheritance) {
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
@@ -384,19 +431,23 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
     }
 
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
+        // 1. 找到: subscriptions
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
             for (Subscription subscription : subscriptions) {
+                // 2. 当前的状态
                 postingState.event = event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 3. 发布到subscription
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
+                    // 清空状态
                     postingState.event = null;
                     postingState.subscription = null;
                     postingState.canceled = false;
@@ -410,12 +461,18 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    //
+    // 如何调度Event呢?
+    //
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        // threadMode
         switch (subscription.subscriberMethod.threadMode) {
+            // 在当前线程执行，就直接invoke
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
             case MAIN:
+                // 在主线程执行，则看情况: 如果当前的线程是主线程，则直接invoke， 否则放在队列中
                 if (isMainThread) {
                     invokeSubscriber(subscription, event);
                 } else {
@@ -437,7 +494,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -455,7 +514,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -474,7 +535,10 @@ static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
     void invokeSubscriber(PendingPost pendingPost) {
         Object event = pendingPost.event;
         Subscription subscription = pendingPost.subscription;
+
+        // 归还 PendingPost
         PendingPost.releasePendingPost(pendingPost);
+
         if (subscription.active) {
             invokeSubscriber(subscription, event);
         }
@@ -482,6 +546,7 @@ void invokeSubscriber(PendingPost pendingPost) {
 
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            //  在subscriber上执行: event
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
@@ -516,9 +581,13 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
+        // 队列
         final List<Object> eventQueue = new ArrayList<Object>();
+        // 当前状态
         boolean isPosting;
         boolean isMainThread;
         Subscription subscription;
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 3247be53..090189a1 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -20,6 +20,10 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+//
+// 同 BackgroundPoster, HandlerPoster也是一次处理一批请求，只不过是通过: Looper来实现事件的驱动
+// 不过: Looper比较特殊是，每次只能分配很小的一个时间片段
+//
 final class HandlerPoster extends Handler {
 
     private final PendingPostQueue queue;
@@ -29,6 +33,7 @@
 
     HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
         super(looper);
+
         this.eventBus = eventBus;
         this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
         queue = new PendingPostQueue();
@@ -36,8 +41,11 @@
 
     void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+
         synchronized (this) {
             queue.enqueue(pendingPost);
+
+            // handlerActive: 表示之前的PendingPost处理完毕，
             if (!handlerActive) {
                 handlerActive = true;
                 if (!sendMessage(obtainMessage())) {
@@ -67,6 +75,7 @@ public void handleMessage(Message msg) {
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
+                    // 安排到下一个Event Loop
                     if (!sendMessage(obtainMessage())) {
                         throw new EventBusException("Could not send handler message");
                     }
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..f61e6a7e 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -18,6 +18,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
+//
+// PendingPost&PendingPost的对象池
+//
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
 
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..d1bd850a 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -16,6 +16,7 @@
 
 package org.greenrobot.eventbus;
 
+// 管理 PendingPost
 final class PendingPostQueue {
     private PendingPost head;
     private PendingPost tail;
@@ -24,6 +25,9 @@ synchronized void enqueue(PendingPost pendingPost) {
         if (pendingPost == null) {
             throw new NullPointerException("null cannot be enqueued");
         }
+
+        // head ---> tail --->
+        // 如果head == null, tail == null
         if (tail != null) {
             tail.next = pendingPost;
             tail = pendingPost;
@@ -32,13 +36,18 @@ synchronized void enqueue(PendingPost pendingPost) {
         } else {
             throw new IllegalStateException("Head present, but no tail");
         }
+
+        // PendingPostQueue 同时也充当一个Lock
         notifyAll();
     }
 
+    // PendingPost从tail进去，从head出来
     synchronized PendingPost poll() {
         PendingPost pendingPost = head;
         if (head != null) {
             head = head.next;
+
+            // 保持状态一致性性
             if (head == null) {
                 tail = null;
             }
@@ -46,6 +55,7 @@ synchronized PendingPost poll() {
         return pendingPost;
     }
 
+    // 带有等待的poll
     synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
         if (head == null) {
             wait(maxMillisToWait);
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscribe.java b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
index ed0b8c82..8263fd73 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscribe.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
@@ -23,10 +23,14 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+
+// Retention的用法: java, class, runtime
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Subscribe {
+
+    // 工作模式:
     ThreadMode threadMode() default ThreadMode.POSTING;
 
     /**
@@ -35,10 +39,12 @@
      */
     boolean sticky() default false;
 
-    /** Subscriber priority to influence the order of event delivery.
+    /**
+     * Subscriber priority to influence the order of event delivery.
      * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before
      * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of
-     * delivery among subscribers with different {@link ThreadMode}s! */
+     * delivery among subscribers with different {@link ThreadMode}s!
+     */
     int priority() default 0;
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..b4c25dc5 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,6 +53,7 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 1. 缓存Reflection的结果
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
@@ -63,6 +64,8 @@
         } else {
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+
+        // 3. 如果没有相应的方法，则报错
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
@@ -75,8 +78,11 @@
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
+
         while (findState.clazz != null) {
             findState.subscriberInfo = getSubscriberInfo(findState);
+
+
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
@@ -87,6 +93,8 @@
             } else {
                 findUsingReflectionInSingleClass(findState);
             }
+
+            // super class
             findState.moveToSuperclass();
         }
         return getMethodsAndRelease(findState);
@@ -106,6 +114,7 @@
         return subscriberMethods;
     }
 
+    // 从POOL中获取一个 FindState, 如果没有找到，则返回
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
@@ -137,9 +146,13 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    //
+    // 如何通过反射来查找相关的方法呢?
+    //
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
+        FindState findState = prepareFindState(); // 从POOL中寻找一个FindState
         findState.initForSubscriber(subscriberClass);
+
         while (findState.clazz != null) {
             findUsingReflectionInSingleClass(findState);
             findState.moveToSuperclass();
@@ -147,7 +160,9 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return getMethodsAndRelease(findState);
     }
 
+    // 通过反射，查找带有: Subscribe annotation的Method
     private void findUsingReflectionInSingleClass(FindState findState) {
+        // 1. 获取Methods
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
@@ -157,26 +172,36 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+
+
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            // 2. 相关的Method需要是public, 并且不是: static, abstract等
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
+
+                // 3. 要求参数个数为1
                 if (parameterTypes.length == 1) {
+                    // 3.1 获取Annotation
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
+
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            // 3.1.1 添加: subscriberMethods
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                    // 3.2 报错
                     String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                     throw new EventBusException("@Subscribe method " + methodName +
                             "must have exactly 1 parameter but has " + parameterTypes.length);
                 }
             } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                // 3.2 报错
                 String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                 throw new EventBusException(methodName +
                         " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
@@ -257,7 +282,9 @@ void moveToSuperclass() {
             if (skipSuperClasses) {
                 clazz = null;
             } else {
+                // 通过: superClass 往上遍历
                 clazz = clazz.getSuperclass();
+
                 String clazzName = clazz.getName();
                 /** Skip system classes, this just degrades performance. */
                 if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..b1f71f44 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -34,8 +34,8 @@
     public boolean equals(Object other) {
         if (other instanceof Subscription) {
             Subscription otherSubscription = (Subscription) other;
-            return subscriber == otherSubscription.subscriber
-                    && subscriberMethod.equals(otherSubscription.subscriberMethod);
+            return subscriber == otherSubscription.subscriber // subscriber相同
+                    && subscriberMethod.equals(otherSubscription.subscriberMethod); // 方法相同
         } else {
             return false;
         }
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index 79d5dc43..5a9b0089 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -28,6 +28,8 @@
      * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
      * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
      * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
+     *
+     * 在哪个线程发送事件，就在哪个线程执行
      */
     POSTING,
 
@@ -35,6 +37,7 @@
      * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
      * the main thread, event handler methods will be called directly. Event handlers using this mode must return
      * quickly to avoid blocking the main thread.
+     * 在主线程执行
      */
     MAIN,
 
