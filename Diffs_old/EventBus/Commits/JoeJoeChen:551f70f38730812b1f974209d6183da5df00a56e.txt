diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 247cbb27..cd48dcf5 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,8 +46,17 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**
+     * key是event的时间class, value 是订阅方列表
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    /**
+     * key 订阅者，value 一共订阅的事件(列表)
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    /**
+     * 粘性订阅事件
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -136,8 +145,11 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        // 获取订阅者类名字
         Class<?> subscriberClass = subscriber.getClass();
+        // 根据订阅者类名，找出已经订阅的 订阅者方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+        // 加个同步锁，会有多处调用，保证原子性
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
@@ -147,9 +159,13 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        // 拿到订阅的 event 类型
         Class<?> eventType = subscriberMethod.eventType;
+        // 构建一个订阅关系
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        // 多线程安全的里 列表
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        // 根据eventtype获取 订阅关系(订阅关系包括订阅者和订阅方法)
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
@@ -162,6 +178,9 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
+            // 是订阅关系列表最后一个，或者  当前订阅方法，权限高于所有已经存在的其他 订阅方法
+            // 优先级没有变化，追加在最后一个；
+            // 优先级高的，直接加载当前i下标的位置, 优先级越高越靠前
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
@@ -175,7 +194,12 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        // 处理粘性订阅事件(粘性订阅是指，在注册这个订阅者的时候，遍历method, 找到粘性事件的方法，手动
+        // 派发一次事件，即 模拟一次post给这个新的订阅者，其他订阅者(不包括他的父类)不会收到)
+
+        // sticky 默认false
         if (subscriberMethod.sticky) {
+            // 默认true
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -196,6 +220,12 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
     }
 
+    /**
+     * 派发一次事件
+     *
+     * @param newSubscription
+     * @param stickyEvent
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
@@ -426,6 +456,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
+            // 直接调用
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..b3c5d1d6 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -52,12 +52,20 @@
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
 
+    /**
+     * 根据订阅者类名，找出已经订阅的所有方法
+     *
+     * @param subscriberClass
+     *
+     * @return
+     */
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
+        // 默认值false
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
@@ -72,11 +80,21 @@
         }
     }
 
+    /**
+     * 根据调用者查询出，订阅的方法列表
+     *
+     * @param subscriberClass
+     *
+     * @return
+     */
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
+        // 搞一个findstate出来
         FindState findState = prepareFindState();
+        // 初始化，把订阅者传递过去，其他字段置空
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
             findState.subscriberInfo = getSubscriberInfo(findState);
+            // 是 null
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
@@ -106,6 +124,11 @@
         return subscriberMethods;
     }
 
+    /**
+     * 从查询状态值的 缓存数组里面随便找一个null的findstate
+     *
+     * @return
+     */
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
@@ -119,13 +142,16 @@ private FindState prepareFindState() {
         return new FindState();
     }
 
+    // 获取订阅者info
     private SubscriberInfo getSubscriberInfo(FindState findState) {
+        // 当不为空    （register过来时一定为空）
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
                 return superclassInfo;
             }
         }
+        // 初始化时 new过 new ArrayList,
         if (subscriberInfoIndexes != null) {
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
@@ -137,46 +163,77 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 通过反射找出 订阅者 订阅的各种方法
+     *
+     * @param subscriberClass
+     *
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        // 搞一个 findstate出来
         FindState findState = prepareFindState();
+        // 初始化一下，主要是传递 订阅者class
         findState.initForSubscriber(subscriberClass);
+
         while (findState.clazz != null) {
+            // 找出
             findUsingReflectionInSingleClass(findState);
             findState.moveToSuperclass();
         }
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * @param findState
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             methods = findState.clazz.getDeclaredMethods();
+            // 找到当前类所有声明的方法. getDeclaredMethods本身就不包含父类的方法
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
+            // 找出当前类申明的public方法(包含当前和父类)， skip设置为true,我们不需要父类信息
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            // 是public且不是需要忽略的
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                // 获取这个方法的参数
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                // 筛选出单参数的方法
                 if (parameterTypes.length == 1) {
+                    // 获取单参数方法的 “Subscribe” 注解字段
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        // 获取event class
                         Class<?> eventType = parameterTypes[0];
+
+                        // 看看是否已经添加过
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
                     }
-                } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                }
+                // 非单参数 且被加上 “Subscribe” 注解
+                else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+
+                    // 抛出异常
                     String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                     throw new EventBusException("@Subscribe method " + methodName +
                             "must have exactly 1 parameter but has " + parameterTypes.length);
                 }
-            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+            }
+            // （非public 或者 被忽略修饰符 修饰的方法） 且 加上了 "Subscribe" 注解
+            else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+
+                // 抛出异常
                 String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                 throw new EventBusException(methodName +
                         " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
@@ -188,15 +245,25 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 查找状态值，
+     */
     static class FindState {
+        /** 订阅的方法 */
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+        /** key:event类型，value:方法 */
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+        /** key - 方法；value-订阅者 */
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
+        /** 订阅者 */
         Class<?> subscriberClass;
+        /** 订阅者中间变量，用来做while循环，中途会被置空 */
         Class<?> clazz;
+        /** 是否跳过父类 */
         boolean skipSuperClasses;
+        /** 订阅者信息（包括 类名、订阅方法集合、父类信息） */
         SubscriberInfo subscriberInfo;
 
         void initForSubscriber(Class<?> subscriberClass) {
@@ -216,8 +283,18 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        /**
+         * 判断是否添加过
+         *
+         * @param method
+         * @param eventType
+         *
+         * @return
+         */
         boolean checkAdd(Method method, Class<?> eventType) {
-            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
+            // 2 level check:
+            //                1st level with event type only (fast),
+            //                2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..21a477fb 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,7 +15,13 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 订阅者信息
+ */
 final class Subscription {
+    /**
+     * 订阅者
+     */
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
     /**
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index b8ee7d53..df8349c8 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -18,7 +18,7 @@
 /**
  * Each subscriber method has a thread mode, which determines in which thread the method is to be called by EventBus.
  * EventBus takes care of threading independently from the posting thread.
- * 
+ *
  * @see EventBus#register(Object)
  * @author Markus
  */
@@ -29,6 +29,11 @@
      * simple tasks that are known to complete in a very short time without requiring the main thread. Event handlers
      * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.
      */
+    /**
+     * 订阅者 将在发布者的线程里 直接被调用。这是默认值。避免了线程切换意味着更少的开销。
+     * 因此 这是针对(已知在短时间内的处理，不需要在主线程里的)的情况下的推荐做法。
+     * 事件处理，使用这个模式，需要在很短时间内完成，防止调用方在主线程，可能造成堵塞。
+     */
     POSTING,
 
     /**
@@ -37,12 +42,20 @@
      * is queued for delivery (non-blocking). Subscribers using this mode must return quickly to avoid blocking the main thread.
      * If not on Android, behaves the same as {@link #POSTING}.
      */
+    /**
+     * 在android里面，订阅者 将被在主线程里面调用。如果post线程是主线程，那边直接调用订阅者的方法，
+     * 阻塞post线程。其他情况下，事件将被被放置到队列里面，订阅者使用这个mode必须很快的返回，避免阻塞主线程。
+     * 在非android环境，使用和POSTING一样。
+     */
     MAIN,
 
     /**
      * On Android, subscriber will be called in Android's main thread (UI thread). Different from {@link #MAIN},
      * the event will always be queued for delivery. This ensures that the post call is non-blocking.
      */
+    /**
+     * 在android上，订阅者将在主线程被调用，不同于MAIN的是，所有的事件都会被放到队列里面传递，这样确保post不会被阻塞。
+     */
     MAIN_ORDERED,
 
     /**
@@ -51,6 +64,12 @@
      * background thread, that will deliver all its events sequentially. Subscribers using this mode should try to
      * return quickly to avoid blocking the background thread. If not on Android, always uses a background thread.
      */
+    /**
+     * 在android上，订阅者将被会在后台线程里调用。如果不是在主线程里面post的，订阅者 将被在post所在线程里面调用。
+     * 如果post线程是主线程，eventbus使用一个单独的后台线程来顺序的传递事件。订阅者使用这个mode也需要在短时间内返回，
+     * 避免阻塞后台线程。
+     * 如果不是android，总是在后台线程被调用。
+     */
     BACKGROUND,
 
     /**
@@ -60,5 +79,10 @@
      * of long running asynchronous subscriber methods at the same time to limit the number of concurrent threads. EventBus
      * uses a thread pool to efficiently reuse threads from completed asynchronous subscriber notifications.
      */
+    /**
+     * 订阅者将被在独立的线程里面调用，不同于post线程和主线程。使用这种mode, post后不需要等待订阅者调用。
+     * 当订阅方法执行需要时间的时候可以使用这个模式，比如网络连接。避免触发大数据量和长时间运行的异步调用方法，
+     * 同时限制并发的线程数。evetbus使用线程池来有效从已完成的异步订阅通知中重用线程
+     */
     ASYNC
 }
\ No newline at end of file
