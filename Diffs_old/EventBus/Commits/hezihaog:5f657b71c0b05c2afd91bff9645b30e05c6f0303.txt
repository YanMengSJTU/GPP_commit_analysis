diff --git a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
index 90a30d1e..f6d0c160 100644
--- a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
@@ -17,12 +17,12 @@
 
 
 /**
- * Posts events in background.
- * 
- * @author Markus
+ * 子线程执行器，实现了Runnable,、Poster接口
  */
 class AsyncPoster implements Runnable, Poster {
-
+    /**
+     * 消息队列
+     */
     private final PendingPostQueue queue;
     private final EventBus eventBus;
 
@@ -31,19 +31,24 @@
         queue = new PendingPostQueue();
     }
 
+    @Override
     public void enqueue(Subscription subscription, Object event) {
+        //入队，获取一个缓存的PendingPost消息对象，重新初始化
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        //将消息入队
         queue.enqueue(pendingPost);
+        //获取执行器执行
         eventBus.getExecutorService().execute(this);
     }
 
     @Override
     public void run() {
+        //获取一个PendingPost消息
         PendingPost pendingPost = queue.poll();
-        if(pendingPost == null) {
+        if (pendingPost == null) {
             throw new IllegalStateException("No pending post available");
         }
+        //反射调用订阅者的订阅方法
         eventBus.invokeSubscriber(pendingPost);
     }
-
-}
+}
\ No newline at end of file
diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 624ddf6d..daa51c35 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -18,12 +18,12 @@
 import java.util.logging.Level;
 
 /**
- * Posts events in background.
- *
- * @author Markus
+ * 子线程回调事件订阅的发送器，实现了Runnable和Poster接口
  */
 final class BackgroundPoster implements Runnable, Poster {
-
+    /**
+     * 发送队列
+     */
     private final PendingPostQueue queue;
     private final EventBus eventBus;
 
@@ -34,12 +34,17 @@
         queue = new PendingPostQueue();
     }
 
+    @Override
     public void enqueue(Subscription subscription, Object event) {
+        //获取一个消息，并将任务重新初始化
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
+            //任务入队
             queue.enqueue(pendingPost);
+            //如果没有执行，马上执行
             if (!executorRunning) {
                 executorRunning = true;
+                //获取配置的线程池执行器进行执行，将任务包裹到自身去执行
                 eventBus.getExecutorService().execute(this);
             }
         }
@@ -49,26 +54,30 @@ public void enqueue(Subscription subscription, Object event) {
     public void run() {
         try {
             try {
+                //一直死循环执行
                 while (true) {
+                    //获取下一个消息
                     PendingPost pendingPost = queue.poll(1000);
                     if (pendingPost == null) {
                         synchronized (this) {
-                            // Check again, this time in synchronized
+                            //同样要双重检查
                             pendingPost = queue.poll();
                             if (pendingPost == null) {
+                                //没有事件了，跳出死循环
                                 executorRunning = false;
                                 return;
                             }
                         }
                     }
+                    //调用订阅者
                     eventBus.invokeSubscriber(pendingPost);
                 }
             } catch (InterruptedException e) {
                 eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + " was interruppted", e);
             }
         } finally {
+            //所有发送任务执行完毕，标志位置为false，下次再入队再继续执行
             executorRunning = false;
         }
     }
-
-}
+}
\ No newline at end of file
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..d3f8f942 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -38,7 +38,9 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
@@ -46,10 +48,22 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**
+     * 事件类型和订阅它的订阅者的订阅信息（包含订阅者对象和订阅方法），一对多关系，一个事件类型，对应多个订阅者信息
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    /**
+     * 订阅者和它所订阅的事件类型映射，一对多关系，一个订阅者对应多个事件
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    /**
+     * 粘性事件映射表，一对一关系，一个事件对应一个最近发送的事件对象
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
+    /**
+     * ThreadLocal类型，保存当前线程的发送状态类，每个线程都有一份PostingThreadState
+     */
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -76,7 +90,9 @@ protected PostingThreadState initialValue() {
     private final int indexCount;
     private final Logger logger;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     */
     public static EventBus getDefault() {
         EventBus instance = defaultInstance;
         if (instance == null) {
@@ -94,7 +110,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -130,38 +148,46 @@ public EventBus() {
     }
 
     /**
-     * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
-     * are no longer interested in receiving events.
-     * <p/>
-     * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
-     * The {@link Subscribe} annotation also allows configuration like {@link
-     * ThreadMode} and priority.
+     * 订阅事件
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        //查找订阅者所有的订阅方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            //遍历订阅的方法列表，对每个订阅方法都进行注册
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
         }
     }
 
-    // Must be called in synchronized block
+    /**
+     * 将订阅者和订阅方法执行绑定
+     *
+     * @param subscriber       订阅者
+     * @param subscriberMethod 订阅方法信息对象
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        //获取事件类型
         Class<?> eventType = subscriberMethod.eventType;
+        //新建Subscription订阅信息类
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        //从subscriptionsByEventType中查找订阅信息列表
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        //没有，则创建一个，并放到subscriptionsByEventType中
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            //已经调用了register方法订阅过了，不能重复订阅
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
             }
         }
 
+        //优先级排序，优先级越高，越在List列表中靠前
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -169,15 +195,20 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 break;
             }
         }
-
+        //从typesBySubscriber中用订阅者获取它订阅的事件类型列表
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
+        //还没有注册过，所以时间类型列表subscribedEvents为空，为空则创建一个
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
+            //创建完毕，再保存到Map
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
+        //将事件类型添加到事件类型列表中
         subscribedEvents.add(eventType);
 
+        //判断订阅方法是否是粘性的
         if (subscriberMethod.sticky) {
+            //判断是否需要发送子类事件时也发送父类事件，默认为true，如果事件POJO不会继承，建议设置为false来提高性能
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -192,25 +223,32 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                     }
                 }
             } else {
+                //粘性事件意思是订阅时，如果之前有发送过粘性事件则马上回调订阅方法
+                //从粘性事件列表以事件类型中获取粘性事件POJO实例（所有粘性事件都会保存最近一份到内存）
                 Object stickyEvent = stickyEvents.get(eventType);
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
     }
 
+    /**
+     * 检查粘性事件对象，以及将粘性事件发送到订阅者
+     *
+     * @param newSubscription 订阅信息
+     * @param stickyEvent     粘性事件
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
+        //没有发送过这个类型的粘性事件，那么就不做任何操作
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
             // --> Strange corner case, which we don't take care of here.
+            //不为空，那么将这个粘性事件发送给订阅者
             postToSubscription(newSubscription, stickyEvent, isMainThread());
         }
     }
 
     /**
-     * Checks if the current thread is running in the main thread.
-     * If there is no main thread support (e.g. non-Android), "true" is always returned. In that case MAIN thread
-     * subscribers are always called in posting thread, and BACKGROUND subscribers are always called from a background
-     * poster.
+     * 判断当前是否是主线程
      */
     private boolean isMainThread() {
         return mainThreadSupport != null ? mainThreadSupport.isMainThread() : true;
@@ -220,15 +258,26 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * 使用事件类型，注销订阅
+     *
+     * @param subscriber 订阅者
+     * @param eventType  事件类型
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+        //获取事件类型的所有订阅者的订阅定系
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        //没有订阅者忽略
         if (subscriptions != null) {
+            //遍历订阅者的订阅信息列表
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
+                //找到本次要取消订阅的订阅者信息
                 Subscription subscription = subscriptions.get(i);
                 if (subscription.subscriber == subscriber) {
+                    //设置为取消订阅
                     subscription.active = false;
+                    //从列表中移除
                     subscriptions.remove(i);
                     i--;
                     size--;
@@ -237,32 +286,47 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * 注销事件注册
+     *
+     * @param subscriber 订阅者
+     */
     public synchronized void unregister(Object subscriber) {
+        //获取订阅者订阅的所有事件类型
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
+        //没有订阅过，忽略
         if (subscribedTypes != null) {
+            //遍历订阅的事件类型，取消注册
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
+            //从订阅者列表中移除
             typesBySubscriber.remove(subscriber);
         } else {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * 发送事件
+     */
     public void post(Object event) {
+        //获取当前线程的发送状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        //获取发送状态的队列
         List<Object> eventQueue = postingState.eventQueue;
+        //事件入队
         eventQueue.add(event);
-
+        //如果没有在发送，则马上发送
         if (!postingState.isPosting) {
+            //对postingState做一些配置
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                //队列不为空，则发送事件
                 while (!eventQueue.isEmpty()) {
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
@@ -297,14 +361,16 @@ public void cancelEventDelivery(Object event) {
     }
 
     /**
-     * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
-     * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
+     * 发送粘性事件
+     *
+     * @param event 事件
      */
     public void postSticky(Object event) {
+        //保存事件到粘性事件映射表
         synchronized (stickyEvents) {
             stickyEvents.put(event.getClass(), event);
         }
-        // Should be posted after it is putted, in case the subscriber wants to remove immediately
+        //马上发送事件，和普通事件一样，粘性事件的特点是register()订阅时，马上检查是否有存在的粘性事件，有则马上回调
         post(event);
     }
 
@@ -375,9 +441,16 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 发送单个事件
+     *
+     * @param event        事件对象
+     * @param postingState 发送状态
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
+        //判断是否发送子类事件时也发送父类事件
         if (eventInheritance) {
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
@@ -388,10 +461,12 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         } else {
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
+        //处理没有订阅者的情况
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
                 logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
             }
+            //没有订阅者，发送一个NoSubscriberEvent事件
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
                 post(new NoSubscriberEvent(this, event));
@@ -399,20 +474,34 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     * 按事件类型，发送单个事件
+     *
+     * @param event        事件对象
+     * @param postingState 发送状态
+     * @param eventClass   事件类型Class
+     * @return 是否有订阅者订阅者这个事件
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            //回查subscriptionsByEventType，获取要发送的这个事件的所有订阅者信息
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
+        //有订阅者订阅，则处理
         if (subscriptions != null && !subscriptions.isEmpty()) {
+            //遍历订阅者，将事件发送给他们
             for (Subscription subscription : subscriptions) {
                 postingState.event = event;
                 postingState.subscription = subscription;
+                //是否发送失败
                 boolean aborted = false;
                 try {
+                    //发送事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
+                    //重置状态
                     postingState.event = null;
                     postingState.subscription = null;
                     postingState.canceled = false;
@@ -423,37 +512,57 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
             }
             return true;
         }
+        //没有订阅者订阅
         return false;
     }
 
+    /**
+     * 发送事件到订阅者
+     *
+     * @param subscription 订阅嘻嘻
+     * @param event        事件类型
+     * @param isMainThread 当时是否在主线程
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        //分类事件回调线程模式
         switch (subscription.subscriberMethod.threadMode) {
+            //POSTING模式，直接在当前线程反射调用订阅者的订阅方法
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
             case MAIN:
+                //MAIN模式，保证在主线程回调订阅者的订阅方法
+                //判断当前是否为主线程，直接调用即可
                 if (isMainThread) {
                     invokeSubscriber(subscription, event);
                 } else {
+                    //当前不在主线程，将任务交给mainThreadPoster主线程发送器使用Handler发送
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
             case MAIN_ORDERED:
+                //MAIN_ORDERED模式，保证主线程中回调订阅者的订阅方法，但是每次都是用Handler去post一个消息
+                //所以即使当前已经是主线程了，也依然post一个消息给Handler排队执行
                 if (mainThreadPoster != null) {
                     mainThreadPoster.enqueue(subscription, event);
                 } else {
+                    //不在安卓上使用EventBus，直接调用订阅者订阅方法
                     // temporary: technically not correct as poster not decoupled from subscriber
                     invokeSubscriber(subscription, event);
                 }
                 break;
             case BACKGROUND:
+                //BACKGROUND模式，保证在子线程回调，如果当前已经在子线程，直接调用订阅者的订阅方法
                 if (isMainThread) {
+                    //不在子线程，将任务交给backgroundPoster
                     backgroundPoster.enqueue(subscription, event);
                 } else {
+                    //已经在子线程了，直接调用
                     invokeSubscriber(subscription, event);
                 }
                 break;
             case ASYNC:
+                //ASYNC模式，无论在哪个线程都让asyncPoster执行任务，所以就算已经在线程中了，也新开一个线程执行
                 asyncPoster.enqueue(subscription, event);
                 break;
             default:
@@ -461,7 +570,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -479,7 +590,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -490,22 +603,27 @@ static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
     }
 
     /**
-     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
-     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
-     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
-     * live cycle of an Activity or Fragment.
+     * 传入PendingPost的方式，调动订阅者订阅方法
      */
     void invokeSubscriber(PendingPost pendingPost) {
         Object event = pendingPost.event;
         Subscription subscription = pendingPost.subscription;
         PendingPost.releasePendingPost(pendingPost);
+        //有一个订阅者订阅事件，则发送
         if (subscription.active) {
             invokeSubscriber(subscription, event);
         }
     }
 
+    /**
+     * 发射调用订阅者的订阅方法
+     *
+     * @param subscription 订阅信息
+     * @param event        事件对象
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            //拿到订阅信息的method对象，invoke()反射调用
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
@@ -540,10 +658,21 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * 发送线程的状态
+     */
     final static class PostingThreadState {
+        /**
+         * 事件队列
+         */
         final List<Object> eventQueue = new ArrayList<>();
+        /**
+         * 是否正在发送中
+         */
         boolean isPosting;
+        /**
+         * 是否主线程
+         */
         boolean isMainThread;
         Subscription subscription;
         Object event;
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 95309547..4beaff36 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -20,11 +20,19 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+/**
+ * Android主线程事件发送器，继承Handler，实现Poster接口
+ */
 public class HandlerPoster extends Handler implements Poster {
-
+    /**
+     * 发送队列
+     */
     private final PendingPostQueue queue;
     private final int maxMillisInsideHandleMessage;
     private final EventBus eventBus;
+    /**
+     * 是否正在运行，没有限制
+     */
     private boolean handlerActive;
 
     protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
@@ -34,12 +42,23 @@ protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHan
         queue = new PendingPostQueue();
     }
 
+    /**
+     * 入队一个事件
+     *
+     * @param subscription 订阅信息
+     * @param event        事件对象
+     */
+    @Override
     public void enqueue(Subscription subscription, Object event) {
+        //获取一个等待发送的消息类对象
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
+            //消息入队
             queue.enqueue(pendingPost);
+            //没有正在执行，那么执行
             if (!handlerActive) {
                 handlerActive = true;
+                //使用Handler发消息
                 if (!sendMessage(obtainMessage())) {
                     throw new EventBusException("Could not send handler message");
                 }
@@ -52,20 +71,24 @@ public void handleMessage(Message msg) {
         boolean rescheduled = false;
         try {
             long started = SystemClock.uptimeMillis();
+            //死循环，从队列中获取下一个事件
             while (true) {
                 PendingPost pendingPost = queue.poll();
                 if (pendingPost == null) {
                     synchronized (this) {
-                        // Check again, this time in synchronized
+                        //为空再检查一遍，因为在并发情况，使用synchronized同步
                         pendingPost = queue.poll();
+                        //真的是获取不到了，那么就是没有
                         if (pendingPost == null) {
                             handlerActive = false;
                             return;
                         }
                     }
                 }
+                //反射调用订阅者的订阅方法，这里在Handler中回调，所以在主线程
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
+                //继续循环发送
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
                     if (!sendMessage(obtainMessage())) {
                         throw new EventBusException("Could not send handler message");
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..baf738ad 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -18,11 +18,25 @@
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * 封装等待发送事件Api的类，类似Handler的Message对象，内部有对象池和事件
+ */
 final class PendingPost {
+    /**
+     *
+     */
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
-
+    /**
+     * 事件
+     */
     Object event;
+    /**
+     * 订阅者信息
+     */
     Subscription subscription;
+    /**
+     * 下一个要发送的信息
+     */
     PendingPost next;
 
     private PendingPost(Object event, Subscription subscription) {
@@ -30,11 +44,18 @@ private PendingPost(Object event, Subscription subscription) {
         this.subscription = subscription;
     }
 
+    /**
+     * 从池子中获取一个事件发送类对象
+     *
+     * @param subscription 订阅信息
+     * @param event        事件
+     */
     static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         synchronized (pendingPostPool) {
             int size = pendingPostPool.size();
             if (size > 0) {
                 PendingPost pendingPost = pendingPostPool.remove(size - 1);
+                //对字段赋值
                 pendingPost.event = event;
                 pendingPost.subscription = subscription;
                 pendingPost.next = null;
@@ -44,16 +65,22 @@ static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         return new PendingPost(event, subscription);
     }
 
+    /**
+     * 回收
+     *
+     * @param pendingPost 事件发送类
+     */
     static void releasePendingPost(PendingPost pendingPost) {
+        //重置字段
         pendingPost.event = null;
         pendingPost.subscription = null;
         pendingPost.next = null;
+        //将对象放回对象池
         synchronized (pendingPostPool) {
-            // Don't let the pool grow indefinitely
+            //这里对池子大小做限制，不然会不断让池容量增长
             if (pendingPostPool.size() < 10000) {
                 pendingPostPool.add(pendingPost);
             }
         }
     }
-
 }
\ No newline at end of file
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..e6cad4a8 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -16,18 +16,34 @@
 
 package org.greenrobot.eventbus;
 
+/**
+ * 发送事件队列，是一个链表
+ */
 final class PendingPostQueue {
+    /**
+     * 队头消息
+     */
     private PendingPost head;
+    /**
+     * 队尾
+     */
     private PendingPost tail;
 
+    /**
+     * 入队
+     *
+     * @param pendingPost 下一个事件对象
+     */
     synchronized void enqueue(PendingPost pendingPost) {
         if (pendingPost == null) {
             throw new NullPointerException("null cannot be enqueued");
         }
+        //将事件绑定在，当前最后一个事件对象的next
         if (tail != null) {
             tail.next = pendingPost;
             tail = pendingPost;
         } else if (head == null) {
+            //第一次，队头为空，赋值
             head = tail = pendingPost;
         } else {
             throw new IllegalStateException("Head present, but no tail");
@@ -35,6 +51,9 @@ synchronized void enqueue(PendingPost pendingPost) {
         notifyAll();
     }
 
+    /**
+     * 获取下一个事件对象
+     */
     synchronized PendingPost poll() {
         PendingPost pendingPost = head;
         if (head != null) {
@@ -52,5 +71,4 @@ synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
         }
         return poll();
     }
-
 }
diff --git a/EventBus/src/org/greenrobot/eventbus/Poster.java b/EventBus/src/org/greenrobot/eventbus/Poster.java
index a69a078d..6c711c96 100644
--- a/EventBus/src/org/greenrobot/eventbus/Poster.java
+++ b/EventBus/src/org/greenrobot/eventbus/Poster.java
@@ -16,17 +16,14 @@
 package org.greenrobot.eventbus;
 
 /**
- * Posts events.
- *
- * @author William Ferguson
+ * 事件发送器
  */
 interface Poster {
-
     /**
-     * Enqueue an event to be posted for a particular subscription.
+     * 入队一个事件发送任务
      *
-     * @param subscription Subscription which will receive the event.
-     * @param event        Event that will be posted to subscribers.
+     * @param subscription 订阅信息
+     * @param event        事件对象
      */
     void enqueue(Subscription subscription, Object event);
-}
+}
\ No newline at end of file
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..d03854a6 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,14 +17,33 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/**
+ * 保存订阅者的订阅方法对@Subscribe注解配置的信息
+ */
 public class SubscriberMethod {
+    /**
+     * 订阅方法
+     */
     final Method method;
+    /**
+     * 线程模式
+     */
     final ThreadMode threadMode;
+    /**
+     * 事件POJO的Class
+     */
     final Class<?> eventType;
+    /**
+     * 回调优先级
+     */
     final int priority;
+    /**
+     * 是否是粘性事件
+     */
     final boolean sticky;
-    /** Used for efficient comparison */
+    /**
+     * 生成的方法字符串，为了高效的比较
+     */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..fb85685c 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,30 +53,43 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //先从缓存中查找，有则直接使用
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //是否忽略apt生成的索引，ignoreGeneratedIndex默认为false
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //反射获取所有订阅的方法
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+        //没有任何一个订阅方法，抛出异常
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //获取到所有订阅方法后，保存到缓存中，然后返回
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
     }
 
+    /**
+     * 反射查找订阅者所有的订阅方法
+     *
+     * @param subscriberClass 订阅者Class
+     */
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
+        //获取一个查找创建实体
         FindState findState = prepareFindState();
+        //初始化一些值
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            //获取订阅信息
             findState.subscriberInfo = getSubscriberInfo(findState);
+            //初始化时，findState.subscriberInfo为null
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
@@ -85,29 +98,45 @@
                     }
                 }
             } else {
+                //反射获取订阅者的所有订阅方法
                 findUsingReflectionInSingleClass(findState);
             }
+            //配置父类Class信息，会自动忽略系统类来提高性能
             findState.moveToSuperclass();
         }
+        //转移findState上保存的List<SubscriberMethod>，并对FindState中间对象回收
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 将FindState上保存的订阅方法保存到一个List集合，并将FindState回收，将FindState类放到对象池中复用
+     *
+     * @param findState 保存了订阅信息的中间类
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
+        //将订阅的方法信息保存到一个List集合
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
+        //回收，就是重置字段
         findState.recycle();
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
+                //保存到对象池中复用
                 if (FIND_STATE_POOL[i] == null) {
                     FIND_STATE_POOL[i] = findState;
                     break;
                 }
             }
         }
+        //返回这个List集合
         return subscriberMethods;
     }
 
+    /**
+     * 获取一个查找状态
+     */
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
+            //享元模式，从对象池中找，避免频繁创建FindState类
             for (int i = 0; i < POOL_SIZE; i++) {
                 FindState state = FIND_STATE_POOL[i];
                 if (state != null) {
@@ -116,10 +145,17 @@ private FindState prepareFindState() {
                 }
             }
         }
+        //没有缓存对象可用，则创建一个
         return new FindState();
     }
 
+    /**
+     * 获取订阅信息
+     *
+     * @param findState 查找状态类
+     */
     private SubscriberInfo getSubscriberInfo(FindState findState) {
+        //初始化时，subscriberInfo和subscriberInfoIndexes都为null，所以初始化时返回null
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
@@ -147,26 +183,43 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 反射获取订阅者的所有订阅方法
+     *
+     * @param findState 查找状态
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
-            // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            //使用getDeclaredMethods，反射获取所有方法，不会获取到父类中的方法，避免查找耗时，尤其是Activity，一般我们都是在子类上使用
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+        //遍历订阅者的方法
         for (Method method : methods) {
+            //获取修饰符
             int modifiers = method.getModifiers();
+            //判断方法的修饰符是否为Public公开，并且不是static静态方法，
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                //获取方法参数
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                //限定订阅方法的方法参数为1个，就是event事件类
                 if (parameterTypes.length == 1) {
+                    //判断方法是否加了@Subscribe注解，必须加了才处理
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        //获取第一个参数，就是事件event
                         Class<?> eventType = parameterTypes[0];
+                        //检查是否已经添加过了，没有添加过才继续
                         if (findState.checkAdd(method, eventType)) {
+                            //获取@Subscribe注解上的threadMode参数，就是事件回调的线程策略
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            //创建SubscriberMethod对象，代表每个订阅方法的信息
+                            //将@Subscribe注解上定义的事件类型、线程回调策略、回调优先级、是否粘性等字段保存到SubscriberMethod类中
+                            //再将SubscriberMethod对象保存到findState.subscriberMethods订阅的方法列表中
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
@@ -188,6 +241,9 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 查找状态实体类
+     */
     static class FindState {
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
@@ -205,6 +261,9 @@ void initForSubscriber(Class<?> subscriberClass) {
             subscriberInfo = null;
         }
 
+        /**
+         * 回收操作，重置字段
+         */
         void recycle() {
             subscriberMethods.clear();
             anyMethodByEventType.clear();
@@ -259,7 +318,7 @@ void moveToSuperclass() {
             } else {
                 clazz = clazz.getSuperclass();
                 String clazzName = clazz.getName();
-                /** Skip system classes, this just degrades performance. */
+                //跳过系统的类（肯定不会有EventBus的东西），来提高性能
                 if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
                     clazz = null;
                 }
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..83fb5a89 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,12 +15,14 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 订阅信息类，包裹订阅者的订阅方法，以及一个active字段来做比较使用
+ */
 final class Subscription {
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
     /**
-     * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
-     * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions.
+     * 是否取消订阅了，取消事件的所有订阅时，会置为false
      */
     volatile boolean active;
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index bf1b63c3..65fe5bd2 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index c25cd47e..693d331f 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,9 +1,9 @@
 include ':EventBus'
 include ':EventBusAnnotationProcessor'
-include ':EventBusTestJava'
-include ':EventBusTest'
-include ':EventBusTestSubscriberInJar'
-include ':EventBusPerformance'
+//include ':EventBusTestJava'
+//include ':EventBusTest'
+//include ':EventBusTestSubscriberInJar'
+//include ':EventBusPerformance'
 
 project(":EventBus").name = "eventbus"
 project(":EventBusAnnotationProcessor").name = "eventbus-annotation-processor"
\ No newline at end of file
