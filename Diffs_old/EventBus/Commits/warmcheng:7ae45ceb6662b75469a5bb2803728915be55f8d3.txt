diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..fda30623 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -38,7 +38,9 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
@@ -47,6 +49,8 @@
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    // typesBySubscriber 是在调用 unregister(this) 的时候，根据订阅者找到我们的 EventType，又根据我们的 EventType 找到订阅事件，
+    // 从而解绑用的
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
 
@@ -76,7 +80,10 @@ protected PostingThreadState initialValue() {
     private final int indexCount;
     private final Logger logger;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     * 通过双检测锁单例来获取 EventBus 的实例
+     */
     public static EventBus getDefault() {
         EventBus instance = defaultInstance;
         if (instance == null) {
@@ -94,7 +101,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -105,18 +114,29 @@ public static void clearCaches() {
      * central bus, consider {@link #getDefault()}.
      */
     public EventBus() {
+        // 传入默认创建器来创建 EventBus 实例
         this(DEFAULT_BUILDER);
     }
 
     EventBus(EventBusBuilder builder) {
         logger = builder.getLogger();
+        // key:订阅的事件,value:订阅了这个事件的所有订阅者的集合
+        // private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
         subscriptionsByEventType = new HashMap<>();
+        // key:订阅者,value:这个订阅者订阅的事件List集合,用于取消订阅
+        // private final Map<Object, List<Class<?>>> typesBySubscriber;
         typesBySubscriber = new HashMap<>();
+        // 粘性事件 key : 订阅了粘性事件的对象， value ： 粘性事件
+        // private final Map<Class<?>, Object> stickyEvents;
         stickyEvents = new ConcurrentHashMap<>();
         mainThreadSupport = builder.getMainThreadSupport();
+        // mainThread 主线程事件处理
         mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
+        // background 后台线程事件处理
         backgroundPoster = new BackgroundPoster(this);
+        // async 异步线程事件处理
         asyncPoster = new AsyncPoster(this);
+        // 订阅者响应函数信息存储和查找类
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
@@ -125,6 +145,7 @@ public EventBus() {
         sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
         sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
         throwSubscriberException = builder.throwSubscriberException;
+        // 是否支持事件继承(默认为：true ，支持)
         eventInheritance = builder.eventInheritance;
         executorService = builder.executorService;
     }
@@ -138,19 +159,34 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        // 首先获得订阅者的class对象
         Class<?> subscriberClass = subscriber.getClass();
+        // 通过 subscriberMethodFinder 来找到订阅者订阅了哪些事件.返回一个 SubscriberMethod 对象的 List,
+        // SubscriberMethod 里包含了这个方法的Method对象(我们之后可以通过反射来调用我们定义的该方法),
+        // 以及将来响应订阅是在哪个线程：ThreadMode、订阅的事件类型：eventType、订阅的优先级：priority,
+        // 以及是否接收粘性事件的 boolean 值：sticky .
+
+        // 找到类中通过 @Subscribe 注解标记的方法，然后进行订阅
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
+                // 进行订阅
                 subscribe(subscriber, subscriberMethod);
             }
         }
     }
 
     // Must be called in synchronized block
+
+    /**
+     * 必须在同步块中调用
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        // eventType 就是我们创建的各种 Event 类
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        // CopyOnWriteArrayList 可以实现读写分离，减少读和写的并发冲突，
+        // 根据 eventType 找到该 Event 注册的所有方法。
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,6 +198,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 事件所关联的方法
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -170,14 +207,19 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // subscribedEvents 为 subscriber 所订阅的事件
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
+            // typesBySubscriber 是在调用 unregister(this) 的时候，根据订阅者找到我们的 EventType，又根据我们的 EventType 找到订阅事件，
+            // 从而解绑用的
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
         subscribedEvents.add(eventType);
 
+        // 如果是粘性事件，就立刻进行处理
         if (subscriberMethod.sticky) {
+            // EventType 的子类也需要考虑进去
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -220,7 +262,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
@@ -237,7 +281,9 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
@@ -250,7 +296,9 @@ public synchronized void unregister(Object subscriber) {
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
@@ -461,7 +509,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -479,7 +529,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -506,6 +558,7 @@ void invokeSubscriber(PendingPost pendingPost) {
 
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            // 使用了反射技术，来调用订阅者 subscriber 订阅的方法（将事件作为参数传递进去）
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
@@ -540,7 +593,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..b856351b 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -21,7 +21,7 @@
 public class SubscriberMethod {
     final Method method;
     final ThreadMode threadMode;
-    final Class<?> eventType;
+    final Class<?> eventType; // 我们创建的各种 Event 类
     final int priority;
     final boolean sticky;
     /** Used for efficient comparison */
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..f0fb977c 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,11 +53,13 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // Map： 以类的 Class 为 key,以 List 为 value，存储订阅过的方法及其信息
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
+        // 如果没有配置使用索引加速，就通过反射来查找订阅的方法，否则通过索引加速来查找
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
@@ -72,6 +74,12 @@
         }
     }
 
+    /**
+     * 索引加速，否则会通过反射来查找对应方法，影响性能
+     *
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..016da706 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,6 +15,10 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * Subscription 是一个订阅，封装了订阅者和对应的回调方法
+ * 而 SubscriberMethod 又包含了我们订阅的各种事件
+ */
 final class Subscription {
     final Object subscriber;
     final SubscriberMethod subscriberMethod;
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index c37c18a5..44e1f55b 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -52,7 +52,9 @@
     public static final String OPTION_EVENT_BUS_INDEX = "eventBusIndex";
     public static final String OPTION_VERBOSE = "verbose";
 
-    /** Found subscriber methods for a class (without superclasses). */
+    /**
+     * Found subscriber methods for a class (without superclasses).
+     */
     private final ListMap<TypeElement, ExecutableElement> methodsByClass = new ListMap<>();
     private final Set<TypeElement> classesToSkip = new HashSet<>();
 
