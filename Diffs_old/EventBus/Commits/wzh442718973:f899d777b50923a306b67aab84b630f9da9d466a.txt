diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 1cd57e32..b2099430 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -124,15 +124,18 @@ public EventBus() {
     }
 
     /**
+     * 注册事件的观察者
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
      * are no longer interested in receiving events.
      * <p/>
      * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
      * The {@link Subscribe} annotation also allows configuration like {@link
      * ThreadMode} and priority.
+     *
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        //查找这个对象类上注册的事件接受者
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -141,7 +144,13 @@ public void register(Object subscriber) {
         }
     }
 
-    // Must be called in synchronized block
+
+
+    /***
+     *Must be called in synchronized block
+     * @param subscriber
+     * @param subscriberMethod
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
@@ -257,7 +266,7 @@ public void post(Object event) {
         }
     }
 
-    /**
+    /** 中止事件传递
      * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
      * subscribers
      * won't receive the event. Events are usually canceled by higher priority subscribers (see
@@ -280,7 +289,7 @@ public void cancelEventDelivery(Object event) {
         postingState.canceled = true;
     }
 
-    /**
+    /** 发送粘性事件
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
      */
@@ -367,6 +376,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
                 Class<?> clazz = eventTypes.get(h);
+                //将消息循环发送到所有类的对象上
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
@@ -383,6 +393,13 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /***
+     *
+     * @param event：事件对象
+     * @param postingState
+     * @param eventClass: 这个事件的类型
+     * @return
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
@@ -410,6 +427,12 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /***
+     * post事件到对于的消息观察者
+     * @param subscription
+     * @param event
+     * @param isMainThread
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -437,7 +460,11 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * 查看这个事件类型关联到多少个对象类上
+     * 查看当前类的父类
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     * */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
