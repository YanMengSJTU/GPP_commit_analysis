diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..187d5421 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,8 +46,17 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**
+     * 内部是一个Map集合，可以根据 事件类型 查找订阅事件。key 为 事件类型 EventType
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+    /**
+     * 根据我们的订阅者找到该订阅者所订阅的事件的列表。key 为 注册者 Subscriber
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+    /**
+     * 粘性事件的缓存。
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
@@ -60,9 +69,21 @@ protected PostingThreadState initialValue() {
     // @Nullable
     private final MainThreadSupport mainThreadSupport;
     // @Nullable
+    /**
+     * 主线程事件投递者
+     */
     private final Poster mainThreadPoster;
+    /**
+     * 后台线程事件投递者
+     */
     private final BackgroundPoster backgroundPoster;
+    /**
+     * 异步事件投递者
+     */
     private final AsyncPoster asyncPoster;
+    /**
+     * 查找方法用的，内部维护了一个订阅方法的集合。
+     */
     private final SubscriberMethodFinder subscriberMethodFinder;
     private final ExecutorService executorService;
 
@@ -71,7 +92,7 @@ protected PostingThreadState initialValue() {
     private final boolean logNoSubscriberMessages;
     private final boolean sendSubscriberExceptionEvent;
     private final boolean sendNoSubscriberEvent;
-    private final boolean eventInheritance;
+    private final boolean eventInheritance;//事件类型是否支持继承
 
     private final int indexCount;
     private final Logger logger;
@@ -139,18 +160,28 @@ public EventBus() {
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        //找出订阅者类里面订阅消息的所有方法。
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
+                // 给观察者订阅每个事件
                 subscribe(subscriber, subscriberMethod);
             }
         }
     }
 
     // Must be called in synchronized block
+
+    /**
+     * 订阅
+     * @param subscriber 订阅者
+     * @param subscriberMethod 订阅者的订阅方法
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
+        //根据订阅者和订阅方法构造一个订阅事件，
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        //根据 EventType 去查找 Subscription 的集合
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -163,6 +194,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
 
         int size = subscriptions.size();
+        // 根据优先级将当前订阅关系插入到 subscriptions 中
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
@@ -170,13 +202,15 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 根据观察者获取到其订阅事件类型集合
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
-        subscribedEvents.add(eventType);
+        subscribedEvents.add(eventType); // 添加事件到观察者订阅事件集合
 
+        //如果是粘性事件
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
@@ -252,6 +286,7 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        //每个线程中都维护了一个投递的状态,获得当前线程的 PostingThreadState
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
@@ -386,7 +421,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
-            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
+            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); // 发送单个事件
         }
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
@@ -399,18 +434,25 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     * 发送某 EventType 类型的所有事件
+     * @param event
+     * @param postingState
+     * @param eventClass
+     * @return
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
-            subscriptions = subscriptionsByEventType.get(eventClass);
+            subscriptions = subscriptionsByEventType.get(eventClass);// 根据事件 class 类型来找出所有订阅该事件的订阅关系
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
-            for (Subscription subscription : subscriptions) {
+            for (Subscription subscription : subscriptions) {// 将事件一一分发给每一个观察者
                 postingState.event = event;
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
-                    postToSubscription(subscription, event, postingState.isMainThread);
+                    postToSubscription(subscription, event, postingState.isMainThread); // 分发给观察者
                     aborted = postingState.canceled;
                 } finally {
                     postingState.event = null;
@@ -504,8 +546,14 @@ void invokeSubscriber(PendingPost pendingPost) {
         }
     }
 
+    /**
+     * 调用订阅者
+     * @param subscription 订阅者订阅方法信息
+     * @param event 事件
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            //通过反射调用了观察者的订阅函数，并把 event 对象作为参数传入
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
@@ -542,7 +590,7 @@ private void handleSubscriberException(Subscription subscription, Object event,
 
     /** For ThreadLocal, much faster to set (and get multiple values). */
     final static class PostingThreadState {
-        final List<Object> eventQueue = new ArrayList<>();
+        final List<Object> eventQueue = new ArrayList<>();//事件队列
         boolean isPosting;
         boolean isMainThread;
         Subscription subscription;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..d5b2afb8 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -36,11 +36,11 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
+    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();//方法缓存
 
-    private List<SubscriberInfoIndex> subscriberInfoIndexes;
+    private List<SubscriberInfoIndex> subscriberInfoIndexes;//预生成的订阅者的信息的索引
     private final boolean strictMethodVerification;
-    private final boolean ignoreGeneratedIndex;
+    private final boolean ignoreGeneratedIndex;//要不要忽略生成的索引
 
     private static final int POOL_SIZE = 4;
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
@@ -54,7 +54,7 @@
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
-        if (subscriberMethods != null) {
+        if (subscriberMethods != null) {//优先使用缓存
             return subscriberMethods;
         }
 
@@ -67,27 +67,34 @@
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
-            METHOD_CACHE.put(subscriberClass, subscriberMethods);
+            METHOD_CACHE.put(subscriberClass, subscriberMethods);//存入缓存，方便下次再查找
             return subscriberMethods;
         }
     }
 
+    /**
+     * 通过预生产的信息（SubscriberInfo）获取注册的方法
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
-        while (findState.clazz != null) {
+        while (findState.clazz != null) {  //从 findState 中获取 SubscriberInfo
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
+                    //根据eventType对SubscriberMethod进行检查
+                    //如果有这种类型的方法，或者有这个方法的类型的子类就返回false了
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
-                        findState.subscriberMethods.add(subscriberMethod);
+                        findState.subscriberMethods.add(subscriberMethod);// 添加订阅方法到 findState
                     }
                 }
             } else {
-                findUsingReflectionInSingleClass(findState);
+                findUsingReflectionInSingleClass(findState);// 通过反射获取订阅方法
             }
-            findState.moveToSuperclass();
+            findState.moveToSuperclass();//移动到父类,继续查找父类的订阅方法
         }
         return getMethodsAndRelease(findState);
     }
@@ -120,12 +127,15 @@ private FindState prepareFindState() {
     }
 
     private SubscriberInfo getSubscriberInfo(FindState findState) {
+        //查找是否存在订阅信息，有则直接返回
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
                 return superclassInfo;
             }
         }
+        // 从我们传入的MyEventBusIndex中查找是否存在订阅信息
+        // 订阅信息就是订阅方法，包括父类的订阅方法
         if (subscriberInfoIndexes != null) {
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
@@ -137,19 +147,31 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 通过反射获取订阅方法。
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        // 用来做订阅方法的订阅和保存
         FindState findState = prepareFindState();
+        // 初始化观察者的 FindState
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
             findUsingReflectionInSingleClass(findState);
-            findState.moveToSuperclass();
+            findState.moveToSuperclass();// 查找父类的订阅方法
         }
+        // 获得 findState 中的订阅方法 list 并返回
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 在某个类中通过反射来寻找订阅方法
+     * @param findState
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
-        try {
+        try {// 通过反射得到方法数组
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
@@ -159,14 +181,15 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
-            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {//是共有方法，不是虚方法、静态方法、
                 Class<?>[] parameterTypes = method.getParameterTypes();
-                if (parameterTypes.length == 1) {
-                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
+                if (parameterTypes.length == 1) {// 保证必须只有一个事件参数
+                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);// 得到注解
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
-                        if (findState.checkAdd(method, eventType)) {
+                        if (findState.checkAdd(method, eventType)) {// 检查是否添加方法到 findState
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            // 添加订阅方法到 findState
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
@@ -219,11 +242,13 @@ void recycle() {
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            //两层检查：一层是只根据EventType，第二次根据签名
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
                 return true;
             } else {
                 if (existing instanceof Method) {
+                    //只有子类中没有发现这种类型的方法类型才返回true
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
@@ -240,9 +265,11 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             methodKeyBuilder.append(method.getName());
             methodKeyBuilder.append('>').append(eventType.getName());
 
+            //将方法名和事件类型当做key，保存方法
             String methodKey = methodKeyBuilder.toString();
             Class<?> methodClass = method.getDeclaringClass();
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
+            //如果我们传递过来的methodClass是父类，则直接返回
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                 // Only add if not already found in a sub class
                 return true;
