diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 5f4b6de2..a3800212 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -18,6 +18,7 @@
 import android.text.TextUtils;
 
 import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -43,6 +44,8 @@
 
     /** Log tag, apps may override it. */
     public static String TAG = "EventBus";
+    public static final String AUTO_REGISTER_CLASS_NAME = "EventBusAutoRegister";
+    public static final String AUTO_REGISTER_METHOD_NAME = "register";
 
     static volatile EventBus defaultInstance;
 
@@ -137,6 +140,31 @@ public EventBus() {
         executorService = builder.executorService;
     }
 
+    private volatile boolean mHasAutoRegistered = false;
+    /**
+     *  harryguo 是否自动注册过了。不能定义为static，要确保：每个EventBus的instance里都进行了自动注册。无论用户通过哪个instance来post或process事件，都可以调用到这里来
+     */
+    private void autoRegisterForOnce() {
+        if (!mHasAutoRegistered) {
+            synchronized (this) {
+                if (!mHasAutoRegistered) {
+                    // harryguo 这一行必须在最前。因为这里比较关键，搞错了就会形成无限循环调用
+                    mHasAutoRegistered = true;
+                    try {
+                        Class autoRegister = Class.forName(EventBus.class.getPackage().getName() + "." + AUTO_REGISTER_CLASS_NAME);
+                        if (autoRegister != null) {
+                            Method registerMethod = autoRegister.getDeclaredMethod(AUTO_REGISTER_METHOD_NAME, EventBus.class);
+                            if (registerMethod != null)
+                                registerMethod.invoke(null, this);
+                        }
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+    }
+
     /**
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
      * are no longer interested in receiving events.
@@ -146,6 +174,7 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        autoRegisterForOnce();
         Class<?> subscriberClass;
         // harryguo add start. shall end with "// harryguo add end"
         // 允许调用者注册静态函数类型的订阅者
@@ -159,19 +188,21 @@ public void register(Object subscriber) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 // harryguo add start. shall end with "// harryguo add end"
                 // subscribe(subscriber, subscriberMethod);
+                boolean subscriberIsClass = (subscriber instanceof Class<?>);
+                boolean isStaticMethod = ((subscriberMethod.method.getModifiers() & Modifier.STATIC) != 0);
                 // 如果register的是类class（XXX.class），而非类的实例(XXX xxx = new XXX())，也行，但这种注册方式里，仅支持注册静态函数（因为没有实例，无法调用非静态函数）
-                if (subscriber instanceof Class<?> && (subscriberMethod.method.getModifiers() & Modifier.STATIC) == 0)
+                if (subscriberIsClass != isStaticMethod)
                     continue;
                     // 如果是排他性的订阅者，那就要把已经注册了该事件的其他订阅者先删除掉
                 // 将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
                 if (subscriberMethod.exclusive) {
-                    if (!TextUtils.isEmpty(subscriberMethod.eventId))
-                        unsubscribeByEventId(null, subscriberMethod.eventId);
+                    if (!TextUtils.isEmpty(subscriberMethod.eventFilter))
+                        unsubscribeByEventId(null, subscriberMethod.eventFilter);
                     else
                         unsubscribeByEventType(null, subscriberMethod.eventType);
                 }
                 // 允许调用者注册带eventId的订阅者
-                if (!TextUtils.isEmpty(subscriberMethod.eventId))
+                if (!TextUtils.isEmpty(subscriberMethod.eventFilter))
                     subscribeByEventId(subscriber, subscriberMethod);
                 else
                     subscribeByEventType(subscriber, subscriberMethod);
@@ -293,8 +324,8 @@ public synchronized void unregister(Object subscriber) {
         // harryguo add start. shall end with "// harryguo add end"
         List<String> subscribedIds = idsBySubscriber.get(subscriber);
         if (subscribedIds != null) {
-            for (String eventId : subscribedIds) {
-                unsubscribeByEventId(subscriber, eventId);
+            for (String eventFilter : subscribedIds) {
+                unsubscribeByEventId(subscriber, eventFilter);
             }
             idsBySubscriber.remove(subscriber);
         }
@@ -307,27 +338,28 @@ public synchronized void unregister(Object subscriber) {
     }
 
     /** Posts the given event to the event bus. */
-    public void post(Object event) {
-        PostingThreadState postingState = currentPostingThreadState.get();
-        List<PostingThreadState.EventMessage> eventQueue = postingState.eventQueue;
-        eventQueue.add(new PostingThreadState.EventMessage(event));
-
-        if (!postingState.isPosting) {
-            postingState.isMainThread = isMainThread();
-            postingState.isPosting = true;
-            if (postingState.canceled) {
-                throw new EventBusException("Internal error. Abort state was not reset");
-            }
-            try {
-                while (!eventQueue.isEmpty()) {
-                    postSingleEvent(eventQueue.remove(0), postingState);
-                }
-            } finally {
-                postingState.isPosting = false;
-                postingState.isMainThread = false;
-            }
-        }
-    }
+    // harryguo comment this，挪到harryguo的专有代码块去
+//    public void post(Object event) {
+//        PostingThreadState postingState = currentPostingThreadState.get();
+//        List<PostingThreadState.EventMessage> eventQueue = postingState.eventQueue;
+//        eventQueue.add(new PostingThreadState.EventMessage(event));
+//
+//        if (!postingState.isPosting) {
+//            postingState.isMainThread = isMainThread();
+//            postingState.isPosting = true;
+//            if (postingState.canceled) {
+//                throw new EventBusException("Internal error. Abort state was not reset");
+//            }
+//            try {
+//                while (!eventQueue.isEmpty()) {
+//                    postSingleEvent(eventQueue.remove(0), postingState);
+//                }
+//            } finally {
+//                postingState.isPosting = false;
+//                postingState.isMainThread = false;
+//            }
+//        }
+//    }
 
     /**
      * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
@@ -436,19 +468,21 @@ private void postSingleEvent(PostingThreadState.EventMessage eventMsg, PostingTh
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         // harryguo add. 这里如果eventId不为空，那就只根据eventId，忽略eventType。eventId优先级高于eventType
-        if (!TextUtils.isEmpty(eventMsg.eventId))
+        if (!TextUtils.isEmpty(eventMsg.eventFilter))
         {
             subscriptionFound = postSingleEventForEventId(eventMsg, postingState);
         }
-        else if (eventInheritance) {
-            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
-            int countTypes = eventTypes.size();
-            for (int h = 0; h < countTypes; h++) {
-                Class<?> clazz = eventTypes.get(h);
-                subscriptionFound |= postSingleEventForEventType(eventMsg, postingState, clazz);
+        else {
+            if (eventInheritance) {
+                List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+                int countTypes = eventTypes.size();
+                for (int h = 0; h < countTypes; h++) {
+                    Class<?> clazz = eventTypes.get(h);
+                    subscriptionFound |= postSingleEventForEventType(eventMsg, postingState, clazz);
+                }
+            } else {
+                subscriptionFound = postSingleEventForEventType(eventMsg, postingState, eventClass);
             }
-        } else {
-            subscriptionFound = postSingleEventForEventType(eventMsg, postingState, eventClass);
         }
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
@@ -606,15 +640,11 @@ private void handleSubscriberException(Subscription subscription, Object event,
     final static class PostingThreadState {
         final static private class EventMessage {
             Object event;
-            String eventId;
+            String eventFilter;
 
-            EventMessage(Object event) {
-                this(event, null);
-            }
-
-            EventMessage(Object event, String eventId) {
+            EventMessage(Object event, String eventFilter) {
                 this.event = event;
-                this.eventId = eventId;
+                this.eventFilter = eventFilter;
             }
         }
 
@@ -650,15 +680,15 @@ public String toString() {
     // harryguo start。以下全是harryguo的代码，有harryguo end做结束：
     // Must be called in synchronized block
     private void subscribeByEventId(Object subscriber, SubscriberMethod subscriberMethod) {
-        String eventId = subscriberMethod.eventId;
+        String eventFilter = subscriberMethod.eventFilter;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
-        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventId.get(eventId);
+        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventId.get(eventFilter);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
-            subscriptionsByEventId.put(eventId, subscriptions);
+            subscriptionsByEventId.put(eventFilter, subscriptions);
         } else {
             if (subscriptions.contains(newSubscription)) {
-                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventId);
+                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventFilter);
             }
         }
 
@@ -675,11 +705,11 @@ private void subscribeByEventId(Object subscriber, SubscriberMethod subscriberMe
             subscribedEvents = new ArrayList<>();
             idsBySubscriber.put(subscriber, subscribedEvents);
         }
-        subscribedEvents.add(eventId);
+        subscribedEvents.add(eventFilter);
     }
 
-    private void unsubscribeByEventId(Object subscriber, String eventId) {
-        List<Subscription> subscriptions = subscriptionsByEventId.get(eventId);
+    private void unsubscribeByEventId(Object subscriber, String eventFilter) {
+        List<Subscription> subscriptions = subscriptionsByEventId.get(eventFilter);
         if (subscriptions != null) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
@@ -692,7 +722,7 @@ private void unsubscribeByEventId(Object subscriber, String eventId) {
                     // harryguo：idsBySubscriber里的数据也要清一下
                     List<String> subscribedIds = idsBySubscriber.get(subscription.subscriber);
                     if (subscribedIds != null) {
-                        subscribedIds.remove(eventId);
+                        subscribedIds.remove(eventFilter);
                         if (subscribedIds.isEmpty())
                             idsBySubscriber.remove(subscription.subscriber);
                     }
@@ -700,14 +730,14 @@ private void unsubscribeByEventId(Object subscriber, String eventId) {
             }
             // harryguo: 如果订阅者都已经被删光了，那这个EventId的记录就可以整体被删掉了
             if (subscriptions.isEmpty())
-                subscriptionsByEventId.remove(eventId);
+                subscriptionsByEventId.remove(eventFilter);
         }
     }
 
-    public boolean hasSubscriberForEvent(String eventId) {
+    public boolean hasSubscriberForEvent(String eventFilter) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
-            subscriptions = subscriptionsByEventId.get(eventId);
+            subscriptions = subscriptionsByEventId.get(eventFilter);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
             return true;
@@ -719,41 +749,51 @@ public Object process(Object eventContent) {
         return process(eventContent, null);
     }
 
-    public Object process(Object eventContent, int eventId) {
-        return process(eventContent, String.valueOf(eventId));
+    public Object process(Object eventContent, int eventFilter) {
+        return process(eventContent, String.valueOf(eventFilter));
     }
 
-    public Object process(Object eventContent, String eventId) {
+    public Object process(Object eventContent, String eventFilter) {
         Object retValue = null;
         boolean subscriptionFound = false;
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
-            if (TextUtils.isEmpty(eventId)) {
+            if (TextUtils.isEmpty(eventFilter)) {
                 // 支持EventBus的原始调用方式（无eventId，只有eventContent的方式）
                 subscriptions = subscriptionsByEventType.get(eventContent.getClass());
             }
             else {
-                subscriptions = subscriptionsByEventId.get(eventId);
+                subscriptions = subscriptionsByEventId.get(eventFilter);
             }
         }
         // 只调用一个处理者
         if (subscriptions != null && !subscriptions.isEmpty()) {
             Subscription subscription = subscriptions.get(0);
-            Class<?> eventType = subscription.subscriberMethod.eventType;
-            if (eventContent == null || (eventType != null && eventType.isInstance(eventContent))) {
-                try {
-                    retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, eventContent);
-                } catch (InvocationTargetException e) {
-                    handleSubscriberException(subscription, eventContent, e.getCause());
-                } catch (IllegalAccessException e) {
-                    throw new IllegalStateException("Unexpected exception", e);
-                }
+            /**
+             * 检查订阅者的threadMode，如果订阅者不希望直接调用的话，就只能post了。此时返回值是null
+             * 在这种情况下，订阅者是不能调用 {@link #cancelEventDelivery(Object)}的。因为本就只调用你一个人呀。如果调用，就会抛出exception
+             * */
+            if (subscription.subscriberMethod.threadMode != ThreadMode.POSTING) {
+                postToSubscription(subscription, eventContent, isMainThread());
                 subscriptionFound = true;
             }
+            else {
+                Class<?> eventType = subscription.subscriberMethod.eventType;
+                if (eventContent == null || (eventType != null && eventType.isInstance(eventContent))) {
+                    try {
+                        retValue = subscription.subscriberMethod.method.invoke(subscription.subscriber, eventContent);
+                    } catch (InvocationTargetException e) {
+                        handleSubscriberException(subscription, eventContent, e.getCause());
+                    } catch (IllegalAccessException e) {
+                        throw new IllegalStateException("Unexpected exception", e);
+                    }
+                    subscriptionFound = true;
+                }
+            }
         }
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
-                logger.log(Level.FINE, "No subscribers registered for event " + eventId);
+                logger.log(Level.FINE, "No subscribers registered for event " + (eventContent == null ? null : eventContent.getClass()) + " filter:" + eventFilter);
             }
             if (sendNoSubscriberEvent) {
                 post(new NoSubscriberEvent(this, eventContent));
@@ -762,16 +802,19 @@ public Object process(Object eventContent, String eventId) {
         return retValue;
     }
 
+    /** Posts the given event to the event bus. */
+    public void post(Object event) {
+        post(event, null);
+    }
     /** Posts the given event to the event bus, with event id. */
-
-    public void post(Object event, int eventId) {
-        post(event, String.valueOf(eventId));
+    public void post(Object event, int eventFilter) {
+        post(event, String.valueOf(eventFilter));
     }
 
-    public void post(Object event, String eventId) {
+    public void post(Object event, String eventFilter) {
         PostingThreadState postingState = currentPostingThreadState.get();
         List<PostingThreadState.EventMessage> eventQueue = postingState.eventQueue;
-        eventQueue.add(new PostingThreadState.EventMessage(event, eventId));
+        eventQueue.add(new PostingThreadState.EventMessage(event, eventFilter));
 
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
@@ -793,7 +836,7 @@ public void post(Object event, String eventId) {
     private boolean postSingleEventForEventId(PostingThreadState.EventMessage eventMsg, PostingThreadState postingState) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
-            subscriptions = subscriptionsByEventId.get(eventMsg.eventId);
+            subscriptions = subscriptionsByEventId.get(eventMsg.eventFilter);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
             for (Subscription subscription : subscriptions) {
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscribe.java b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
index 4dbf2f42..aa5a4112 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscribe.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscribe.java
@@ -41,10 +41,14 @@
      * delivery among subscribers with different {@link ThreadMode}s! */
     int priority() default 0;
 
-    // 相当于一个filter，指定只有这种事件才接收，忽略参数的class type
-    String eventId() default "";
+    /**
+     * 一个filter，指定只有这种事件才接收，优先级高于参数的class type
+     */
+    String filter() default "";
 
-    // 排他性的，谨慎指定！会将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
+    /**
+     * 排他性的，独享这种Event。谨慎指定！会将其他所有同类Subscrible(什么是同类：eventId相同；eventId都为空，而event事件是同一个class)踢出去
+     */
     boolean exclusive() default false;
 }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index deeb053c..76dee17c 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -24,18 +24,18 @@
     final Class<?> eventType;
     final int priority;
     final boolean sticky;
-    final String eventId;
+    final String eventFilter;
     final boolean exclusive;
     /** Used for efficient comparison */
     String methodString;
 
-    public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky, String eventId, boolean exclusive) {
+    public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky, String eventFilter, boolean exclusive) {
         this.method = method;
         this.threadMode = threadMode;
         this.eventType = eventType;
         this.priority = priority;
         this.sticky = sticky;
-        this.eventId = eventId;
+        this.eventFilter = eventFilter;
         this.exclusive = exclusive;
     }
 
@@ -61,7 +61,7 @@ private synchronized void checkMethodString() {
             builder.append(method.getDeclaringClass().getName());
             builder.append('#').append(method.getName());
             builder.append('(').append(eventType.getName());
-            builder.append(eventId).append(exclusive);
+            builder.append(eventFilter).append(exclusive);
             methodString = builder.toString();
         }
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index efd6d173..09e03e59 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -169,10 +169,10 @@ private void findUsingReflectionInSingleClass(FindState findState) {
                         Class<?> eventType = parameterTypes[0];
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
-                            String  eventId = subscribeAnnotation.eventId();
+                            String  filter = subscribeAnnotation.filter();
                             boolean  exclusive = subscribeAnnotation.exclusive();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
-                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky(), eventId, exclusive));
+                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky(), filter, exclusive));
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
index 8bf2e7d1..09bf2d17 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/AbstractSubscriberInfo.java
@@ -67,10 +67,10 @@ protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> ev
     }
 
     protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType, ThreadMode threadMode,
-                                                      int priority, boolean sticky, String eventId, boolean exclusive) {
+                                                      int priority, boolean sticky, String eventFilter, boolean exclusive) {
         try {
             Method method = subscriberClass.getDeclaredMethod(methodName, eventType);
-            return new SubscriberMethod(method, eventType, threadMode, priority, sticky, eventId, exclusive);
+            return new SubscriberMethod(method, eventType, threadMode, priority, sticky, eventFilter, exclusive);
         } catch (NoSuchMethodException e) {
             throw new EventBusException("Could not find subscriber method in " + subscriberClass +
                     ". Maybe a missing ProGuard rule?", e);
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
index 8296e9c1..f43a8845 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SimpleSubscriberInfo.java
@@ -36,7 +36,7 @@ public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass
         for (int i = 0; i < length; i++) {
             SubscriberMethodInfo info = methodInfos[i];
             methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,
-                    info.priority, info.sticky, info.eventId, info.exclusive);
+                    info.priority, info.sticky, info.eventFilter, info.exclusive);
         }
         return methods;
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
index 35e00351..3bada598 100644
--- a/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
+++ b/EventBus/src/org/greenrobot/eventbus/meta/SubscriberMethodInfo.java
@@ -24,17 +24,17 @@
     final int priority;
     final boolean sticky;
     // harryguo add. accordingto @Subscribe
-    final String eventId;
+    final String eventFilter;
     final boolean exclusive;
 
     public SubscriberMethodInfo(String methodName, Class<?> eventType, ThreadMode threadMode,
-                                int priority, boolean sticky, String eventId, boolean exclusive) {
+                                int priority, boolean sticky, String eventFilter, boolean exclusive) {
         this.methodName = methodName;
         this.threadMode = threadMode;
         this.eventType = eventType;
         this.priority = priority;
         this.sticky = sticky;
-        this.eventId = eventId;
+        this.eventFilter = eventFilter;
         this.exclusive = exclusive;
     }
 
diff --git a/EventBusAnnotationProcessor/build.gradle b/EventBusAnnotationProcessor/build.gradle
index 76b5e1fd..a2fd9ca7 100644
--- a/EventBusAnnotationProcessor/build.gradle
+++ b/EventBusAnnotationProcessor/build.gradle
@@ -27,6 +27,9 @@ dependencies {
     implementation project(':eventbus')
     implementation 'de.greenrobot:java-common:2.3.1'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
+    implementation 'com.google.auto.service:auto-service:1.0-rc2'
+    // JavaFile等，用于processor自动生成源码。这个工具库更方便
+    implementation 'com.squareup:javapoet:1.7.0'
 }
 
 sourceSets {
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/AutoRegisterCreator.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/AutoRegisterCreator.java
new file mode 100644
index 00000000..623c085b
--- /dev/null
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/AutoRegisterCreator.java
@@ -0,0 +1,54 @@
+package org.greenrobot.eventbus.annotationprocessor;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import org.greenrobot.eventbus.EventBus;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Created by harryguo on 2018/7/22.
+ * 本类用来创建一个class的内容全文
+ */
+public class AutoRegisterCreator {
+
+    private TypeElement mTypeElement;
+    private Collection<SubscribeClass> mSubscribeClazz;
+
+    public AutoRegisterCreator(Collection<SubscribeClass> clazz) {
+        mSubscribeClazz = clazz;
+    }
+
+    public void createFile(Filer filer) throws IOException {
+        if (mSubscribeClazz != null && mSubscribeClazz.size() > 0) {
+            // 带参数eventBus的函数：public static EventBusAutoRegister.register(EventBus eventBus);
+            MethodSpec.Builder registerMethod = MethodSpec.methodBuilder(EventBus.AUTO_REGISTER_METHOD_NAME)
+                    .addModifiers(Modifier.PUBLIC)
+                    .addModifiers(Modifier.STATIC)
+                    .addParameter(ClassName.get(EventBus.class), "eventBus");
+            registerMethod.addJavadoc("This is called by EventBus. When any register is about to run.\n");
+            for(SubscribeClass subscribeClass : mSubscribeClazz) {
+                // 注册那些静态订阅者所对应的类
+                registerMethod.addStatement("eventBus.register($N.class)", subscribeClass.getFullClassName());
+            }
+
+            //generate class
+            TypeSpec injectedClass = TypeSpec.classBuilder(EventBus.AUTO_REGISTER_CLASS_NAME)
+                    .addModifiers(Modifier.PUBLIC)
+                    .addMethod(registerMethod.build())
+                    .addJavadoc("Copyright (C) 2018-2023 Harry Guo\nAuto generated by EventBus.\n" +
+                            "The purpose of this class is to auto register static subscriber.\n")
+                    .build();
+
+            JavaFile.builder(EventBus.class.getPackage().getName(), injectedClass).build().writeTo(filer);
+        }
+    }
+}
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index a33b281c..b6626ff1 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -21,6 +21,7 @@
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -44,7 +45,6 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import de.greenrobot.common.ListMap;
 
 @SupportedAnnotationTypes("org.greenrobot.eventbus.Subscribe")
 @SupportedOptions(value = {"eventBusIndex", "verbose"})
@@ -53,7 +53,7 @@
     public static final String OPTION_VERBOSE = "verbose";
 
     /** Found subscriber methods for a class (without superclasses). */
-    private final ListMap<TypeElement, ExecutableElement> methodsByClass = new ListMap<>();
+    private final HashMap<TypeElement, List<ExecutableElement>> methodsByClass = new HashMap<>();
     private final Set<TypeElement> classesToSkip = new HashSet<>();
 
     private boolean writerRoundDone;
@@ -67,53 +67,59 @@ public SourceVersion getSupportedSourceVersion() {
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
-        Messager messager = processingEnv.getMessager();
-        try {
-            String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
-            if (index == null) {
-                messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
-                        " passed to annotation processor");
-                return false;
-            }
-            verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));
-            int lastPeriod = index.lastIndexOf('.');
-            String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null;
-
-            round++;
-            if (verbose) {
-                messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +
-                        !annotations.isEmpty() + ", processingOver: " + env.processingOver());
-            }
-            if (env.processingOver()) {
-                if (!annotations.isEmpty()) {
-                    messager.printMessage(Diagnostic.Kind.ERROR,
-                            "Unexpected processing state: annotations still available after processing over");
-                    return false;
-                }
-            }
-            if (annotations.isEmpty()) {
-                return false;
-            }
-
-            if (writerRoundDone) {
-                messager.printMessage(Diagnostic.Kind.ERROR,
-                        "Unexpected processing state: annotations still available after writing.");
-            }
-            collectSubscribers(annotations, env, messager);
-            checkForSubscribersToSkip(messager, indexPackage);
+//        Messager messager = processingEnv.getMessager();
+//        try {
+//            String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
+//            if (index == null) {
+//                messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
+//                        " passed to annotation processor");
+//                return false;
+//            }
+//            verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));
+//            int lastPeriod = index.lastIndexOf('.');
+//            String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null;
+//
+//            round++;
+//            if (verbose) {
+//                messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +
+//                        !annotations.isEmpty() + ", processingOver: " + env.processingOver());
+//            }
+//            if (env.processingOver()) {
+//                if (!annotations.isEmpty()) {
+//                    messager.printMessage(Diagnostic.Kind.ERROR,
+//                            "Unexpected processing state: annotations still available after processing over");
+//                    return false;
+//                }
+//            }
+//            if (annotations.isEmpty()) {
+//                return false;
+//            }
+//
+//            if (writerRoundDone) {
+//                messager.printMessage(Diagnostic.Kind.ERROR,
+//                        "Unexpected processing state: annotations still available after writing.");
+//            }
+//            collectSubscribers(annotations, env, messager);
+//            checkForSubscribersToSkip(messager, indexPackage);
+//
+//            if (!methodsByClass.isEmpty()) {
+//                createInfoIndexFile(index);
+//            } else {
+//                messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
+//            }
+//            writerRoundDone = true;
+//        } catch (RuntimeException e) {
+//            // IntelliJ does not handle exceptions nicely, so log and print a message
+//            e.printStackTrace();
+//            messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e);
+//        }
+//        return true;
 
-            if (!methodsByClass.isEmpty()) {
-                createInfoIndexFile(index);
-            } else {
-                messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
-            }
-            writerRoundDone = true;
-        } catch (RuntimeException e) {
-            // IntelliJ does not handle exceptions nicely, so log and print a message
-            e.printStackTrace();
-            messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e);
+        {
+            EventBusAutoRegisterProcessor autoRegisterProcessor = new EventBusAutoRegisterProcessor();
+            autoRegisterProcessor.init(processingEnv);
+            return autoRegisterProcessor.process(annotations, env);
         }
-        return true;
     }
 
     private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
@@ -124,7 +130,12 @@ private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnv
                     ExecutableElement method = (ExecutableElement) element;
                     if (checkHasNoErrors(method, messager)) {
                         TypeElement classElement = (TypeElement) method.getEnclosingElement();
-                        methodsByClass.putElement(classElement, method);
+                        List<ExecutableElement> methods = methodsByClass.get(classElement);
+                        if (methods == null) {
+                            methods = new ArrayList<ExecutableElement>();
+                            methodsByClass.put(classElement, methods);
+                        }
+                        methods.add(method);
                     }
                 } else {
                     messager.printMessage(Diagnostic.Kind.ERROR, "@Subscribe is only valid for methods", element);
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAutoRegisterProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAutoRegisterProcessor.java
new file mode 100644
index 00000000..293372b9
--- /dev/null
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAutoRegisterProcessor.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2018-2020 harryguo
+ * 本类的作用：客户源码在编译过程中，用本类来生成代码，该代码记录下所有@Subscribe的静态函数，在post/process时自动register。
+ * 所以，这里再重复声明一下：静态函数的@Subscribe是由EventBus系统自动注册的，这些想监听事件的静态函数不会错过任何一个Event。
+ */
+package org.greenrobot.eventbus.annotationprocessor;
+
+import org.greenrobot.eventbus.Subscribe;
+
+import java.util.Set;
+import java.util.TreeMap;
+
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic;
+
+public class EventBusAutoRegisterProcessor {
+    private Filer mFiler; //文件相关的辅助类
+    private Messager mMessager; //日志相关的辅助类
+
+    private TreeMap<String, SubscribeClass> mSubscribeClazzMap = new TreeMap<>();
+
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+        mFiler = processingEnv.getFiler();
+        mMessager = processingEnv.getMessager();
+    }
+
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+        mSubscribeClazzMap.clear();
+
+        try {
+            processSubScribeAnnotation(env);
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+            printError(e.getMessage());
+        }
+        AutoRegisterCreator creator = new AutoRegisterCreator(mSubscribeClazzMap.values());
+        try {
+            creator.createFile(mFiler);
+        } catch (Exception e) {
+            e.printStackTrace();
+            printError(e.getMessage());
+        }
+        return true;
+    }
+
+    private void processSubScribeAnnotation(RoundEnvironment roundEnv) throws IllegalArgumentException {
+        for (Element element : roundEnv.getElementsAnnotatedWith(Subscribe.class)) {
+            // 只处理静态订阅者（静态订阅者，是由我们EventBus默认注册的）
+            if (element.getModifiers().contains(Modifier.STATIC)) {
+                SubscribeClass annotatedClass = getSubscribeClass(element);
+                SubscribeMethodElement subscribedMethod = new SubscribeMethodElement(element);
+                annotatedClass.addMethod(subscribedMethod);
+            }
+        }
+    }
+
+    /**
+     * 获取/创建含有@Subscribe的函数的类
+     * @param element 使用了注解@Subscribe的函数
+     * */
+    private SubscribeClass getSubscribeClass(Element element) {
+        TypeElement typeElement = (TypeElement) element.getEnclosingElement();
+        // 包含@Subscribe 静态订阅者的类的全路径名（也就是包含了包名）
+        String fullClassName = typeElement.getQualifiedName().toString();
+        SubscribeClass annotatedClass = mSubscribeClazzMap.get(fullClassName);
+        if (annotatedClass == null) {
+            annotatedClass = new SubscribeClass(typeElement);
+            mSubscribeClazzMap.put(fullClassName, annotatedClass);
+        }
+        return annotatedClass;
+    }
+
+    private void printError(String msg, Object... args) {
+        mMessager.printMessage(Diagnostic.Kind.ERROR, String.format(msg, args));
+    }
+}
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeClass.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeClass.java
new file mode 100644
index 00000000..915fb2ed
--- /dev/null
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeClass.java
@@ -0,0 +1,28 @@
+package org.greenrobot.eventbus.annotationprocessor;
+
+import java.util.ArrayList;
+
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Created by harryguo on 2018/7/22.
+ * 本类记录的是：订阅者所在的类
+ */
+public class SubscribeClass {
+    private TypeElement mTypeElement;
+    private ArrayList<SubscribeMethodElement> mMethods = null;
+
+    public SubscribeClass(TypeElement typeElement) {
+        mTypeElement = typeElement;
+        mMethods = new ArrayList<>();
+    }
+
+    public Name getFullClassName() {
+        return mTypeElement.getQualifiedName();
+    }
+
+    public void addMethod(SubscribeMethodElement method) {
+        mMethods.add(method);
+    }
+}
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeMethodElement.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeMethodElement.java
new file mode 100644
index 00000000..f70e56ad
--- /dev/null
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/SubscribeMethodElement.java
@@ -0,0 +1,35 @@
+package org.greenrobot.eventbus.annotationprocessor;
+
+
+import org.greenrobot.eventbus.Subscribe;
+
+import java.util.List;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Created by harryguo on 2018/7/22.
+ */
+public class SubscribeMethodElement {
+    private ExecutableElement mExecutableElement;
+    private Name mMethodName;
+
+    public SubscribeMethodElement(Element element) throws IllegalArgumentException {
+        if (element.getKind() != ElementKind.METHOD) {
+            throw new IllegalArgumentException(
+                    String.format("Only methods can be annotated with @%s", Subscribe.class.getSimpleName()));
+        }
+        mExecutableElement = (ExecutableElement) element;
+        mMethodName = mExecutableElement.getSimpleName();
+        List<? extends VariableElement> parameters = mExecutableElement.getParameters();
+
+        if (parameters.size() != 1) {
+            throw new IllegalArgumentException(
+                    String.format("The method annotated with @%s must have only 1 parameter", Subscribe.class.getSimpleName()));
+        }
+    }
+}
diff --git a/build.gradle b/build.gradle
index 4bbbbde1..67106784 100644
--- a/build.gradle
+++ b/build.gradle
@@ -16,8 +16,10 @@ allprojects {
 
 if (JavaVersion.current().isJava8Compatible()) {
     allprojects {
+        // harryguo 自动生成Javadoc文档。
         tasks.withType(Javadoc) {
             options.addStringOption('Xdoclint:none', '-quiet')
+            options.encoding = "UTF-8"
         }
     }
 }
