diff --git a/EventBus/src/de/greenrobot/event/BackgroundPoster.java b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
index 00e9ee54..0de32924 100644
--- a/EventBus/src/de/greenrobot/event/BackgroundPoster.java
+++ b/EventBus/src/de/greenrobot/event/BackgroundPoster.java
@@ -17,6 +17,8 @@
 
 import android.util.Log;
 
+import java.util.concurrent.ExecutorService;
+
 /**
  * Posts events in background.
  * 
@@ -26,12 +28,22 @@
 
     private final PendingPostQueue queue;
     private final EventBus eventBus;
+    private final ExecutorService executorService;
+    private final String name;
 
     private volatile boolean executorRunning;
 
+
     BackgroundPoster(EventBus eventBus) {
+        this(eventBus, eventBus.getExecutorService(), "EventBusBackgroundThread");
+    }
+
+    BackgroundPoster(EventBus eventBus, ExecutorService executorService, String name) {
         this.eventBus = eventBus;
+        this.executorService = executorService;
+        this.name = name;
         queue = new PendingPostQueue();
+
     }
 
     public void enqueue(Subscription subscription, Object event) {
@@ -40,7 +52,7 @@ public void enqueue(Subscription subscription, Object event) {
             queue.enqueue(pendingPost);
             if (!executorRunning) {
                 executorRunning = true;
-                eventBus.getExecutorService().execute(this);
+                executorService.execute(this);
             }
         }
     }
@@ -71,4 +83,7 @@ public void run() {
         }
     }
 
+    public String getName() {
+        return name;
+    }
 }
diff --git a/EventBus/src/de/greenrobot/event/BackgroundPosterProvider.java b/EventBus/src/de/greenrobot/event/BackgroundPosterProvider.java
new file mode 100644
index 00000000..6de9cba7
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/BackgroundPosterProvider.java
@@ -0,0 +1,14 @@
+package de.greenrobot.event;
+
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Created by matous.voldrich on 12/11/2014.
+ */
+public interface BackgroundPosterProvider {
+    void register(String name, ExecutorService service) throws EventBusException;
+
+    boolean posterExists(String name);
+
+    BackgroundPoster getPoster(String name);
+}
diff --git a/EventBus/src/de/greenrobot/event/BackgroundPosterProviderImpl.java b/EventBus/src/de/greenrobot/event/BackgroundPosterProviderImpl.java
new file mode 100644
index 00000000..fedef76b
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/BackgroundPosterProviderImpl.java
@@ -0,0 +1,37 @@
+package de.greenrobot.event;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Created by matous.voldrich on 12/11/2014.
+ */
+public class BackgroundPosterProviderImpl implements BackgroundPosterProvider {
+
+    private final Map<String, BackgroundPoster> backgroundPosterMap = new HashMap<String, BackgroundPoster>();
+    private EventBus eventBus;
+
+    public BackgroundPosterProviderImpl(EventBus eventBus) {
+        this.eventBus = eventBus;
+    }
+
+    @Override
+    public void register(String name, ExecutorService service) throws EventBusException {
+        BackgroundPoster backgroundPoster = new BackgroundPoster(eventBus, service, name);
+        if (backgroundPosterMap.containsKey(name)) {
+            throw new EventBusException("Executor with name " + name + " is already registered");
+        }
+        backgroundPosterMap.put(name, backgroundPoster);
+    }
+
+    @Override
+    public boolean posterExists(String name) {
+        return backgroundPosterMap.containsKey(name);
+    }
+
+    @Override
+    public BackgroundPoster getPoster(String name) {
+        return backgroundPosterMap.get(name);
+    }
+}
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index e97ed2a9..256cc2b7 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -44,7 +44,6 @@
     static volatile EventBus defaultInstance;
 
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
-    private static final String DEFAULT_METHOD_NAME = "onEvent";
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();
 
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
@@ -72,6 +71,8 @@ protected PostingThreadState initialValue() {
     private final boolean sendNoSubscriberEvent;
     private final boolean eventInheritance;
 
+    private final BackgroundPosterProvider backgroundPosterProvider;
+
     /** Convenience singleton for apps using a process-wide EventBus instance. */
     public static EventBus getDefault() {
         if (defaultInstance == null) {
@@ -102,7 +103,7 @@ public EventBus() {
         this(DEFAULT_BUILDER);
     }
 
-    EventBus(EventBusBuilder builder) {
+    public EventBus(EventBusBuilder builder) {
         subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();
         typesBySubscriber = new HashMap<Object, List<Class<?>>>();
         stickyEvents = new ConcurrentHashMap<Class<?>, Object>();
@@ -117,8 +118,17 @@ public EventBus() {
         throwSubscriberException = builder.throwSubscriberException;
         eventInheritance = builder.eventInheritance;
         executorService = builder.executorService;
+        backgroundPosterProvider = new BackgroundPosterProviderImpl(this);
     }
 
+    /**
+     * Registers a new background executor under specified name.
+     * Event name which wants to use this executor then must have onEventBackgroundThread + Name.
+     * Note that this method must be called before registering new object withing event bus.
+     **/
+    public void registerExecutor(String name, ExecutorService executorService) {
+        backgroundPosterProvider.register(name, executorService);
+    }
 
     /**
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
@@ -131,7 +141,7 @@ public EventBus() {
      * "onEventMainThread".
      */
     public void register(Object subscriber) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, 0);
+        register(subscriber, false, 0);
     }
 
     /**
@@ -141,15 +151,7 @@ public void register(Object subscriber) {
      * delivery among subscribers with different {@link ThreadMode}s!
      */
     public void register(Object subscriber, int priority) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, priority);
-    }
-
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void register(Object subscriber, String methodName) {
-        register(subscriber, methodName, false, 0);
+        register(subscriber, false, priority);
     }
 
     /**
@@ -157,7 +159,7 @@ public void register(Object subscriber, String methodName) {
      * {@link #postSticky(Object)}) to the given subscriber.
      */
     public void registerSticky(Object subscriber) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, 0);
+        register(subscriber, true, 0);
     }
 
     /**
@@ -165,76 +167,17 @@ public void registerSticky(Object subscriber) {
      * {@link #postSticky(Object)}) to the given subscriber.
      */
     public void registerSticky(Object subscriber, int priority) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, priority);
-    }
-
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void registerSticky(Object subscriber, String methodName) {
-        register(subscriber, methodName, true, 0);
+        register(subscriber, true, priority);
     }
 
-    private synchronized void register(Object subscriber, String methodName, boolean sticky, int priority) {
+    private synchronized void register(Object subscriber, boolean sticky, int priority) {
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass(),
-                methodName);
+                backgroundPosterProvider);
         for (SubscriberMethod subscriberMethod : subscriberMethods) {
             subscribe(subscriber, subscriberMethod, sticky, priority);
         }
     }
 
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void register(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, DEFAULT_METHOD_NAME, false, eventType, moreEventTypes);
-    }
-
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void register(Object subscriber, String methodName, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, methodName, false, eventType, moreEventTypes);
-    }
-
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void registerSticky(Object subscriber, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, DEFAULT_METHOD_NAME, true, eventType, moreEventTypes);
-    }
-
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public void registerSticky(Object subscriber, String methodName, Class<?> eventType, Class<?>... moreEventTypes) {
-        register(subscriber, methodName, true, eventType, moreEventTypes);
-    }
-
-    private synchronized void register(Object subscriber, String methodName, boolean sticky, Class<?> eventType,
-                                       Class<?>... moreEventTypes) {
-        Class<?> subscriberClass = subscriber.getClass();
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass,
-                methodName);
-        for (SubscriberMethod subscriberMethod : subscriberMethods) {
-            if (eventType == subscriberMethod.eventType) {
-                subscribe(subscriber, subscriberMethod, sticky, 0);
-            } else if (moreEventTypes != null) {
-                for (Class<?> eventType2 : moreEventTypes) {
-                    if (eventType2 == subscriberMethod.eventType) {
-                        subscribe(subscriber, subscriberMethod, sticky, 0);
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {
         Class<?> eventType = subscriberMethod.eventType;
@@ -285,28 +228,6 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /**
-     * @deprecated For simplification of the API, this method will be removed in the future.
-     */
-    @Deprecated
-    public synchronized void unregister(Object subscriber, Class<?>... eventTypes) {
-        if (eventTypes.length == 0) {
-            throw new IllegalArgumentException("Provide at least one event class");
-        }
-        List<Class<?>> subscribedClasses = typesBySubscriber.get(subscriber);
-        if (subscribedClasses != null) {
-            for (Class<?> eventType : eventTypes) {
-                unubscribeByEventType(subscriber, eventType);
-                subscribedClasses.remove(eventType);
-            }
-            if (subscribedClasses.isEmpty()) {
-                typesBySubscriber.remove(subscriber);
-            }
-        } else {
-            Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
-        }
-    }
-
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
     private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
@@ -527,7 +448,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 }
                 break;
             case BackgroundThread:
-                if (isMainThread) {
+                if (subscription.subscriberMethod.backgroundPoster != null) {
+                    subscription.subscriberMethod.backgroundPoster.enqueue(subscription, event);
+                } else if (isMainThread) {
                     backgroundPoster.enqueue(subscription, event);
                 } else {
                     invokeSubscriber(subscription, event);
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethod.java b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
index 5e0df398..2be5ed08 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethod.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
@@ -21,13 +21,16 @@
     final Method method;
     final ThreadMode threadMode;
     final Class<?> eventType;
+    final BackgroundPoster backgroundPoster;
+
     /** Used for efficient comparison */
     String methodString;
 
-    SubscriberMethod(Method method, ThreadMode threadMode, Class<?> eventType) {
+    SubscriberMethod(Method method, ThreadMode threadMode, Class<?> eventType, BackgroundPoster backgroundPoster) {
         this.method = method;
         this.threadMode = threadMode;
         this.eventType = eventType;
+        this.backgroundPoster = backgroundPoster;
     }
 
     @Override
@@ -50,6 +53,9 @@ private synchronized void checkMethodString() {
             builder.append(method.getDeclaringClass().getName());
             builder.append('#').append(method.getName());
             builder.append('(').append(eventType.getName());
+            if (backgroundPoster != null) {
+                builder.append('@').append(backgroundPoster.getName());
+            }
             methodString = builder.toString();
         }
     }
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 556f9466..a5687ee8 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -27,6 +27,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 class SubscriberMethodFinder {
+    private static final String ON_EVENT_METHOD_NAME = "onEvent";
+
     /*
      * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
      * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
@@ -49,8 +51,8 @@
         }
     }
 
-    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass, String eventMethodName) {
-        String key = subscriberClass.getName() + '.' + eventMethodName;
+    List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass, BackgroundPosterProvider backgroundPosterProvider) {
+        String key = subscriberClass.getName();
         List<SubscriberMethod> subscriberMethods;
         synchronized (methodCache) {
             subscriberMethods = methodCache.get(key);
@@ -62,6 +64,7 @@
         Class<?> clazz = subscriberClass;
         HashSet<String> eventTypesFound = new HashSet<String>();
         StringBuilder methodKeyBuilder = new StringBuilder();
+
         while (clazz != null) {
             String name = clazz.getName();
             if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
@@ -73,19 +76,28 @@
             Method[] methods = clazz.getDeclaredMethods();
             for (Method method : methods) {
                 String methodName = method.getName();
-                if (methodName.startsWith(eventMethodName)) {
+                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
                     int modifiers = method.getModifiers();
                     if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                        BackgroundPoster backgroundPoster = null;
                         Class<?>[] parameterTypes = method.getParameterTypes();
                         if (parameterTypes.length == 1) {
-                            String modifierString = methodName.substring(eventMethodName.length());
+                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
                             ThreadMode threadMode;
                             if (modifierString.length() == 0) {
                                 threadMode = ThreadMode.PostThread;
                             } else if (modifierString.equals("MainThread")) {
                                 threadMode = ThreadMode.MainThread;
-                            } else if (modifierString.equals("BackgroundThread")) {
+                            } else if (modifierString.startsWith("BackgroundThread")) {
                                 threadMode = ThreadMode.BackgroundThread;
+                                String executorName = modifierString.substring("BackgroundThread".length());
+                                if (executorName.length() > 0) {
+                                    if (!backgroundPosterProvider.posterExists(executorName)) {
+                                        throw new EventBusException("Unknown background executor name: " + executorName
+                                                + ". Check that executor is registered in event bus.");
+                                    }
+                                    backgroundPoster = backgroundPosterProvider.getPoster(executorName);
+                                }
                             } else if (modifierString.equals("Async")) {
                                 threadMode = ThreadMode.Async;
                             } else {
@@ -102,7 +114,7 @@
                             String methodKey = methodKeyBuilder.toString();
                             if (eventTypesFound.add(methodKey)) {
                                 // Only add if not already found in a sub class
-                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType, backgroundPoster));
                             }
                         }
                     } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
@@ -115,7 +127,7 @@
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
-                    + eventMethodName);
+                    + ON_EVENT_METHOD_NAME);
         } else {
             synchronized (methodCache) {
                 methodCache.put(key, subscriberMethods);
