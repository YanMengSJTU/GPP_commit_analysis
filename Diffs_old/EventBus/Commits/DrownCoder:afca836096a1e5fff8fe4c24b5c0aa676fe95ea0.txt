diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 49af5592..e6eeb0df 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -112,7 +112,7 @@
     }
 
     private FindState prepareFindState() {
-        //有点简单粗暴都意思。。。
+        //有点简单粗暴的意思。。。
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
                 FindState state = FIND_STATE_POOL[i];
@@ -163,6 +163,8 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             //通过注释其实也可以看到EventBus团队对于反射性能都考虑，所以用getDeclaredMethods而不是getMethods
             //获取都不包括父类和接口都方法，包括私有都，
+            //这种获取方式不会获取父类的public方法，所以要去父类中查找并添加订阅方法（就要去父类中找就要执行moeToUperclass）
+            //但是父类中如果找到了被重写的public方法，还是会走methodClassOld.isAssignableFrom(methodClass)也会返回false防止再添加父类中的订阅方法。
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
@@ -242,10 +244,11 @@ boolean checkAdd(Method method, Class<?> eventType) {
             //HashMap,一般一个Event只有一个方法
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
+                //不存在该参数类型的方法，直接添加到订阅者
                 return true;
             } else {
                 if (existing instanceof Method) {
-                    //存在多个方法都能接受Event,比如一个接受子类，一个接受父类，会返回True,
+                    //存在相同的参数类型，代表参数类型相同，但可能方法名不同，或者方法名也相同(父类中的被重写的方法)
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
