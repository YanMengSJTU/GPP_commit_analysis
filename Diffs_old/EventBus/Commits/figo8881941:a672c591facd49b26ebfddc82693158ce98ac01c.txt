diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 6d4c9c95..733c7047 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -165,9 +165,12 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            //这里只获取自身定义的方法，不包括父类的
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+            //这里是获取所有的方法，包括从父类继承的
+            //所以findState.skipSuperClasses = true
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
@@ -247,9 +250,9 @@ boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
             //一般情况下，一个订阅者不会出现有多个订阅方法订阅相同类型的事件
-            //如果有，可能两种情况
-            //1.真的定义了多个方法订阅相同类型的事件
-            //2.因为继承关系，父类和自身定义了方法订阅相同类型的事件
+            //如果有，可能情况如下：
+            //1.真的定义了多个方法订阅相同类型的事件。这个可以有，检查会通过。
+            //2.继承，并且重写了父类里面的某个订阅方法。这个检查的时候，只会让子类重写的方法通过。
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
                 //如果还没有存在订阅该类型事件的方法，直接返回true
