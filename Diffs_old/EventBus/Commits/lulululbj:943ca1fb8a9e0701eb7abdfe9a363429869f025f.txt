diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..9bce99a6 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -46,6 +46,7 @@
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    // Map集合，key是事件的类，value是该事件的所有的订阅者以及处理该事件的回调方法的集合
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     private final Map<Class<?>, Object> stickyEvents;
@@ -110,14 +111,18 @@ public EventBus() {
 
     EventBus(EventBusBuilder builder) {
         logger = builder.getLogger();
+        // Map集合，key是事件的类，value是该事件的所有的订阅者以及处理该事件的回调方法的集合
         subscriptionsByEventType = new HashMap<>();
+        // Map集合，key是订阅者对象，value是该订阅者订阅的事件类型集合
         typesBySubscriber = new HashMap<>();
+        // 粘性事件集合
         stickyEvents = new ConcurrentHashMap<>();
         mainThreadSupport = builder.getMainThreadSupport();
         mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
+        // 订阅方法查找类
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
         logSubscriberExceptions = builder.logSubscriberExceptions;
@@ -125,6 +130,7 @@ public EventBus() {
         sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
         sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
         throwSubscriberException = builder.throwSubscriberException;
+        // 是否支持事件继承
         eventInheritance = builder.eventInheritance;
         executorService = builder.executorService;
     }
@@ -138,19 +144,24 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+        // 获取订阅者的class对象
         Class<?> subscriberClass = subscriber.getClass();
+        // 查找订阅者所有的回调方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
+                // 订阅
                 subscribe(subscriber, subscriberMethod);
             }
         }
     }
 
     // Must be called in synchronized block
+    // 必须在同步代码块中执行
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
-        Class<?> eventType = subscriberMethod.eventType;
+        Class<?> eventType = subscriberMethod.eventType;// 订阅的事件类型
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+        // 判断 subscriptionsByEventType 中是否添加过该事件类型，未添加则添加，已添加，报错
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,6 +173,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 根据优先级priority添加newSubscription
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -177,6 +189,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        // 黏性事件，立即post
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
@@ -239,6 +252,7 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
 
     /** Unregisters the given subscriber from all event classes. */
     public synchronized void unregister(Object subscriber) {
+        // 获取该订阅者订阅的所有事件类型
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
@@ -252,7 +266,9 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        // 获取当前线程的posting状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        // 获取当前线程的事件队列
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
@@ -378,7 +394,7 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
-        if (eventInheritance) {
+        if (eventInheritance) { //是否触发订阅了该事件(eventClass)的父类,以及接口的类的响应方法.
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -386,6 +402,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            // 发送单个事件
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
@@ -394,7 +411,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
             }
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
-                post(new NoSubscriberEvent(this, event));
+                post(new NoSubscriberEvent(this, event)); // 发送了未被订阅的事件
             }
         }
     }
@@ -402,6 +419,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            // 获取订阅了该事件的Subscription
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
@@ -410,6 +428,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 发送事件
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..53efeeac 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,43 +53,49 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 先从缓存中查找，若存在直接返回
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
 
+        // 是否忽略生成的索引
         if (ignoreGeneratedIndex) {
+            // 利用反射获取订阅对象类中的回调方法信息
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 利用apt生成的MyEventBusIndex类中索引订阅对象类中的回调方法信息
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
-            METHOD_CACHE.put(subscriberClass, subscriberMethods);
+            METHOD_CACHE.put(subscriberClass, subscriberMethods); // 加入缓存
             return subscriberMethods;
         }
     }
 
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
-        FindState findState = prepareFindState();
-        findState.initForSubscriber(subscriberClass);
+        // 最新版的EventBus3中，寻找方法时所需的临时变量都被封装到了FindState这个静态内部类中
+        FindState findState = prepareFindState(); // 到对象池中取得上下文，避免频繁创造对象
+        findState.initForSubscriber(subscriberClass); // 初始化寻找方法的上下文
         while (findState.clazz != null) {
-            findState.subscriberInfo = getSubscriberInfo(findState);
+            findState.subscriberInfo = getSubscriberInfo(findState); // 获取订阅者信息
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
+                    // checkAdd是为了避免在父类中找到的方法是被子类重写的，此时应该保证回调时执行子类的方法
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                         findState.subscriberMethods.add(subscriberMethod);
                     }
                 }
-            } else {
+            } else { // 索引中无订阅者信息，改为使用运行时注解和反射去寻找
                 findUsingReflectionInSingleClass(findState);
             }
-            findState.moveToSuperclass();
+            findState.moveToSuperclass(); // 上下文切换成父类，继续寻找
         }
-        return getMethodsAndRelease(findState);
+        return getMethodsAndRelease(findState); // 找完后，释放FindState进对象池，并返回找到的回调方法
     }
 
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
@@ -122,11 +128,11 @@ private FindState prepareFindState() {
     private SubscriberInfo getSubscriberInfo(FindState findState) {
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
-            if (findState.clazz == superclassInfo.getSubscriberClass()) {
+            if (findState.clazz == superclassInfo.getSubscriberClass()) { // 确定是所需查找的类
                 return superclassInfo;
             }
         }
-        if (subscriberInfoIndexes != null) {
+        if (subscriberInfoIndexes != null) { // 从我们传进来的subscriberInfoIndexes中获取相应的订阅者信息
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
                 if (info != null) {
@@ -141,34 +147,41 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 使用运行时注解和反射寻找
             findUsingReflectionInSingleClass(findState);
+            // 寻找父类
             findState.moveToSuperclass();
         }
-        return getMethodsAndRelease(findState);
+        return getMethodsAndRelease(findState);// 找完后，释放FindState进对象池，并返回找到的回调方法
     }
 
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            // 反射得到订阅者类的所有方法
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+        // 遍历所有方法找到订阅方法
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            // 订阅方法必须是 public, non-static, and non-abstract 的
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                // 订阅方法只能有一个事件参数
                 if (parameterTypes.length == 1) {
+                    // 获取 Subscribe 注解
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
-                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
+                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky())); // 生成SubscriberMethod并添加
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
