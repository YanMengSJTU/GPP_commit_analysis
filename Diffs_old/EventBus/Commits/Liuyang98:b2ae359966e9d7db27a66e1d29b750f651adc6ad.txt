diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 44296f9d..9113dec7 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -73,6 +73,7 @@ protected PostingThreadState initialValue() {
     private final boolean logNoSubscriberMessages;
     private final boolean sendSubscriberExceptionEvent;
     private final boolean sendNoSubscriberEvent;
+//  默认为true，即EventBus会考虑事件的继承树
     private final boolean eventInheritance;
 
     private final int indexCount;
@@ -174,12 +175,13 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
 //       将订阅封装类和订阅对象 再次封装
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
-//        从MAP中获取该事件类型的订阅列表，如果没有，则创建，并添加到MAP中
+//        从MAP中获取该事件类型的订阅列表，如果没有，则创建，并添加到MAP中    Map<事件类型,List<新订阅封装类>>
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+//            判断新订阅对象是否已存在，若已经存在，则抛出异常
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
@@ -195,14 +197,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
-//      通过订阅对象，获取该订阅对象所对应的订阅事件列表。 如果没有，则创建，并添加到MAP中
+//      通过订阅对象，获取该订阅对象所对应的订阅事件列表。 如果没有，则创建，并添加到MAP中    MAP<对象,List<事件类型>>，  用于判断是否注册和反注册所用。
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
 
-//      将该事件加入订阅
+//      将事件类型加入对象下的List
         subscribedEvents.add(eventType);
 
 //        判断是否粘性事件
@@ -299,9 +301,10 @@ public void post(Object event) {
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
+//            循环遍历，直到列表中无事件
             try {
                 while (!eventQueue.isEmpty()) {
-//                    开始一个个post 分发列表中的事件
+//                    开始发布一个事件
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
