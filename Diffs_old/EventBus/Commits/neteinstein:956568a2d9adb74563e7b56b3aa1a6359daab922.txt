diff --git a/EventBus/src/de/greenrobot/event/AsyncTrackedPoster.java b/EventBus/src/de/greenrobot/event/AsyncTrackedPoster.java
new file mode 100644
index 00000000..f5fd858f
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/AsyncTrackedPoster.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2015 Pedro Vicente (neteinstein@gmail.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Future;
+
+import de.greenrobot.event.models.AbstractEvent;
+import de.greenrobot.event.models.EventBusAsyncTrackedTask;
+
+/**
+ * Posts events in background.
+ * 
+ * @author Pedro Vicente
+ */
+class AsyncTrackedPoster implements Runnable {
+
+    private final PendingPostQueue queue;
+
+    private final EventBus eventBus;
+
+    /**
+     * List of current submitted/executing tasks of EventBus
+     */
+    private ConcurrentHashMap<String, List<EventBusAsyncTrackedTask>> mEventBusTaskList = null;
+
+    AsyncTrackedPoster(EventBus eventBus) {
+        this.eventBus = eventBus;
+        mEventBusTaskList = new ConcurrentHashMap<String, List<EventBusAsyncTrackedTask>>();
+        queue = new PendingPostQueue();
+    }
+
+    public void enqueue(Subscription subscription, Object event) {
+        if (event instanceof AbstractEvent) {
+            AbstractEvent abstractEvent = ((AbstractEvent) event);
+            // Add this to have a single identification for each event that targets a subscriber to be able to remove
+            // the specific one
+            abstractEvent.setSubscriberHashCode(subscription.subscriber.hashCode());
+            submitEvent(subscription, abstractEvent);
+        } else {
+            PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+            queue.enqueue(pendingPost);
+            EventBus.executorService.execute(this);
+        }
+
+    }
+
+    @Override
+    public void run() {
+        PendingPost pendingPost = queue.poll();
+        if (pendingPost == null) {
+            throw new IllegalStateException("No pending post available");
+        }
+        eventBus.invokeSubscriber(pendingPost);
+
+        if (pendingPost.event instanceof AbstractEvent) {
+            // remove the event from the tracker after finishing execution
+            remove((AbstractEvent) pendingPost.event);
+        }
+    }
+
+    public void submitEvent(Subscription subscription, AbstractEvent event) {
+
+        // There is at least one event of this type.
+        if (mEventBusTaskList.containsKey(event.getEventType())) {
+
+            List<EventBusAsyncTrackedTask> taskList = mEventBusTaskList.get(event.getEventType());
+            Iterator<EventBusAsyncTrackedTask> it = taskList.iterator();
+
+            while (it.hasNext()) {
+                EventBusAsyncTrackedTask task = it.next();
+                AbstractEvent storedEvent = task.getEvent();
+
+                if (AbstractEvent.compareEventUniqueCode(storedEvent, event)
+                        && AbstractEvent.compareEventSubscribersHashCode(storedEvent, event)) {
+
+                    Future future = task.getFuture();
+
+                    switch (event.getCollisionBehavior()) {
+                    case IGNORE_NEW_EVENT:
+                        if (!future.isCancelled() && !future.isDone()) {
+                            return;
+                        } else {
+                            // removing as it has finished so should not be here anymore (just to be safe)
+                            taskList.remove(task);
+                        }
+                        break;
+                    case REPLACE_WITH_NEW_EVENT:
+                    default:
+                        if (!future.isCancelled() && !future.isDone()) {
+                            future.cancel(true);
+                        }
+                        taskList.remove(task);
+                        break;
+
+                    }
+                }
+            }
+
+            PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+            queue.enqueue(pendingPost);
+            Future future = EventBus.executorService.submit(this);
+
+            EventBusAsyncTrackedTask task = new EventBusAsyncTrackedTask();
+            task.setFuture(future);
+            task.setEvent(event);
+
+            taskList.add(task);
+
+        } else {
+            // If its a new type of event, add it to the map with a new list
+
+            PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+            queue.enqueue(pendingPost);
+            Future future = EventBus.executorService.submit(this);
+
+            EventBusAsyncTrackedTask task = new EventBusAsyncTrackedTask();
+            task.setFuture(future);
+            task.setEvent(event);
+
+            List<EventBusAsyncTrackedTask> taskList = Collections
+                    .synchronizedList(new ArrayList<EventBusAsyncTrackedTask>());
+            taskList.add(task);
+
+            mEventBusTaskList.put(event.getEventType(), taskList);
+
+        }
+    }
+
+    /**
+     * Remove an event/runnable from the current tracking. It is used when a method has finished executing.
+     *
+     * @param event The event to remove
+     */
+    private void remove(AbstractEvent event) {
+
+        if (mEventBusTaskList.containsKey(event.getEventType())) {
+            List<EventBusAsyncTrackedTask> tasks = mEventBusTaskList.get(event.getEventType());
+            Iterator<EventBusAsyncTrackedTask> it = tasks.iterator();
+            while (it.hasNext()) {
+                EventBusAsyncTrackedTask task = it.next();
+                AbstractEvent storedEvent = task.getEvent();
+
+                boolean remove = false;
+                boolean breakCycle = false;
+
+                if (AbstractEvent.compareEventUniqueCode(storedEvent, event)
+                        && AbstractEvent.compareEventSubscribersHashCode(storedEvent, event)) {
+                    tasks.remove(task);
+                    break;
+                }
+            }
+
+            // If there are no events of that type, clear it from the map.
+            if (tasks.size() == 0) {
+                mEventBusTaskList.remove(event.getEventType());
+            }
+        }
+    }
+
+    /**
+     * Cancels and removes an event from the tracking
+     *
+     * @param eventToCancel The event to cancel
+     */
+    public int cancel(AbstractEvent eventToCancel) {
+        int cancelledEvent = 0;
+
+        if (mEventBusTaskList.containsKey(eventToCancel.getEventType())) {
+            List<EventBusAsyncTrackedTask> tasks = mEventBusTaskList.get(eventToCancel.getEventType());
+            Iterator<EventBusAsyncTrackedTask> it = tasks.iterator();
+            while (it.hasNext()) {
+                EventBusAsyncTrackedTask task = it.next();
+                AbstractEvent storedEvent = task.getEvent();
+
+                //Here the subscriber code is not validated in purpose to cancel all events from all subscribers
+                if (AbstractEvent.compareEventUniqueCode(storedEvent, eventToCancel)) {
+
+                    Future future = task.getFuture();
+                    if (!future.isDone()) {
+                        future.cancel(true);
+                    }
+                    tasks.remove(storedEvent);
+                    cancelledEvent++;
+                }
+            }
+
+            // If there are no events of that type, clear it from the map.
+            if (tasks.size() == 0) {
+                mEventBusTaskList.remove(eventToCancel.getEventType());
+            }
+        }
+
+        return cancelledEvent;
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index dd5f14ad..958b12fe 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -15,6 +15,9 @@
  */
 package de.greenrobot.event;
 
+import android.os.Looper;
+import android.util.Log;
+
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -23,10 +26,12 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
-import android.os.Looper;
-import android.util.Log;
+import de.greenrobot.event.models.AbstractEvent;
 
 /**
  * EventBus is a central publish/subscribe event system for Android. Events are posted ({@link #post(Object)} to the
@@ -38,7 +43,9 @@
  * @author Markus Junginger, greenrobot
  */
 public class EventBus {
-    static ExecutorService executorService = Executors.newCachedThreadPool();
+    private static Integer asyncMaxThreads = Integer.MAX_VALUE;
+
+    static ExecutorService executorService = null;
 
     /** Log tag, apps may override it. */
     public static String TAG = "Event";
@@ -59,10 +66,10 @@ protected PostingThreadState initialValue() {
         }
     };
 
-
     private final HandlerPoster mainThreadPoster;
     private final BackgroundPoster backgroundPoster;
     private final AsyncPoster asyncPoster;
+    private final AsyncTrackedPoster asyncTrackedPoster;
     private final SubscriberMethodFinder subscriberMethodFinder;
 
     private boolean subscribed;
@@ -74,6 +81,8 @@ public static EventBus getDefault() {
         if (defaultInstance == null) {
             synchronized (EventBus.class) {
                 if (defaultInstance == null) {
+                    executorService = new ThreadPoolExecutor(0, asyncMaxThreads, 60L, TimeUnit.SECONDS,
+                            new SynchronousQueue<Runnable>());
                     defaultInstance = new EventBus();
                 }
             }
@@ -112,6 +121,7 @@ public EventBus() {
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
+        asyncTrackedPoster = new AsyncTrackedPoster(this);
         subscriberMethodFinder = new SubscriberMethodFinder();
         logSubscriberExceptions = true;
     }
@@ -189,9 +199,9 @@ private synchronized void register(Object subscriber, String methodName, boolean
         for (SubscriberMethod subscriberMethod : subscriberMethods) {
             subscribe(subscriber, subscriberMethod, sticky, priority);
         }
-        
-        if(losslessState){
-        	checkQueue();
+
+        if (losslessState) {
+            checkQueue();
         }
     }
 
@@ -258,7 +268,9 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boo
         } else {
             for (Subscription subscription : subscriptions) {
                 if (subscription.equals(newSubscription)) {
-                    throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
+                    throw new EventBusException("Subscriber "
+                            + subscriber.getClass()
+                            + " already registered to event "
                             + eventType);
                 }
             }
@@ -366,18 +378,18 @@ public void post(Object event) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
-            	int queuePosition = 0;
-            	
+                int queuePosition = 0;
+
                 while (!eventQueue.isEmpty()) {
-                	if(queuePosition < eventQueue.size()){
-	                	if(typesBySubscriber.containsKey(eventQueue.get(queuePosition))){
-	                		postSingleEvent(eventQueue.remove(queuePosition), postingState);
-	                	}else if(queuePosition < eventQueue.size() ){
-	                		queuePosition++;
-	                	}
-                	}else{
-                		break;
-                	}
+                    if (queuePosition < eventQueue.size()) {
+                        if (typesBySubscriber.containsKey(eventQueue.get(queuePosition))) {
+                            postSingleEvent(eventQueue.remove(queuePosition), postingState);
+                        } else if (queuePosition < eventQueue.size()) {
+                            queuePosition++;
+                        }
+                    } else {
+                        break;
+                    }
                 }
             } finally {
                 postingState.isPosting = false;
@@ -385,12 +397,15 @@ public void post(Object event) {
             }
         }
     }
-    
-    /** Everytime some object registers, it validates if the queue is empty, if not checks if someone is listening and if it is sends the events */
-    private void checkQueue(){    	
-    	PostingThreadState postingState = currentPostingThreadState.get();
+
+    /**
+     * Everytime some object registers, it validates if the queue is empty, if not checks if someone is listening and if
+     * it is sends the events
+     */
+    private void checkQueue() {
+        PostingThreadState postingState = currentPostingThreadState.get();
         final List<Object> eventQueue = postingState.eventQueue;
-        
+
         if (postingState.isPosting || eventQueue.isEmpty()) {
             return;
         } else {
@@ -400,27 +415,28 @@ private void checkQueue(){
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
-            	int queuePosition = 0;
-            	
+                int queuePosition = 0;
+
                 while (!eventQueue.isEmpty()) {
-                	if(queuePosition < eventQueue.size()){
-                		final Object ob = eventQueue.get(queuePosition);
-                		boolean hasSubscriber = false;
-	                	for(List<Class<?>> clazzes : typesBySubscriber.values()){
-	                		for(Class<?> clazz : clazzes){
-		                		if(clazz.getName().equals(ob.getClass().getName())){
-		                			postSingleEvent(eventQueue.remove(queuePosition), postingState);
-		                			hasSubscriber = true;
-		                			//break; Should not break. Although not very likely, there can be more than one subscriber registered here already.
-		                		}
-	                		}
-	                	}
-	                	if(!hasSubscriber && queuePosition < eventQueue.size() ){
-	                		queuePosition++;
-	                	}
-                	}else{
-                		break;
-                	}
+                    if (queuePosition < eventQueue.size()) {
+                        final Object ob = eventQueue.get(queuePosition);
+                        boolean hasSubscriber = false;
+                        for (List<Class<?>> clazzes : typesBySubscriber.values()) {
+                            for (Class<?> clazz : clazzes) {
+                                if (clazz.getName().equals(ob.getClass().getName())) {
+                                    postSingleEvent(eventQueue.remove(queuePosition), postingState);
+                                    hasSubscriber = true;
+                                    // break; Should not break. Although not very likely, there can be more than one
+                                    // subscriber registered here already.
+                                }
+                            }
+                        }
+                        if (!hasSubscriber && queuePosition < eventQueue.size()) {
+                            queuePosition++;
+                        }
+                    } else {
+                        break;
+                    }
                 }
             } finally {
                 postingState.isPosting = false;
@@ -451,6 +467,15 @@ public void cancelEventDelivery(Object event) {
         postingState.canceled = true;
     }
 
+    /**
+     * Attempts to cancel a future of a event run on AsyncTracked. It will do nothing to events on other modes.
+     * 
+     * @return the number of single events cancelled (a single event is a combination of event + subscriber)
+     */
+    public int cancelEvent(AbstractEvent event) {
+        return asyncTrackedPoster.cancel(event);
+    }
+
     /**
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access. This can be {@link #registerSticky(Object)} or
@@ -552,7 +577,8 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
-    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+    private Future postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        Future future = null;
         switch (subscription.subscriberMethod.threadMode) {
         case PostThread:
             invokeSubscriber(subscription, event);
@@ -574,9 +600,14 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         case Async:
             asyncPoster.enqueue(subscription, event);
             break;
+        case AsyncTracked:
+            asyncTrackedPoster.enqueue(subscription, event);
+            break;
         default:
             throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
         }
+
+        return future;
     }
 
     /** Finds all Class objects including super classes and interfaces. */
@@ -629,14 +660,19 @@ void invokeSubscriber(Subscription subscription, Object event) throws Error {
             Throwable cause = e.getCause();
             if (event instanceof SubscriberExceptionEvent) {
                 // Don't send another SubscriberExceptionEvent to avoid infinite event recursion, just log
-                Log.e(TAG, "SubscriberExceptionEvent subscriber " + subscription.subscriber.getClass()
+                Log.e(TAG, "SubscriberExceptionEvent subscriber "
+                        + subscription.subscriber.getClass()
                         + " threw an exception", cause);
                 SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;
-                Log.e(TAG, "Initial event " + exEvent.causingEvent + " caused exception in "
+                Log.e(TAG, "Initial event "
+                        + exEvent.causingEvent
+                        + " caused exception in "
                         + exEvent.causingSubscriber, exEvent.throwable);
             } else {
                 if (logSubscriberExceptions) {
-                    Log.e(TAG, "Could not dispatch event: " + event.getClass() + " to subscribing class "
+                    Log.e(TAG, "Could not dispatch event: "
+                            + event.getClass()
+                            + " to subscribing class "
                             + subscription.subscriber.getClass(), cause);
                 }
                 SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,
@@ -663,12 +699,25 @@ void invokeSubscriber(Subscription subscription, Object event) throws Error {
         void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
     }
 
-	public boolean isLosslessState() {
-		return losslessState;
-	}
+    public boolean isLosslessState() {
+        return losslessState;
+    }
+
+    public void setLosslessState(boolean losslessState) {
+        this.losslessState = losslessState;
+    }
 
-	public void setLosslessState(boolean losslessState) {
-		this.losslessState = losslessState;
-	}
+    public static Integer getAsyncMaxThreads() {
+        return asyncMaxThreads;
+    }
 
+    /**
+     * Max number of threads of Async mode. This MUST be set BEFORE initializing the EventBus or else it will not have
+     * any influence
+     * 
+     * @param asyncMaxThreads Number of threads
+     */
+    public static void setAsyncMaxThreads(Integer asyncMaxThreads) {
+        EventBus.asyncMaxThreads = asyncMaxThreads;
+    }
 }
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index f3ec4628..346440da 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.event;
 
+import android.util.Log;
+
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
@@ -24,8 +26,6 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import android.util.Log;
-
 class SubscriberMethodFinder {
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC;
     private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
@@ -70,6 +70,8 @@
                                 threadMode = ThreadMode.BackgroundThread;
                             } else if (modifierString.equals("Async")) {
                                 threadMode = ThreadMode.Async;
+                            } else if (modifierString.equals("AsyncTracked")) {
+                                threadMode = ThreadMode.AsyncTracked;
                             } else {
                                 if (skipMethodVerificationForClasses.containsKey(clazz)) {
                                     continue;
diff --git a/EventBus/src/de/greenrobot/event/ThreadMode.java b/EventBus/src/de/greenrobot/event/ThreadMode.java
index 4022ace5..85cec8e9 100644
--- a/EventBus/src/de/greenrobot/event/ThreadMode.java
+++ b/EventBus/src/de/greenrobot/event/ThreadMode.java
@@ -53,5 +53,17 @@
      * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
      * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.
      */
-    Async
+    Async,
+
+    /**
+     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
+     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
+     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
+     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus
+     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications. This is
+     * different from the simple Async mode as you can manage the events running (avoid the same event to be run in 2
+     * threads in parallel for example).
+     * Note: You can only use this mode if your event objects extend from AbstractEvent
+     */
+    AsyncTracked
 }
\ No newline at end of file
diff --git a/EventBus/src/de/greenrobot/event/models/AbstractEvent.java b/EventBus/src/de/greenrobot/event/models/AbstractEvent.java
new file mode 100644
index 00000000..e6c315c0
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/models/AbstractEvent.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2015 Pedro Vicente (neteinstein@gmail.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.models;
+
+/**
+ * Generic event to be extended by events when using the AsyncTracked mode. It allows each event to define its behavior
+ */
+public class AbstractEvent {
+
+    /**
+     * Collision Behavior options
+     */
+    public enum EventCollisionBehavior {
+        IGNORE_NEW_EVENT, REPLACE_WITH_NEW_EVENT
+    }
+
+    /**
+     * Default collision behavior
+     */
+    protected EventCollisionBehavior mCollisionBehavior = EventCollisionBehavior.REPLACE_WITH_NEW_EVENT;
+
+    private long subscriberHashCode = 0l;
+
+    /**
+     * Compare AbstractEventRequests unique event codes to check if the event is considered "the same"
+     *
+     * @param a An AbstractEventRequest
+     * @param b An AbstractEventRequest
+     * @return true if they are the same, false if not.
+     */
+    public static boolean compareEventUniqueCode(AbstractEvent a, AbstractEvent b) {
+        String eventCodeA = a.getEventUniqueCode();
+        String eventCodeB = b.getEventUniqueCode();
+
+        if (eventCodeA == null || eventCodeB == null) {
+            return true;
+        } else if (eventCodeA == null || eventCodeB == null) {
+            return false;
+        }
+
+        return eventCodeA.equals(eventCodeB);
+    }
+
+    /**
+     * Compare AbstractEventRequests subscriber codes
+     *
+     * @param a An AbstractEventRequest
+     * @param b An AbstractEventRequest
+     * @return true if they are the same, false if not.
+     */
+    public static boolean compareEventSubscribersHashCode(AbstractEvent a, AbstractEvent b) {
+        long eventCodeA = a.getSubscriberHashCode();
+        long eventCodeB = b.getSubscriberHashCode();
+
+        return eventCodeA == eventCodeB;
+    }
+
+    /**
+     * This will return the class name which can be used as a "type" of event
+     */
+    public String getEventType() {
+        String className = getClass().getCanonicalName();
+
+        return className;
+    }
+
+    /**
+     * This method should be overriden by events if the same event class triggers different events that should run in
+     * parallel
+     */
+    public String getEventUniqueCode() {
+        return getEventType();
+    }
+
+    /**
+     * What happens if an event with the same type and hashcode is submitted
+     *
+     * @return enum with the behaviour
+     */
+    public EventCollisionBehavior getCollisionBehavior() {
+        return mCollisionBehavior;
+    }
+
+    /**
+     * Override the default collision behaviour if necessary
+     *
+     * @param collisionBehavior The new collision behavior
+     */
+    public void setCollisionBehavior(EventCollisionBehavior collisionBehavior) {
+        this.mCollisionBehavior = collisionBehavior;
+    }
+
+    public long getSubscriberHashCode() {
+        return subscriberHashCode;
+    }
+
+    public void setSubscriberHashCode(long subscriberHashCode) {
+        this.subscriberHashCode = subscriberHashCode;
+    }
+
+    /**
+     * Prints readable object in readable format
+     *
+     * @return The object info in readable format
+     */
+    public String toString() {
+
+        return getEventType()
+                + " with  EventCode:"
+                + getEventUniqueCode()
+                + " CollisionBehavior:"
+                + getCollisionBehavior();
+    }
+}
diff --git a/EventBus/src/de/greenrobot/event/models/EventBusAsyncTrackedTask.java b/EventBus/src/de/greenrobot/event/models/EventBusAsyncTrackedTask.java
new file mode 100644
index 00000000..c2c8b2b4
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/models/EventBusAsyncTrackedTask.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Pedro Vicente (neteinstein@gmail.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.event.models;
+
+import java.util.concurrent.Future;
+
+/**
+ * A representation of an Event Task which allows it to be compared, replaced or cancelled.
+ */
+final public class EventBusAsyncTrackedTask {
+
+    /**
+     * The future associated with this event
+     */
+    private Future mFuture;
+    /**
+     * The event the triggered the future
+     */
+    private AbstractEvent mEvent;
+
+    /**
+     * Gets the future
+     *
+     * @return The future
+     */
+    public Future getFuture() {
+        return mFuture;
+    }
+
+    /**
+     * Sets the future
+     *
+     * @param mFuture The future to set
+     */
+    public void setFuture(Future mFuture) {
+        this.mFuture = mFuture;
+    }
+
+    /**
+     * Gets the original event
+     *
+     * @return The event
+     */
+    public AbstractEvent getEvent() {
+        return mEvent;
+    }
+
+    /**
+     * Sets the original event
+     *
+     * @param mEvent The event
+     */
+    public void setEvent(AbstractEvent mEvent) {
+        this.mEvent = mEvent;
+    }
+}
