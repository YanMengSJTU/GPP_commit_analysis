diff --git a/.gitignore b/.gitignore
index 36573eee..36c5498b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,14 +1,32 @@
-.settings/
+# Built application files
+*.apk
+*.ap_
 
-*.iml
-.idea
+# Files for the Dalvik VM
+*.dex
 
-gen/
+# Java class files
+*.class
+
+# Generated files
 bin/
+gen/
 release/
-build/
 
+# Gradle files
 .gradle/
+build/
 gradle.properties
 
+# Local configuration file (sdk path, etc)
 local.properties
+
+# IntelliJ project files
+*.iml
+.idea/
+
+# Eclipse project files
+.settings/
+
+# Misc
+.DS_Store
diff --git a/.travis.yml b/.travis.yml
index e086ce10..07706ece 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,12 @@
+sudo: false
 language: android
 jdk:
-  - openjdk6
   - oraclejdk7
 
 # http://docs.travis-ci.com/user/languages/android/
 android:
   components:
-    - build-tools-21.1.2
+    - build-tools-23.0.1
     - android-10
 
 before_script:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1db6f10c..afe615df 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,6 @@
-### V2.x.x (2015-0x-xx) Future release
+### V2.4.1 (2015-11-12) Bug fix release
 * Registering for sticky events now considers sticky events of subclasses, not just the exact same event type. This makes the semantic consistent to posting events. Note, that this may lead to subscribers being called more than once if matching sticky events of event type subclasses are available.
+* Workaround for an Android bug causing NoClassDefFoundError on some devices
 
 ### V2.4.0 (2014-11-11) Clean up release
 * Removed deprecated APIs: A year ago in Version 2.2.0, a couple of EventBus methods were deprecated and flagged to be removed in a future release. Well, version 2.4.0 is that release. Clean ups like this one keep the API concise and simple.
diff --git a/COMPARISON.md b/COMPARISON.md
index 1ba60ccd..d7733f8d 100644
--- a/COMPARISON.md
+++ b/COMPARISON.md
@@ -51,7 +51,7 @@ Otto is another event bus library for Android; actually it's a fork of Guava's E
         <td>No</td>
     </tr>	
     <tr>
-        <th>Aynchronous event delivery</th>
+        <th>Asynchronous event delivery</th>
         <td>Yes</td>
         <td>No</td>
     </tr>
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..8e7aee90
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,44 @@
+Before you create an Issue...
+=============================
+
+There are better Places for Support
+-----------------------------------
+Please be aware that an issue tracker is not the best place to ask for support. An issue tracker is used to track issues (bugs or feature requests).
+Instead, please use [stackoverflow.com](http://stackoverflow.com/questions/tagged/greenrobot-eventbus?sort=frequent) and use the tag [greenrobot-eventbus](http://stackoverflow.com/tags/greenrobot-eventbus/info) for your question.
+If you want professional support, you can contact the main author and maintainer [Markus Junginger via Google+](https://plus.google.com/+MarkusJunginger/posts).
+
+Examples for support questions better asked elsewhere:
+
+* Asking how something works
+* Asking how to use EventBus in a specific scenario
+* Your app crashes/misbehaves and you are not sure why
+
+The perfect Issue Report
+------------------------
+A couple of simple steps can save time for everyone.
+
+Check before reporting:
+
+* It's not a support inquiry
+* You have read the docs
+* You searched the web and stackoverflow
+* You searched existing issues to avoid duplicates
+
+Reporting bugs:
+
+ * Please investigate if is the bug is really caused by the library. Isolate the issue: what's the minimal code to reproduce the bug?
+ * Bonus steps to gain extra karma points: once you isolated and identified the issue, you can prepare an push request. Submit an unit test causing the bug, and ideally a fix for the bug.
+
+Requesting features:
+
+ * Ask yourself: is the feature useful for a majority users? One of our major goals is to keep the API simple and concise. We do not want to cover all possible use cases, but those that make 80% of users happy.
+
+A Note on Pull Requests
+=======================
+Pull requests (and issue) may queue up up a bit. Usually, pull requests and issues are checked when new releases are planned.
+
+For bigger pull requests, it's a good idea to check with the maintainer upfront about the idea and the implementation outline.
+
+Thanks for reading!
+===================
+It's your contributions and feedback that makes maintaining this library fun.
diff --git a/EventBus/build.gradle b/EventBus/build.gradle
index b377bf64..3accb1e5 100644
--- a/EventBus/build.gradle
+++ b/EventBus/build.gradle
@@ -3,8 +3,8 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '2.4.1-SNAPSHOT'
-sourceCompatibility = 1.6
+version = '2.4.2-SNAPSHOT'
+sourceCompatibility = 1.7
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
 def sonatypeRepositoryUrl
@@ -45,9 +45,10 @@ sourceSets {
 }
 
 javadoc {
+    failOnError = false
     classpath += configurations.provided
     title = "EventBus ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2014 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2012-2015 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
@@ -133,4 +134,4 @@ uploadArchives {
            }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index 95863ade..16eb3978 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -234,7 +234,7 @@ public synchronized boolean isRegistered(Object subscriber) {
     }
 
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
-    private void unubscribeByEventType(Object subscriber, Class<?> eventType) {
+    private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
@@ -255,7 +255,7 @@ public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
-                unubscribeByEventType(subscriber, eventType);
+                unsubscribeByEventType(subscriber, eventType);
             }
             typesBySubscriber.remove(subscriber);
         } else {
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 823cb0ec..08eb766b 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -21,7 +21,6 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
@@ -38,7 +37,7 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
+    private static final Map<Class<?>, List<SubscriberMethod>> methodCache = new HashMap<Class<?>, List<SubscriberMethod>>();
 
     private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
 
@@ -52,17 +51,16 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
-        String key = subscriberClass.getName();
         List<SubscriberMethod> subscriberMethods;
         synchronized (methodCache) {
-            subscriberMethods = methodCache.get(key);
+            subscriberMethods = methodCache.get(subscriberClass);
         }
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
         subscriberMethods = new ArrayList<SubscriberMethod>();
         Class<?> clazz = subscriberClass;
-        HashSet<String> eventTypesFound = new HashSet<String>();
+        HashMap<String, Class> eventTypesFound = new HashMap<String, Class>();
         StringBuilder methodKeyBuilder = new StringBuilder();
         while (clazz != null) {
             String name = clazz.getName();
@@ -72,46 +70,17 @@
             }
 
             // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
-            Method[] methods = clazz.getDeclaredMethods();
-            for (Method method : methods) {
-                String methodName = method.getName();
-                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
-                    int modifiers = method.getModifiers();
-                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                        Class<?>[] parameterTypes = method.getParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
-                            ThreadMode threadMode;
-                            if (modifierString.length() == 0) {
-                                threadMode = ThreadMode.PostThread;
-                            } else if (modifierString.equals("MainThread")) {
-                                threadMode = ThreadMode.MainThread;
-                            } else if (modifierString.equals("BackgroundThread")) {
-                                threadMode = ThreadMode.BackgroundThread;
-                            } else if (modifierString.equals("Async")) {
-                                threadMode = ThreadMode.Async;
-                            } else {
-                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
-                                    continue;
-                                } else {
-                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
-                                }
-                            }
-                            Class<?> eventType = parameterTypes[0];
-                            methodKeyBuilder.setLength(0);
-                            methodKeyBuilder.append(methodName);
-                            methodKeyBuilder.append('>').append(eventType.getName());
-                            String methodKey = methodKeyBuilder.toString();
-                            if (eventTypesFound.add(methodKey)) {
-                                // Only add if not already found in a sub class
-                                subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
-                            }
-                        }
-                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
-                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
-                                + methodName);
-                    }
-                }
+            try {
+                // This is faster than getMethods, especially when subscribers a fat classes like Activities
+                Method[] methods = clazz.getDeclaredMethods();
+                filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);
+            } catch (Throwable th) {
+                // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+                Method[] methods = subscriberClass.getMethods();
+                subscriberMethods.clear();
+                eventTypesFound.clear();
+                filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);
+                break;
             }
             clazz = clazz.getSuperclass();
         }
@@ -120,12 +89,70 @@
                     + ON_EVENT_METHOD_NAME);
         } else {
             synchronized (methodCache) {
-                methodCache.put(key, subscriberMethods);
+                methodCache.put(subscriberClass, subscriberMethods);
             }
             return subscriberMethods;
         }
     }
 
+    private void filterSubscriberMethods(List<SubscriberMethod> subscriberMethods,
+                                         HashMap<String, Class> eventTypesFound, StringBuilder methodKeyBuilder,
+                                         Method[] methods) {
+        for (Method method : methods) {
+            String methodName = method.getName();
+            if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
+                int modifiers = method.getModifiers();
+                Class<?> methodClass = method.getDeclaringClass();
+                if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                    Class<?>[] parameterTypes = method.getParameterTypes();
+                    if (parameterTypes.length == 1) {
+                        ThreadMode threadMode = getThreadMode(methodClass, method, methodName);
+                        if (threadMode == null) {
+                            continue;
+                        }
+                        Class<?> eventType = parameterTypes[0];
+                        methodKeyBuilder.setLength(0);
+                        methodKeyBuilder.append(methodName);
+                        methodKeyBuilder.append('>').append(eventType.getName());
+                        String methodKey = methodKeyBuilder.toString();
+                        Class methodClassOld = eventTypesFound.put(methodKey, methodClass);
+                        if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
+                            // Only add if not already found in a sub class
+                            subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
+                        } else {
+                            // Revert the put, old class is further down the class hierarchy
+                            eventTypesFound.put(methodKey, methodClassOld);
+                        }
+                    }
+                } else if (!skipMethodVerificationForClasses.containsKey(methodClass)) {
+                    Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + methodClass + "."
+                            + methodName);
+                }
+            }
+        }
+    }
+
+    private ThreadMode getThreadMode(Class<?> clazz, Method method, String methodName) {
+        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
+        ThreadMode threadMode;
+        if (modifierString.length() == 0) {
+            threadMode = ThreadMode.PostThread;
+        } else if (modifierString.equals("MainThread")) {
+            threadMode = ThreadMode.MainThread;
+        } else if (modifierString.equals("BackgroundThread")) {
+            threadMode = ThreadMode.BackgroundThread;
+        } else if (modifierString.equals("Async")) {
+            threadMode = ThreadMode.Async;
+        } else {
+            if (!skipMethodVerificationForClasses.containsKey(clazz)) {
+                throw new EventBusException("Illegal onEvent method, check for typos: " + method);
+            } else {
+                threadMode = null;
+            }
+        }
+        return threadMode;
+    }
+
     static void clearCaches() {
         synchronized (methodCache) {
             methodCache.clear();
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
index 570c64b0..f8d7dbfc 100644
--- a/EventBusPerformance/build.gradle
+++ b/EventBusPerformance/build.gradle
@@ -1,17 +1,17 @@
 buildscript {
     repositories {
-        mavenCentral()
+        jcenter()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.1.0'
+        classpath 'com.android.tools.build:gradle:1.3.1'
     }
 }
 
 apply plugin: 'com.android.application'
 
 repositories {
-    mavenCentral()
+    jcenter()
 }
 
 dependencies {
@@ -20,7 +20,7 @@ dependencies {
 }
 
 android {
-    buildToolsVersion '21.1.2'
+    buildToolsVersion '23.0.1'
     compileSdkVersion 19
 
     sourceSets {
diff --git a/EventBusTest/build.gradle b/EventBusTest/build.gradle
index 2f48f9c5..a8b1fb07 100644
--- a/EventBusTest/build.gradle
+++ b/EventBusTest/build.gradle
@@ -1,17 +1,17 @@
 buildscript {
     repositories {
-        mavenCentral()
+        jcenter()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.1.0'
+        classpath 'com.android.tools.build:gradle:1.3.1'
     }
 }
 
 apply plugin: 'com.android.application'
 
 repositories {
-    mavenCentral()
+    jcenter()
 }
 
 dependencies {
@@ -19,7 +19,7 @@ dependencies {
 }
 
 android {
-    buildToolsVersion '21.1.2'
+    buildToolsVersion '23.0.1'
     compileSdkVersion 19
 
     sourceSets {
diff --git a/EventBusTest/src/de/greenrobot/event/test/ClassMapPerfTest.java b/EventBusTest/src/de/greenrobot/event/test/ClassMapPerfTest.java
new file mode 100644
index 00000000..afeb00bb
--- /dev/null
+++ b/EventBusTest/src/de/greenrobot/event/test/ClassMapPerfTest.java
@@ -0,0 +1,41 @@
+package de.greenrobot.event.test;
+
+import junit.framework.TestCase;
+
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Map;
+
+/**
+ * Just to verify testHashMapClassObject is fastest. Ignore this test.
+ */
+public class ClassMapPerfTest /* extends TestCase */ {
+
+    static final int COUNT = 10000000;
+    static final Class CLAZZ = ClassMapPerfTest.class;
+
+    public void testHashMapClassObject() {
+        Map<Class, Class> map = new HashMap<Class, Class>();
+        for (int i = 0; i < COUNT; i++) {
+            Class oldValue = map.put(CLAZZ, CLAZZ);
+            Class value = map.get(CLAZZ);
+        }
+    }
+
+    public void testIdentityHashMapClassObject() {
+        Map<Class, Class> map = new IdentityHashMap<Class, Class>();
+        for (int i = 0; i < COUNT; i++) {
+            Class oldValue = map.put(CLAZZ, CLAZZ);
+            Class value = map.get(CLAZZ);
+        }
+    }
+
+    public void testHashMapClassName() {
+        Map<String, Class> map = new HashMap<String, Class>();
+        for (int i = 0; i < COUNT; i++) {
+            Class oldValue = map.put(CLAZZ.getName(), CLAZZ);
+            Class value = map.get(CLAZZ.getName());
+        }
+    }
+
+}
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
index c34feb38..f3b14d0f 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
@@ -20,8 +20,6 @@
 import de.greenrobot.event.EventBus;
 import junit.framework.TestCase;
 
-import java.lang.ref.WeakReference;
-
 /**
  * @author Markus Junginger, greenrobot
  */
@@ -65,25 +63,14 @@ public void testUnregisterWithoutRegister() {
     }
 
     public void testUnregisterNotLeaking() {
-        EventBusBasicTest subscriber = new EventBusBasicTest();
-        eventBus.register(subscriber);
-        eventBus.unregister(subscriber);
-
-        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);
-        subscriber = null;
-        assertSubscriberNotReferenced(ref);
-    }
-
-    private void assertSubscriberNotReferenced(WeakReference<EventBusBasicTest> ref) {
-        EventBusBasicTest subscriberTest = new EventBusBasicTest();
-        WeakReference<EventBusBasicTest> refTest = new WeakReference<EventBusBasicTest>(subscriberTest);
-        subscriberTest = null;
-
-        // Yeah, in theory is is questionable (in practice just fine so far...)
-        System.gc();
-
-        assertNull(refTest.get());
-        assertNull(ref.get());
+        // This will throw "out of memory" if subscribers are leaked
+        for (int i = 0; i < 300; i++) {
+            EventBusBasicTest subscriber = new EventBusBasicTest() {
+                byte[] expensiveObject = new byte[1024 * 1024];
+            };
+            eventBus.register(subscriber);
+            eventBus.unregister(subscriber);
+        }
     }
 
     public void testRegisterTwice() {
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
index 04be4d91..3755ab71 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
@@ -34,6 +34,21 @@ public void testPostStickyTwoEvents() throws InterruptedException {
         assertEquals(2, eventCount.intValue());
     }
 
+    public void testPostStickyTwoSubscribers() throws InterruptedException {
+        eventBus.postSticky("Sticky");
+        eventBus.postSticky(new IntTestEvent(7));
+        eventBus.registerSticky(this);
+        StickyIntTestSubscriber subscriber2 = new StickyIntTestSubscriber();
+        eventBus.registerSticky(subscriber2);
+        assertEquals(3, eventCount.intValue());
+
+        eventBus.postSticky("Sticky");
+        assertEquals(4, eventCount.intValue());
+
+        eventBus.postSticky(new IntTestEvent(8));
+        assertEquals(6, eventCount.intValue());
+    }
+
     public void testPostStickyRegisterNonSticky() throws InterruptedException {
         eventBus.postSticky("Sticky");
         eventBus.register(this);
@@ -138,4 +153,10 @@ public void onEvent(IntTestEvent event) {
         trackEvent(event);
     }
 
+    public class StickyIntTestSubscriber {
+        public void onEvent(IntTestEvent event) {
+            trackEvent(event);
+        }
+    }
+
 }
diff --git a/HOWTO.md b/HOWTO.md
index 8661770c..aafc2ed6 100644
--- a/HOWTO.md
+++ b/HOWTO.md
@@ -130,7 +130,7 @@ For example, it's possible to configure the default EventBus instance to rethrow
 EventBus.builder().throwSubscriberException(BuildConfig.DEBUG).installDefaultEventBus();
 ```
 
-Note: this can be done only once before the the default EventBus instance is used the first time. This ensures consistent behavior in your app. Your Application class is a good place to configure the default EventBus instance before its used.
+Note: this can be done only once before the default EventBus instance is used the first time. This ensures consistent behavior in your app. Your Application class is a good place to configure the default EventBus instance before its used.
 
 Cancelling event delivery
 -------------------------
@@ -189,7 +189,7 @@ ProGuard obfuscates method names. However, the onEvent methods must not renamed
 
 ```
 -keepclassmembers class ** {
-    public void onEvent*(**);
+    public void onEvent*(***);
 }
 
 # Only required if you use AsyncExecutor
@@ -244,4 +244,4 @@ Another customization options is the execution scope, which gives failure events
 
 Comparison with Square's Otto
 -----------------------------
-Check the [COMPARISON.md](COMPARISON.md)
\ No newline at end of file
+Check the [COMPARISON.md](COMPARISON.md)
diff --git a/README.md b/README.md
index e7c6975b..b0d001ec 100644
--- a/README.md
+++ b/README.md
@@ -67,8 +67,8 @@ FAQ
 **Q:** How is EventBus different to Android's BroadcastReceiver/Intent system?<br/>
 **A:** Unlike Android's BroadcastReceiver/Intent system, EventBus uses standard Java classes as events and offers a more convenient API. EventBus is intended for a lot more uses cases where you wouldn't want to go through the hassle of setting up Intents, preparing Intent extras, implementing broadcast receivers, and extracting Intent extras again. Also, EventBus comes with a much lower overhead.
 
- **Q:** How to do pull requests?<br/>
- **A:** Ensure good code quality and consistent formatting. EventBus has a good test coverage: if you propose a new feature or fix a bug, please add a unit test.
+**Q:** How to do pull requests?<br/>
+**A:** Ensure good code quality and consistent formatting. EventBus has a good test coverage: if you propose a new feature or fix a bug, please add a unit test.
 
 Release History, License
 ------------------------
diff --git a/build.gradle b/build.gradle
index e69de29b..760a32ad 100644
--- a/build.gradle
+++ b/build.gradle
@@ -0,0 +1,7 @@
+if (JavaVersion.current().isJava8Compatible()) {
+    allprojects {
+        tasks.withType(Javadoc) {
+            options.addStringOption('Xdoclint:none', '-quiet')
+        }
+    }
+}
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c97a8bdb..05ef575b 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index c8dcd502..c1823e9a 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sun Feb 22 14:20:02 CET 2015
+#Wed Nov 04 17:33:28 SGT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
diff --git a/gradlew b/gradlew
old mode 100644
new mode 100755
index 91a7e269..9d82f789
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/gradlew.bat b/gradlew.bat
index 8a0b282a..aec99730 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/javadoc-style/background.gif b/javadoc-style/background.gif
new file mode 100644
index 00000000..ec068a06
Binary files /dev/null and b/javadoc-style/background.gif differ
