diff --git a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
index 90a30d1e..5dd90e62 100644
--- a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
@@ -34,6 +34,7 @@
     public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         queue.enqueue(pendingPost);
+        //和Background一样的是newCachedThreadPool，但是没有了串行的限制，是并行的，来一个new一个线程，无限制
         eventBus.getExecutorService().execute(this);
     }
 
@@ -43,6 +44,7 @@ public void run() {
         if(pendingPost == null) {
             throw new IllegalStateException("No pending post available");
         }
+        //反射执行
         eventBus.invokeSubscriber(pendingPost);
     }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 624ddf6d..95bf02a0 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -38,8 +38,10 @@ public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
             queue.enqueue(pendingPost);
+            //可以看到在线程池中是串行的，执行完一个，才会变为false
             if (!executorRunning) {
                 executorRunning = true;
+                //EventBus默认的线程池是newCachedThreadPool,无限大的可复用线程池
                 eventBus.getExecutorService().execute(this);
             }
         }
@@ -61,6 +63,7 @@ public void run() {
                             }
                         }
                     }
+                    //反射执行
                     eventBus.invokeSubscriber(pendingPost);
                 }
             } catch (InterruptedException e) {
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 95958566..ef7d6f83 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -78,7 +78,7 @@ protected PostingThreadState initialValue() {
 
     /** Convenience singleton for apps using a process-wide EventBus instance. */
     public static EventBus getDefault() {
-        //常规的双重锁单例模式
+        //常规的双重锁单例模式，特殊的是构造方法是共有的，也就是可以创建多个EventBus,互相不干扰
         EventBus instance = defaultInstance;
         if (instance == null) {
             synchronized (EventBus.class) {
@@ -142,6 +142,7 @@ public EventBus() {
     public void register(Object subscriber) {
         //获得订阅者对应的Class,MainActivity.class
         Class<?> subscriberClass = subscriber.getClass();
+        //找到所有的订阅的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -239,6 +240,7 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
+                //判断两个变量指向的是否是同一个内存地址
                 if (subscription.subscriber == subscriber) {
                     subscription.active = false;
                     subscriptions.remove(i);
@@ -255,6 +257,7 @@ public synchronized void unregister(Object subscriber) {
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
             for (Class<?> eventType : subscribedTypes) {
+                //到Event的map中删除MainActivity
                 unsubscribeByEventType(subscriber, eventType);
             }
             typesBySubscriber.remove(subscriber);
@@ -447,17 +450,20 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
+            //默认类型
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
             case MAIN:
                 if (isMainThread) {
+                    //如果当前就在UI线程，则直接反射执行
                     invokeSubscriber(subscription, event);
                 } else {
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
             case MAIN_ORDERED:
+                //不同于MAIN，直接通过Handler的队列执行，串行的
                 if (mainThreadPoster != null) {
                     mainThreadPoster.enqueue(subscription, event);
                 } else {
@@ -467,8 +473,10 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 break;
             case BACKGROUND:
                 if (isMainThread) {
+                    //如果当前是UI线程，则异步
                     backgroundPoster.enqueue(subscription, event);
                 } else {
+                    //不是UI线程，则在该线程执行
                     invokeSubscriber(subscription, event);
                 }
                 break;
@@ -520,8 +528,10 @@ static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
     void invokeSubscriber(PendingPost pendingPost) {
         Object event = pendingPost.event;
         Subscription subscription = pendingPost.subscription;
+        //回收
         PendingPost.releasePendingPost(pendingPost);
         if (subscription.active) {
+            //反射调用
             invokeSubscriber(subscription, event);
         }
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 95309547..88b2389d 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -31,15 +31,19 @@ protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHan
         super(looper);
         this.eventBus = eventBus;
         this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
+        //用java实现的一个队列
         queue = new PendingPostQueue();
     }
 
     public void enqueue(Subscription subscription, Object event) {
+        //内部有一个ArrayList,没有就new
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
+            //入队
             queue.enqueue(pendingPost);
             if (!handlerActive) {
                 handlerActive = true;
+                //发送消息
                 if (!sendMessage(obtainMessage())) {
                     throw new EventBusException("Could not send handler message");
                 }
@@ -53,19 +57,24 @@ public void handleMessage(Message msg) {
         try {
             long started = SystemClock.uptimeMillis();
             while (true) {
+                //出队列
                 PendingPost pendingPost = queue.poll();
                 if (pendingPost == null) {
                     synchronized (this) {
                         // Check again, this time in synchronized
+                        //再获取一次
                         pendingPost = queue.poll();
+                        //仍然为null则return
                         if (pendingPost == null) {
                             handlerActive = false;
                             return;
                         }
                     }
                 }
+                //反射调用
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
+                //如果超过maxMillisInsideHandleMessage还没执行完则重新调度
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
                     if (!sendMessage(obtainMessage())) {
                         throw new EventBusException("Could not send handler message");
diff --git a/EventBus/src/org/greenrobot/eventbus/MainThreadSupport.java b/EventBus/src/org/greenrobot/eventbus/MainThreadSupport.java
index d5655533..49908e1c 100644
--- a/EventBus/src/org/greenrobot/eventbus/MainThreadSupport.java
+++ b/EventBus/src/org/greenrobot/eventbus/MainThreadSupport.java
@@ -41,6 +41,7 @@ public boolean isMainThread() {
 
         @Override
         public Poster createPoster(EventBus eventBus) {
+            //在主线程的Handler
             return new HandlerPoster(eventBus, looper, 10);
         }
     }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 5f2503fc..49af5592 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -245,15 +245,15 @@ boolean checkAdd(Method method, Class<?> eventType) {
                 return true;
             } else {
                 if (existing instanceof Method) {
-                    //存在多个方法都能接受Event,比如一个接受子类，一个接受父类，会返回True
+                    //存在多个方法都能接受Event,比如一个接受子类，一个接受父类，会返回True,
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
                         throw new IllegalStateException();
                     }
-                    //所以也能接收
                     // Put any non-Method object to "consume" the existing Method
                     anyMethodByEventType.put(eventType, this);
                 }
+                //但当子类和父类相同的方法名和Event类型会返回true，所以也放到anyMethodByEventType,但是不能被接收
                 return checkAddWithMethodSignature(method, eventType);
             }
         }
