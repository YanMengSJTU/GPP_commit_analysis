diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 466c5aaa..2d59687f 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -159,9 +159,13 @@ public void register(Object subscriber) {
     }
 
     // Must be called in synchronized block
+//    必须在同步代码块中调用
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+//        获取订阅的事件类型
         Class<?> eventType = subscriberMethod.eventType;
+//        创建Subscription对象
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+//        从subscriptionsByEventType检查是否已经添加过该Subscription，如果添加过就抛出异常
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -172,7 +176,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                         + eventType);
             }
         }
-
+//        根据优先级priority来添加Subscription对象
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -180,15 +184,16 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 break;
             }
         }
-
+//      将订阅者对象以及订阅的事件保存到typesBySubscriber里
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
         subscribedEvents.add(eventType);
-
+//        如果接收到sticky事件，立即分发sticky事件
         if (subscriberMethod.sticky) {
+//            eventInheritance 表示是否分发订阅了响应事件类父类事件的方法
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -263,7 +268,9 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+//        得到当前线程的Posting状态
         PostingThreadState postingState = currentPostingThreadState.get();
+//        获得当前线程的事件队列
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
@@ -275,6 +282,7 @@ public void post(Object event) {
             }
             try {
                 while (!eventQueue.isEmpty()) {
+//                    发送单个事件，
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -392,8 +400,10 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         if (eventInheritance) {
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
+//            循环postSingleEventForEventType
             for (int h = 0; h < countTypes; h++) {
                 Class<?> clazz = eventTypes.get(h);
+//                只要有一次返回为true subscriptionFound最终结果就是true
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
@@ -412,6 +422,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
 
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
+//        获取到订阅了这个事件的Subscription列表
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
@@ -421,6 +432,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+//                    分发给订阅者
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -439,13 +451,18 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
+            // 订阅线程跟随发布线程
             case POSTING:
+                // 订阅线程和发布线程相同，直接订阅
                 invokeSubscriber(subscription, event);
                 break;
+            // 订阅线程为主线程
             case MAIN:
                 if (isMainThread) {
+                    // 发布线程和订阅线程都是主线程，直接订阅
                     invokeSubscriber(subscription, event);
                 } else {
+                    // 发布线程不是主线程，订阅线程切换到主线程订阅
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
@@ -457,14 +474,19 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     invokeSubscriber(subscription, event);
                 }
                 break;
+            // 订阅线程为后台线程
             case BACKGROUND:
                 if (isMainThread) {
+                    // 发布线程为主线程，切换到后台线程订阅
                     backgroundPoster.enqueue(subscription, event);
                 } else {
+                    // 发布线程不为主线程，直接订阅
                     invokeSubscriber(subscription, event);
                 }
                 break;
+            // 订阅线程为异步线程
             case ASYNC:
+                // 使用线程池线程订阅
                 asyncPoster.enqueue(subscription, event);
                 break;
             default:
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 95309547..feb2dc54 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -35,9 +35,11 @@ protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHan
     }
 
     public void enqueue(Subscription subscription, Object event) {
+//        将待发送对象加入队列
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
             queue.enqueue(pendingPost);
+//            当HandleMessage没有运行，发一条空消息让handleMessage响应
             if (!handlerActive) {
                 handlerActive = true;
                 if (!sendMessage(obtainMessage())) {
@@ -64,7 +66,9 @@ public void handleMessage(Message msg) {
                         }
                     }
                 }
+                //如果订阅者没有取消注册,则分发消息
                 eventBus.invokeSubscriber(pendingPost);
+                //如果在一定时间内仍然没有发完队列中所有的待发送者,则退出
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
                     if (!sendMessage(obtainMessage())) {
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..f9a7879b 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -19,10 +19,13 @@
 import java.util.List;
 
 final class PendingPost {
+//    单例池，复用对象
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
-
+//  事件类型
     Object event;
+//    订阅者
     Subscription subscription;
+//    队列下一个待发送对象
     PendingPost next;
 
     private PendingPost(Object event, Subscription subscription) {
@@ -30,6 +33,12 @@ private PendingPost(Object event, Subscription subscription) {
         this.subscription = subscription;
     }
 
+    /**
+     * 首先检查复用池中是否有可用，如果有则返回复用，否则返回一个新的
+     * @param subscription  订阅者
+     * @param event         订阅事件
+     * @return      待发送对象
+     */
     static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         synchronized (pendingPostPool) {
             int size = pendingPostPool.size();
@@ -44,6 +53,10 @@ static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         return new PendingPost(event, subscription);
     }
 
+    /**
+     * 回收一个待发送对象，并加入复用池
+     * @param pendingPost
+     */
     static void releasePendingPost(PendingPost pendingPost) {
         pendingPost.event = null;
         pendingPost.subscription = null;
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..5df79159 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -17,7 +17,9 @@
 package org.greenrobot.eventbus;
 
 final class PendingPostQueue {
+//    待发送对象队列头结点
     private PendingPost head;
+//    待发送对象队列尾节点
     private PendingPost tail;
 
     synchronized void enqueue(PendingPost pendingPost) {
