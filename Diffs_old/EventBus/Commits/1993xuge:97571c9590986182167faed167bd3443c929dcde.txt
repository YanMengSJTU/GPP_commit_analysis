diff --git a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
index 90a30d1e..ac430a97 100644
--- a/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/AsyncPoster.java
@@ -18,6 +18,10 @@
 
 /**
  * Posts events in background.
+ * 同时实现了Runnable接口和Poster接口，与ThreadMode.ASYNC相对应。
+ *
+ * 它的作用是 通过enqueue()函数将事件保存到内部封装的PendingPostQueue队列中，
+ * 并调用线程池执行该任务，在run()方法中将事件取出，并执行回调。
  * 
  * @author Markus
  */
@@ -32,7 +36,9 @@
     }
 
     public void enqueue(Subscription subscription, Object event) {
+        // 把 事件和Subscription对象 封装成 PendingPost
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
+        // 将 生成的 pendingPost对象 加入到队列中
         queue.enqueue(pendingPost);
         eventBus.getExecutorService().execute(this);
     }
@@ -43,6 +49,7 @@ public void run() {
         if(pendingPost == null) {
             throw new IllegalStateException("No pending post available");
         }
+        // 从队列中取出 PendingPost对象
         eventBus.invokeSubscriber(pendingPost);
     }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 624ddf6d..bd4ec9f7 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -19,7 +19,10 @@
 
 /**
  * Posts events in background.
+ * 同时实现了Runnable接口和Poster接口，与ThreadMode.BACKGROUND相对应。
  *
+ * 它的作用是通过enquque()函数，将事件保存到PendingPostQueue队列中，
+ * 并使用线程池执行当前任务，在run()函数中，依次从队列中取出事件，并处理。
  * @author Markus
  */
 final class BackgroundPoster implements Runnable, Poster {
@@ -35,9 +38,11 @@
     }
 
     public void enqueue(Subscription subscription, Object event) {
+        // 将参数Subscription对象和事件封装成PendingPost，并添加到事件队列中。
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
             queue.enqueue(pendingPost);
+            // 如果executorRunning = false，即BackgroundPoster处于“闲置”状态，则开启线程池，处理当前Runnable
             if (!executorRunning) {
                 executorRunning = true;
                 eventBus.getExecutorService().execute(this);
@@ -49,6 +54,7 @@ public void enqueue(Subscription subscription, Object event) {
     public void run() {
         try {
             try {
+                // 循环从事件队列中取出事件，并使用EventBus中的invokeSubscriber方法处理事件，直到事件队列中的事件全部处理完毕
                 while (true) {
                     PendingPost pendingPost = queue.poll(1000);
                     if (pendingPost == null) {
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..80ffb3a7 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -38,18 +38,59 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
+    /**
+     * Log tag, apps may override it.
+     */
     public static String TAG = "EventBus";
 
+    /**
+     * 默认的EventBus对象实例，可以通过静态方法getDefault()获取。
+     */
     static volatile EventBus defaultInstance;
 
+    /**
+     * 默认的EventBusBuilder，通过DEFAULT_BUILDER构造EventBus的实例对象。
+     */
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+
+    /**
+     * 事件对应类型及其父类和实现接口的缓存。
+     * key : 事件类型
+     * value : 事件类型的父类或实现的接口列表
+     */
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
+    /**
+     * 缓存了当前EventBus对象所能处理的所有事件的所有订阅回调方法.
+     * key : 事件对应的类型
+     * value : 订阅该类型事件的Subscription对象的列表。
+     * <p>
+     * 在订阅者注册时，会将订阅者的所有订阅方法保存到该数组的相应位置，
+     * 等到事件发布者发布事件时，会从中找出所发布事件类型对象的Subscription列表，将事件回调到各个订阅方法中。
+     */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+    /**
+     * 订阅者 订阅的所有事件的列表。
+     * key：订阅者对象。
+     * value：订阅事件对应的类型列表。
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
+
+    /**
+     * 粘性事件的缓存队列。
+     * key：粘性事件对应的类型
+     * value：最后一个发送的事件对象。
+     * <p>
+     * 在stickyEvents中，只保留各个事件类型的最后一个发送的事件对象。
+     */
     private final Map<Class<?>, Object> stickyEvents;
 
+    /**
+     * 是一个ThreadLocal对象，保存当前线程的PostingThreadState对象。
+     * <p>
+     * PostingThreadState对象中保存着当前线程的事件队列、状态、正在处理的事件等信息。
+     */
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -57,26 +98,66 @@ protected PostingThreadState initialValue() {
         }
     };
 
-    // @Nullable
+    /**
+     * 主要用来 提供Android主线程的Looper，以便构造主线程的Poster。
+     *
+     * @Nullable
+     */
     private final MainThreadSupport mainThreadSupport;
-    // @Nullable
+    /**
+     * 用来 将事件发送到Android主线程。
+     * 声明为Poster，实际上是通过mainThreadSupport中的主线程的Looper创建的HandlerPoster对象。
+     *
+     * @Nullable
+     */
     private final Poster mainThreadPoster;
+
+    /**
+     * 用来将事件发送到后台进程处理。
+     */
     private final BackgroundPoster backgroundPoster;
+
+    /**
+     * 使用异步线程处理事件。
+     */
     private final AsyncPoster asyncPoster;
+
+    /**
+     * 在订阅者进行注册时，查找订阅者中声明的所有订阅方法。
+     * 订阅方法要么在自定义的SubscriberInfoIndex对象中查找，要么通过反射的方式查找。
+     */
     private final SubscriberMethodFinder subscriberMethodFinder;
+
+    /**
+     * 线程池，用于处理BackgroundPoster或AsyncPoster中发送的事件。
+     */
     private final ExecutorService executorService;
 
     private final boolean throwSubscriberException;
+    /**
+     * 是否在invoke Subscriber发生异常时，打印log
+     */
     private final boolean logSubscriberExceptions;
     private final boolean logNoSubscriberMessages;
     private final boolean sendSubscriberExceptionEvent;
+
+    /**
+     * 是否发送没有订阅者的消息
+     */
     private final boolean sendNoSubscriberEvent;
+
+    /**
+     * 是否支持事件继承。
+     */
     private final boolean eventInheritance;
 
     private final int indexCount;
     private final Logger logger;
 
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
+    /**
+     * Convenience singleton for apps using a process-wide EventBus instance.
+     * 获取 EventBus 单例对象
+     */
     public static EventBus getDefault() {
         EventBus instance = defaultInstance;
         if (instance == null) {
@@ -94,7 +175,9 @@ public static EventBusBuilder builder() {
         return new EventBusBuilder();
     }
 
-    /** For unit test primarily. */
+    /**
+     * For unit test primarily.
+     */
     public static void clearCaches() {
         SubscriberMethodFinder.clearCaches();
         eventTypesCache.clear();
@@ -103,6 +186,8 @@ public static void clearCaches() {
     /**
      * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
      * central bus, consider {@link #getDefault()}.
+     *
+     * 可以通过构造函数创建新的EventBus实例
      */
     public EventBus() {
         this(DEFAULT_BUILDER);
@@ -139,8 +224,10 @@ public EventBus() {
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        // 1、查找订阅方法列表
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            // 2、遍历订阅方法，进行注册。
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
@@ -149,8 +236,13 @@ public void register(Object subscriber) {
 
     // Must be called in synchronized block
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+        // 事件的class
         Class<?> eventType = subscriberMethod.eventType;
+
+        // 把订阅者和订阅方法封装成Subscription
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+
+        // 1、把Subscription对象按照 eventType 存储在 subscriptionsByEventType
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
@@ -162,6 +254,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 把 Subscription对象 插入到 subscriptions的合适位置。subscriptions是按照 优先级 从高到低 排列的
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
@@ -170,6 +263,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             }
         }
 
+        // 2、把 订阅者subscriber 订阅的事件类型保存到 typesBySubscriber
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -177,8 +271,10 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
         subscribedEvents.add(eventType);
 
+        // 3、订阅方法 接受 粘性事件
         if (subscriberMethod.sticky) {
             if (eventInheritance) {
+                // 如果支持事件继承，那么遍历粘性事件的列表，找出该类的所有子类事件，将其发送
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
@@ -187,12 +283,15 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
                     if (eventType.isAssignableFrom(candidateEventType)) {
+                        //
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
                 }
             } else {
+                // 从map中，获取对应类型的粘性事件
                 Object stickyEvent = stickyEvents.get(eventType);
+                // 检查并发送粘性 事件
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
@@ -220,15 +319,21 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
+    /**
+     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+     */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+        // 获取 该事件的所有事件处理方法
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions != null) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
+                // 遍历事件处理方法
                 Subscription subscription = subscriptions.get(i);
+                // 校验订阅者
                 if (subscription.subscriber == subscriber) {
                     subscription.active = false;
+                    // 将 订阅方法从列表中移除
                     subscriptions.remove(i);
                     i--;
                     size--;
@@ -237,33 +342,49 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
-    /** Unregisters the given subscriber from all event classes. */
+    /**
+     * Unregisters the given subscriber from all event classes.
+     */
     public synchronized void unregister(Object subscriber) {
+        // 获取 该订阅者 订阅的所有事件类型
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
         if (subscribedTypes != null) {
+            // 遍历 事件列表
             for (Class<?> eventType : subscribedTypes) {
+                // 移除保存的Subscription信息，实质上是从subscriptionsByEventType中将订阅方法移除
                 unsubscribeByEventType(subscriber, eventType);
             }
+            // 将 该订阅者的信息移除掉
             typesBySubscriber.remove(subscriber);
         } else {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
-    /** Posts the given event to the event bus. */
+    /**
+     * Posts the given event to the event bus.
+     */
     public void post(Object event) {
+        // 获取当前线程的信息
         PostingThreadState postingState = currentPostingThreadState.get();
+
+        // 获取对应的 事件队列
         List<Object> eventQueue = postingState.eventQueue;
+
+        // 将事件加入到当前线程的事件队列中
         eventQueue.add(event);
 
+        // 此时没有发布事件
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
+            // 表明当前正在发布事件
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    // 事件序列非空，取出队首的事件，开始发送
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -302,9 +423,11 @@ public void cancelEventDelivery(Object event) {
      */
     public void postSticky(Object event) {
         synchronized (stickyEvents) {
+            // 每一种 类型的事件 只存储一个，多个事件会被 覆盖
             stickyEvents.put(event.getClass(), event);
         }
         // Should be posted after it is putted, in case the subscriber wants to remove immediately
+        // 通过普通方式 发送事件
         post(event);
     }
 
@@ -375,6 +498,12 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 分发事件
+     * @param event
+     * @param postingState
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
@@ -427,19 +556,24 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
     }
 
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        // 取出Subscription的线程模式，进行分类处理
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
+                // 直接处理事件
                 invokeSubscriber(subscription, event);
                 break;
             case MAIN:
                 if (isMainThread) {
+                    // 发布线程是主线程，直接处理
                     invokeSubscriber(subscription, event);
                 } else {
+                    // 使用绑定主线程Looper的Post对象，发送事件
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
             case MAIN_ORDERED:
                 if (mainThreadPoster != null) {
+                    // 直接 将 事件发送到 主线程的队列中
                     mainThreadPoster.enqueue(subscription, event);
                 } else {
                     // temporary: technically not correct as poster not decoupled from subscriber
@@ -448,12 +582,15 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 break;
             case BACKGROUND:
                 if (isMainThread) {
+                    // 如果当前发布线程是主线程，则将事件加入到后台线程的事件队列中
                     backgroundPoster.enqueue(subscription, event);
                 } else {
+                    // 不是主线程，直接处理
                     invokeSubscriber(subscription, event);
                 }
                 break;
             case ASYNC:
+                // 开启新线程处理
                 asyncPoster.enqueue(subscription, event);
                 break;
             default:
@@ -461,7 +598,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+     */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -479,7 +618,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
         }
     }
 
-    /** Recurses through super interfaces. */
+    /**
+     * Recurses through super interfaces.
+     */
     static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
         for (Class<?> interfaceClass : interfaces) {
             if (!eventTypes.contains(interfaceClass)) {
@@ -540,7 +681,9 @@ private void handleSubscriberException(Subscription subscription, Object event,
         }
     }
 
-    /** For ThreadLocal, much faster to set (and get multiple values). */
+    /**
+     * For ThreadLocal, much faster to set (and get multiple values).
+     */
     final static class PostingThreadState {
         final List<Object> eventQueue = new ArrayList<>();
         boolean isPosting;
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 95309547..4c2f2e5a 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -20,8 +20,15 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+/**
+ * 继承了Handler并且实现了Poster接口，与ThreadMode.Main相对应。
+ *
+ * 它的作用是将Event保存到内部封装的PendingPostQueue中，
+ * 不断地将队列中的事件发送到主线程的Looper，并在handleMessage()方法中处理事件。
+ */
 public class HandlerPoster extends Handler implements Poster {
 
+    /** 事件队列 **/
     private final PendingPostQueue queue;
     private final int maxMillisInsideHandleMessage;
     private final EventBus eventBus;
@@ -34,6 +41,7 @@ protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHan
         queue = new PendingPostQueue();
     }
 
+    /** 将 subscription和event 封装成PendingPost对象， 并加入到PendingPostQueue队列中 **/
     public void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
@@ -49,10 +57,12 @@ public void enqueue(Subscription subscription, Object event) {
 
     @Override
     public void handleMessage(Message msg) {
+        // 处理事件
         boolean rescheduled = false;
         try {
             long started = SystemClock.uptimeMillis();
             while (true) {
+                // 死循环，不断从 队列中取 内容
                 PendingPost pendingPost = queue.poll();
                 if (pendingPost == null) {
                     synchronized (this) {
@@ -64,6 +74,7 @@ public void handleMessage(Message msg) {
                         }
                     }
                 }
+                // 通过EventBus的invokeSubscriber方法处理事件。
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..494e7cf1 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -18,6 +18,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * 将事件对象和订阅方法信息Subscription对象封装在一起，并含有同一队列中指向下一个对象的指针
+ *
+ * 该类的实例对象一般用在PendingPostQueue队列中。
+ *
+ * 该类中还通过缓存存储不用的对象，减少下次创建的性能消耗。
+ */
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
 
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..7ea1de3d 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -16,6 +16,14 @@
 
 package org.greenrobot.eventbus;
 
+/**
+ * 通过head和tail指针维护的一个PendingPost队列。
+ *
+ * HandlerPoster、BackgroundPoster和AsyncPoster中都有一个PendingPostQueue实例对象，通过这个PendingPostQueue对象来存储事件。
+ *
+ * enqueue()函数完成入队操作。
+ * poll()函数完成出队操作。
+ */
 final class PendingPostQueue {
     private PendingPost head;
     private PendingPost tail;
diff --git a/EventBus/src/org/greenrobot/eventbus/Poster.java b/EventBus/src/org/greenrobot/eventbus/Poster.java
index a69a078d..fb73dea4 100644
--- a/EventBus/src/org/greenrobot/eventbus/Poster.java
+++ b/EventBus/src/org/greenrobot/eventbus/Poster.java
@@ -17,7 +17,7 @@
 
 /**
  * Posts events.
- *
+ * 定义了enqueue()方法，其作用是将事件添加到队列中，但具体事件如何发送处理，由实现类根据自己的需求完成。
  * @author William Ferguson
  */
 interface Poster {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..1895b28a 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -17,14 +17,21 @@
 
 import java.lang.reflect.Method;
 
-/** Used internally by EventBus and generated subscriber indexes. */
+/**
+ * Used internally by EventBus and generated subscriber indexes.
+ *
+ * 订阅事件响应函数信息，
+ * 该类中包含了响应函数Method对象、处理事件的线程模型ThreadMode对象、事件对应的类型、优先级priority、是否接受粘性事件。
+ */
 public class SubscriberMethod {
     final Method method;
     final ThreadMode threadMode;
     final Class<?> eventType;
     final int priority;
     final boolean sticky;
-    /** Used for efficient comparison */
+    /**
+     * Used for efficient comparison
+     */
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
@@ -41,7 +48,7 @@ public boolean equals(Object other) {
             return true;
         } else if (other instanceof SubscriberMethod) {
             checkMethodString();
-            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
+            SubscriberMethod otherSubscriberMethod = (SubscriberMethod) other;
             otherSubscriberMethod.checkMethodString();
             // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6
             return methodString.equals(otherSubscriberMethod.methodString);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..ddb2c81d 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -26,6 +26,13 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
+/**
+ * 用来查找特定订阅者类型中的订阅方法列表，并将其封装成Subscription列表。
+ * <p>
+ * 该类通过findSubscriberMethods()方法对外提供查找功能。
+ * <p>
+ * 有两种查找方式：从SubscriberInfo中查找和 通过反射的方式查找。
+ */
 class SubscriberMethodFinder {
     /*
      * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
@@ -53,38 +60,53 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 1、先从缓存中查找
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
+            // 在缓存中找到了该类的订阅方法，则直接返回
             return subscriberMethods;
         }
 
+        // 2、查找订阅方法
         if (ignoreGeneratedIndex) {
+            // 通过反射方式获取订阅方法列表
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+
+        // 3、处理查找结果
         if (subscriberMethods.isEmpty()) {
+            // 如果该class没有public的订阅方法，则抛出异常
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            // 成功的找到了订阅方法，将其保存到缓存中，并返回
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
     }
 
     private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
+        // 获取并初始化FindState对象
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 获取SubscriberInfo对象
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
+                // 获取订阅方法列表
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                 for (SubscriberMethod subscriberMethod : array) {
+                    // check 订阅方法
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
+                        // 添加订阅方法到findState中
                         findState.subscriberMethods.add(subscriberMethod);
                     }
                 }
             } else {
+                // 通过反射 获取所有的订阅方法
                 findUsingReflectionInSingleClass(findState);
             }
             findState.moveToSuperclass();
@@ -127,6 +149,7 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
             }
         }
         if (subscriberInfoIndexes != null) {
+            // 从 EventBusAnnotationProcessor 中生成的 SubscriberInfoIndex 中 获取 SubscriberInfo
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
                 if (info != null) {
@@ -137,46 +160,70 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 通过反射查找订阅方法信息
+     *
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
+        // 获取并初始化FindState对象
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 查找 findState.clazz类中的所有事件响应方法
             findUsingReflectionInSingleClass(findState);
+            // 将 clazz 指向父类
             findState.moveToSuperclass();
         }
+        // 取出findState中保存的订阅方法，回收findState，并将findState加入到FIND_STATE_POOL
         return getMethodsAndRelease(findState);
     }
 
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
+        // 1、获取类中的所有方法
         try {
+            // getDeclaredMethods：返回这个类的所有声明的方法的Method对象数组。包括公共、保护、默认和私有方法，但不包括继承的方法
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+            // 返回类的所有公共方法，包括自身的所有public方法、从基类中继承的方法、实现接口中的方法。
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+
+        // 2、遍历方法列表，找出订阅方法
+        // 即使没有获取到自身或者基类中的方法，但methods不会为null，只不过size=0
         for (Method method : methods) {
+            // 获取方法的修饰符
             int modifiers = method.getModifiers();
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                // 2.1 是public 并且不是abstract和static
+                // 获取方法的参数类型
                 Class<?>[] parameterTypes = method.getParameterTypes();
                 if (parameterTypes.length == 1) {
+                    // 2.2 方法的参数为1个，EventBus中的订阅方法参数为1个
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        // 2.3 该方法的修饰符正确、参数个数为1、并且被Subscribe注释修饰
                         Class<?> eventType = parameterTypes[0];
                         if (findState.checkAdd(method, eventType)) {
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
+                            // 2.4 生成SubscriberMethod，并将其加入到findState.subscriberMethods
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                    // 方法的参数个数不为1，并且被Subscribe修饰了，那么抛出异常
                     String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                     throw new EventBusException("@Subscribe method " + methodName +
                             "must have exactly 1 parameter but has " + parameterTypes.length);
                 }
             } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                // 方法的修饰符不正确，并且该方法是被Subscribe修饰的方法，那么需要抛出异常
                 String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                 throw new EventBusException(methodName +
                         " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
@@ -189,22 +236,41 @@ static void clearCaches() {
     }
 
     static class FindState {
+        /**
+         * 订阅方法列表，查找订阅方法时，会将订阅方法列表保存到subscriberMethods中
+         */
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+
+        /** key：event的class， value：Method对 */
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+
+        /**
+         * key : 方法签名，一般为 methodName>eventTypeName
+         * value ：声明方法的class对象
+         */
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
+
+        /** 生成方法签名验证的Key */
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
+        /** 订阅者的class **/
         Class<?> subscriberClass;
+
+        /** clazz 是一个类型指针，指向当前需要查找的类 **/
         Class<?> clazz;
+
+        /** 是否跳过了基类 **/
         boolean skipSuperClasses;
         SubscriberInfo subscriberInfo;
 
+        /** 使用 订阅者的类型 初始化FindState */
         void initForSubscriber(Class<?> subscriberClass) {
             this.subscriberClass = clazz = subscriberClass;
             skipSuperClasses = false;
             subscriberInfo = null;
         }
 
+        /** 回收FindState对象，重置其属性 */
         void recycle() {
             subscriberMethods.clear();
             anyMethodByEventType.clear();
@@ -216,6 +282,7 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        /** 对 订阅方法对象与订阅的事件类型做检查 **/
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
@@ -235,6 +302,11 @@ boolean checkAdd(Method method, Class<?> eventType) {
             }
         }
 
+        /**
+         * 进行方法签名验证
+         * @param method - 需要验证的方法，用来生成 methodKey
+         * @param eventType - 事件类型，用来生成 methodKey
+         */
         private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             methodKeyBuilder.setLength(0);
             methodKeyBuilder.append(method.getName());
@@ -253,6 +325,9 @@ private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             }
         }
 
+        /**
+         * 将 类型指针clazz 指向其父类，如果 设置了skipSuperClasses 或 其父类是系统类，则clazz = null
+         */
         void moveToSuperclass() {
             if (skipSuperClasses) {
                 clazz = null;
diff --git a/EventBus/src/org/greenrobot/eventbus/Subscription.java b/EventBus/src/org/greenrobot/eventbus/Subscription.java
index cc0de1e3..291f0774 100644
--- a/EventBus/src/org/greenrobot/eventbus/Subscription.java
+++ b/EventBus/src/org/greenrobot/eventbus/Subscription.java
@@ -15,8 +15,19 @@
  */
 package org.greenrobot.eventbus;
 
+/**
+ * 订阅信息类，其中封装了Subscriber和SubscriberMethod，
+ * 其作用就是将Subscriber和SubscriberMethod绑定在一起。
+ */
 final class Subscription {
+    /**
+     * 订阅者对象，如MainActivity
+     */
     final Object subscriber;
+
+    /**
+     * 订阅者的一个订阅方法，如在MainActivity中声明的被@Subscribe标注的订阅方法
+     */
     final SubscriberMethod subscriberMethod;
     /**
      * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index c37c18a5..c17ad77f 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -69,6 +69,7 @@ public SourceVersion getSupportedSourceVersion() {
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
         Messager messager = processingEnv.getMessager();
         try {
+            // 1、读取配置参数信息 —— 生成类的全名称和是否打印解析信息。
             String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
             if (index == null) {
                 messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
@@ -99,10 +100,16 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 messager.printMessage(Diagnostic.Kind.ERROR,
                         "Unexpected processing state: annotations still available after writing.");
             }
+
+            // 2、收集订阅方法 —— 即被@Subscribe注释的“合法”方法元素，并保存到methodsByClass中。
             collectSubscribers(annotations, env, messager);
+
+            // 3、收集“不合法的”类元素。
             checkForSubscribersToSkip(messager, indexPackage);
 
             if (!methodsByClass.isEmpty()) {
+
+                // 4、生成中间代码。
                 createInfoIndexFile(index);
             } else {
                 messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
@@ -117,13 +124,19 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     }
 
     private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
+        // 1、循环遍历 支持的注解
         for (TypeElement annotation : annotations) {
+
+            // 2、获取并遍历 被 annotation 注释的所有元素
             Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
             for (Element element : elements) {
                 if (element instanceof ExecutableElement) {
+                    // ExecutableElement 指的是 方法元素
                     ExecutableElement method = (ExecutableElement) element;
+                    //  3、找出合法的方法元素
                     if (checkHasNoErrors(method, messager)) {
                         TypeElement classElement = (TypeElement) method.getEnclosingElement();
+                        // 4、将 合法的 方法元素加入到 methodsByClass 中
                         methodsByClass.putElement(classElement, method);
                     }
                 } else {
@@ -133,17 +146,26 @@ private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnv
         }
     }
 
+    /**
+     * 检查 事件处理方法是否"合法"
+     * @param element - 所要检查的方法元素
+     * @param messager
+     * @return
+     */
     private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
+        // 方法的修饰符中是否含有 STATIC
         if (element.getModifiers().contains(Modifier.STATIC)) {
             messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must not be static", element);
             return false;
         }
 
+        // 方法的修饰符中是否含有 PUBLIC
         if (!element.getModifiers().contains(Modifier.PUBLIC)) {
             messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must be public", element);
             return false;
         }
 
+        // 方法的参数数量是否是1
         List<? extends VariableElement> parameters = ((ExecutableElement) element).getParameters();
         if (parameters.size() != 1) {
             messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must have exactly 1 parameter", element);
@@ -156,10 +178,13 @@ private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
      * Subscriber classes should be skipped if their class or any involved event class are not visible to the index.
      */
     private void checkForSubscribersToSkip(Messager messager, String myPackage) {
+        // 遍历 声明订阅方法的类元素
         for (TypeElement skipCandidate : methodsByClass.keySet()) {
             TypeElement subscriberClass = skipCandidate;
             while (subscriberClass != null) {
+                // 1、判断 声明订阅方法的类 是否对 indexPackage 可见
                 if (!isVisible(myPackage, subscriberClass)) {
+                    // 不可见，则将skipCandidate加入到跳过的集合中方
                     boolean added = classesToSkip.add(skipCandidate);
                     if (added) {
                         String msg;
@@ -171,14 +196,21 @@ private void checkForSubscribersToSkip(Messager messager, String myPackage) {
                         }
                         messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);
                     }
+                    // 跳出 While 循环
                     break;
                 }
+                // 此处就是 可见的
+                // 2、获取 subscriberClass 类中定义的 订阅方法元素 集合，检查 订阅方法的参数 是否 合法
                 List<ExecutableElement> methods = methodsByClass.get(subscriberClass);
                 if (methods != null) {
+                    // 遍历 方法元素
                     for (ExecutableElement method : methods) {
                         String skipReason = null;
+                        // 获取 订阅方法的 唯一 参数
                         VariableElement param = method.getParameters().get(0);
+                        // 获取 参数变量元素的 类型（TypeMirror）
                         TypeMirror typeMirror = getParamTypeMirror(param, messager);
+                        // DeclaredType 表示 一个类元素 或 接口元素
                         if (!(typeMirror instanceof DeclaredType) ||
                                 !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) {
                             skipReason = "event type cannot be processed";
@@ -190,6 +222,7 @@ private void checkForSubscribersToSkip(Messager messager, String myPackage) {
                             }
                         }
                         if (skipReason != null) {
+                            // 参数不合法，将声明订阅方法的类，添加到classesToSkip
                             boolean added = classesToSkip.add(skipCandidate);
                             if (added) {
                                 String msg = "Falling back to reflection because " + skipReason;
@@ -310,11 +343,18 @@ private void writeCreateSubscriberMethods(BufferedWriter writer, List<Executable
     private void createInfoIndexFile(String index) {
         BufferedWriter writer = null;
         try {
+            // 创建 Java 文件
             JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index);
+
+            // 获取 该java 文件的 包名类名等信息。
             int period = index.lastIndexOf('.');
             String myPackage = period > 0 ? index.substring(0, period) : null;
             String clazz = index.substring(period + 1);
+
+            // 初始化 writer对象，以便 向生成的Java文件中 写入数据
             writer = new BufferedWriter(sourceFile.openWriter());
+
+            // 开始写入数据
             if (myPackage != null) {
                 writer.write("package " + myPackage + ";\n\n");
             }
@@ -326,10 +366,14 @@ private void createInfoIndexFile(String index) {
             writer.write("import java.util.HashMap;\n");
             writer.write("import java.util.Map;\n\n");
             writer.write("/** This class is generated by EventBus, do not edit. */\n");
+
+            // 类声明 的代码
             writer.write("public class " + clazz + " implements SubscriberInfoIndex {\n");
             writer.write("    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n");
             writer.write("    static {\n");
             writer.write("        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();\n\n");
+
+            // 关键代码
             writeIndexLines(writer, myPackage);
             writer.write("    }\n\n");
             writer.write("    private static void putIndex(SubscriberInfo info) {\n");
@@ -359,11 +403,14 @@ private void createInfoIndexFile(String index) {
     }
 
     private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOException {
+        // 遍历 methodsByClass中 声明订阅方法的类元素
         for (TypeElement subscriberTypeElement : methodsByClass.keySet()) {
+            // 跳过 被保存到classesToSkip中的类
             if (classesToSkip.contains(subscriberTypeElement)) {
                 continue;
             }
 
+            //
             String subscriberClass = getClassString(subscriberTypeElement, myPackage);
             if (isVisible(myPackage, subscriberTypeElement)) {
                 writeLine(writer, 2,
@@ -378,14 +425,23 @@ private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOE
         }
     }
 
+    /**
+     * 判断 typeElement所指代的元素对否对 myPackage可见
+     * @param myPackage
+     * @param typeElement
+     * @return
+     */
     private boolean isVisible(String myPackage, TypeElement typeElement) {
         Set<Modifier> modifiers = typeElement.getModifiers();
         boolean visible;
         if (modifiers.contains(Modifier.PUBLIC)) {
+            // 该元素的修饰符中 含有 PUBLIC，可见
             visible = true;
         } else if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) {
+            // 该元素的修饰符中含有 PRIVATE或PROTECTED，不可见
             visible = false;
         } else {
+            // 判断 该元素所在的包是不是 与 myPackage相同
             String subscriberPackage = getPackageElement(typeElement).getQualifiedName().toString();
             if (myPackage == null) {
                 visible = subscriberPackage.length() == 0;
