diff --git a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
index 2a5319d0..fc66999e 100644
--- a/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/BackgroundPoster.java
@@ -50,12 +50,14 @@ public void run() {
         try {
             try {
                 while (true) {
+                    //延迟1秒执行执行
                     PendingPost pendingPost = queue.poll(1000);
                     if (pendingPost == null) {
                         synchronized (this) {
                             // Check again, this time in synchronized
                             pendingPost = queue.poll();
                             if (pendingPost == null) {
+                                //如果没有消息了,方法返回
                                 executorRunning = false;
                                 return;
                             }
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index 75e0a199..8b34d10c 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -53,17 +53,24 @@
      */
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
     /**
-     * 事件类型缓存???
+     * 事件类型缓存
+     * 事件类-父类&接口&父类的父类&父类的接口....即所有超类包含接口
+     * 1-n关系
      */
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
     /**
      * 类和订阅者存储,第一个为创建的Event对象,第二个为订阅者
+     * 事件类-订阅者方法
      */
     private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+
+    /**
+     * 用途:根据订阅者去查找EventType的缓存
+     */
     private final Map<Object, List<Class<?>>> typesBySubscriber;
     /**
-     * 主要完成的是事情就是保存sticky 标记的类,可以将附带的信息保存起来,在需要的时候可以再取出来
+     * 粘性事件缓存,key:EventType.class;value:EventType实例
      */
     private final Map<Class<?>, Object> stickyEvents;
 
@@ -74,10 +81,25 @@ protected PostingThreadState initialValue() {
         }
     };
 
+    /**
+     * 主线程处理类
+     */
     private final HandlerPoster mainThreadPoster;
+    /**
+     * 非主线程执行
+     */
     private final BackgroundPoster backgroundPoster;
+    /**
+     * 新开线程执行
+     */
     private final AsyncPoster asyncPoster;
+    /**
+     * 订阅方法查找类
+     */
     private final SubscriberMethodFinder subscriberMethodFinder;
+    /**
+     * 事件执行者
+     */
     private final ExecutorService executorService;
 
     private final boolean throwSubscriberException;
@@ -85,8 +107,14 @@ protected PostingThreadState initialValue() {
     private final boolean logNoSubscriberMessages;
     private final boolean sendSubscriberExceptionEvent;
     private final boolean sendNoSubscriberEvent;
+    /**
+     * 处理粘性事件的继承
+     */
     private final boolean eventInheritance;
 
+    /**
+     * 索引数量
+     */
     private final int indexCount;
 
     /**
@@ -107,6 +135,7 @@ public static EventBus getDefault() {
 
     /**
      * 创建一个构建者
+     *
      * @return
      */
     public static EventBusBuilder builder() {
@@ -132,6 +161,7 @@ public EventBus() {
 
     /**
      * 通过构建者 构建EventBus
+     *
      * @param builder
      */
     EventBus(EventBusBuilder builder) {
@@ -154,6 +184,8 @@ public EventBus() {
     }
 
     /**
+     * 注册方法;
+     * <p>
      * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
      * are no longer interested in receiving events.
      * <p/>
@@ -162,7 +194,9 @@ public EventBus() {
      * ThreadMode} and priority.
      */
     public void register(Object subscriber) {
+//        注册方法
         Class<?> subscriberClass = subscriber.getClass();
+        //查找订阅方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
@@ -171,16 +205,24 @@ public void register(Object subscriber) {
         }
     }
 
-    // Must be called in synchronized block
+    /**
+     * 必须在同步代码块中调用
+     *
+     * @param subscriber
+     * @param subscriberMethod
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
         if (subscriptions == null) {
+            //这个事件没有其他的订阅者
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            //不为空,意味着这个事件还有其他的订阅者
             if (subscriptions.contains(newSubscription)) {
+                //如果有重复的订阅者,报错
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
             }
@@ -188,12 +230,13 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
+            //优先级处理,其实就是按照优先级插入到集合中
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
-
+        //处理EventType缓存,暂时不知道有什么好处
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
@@ -202,11 +245,16 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         subscribedEvents.add(eventType);
 
         if (subscriberMethod.sticky) {
+            //如果是粘性事件
             if (eventInheritance) {
-                // Existing sticky events of all subclasses of eventType have to be considered.
-                // Note: Iterating over all events may be inefficient with lots of sticky events,
-                // thus data structure should be changed to allow a more efficient lookup
-                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                /**
+                 *  处理粘性事件的超类
+                 *  Existing sticky events of all subclasses of eventType have to be considered.
+                 *  Note: Iterating over all events may be inefficient with lots of sticky events,
+                 *  thus data structure should be changed to allow a more efficient lookup
+                 *  (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                 *  stickyEvents 的赋值在{@link EventBus#postSticky}
+                 */
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
@@ -216,12 +264,18 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                     }
                 }
             } else {
+                //不考虑超类的情况
                 Object stickyEvent = stickyEvents.get(eventType);
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
         }
     }
 
+    /**
+     * post粘性事件
+     * @param newSubscription
+     * @param stickyEvent
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
@@ -269,7 +323,7 @@ public synchronized void unregister(Object subscriber) {
     }
 
     /**
-     * Posts the given event to the event bus.
+     * 发送一个事件
      */
     public void post(Object event) {
         PostingThreadState postingState = currentPostingThreadState.get();
@@ -280,10 +334,12 @@ public void post(Object event) {
             postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
             postingState.isPosting = true;
             if (postingState.canceled) {
+                //内部错误,状态没有重置
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
                 while (!eventQueue.isEmpty()) {
+                    //如果不为空
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
@@ -317,6 +373,7 @@ public void cancelEventDelivery(Object event) {
     }
 
     /**
+     * 发送一个粘性事件,更加高效
      * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
      * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
      */
@@ -340,6 +397,7 @@ public void postSticky(Object event) {
     }
 
     /**
+     * 移出一个粘性事件并返回一个实例
      * Remove and gets the recent sticky event for the given event type.
      *
      * @see #postSticky(Object)
@@ -351,6 +409,7 @@ public void postSticky(Object event) {
     }
 
     /**
+     * 移除一个粘性事件
      * Removes the sticky event if it equals to the given event.
      *
      * @return true if the events matched and the sticky event was removed.
@@ -369,6 +428,7 @@ public boolean removeStickyEvent(Object event) {
     }
 
     /**
+     * 清空粘性事件
      * Removes all sticky events.
      */
     public void removeAllStickyEvents() {
@@ -377,6 +437,11 @@ public void removeAllStickyEvents() {
         }
     }
 
+    /**
+     * 事件是否有订阅者
+     * @param eventClass
+     * @return
+     */
     public boolean hasSubscriberForEvent(Class<?> eventClass) {
         List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
         if (eventTypes != null) {
@@ -395,20 +460,31 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 处理一个事件
+     * @param event
+     * @param postingState
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            //处理超类和自身
+            //查找超类&接口
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
+                //遍历发送所有超类事件
                 Class<?> clazz = eventTypes.get(h);
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            //不处理超类
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
+            //该事件没有订阅者,只要有一个发送成功就不会走这个方法
             if (logNoSubscriberMessages) {
                 Log.d(TAG, "No subscribers registered for event " + eventClass);
             }
@@ -419,6 +495,13 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     * 发送一个事件,包换事件类的超类
+     * @param event
+     * @param postingState
+     * @param eventClass
+     * @return
+     */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
@@ -446,6 +529,12 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 发送事件广播
+     * @param subscription
+     * @param event
+     * @param isMainThread
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -474,6 +563,7 @@ private void postToSubscription(Subscription subscription, Object event, boolean
     }
 
     /**
+     * 查找一个事件的父类,并且包含接口
      * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
      */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
@@ -483,8 +573,11 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                 eventTypes = new ArrayList<>();
                 Class<?> clazz = eventClass;
                 while (clazz != null) {
+                    //添加自身
                     eventTypes.add(clazz);
+                    //添加接口
                     addInterfaces(eventTypes, clazz.getInterfaces());
+                    //获取父类
                     clazz = clazz.getSuperclass();
                 }
                 eventTypesCache.put(eventClass, eventTypes);
@@ -506,6 +599,7 @@ static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
     }
 
     /**
+     * 执行一个订阅方法
      * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
      * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
      * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
@@ -520,6 +614,11 @@ void invokeSubscriber(PendingPost pendingPost) {
         }
     }
 
+    /**
+     * 执行一个订阅方法
+     * @param subscription
+     * @param event
+     */
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
@@ -530,6 +629,12 @@ void invokeSubscriber(Subscription subscription, Object event) {
         }
     }
 
+    /**
+     * 处理订阅方法异常
+     * @param subscription
+     * @param event
+     * @param cause
+     */
     private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
         if (event instanceof SubscriberExceptionEvent) {
             if (logSubscriberExceptions) {
@@ -557,6 +662,7 @@ private void handleSubscriberException(Subscription subscription, Object event,
     }
 
     /**
+     * 本地线程状态,比get和set要快一些
      * For ThreadLocal, much faster to set (and get multiple values).
      */
     final static class PostingThreadState {
@@ -573,7 +679,8 @@ ExecutorService getExecutorService() {
     }
 
     // Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...
-    /* public */interface PostCallback {
+    /* public */
+    interface PostCallback {
         void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
     }
 
diff --git a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
index 6bf38276..130a30d2 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBusBuilder.java
@@ -37,11 +37,28 @@
     boolean sendSubscriberExceptionEvent = true;
     boolean sendNoSubscriberEvent = true;
     boolean throwSubscriberException;
+
+    /**
+     * 是否考虑子类,就是一个订阅事件继承另一个订阅事件
+     */
     boolean eventInheritance = true;
+    /**
+     * EventBusAnnotationProcessor APT自动生成index,如果使用了,那么在程序初始化中就不用做任何事情;
+     * 提高了效率
+     */
     boolean ignoreGeneratedIndex;
     boolean strictMethodVerification;
+    /**
+     * 默认线程池
+     */
     ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;
+    /**
+     * 跳过方法验证?
+     */
     List<Class<?>> skipMethodVerificationForClasses;
+    /**
+     * 订阅者序列,APT自动生成
+     */
     List<SubscriberInfoIndex> subscriberInfoIndexes;
 
     EventBusBuilder() {
@@ -124,11 +141,11 @@ public EventBusBuilder executorService(ExecutorService executorService) {
 
     /**
      * 不太明白
-     *
+     * <p>
      * 对于以onEvent开头的方法，方法名称的验证是为了避免拼写错误;
      * 使用此方法，您可以从此检查中排除订阅类。
      * 还禁用检查方法修饰符（public，not static或abstract）
-     *
+     * <p>
      * Method name verification is done for methods starting with onEvent to avoid typos; using this method you can
      * exclude subscriber classes from this check. Also disables checks for method modifiers (public, not static nor
      * abstract).
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 3247be53..d25b6e29 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -20,11 +20,24 @@
 import android.os.Message;
 import android.os.SystemClock;
 
+/**
+ * 主线程时间处理类
+ */
 final class HandlerPoster extends Handler {
 
+    /**
+     * 事件队列
+     */
     private final PendingPostQueue queue;
+    /**
+     * 其实就是执行一个事件的事件,如果大于一定值,则认为这个事件处理失败
+     */
     private final int maxMillisInsideHandleMessage;
     private final EventBus eventBus;
+    /**
+     * 是否可以处理活动
+     * true:可以,false,正在处理
+     */
     private boolean handlerActive;
 
     HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
@@ -34,13 +47,21 @@
         queue = new PendingPostQueue();
     }
 
+    /**
+     * 添加一个事件到队列
+     *
+     * @param subscription
+     * @param event
+     */
     void enqueue(Subscription subscription, Object event) {
         PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
         synchronized (this) {
             queue.enqueue(pendingPost);
             if (!handlerActive) {
+                //正在处理事件
                 handlerActive = true;
                 if (!sendMessage(obtainMessage())) {
+                    //发送失败
                     throw new EventBusException("Could not send handler message");
                 }
             }
@@ -59,12 +80,14 @@ public void handleMessage(Message msg) {
                         // Check again, this time in synchronized
                         pendingPost = queue.poll();
                         if (pendingPost == null) {
+//                            只能同时处理一个事件
                             handlerActive = false;
                             return;
                         }
                     }
                 }
                 eventBus.invokeSubscriber(pendingPost);
+                //时间上的判断,是否超时,这个有啥用...执行之后再统计?
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
                     if (!sendMessage(obtainMessage())) {
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 01f474c2..936cf5ea 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -18,6 +18,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * 要执行的对象
+ */
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
 
@@ -30,6 +33,15 @@ private PendingPost(Object event, Subscription subscription) {
         this.subscription = subscription;
     }
 
+    /**
+     * 获取一个新的PendingPost;
+     * 如果有缓存,那么从缓存拿;
+     * 如果没有,重新创建一个;
+     *
+     * @param subscription
+     * @param event
+     * @return
+     */
     static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         synchronized (pendingPostPool) {
             int size = pendingPostPool.size();
@@ -44,6 +56,11 @@ static PendingPost obtainPendingPost(Subscription subscription, Object event) {
         return new PendingPost(event, subscription);
     }
 
+    /**
+     * 移出一个paddingPost,将移出的对象添加到缓存中,缓存最大为1000(好大...)
+     *
+     * @param pendingPost
+     */
     static void releasePendingPost(PendingPost pendingPost) {
         pendingPost.event = null;
         pendingPost.subscription = null;
diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
index 55db529a..38943eee 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPostQueue.java
@@ -16,10 +16,23 @@
 
 package org.greenrobot.eventbus;
 
+/**
+ * 执行队列
+ */
 final class PendingPostQueue {
+    /**
+     * 头
+     */
     private PendingPost head;
+    /**
+     * 尾
+     */
     private PendingPost tail;
 
+    /**
+     * 添加一个要执行的对象
+     * @param pendingPost
+     */
     synchronized void enqueue(PendingPost pendingPost) {
         if (pendingPost == null) {
             throw new NullPointerException("null cannot be enqueued");
@@ -32,9 +45,14 @@ synchronized void enqueue(PendingPost pendingPost) {
         } else {
             throw new IllegalStateException("Head present, but no tail");
         }
+        //唤醒线程?
         notifyAll();
     }
 
+    /**
+     * 取走头结点
+     * @return
+     */
     synchronized PendingPost poll() {
         PendingPost pendingPost = head;
         if (head != null) {
@@ -46,6 +64,12 @@ synchronized PendingPost poll() {
         return pendingPost;
     }
 
+    /**
+     * 等待秒再执行
+     * @param maxMillisToWait
+     * @return
+     * @throws InterruptedException
+     */
     synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException {
         if (head == null) {
             wait(maxMillisToWait);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1fa43645..f1678885 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -31,7 +31,7 @@
      */
     final ThreadMode threadMode;
     /**
-     * 事件类型,其实就是Event.post(new Object.class);
+     * 事件类型,其实就是Event.post(new Object.class)的OBject.class;
      */
     final Class<?> eventType;
     /**
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..1836d7fe 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -26,23 +26,62 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
+
+/**
+ * 在行的类文件中,编译器可能添加了方法<br/>
+ * 他们是桥接和合成方法<br/>
+ * EventBus必须忽略他们<br/>
+ * 这些方法在java文件中并不是public的<br/>
+ * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
+ * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
+ * <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1">参考<a/>
+ */
 class SubscriberMethodFinder {
-    /*
-     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
-     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
-     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1
+    /**
+     * 由于不是public的,直接定义出来
+     * {link {@link Modifier#BRIDGE}}
      */
     private static final int BRIDGE = 0x40;
+    /**
+     * 由于不是public的,直接定义出来
+     * {link {@link Modifier#SYNTHETIC}}
+     */
     private static final int SYNTHETIC = 0x1000;
 
+    /**
+     * 忽略以什么标记的类后面两个不知道啥意思,jdk文档里也没有,,好奇怪
+     * 抽象,静态修饰的方法忽略
+     */
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
 
+    /**
+     * 方法缓存<br/>
+     * <a href="http://ifeve.com/ConcurrentHashMap/">ConcurrentHashMap参考<a/><br/>
+     * 最多支持16个线程同时操作<br/>
+     * 由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。
+     */
+    private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
+    /**
+     * 索引
+     */
     private List<SubscriberInfoIndex> subscriberInfoIndexes;
+    /**
+     * 是否严格的方法验证,如果方法定义不符合要求切这个变量为true,那么直接报错
+     * 如果false,忽略那个方法,不会报错
+     */
     private final boolean strictMethodVerification;
+    /**
+     * 是否忽略Apt生成的索引信息.默认false
+     */
     private final boolean ignoreGeneratedIndex;
-
+    /**
+     * 线程池大小
+     */
     private static final int POOL_SIZE = 4;
+
+    /**
+     * 查找状态池?
+     */
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
 
     SubscriberMethodFinder(List<SubscriberInfoIndex> subscriberInfoIndexes, boolean strictMethodVerification,
@@ -52,21 +91,30 @@
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
 
+    /**
+     * 查找订阅的方法
+     *
+     * @param subscriberClass EventType
+     * @return
+     */
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        //从缓存拿
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        //是否忽略了自动生成的索引
         if (ignoreGeneratedIndex) {
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
+            //如果没有订阅方法
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            //放入缓存
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -92,6 +140,13 @@
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 从FindState里面拿到订阅者方法集合<br/>
+     * 并将笨findState对象添加到池中
+     *
+     * @param findState
+     * @return
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
@@ -106,6 +161,11 @@
         return subscriberMethods;
     }
 
+    /**
+     * 从池中获取一个FindState
+     *
+     * @return
+     */
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
@@ -137,31 +197,50 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 利用反射获取
+     *
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
+        //将订阅者传递过去
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
             findUsingReflectionInSingleClass(findState);
+            //当没有父类的时候跳出循环
             findState.moveToSuperclass();
         }
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 反射查找一个类总的订阅方法
+     *
+     * @param findState
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
+            //getDeclaredMethods()比getMethod方法快,getMethod查找的不仅是本类的,所有的父类的也会列出来
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
+            //在某些设备上会报java.lang.NoClassDefFoundError 错误
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
             methods = findState.clazz.getMethods();
+            //如果使用了获取所有方法,那么跳过检查父类
             findState.skipSuperClasses = true;
         }
         for (Method method : methods) {
+            //获取方法修饰符
             int modifiers = method.getModifiers();
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                //方法是public的并且不是忽略方法
                 Class<?>[] parameterTypes = method.getParameterTypes();
                 if (parameterTypes.length == 1) {
+                    //参数为数目为1
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
                         Class<?> eventType = parameterTypes[0];
@@ -172,11 +251,15 @@ private void findUsingReflectionInSingleClass(FindState findState) {
                         }
                     }
                 } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                    //参数数量不是1的情况
+                    //参数多个并且使用了严格的方法检查,并且是使用#Subscribe注解的
+                    //在这里就可以看出strictMethodVerification这个属性的作用了,就是在方法验证的时候,如果不符合要求,是否强制报错
                     String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                     throw new EventBusException("@Subscribe method " + methodName +
                             "must have exactly 1 parameter but has " + parameterTypes.length);
                 }
             } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
+                //如果修饰符不是public
                 String methodName = method.getDeclaringClass().getName() + "." + method.getName();
                 throw new EventBusException(methodName +
                         " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
@@ -188,23 +271,47 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 订阅方法查找结果的封装
+     */
     static class FindState {
+        //订阅方法集合
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+        //eventType-FindState
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+        /**
+         * 方法全名-所在类
+         */
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
+        /**
+         * 其实装的是 com.yzl.ClassName>methodName
+         */
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
         Class<?> subscriberClass;
+        /**
+         * EventType对应的class文件
+         */
         Class<?> clazz;
+        //是否跳过父类
         boolean skipSuperClasses;
+        //订阅信息
         SubscriberInfo subscriberInfo;
 
+        /**
+         * 初始化
+         *
+         * @param subscriberClass
+         */
         void initForSubscriber(Class<?> subscriberClass) {
             this.subscriberClass = clazz = subscriberClass;
             skipSuperClasses = false;
             subscriberInfo = null;
         }
 
+        /**
+         * 重用,清除信息
+         */
         void recycle() {
             subscriberMethods.clear();
             anyMethodByEventType.clear();
@@ -216,6 +323,14 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        /**
+         * 二级检查,通常是一个方法只能监听一个事件,应该是这样子理解
+         * 二级检查需要完整的签名
+         *
+         * @param method
+         * @param eventType
+         * @return
+         */
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
@@ -235,31 +350,47 @@ boolean checkAdd(Method method, Class<?> eventType) {
             }
         }
 
+        /**
+         * 检查方法签名
+         *
+         * @param method
+         * @param eventType
+         * @return
+         */
         private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
             methodKeyBuilder.setLength(0);
             methodKeyBuilder.append(method.getName());
             methodKeyBuilder.append('>').append(eventType.getName());
 
             String methodKey = methodKeyBuilder.toString();
+            //获取申明类
             Class<?> methodClass = method.getDeclaringClass();
+            //旧的类
             Class<?> methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
             if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
+                //isAssignableFrom:判断一个类Class1和另一个类Class2是否相同或是另一个类的子类或接口
                 // Only add if not already found in a sub class
                 return true;
             } else {
                 // Revert the put, old class is further down the class hierarchy
+                //重新将旧对象放进去,旧的类下降了类的层次结构?????不懂
                 subscriberClassByMethodKey.put(methodKey, methodClassOld);
                 return false;
             }
         }
 
+        /**
+         * 转移到父类,查找父类type的方法
+         */
         void moveToSuperclass() {
             if (skipSuperClasses) {
+                //不忽略父类
                 clazz = null;
             } else {
+                //忽略父类
                 clazz = clazz.getSuperclass();
                 String clazzName = clazz.getName();
-                /** Skip system classes, this just degrades performance. */
+                /** 跳过系统jdk类和Android sdk 的类,提高速度*/
                 if (clazzName.startsWith("java.") || clazzName.startsWith("javax.") || clazzName.startsWith("android.")) {
                     clazz = null;
                 }
diff --git a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
index 1e7f99f9..845a685a 100644
--- a/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
+++ b/EventBus/src/org/greenrobot/eventbus/ThreadMode.java
@@ -24,7 +24,7 @@
  */
 public enum ThreadMode {
     /**
-     * 同一个线程
+     * 同一个线程<br/>
      * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery
      * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for
      * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers
@@ -33,7 +33,7 @@
     POSTING,
 
     /**
-     * Android 主线程
+     * Android 主线程<br/>
      * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is
      * the main thread, event handler methods will be called directly. Event handlers using this mode must return
      * quickly to avoid blocking the main thread.
@@ -41,7 +41,7 @@
     MAIN,
 
     /**
-     * 后台线程,如果不是主线程,那么还在当前线程执行
+     * 后台线程,如果不是主线程,那么还在当前线程执行<br/>
      * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods
      * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single
      * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to
@@ -50,7 +50,7 @@
     BACKGROUND,
 
     /**
-     * 重新创建一个线程
+     * 重新创建一个线程<br/>
      * Event handler methods are called in a separate thread. This is always independent from the posting thread and the
      * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should
      * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number
