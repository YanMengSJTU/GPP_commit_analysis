diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e42c2bed..e17dae4e 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -166,7 +166,7 @@ public void register(Object subscriber) {
      * @param subscriberMethod   订阅事件方法, 比如加了@Subscribe注解的方法
      */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
-        // 订阅事件的类, 比如平常传递的自己写的EventSubscriber等等..
+        // 订阅事件的类, 比如平常传递的自己写的EventLogin等等..
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         // 获取与eventType有关的订阅事件的队列
@@ -199,8 +199,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
         subscribedEvents.add(eventType);
-        // TODO: 2018/3/29 理解粘性 yutt
-        // 是否粘性事件(粘性???)
+        // 是否粘性事件
         if (subscriberMethod.sticky) {
             // 是否分发订阅了响应事件类父类事件的方法, 默认为true
             if (eventInheritance) {
@@ -208,10 +207,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
                 // thus data structure should be changed to allow a more efficient lookup
                 // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+                // stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
+                    // 获取候选eventType
                     Class<?> candidateEventType = entry.getKey();
+                    // native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配
                     if (eventType.isAssignableFrom(candidateEventType)) {
+                        // 如果匹配, 校验并发送订阅
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                     }
@@ -223,8 +226,14 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         }
     }
 
+    /**
+     * 校验并发送订阅
+     * @param newSubscription 新的订阅
+     * @param stickyEvent 粘性eventType
+     */
     private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
         if (stickyEvent != null) {
+            // 如果订阅者尝试中断响应事件, 就不会post
             // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
             // --> Strange corner case, which we don't take care of here.
             postToSubscription(newSubscription, stickyEvent, isMainThread());
@@ -245,6 +254,9 @@ public synchronized boolean isRegistered(Object subscriber) {
         return typesBySubscriber.containsKey(subscriber);
     }
 
+    /**
+     * 只更新通过eventType分类的订阅者, 而不更新根据订阅者区分的eventType
+     */
     /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
     private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
@@ -252,8 +264,11 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
             int size = subscriptions.size();
             for (int i = 0; i < size; i++) {
                 Subscription subscription = subscriptions.get(i);
+                // 如果key为eventType的订阅者队列里, 能找到对应的匹配队列这
                 if (subscription.subscriber == subscriber) {
+                    // 关闭active
                     subscription.active = false;
+                    // 移除相关的订阅者
                     subscriptions.remove(i);
                     i--;
                     size--;
@@ -262,36 +277,55 @@ private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
         }
     }
 
+    /**
+     * 解绑
+     */
     /** Unregisters the given subscriber from all event classes. */
     public synchronized void unregister(Object subscriber) {
+        // 根据订阅者获取对应的eventType
         List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
+        // 如果不为空
         if (subscribedTypes != null) {
+            // 遍历解绑
             for (Class<?> eventType : subscribedTypes) {
                 unsubscribeByEventType(subscriber, eventType);
             }
+            // 移除相关的eventType
             typesBySubscriber.remove(subscriber);
         } else {
             logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
         }
     }
 
+    /**
+     * 事件发送
+     */
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        // currentPostingThreadState 为ThreadLocal对象
+        // 获取当前线程的发送状态
         PostingThreadState postingState = currentPostingThreadState.get();
+        // 获取当前线程的事件发送队列
         List<Object> eventQueue = postingState.eventQueue;
+        // 添加事件
         eventQueue.add(event);
-
+        // 如果不在发送中
         if (!postingState.isPosting) {
+            // 判断是否在主线程
             postingState.isMainThread = isMainThread();
+            // 修改发送中状态
             postingState.isPosting = true;
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                // 遍历发送队列事件
                 while (!eventQueue.isEmpty()) {
+                    // 从队头开始发送, 同时移除队列中的对应事件
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
+                // 修改发送中状态, 修改主线程判断
                 postingState.isPosting = false;
                 postingState.isMainThread = false;
             }
@@ -400,12 +434,23 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 发送单个事件
+     * @param event
+     * @param postingState
+     * @throws Error
+     */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+        // event 是对应eventType的实例
         Class<?> eventClass = event.getClass();
+        // 默认没有找到订阅者
         boolean subscriptionFound = false;
+        // 默认true, 判断是否触发eventType的父类或接口的订阅
         if (eventInheritance) {
+            // 查找获取所有eventType的父类和接口
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
+            // 循环发送
             for (int h = 0; h < countTypes; h++) {
                 Class<?> clazz = eventTypes.get(h);
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
@@ -413,12 +458,15 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         } else {
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
+        // 如果没有找到订阅者
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
                 logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
             }
+            // 如果我们的builder配置了sendNoSubscriberEvent(默认为true)
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
+                // 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理
                 post(new NoSubscriberEvent(this, event));
             }
         }
@@ -427,6 +475,7 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
         synchronized (this) {
+            // 根据eventType获取订阅者
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
         if (subscriptions != null && !subscriptions.isEmpty()) {
@@ -435,6 +484,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 发送给订阅者
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -451,18 +501,30 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 订阅发布
+     * @param subscription 新注册的订阅者
+     * @param event eventType
+     * @param isMainThread 是否主线程
+     */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+        // 订阅方法的指定线程
         switch (subscription.subscriberMethod.threadMode) {
+            // 相同线程内
             case POSTING:
                 invokeSubscriber(subscription, event);
                 break;
+            // 主线程内, 不阻塞
             case MAIN:
                 if (isMainThread) {
+                    // 订阅者的调用
                     invokeSubscriber(subscription, event);
                 } else {
+                    // 通过handler处理
                     mainThreadPoster.enqueue(subscription, event);
                 }
                 break;
+            // 主线程, 阻塞
             case MAIN_ORDERED:
                 if (mainThreadPoster != null) {
                     mainThreadPoster.enqueue(subscription, event);
@@ -471,13 +533,16 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     invokeSubscriber(subscription, event);
                 }
                 break;
+            // 后台线程,
             case BACKGROUND:
                 if (isMainThread) {
+                    // 实现了Runnable
                     backgroundPoster.enqueue(subscription, event);
                 } else {
                     invokeSubscriber(subscription, event);
                 }
                 break;
+            // 异步线程
             case ASYNC:
                 asyncPoster.enqueue(subscription, event);
                 break;
@@ -531,6 +596,7 @@ void invokeSubscriber(PendingPost pendingPost) {
 
     void invokeSubscriber(Subscription subscription, Object event) {
         try {
+            // 订阅方法的调用
             subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
         } catch (InvocationTargetException e) {
             handleSubscriberException(subscription, event, e.getCause());
diff --git a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
index 95309547..27fc6168 100644
--- a/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
+++ b/EventBus/src/org/greenrobot/eventbus/HandlerPoster.java
@@ -64,6 +64,7 @@ public void handleMessage(Message msg) {
                         }
                     }
                 }
+                // 调用订阅者
                 eventBus.invokeSubscriber(pendingPost);
                 long timeInMethod = SystemClock.uptimeMillis() - started;
                 if (timeInMethod >= maxMillisInsideHandleMessage) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 013006ad..10501452 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -59,7 +59,7 @@
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-        // 查找注册方法
+        // 查找注册方法, 默认false
         if (ignoreGeneratedIndex) {
             // 使用反射查找
             subscriberMethods = findUsingReflection(subscriberClass);
diff --git a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
index b21efabf..23773989 100644
--- a/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
+++ b/EventBusPerformance/src/org/greenrobot/eventbusperf/TestRunnerActivity.java
@@ -45,6 +45,8 @@ public void onCreate(Bundle savedInstanceState) {
         textViewResult = findViewById(R.id.textViewResult);
         controlBus = new EventBus();
         controlBus.register(this);
+
+        
     }
 
     @Override
