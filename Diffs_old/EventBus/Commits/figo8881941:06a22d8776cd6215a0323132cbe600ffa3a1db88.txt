diff --git a/EventBus/src/org/greenrobot/eventbus/PendingPost.java b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
index 86dc225f..a6ed3807 100644
--- a/EventBus/src/org/greenrobot/eventbus/PendingPost.java
+++ b/EventBus/src/org/greenrobot/eventbus/PendingPost.java
@@ -20,7 +20,7 @@
 
 /**
  * 将要发布的信息类
- * 这里使用了缓存池，避免频繁创建过多的临时对象，导致GC，影响性能
+ * 这里使用了缓存池，避免频繁创建过多的临时对象，消耗资源，导致GC，影响性能
  */
 final class PendingPost {
     private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..92b2a2a3 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -19,12 +19,18 @@
 
 /** Used internally by EventBus and generated subscriber indexes. */
 public class SubscriberMethod {
+    //订阅方法
     final Method method;
+    //订阅方法回调的线程方式
     final ThreadMode threadMode;
+    //事件类型
     final Class<?> eventType;
+    //优先级
     final int priority;
+    //是否粘性
     final boolean sticky;
     /** Used for efficient comparison */
+    //用于比较两个订阅方法是否一样的字符串
     String methodString;
 
     public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 19f397ca..1f8816dc 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -44,6 +44,7 @@
     private final boolean strictMethodVerification;
     private final boolean ignoreGeneratedIndex;
 
+    //FindState缓存池，避免频繁创建临时对象，消耗资源，引起GC，影响性能
     private static final int POOL_SIZE = 4;
     private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
 
@@ -61,8 +62,11 @@
         }
 
         if (ignoreGeneratedIndex) {
+            //直接通过反射，获取订阅方法
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            //优先通过编译期生成的SubscriberInfo来获取订阅方法
+            //如果没有SubscriberInfo，则仍然走findUsingReflection
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
@@ -94,6 +98,11 @@
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 释放FindState并方法订阅方法集合的方法
+     * @param findState
+     * @return
+     */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
@@ -150,6 +159,7 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
     }
 
     private void findUsingReflectionInSingleClass(FindState findState) {
+        //获取订阅者所有的方法
         Method[] methods;
         try {
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
@@ -161,6 +171,7 @@ private void findUsingReflectionInSingleClass(FindState findState) {
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            //订阅方法必须是public，而且只有一个参数
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
                 if (parameterTypes.length == 1) {
@@ -190,15 +201,27 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 方法查找状态信息类
+     */
     static class FindState {
+        //订阅方法集合
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
+        //以订阅事件类型分类的订阅方法集合
+        //保存的是某个类型的事件对应的订阅方法
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
+        //以MethodKey进行分类的Class对象集合
+        //保存的是某个MethodKey对应的Class对象
         final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();
         final StringBuilder methodKeyBuilder = new StringBuilder(128);
 
+        //订阅对象的Class对象
         Class<?> subscriberClass;
+        //查找过程中使用到的Class对象
         Class<?> clazz;
+        //是否跳过父类，默认false
         boolean skipSuperClasses;
+        //订阅者信息类，在编译期生成
         SubscriberInfo subscriberInfo;
 
         void initForSubscriber(Class<?> subscriberClass) {
@@ -221,10 +244,16 @@ void recycle() {
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            //一般情况下，一个订阅者不会出现有多个订阅方法订阅相同类型的事件
+            //如果有，可能两种情况
+            //1.真的定义了多个方法订阅相同类型的事件
+            //2.因为继承关系，父类和自身定义了方法订阅相同类型的事件
             Object existing = anyMethodByEventType.put(eventType, method);
             if (existing == null) {
+                //如果还没有存在订阅该类型事件的方法，直接返回true
                 return true;
             } else {
+                //如果已经存在订阅该类型事件的方法，就要进行判断
                 if (existing instanceof Method) {
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
