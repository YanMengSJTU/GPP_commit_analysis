diff --git a/EventBus/build.gradle b/EventBus/build.gradle
index b377bf64..b8ad8c0f 100644
--- a/EventBus/build.gradle
+++ b/EventBus/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '2.4.1-SNAPSHOT'
+version = '3.0.0-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
diff --git a/EventBus/src/de/greenrobot/event/EventBus.java b/EventBus/src/de/greenrobot/event/EventBus.java
index 95863ade..85075b7c 100644
--- a/EventBus/src/de/greenrobot/event/EventBus.java
+++ b/EventBus/src/de/greenrobot/event/EventBus.java
@@ -40,7 +40,7 @@
 public class EventBus {
 
     /** Log tag, apps may override it. */
-    public static String TAG = "Event";
+    public static String TAG = "EventBus";
 
     static volatile EventBus defaultInstance;
 
@@ -109,7 +109,7 @@ public EventBus() {
         mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
         backgroundPoster = new BackgroundPoster(this);
         asyncPoster = new AsyncPoster(this);
-        subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses);
+        subscriberMethodFinder = new SubscriberMethodFinder(/* TODO */ false);
         logSubscriberExceptions = builder.logSubscriberExceptions;
         logNoSubscriberMessages = builder.logNoSubscriberMessages;
         sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
@@ -161,7 +161,12 @@ public void registerSticky(Object subscriber, int priority) {
     }
 
     private synchronized void register(Object subscriber, boolean sticky, int priority) {
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());
+        Class<?> subscriberClass = subscriber.getClass();
+        if(subscriberClass.isAnonymousClass()) {
+            // We cannot get @Subscribe annotations from anonymous classes, so fail fast
+            throw new EventBusException("Anonymous class cannot be registered: "+ subscriberClass);
+        }
+        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         for (SubscriberMethod subscriberMethod : subscriberMethods) {
             subscribe(subscriber, subscriberMethod, sticky, priority);
         }
diff --git a/EventBus/src/de/greenrobot/event/Subscribe.java b/EventBus/src/de/greenrobot/event/Subscribe.java
new file mode 100644
index 00000000..76ff1c88
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/Subscribe.java
@@ -0,0 +1,18 @@
+package de.greenrobot.event;
+
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import de.greenrobot.event.ThreadMode;
+
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+public @interface Subscribe {
+    ThreadMode threadMode() default ThreadMode.PostThread;
+}
+
diff --git a/EventBus/src/de/greenrobot/event/SubscriberIndex.java b/EventBus/src/de/greenrobot/event/SubscriberIndex.java
new file mode 100644
index 00000000..a442d1cc
--- /dev/null
+++ b/EventBus/src/de/greenrobot/event/SubscriberIndex.java
@@ -0,0 +1,35 @@
+package de.greenrobot.event;
+
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+/** Preprocessed index: base class for generated "MyGeneratedSubscriberIndex" class by annotation processing. */
+abstract class SubscriberIndex {
+    private Map<Class<?>, SubscriberMethod[]> map = new HashMap<Class<?>, SubscriberMethod[]>();
+
+    SubscriberMethod[] getSubscribersFor(Class<?> subscriberClass) {
+        SubscriberMethod[] entries = map.get(subscriberClass);
+        if (entries == null) {
+            entries = createSubscribersFor(subscriberClass);
+            if (entries != null) {
+                map.put(subscriberClass, entries);
+            }
+        }
+        return entries;
+    }
+
+    abstract SubscriberMethod[] createSubscribersFor(Class<?> subscriberClass);
+
+    SubscriberMethod createSubscriberMethod(Class<?> subscriberClass, String methodName, Class<?> eventType,
+                                            ThreadMode threadMode) {
+        try {
+            Method method = subscriberClass.getDeclaredMethod(methodName, eventType);
+            return new SubscriberMethod(method, threadMode, eventType);
+        } catch (NoSuchMethodException e) {
+            throw new EventBusException("Could not find subscriber method in " + subscriberClass +
+                    ". Maybe a missing ProGuard rule?", e);
+        }
+    }
+
+}
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethod.java b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
index 5e0df398..cf13c292 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethod.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java
@@ -32,7 +32,9 @@
 
     @Override
     public boolean equals(Object other) {
-        if (other instanceof SubscriberMethod) {
+        if (other == this) {
+            return true;
+        } else if (other instanceof SubscriberMethod) {
             checkMethodString();
             SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;
             otherSubscriberMethod.checkMethodString();
diff --git a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
index 823cb0ec..35b982e3 100644
--- a/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java
@@ -20,15 +20,13 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 class SubscriberMethodFinder {
-    private static final String ON_EVENT_METHOD_NAME = "onEvent";
-
     /*
      * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.
      * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:
@@ -38,29 +36,80 @@
     private static final int SYNTHETIC = 0x1000;
 
     private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
-    private static final Map<String, List<SubscriberMethod>> methodCache = new HashMap<String, List<SubscriberMethod>>();
+    private static final Map<String, List<SubscriberMethod>> METHOD_CACHE = new HashMap<String, List<SubscriberMethod>>();
 
-    private final Map<Class<?>, Class<?>> skipMethodVerificationForClasses;
+    /** Optional generated index without entries from subscribers super classes */
+    private static final SubscriberIndex INDEX;
 
-    SubscriberMethodFinder(List<Class<?>> skipMethodVerificationForClassesList) {
-        skipMethodVerificationForClasses = new ConcurrentHashMap<Class<?>, Class<?>>();
-        if (skipMethodVerificationForClassesList != null) {
-            for (Class<?> clazz : skipMethodVerificationForClassesList) {
-                skipMethodVerificationForClasses.put(clazz, clazz);
-            }
+    static {
+        SubscriberIndex newIndex = null;
+        try {
+            Class<?> clazz = Class.forName("de.greenrobot.event.MyGeneratedSubscriberIndex");
+            newIndex = (SubscriberIndex) clazz.newInstance();
+        } catch (ClassNotFoundException e) {
+            Log.d(EventBus.TAG, "No subscriber index available, reverting to dynamic look-up");
+            // Fine
+        } catch (Exception e) {
+            Log.w(EventBus.TAG, "Could not init subscriber index, reverting to dynamic look-up", e);
         }
+        INDEX = newIndex;
+    }
+
+    private final boolean strictMethodVerification;
+
+    SubscriberMethodFinder(boolean strictMethodVerification) {
+        this.strictMethodVerification = strictMethodVerification;
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
         String key = subscriberClass.getName();
         List<SubscriberMethod> subscriberMethods;
-        synchronized (methodCache) {
-            subscriberMethods = methodCache.get(key);
+        synchronized (METHOD_CACHE) {
+            subscriberMethods = METHOD_CACHE.get(key);
         }
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-        subscriberMethods = new ArrayList<SubscriberMethod>();
+        if (INDEX != null) {
+            subscriberMethods = findSubscriberMethodsWithIndex(subscriberClass);
+        } else {
+            subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);
+        }
+        if (subscriberMethods.isEmpty()) {
+            throw new EventBusException("Subscriber " + subscriberClass
+                    + " and its super classes have no public methods with the @Subscribe annotation");
+        } else {
+            synchronized (METHOD_CACHE) {
+                METHOD_CACHE.put(key, subscriberMethods);
+            }
+            return subscriberMethods;
+        }
+    }
+
+    private List<SubscriberMethod> findSubscriberMethodsWithIndex(Class<?> subscriberClass) {
+        Class<?> clazz = subscriberClass;
+        while (clazz != null) {
+            SubscriberMethod[] array = INDEX.getSubscribersFor(clazz);
+            if (array != null && array.length > 0) {
+                List<SubscriberMethod> subscriberMethods = new ArrayList<SubscriberMethod>();
+                for (SubscriberMethod subscriberMethod : array) {
+                    subscriberMethods.add(subscriberMethod);
+                }
+                return subscriberMethods;
+            } else {
+                String name = clazz.getName();
+                if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
+                    // Skip system classes, this just degrades performance
+                    break;
+                }
+                clazz = clazz.getSuperclass();
+            }
+        }
+        return Collections.EMPTY_LIST;
+    }
+
+    private List<SubscriberMethod> findSubscriberMethodsWithReflection(Class<?> subscriberClass) {
+        List<SubscriberMethod> subscriberMethods = new ArrayList<SubscriberMethod>();
         Class<?> clazz = subscriberClass;
         HashSet<String> eventTypesFound = new HashSet<String>();
         StringBuilder methodKeyBuilder = new StringBuilder();
@@ -74,61 +123,50 @@
             // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)
             Method[] methods = clazz.getDeclaredMethods();
             for (Method method : methods) {
-                String methodName = method.getName();
-                if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
-                    int modifiers = method.getModifiers();
-                    if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
-                        Class<?>[] parameterTypes = method.getParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
-                            ThreadMode threadMode;
-                            if (modifierString.length() == 0) {
-                                threadMode = ThreadMode.PostThread;
-                            } else if (modifierString.equals("MainThread")) {
-                                threadMode = ThreadMode.MainThread;
-                            } else if (modifierString.equals("BackgroundThread")) {
-                                threadMode = ThreadMode.BackgroundThread;
-                            } else if (modifierString.equals("Async")) {
-                                threadMode = ThreadMode.Async;
-                            } else {
-                                if (skipMethodVerificationForClasses.containsKey(clazz)) {
-                                    continue;
-                                } else {
-                                    throw new EventBusException("Illegal onEvent method, check for typos: " + method);
-                                }
-                            }
+                int modifiers = method.getModifiers();
+                if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                    Class<?>[] parameterTypes = method.getParameterTypes();
+                    if (parameterTypes.length == 1) {
+                        Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
+                        if (subscribeAnnotation != null) {
+                            String methodName = method.getName();
                             Class<?> eventType = parameterTypes[0];
                             methodKeyBuilder.setLength(0);
                             methodKeyBuilder.append(methodName);
                             methodKeyBuilder.append('>').append(eventType.getName());
+
                             String methodKey = methodKeyBuilder.toString();
                             if (eventTypesFound.add(methodKey)) {
                                 // Only add if not already found in a sub class
+                                ThreadMode threadMode = subscribeAnnotation.threadMode();
                                 subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
                             }
                         }
-                    } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
-                        Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
-                                + methodName);
+                    } else if (strictMethodVerification) {
+                        if (method.isAnnotationPresent(Subscribe.class)) {
+                            String methodName = name + "." + method.getName();
+                            throw new EventBusException("@Subscribe method " + methodName +
+                                    "must have exactly 1 parameter but has " + parameterTypes.length);
+                        }
                     }
+                } else if (strictMethodVerification) {
+                    if (method.isAnnotationPresent(Subscribe.class)) {
+                        String methodName = name + "." + method.getName();
+                        throw new EventBusException(methodName +
+                                " is a illegal @Subscribe method: must be public, non-static, and non-abstract");
+                    }
+
                 }
             }
+
             clazz = clazz.getSuperclass();
         }
-        if (subscriberMethods.isEmpty()) {
-            throw new EventBusException("Subscriber " + subscriberClass + " has no public methods called "
-                    + ON_EVENT_METHOD_NAME);
-        } else {
-            synchronized (methodCache) {
-                methodCache.put(key, subscriberMethods);
-            }
-            return subscriberMethods;
-        }
+        return subscriberMethods;
     }
 
     static void clearCaches() {
-        synchronized (methodCache) {
-            methodCache.clear();
+        synchronized (METHOD_CACHE) {
+            METHOD_CACHE.clear();
         }
     }
 
diff --git a/EventBusAnnotationProcessor/build.gradle b/EventBusAnnotationProcessor/build.gradle
new file mode 100644
index 00000000..ffe5eba5
--- /dev/null
+++ b/EventBusAnnotationProcessor/build.gradle
@@ -0,0 +1,123 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+group = 'de.greenrobot'
+version = '3.0.0-SNAPSHOT'
+
+sourceCompatibility = 1.6
+
+def isSnapshot = version.endsWith('-SNAPSHOT')
+def sonatypeRepositoryUrl
+if (isSnapshot) {
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+} else {
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+}
+
+repositories {
+    mavenCentral()
+}
+
+// Still unsupported, see http://issues.gradle.org/browse/GRADLE-784
+// Like this, it won't appear at all in the POM
+configurations {
+    provided
+    deployerJars
+}
+
+dependencies {
+    compile project(':EventBus')
+    deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
+}
+
+sourceSets {
+    main {
+        compileClasspath += configurations.provided
+        java {
+            srcDir 'src'
+        }
+        resources {
+            srcDir 'res'
+        }
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from sourceSets.main.allSource
+    classifier = 'sources'
+}
+
+artifacts {
+    archives jar
+    archives sourcesJar
+}
+
+signing {
+    if (project.hasProperty('signing.keyId') && project.hasProperty('signing.password') &&
+            project.hasProperty('signing.secretKeyRingFile')) {
+        sign configurations.archives
+    } else {
+        println "Signing information missing/incomplete for ${project.name}"
+    }
+}
+
+uploadArchives {
+    repositories {
+        mavenDeployer {
+            if (project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername')
+                    && project.hasProperty('preferedPassword')) {
+                configuration = configurations.deployerJars
+                repository(url: preferedRepo) {
+                    authentication(userName: preferedUsername, password: preferedPassword)
+                }
+            } else if (project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+                repository(url: sonatypeRepositoryUrl) {
+                    authentication(userName: sonatypeUsername, password: sonatypePassword)
+                }
+            } else {
+                println "Settings sonatypeUsername/sonatypePassword missing/incomplete for ${project.name}"
+            }
+
+            pom.artifactId = 'eventbus-annotation-processor'
+            pom.project {
+                name 'EventBus Annotation Processor'
+                packaging 'jar'
+                description 'Precompiler for EventBus Annotations.'
+                url 'https://github.com/greenrobot/EventBus'
+
+                scm {
+                    url 'https://github.com/greenrobot/EventBus'
+                    connection 'scm:git@github.com:greenrobot/EventBus.git'
+                    developerConnection 'scm:git@github.com:greenrobot/EventBus.git'
+                }
+
+                licenses {
+                    license {
+                        name 'The Apache Software License, Version 2.0'
+                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                        distribution 'repo'
+                    }
+                }
+
+                developers {
+                    developer {
+                        id 'greenrobot'
+                        name 'greenrobot'
+                    }
+                }
+
+                issueManagement {
+                    system 'GitHub Issues'
+                    url 'https://github.com/greenrobot/EventBus/issues'
+                }
+
+                organization {
+                    name 'greenrobot'
+                    url 'http://greenrobot.de'
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor b/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor
new file mode 100644
index 00000000..ec7e34b6
--- /dev/null
+++ b/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor
@@ -0,0 +1 @@
+de.greenrobot.event.annotationprocessor.EventBusAnnotationProcessor
diff --git a/EventBusAnnotationProcessor/settings.gradle b/EventBusAnnotationProcessor/settings.gradle
new file mode 100644
index 00000000..51ebbb79
--- /dev/null
+++ b/EventBusAnnotationProcessor/settings.gradle
@@ -0,0 +1 @@
+rootProject.name = 'eventbus-annotation-processor'
\ No newline at end of file
diff --git a/EventBusAnnotationProcessor/src/de/greenrobot/event/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/de/greenrobot/event/annotationprocessor/EventBusAnnotationProcessor.java
new file mode 100644
index 00000000..6fdec9f5
--- /dev/null
+++ b/EventBusAnnotationProcessor/src/de/greenrobot/event/annotationprocessor/EventBusAnnotationProcessor.java
@@ -0,0 +1,228 @@
+package de.greenrobot.event.annotationprocessor;
+
+import de.greenrobot.event.Subscribe;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+@SupportedAnnotationTypes("de.greenrobot.event.Subscribe")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public class EventBusAnnotationProcessor extends AbstractProcessor {
+    private final Map<Element, List<Element>> methodsByClass = new HashMap<Element, List<Element>>();
+    private boolean writerRoundDone;
+    private int round;
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+        Messager messager = processingEnv.getMessager();
+        round++;
+        messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +
+                !annotations.isEmpty() + ", processingOver: " + env.processingOver());
+        if (env.processingOver()) {
+            if (!annotations.isEmpty()) {
+                messager.printMessage(Diagnostic.Kind.ERROR,
+                        "Unexpected processing state: annotations still available after processing over");
+                return false;
+            }
+        }
+        if (annotations.isEmpty()) {
+            return false;
+        }
+
+        if (writerRoundDone) {
+            messager.printMessage(Diagnostic.Kind.ERROR,
+                    "Unexpected processing state: annotations still available after writing.");
+        }
+        collectSubscribers(annotations, env, messager);
+
+        if (!methodsByClass.isEmpty()) {
+            writeSources();
+        } else {
+            messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
+        }
+        writerRoundDone = true;
+
+        return true;
+    }
+
+    private boolean checkElement(Element element, Messager messager) {
+        if (element.getModifiers().contains(Modifier.STATIC)) {
+            messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must not be static", element);
+            return false;
+        }
+
+        if (!element.getModifiers().contains(Modifier.PUBLIC)) {
+            messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must be public", element);
+            return false;
+        }
+
+        Set<Modifier> subscriberClassModifiers = element.getEnclosingElement().getModifiers();
+        if (!subscriberClassModifiers.contains(Modifier.PUBLIC)) {
+            messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber class must be public",
+                    element.getEnclosingElement());
+            return false;
+        }
+
+        List<? extends VariableElement> parameters = ((ExecutableElement) element).getParameters();
+        if (parameters.size() != 1) {
+            messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must have exactly 1 parameter", element);
+            return false;
+        }
+
+        VariableElement param = parameters.get(0);
+        DeclaredType paramType = (DeclaredType) param.asType();
+        Set<Modifier> eventClassModifiers = paramType.asElement().getModifiers();
+        if (!eventClassModifiers.contains(Modifier.PUBLIC)) {
+            messager.printMessage(Diagnostic.Kind.ERROR, "Event type must be public: " + paramType, param);
+            return false;
+        }
+        return true;
+    }
+
+    private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
+        for (TypeElement annotation : annotations) {
+            Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
+            for (Element element : elements) {
+                if (checkElement(element, messager)) {
+                    Element classElement = element.getEnclosingElement();
+                    List<Element> methods = methodsByClass.get(classElement);
+                    if (methods == null) {
+                        methods = new ArrayList<Element>();
+                        methodsByClass.put(classElement, methods);
+                    }
+                    methods.add(element);
+                }
+            }
+        }
+    }
+
+    private void writeSources() {
+        String pack = "de.greenrobot.event";
+        String className = "MyGeneratedSubscriberIndex";
+        BufferedWriter writer = null;
+        try {
+            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(pack + '.' + className);
+            writer = new BufferedWriter(sourceFile.openWriter());
+            writer.write("package de.greenrobot.event;\n\n");
+            //            writer.write("import de.greenrobot.event.SubscriberIndexEntry;\n");
+            //            writer.write("import de.greenrobot.event.ThreadMode;\n\n");
+            writer.write("/** This class is generated by EventBus, do not edit. */\n");
+            writer.write("class " + className + " extends SubscriberIndex {\n");
+            writer.write("    SubscriberMethod[] createSubscribersFor(Class<?> subscriberClass) {\n");
+
+            boolean first = true;
+            for (Map.Entry<Element, List<Element>> entry : methodsByClass.entrySet()) {
+                String ifPrefix;
+                if (first) {
+                    ifPrefix = "";
+                    first = false;
+                } else {
+                    ifPrefix = "} else ";
+                }
+                TypeElement subscriberClass = (TypeElement) entry.getKey();
+                writeLine(writer, 2, ifPrefix + "if(subscriberClass ==", subscriberClass.asType() + ".class) {");
+                writer.write("            return new SubscriberMethod[] {\n");
+
+                Set<String> methodSignatures = new HashSet<String>();
+                writeIndexEntries(writer, null, entry.getValue(), methodSignatures);
+                while (subscriberClass.getSuperclass().getKind() == TypeKind.DECLARED) {
+                    subscriberClass = (TypeElement) processingEnv.getTypeUtils().asElement(subscriberClass.getSuperclass());
+                    List<Element> superClassMethods = methodsByClass.get(subscriberClass);
+                    if (superClassMethods != null) {
+                        writeIndexEntries(writer, subscriberClass, superClassMethods, methodSignatures);
+                    }
+                }
+                writer.write("            };\n");
+            }
+            if (!methodsByClass.isEmpty()) {
+                writer.write("        }\n");
+            }
+            writer.write("        return null;\n");
+            writer.write("    };\n}\n");
+        } catch (IOException e) {
+            throw new RuntimeException("Could not write source for " + className, e);
+        } finally {
+            try {
+                writer.close();
+            } catch (IOException e) {
+                //Silent
+            }
+        }
+    }
+
+    private void writeIndexEntries(BufferedWriter writer, TypeElement subscriberClass, List<Element> elements, Set<String> methodSignatures) throws IOException {
+        for (Element element : elements) {
+
+            List<? extends VariableElement> parameters = ((ExecutableElement) element).getParameters();
+            VariableElement param = parameters.get(0);
+            DeclaredType paramType = (DeclaredType) param.asType();
+
+            String methodSignature = element+">"+paramType;
+            if(!methodSignatures.add(methodSignature)) {
+                continue;
+            }
+
+            String methodName = element.getSimpleName().toString();
+            String subscriberClassString = subscriberClass == null ? "subscriberClass" :
+                    subscriberClass.asType().toString() + ".class";
+
+            Subscribe subscribe = element.getAnnotation(Subscribe.class);
+            writeLine(writer, 4, "createSubscriberMethod(" + subscriberClassString + ",",
+                    "\"" + methodName + "\",",
+                    paramType.toString() + ".class,",
+                    "ThreadMode." + subscribe.threadMode().name() + "),");
+
+            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Indexed @Subscribe at " +
+                    element.getEnclosingElement().getSimpleName() + "." + methodName +
+                    "(" + paramType.asElement().getSimpleName() + ")");
+        }
+    }
+
+    private void writeLine(BufferedWriter writer, int indentLevel, String... parts) throws IOException {
+        writeIndent(writer, indentLevel);
+        int len = indentLevel * 4;
+        for (int i = 0; i < parts.length; i++) {
+            String part = parts[i];
+            if (len + part.length() > 118) {
+                writer.write("\n");
+                if (indentLevel < 12) {
+                    indentLevel += 2;
+                }
+                writeIndent(writer, indentLevel);
+                len = indentLevel * 4;
+            } else if (i != 0) {
+                writer.write(" ");
+            }
+            writer.write(part);
+            len += part.length();
+        }
+        writer.write("\n");
+    }
+
+    private void writeIndent(BufferedWriter writer, int indentLevel) throws IOException {
+        for (int i = 0; i < indentLevel; i++) {
+            writer.write("    ");
+        }
+    }
+}
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
index 570c64b0..46adb91b 100644
--- a/EventBusPerformance/build.gradle
+++ b/EventBusPerformance/build.gradle
@@ -16,7 +16,8 @@ repositories {
 
 dependencies {
     compile project(':EventBus')
-    compile 'com.squareup:otto:1.3.5'
+    provided project(':EventBusAnnotationProcessor')
+    compile 'com.squareup:otto:1.3.6'
 }
 
 android {
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/TestRunnerActivity.java b/EventBusPerformance/src/de/greenrobot/eventperf/TestRunnerActivity.java
index 127d528b..07f55777 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/TestRunnerActivity.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/TestRunnerActivity.java
@@ -1,5 +1,8 @@
 package de.greenrobot.eventperf;
 
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
+
 import android.app.Activity;
 import android.os.Bundle;
 import android.os.Process;
@@ -43,6 +46,7 @@ protected void onResume() {
         }
     }
 
+    @Subscribe(threadMode = ThreadMode.MainThread)
     public void onEventMainThread(TestFinishedEvent event) {
         Test test = event.test;
         String text = "<b>" + test.getDisplayName() + "</b><br/>" + //
diff --git a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
index 16920dc3..66bf9131 100644
--- a/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
+++ b/EventBusPerformance/src/de/greenrobot/eventperf/testsubject/PerfTestEventBus.java
@@ -6,6 +6,8 @@
 
 import android.content.Context;
 import de.greenrobot.event.EventBus;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 import de.greenrobot.eventperf.Test;
 import de.greenrobot.eventperf.TestEvent;
 import de.greenrobot.eventperf.TestParams;
@@ -174,6 +176,7 @@ public String getDisplayName() {
     }
 
     public class SubscribeClassEventBusDefault {
+        @Subscribe
         public void onEvent(TestEvent event) {
             eventsReceivedCount.incrementAndGet();
         }
@@ -195,6 +198,7 @@ public void dummy5() {
     }
 
     public class SubscribeClassEventBusMain {
+        @Subscribe(threadMode = ThreadMode.MainThread)
         public void onEventMainThread(TestEvent event) {
             eventsReceivedCount.incrementAndGet();
         }
@@ -216,6 +220,7 @@ public void dummy5() {
     }
 
     public class SubscribeClassEventBusBackground {
+        @Subscribe(threadMode = ThreadMode.BackgroundThread)
         public void onEventBackgroundThread(TestEvent event) {
             eventsReceivedCount.incrementAndGet();
         }
@@ -237,6 +242,7 @@ public void dummy5() {
     }
 
     public class SubscriberClassEventBusAsync {
+        @Subscribe(threadMode = ThreadMode.Async)
         public void onEventAsync(TestEvent event) {
             eventsReceivedCount.incrementAndGet();
         }
diff --git a/EventBusTest/build.gradle b/EventBusTest/build.gradle
index 2f48f9c5..5983a7ab 100644
--- a/EventBusTest/build.gradle
+++ b/EventBusTest/build.gradle
@@ -5,16 +5,19 @@ buildscript {
 
     dependencies {
         classpath 'com.android.tools.build:gradle:1.1.0'
+        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
     }
 }
 
 apply plugin: 'com.android.application'
+apply plugin: 'com.neenbedankt.android-apt'
 
 repositories {
     mavenCentral()
 }
 
 dependencies {
+    androidTestApt project(':EventBusAnnotationProcessor')
     androidTestCompile project(':EventBus')
 }
 
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
index 888b37d5..99de5a32 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBackgroundThreadTest.java
@@ -16,6 +16,8 @@
 package de.greenrobot.event.test;
 
 import android.os.Looper;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -40,6 +42,7 @@ public void testPostFromMain() throws InterruptedException {
         assertFalse(lastThread.equals(Looper.getMainLooper().getThread()));
     }
 
+    @Subscribe(threadMode = ThreadMode.BackgroundThread)
     public void onEventBackgroundThread(String event) {
         trackEvent(event);
     }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
index c34feb38..ad8c20f2 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java
@@ -18,6 +18,7 @@
 import android.app.Activity;
 import android.util.Log;
 import de.greenrobot.event.EventBus;
+import de.greenrobot.event.Subscribe;
 import junit.framework.TestCase;
 
 import java.lang.ref.WeakReference;
@@ -34,6 +35,7 @@
     private int lastIntEvent;
     private int countMyEventExtended;
     private int countMyEvent;
+    private int countMyEvent2;
 
     protected void setUp() throws Exception {
         super.setUp();
@@ -129,6 +131,14 @@ public void testPostMultipleTimes() {
         assertEquals(count, countMyEvent);
     }
 
+    public void testMultipleSubscribeMethodsForEvent() {
+        eventBus.register(this);
+        MyEvent event = new MyEvent();
+        eventBus.post(event);
+        assertEquals(1, countMyEvent);
+        assertEquals(1, countMyEvent2);
+    }
+
     public void testPostAfterUnregister() {
         eventBus.register(this);
         eventBus.unregister(this);
@@ -186,10 +196,7 @@ public void testHasSubscriberForEvent() {
     public void testHasSubscriberForEventSuperclass() {
         assertFalse(eventBus.hasSubscriberForEvent(String.class));
 
-        Object subscriber = new Object() {
-            public void onEvent(Object event) {
-            }
-        };
+        Object subscriber = new ObjectSubscriber();
         eventBus.register(subscriber);
         assertTrue(eventBus.hasSubscriberForEvent(String.class));
 
@@ -200,10 +207,7 @@ public void onEvent(Object event) {
     public void testHasSubscriberForEventImplementedInterface() {
         assertFalse(eventBus.hasSubscriberForEvent(String.class));
 
-        Object subscriber = new Object() {
-            public void onEvent(CharSequence event) {
-            }
-        };
+        Object subscriber = new CharSequenceSubscriber();
         eventBus.register(subscriber);
         assertTrue(eventBus.hasSubscriberForEvent(CharSequence.class));
         assertTrue(eventBus.hasSubscriberForEvent(String.class));
@@ -213,42 +217,65 @@ public void onEvent(CharSequence event) {
         assertFalse(eventBus.hasSubscriberForEvent(String.class));
     }
 
+    @Subscribe
     public void onEvent(String event) {
         lastStringEvent = event;
         countStringEvent++;
     }
 
+    @Subscribe
     public void onEvent(Integer event) {
         lastIntEvent = event;
         countIntEvent++;
     }
 
+    @Subscribe
     public void onEvent(MyEvent event) {
         countMyEvent++;
     }
 
+    @Subscribe
+    public void onEvent2(MyEvent event) {
+        countMyEvent2++;
+    }
+
+    @Subscribe
     public void onEvent(MyEventExtended event) {
         countMyEventExtended++;
     }
 
-    static class TestActivity extends Activity {
+    public static class TestActivity extends Activity {
         public String lastStringEvent;
 
+        @Subscribe
         public void onEvent(String event) {
             lastStringEvent = event;
         }
     }
 
-    class MyEvent {
+    public static class CharSequenceSubscriber {
+        @Subscribe
+        public void onEvent(CharSequence event) {
+        }
+    }
+
+    public static class ObjectSubscriber {
+        @Subscribe
+        public void onEvent(Object event) {
+        }
+    }
+
+    public class MyEvent {
     }
 
-    class MyEventExtended extends MyEvent {
+    public class MyEventExtended extends MyEvent {
     }
 
-    class RepostInteger {
+    public class RepostInteger {
         public int lastEvent;
         public int countEvent;
 
+        @Subscribe
         public void onEvent(Integer event) {
             lastEvent = event;
             countEvent++;
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java
index 58b6bc8d..2bab15e0 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBuilderTest.java
@@ -20,6 +20,7 @@
 import de.greenrobot.event.EventBusException;
 import de.greenrobot.event.NoSubscriberEvent;
 import de.greenrobot.event.SubscriberExceptionEvent;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -74,19 +75,22 @@ public void testEventInheritance() {
         eventBus.post("Foo");
     }
 
-    class SubscriberExceptionEventTracker {
+    public class SubscriberExceptionEventTracker {
+        @Subscribe
         public void onEvent(SubscriberExceptionEvent event) {
             trackEvent(event);
         }
     }
 
-    class NoSubscriberEventTracker {
+    public class NoSubscriberEventTracker {
+        @Subscribe
         public void onEvent(NoSubscriberEvent event) {
             trackEvent(event);
         }
     }
 
-    class ThrowingSubscriber {
+    public class ThrowingSubscriber {
+        @Subscribe
         public void onEvent(Object event) {
             throw new RuntimeException();
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java
index 027d74f9..0950f71c 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusCancelEventDeliveryTest.java
@@ -19,6 +19,8 @@
 
 import android.test.UiThreadTest;
 import de.greenrobot.event.EventBusException;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -75,13 +77,14 @@ public void testCancelInMainThread() {
         assertNotNull(failed);
     }
 
-    class Subscriber {
+    public class Subscriber {
         private final boolean cancel;
 
         public Subscriber(boolean cancel) {
             this.cancel = cancel;
         }
 
+        @Subscribe
         public void onEvent(String event) {
             trackEvent(event);
             if (cancel) {
@@ -90,7 +93,8 @@ public void onEvent(String event) {
         }
     }
 
-    class SubscriberCancelOtherEvent {
+    public class SubscriberCancelOtherEvent {
+        @Subscribe
         public void onEvent(String event) {
             try {
                 eventBus.cancelEventDelivery(this);
@@ -100,9 +104,10 @@ public void onEvent(String event) {
         }
     }
 
-    class SubscriberMainThread {
+    public class SubscriberMainThread {
         final CountDownLatch done = new CountDownLatch(1);
 
+        @Subscribe(threadMode = ThreadMode.MainThread)
         public void onEventMainThread(String event) {
             try {
                 eventBus.cancelEventDelivery(event);
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java
index 43aaf467..20a5195c 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceDisabledTest.java
@@ -16,6 +16,7 @@
 package de.greenrobot.event.test;
 
 import de.greenrobot.event.EventBus;
+import de.greenrobot.event.Subscribe;
 import junit.framework.TestCase;
 
 /**
@@ -118,41 +119,47 @@ public void testSubscriberClassHierarchyWithoutNewSubscriberMethod() {
         assertEquals(1, subscriber.countMyEventExtended);
     }
 
+    @Subscribe
     public void onEvent(Object event) {
         countObjectEvent++;
     }
 
+    @Subscribe
     public void onEvent(MyEvent event) {
         countMyEvent++;
     }
 
+    @Subscribe
     public void onEvent(MyEventExtended event) {
         countMyEventExtended++;
     }
 
+    @Subscribe
     public void onEvent(MyEventInterface event) {
         countMyEventInterface++;
     }
 
+    @Subscribe
     public void onEvent(MyEventInterfaceExtended event) {
         countMyEventInterfaceExtended++;
     }
 
-    static interface MyEventInterface {
+    public static interface MyEventInterface {
     }
 
-    static class MyEvent implements MyEventInterface {
+    public static class MyEvent implements MyEventInterface {
     }
 
-    static interface MyEventInterfaceExtended extends MyEventInterface {
+    public static interface MyEventInterfaceExtended extends MyEventInterface {
     }
 
-    static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
+    public static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
     }
 
-    static class SubscriberExtended extends EventBusInheritanceDisabledTest {
+    public static class SubscriberExtended extends EventBusInheritanceDisabledTest {
         private int countMyEventOverwritten;
 
+        @Subscribe
         public void onEvent(MyEvent event) {
             countMyEventOverwritten++;
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
index 10384951..1de6943a 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusInheritanceTest.java
@@ -15,6 +15,7 @@
  */
 package de.greenrobot.event.test;
 
+import de.greenrobot.event.Subscribe;
 import junit.framework.TestCase;
 import de.greenrobot.event.EventBus;
 
@@ -118,41 +119,47 @@ public void testSubscriberClassHierarchyWithoutNewSubscriberMethod() {
         assertEquals(1, subscriber.countMyEventExtended);
     }
 
+    @Subscribe
     public void onEvent(Object event) {
         countObjectEvent++;
     }
 
+    @Subscribe
     public void onEvent(MyEvent event) {
         countMyEvent++;
     }
 
+    @Subscribe
     public void onEvent(MyEventExtended event) {
         countMyEventExtended++;
     }
 
+    @Subscribe
     public void onEvent(MyEventInterface event) {
         countMyEventInterface++;
     }
 
+    @Subscribe
     public void onEvent(MyEventInterfaceExtended event) {
         countMyEventInterfaceExtended++;
     }
 
-    static interface MyEventInterface {
+    public static interface MyEventInterface {
     }
 
-    static class MyEvent implements MyEventInterface {
+    public static class MyEvent implements MyEventInterface {
     }
 
-    static interface MyEventInterfaceExtended extends MyEventInterface {
+    public static interface MyEventInterfaceExtended extends MyEventInterface {
     }
 
-    static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
+    public static class MyEventExtended extends MyEvent implements MyEventInterfaceExtended {
     }
 
-    static class SubscriberExtended extends EventBusInheritanceTest {
+    public static class SubscriberExtended extends EventBusInheritanceTest {
         private int countMyEventOverwritten;
 
+        @Subscribe
         public void onEvent(MyEvent event) {
             countMyEventOverwritten++;
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java
index 0b3ac3a8..9fa4a487 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java
@@ -20,6 +20,8 @@
 
 import android.os.Handler;
 import android.os.Looper;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -84,6 +86,7 @@ public void run() {
         awaitLatch(doneLatch, 10);
     }
 
+    @Subscribe(threadMode = ThreadMode.MainThread)
     public void onEventMainThread(String event) {
         trackEvent(event);
         if (unregistered) {
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
index 41b6302b..3d6b7541 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadTest.java
@@ -19,6 +19,8 @@
 import java.util.List;
 
 import android.os.Looper;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -57,6 +59,7 @@ public void testPostInBackgroundThread() throws InterruptedException {
         assertEquals(Looper.getMainLooper().getThread(), lastThread);
     }
 
+    @Subscribe(threadMode = ThreadMode.MainThread)
     public void onEventMainThread(String event) {
         trackEvent(event);
     }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
index 6d664b9c..aad8d781 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMethodModifiersTest.java
@@ -18,6 +18,8 @@
 import android.os.Looper;
 import de.greenrobot.event.EventBus;
 import de.greenrobot.event.EventBusException;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -31,47 +33,28 @@ public void testRegisterForEventTypeAndPost() throws InterruptedException {
         waitForEventCount(4, 1000);
     }
 
-    public void testIllegalMethodNameThrow() {
-        try {
-            eventBus.register(new IllegalEventMethodName());
-            fail("Illegal name registered");
-        } catch (EventBusException ex) {
-            // OK, expected
-        }
-    }
-
-    public void testIllegalMethodNameSkip() {
-        eventBus=EventBus.builder().skipMethodVerificationFor(IllegalEventMethodName.class).build();
-        eventBus.register(new IllegalEventMethodName());
-        eventBus.post(new Object());
-    }
-
+    @Subscribe
     public void onEvent(String event) {
         trackEvent(event);
         assertNotSame(Looper.getMainLooper(), Looper.myLooper());
     }
 
+    @Subscribe(threadMode = ThreadMode.MainThread)
     public void onEventMainThread(String event) {
         trackEvent(event);
         assertSame(Looper.getMainLooper(), Looper.myLooper());
     }
 
+    @Subscribe(threadMode = ThreadMode.BackgroundThread)
     public void onEventBackgroundThread(String event) {
         trackEvent(event);
         assertNotSame(Looper.getMainLooper(), Looper.myLooper());
     }
 
+    @Subscribe(threadMode = ThreadMode.Async)
     public void onEventAsync(String event) {
         trackEvent(event);
         assertNotSame(Looper.getMainLooper(), Looper.myLooper());
     }
 
-    public static class IllegalEventMethodName {
-        public void onEventIllegalName(Object event) {
-            fail("onEventIllegalName got called");
-        }
-
-        public void onEvent(IntTestEvent event) {
-        }
-    }
 }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
index be68fd12..87d89d13 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMultithreadedTest.java
@@ -23,6 +23,8 @@
 import android.os.Looper;
 import android.util.Log;
 import de.greenrobot.event.EventBus;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -164,24 +166,28 @@ private long triggerAndWaitForThreads(List<PosterThread> threads, CountDownLatch
         return threads;
     }
 
+    @Subscribe(threadMode = ThreadMode.BackgroundThread)
     public void onEventBackgroundThread(String event) {
         lastStringEvent = event;
         countStringEvent.incrementAndGet();
         trackEvent(event);
     }
 
+    @Subscribe(threadMode = ThreadMode.MainThread)
     public void onEventMainThread(Integer event) {
         lastIntegerEvent = event;
         countIntegerEvent.incrementAndGet();
         trackEvent(event);
     }
 
+    @Subscribe(threadMode = ThreadMode.Async)
     public void onEventAsync(IntTestEvent event) {
         countIntTestEvent.incrementAndGet();
         lastIntTestEvent = event;
         trackEvent(event);
     }
 
+    @Subscribe
     public void onEvent(Object event) {
         countObjectEvent.incrementAndGet();
         trackEvent(event);
@@ -214,7 +220,7 @@ public void run() {
         }
     }
 
-    class SubscribeUnsubscribeThread extends Thread {
+    public class SubscribeUnsubscribeThread extends Thread {
         boolean running = true;
 
         public void shutdown() {
@@ -239,18 +245,22 @@ public void run() {
             }
         }
 
+        @Subscribe(threadMode = ThreadMode.MainThread)
         public void onEventMainThread(String event) {
             assertSame(Looper.getMainLooper(), Looper.myLooper());
         }
 
+        @Subscribe(threadMode = ThreadMode.BackgroundThread)
         public void onEventBackgroundThread(Integer event) {
             assertNotSame(Looper.getMainLooper(), Looper.myLooper());
         }
 
+        @Subscribe
         public void onEvent(Object event) {
             assertNotSame(Looper.getMainLooper(), Looper.myLooper());
         }
 
+        @Subscribe(threadMode = ThreadMode.Async)
         public void onEventAsync(Object event) {
             assertNotSame(Looper.getMainLooper(), Looper.myLooper());
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
index ffe48f10..f6d7516b 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusNoSubscriberEventTest.java
@@ -18,6 +18,7 @@
 import de.greenrobot.event.EventBus;
 import de.greenrobot.event.NoSubscriberEvent;
 import de.greenrobot.event.SubscriberExceptionEvent;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -35,11 +36,7 @@ public void testNoSubscriberEvent() {
     }
 
     public void testNoSubscriberEventAfterUnregister() {
-        Object subscriber = new Object() {
-            @SuppressWarnings("unused")
-            public void onEvent(String dummy) {
-            }
-        };
+        Object subscriber = new DummySubscriber();
         eventBus.register(subscriber);
         eventBus.unregister(subscriber);
         testNoSubscriberEvent();
@@ -57,15 +54,25 @@ public void testBadNoSubscriberSubscriber() {
         assertEquals("Foo", noSub.originalEvent);
     }
 
+    @Subscribe
     public void onEvent(NoSubscriberEvent event) {
         trackEvent(event);
     }
 
+    @Subscribe
     public void onEvent(SubscriberExceptionEvent event) {
         trackEvent(event);
     }
 
-    class BadNoSubscriberSubscriber {
+    public static class DummySubscriber {
+        @SuppressWarnings("unused")
+        @Subscribe
+        public void onEvent(String dummy) {
+        }
+    }
+
+    public class BadNoSubscriberSubscriber {
+        @Subscribe
         public void onEvent(NoSubscriberEvent event) {
             throw new RuntimeException("I'm bad");
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java
index 0cb794ac..1864da54 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusOrderedSubscriptionsTest.java
@@ -20,6 +20,8 @@
 
 import de.greenrobot.event.EventBus;
 import android.util.Log;
+import de.greenrobot.event.ThreadMode;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -87,7 +89,7 @@ protected PrioSubscriber register(int priority, boolean sticky) {
         return subscriber;
     }
 
-    private final class PrioSubscriber {
+    public final class PrioSubscriber {
 
         final int prio;
 
@@ -96,14 +98,17 @@ public PrioSubscriber(int prio) {
             // TODO Auto-generated constructor stub
         }
 
+        @Subscribe
         public void onEvent(String event) {
             handleEvent(event);
         }
 
+        @Subscribe(threadMode = ThreadMode.MainThread)
         public void onEventMainThread(IntTestEvent event) {
             handleEvent(event);
         }
 
+        @Subscribe(threadMode = ThreadMode.BackgroundThread)
         public void onEventBackgroundThread(Integer event) {
             handleEvent(event);
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java
index 41808dc7..7c4dbf9d 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusRegistrationRacingTest.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.event.test;
 
+import de.greenrobot.event.Subscribe;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
@@ -70,7 +72,7 @@ public void testRacingRegistrations() throws InterruptedException {
         return threads;
     }
 
-    class SubscriberThread implements Runnable {
+    public class SubscriberThread implements Runnable {
         volatile int eventCount;
 
         @Override
@@ -87,6 +89,7 @@ public void run() {
             unregisteredLatch.countDown();
         }
 
+        @Subscribe
         public void onEvent(String event) {
             eventCount++;
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
index 04be4d91..9223bb32 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusStickyEventTest.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.event.test;
 
+import de.greenrobot.event.Subscribe;
+
 /**
  * @author Markus Junginger, greenrobot
  */
@@ -117,12 +119,7 @@ public void testPostStickyRemoveAll() throws InterruptedException {
     }
 
     public void testRemoveStickyEventInSubscriber() throws InterruptedException {
-        eventBus.registerSticky(new Object() {
-            @SuppressWarnings("unused")
-            public void onEvent(String event) {
-                eventBus.removeStickyEvent(event);
-            }
-        });
+        eventBus.registerSticky(new RemoveStickySubscriber());
         eventBus.postSticky("Sticky");
         eventBus.registerSticky(this);
         assertNull(lastEvent);
@@ -130,12 +127,21 @@ public void onEvent(String event) {
         assertNull(eventBus.getStickyEvent(String.class));
     }
 
+    @Subscribe
     public void onEvent(String event) {
         trackEvent(event);
     }
 
+    @Subscribe
     public void onEvent(IntTestEvent event) {
         trackEvent(event);
     }
 
+    public class RemoveStickySubscriber {
+        @SuppressWarnings("unused")
+        @Subscribe
+        public void onEvent(String event) {
+            eventBus.removeStickyEvent(event);
+        }
+    }
 }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
index f9acaa7e..21c79f95 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberExceptionTest.java
@@ -17,6 +17,7 @@
 
 import de.greenrobot.event.EventBus;
 import de.greenrobot.event.SubscriberExceptionEvent;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -43,15 +44,18 @@ public void testBadExceptionSubscriber() {
         assertEventCount(1);
     }
 
+    @Subscribe
     public void onEvent(String event) {
         throw new RuntimeException("Bar");
     }
 
+    @Subscribe
     public void onEvent(SubscriberExceptionEvent event) {
         trackEvent(event);
     }
 
-    class BadExceptionSubscriber {
+    public class BadExceptionSubscriber {
+        @Subscribe
         public void onEvent(SubscriberExceptionEvent event) {
             throw new RuntimeException("Bad");
         }
diff --git a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java
index ee435219..1c84dda6 100644
--- a/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java
+++ b/EventBusTest/src/de/greenrobot/event/test/EventBusSubscriberLegalTest.java
@@ -16,6 +16,7 @@
 package de.greenrobot.event.test;
 
 import de.greenrobot.event.EventBusException;
+import de.greenrobot.event.Subscribe;
 
 /**
  * @author Markus Junginger, greenrobot
@@ -29,54 +30,62 @@ public void testSubscriberLegal() {
         assertEquals(1, eventCount.intValue());
     }
 
-    public void testSubscriberNotPublic() {
-        try {
-            eventBus.register(new NotPublic());
-            fail("Registration of ilegal subscriber successful");
-        } catch (EventBusException e) {
-            // Expected
-        }
-    }
+    // With build time verification, some of these tests are obsolete (and cause problems during build)
+//    public void testSubscriberNotPublic() {
+//        try {
+//            eventBus.register(new NotPublic());
+//            fail("Registration of ilegal subscriber successful");
+//        } catch (EventBusException e) {
+//            // Expected
+//        }
+//    }
 
-    public void testSubscriberStatic() {
-        try {
-            eventBus.register(new Static());
-            fail("Registration of ilegal subscriber successful");
-        } catch (EventBusException e) {
-            // Expected
-        }
-    }
+//    public void testSubscriberStatic() {
+//        try {
+//            eventBus.register(new Static());
+//            fail("Registration of ilegal subscriber successful");
+//        } catch (EventBusException e) {
+//            // Expected
+//        }
+//    }
 
     public void testSubscriberLegalAbstract() {
-        eventBus.register(new Abstract() {
-
-            @Override
-            public void onEvent(String event) {
-                trackEvent(event);
-            }
-
-        });
+        eventBus.register(new AbstractImpl());
 
         eventBus.post("42");
         assertEquals(1, eventCount.intValue());
     }
 
+    @Subscribe
     public void onEvent(String event) {
         trackEvent(event);
     }
 
-    static class NotPublic {
-        void onEvent(String event) {
-        }
-    }
+//    public static class NotPublic {
+//        @Subscribe
+//        void onEvent(String event) {
+//        }
+//    }
 
-    static abstract class Abstract {
+    public static abstract class Abstract {
+        @Subscribe
         public abstract void onEvent(String event);
     }
 
-    static class Static {
-        public static void onEvent(String event) {
+    public class AbstractImpl extends Abstract {
+
+        @Override
+        @Subscribe
+        public void onEvent(String event) {
+            trackEvent(event);
         }
+
     }
 
+//    public static class Static {
+//        @Subscribe
+//        public static void onEvent(String event) {
+//        }
+//    }
+
 }
diff --git a/README.md b/README.md
index e7c6975b..808d044a 100644
--- a/README.md
+++ b/README.md
@@ -17,23 +17,36 @@ EventBus...
 
  [![Build Status](https://travis-ci.org/greenrobot/EventBus.svg?branch=master)](https://travis-ci.org/greenrobot/EventBus)
 
-EventBus in 3 steps
+Limitations of the SNAPSHOT version
+-----------------------------------
+The "subscriber index" is an optional optimization to speed up initial subscriber registration. The subscriber index is created during build time using an annotation processor. There are a couple of limitations of the current implementation:
+
+ * Subscriber classes must be public
+ * Event classes must be public
+ * @Subscribe seems to be not recognized when inside of anonymous classes
+
+EventBus in 4 steps
 -------------------
 1. Define events:<br/>
 <code>public class MessageEvent { /* Additional fields if needed */ }</code><br/><br/>
-2. Prepare subscribers:<br/>
-<code>eventBus.register(this);</code><br/>
+2. Register your subscriber (in your onCreate or in a constructor):<br/>
+<code>eventBus.register(this);</code><br/><br/>
+3. Declare your subscribing method<br/>
+<code>@Subscribe</code><br/>
 <code>public void onEvent(AnyEventType event) {/* Do something */};</code><br/><br/>
-3. Post events:<br/>
+4. Post events:<br/>
 <code>eventBus.post(event);</code>
 
 Add EventBus to your project
 ----------------------------
 EventBus is available on Maven Central. Please ensure that you are using the latest version by [checking here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22)
 
+Note: This SNAPSHOT version is only available on Sonatype's snapshot repository (https://oss.sonatype.org/content/repositories/snapshots).
+
 Gradle:
 ```
-    compile 'de.greenrobot:eventbus:2.4.0'
+    compile 'de.greenrobot:eventbus:3.0.0-SNAPSHOT'
+    provided 'de.greenrobot:eventbus-annotation-processor:3.0.0-SNAPSHOT'
 ```
 
 Maven:
@@ -41,7 +54,7 @@ Maven:
 <dependency>
     <groupId>de.greenrobot</groupId>
     <artifactId>eventbus</artifactId>
-    <version>2.4.0</version>
+    <version>3.0.0-SNAPSHOT</version>
 </dependency>
 ```
 
@@ -56,8 +69,7 @@ How does EventBus compare to other solutions, like Otto from Square? Check this
 Additional Features and Notes
 -----------------------------
 
-* **NOT based on annotations:** Querying annotations are slow on Android, especially before Android 4.0. Have a look at this [Android bug report](http://code.google.com/p/android/issues/detail?id=7811).
-* **Based on conventions:** Event handling methods are called "onEvent".
+* **Based on annotations:** Event handling methods can be named however you want, and only need to be annotated with **@Subscribe**.
 * **Performance optimized:** It's probably the fastest event bus for Android.
 * **Convenience singleton:** You can get a process wide event bus instance by calling EventBus.getDefault(). You can still call new EventBus() to create any number of local busses.
 * **Subscriber and event inheritance:** Event handler methods may be defined in super classes, and events are posted to handlers of the event's super classes including any implemented interfaces. For example, subscriber may register to events of the type Object to receive all events posted on the event bus.
diff --git a/settings.gradle b/settings.gradle
index 76c570b0..d51c4e7b 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,3 +1,4 @@
 include 'EventBus'
+include 'EventBusAnnotationProcessor'
 include 'EventBusTest'
 include 'EventBusPerformance'
