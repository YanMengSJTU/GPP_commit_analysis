diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..f83a5529 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -139,7 +139,9 @@ public EventBus() {
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        // 找到Class注解的对应的方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+        // 开启同步锁，把class中的方法保存到对应的集合中
         synchronized (this) {
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
@@ -152,10 +154,12 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
         CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+        // 如果eventType之前没有注册过, 创建新的CopyOnWriteArrayList，并添加到列表中
         if (subscriptions == null) {
             subscriptions = new CopyOnWriteArrayList<>();
             subscriptionsByEventType.put(eventType, subscriptions);
         } else {
+            // 如果已经添加过了，抛出异常
             if (subscriptions.contains(newSubscription)) {
                 throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                         + eventType);
@@ -164,20 +168,24 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
 
         int size = subscriptions.size();
         for (int i = 0; i <= size; i++) {
+            // 这里是遍历排序，根据priority排序，所以高优先级会先得到回调
             if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                 subscriptions.add(i, newSubscription);
                 break;
             }
         }
 
+        // 把class保存到typesBySubscriber
         List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
         if (subscribedEvents == null) {
             subscribedEvents = new ArrayList<>();
             typesBySubscriber.put(subscriber, subscribedEvents);
         }
+        // 保存eventType
         subscribedEvents.add(eventType);
-
+        // 判断是否是粘性广播
         if (subscriberMethod.sticky) {
+            // 如果event可以被继承
             if (eventInheritance) {
                 // Existing sticky events of all subclasses of eventType have to be considered.
                 // Note: Iterating over all events may be inefficient with lots of sticky events,
@@ -192,6 +200,7 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                     }
                 }
             } else {
+                // 从缓存中找到上一次的结果，回调给newSubscription
                 Object stickyEvent = stickyEvents.get(eventType);
                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);
             }
@@ -252,21 +261,28 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+        // 得到当前线程的PostingThreadState
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
+        // 添加要分发的event
         eventQueue.add(event);
-
+        // 如果当前线程没有在分发
         if (!postingState.isPosting) {
+            // 是否是主线程
             postingState.isMainThread = isMainThread();
+            // 设置状态为开发分发
             postingState.isPosting = true;
+            // 如果当前状态是取消，抛出异常
             if (postingState.canceled) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                // 开始分发event
                 while (!eventQueue.isEmpty()) {
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
             } finally {
+                // 执行结束，重置状态
                 postingState.isPosting = false;
                 postingState.isMainThread = false;
             }
@@ -301,6 +317,7 @@ public void cancelEventDelivery(Object event) {
      * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
      */
     public void postSticky(Object event) {
+        // 更新缓存
         synchronized (stickyEvents) {
             stickyEvents.put(event.getClass(), event);
         }
@@ -375,10 +392,15 @@ public boolean hasSubscriberForEvent(Class<?> eventClass) {
         return false;
     }
 
+    /**
+     * 分发event
+     * */
     private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
+        // 如果event是可继承的
         if (eventInheritance) {
+            // 找到event的所有父类，依次进行分发
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -388,10 +410,12 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         } else {
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
+        // 如果没有执行分发
         if (!subscriptionFound) {
             if (logNoSubscriberMessages) {
                 logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
             }
+            // 如果需要发送一个没有订阅者的event，会发送一个NoSubscriberEvent，默认是false
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
                 post(new NoSubscriberEvent(this, event));
@@ -399,8 +423,12 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         }
     }
 
+    /**
+     * 分发一个Event，执行结束返回true，如果没有执行返回false
+     * */
     private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
         CopyOnWriteArrayList<Subscription> subscriptions;
+        // 从集合中找到所有使用event的方法
         synchronized (this) {
             subscriptions = subscriptionsByEventType.get(eventClass);
         }
@@ -410,6 +438,7 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
                 postingState.subscription = subscription;
                 boolean aborted = false;
                 try {
+                    // 按照指定的线程进行分发
                     postToSubscription(subscription, event, postingState.isMainThread);
                     aborted = postingState.canceled;
                 } finally {
@@ -426,6 +455,11 @@ private boolean postSingleEventForEventType(Object event, PostingThreadState pos
         return false;
     }
 
+    /**
+     * 回调给Subscribe
+     *
+     *      按照配置的线程，进行分发
+     * */
     private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
         switch (subscription.subscriberMethod.threadMode) {
             case POSTING:
@@ -462,6 +496,9 @@ private void postToSubscription(Subscription subscription, Object event, boolean
     }
 
     /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
+    /**
+     * 找到event所有的父类，包括接口
+     * */
     private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
         synchronized (eventTypesCache) {
             List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
@@ -473,6 +510,7 @@ private void postToSubscription(Subscription subscription, Object event, boolean
                     addInterfaces(eventTypes, clazz.getInterfaces());
                     clazz = clazz.getSuperclass();
                 }
+                // 添加缓存
                 eventTypesCache.put(eventClass, eventTypes);
             }
             return eventTypes;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..b96c5c50 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -52,21 +52,28 @@
         this.ignoreGeneratedIndex = ignoreGeneratedIndex;
     }
 
+    /**
+     * 找到某一个Class注解的对应的方法
+     * */
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 从缓存取，查看是否已经注册过
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        // 是否要忽略之前编译生成的文件
         if (ignoreGeneratedIndex) {
+            // 使用反射找到对应的方法
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 通过可用的信息查找class注解的方法
             subscriberMethods = findUsingInfo(subscriberClass);
         }
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            // 加入到缓存中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -76,6 +83,7 @@
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 先判断findState是否已经找到了对应的info信息
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
@@ -85,13 +93,19 @@
                     }
                 }
             } else {
+                // 通过注解查找一个类中所有的方法
                 findUsingReflectionInSingleClass(findState);
             }
+            // 继续查找父类
             findState.moveToSuperclass();
         }
+        // 从findState中取出注解的方法的信息，释放事务
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 从事务中取出找到的方法，释放查找事务
+     * */
     private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
         List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
         findState.recycle();
@@ -106,6 +120,9 @@
         return subscriberMethods;
     }
 
+    /**
+     * 找到一个可用的查找事务对象
+     * */
     private FindState prepareFindState() {
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
@@ -119,13 +136,18 @@ private FindState prepareFindState() {
         return new FindState();
     }
 
+    /**
+     * 通过findState找到注解方法的信息
+     * */
     private SubscriberInfo getSubscriberInfo(FindState findState) {
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
+            // 如果查找的class正好是自己的父类，直接使用父类的信息
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
                 return superclassInfo;
             }
         }
+        // 从编译生成的文件中查找对应的注解的方法信息
         if (subscriberInfoIndexes != null) {
             for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                 SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
@@ -137,35 +159,53 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 使用反射找到class注解的方法
+     * */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 找到一个类中被注解的方法
             findUsingReflectionInSingleClass(findState);
+            // 继续遍历自己的父类
             findState.moveToSuperclass();
         }
+        // 从事务中取不出找到的方法，释放事务
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 找到一个类中被注解的方法
+     * */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
+            // 所有声明的方法，这个方法比getMethods要快，尤其是比较庞大的类
             // This is faster than getMethods, especially when subscribers are fat classes like Activities
             methods = findState.clazz.getDeclaredMethods();
         } catch (Throwable th) {
             // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
+            // 有些机型会报错，使用getMethods，并且不检查父类
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            // 如果方法是public，并且没有使用Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                // 得到方法中的所有参数类型
                 Class<?>[] parameterTypes = method.getParameterTypes();
+                // 如果参数只有1个
                 if (parameterTypes.length == 1) {
+                    // 得到方法的Subscribe注解
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        // 参数的类型作为EventType
                         Class<?> eventType = parameterTypes[0];
+                        // 检查是否要加入到方法列表中
                         if (findState.checkAdd(method, eventType)) {
+                            // 把查找到的信息封装到findState中
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
@@ -188,6 +228,9 @@ static void clearCaches() {
         METHOD_CACHE.clear();
     }
 
+    /**
+     * 查找事务，封装找到的方法的信息
+     * */
     static class FindState {
         final List<SubscriberMethod> subscriberMethods = new ArrayList<>();
         final Map<Class, Object> anyMethodByEventType = new HashMap<>();
@@ -216,13 +259,19 @@ void recycle() {
             subscriberInfo = null;
         }
 
+        /**
+         * 检查是否要把某一个方法加入到集合中
+         * */
         boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
+            // HashMap的put方法会返回之前的oldValue
             Object existing = anyMethodByEventType.put(eventType, method);
+            // 如果之前没有值，直接返回true
             if (existing == null) {
                 return true;
             } else {
+                // 判断之前的value是不是方法
                 if (existing instanceof Method) {
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
diff --git a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
index c37c18a5..22b5e686 100644
--- a/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
+++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java
@@ -69,16 +69,19 @@ public SourceVersion getSupportedSourceVersion() {
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
         Messager messager = processingEnv.getMessager();
         try {
+            // 得到gradle中配置的参数eventBusIndex
             String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
             if (index == null) {
                 messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
                         " passed to annotation processor");
                 return false;
             }
+            // 输出日志的标记位，可以忽略
             verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));
+            // 从eventBusIndex中截取我们要使用的包名
             int lastPeriod = index.lastIndexOf('.');
             String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null;
-
+            // 记录是第几次执行process方法
             round++;
             if (verbose) {
                 messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +
@@ -99,10 +102,13 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 messager.printMessage(Diagnostic.Kind.ERROR,
                         "Unexpected processing state: annotations still available after writing.");
             }
+            // 收集代码中使用的注解
             collectSubscribers(annotations, env, messager);
+            // 检查是否有需要忽略的注解
             checkForSubscribersToSkip(messager, indexPackage);
 
             if (!methodsByClass.isEmpty()) {
+                // 生成源文件
                 createInfoIndexFile(index);
             } else {
                 messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
@@ -116,13 +122,21 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         return true;
     }
 
+    /**
+     * 收集代码中使用的Subscribe注解
+     * */
     private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
+        // 遍历所有要使用的注解
         for (TypeElement annotation : annotations) {
+            // 得到这个注解标注的所有元素集合
             Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
             for (Element element : elements) {
+                // 判断是否是一个可执行的方法
                 if (element instanceof ExecutableElement) {
                     ExecutableElement method = (ExecutableElement) element;
+                    // 检查方法是否符合要求：非static, 只能是public，只能有一个参数
                     if (checkHasNoErrors(method, messager)) {
+                        // 把含有方法的对象保存在集合中
                         TypeElement classElement = (TypeElement) method.getEnclosingElement();
                         methodsByClass.putElement(classElement, method);
                     }
@@ -133,6 +147,9 @@ private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnv
         }
     }
 
+    /**
+     * 检查被注解的元素是否符合要求：非static, 只能是public，只能有一个参数
+     * */
     private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
         if (element.getModifiers().contains(Modifier.STATIC)) {
             messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must not be static", element);
@@ -154,12 +171,17 @@ private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {
 
     /**
      * Subscriber classes should be skipped if their class or any involved event class are not visible to the index.
+     *
+     *      检查需要被忽略的注解
      */
     private void checkForSubscribersToSkip(Messager messager, String myPackage) {
+        // 遍历被注解的元素集合
         for (TypeElement skipCandidate : methodsByClass.keySet()) {
             TypeElement subscriberClass = skipCandidate;
             while (subscriberClass != null) {
+                // 判断元素是否可见
                 if (!isVisible(myPackage, subscriberClass)) {
+                    // 添加到忽略的集合中
                     boolean added = classesToSkip.add(skipCandidate);
                     if (added) {
                         String msg;
@@ -173,23 +195,28 @@ private void checkForSubscribersToSkip(Messager messager, String myPackage) {
                     }
                     break;
                 }
+                // 得到这个元素被注解的所有方法
                 List<ExecutableElement> methods = methodsByClass.get(subscriberClass);
                 if (methods != null) {
                     for (ExecutableElement method : methods) {
                         String skipReason = null;
+                        // 获得第一个形参的类型
                         VariableElement param = method.getParameters().get(0);
                         TypeMirror typeMirror = getParamTypeMirror(param, messager);
+                        // 如果参数的类型是基本类型，忽略
                         if (!(typeMirror instanceof DeclaredType) ||
                                 !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) {
                             skipReason = "event type cannot be processed";
                         }
                         if (skipReason == null) {
+                            // 判断元素是否可见，否则忽略
                             TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();
                             if (!isVisible(myPackage, eventTypeElement)) {
                                 skipReason = "event type is not public";
                             }
                         }
                         if (skipReason != null) {
+                            // 如果刚才两项检查没通过，加入到忽略的集合中
                             boolean added = classesToSkip.add(skipCandidate);
                             if (added) {
                                 String msg = "Falling back to reflection because " + skipReason;
@@ -202,16 +229,22 @@ private void checkForSubscribersToSkip(Messager messager, String myPackage) {
                         }
                     }
                 }
+                // 找到自己的父类，继续遍历
                 subscriberClass = getSuperclass(subscriberClass);
             }
         }
     }
 
+    /**
+     * 获得一个参数的类型
+     * */
     private TypeMirror getParamTypeMirror(VariableElement param, Messager messager) {
         TypeMirror typeMirror = param.asType();
         // Check for generic type
         if (typeMirror instanceof TypeVariable) {
+            // 得到这个元素的父元素
             TypeMirror upperBound = ((TypeVariable) typeMirror).getUpperBound();
+            // 如果父元素是被声明的类型，非基本类型
             if (upperBound instanceof DeclaredType) {
                 if (messager != null) {
                     messager.printMessage(Diagnostic.Kind.NOTE, "Using upper bound type " + upperBound +
@@ -223,10 +256,14 @@ private TypeMirror getParamTypeMirror(VariableElement param, Messager messager)
         return typeMirror;
     }
 
+    /**
+     * 获得指定元素的父类
+     * */
     private TypeElement getSuperclass(TypeElement type) {
         if (type.getSuperclass().getKind() == TypeKind.DECLARED) {
             TypeElement superclass = (TypeElement) processingEnv.getTypeUtils().asElement(type.getSuperclass());
             String name = superclass.getQualifiedName().toString();
+            // 如果父类是java类或者是android类，检查结束
             if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
                 // Skip system classes, this just degrades performance
                 return null;
@@ -238,17 +275,26 @@ private TypeElement getSuperclass(TypeElement type) {
         }
     }
 
+    /**
+     * 获得一个类的class
+     * */
     private String getClassString(TypeElement typeElement, String myPackage) {
+        // 得到元素的包名
         PackageElement packageElement = getPackageElement(typeElement);
         String packageString = packageElement.getQualifiedName().toString();
         String className = typeElement.getQualifiedName().toString();
+        // 如果包名并不为空
         if (packageString != null && !packageString.isEmpty()) {
+            // 如果与我们创建的文件的包名相同，裁剪掉包名，只留下类名
             if (packageString.equals(myPackage)) {
                 className = cutPackage(myPackage, className);
-            } else if (packageString.equals("java.lang")) {
+            }
+            // 如果是java原生类，直接使用类名
+            else if (packageString.equals("java.lang")) {
                 className = typeElement.getSimpleName().toString();
             }
         }
+        // 其他情况使用完整的包名+类名
         return className;
     }
 
@@ -270,6 +316,9 @@ private PackageElement getPackageElement(TypeElement subscriberClass) {
         return (PackageElement) candidate;
     }
 
+    /**
+     * 创建一个SimpleSubscriberInfo对象
+     * */
     private void writeCreateSubscriberMethods(BufferedWriter writer, List<ExecutableElement> methods,
                                               String callPrefix, String myPackage) throws IOException {
         for (ExecutableElement method : methods) {
@@ -307,6 +356,11 @@ private void writeCreateSubscriberMethods(BufferedWriter writer, List<Executable
         }
     }
 
+    /**
+     * 生成源文件
+     *
+     * @param index 指定的生成文件的名称
+     * */
     private void createInfoIndexFile(String index) {
         BufferedWriter writer = null;
         try {
@@ -326,16 +380,20 @@ private void createInfoIndexFile(String index) {
             writer.write("import java.util.HashMap;\n");
             writer.write("import java.util.Map;\n\n");
             writer.write("/** This class is generated by EventBus, do not edit. */\n");
+            // 实现SubscriberInfoIndex接口
             writer.write("public class " + clazz + " implements SubscriberInfoIndex {\n");
             writer.write("    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n");
+            // static代码块，把刚才找到的注解信息，直接保存在集合中
             writer.write("    static {\n");
             writer.write("        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();\n\n");
             writeIndexLines(writer, myPackage);
             writer.write("    }\n\n");
+            // 加入一个注解信息
             writer.write("    private static void putIndex(SubscriberInfo info) {\n");
             writer.write("        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n");
             writer.write("    }\n\n");
             writer.write("    @Override\n");
+            // 获得指定class的注解信息
             writer.write("    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {\n");
             writer.write("        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n");
             writer.write("        if (info != null) {\n");
@@ -358,14 +416,20 @@ private void createInfoIndexFile(String index) {
         }
     }
 
+    /**
+     * 把找到的注解信息封装起来
+     * */
     private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOException {
         for (TypeElement subscriberTypeElement : methodsByClass.keySet()) {
+            // 如果这是一个被忽略的元素，直接跳过
             if (classesToSkip.contains(subscriberTypeElement)) {
                 continue;
             }
 
             String subscriberClass = getClassString(subscriberTypeElement, myPackage);
+            // 如果元素是可见的
             if (isVisible(myPackage, subscriberTypeElement)) {
+                // 把注解信息封装成SimpleSubscriberInfo，放入集合中
                 writeLine(writer, 2,
                         "putIndex(new SimpleSubscriberInfo(" + subscriberClass + ".class,",
                         "true,", "new SubscriberMethodInfo[] {");
@@ -378,6 +442,9 @@ private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOE
         }
     }
 
+    /**
+     * 判断元素是否是全局可见：public或者在app的包名中，或者是最外层类，不属于任何包
+     * */
     private boolean isVisible(String myPackage, TypeElement typeElement) {
         Set<Modifier> modifiers = typeElement.getModifiers();
         boolean visible;
diff --git a/EventBusPerformance/build.gradle b/EventBusPerformance/build.gradle
index fb2cc52f..f1cd5575 100644
--- a/EventBusPerformance/build.gradle
+++ b/EventBusPerformance/build.gradle
@@ -1,10 +1,11 @@
 buildscript {
     repositories {
         jcenter()
+        google()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.android.tools.build:gradle:3.1.3'
     }
 }
 
diff --git a/EventBusTest/build.gradle b/EventBusTest/build.gradle
index ab6b884c..32845b5f 100644
--- a/EventBusTest/build.gradle
+++ b/EventBusTest/build.gradle
@@ -1,10 +1,11 @@
 buildscript {
     repositories {
         jcenter()
+        google()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.android.tools.build:gradle:3.1.3'
     }
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index bf1b63c3..2b6c2d32 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
+#Fri Jul 13 17:14:50 CST 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
