diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e35ecd38..c64afc52 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -110,14 +110,23 @@ public EventBus() {
 
     EventBus(EventBusBuilder builder) {
         logger = builder.getLogger();
+        // 根据事件类型的订阅集合, key是订阅者对象
         subscriptionsByEventType = new HashMap<>();
+        //
         typesBySubscriber = new HashMap<>();
+        // 粘性事件
         stickyEvents = new ConcurrentHashMap<>();
+        // 主线程支持实现接口
         mainThreadSupport = builder.getMainThreadSupport();
+        // 事件主线程处理
         mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
+        // 后台事件处理
         backgroundPoster = new BackgroundPoster(this);
+        // 异步事件处理
         asyncPoster = new AsyncPoster(this);
+        //
         indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
+        // 订阅方法查找器
         subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                 builder.strictMethodVerification, builder.ignoreGeneratedIndex);
         logSubscriberExceptions = builder.logSubscriberExceptions;
@@ -139,8 +148,10 @@ public EventBus() {
      */
     public void register(Object subscriber) {
         Class<?> subscriberClass = subscriber.getClass();
+        // 获取对应subscriber类的订阅方法
         List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
         synchronized (this) {
+            // 遍历执行订阅
             for (SubscriberMethod subscriberMethod : subscriberMethods) {
                 subscribe(subscriber, subscriberMethod);
             }
@@ -148,6 +159,12 @@ public void register(Object subscriber) {
     }
 
     // Must be called in synchronized block
+
+    /**
+     * 订阅动作
+     * @param subscriber
+     * @param subscriberMethod
+     */
     private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
         Class<?> eventType = subscriberMethod.eventType;
         Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
index 1d78d479..ab264c98 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethod.java
@@ -19,10 +19,14 @@
 
 /** Used internally by EventBus and generated subscriber indexes. */
 public class SubscriberMethod {
+    // 具体执行方法
     final Method method;
+    // 执行线程
     final ThreadMode threadMode;
     final Class<?> eventType;
+    // 优先级
     final int priority;
+    // 是否粘性
     final boolean sticky;
     /** Used for efficient comparison */
     String methodString;
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index db5e0ad3..013006ad 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -53,20 +53,26 @@
     }
 
     List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
+        // 从缓存中查找订阅方法
         List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
+        // 缓存中有, 直接返回
         if (subscriberMethods != null) {
             return subscriberMethods;
         }
-
+        // 查找注册方法
         if (ignoreGeneratedIndex) {
+            // 使用反射查找
             subscriberMethods = findUsingReflection(subscriberClass);
         } else {
+            // 使用注解器生成的类查找
             subscriberMethods = findUsingInfo(subscriberClass);
         }
+        // 如果没有订阅方法, 则抛出异常
         if (subscriberMethods.isEmpty()) {
             throw new EventBusException("Subscriber " + subscriberClass
                     + " and its super classes have no public methods with the @Subscribe annotation");
         } else {
+            // 否则加入缓存中
             METHOD_CACHE.put(subscriberClass, subscriberMethods);
             return subscriberMethods;
         }
@@ -79,12 +85,14 @@
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
                 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
+                // 遍历订阅者方法
                 for (SubscriberMethod subscriberMethod : array) {
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                         findState.subscriberMethods.add(subscriberMethod);
                     }
                 }
             } else {
+                // 没有订阅信息, 从反射来找
                 findUsingReflectionInSingleClass(findState);
             }
             findState.moveToSuperclass();
@@ -120,8 +128,11 @@ private FindState prepareFindState() {
     }
 
     private SubscriberInfo getSubscriberInfo(FindState findState) {
+        // 父类和当前类的订阅信息不为空
         if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
+            // 获取父类的订阅信息
             SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
+            // 如果订阅类和父类的订阅信息相同, 返回父类
             if (findState.clazz == superclassInfo.getSubscriberClass()) {
                 return superclassInfo;
             }
@@ -137,16 +148,28 @@ private SubscriberInfo getSubscriberInfo(FindState findState) {
         return null;
     }
 
+    /**
+     * 利用反射查找订阅方法
+     * @param subscriberClass
+     * @return
+     */
     private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
         FindState findState = prepareFindState();
         findState.initForSubscriber(subscriberClass);
         while (findState.clazz != null) {
+            // 使用反射找到单类
             findUsingReflectionInSingleClass(findState);
+            // 查找父类的订阅方法
             findState.moveToSuperclass();
         }
+        // 获取订阅方法list, 并释放findState
         return getMethodsAndRelease(findState);
     }
 
+    /**
+     * 使用反射找到订阅方法单类
+     * @param findState
+     */
     private void findUsingReflectionInSingleClass(FindState findState) {
         Method[] methods;
         try {
@@ -157,15 +180,22 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             methods = findState.clazz.getMethods();
             findState.skipSuperClasses = true;
         }
+        // 遍历方法
         for (Method method : methods) {
             int modifiers = method.getModifiers();
+            // 如果方法修饰符是PUBLIC, 并且不带ABSTRACT等等修饰符, 执行下面流程
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
+                // 得到请求参数类型
                 Class<?>[] parameterTypes = method.getParameterTypes();
                 if (parameterTypes.length == 1) {
                     Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                     if (subscribeAnnotation != null) {
+                        // 带有Subscribe注解
+                        // 传递事件类型赋值
                         Class<?> eventType = parameterTypes[0];
+                        // 校验
                         if (findState.checkAdd(method, eventType)) {
+                            // 实例化
                             ThreadMode threadMode = subscribeAnnotation.threadMode();
                             findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
@@ -220,9 +250,11 @@ boolean checkAdd(Method method, Class<?> eventType) {
             // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
             // Usually a subscriber doesn't have methods listening to the same event type.
             Object existing = anyMethodByEventType.put(eventType, method);
+            // 如果同样的eventType不存在, 校验成功
             if (existing == null) {
                 return true;
             } else {
+                // 存在同样的eventType
                 if (existing instanceof Method) {
                     if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                         // Paranoia check
