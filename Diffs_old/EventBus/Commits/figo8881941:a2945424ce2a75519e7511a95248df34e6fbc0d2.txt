diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index e7a7f83d..1e348646 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -44,6 +44,9 @@
     static volatile EventBus defaultInstance;
 
     private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+
+    //以事件类型分类的事件类型的父类及实现接口的Map集合
+    //保存的是某个事件的父类及接口集合
     private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
 
     //以订阅事件类型分类的订阅信息的Map集合
@@ -57,6 +60,7 @@
     //粘性事件集合
     private final Map<Class<?>, Object> stickyEvents;
 
+    //发布事件线程的状态信息
     private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
         @Override
         protected PostingThreadState initialValue() {
@@ -202,6 +206,11 @@ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                 Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
                 for (Map.Entry<Class<?>, Object> entry : entries) {
                     Class<?> candidateEventType = entry.getKey();
+                    /**
+                     * 有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a），以及方法中作为参数的这个类对象（称之为对象b），这两个对象如果满足以下条件则返回true，否则返回false：
+                     *  a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口
+                     *  a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口
+                     */
                     if (eventType.isAssignableFrom(candidateEventType)) {
                         Object stickyEvent = entry.getValue();
                         checkPostStickyEventToSubscription(newSubscription, stickyEvent);
@@ -274,10 +283,13 @@ public synchronized void unregister(Object subscriber) {
 
     /** Posts the given event to the event bus. */
     public void post(Object event) {
+
+        //把事件添加到当前线程状态信息的事件队列里面
         PostingThreadState postingState = currentPostingThreadState.get();
         List<Object> eventQueue = postingState.eventQueue;
         eventQueue.add(event);
 
+        //同一线程发布的事件，是按先后顺序，逐个进行发布的
         if (!postingState.isPosting) {
             postingState.isMainThread = isMainThread();
             postingState.isPosting = true;
@@ -285,6 +297,7 @@ public void post(Object event) {
                 throw new EventBusException("Internal error. Abort state was not reset");
             }
             try {
+                //循环队列，发布事件，通知订阅者
                 while (!eventQueue.isEmpty()) {
                     postSingleEvent(eventQueue.remove(0), postingState);
                 }
@@ -296,6 +309,10 @@ public void post(Object event) {
     }
 
     /**
+     * 取消事件向后续订阅者发布的方法
+     * 在某个订阅者处理事件的方法里面调用
+     * 一般是用于高优先级的订阅者处理事件后，阻止向后续低优先级订阅者发布事件
+     * 取消操作严格限制在订阅方法threadMode = ThreadMode.POSTING中调用，也就是订阅方法与发布事件的方法在同一线程运行
      * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
      * subscribers
      * won't receive the event. Events are usually canceled by higher priority subscribers (see
@@ -404,6 +421,8 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
         Class<?> eventClass = event.getClass();
         boolean subscriptionFound = false;
         if (eventInheritance) {
+            //如果开启事件继承
+            //找出事件类型所有的父类和接口类型
             List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
             int countTypes = eventTypes.size();
             for (int h = 0; h < countTypes; h++) {
@@ -411,12 +430,15 @@ private void postSingleEvent(Object event, PostingThreadState postingState) thro
                 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
             }
         } else {
+            //如果没有开启事件继续
             subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
         }
         if (!subscriptionFound) {
+            //如果没有找到订阅者
             if (logNoSubscriberMessages) {
                 logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
             }
+            //根据条件，发布没有订阅者事件
             if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                     eventClass != SubscriberExceptionEvent.class) {
                 post(new NoSubscriberEvent(this, event));
