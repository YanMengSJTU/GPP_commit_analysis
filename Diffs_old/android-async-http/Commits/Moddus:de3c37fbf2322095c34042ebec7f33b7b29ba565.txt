diff --git a/.travis.yml b/.travis.yml
index a7560a7b..40336a55 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -22,22 +22,15 @@ before_install:
   - export PATH=$GRADLE_HOME/bin:$PATH
   # just to test gradle version, against our provided one
   - gradle -v
-  # newest android SDK 22.0.5
-  - wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz
-  - tar -zxf android-sdk_r22.0.5-linux.tgz
+  # newest android SDK 22.3
+  - wget http://dl.google.com/android/android-sdk_r22.3-linux.tgz
+  - tar -zxf android-sdk_r22.3-linux.tgz
   - export ANDROID_HOME=`pwd`/android-sdk-linux
   - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
   # manually set sdk.dir variable, according to local paths
   - echo "sdk.dir=$ANDROID_HOME" > local.properties
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-18 --force --no-ui
-  # build tools cannot be installed through "android update sdk" as of now
-  - wget http://dl.google.com/android/repository/build-tools_r18.0.1-linux.zip
-  - mkdir -p $ANDROID_HOME/build-tools
-  - unzip -qq build-tools_r18.0.1-linux.zip -d $ANDROID_HOME/build-tools/
-  - mv $ANDROID_HOME/build-tools/android-4.3 $ANDROID_HOME/build-tools/18.0.1
-  # verify files exist in right paths
-  - find $ANDROID_HOME/build-tools
-  - file $ANDROID_HOME/build-tools/18.0.1/aapt
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.0 --force --no-ui
+  # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
 
diff --git a/README.md b/README.md
index bcb46116..670b0313 100644
--- a/README.md
+++ b/README.md
@@ -29,7 +29,7 @@ https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/androi
 Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
 ArtifactId: async-http-client
-Version: 1.4.4-SNAPSHOT
+Version: 1.4.5-SNAPSHOT
 Packaging: JAR or AAR
 ```
 
@@ -40,7 +40,7 @@ http://central.maven.org/maven2/com/loopj/android/android-async-http/
 Maven URL: http://repo1.maven.org/maven2/
 GroupId: com.loopj.android
 ArtifactId: android-async-http
-Version: 1.4.3
+Version: 1.4.4
 Packaging: JAR or AAR
 ```
 
diff --git a/build.gradle b/build.gradle
index d239f5ad..86808556 100644
--- a/build.gradle
+++ b/build.gradle
@@ -14,7 +14,7 @@ def isReleaseBuild() {
 
 allprojects {
     group = 'com.loopj.android'
-    version = '1.4.4-SNAPSHOT'
+    version = '1.4.5-SNAPSHOT'
 
     repositories {
         mavenCentral()
diff --git a/gradle.properties b/gradle.properties
index 0de12ce9..faf4d955 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
-VERSION_NAME=1.4.4-SNAPSHOT
-VERSION_CODE=144
+VERSION_NAME=1.4.5-SNAPSHOT
+VERSION_CODE=145
 GROUP=com.loopj.android
 
 POM_DESCRIPTION=An Asynchronous HTTP Library for Android
diff --git a/library/build.gradle b/library/build.gradle
index 4126bb52..7cd3e2af 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,16 +1,19 @@
 apply plugin: 'android-library'
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion '18.0.1'
+    compileSdkVersion 19
+    buildToolsVersion '19.0.0'
+}
 
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
+android.libraryVariants.all { variant ->
+  def name = variant.buildType.name
+  if (name.equals(com.android.builder.BuilderConstants.DEBUG)) {
+    return; // Skip debug builds.
+  }
+  def task = project.tasks.create "android${name.capitalize()}Jar", Jar
+  task.dependsOn variant.javaCompile
+  task.from variant.javaCompile.destinationDir
+  artifacts.add('archives', task);
 }
 
 android.libraryVariants.all { variant ->
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
deleted file mode 100644
index 76049ccd..00000000
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package com.loopj.android.http;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-
-public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
-
-    private File mFile;
-
-    public FileAsyncHttpResponseHandler(File file) {
-        super();
-        this.mFile = file;
-    }
-
-    public void onSuccess(File file) {
-    }
-
-    public void onSuccess(int statusCode, File file) {
-        onSuccess(file);
-    }
-
-    public void onFailure(Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e);
-    }
-
-    public void onFailure(int statusCode, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e, response);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(statusCode, e, response);
-    }
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        onFailure(statusCode, headers, error, mFile);
-    }
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        onSuccess(statusCode, mFile);
-    }
-
-    @Override
-    byte[] getResponseData(HttpEntity entity) throws IOException {
-      if (entity != null) {
-          InputStream instream = entity.getContent();
-          long contentLength = entity.getContentLength();
-          FileOutputStream buffer = new FileOutputStream(this.mFile);
-          if (instream != null) {
-              try {
-                  byte[] tmp = new byte[BUFFER_SIZE];
-                  int l, count = 0;
-                  // do not send messages if request has been cancelled
-                  while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                      count += l;
-                      buffer.write(tmp, 0, l);
-                      sendProgressMessage(count, (int) contentLength);
-                  }
-              } finally {
-                  instream.close();
-                  buffer.flush();
-                  buffer.close();
-              }
-          }
-      }
-      return null;
-  }
-  
-}
diff --git a/library/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
similarity index 80%
rename from library/AndroidManifest.xml
rename to library/src/main/AndroidManifest.xml
index dede71fe..13d6f26e 100644
--- a/library/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.4-SNAPSHOT"
-    android:versionCode="144">
+    android:versionName="1.4.5-SNAPSHOT"
+    android:versionCode="145">
 
     <uses-sdk
         android:minSdkVersion="3" />
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
similarity index 74%
rename from library/src/com/loopj/android/http/AsyncHttpClient.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 088563fc..abaf6ee5 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -86,9 +86,13 @@
  * <p>&nbsp;</p>
  * For example:
  * <p>&nbsp;</p>
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
+ * your Android applications. Requests can be made with additional parameters by passing a {@link
+ * RequestParams} instance, and responses can be handled by passing an anonymously overridden {@link
+ * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ * client.get("http://www.google.com", new ResponseHandlerInterface() {
  *     &#064;Override
  *     public void onSuccess(String response) {
  *         System.out.println(response);
@@ -97,7 +101,7 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.4";
+    private static final String VERSION = "1.4.5";
 
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
@@ -215,7 +219,7 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+        threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(DEFAULT_MAX_CONNECTIONS);
         requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
         clientHeaderMap = new HashMap<String, String>();
 
@@ -256,9 +260,9 @@ public void process(HttpResponse response, HttpContext context) {
     }
 
     /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
+     * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
+     * settings for requests by accessing the client's ConnectionManager, HttpParams and
+     * SchemeRegistry.
      *
      * @return underlying HttpClient instance
      */
@@ -267,9 +271,8 @@ public HttpClient getHttpClient() {
     }
 
     /**
-     * Get the underlying HttpContext instance. This is useful for getting
-     * and setting fine-grained settings for requests by accessing the
-     * context's attributes such as the CookieStore.
+     * Get the underlying HttpContext instance. This is useful for getting and setting fine-grained
+     * settings for requests by accessing the context's attributes such as the CookieStore.
      *
      * @return underlying HttpContext instance
      */
@@ -280,25 +283,27 @@ public HttpContext getHttpContext() {
     /**
      * Sets an optional CookieStore to use when making requests
      *
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
+     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link
+     *                    PersistentCookieStore}
      */
     public void setCookieStore(CookieStore cookieStore) {
         httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
     }
 
     /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
+     * Overrides the threadpool implementation used when queuing/pooling requests. By default,
+     * Executors.newFixedThreadPool() is used.
      *
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
+     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling
+     *                   requests.
      */
     public void setThreadPool(ThreadPoolExecutor threadPool) {
         this.threadPool = threadPool;
     }
 
     /**
-     * Simple interface method, to enable or disable redirects.
-     * If you set manually RedirectHandler on underlying HttpClient, effects of this method will be canceled.
+     * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
+     * on underlying HttpClient, effects of this method will be canceled.
      *
      * @param enableRedirects boolean
      */
@@ -312,8 +317,8 @@ public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
     }
 
     /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     * Sets the User-Agent header to be sent with each request. By default, "Android Asynchronous
+     * Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
      *
      * @param userAgent the string to use in the User-Agent header.
      */
@@ -399,8 +404,8 @@ public void setProxy(String hostname, int port, String username, String password
 
 
     /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
+     * Sets the SSLSocketFactory to user when making requests. By default, a new, default
+     * SSLSocketFactory is used.
      *
      * @param sslSocketFactory the socket factory to use for https requests.
      */
@@ -412,6 +417,7 @@ public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
      * Sets the maximum number of retries and timeout for a particular Request.
      *
      * @param retries maximum number of retries per request
+     * @param timeout sleep between retries in milliseconds
      */
     public void setMaxRetriesAndTimeout(int retries, int timeout) {
         this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
@@ -449,8 +455,8 @@ public void setBasicAuth(String username, String password) {
     }
 
     /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
-     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
      *
      * @param username Basic Auth username
      * @param password Basic Auth password
@@ -469,16 +475,14 @@ public void clearBasicAuth() {
     }
 
     /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>&nbsp;</p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
+     * Cancels any pending (or potentially active) requests associated with the passed Context.
+     * <p>&nbsp;</p> <b>Note:</b> This will only affect requests which were created with a non-null
+     * android Context. This method is intended to be used in the onDestroy method of your android
+     * activities to destroy all requests which are no longer required.
      *
      * @param context               the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
      */
     public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         List<WeakReference<Future<?>>> requestList = requestMap.get(context);
@@ -502,9 +506,10 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
      *
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void head(String url, AsyncHttpResponseHandler responseHandler) {
-        head(null, url, null, responseHandler);
+    public RequestHandle head(String url, ResponseHandlerInterface responseHandler) {
+        return head(null, url, null, responseHandler);
     }
 
     /**
@@ -513,20 +518,23 @@ public void head(String url, AsyncHttpResponseHandler responseHandler) {
      * @param url             the URL to send the request to.
      * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        head(null, url, params, responseHandler);
+    public RequestHandle head(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return head(null, url, params, responseHandler);
     }
 
     /**
-     * Perform a HTTP HEAD request without any parameters and track the Android Context which initiated the request.
+     * Perform a HTTP HEAD request without any parameters and track the Android Context which
+     * initiated the request.
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        head(context, url, null, responseHandler);
+    public RequestHandle head(Context context, String url, ResponseHandlerInterface responseHandler) {
+        return head(context, url, null, responseHandler);
     }
 
     /**
@@ -536,26 +544,27 @@ public void head(Context context, String url, AsyncHttpResponseHandler responseH
      * @param url             the URL to send the request to.
      * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    public RequestHandle head(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
-     * Perform a HTTP HEAD request and track the Android Context which initiated
-     * the request with customized headers
+     * Perform a HTTP HEAD request and track the Android Context which initiated the request with
+     * customized headers
      *
      * @param context         Context to execute request against
      * @param url             the URL to send the request to.
      * @param headers         set headers only for this request
      * @param params          additional HEAD parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *                        the response.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle head(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
 
@@ -569,9 +578,10 @@ public void head(Context context, String url, Header[] headers, RequestParams pa
      *
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
+    public RequestHandle get(String url, ResponseHandlerInterface responseHandler) {
+        return get(null, url, null, responseHandler);
     }
 
     /**
@@ -580,20 +590,23 @@ public void get(String url, AsyncHttpResponseHandler responseHandler) {
      * @param url             the URL to send the request to.
      * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
+    public RequestHandle get(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return get(null, url, params, responseHandler);
     }
 
     /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
+     * Perform a HTTP GET request without any parameters and track the Android Context which
+     * initiated the request.
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
+    public RequestHandle get(Context context, String url, ResponseHandlerInterface responseHandler) {
+        return get(context, url, null, responseHandler);
     }
 
     /**
@@ -603,26 +616,27 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
      * @param url             the URL to send the request to.
      * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    public RequestHandle get(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
+     * Perform a HTTP GET request and track the Android Context which initiated the request with
+     * customized headers
      *
      * @param context         Context to execute request against
      * @param url             the URL to send the request to.
      * @param headers         set headers only for this request
      * @param params          additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *                        the response.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
 
@@ -636,9 +650,10 @@ public void get(Context context, String url, Header[] headers, RequestParams par
      *
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
+    public RequestHandle post(String url, ResponseHandlerInterface responseHandler) {
+        return post(null, url, null, responseHandler);
     }
 
     /**
@@ -647,9 +662,10 @@ public void post(String url, AsyncHttpResponseHandler responseHandler) {
      * @param url             the URL to send the request to.
      * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
+    public RequestHandle post(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return post(null, url, params, responseHandler);
     }
 
     /**
@@ -659,9 +675,10 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param url             the URL to send the request to.
      * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    public RequestHandle post(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -669,56 +686,60 @@ public void post(Context context, String url, RequestParams params, AsyncHttpRes
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
-     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
      * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+    public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
     }
 
     /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
+     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
+     * headers only for this request
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param headers         set headers only for this request
      * @param params          additional POST parameters to send with the request.
-     * @param contentType     the content type of the payload you are sending, for
-     *                        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *                        the response.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-                     AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+                              ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
+        return sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
     }
 
     /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
+     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
+     * headers only for this request
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param headers         set headers only for this request
-     * @param entity          a raw {@link HttpEntity} to send with the request, for
-     *                        example, use this to send string/json/xml payloads to a server by
-     *                        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for
-     *                        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *                        the response.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-                     AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+                              ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
     //
@@ -730,9 +751,10 @@ public void post(Context context, String url, Header[] headers, HttpEntity entit
      *
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
+    public RequestHandle put(String url, ResponseHandlerInterface responseHandler) {
+        return put(null, url, null, responseHandler);
     }
 
     /**
@@ -741,9 +763,10 @@ public void put(String url, AsyncHttpResponseHandler responseHandler) {
      * @param url             the URL to send the request to.
      * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
+    public RequestHandle put(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return put(null, url, params, responseHandler);
     }
 
     /**
@@ -753,40 +776,49 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param url             the URL to send the request to.
      * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    public RequestHandle put(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
+     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+    public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
     }
 
     /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
+     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param headers         set one-time headers for this request
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
     //
@@ -821,9 +853,10 @@ public void patch( Context context, String url,Header[] headers, HttpEntity enti
      *
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
+    public RequestHandle delete(String url, ResponseHandlerInterface responseHandler) {
+        return delete(null, url, responseHandler);
     }
 
     /**
@@ -832,10 +865,11 @@ public void delete(String url, AsyncHttpResponseHandler responseHandler) {
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
     /**
@@ -845,11 +879,12 @@ public void delete(Context context, String url, AsyncHttpResponseHandler respons
      * @param url             the URL to send the request to.
      * @param headers         set one-time headers for this request
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
         if (headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
     /**
@@ -860,11 +895,12 @@ public void delete(Context context, String url, Header[] headers, AsyncHttpRespo
      * @param headers         set one-time headers for this request
      * @param params          additional DELETE parameters or files to send along with request
      * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
      */
-    public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) httpDelete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
     /**
@@ -875,13 +911,18 @@ public void delete(Context context, String url, Header[] headers, RequestParams
      * @param context         Context of Android application, to hold the reference of request
      * @param httpContext     HttpContext in which the request will be executed
      * @param responseHandler ResponseHandler or its subclass to put the response into
-     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete, HttpPost, HttpGet, HttpPut, etc.
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
+     *                        HttpPost, HttpGet, HttpPut, etc.
+     * @return RequestHandle of future request process
      */
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
+    protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            uriRequest.setHeader("Content-Type", contentType);
         }
 
+        responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
+        responseHandler.setRequestURI(uriRequest.getURI());
+
         Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
 
         if (context != null) {
@@ -896,11 +937,13 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
 
             // TODO: Remove dead weakrefs from requestLists?
         }
+
+        return new RequestHandle(request);
     }
 
     /**
-     * Sets state of URL encoding feature, see bug #227, this method
-     * allows you to turn off and on this auto-magic feature on-demand.
+     * Sets state of URL encoding feature, see bug #227, this method allows you to turn off and on
+     * this auto-magic feature on-demand.
      *
      * @param enabled desired state of feature
      */
@@ -911,11 +954,13 @@ public void setURLEncodingEnabled(boolean enabled) {
     /**
      * Will encode url, if not disabled, and adds params on the end of it
      *
-     * @param url    String with URL, should be valid URL without params
-     * @param params RequestParams to be appended on the end of URL
+     * @param url             String with URL, should be valid URL without params
+     * @param params          RequestParams to be appended on the end of URL
+     * @param shouldEncodeUrl whether url should be encoded (replaces spaces with %20)
+     * @return encoded url if requested with params appended if any available
      */
-    public static String getUrlWithQueryString(boolean isUrlEncodingEnabled, String url, RequestParams params) {
-        if (isUrlEncodingEnabled)
+    public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
+        if (shouldEncodeUrl)
             url = url.replace(" ", "%20");
 
         if (params != null) {
@@ -935,9 +980,9 @@ public static String getUrlWithQueryString(boolean isUrlEncodingEnabled, String
      * Allows also passing progress from upload via provided ResponseHandler
      *
      * @param params          additional request params
-     * @param responseHandler AsyncHttpResponseHandler or its subclass to be notified on progress
+     * @param responseHandler ResponseHandlerInterface or its subclass to be notified on progress
      */
-    private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpEntity entity = null;
 
         try {
@@ -946,7 +991,7 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
             }
         } catch (Throwable t) {
             if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, (byte[]) null, t);
+                responseHandler.sendFailureMessage(0, null, null, t);
             else
                 t.printStackTrace();
         }
@@ -959,7 +1004,8 @@ public boolean isUrlEncodingEnabled() {
     }
 
     /**
-     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for example not DELETE
+     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for
+     * example not DELETE
      *
      * @param entity      entity to be included within the request
      * @param requestBase HttpRequest instance, must not be null
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
similarity index 93%
rename from library/src/com/loopj/android/http/AsyncHttpRequest.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 1f7c8a3a..d6c36f2a 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -18,6 +18,8 @@
 
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
@@ -32,10 +34,10 @@
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
-    private final AsyncHttpResponseHandler responseHandler;
+    private final ResponseHandlerInterface responseHandler;
     private int executionCount;
 
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
+    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
         this.client = client;
         this.context = context;
         this.request = request;
@@ -55,7 +57,7 @@ public void run() {
                 responseHandler.sendFailureMessage(0, null, null, e);
             }
         }
-        
+
         if (responseHandler != null) {
             responseHandler.sendFinishMessage();
         }
@@ -83,8 +85,7 @@ private void makeRequestWithRetries() throws IOException {
         boolean retry = true;
         IOException cause = null;
         HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        try
-        {
+        try {
             while (retry) {
                 try {
                     makeRequest();
@@ -105,16 +106,17 @@ private void makeRequestWithRetries() throws IOException {
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                if(retry && (responseHandler != null)) {
+                if (retry && (responseHandler != null)) {
                     responseHandler.sendRetryMessage();
                 }
             }
         } catch (Exception e) {
             // catch anything else to ensure failure message is propagated
+            Log.e("AsyncHttpRequest", "Unhandled exception origin cause", e);
             cause = new IOException("Unhandled exception: " + e.getMessage());
         }
-        
+
         // cleaned up to throw IOException
-        throw(cause);
+        throw (cause);
     }
 }
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
similarity index 83%
rename from library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 34b7d79f..58371eca 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -34,17 +34,15 @@
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.ref.WeakReference;
+import java.net.URI;
 
 /**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. The {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is
- * designed to be anonymously overridden with your own response handling code.
- * <p>&nbsp;</p>
- * Additionally, you can override the {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)},
- * {@link #onStart()}, {@link #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
- * <p>&nbsp;</p>
- * For example:
- * <p>&nbsp;</p>
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
+ * #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
+ * <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -59,7 +57,8 @@
  *     }
  *
  *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error)
+ * {
  *         // Response failed :(
  *     }
  *
@@ -80,7 +79,7 @@
  * });
  * </pre>
  */
-public class AsyncHttpResponseHandler {
+public class AsyncHttpResponseHandler implements ResponseHandlerInterface {
     private static final String LOG_TAG = "AsyncHttpResponseHandler";
 
     protected static final int SUCCESS_MESSAGE = 0;
@@ -97,6 +96,29 @@
     private String responseCharset = DEFAULT_CHARSET;
     private Boolean useSynchronousMode = false;
 
+    private URI requestURI = null;
+    private Header[] requestHeaders = null;
+
+    @Override
+    public URI getRequestURI() {
+        return this.requestURI;
+    }
+
+    @Override
+    public Header[] getRequestHeaders() {
+        return this.requestHeaders;
+    }
+
+    @Override
+    public void setRequestURI(URI requestURI) {
+        this.requestURI = requestURI;
+    }
+
+    @Override
+    public void setRequestHeaders(Header[] requestHeaders) {
+        this.requestHeaders = requestHeaders;
+    }
+
     // avoid leaks by using a non-anonymous handler class
     // with a weak reference
     static class ResponderHandler extends Handler {
@@ -119,12 +141,8 @@ public boolean getUseSynchronousMode() {
         return (useSynchronousMode);
     }
 
-    /**
-     * Set the response handler to use synchronous mode or not
-     *
-     * @param value true indicates that synchronous mode should be used
-     */
-    public void setUseSynchronousMode(Boolean value) {
+    @Override
+    public void setUseSynchronousMode(boolean value) {
         useSynchronousMode = value;
     }
 
@@ -139,7 +157,7 @@ public void setCharset(final String charset) {
     }
 
     public String getCharset() {
-        return this.responseCharset;
+        return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
     }
 
     /**
@@ -173,7 +191,8 @@ public void onStart() {
     }
 
     /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
+     * Fired in all cases when the request is finished, after both success and failure, override to
+     * handle in your own code
      */
     public void onFinish() {
     }
@@ -222,11 +241,11 @@ public void onSuccess(int statusCode, String content) {
      */
     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
         try {
-            String response = new String(responseBody, getCharset());
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
             onSuccess(statusCode, headers, response);
         } catch (UnsupportedEncodingException e) {
             Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, (String) null);
+            onFailure(statusCode, headers, e, null);
         }
     }
 
@@ -291,13 +310,12 @@ public void onFailure(int statusCode, Header[] headers, Throwable error, String
      * @param error        the underlying cause of the failure
      */
     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        String response = null;
         try {
-            response = new String(responseBody, getCharset());
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
             onFailure(statusCode, headers, error, response);
         } catch (UnsupportedEncodingException e) {
             Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
+            onFailure(statusCode, headers, error, null);
         }
     }
 
@@ -312,27 +330,27 @@ public void onRetry() {
     // Pre-processing of messages (executes in background threadpool thread)
     //
 
-    protected void sendProgressMessage(int bytesWritten, int totalSize) {
-        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, totalSize}));
+    final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
-    protected void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
+    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
 
-    protected void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
     }
 
-    protected void sendStartMessage() {
+    final public void sendStartMessage() {
         sendMessage(obtainMessage(START_MESSAGE, null));
     }
 
-    protected void sendFinishMessage() {
+    final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-    protected void sendRetryMessage() {
+    final public void sendRetryMessage() {
         sendMessage(obtainMessage(RETRY_MESSAGE, null));
     }
 
@@ -343,17 +361,19 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                if (response != null && response.length >= 3)
+                if (response != null && response.length >= 3) {
                     onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
-                else
+                } else {
                     Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
+                }
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                if (response != null && response.length >= 4)
+                if (response != null && response.length >= 4) {
                     onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
-                else
+                } else {
                     Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
+                }
                 break;
             case START_MESSAGE:
                 onStart();
@@ -363,10 +383,15 @@ protected void handleMessage(Message msg) {
                 break;
             case PROGRESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                if (response != null && response.length >= 2)
-                    onProgress((Integer) response[0], (Integer) response[1]);
-                else
+                if (response != null && response.length >= 2) {
+                    try {
+                        onProgress((Integer) response[0], (Integer) response[1]);
+                    } catch (Throwable t) {
+                        Log.e(LOG_TAG, "custom onProgress contains an error", t);
+                    }
+                } else {
                     Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                }
                 break;
             case RETRY_MESSAGE:
                 onRetry();
@@ -402,8 +427,8 @@ protected Message obtainMessage(int responseMessage, Object response) {
         return msg;
     }
 
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) throws IOException {
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
         // do not process if request has been cancelled
         if (!Thread.currentThread().isInterrupted()) {
             StatusLine status = response.getStatusLine();
@@ -446,7 +471,7 @@ void sendResponseMessage(HttpResponse response) throws IOException {
                     } finally {
                         instream.close();
                     }
-                    responseBody = buffer.buffer();
+                    responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
                     System.gc();
                     throw new IOException("File too large to fit into available memory");
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
new file mode 100644
index 00000000..c9a89091
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -0,0 +1,160 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpStatus;
+
+public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
+    private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
+
+    /**
+     * Creates a new JsonHttpResponseHandler
+     */
+
+    public BaseJsonHttpResponseHandler() {
+        super(DEFAULT_CHARSET);
+    }
+
+    public BaseJsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
+
+    @Override
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        // Disabling this method
+        super.onSuccess(statusCode, headers, responseBody);
+    }
+
+    @Override
+    public final void onSuccess(String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onSuccess(content);
+    }
+
+    @Override
+    public final void onSuccess(int statusCode, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onSuccess(statusCode, content);
+    }
+
+    @Override
+    public final void onFailure(String responseBody, Throwable error) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(responseBody, error);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        //Disabling this method
+        super.onFailure(statusCode, headers, responseBody, error);
+    }
+
+    @Override
+    public final void onFailure(Throwable error) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(error);
+    }
+
+    @Override
+    public final void onFailure(Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(error, content);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(statusCode, error, content);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(statusCode, headers, error, content);
+    }
+
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawResponse, JSON_TYPE response);
+
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable e, String rawData, JSON_TYPE errorResponse);
+
+    @Override
+    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onSuccess(statusCode, headers, responseBody, jsonResponse);
+                            }
+                        });
+                    } catch (final Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, t, responseBody, null);
+                            }
+                        });
+                    }
+                }
+            }).start();
+        } else {
+            onSuccess(statusCode, headers, null, null);
+        }
+    }
+
+    @Override
+    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
+        if (responseBody != null) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, e, responseBody, jsonResponse);
+                            }
+                        });
+                    } catch (Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, e, responseBody, null);
+                            }
+                        });
+                    }
+                }
+            }).start();
+        } else {
+            onFailure(statusCode, headers, e, null, null);
+        }
+    }
+
+    protected abstract JSON_TYPE parseResponse(String responseBody) throws Throwable;
+}
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
similarity index 70%
rename from library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index bc80d658..ce475850 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -19,6 +19,8 @@
 package com.loopj.android.http;
 
 import android.os.Message;
+import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -26,15 +28,12 @@
 
 import java.io.IOException;
 import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 /**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a
- * content-type whitelist. (e.g. checks Content-Type against allowed list,
- * Content-length).
- * <p>&nbsp;</p>
- * For example:
- * <p>&nbsp;</p>
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}.
+ * Receives response body as byte array with a content-type whitelist. (e.g. checks Content-Type
+ * against allowed list, Content-length). <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * String[] allowedTypes = new String[] { "image/png" };
@@ -52,12 +51,22 @@
  * </pre>
  */
 public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
-    // Allow images by default
+
     private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
             "image/png"
     };
 
+    /**
+     * Method can be overriden to return allowed content types, can be sometimes better than passing
+     * data in constructor
+     *
+     * @return array of content-types or Pattern string templates (eg. '.*' to match every response)
+     */
+    public String[] getAllowedContentTypes() {
+        return mAllowedContentTypes;
+    }
+
     /**
      * Creates a new BinaryHttpResponseHandler
      */
@@ -66,10 +75,10 @@ public BinaryHttpResponseHandler() {
     }
 
     /**
-     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
-     * content types with passed String array (hopefully) of content types.
+     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed content types with
+     * passed String array (hopefully) of content types.
      *
-     * @param allowedContentTypes content types array, eg. 'image/jpeg'
+     * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
         this();
@@ -102,27 +111,27 @@ public void onSuccess(int statusCode, byte[] binaryData) {
     /**
      * Fired when a request returns successfully, override to handle in your own code
      *
-     * @param statusCode    response HTTP statuse code
-     * @param headers       response headers, if any
-     * @param responseData  the response body, if any
+     * @param statusCode response HTTP statuse code
+     * @param headers    response headers, if any
+     * @param binaryData the response body, if any
      */
 
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseData) {
-        onSuccess(statusCode, responseData);
+    public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
+        onSuccess(statusCode, binaryData);
     }
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
      *
-     * @param statusCode    response HTTP statuse code
-     * @param headers       response headers, if any
-     * @param responseData  the response body, if any
-     * @param error         the underlying cause of the failure
+     * @param statusCode response HTTP statuse code
+     * @param headers    response headers, if any
+     * @param binaryData the response body, if any
+     * @param error      the underlying cause of the failure
      */
 
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseData, Throwable error) {
+    public void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error) {
         onFailure(statusCode, error, null);
     }
 
@@ -132,7 +141,7 @@ public void onFailure(int statusCode, Header[] headers, byte[] responseData, Thr
 
     // Interface to AsyncHttpRequest
     @Override
-    protected void sendResponseMessage(HttpResponse response) throws IOException {
+    public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
         if (contentTypeHeaders.length != 1) {
@@ -142,9 +151,13 @@ protected void sendResponseMessage(HttpResponse response) throws IOException {
         }
         Header contentTypeHeader = contentTypeHeaders[0];
         boolean foundAllowedContentType = false;
-        for (String anAllowedContentType : mAllowedContentTypes) {
-            if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
-                foundAllowedContentType = true;
+        for (String anAllowedContentType : getAllowedContentTypes()) {
+            try {
+                if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
+                    foundAllowedContentType = true;
+                }
+            } catch (PatternSyntaxException e) {
+                Log.e("BinaryHttpResponseHandler", "Given pattern is not valid: " + anAllowedContentType, e);
             }
         }
         if (!foundAllowedContentType) {
@@ -152,6 +165,6 @@ protected void sendResponseMessage(HttpResponse response) throws IOException {
             sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
             return;
         }
-        super.sendResponseMessage( response );
+        super.sendResponseMessage(response);
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..51177c93
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,108 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private File mFile;
+    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
+
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        assert (file != null);
+        this.mFile = file;
+    }
+
+    public FileAsyncHttpResponseHandler(Context c) {
+        super();
+        assert (c != null);
+        this.mFile = getTemporaryFile(c);
+    }
+
+    protected File getTemporaryFile(Context c) {
+        try {
+            return File.createTempFile("temp_", "_handled", c.getCacheDir());
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "Cannot create temporary file", t);
+        }
+        return null;
+    }
+
+    protected File getTargetFile() {
+        assert (mFile != null);
+        return mFile;
+    }
+
+    public void onSuccess(File file) {
+    }
+
+    public void onSuccess(int statusCode, File file) {
+        onSuccess(file);
+    }
+
+    public void onSuccess(int statusCode, Header[] headers, File file) {
+        onSuccess(statusCode, file);
+    }
+
+    public void onFailure(Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e, response);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(statusCode, e, response);
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        onFailure(statusCode, headers, error, getTargetFile());
+    }
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, headers, getTargetFile());
+    }
+
+    @Override
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength();
+            FileOutputStream buffer = new FileOutputStream(getTargetFile());
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l, count = 0;
+                    // do not send messages if request has been cancelled
+                    while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        count += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage(count, (int) contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
+
+}
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
similarity index 78%
rename from library/src/com/loopj/android/http/JsonHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index f6191607..d48ded5d 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -27,30 +27,35 @@
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
-import java.io.UnsupportedEncodingException;
-
 /**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
- * or {@link JSONArray}.
- * <p>&nbsp;</p>
- * This class is designed to be passed to get, post, put and delete requests
- * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
- * methods anonymously overridden.
- * <p>&nbsp;</p>
- * Additionally, you can override the other event methods from the
- * parent class.
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
+ * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
+ * designed to be passed to get, post, put and delete requests with the {@link
+ * #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)} methods anonymously overridden.
+ * <p>&nbsp;</p> Additionally, you can override the other event methods from the parent class.
  */
-public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
+public class JsonHttpResponseHandler extends TextHttpResponseHandler {
     private static final String LOG_TAG = "JsonHttpResponseHandler";
+
+    /**
+     * Creates a new JsonHttpResponseHandler
+     */
+
+    public JsonHttpResponseHandler() {
+        super(DEFAULT_CHARSET);
+    }
+
+    public JsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
+
     //
     // Callbacks to be overridden, typically anonymously
     //
 
     /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json object at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param response the parsed json object found in the server response (if any)
      */
@@ -59,9 +64,8 @@ public void onSuccess(JSONObject response) {
 
 
     /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json array at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param response the parsed json array found in the server response (if any)
      */
@@ -69,9 +73,8 @@ public void onSuccess(JSONArray response) {
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json object at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param statusCode the status code of the response
      * @param headers    the headers of the HTTP response
@@ -82,9 +85,8 @@ public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json object at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param statusCode the status code of the response
      * @param response   the parsed json object found in the server response (if any)
@@ -94,9 +96,8 @@ public void onSuccess(int statusCode, JSONObject response) {
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json array at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param statusCode the status code of the response
      * @param headers    the headers of the HTTP response
@@ -107,9 +108,8 @@ public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
+     * Fired when a request returns successfully and contains a json array at the base of the
+     * response string. Override to handle in your own code.
      *
      * @param statusCode the status code of the response
      * @param response   the parsed json array found in the server response (if any)
@@ -143,7 +143,7 @@ public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray e
     }
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBody) {
+    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
@@ -181,7 +181,7 @@ public void run() {
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final byte[] responseBody, final Throwable e) {
+    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
         if (responseBody != null) {
             new Thread(new Runnable() {
                 @Override
@@ -207,7 +207,7 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(ex, (JSONObject) null);
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
                             }
                         });
 
@@ -216,26 +216,21 @@ public void run() {
             }).start();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
-            onFailure(e, (JSONObject) null);
+            onFailure(statusCode, headers, e, (JSONObject) null);
         }
     }
 
-    protected Object parseResponse(byte[] responseBody) throws JSONException {
+    protected Object parseResponse(String responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
-        try {
-            //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-            String jsonString = new String(responseBody, "UTF-8").trim();
-            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-                result = new JSONTokener(jsonString).nextValue();
-            }
-            if (result == null) {
-                result = jsonString;
-            }
-        } catch (UnsupportedEncodingException ex) {
-            Log.v(LOG_TAG, "JSON parsing failed, calling onFailure(Throwable, JSONObject)");
-            onFailure(ex, (JSONObject) null);
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        String jsonString = responseBody.trim();
+        if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+            result = new JSONTokener(jsonString).nextValue();
+        }
+        if (result == null) {
+            result = jsonString;
         }
         return result;
     }
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
similarity index 97%
rename from library/src/com/loopj/android/http/MySSLSocketFactory.java
rename to library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
index 86eeaab9..eb4aa97e 100644
--- a/library/src/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -15,8 +15,8 @@
 import javax.net.ssl.X509TrustManager;
 
 /**
- * This file is introduced to fix HTTPS Post bug on API &lt; ICS
- * see http://code.google.com/p/android/issues/detail?id=13117#c14
+ * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
+ * http://code.google.com/p/android/issues/detail?id=13117#c14
  */
 public class MySSLSocketFactory extends SSLSocketFactory {
     SSLContext sslContext = SSLContext.getInstance("TLS");
diff --git a/library/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
similarity index 95%
rename from library/src/com/loopj/android/http/PersistentCookieStore.java
rename to library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 218fc065..e28ec19f 100644
--- a/library/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -34,13 +34,10 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
- * A persistent cookie store which implements the Apache HttpClient
- * {@link CookieStore} interface. Cookies are stored and will persist on the
- * user's device between application sessions since they are serialized and
- * stored in {@link SharedPreferences}.
- * <p>&nbsp;</p>
- * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a
+ * A persistent cookie store which implements the Apache HttpClient {@link CookieStore} interface.
+ * Cookies are stored and will persist on the user's device between application sessions since they
+ * are serialized and stored in {@link SharedPreferences}. <p>&nbsp;</p> Instances of this class are
+ * designed to be used with {@link AsyncHttpClient#setCookieStore}, but can also be used with a
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
new file mode 100644
index 00000000..08cb7824
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -0,0 +1,52 @@
+package com.loopj.android.http;
+
+import java.util.concurrent.Future;
+
+/**
+ * A Handle to an AsyncRequest which can be used to cancel a running request.
+ */
+public class RequestHandle {
+    private final Future<?> request;
+
+    public RequestHandle(Future<?> request) {
+        this.request = request;
+    }
+
+    /**
+     * Attempts to cancel this request. This attempt will fail if the request has already completed,
+     * has already been cancelled, or could not be cancelled for some other reason. If successful,
+     * and this request has not started when cancel is called, this request should never run. If the
+     * request has already started, then the mayInterruptIfRunning parameter determines whether the
+     * thread executing this request should be interrupted in an attempt to stop the request.
+     * <p>&nbsp;</p> After this method returns, subsequent calls to isDone() will always return
+     * true. Subsequent calls to isCancelled() will always return true if this method returned
+     * true.
+     *
+     * @param mayInterruptIfRunning true if the thread executing this request should be interrupted;
+     *                              otherwise, in-progress requests are allowed to complete
+     * @return false if the request could not be cancelled, typically because it has already
+     * completed normally; true otherwise
+     */
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return this.request != null && request.cancel(mayInterruptIfRunning);
+    }
+
+    /**
+     * Returns true if this task completed. Completion may be due to normal termination, an
+     * exception, or cancellation -- in all of these cases, this method will return true.
+     *
+     * @return true if this task completed
+     */
+    public boolean isFinished() {
+        return this.request == null || request.isDone();
+    }
+
+    /**
+     * Returns true if this task was cancelled before it completed normally.
+     *
+     * @return true if this task was cancelled before it completed
+     */
+    public boolean isCancelled() {
+        return this.request != null && request.isCancelled();
+    }
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
similarity index 86%
rename from library/src/com/loopj/android/http/RequestParams.java
rename to library/src/main/java/com/loopj/android/http/RequestParams.java
index 05a6e3d8..229a9da4 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -30,6 +30,7 @@
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -38,11 +39,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
- * A collection of string request parameters or files to send along with
- * requests made from an {@link AsyncHttpClient} instance.
- * <p>&nbsp;</p>
- * For example:
- * <p>&nbsp;</p>
+ * A collection of string request parameters or files to send along with requests made from an
+ * {@link AsyncHttpClient} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * RequestParams params = new RequestParams();
  * params.put("username", "james");
@@ -51,35 +49,35 @@
  * params.put("profile_picture", new File("pic.jpg")); // Upload a File
  * params.put("profile_picture2", someInputStream); // Upload an InputStream
  * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- * 
- * Map<String, String> map = new HashMap<String, String>();
+ *
+ * Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
  * map.put("first_name", "James");
  * map.put("last_name", "Smith");
- * params.put("user", map); // url params: "user[first_name]=James&user[last_name]=Smith"
+ * params.put("user", map); // url params: "user[first_name]=James&amp;user[last_name]=Smith"
  *
- * Set<String> set = new HashSet<String>(); // unordered collection
+ * Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // unordered collection
  * set.add("music");
  * set.add("art");
- * params.put("like", set); // url params: "like=music&like=art"
- * 
- * List<String> list = new ArrayList<String>(); // Ordered collection
+ * params.put("like", set); // url params: "like=music&amp;like=art"
+ *
+ * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
  * list.add("Java");
  * list.add("C");
- * params.put("languages", list); // url params: "languages[]=Java&languages[]=C"
- * 
+ * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
+ *
  * String[] colors = { "blue", "yellow" }; // Ordered collection
- * params.put("colors", colors); // url params: "colors[]=blue&colors[]=yellow"
- * 
- * List<Map<String, String>> listOfMaps = new ArrayList<Map<String, String>>();
- * Map<String, String> user1 = new HashMap<String, String>();
+ * params.put("colors", colors); // url params: "colors[]=blue&amp;colors[]=yellow"
+ *
+ * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
+ * Map&lt;String, String&gt; user1 = new HashMap&lt;String, String&gt;();
  * user1.put("age", "30");
  * user1.put("gender", "male");
- * Map<String, String> user2 = new HashMap<String, String>();
+ * Map&lt;String, String&gt; user2 = new HashMap&lt;String, String&gt;();
  * user2.put("age", "25");
  * user2.put("gender", "female");
  * listOfMaps.add(user1);
  * listOfMaps.add(user2);
- * params.put("users", listOfMaps); // url params: "users[][age]=30&users[][gender]=male&users[][age]=25&users[][gender]=female"
+ * params.put("users", listOfMaps); // url params: "users[][age]=30&amp;users[][gender]=male&amp;users[][age]=25&amp;users[][gender]=female"
  *
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.post("http://myendpoint.com", params, responseHandler);
@@ -87,53 +85,53 @@
  */
 public class RequestParams {
 
-    private static final String LOG_TAG = "RequestParams";
-
+    protected boolean isRepeatable = false;
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
     protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
 
     /**
-     * Constructs a new empty <code>RequestParams</code> instance.
+     * Constructs a new empty {@code RequestParams} instance.
      */
     public RequestParams() {
-        init();
+        this((Map<String, String>) null);
     }
 
     /**
-     * Constructs a new RequestParams instance containing the key/value
-     * string params from the specified map.
+     * Constructs a new RequestParams instance containing the key/value string params from the
+     * specified map.
      *
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
         init();
-
-        for (Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
+        if (source != null) {
+            for (Map.Entry<String, String> entry : source.entrySet()) {
+                put(entry.getKey(), entry.getValue());
+            }
         }
     }
 
     /**
-     * Constructs a new RequestParams instance and populate it with a single
-     * initial key/value string param.
+     * Constructs a new RequestParams instance and populate it with a single initial key/value
+     * string param.
      *
      * @param key   the key name for the intial param.
      * @param value the value string for the initial param.
      */
-    public RequestParams(String key, String value) {
-        init();
-
-        put(key, value);
+    public RequestParams(final String key, final String value) {
+        this(new HashMap<String, String>() {{
+            put(key, value);
+        }});
     }
 
     /**
-     * Constructs a new RequestParams instance and populate it with multiple
-     * initial key/value string param.
+     * Constructs a new RequestParams instance and populate it with multiple initial key/value
+     * string param.
      *
-     * @param keysAndValues a sequence of keys and values. Objects are
-     *                      automatically converted to Strings (including the value {@code null}).
+     * @param keysAndValues a sequence of keys and values. Objects are automatically converted to
+     *                      Strings (including the value {@code null}).
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
@@ -222,17 +220,19 @@ public void put(String key, InputStream stream, String name, String contentType)
 
     /**
      * Adds param with non-string value (e.g. Map, List, Set).
+     *
      * @param key   the key name for the new param.
      * @param value the non-string value object for the new param.
      */
-    public void put(String key, Object value)  {
+    public void put(String key, Object value) {
         if (key != null && value != null) {
             urlParamsWithObjects.put(key, value);
         }
     }
-            
+
     /**
      * Adds string value to param which can have more than one value.
+     *
      * @param key   the key name for the param, either existing or new.
      * @param value the value string for the new param.
      */
@@ -251,7 +251,7 @@ public void add(String key, String value) {
             }
         }
     }
-    
+
     /**
      * Removes a parameter from the request.
      *
@@ -298,7 +298,7 @@ public String toString() {
         for (BasicNameValuePair kv : params) {
             if (result.length() > 0)
                 result.append("&");
-            
+
             result.append(kv.getName());
             result.append("=");
             result.append(kv.getValue());
@@ -307,14 +307,19 @@ public String toString() {
         return result.toString();
     }
 
+    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
+        this.isRepeatable = isRepeatable;
+    }
+
     /**
      * Returns an HttpEntity containing all request parameters
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
-     * @return HttpEntity resulting HttpEntity to be included along with {@link org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
+     * @return HttpEntity resulting HttpEntity to be included along with {@link
+     * org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
      * @throws IOException if one of the streams cannot be read
      */
-    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+    public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
         if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
@@ -330,8 +335,9 @@ private HttpEntity createFormEntity() {
         }
     }
 
-    private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+    private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandler) throws IOException {
         SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
+        entity.setIsRepeatable(isRepeatable);
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -341,7 +347,7 @@ private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandle
         // Add non-string params
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
-        	entity.addPart(kv.getName(), kv.getValue());
+            entity.addPart(kv.getName(), kv.getValue());
         }
 
         // Add stream params
@@ -415,7 +421,7 @@ private void init() {
         }
         return params;
     }
-    
+
     protected String getParamString() {
         return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
new file mode 100644
index 00000000..06b2145b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -0,0 +1,98 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.net.URI;
+
+/**
+ * Interface to standardize implementations
+ */
+public interface ResponseHandlerInterface {
+
+    /**
+     * Returns data whether request completed successfully
+     *
+     * @param response HttpResponse object with data
+     * @throws java.io.IOException if retrieving data from response fails
+     */
+    void sendResponseMessage(HttpResponse response) throws IOException;
+
+    /**
+     * Notifies callback, that request started execution
+     */
+    void sendStartMessage();
+
+    /**
+     * Notifies callback, that request was completed and is being removed from thread pool
+     */
+    void sendFinishMessage();
+
+    /**
+     * Notifies callback, that request (mainly uploading) has progressed
+     *
+     * @param bytesWritten number of written bytes
+     * @param bytesTotal   number of total bytes to be written
+     */
+    void sendProgressMessage(int bytesWritten, int bytesTotal);
+
+    /**
+     * Notifies callback, that request was handled successfully
+     *
+     * @param statusCode   HTTP status code
+     * @param headers      returned headers
+     * @param responseBody returned data
+     */
+    void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody);
+
+    /**
+     * Returns if request was completed with error code or failure of implementation
+     *
+     * @param statusCode   returned HTTP status code
+     * @param headers      returned headers
+     * @param responseBody returned data
+     * @param error        cause of request failure
+     */
+    void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
+
+    /**
+     * Notifies callback of retrying request
+     */
+    void sendRetryMessage();
+
+    /**
+     * Returns URI which was used to request
+     *
+     * @return uri of origin request
+     */
+    public URI getRequestURI();
+
+    /**
+     * Returns Header[] which were used to request
+     *
+     * @return headers from origin request
+     */
+    public Header[] getRequestHeaders();
+
+    /**
+     * Helper for handlers to receive Request URI info
+     *
+     * @param requestURI claimed request URI
+     */
+    public void setRequestURI(URI requestURI);
+
+    /**
+     * Helper for handlers to receive Request Header[] info
+     *
+     * @param requestHeaders Headers, claimed to be from original request
+     */
+    public void setRequestHeaders(Header[] requestHeaders);
+
+    /**
+     * Can set, whether the handler should be asynchronous or synchronous
+     *
+     * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
+     */
+    void setUseSynchronousMode(boolean useSynchronousMode);
+}
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
similarity index 100%
rename from library/src/com/loopj/android/http/RetryHandler.java
rename to library/src/main/java/com/loopj/android/http/RetryHandler.java
diff --git a/library/src/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
similarity index 97%
rename from library/src/com/loopj/android/http/SerializableCookie.java
rename to library/src/main/java/com/loopj/android/http/SerializableCookie.java
index d9730d21..855105b1 100644
--- a/library/src/com/loopj/android/http/SerializableCookie.java
+++ b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
@@ -28,8 +28,8 @@
 import java.util.Date;
 
 /**
- * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
- * designed for use in {@link PersistentCookieStore}.
+ * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie} designed for use in {@link
+ * PersistentCookieStore}.
  */
 public class SerializableCookie implements Serializable {
     private static final long serialVersionUID = 6374381828722046732L;
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
similarity index 96%
rename from library/src/com/loopj/android/http/SimpleMultipartEntity.java
rename to library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index 4ae3add4..fcaf4d21 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -56,6 +56,7 @@
     private String boundary;
     private byte[] boundaryLine;
     private byte[] boundaryEnd;
+    private boolean isRepeatable = false;
 
     private List<FilePart> fileParts = new ArrayList<FilePart>();
 
@@ -63,13 +64,13 @@
     // boundary
     private ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    private AsyncHttpResponseHandler progressHandler;
+    private ResponseHandlerInterface progressHandler;
 
     private int bytesWritten;
 
     private int totalSize;
 
-    public SimpleMultipartEntity(AsyncHttpResponseHandler progressHandler) {
+    public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         final StringBuilder buf = new StringBuilder();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
@@ -242,9 +243,13 @@ public boolean isChunked() {
         return false;
     }
 
+    public void setIsRepeatable(boolean isRepeatable) {
+        this.isRepeatable = isRepeatable;
+    }
+
     @Override
     public boolean isRepeatable() {
-        return false;
+        return isRepeatable;
     }
 
     @Override
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
similarity index 79%
rename from library/src/com/loopj/android/http/SyncHttpClient.java
rename to library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index fbaae7ab..22466edd 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -1,6 +1,7 @@
 package com.loopj.android.http;
 
 import android.content.Context;
+
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.impl.client.DefaultHttpClient;
@@ -55,10 +56,10 @@ public SyncHttpClient(SchemeRegistry schemeRegistry) {
     }
 
     @Override
-    protected void sendRequest(DefaultHttpClient client,
-                               HttpContext httpContext, HttpUriRequest uriRequest,
-                               String contentType, AsyncHttpResponseHandler responseHandler,
-                               Context context) {
+    protected RequestHandle sendRequest(DefaultHttpClient client,
+                                        HttpContext httpContext, HttpUriRequest uriRequest,
+                                        String contentType, ResponseHandlerInterface responseHandler,
+                                        Context context) {
         if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
         }
@@ -69,5 +70,9 @@ protected void sendRequest(DefaultHttpClient client,
          * will execute the request directly
 		*/
         new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+
+        // Return a Request Handle that cannot be used to cancel the request
+        // because it is already complete by the time this returns
+        return new RequestHandle(null);
     }
 }
diff --git a/library/src/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
similarity index 65%
rename from library/src/com/loopj/android/http/TextHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
index f99ba1d6..c476814d 100644
--- a/library/src/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -1,19 +1,17 @@
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.Header;
 
 import java.io.UnsupportedEncodingException;
 
 /**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
- * designed to be anonymously overridden with your own response handling code.
- * <p/>
- * Additionally, you can override the {@link #onFailure(String, Throwable)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p/>
- * For example:
- * <p/>
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(String)} method is designed to be anonymously overridden with your own response
+ * handling code. <p>&nbsp;</p> Additionally, you can override the {@link #onFailure(String,
+ * Throwable)}, {@link #onStart()}, and {@link #onFinish()} methods as required. <p>&nbsp;</p> For
+ * example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new TextHttpResponseHandler() {
@@ -40,6 +38,7 @@
  * </pre>
  */
 public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "TextHttpResponseHandler";
 
     /**
      * Creates a new TextHttpResponseHandler
@@ -59,8 +58,7 @@ public TextHttpResponseHandler(String encoding) {
     //
 
     /**
-     * Fired when a request fails to complete, override to handle in your own
-     * code
+     * Fired when a request fails to complete, override to handle in your own code
      *
      * @param responseBody the response body, if any
      * @param error        the underlying cause of the failure
@@ -69,8 +67,7 @@ public void onFailure(String responseBody, Throwable error) {
     }
 
     /**
-     * Fired when a request fails to complete, override to handle in your own
-     * code
+     * Fired when a request fails to complete, override to handle in your own code
      *
      * @param statusCode   the status code of the response
      * @param headers      HTTP response headers
@@ -82,23 +79,24 @@ public void onFailure(int statusCode, Header[] headers, String responseBody, Thr
     }
 
     /**
-     * Fired when a request returns successfully, override to handle in your own
-     * code
+     * Fired when a request returns successfully, override to handle in your own code
      *
-     * @param statusCode the status code of the response
-     * @param headers HTTP response headers
+     * @param statusCode   the status code of the response
+     * @param headers      HTTP response headers
      * @param responseBody the body of the HTTP response from the server
      */
     @Override
     public void onSuccess(int statusCode, Header[] headers, String responseBody) {
-        onSuccess( statusCode, responseBody );
+        onSuccess(statusCode, responseBody);
     }
 
     @Override
     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
         try {
-            onSuccess(statusCode, headers, new String(responseBody, getCharset()));
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onSuccess(statusCode, headers, response);
         } catch (UnsupportedEncodingException e) {
+            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
             onFailure(0, headers, (String) null, e);
         }
     }
@@ -106,9 +104,11 @@ public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
     @Override
     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
         try {
-            onFailure(statusCode, headers, new String(responseBody, getCharset()), error);
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onFailure(statusCode, headers, response, error);
         } catch (UnsupportedEncodingException e) {
-            onFailure(0, headers, (String) null, e);
+            Log.e(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)", e);
+            onFailure(0, headers, (String) null, error);
         }
     }
 
diff --git a/maven_push.gradle b/maven_push.gradle
index 1c7ec711..6fc6fb30 100644
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -82,11 +82,7 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidReleaseJar(type: Jar, dependsOn: assembleRelease) {
-        from "$buildDir/classes/release/"
-    }
-
-    task androidJavadocsJar(type: Jar) {
+    task androidJavadocsJar(type: Jar, dependsOn: generateReleaseJavadoc) {
         classifier = 'javadoc'
         from generateReleaseJavadoc.destinationDir
     }
diff --git a/releases/android-async-http-1.4.4.jar b/releases/android-async-http-1.4.4.jar
new file mode 100644
index 00000000..75af7015
Binary files /dev/null and b/releases/android-async-http-1.4.4.jar differ
diff --git a/sample/build.gradle b/sample/build.gradle
index 20fdcb60..0792285e 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -16,15 +16,16 @@ repositories {
 }
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion "18.0.1"
+    compileSdkVersion 19
+    buildToolsVersion '19.0.0'
 
     defaultConfig {
         minSdkVersion 3
-        targetSdkVersion 18
+        targetSdkVersion 19
     }
 }
 
 dependencies {
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
     compile project(':library')
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 8ad41e76..3e0a2fa8 100644
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
     android:versionCode="1"
     android:versionName="1.0">
 
-    <permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
     <uses-sdk
         android:minSdkVersion="3"
@@ -14,12 +14,19 @@
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
-        <activity android:name="com.loopj.android.http.sample.MainActivity">
+        <activity android:name=".WaypointsActivity">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+        <activity android:name=".GetSample" />
+        <activity android:name=".PostSample" />
+        <activity android:name=".DeleteSample" />
+        <activity android:name=".PutSample" />
+        <activity android:name=".JsonSample" />
+        <activity android:name=".FileSample" />
+        <activity android:name=".BinarySample" />
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
new file mode 100644
index 00000000..e134a1b6
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -0,0 +1,69 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.BinaryHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class BinarySample extends SampleParentActivity {
+    private static final String LOG_TAG = "BinarySample";
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_binary_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new BinaryHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public String[] getAllowedContentTypes() {
+                // Allowing all data for debug purposes
+                return new String[]{".*"};
+            }
+
+            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
+                }
+            }
+        };
+    }
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
new file mode 100644
index 00000000..42104356
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -0,0 +1,65 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class DeleteSample extends SampleParentActivity {
+    private static final String LOG_TAG = "DeleteSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.delete(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_delete_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/delete";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
new file mode 100644
index 00000000..46912aaa
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -0,0 +1,82 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.sample.util.FileUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+
+public class FileSample extends SampleParentActivity {
+    private static final String LOG_TAG = "FileSample";
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_file_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "https://httpbin.org/robots.txt";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new FileAsyncHttpResponseHandler(this) {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugFile(getTargetFile());
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                debugFile(getTargetFile());
+            }
+
+            private void debugFile(File file) {
+                if (file == null || !file.exists()) {
+                    debugResponse(LOG_TAG, "Response is null");
+                    return;
+                }
+                try {
+                    debugResponse(LOG_TAG, file.getAbsolutePath() + "\r\n\r\n" + FileUtil.getStringFromFile(file));
+                } catch (Throwable t) {
+                    Log.e(LOG_TAG, "Cannot debug file contents", t);
+                }
+                if (!file.delete()) {
+                    Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
+                }
+            }
+        };
+    }
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
new file mode 100644
index 00000000..96ab3e64
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -0,0 +1,64 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class GetSample extends SampleParentActivity {
+    private static final String LOG_TAG = "GetSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_get_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
new file mode 100644
index 00000000..154804f8
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -0,0 +1,76 @@
+package com.loopj.android.http.sample;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class JsonSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "JsonSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_json_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/headers";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable e, String rawResponse, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawResponse);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String responseBody) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(responseBody), SampleJSON.class).next();
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
deleted file mode 100644
index 62571c72..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
+++ /dev/null
@@ -1,161 +0,0 @@
-package com.loopj.android.http.sample;
-
-import android.app.Activity;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.View;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.TextHttpResponseHandler;
-
-import org.apache.http.Header;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.net.URI;
-
-public class MainActivity extends Activity implements View.OnClickListener {
-
-    private AsyncHttpClient aclient = new AsyncHttpClient(false, 80, 443);
-    private TextView statusCode, headers, contents, state, error;
-    private EditText url;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-        Button get = (Button) findViewById(R.id.request_get);
-        statusCode = (TextView) findViewById(R.id.return_code);
-        headers = (TextView) findViewById(R.id.return_headers);
-        contents = (TextView) findViewById(R.id.return_data);
-        state = (TextView) findViewById(R.id.current_state);
-        error = (TextView) findViewById(R.id.return_error);
-        url = (EditText) findViewById(R.id.request_url);
-
-        get.setOnClickListener(this);
-    }
-
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.main, menu);
-        return true;
-    }
-
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.request_get:
-                if (verifyUrl()) {
-                    startRequest();
-                }
-                break;
-        }
-    }
-
-    private void startRequest() {
-        aclient.get(this, getURLString(), new TextHttpResponseHandler() {
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, String responseBody) {
-                setStatusMessage("Succeeded", Color.parseColor("#DD00FF00"));
-                printThrowable(null);
-                printHeaders(headers);
-                printContents(responseBody);
-                printStatusCode(statusCode);
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
-                setStatusMessage("Failed", Color.parseColor("#99FF0000"));
-                printThrowable(error);
-                printHeaders(headers);
-                printContents(responseBody);
-                printStatusCode(statusCode);
-            }
-
-            @Override
-            public void onStart() {
-                setStatusMessage("Started", Color.parseColor("#EE00FF00"));
-            }
-
-            @Override
-            public void onFinish() {
-                setStatusMessage("Finished", 0);
-            }
-        });
-    }
-
-    private void printThrowable(Throwable error) {
-        if (this.error != null) {
-            if (error != null) {
-                StringWriter sw = new StringWriter();
-                error.printStackTrace(new PrintWriter(sw));
-                this.error.setText(sw.toString());
-            } else {
-                this.error.setText(null);
-            }
-        }
-    }
-
-    private void printStatusCode(int statusCode) {
-        if (this.statusCode != null) {
-            this.statusCode.setText(String.format("HTTP Status Code: %d", statusCode));
-        }
-    }
-
-    private void printContents(String content) {
-        if (this.contents != null) {
-            if (content == null)
-                contents.setText("Return is NULL");
-            else
-                contents.setText(content);
-        }
-    }
-
-    private void printHeaders(Header[] headers) {
-        if (this.headers != null) {
-            StringBuilder sb = new StringBuilder();
-            sb.append("Headers:");
-            if (headers != null) {
-                for (Header h : headers) {
-                    sb.append("\n").append(h.getName()).append(": ").append(h.getValue());
-                }
-            }
-            this.headers.setText(sb.toString());
-        }
-    }
-
-    private void setStatusMessage(String message, int color) {
-        if (state != null) {
-            state.setText(String.format("Status: %s", message));
-            if (color != 0)
-                state.setBackgroundColor(color);
-        }
-    }
-
-    private String getURLString() {
-        return url.getText() != null ? url.getText().toString() : null;
-    }
-
-    private boolean verifyUrl() {
-        String contents = getURLString();
-        if (contents != null) {
-            try {
-                URI.create(contents);
-                return true;
-            } catch (Throwable t) {
-                Toast.makeText(this, "Given URL is not valid", Toast.LENGTH_SHORT).show();
-                t.printStackTrace();
-                return false;
-            }
-        }
-        Toast.makeText(this, "You must fill in URL", Toast.LENGTH_SHORT).show();
-        return false;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
new file mode 100644
index 00000000..8ecad2b0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -0,0 +1,67 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+public class PostSample extends SampleParentActivity {
+    private static final String LOG_TAG = "PostSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        headers = new Header[]{ new BasicHeader("Content-Type", "ee") };
+        client.post(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_post_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/post";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
+
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
new file mode 100644
index 00000000..f9e6b5dc
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -0,0 +1,65 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class PutSample extends SampleParentActivity {
+    private static final String LOG_TAG = "PutSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.put(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_put_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/put";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
new file mode 100644
index 00000000..eae9011b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -0,0 +1,189 @@
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class SampleParentActivity extends Activity {
+
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+    private EditText urlEditText, headersEditText, bodyEditText;
+    private LinearLayout responseLayout;
+
+    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    private static final int LIGHTRED = Color.parseColor("#FF3300");
+    private static final int YELLOW = Color.parseColor("#FFFF00");
+    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.parent_layout);
+        setTitle(getSampleTitle());
+
+        urlEditText = (EditText) findViewById(R.id.edit_url);
+        headersEditText = (EditText) findViewById(R.id.edit_headers);
+        bodyEditText = (EditText) findViewById(R.id.edit_body);
+        Button runButton = (Button) findViewById(R.id.button_run);
+        LinearLayout headersLayout = (LinearLayout) findViewById(R.id.layout_headers);
+        LinearLayout bodyLayout = (LinearLayout) findViewById(R.id.layout_body);
+        responseLayout = (LinearLayout) findViewById(R.id.layout_response);
+
+        urlEditText.setText(getDefaultURL());
+
+        bodyLayout.setVisibility(isRequestBodyAllowed() ? View.VISIBLE : View.GONE);
+        headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
+
+        runButton.setOnClickListener(onClickListener);
+    }
+
+    private View.OnClickListener onClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            switch (v.getId()) {
+                case R.id.button_run:
+                    executeSample(getAsyncHttpClient(),
+                            (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
+                            getRequestHeaders(),
+                            getRequestEntity(),
+                            getResponseHandler());
+                    break;
+            }
+        }
+    };
+
+    protected Header[] getRequestHeaders() {
+        List<Header> headers = new ArrayList<Header>();
+        String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
+
+        if (headersRaw != null && headersRaw.length() > 3) {
+            String[] lines = headersRaw.split("\\r?\\n");
+            for (String line : lines) {
+                try {
+                    String[] kv = line.split("=");
+                    if (kv.length != 2)
+                        throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
+                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                } catch (Throwable t) {
+                    Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
+                }
+            }
+        }
+        return headers.toArray(new Header[headers.size()]);
+    }
+
+    protected HttpEntity getRequestEntity() {
+        if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
+            try {
+                return new StringEntity(bodyEditText.getText().toString());
+            } catch (UnsupportedEncodingException e) {
+                Log.e("SampleParentActivity", "cannot create String entity", e);
+            }
+        }
+        return null;
+    }
+
+    protected final void debugHeaders(String TAG, Header[] headers) {
+        if (headers != null) {
+            Log.d(TAG, "Return Headers:");
+            StringBuilder builder = new StringBuilder();
+            for (Header h : headers) {
+                String _h = String.format("%s : %s", h.getName(), h.getValue());
+                Log.d(TAG, _h);
+                builder.append(_h);
+                builder.append("\n");
+            }
+            addView(getColoredView(YELLOW, builder.toString()));
+        }
+    }
+
+    protected static String throwableToString(Throwable t) {
+        if (t == null)
+            return null;
+
+        StringWriter sw = new StringWriter();
+        t.printStackTrace(new PrintWriter(sw));
+        return sw.toString();
+    }
+
+    protected final void debugThrowable(String TAG, Throwable t) {
+        if (t != null) {
+            Log.e(TAG, "AsyncHttpClient returned error", t);
+            addView(getColoredView(LIGHTRED, throwableToString(t)));
+        }
+    }
+
+    protected final void debugResponse(String TAG, String response) {
+        if (response != null) {
+            Log.d(TAG, "Response data:");
+            Log.d(TAG, response);
+            addView(getColoredView(LIGHTGREEN, response));
+        }
+    }
+
+    protected final void debugStatusCode(String TAG, int statusCode) {
+        String msg = String.format("Return Status Code: %d", statusCode);
+        Log.d(TAG, msg);
+        addView(getColoredView(LIGHTBLUE, msg));
+    }
+
+    public static int getContrastColor(int color) {
+        double y = (299 * Color.red(color) + 587 * Color.green(color) + 114 * Color.blue(color)) / 1000;
+        return y >= 128 ? Color.BLACK : Color.WHITE;
+    }
+
+    private View getColoredView(int bgColor, String msg) {
+        TextView tv = new TextView(this);
+        tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        tv.setText(msg);
+        tv.setBackgroundColor(bgColor);
+        tv.setPadding(10, 10, 10, 10);
+        tv.setTextColor(getContrastColor(bgColor));
+        return tv;
+    }
+
+    protected final void addView(View v) {
+        responseLayout.addView(v);
+    }
+
+    protected final void clearOutputs() {
+        responseLayout.removeAllViews();
+    }
+
+    protected abstract int getSampleTitle();
+
+    protected abstract boolean isRequestBodyAllowed();
+
+    protected abstract boolean isRequestHeadersAllowed();
+
+    protected abstract String getDefaultURL();
+
+    protected abstract AsyncHttpResponseHandler getResponseHandler();
+
+    protected AsyncHttpClient getAsyncHttpClient() {
+        return this.asyncHttpClient;
+    }
+
+    protected abstract void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler);
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
new file mode 100644
index 00000000..736c5424
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -0,0 +1,50 @@
+package com.loopj.android.http.sample;
+
+import android.app.ListActivity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+public class WaypointsActivity extends ListActivity {
+
+    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY"};
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+    }
+
+    @Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        Class<?> targetClass;
+        switch (position) {
+            case 0:
+            default:
+                targetClass = GetSample.class;
+                break;
+            case 1:
+                targetClass = PostSample.class;
+                break;
+            case 2:
+                targetClass = DeleteSample.class;
+                break;
+            case 3:
+                targetClass = PutSample.class;
+                break;
+            case 4:
+                targetClass = JsonSample.class;
+                break;
+            case 5:
+                targetClass = FileSample.class;
+                break;
+            case 6:
+                targetClass = BinarySample.class;
+                break;
+        }
+        if (targetClass != null)
+            startActivity(new Intent(this, targetClass));
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
new file mode 100644
index 00000000..2d9d5dda
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -0,0 +1,30 @@
+package com.loopj.android.http.sample.util;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+// Source: http://stackoverflow.com/questions/12910503/android-read-file-as-string
+public class FileUtil {
+
+    public static String convertStreamToString(InputStream is) throws Exception {
+        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+        StringBuilder sb = new StringBuilder();
+        String line = null;
+        while ((line = reader.readLine()) != null) {
+            sb.append(line).append("\n");
+        }
+        return sb.toString();
+    }
+
+    public static String getStringFromFile(File file) throws Exception {
+        FileInputStream fin = new FileInputStream(file);
+        String ret = convertStreamToString(fin);
+        //Make sure you close all streams.
+        fin.close();
+        return ret;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
new file mode 100644
index 00000000..e12c30fc
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -0,0 +1,59 @@
+package com.loopj.android.http.sample.util;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class SampleJSON {
+
+    private String Accept;
+    private String Referer;
+    private String AcceptLanguage;
+    private String Connection;
+    private String UserAgent;
+
+    public String getAccept() {
+        return Accept;
+    }
+
+    @JsonProperty("Accept")
+    public void setAccept(String accept) {
+        Accept = accept;
+    }
+
+    public String getReferer() {
+        return Referer;
+    }
+
+    @JsonProperty("Referer")
+    public void setReferer(String referer) {
+        Referer = referer;
+    }
+
+    public String getAcceptLanguage() {
+        return AcceptLanguage;
+    }
+
+    @JsonProperty("Accept-Language")
+    public void setAcceptLanguage(String acceptLanguage) {
+        AcceptLanguage = acceptLanguage;
+    }
+
+    public String getConnection() {
+        return Connection;
+    }
+
+    @JsonProperty("Connection")
+    public void setConnection(String connection) {
+        Connection = connection;
+    }
+
+    public String getUserAgent() {
+        return UserAgent;
+    }
+
+    @JsonProperty("User-Agent")
+    public void setUserAgent(String userAgent) {
+        UserAgent = userAgent;
+    }
+}
diff --git a/sample/src/main/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
deleted file mode 100644
index 7d92ae61..00000000
--- a/sample/src/main/res/layout/activity_main.xml
+++ /dev/null
@@ -1,75 +0,0 @@
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical"
-        tools:context=".MainActivity">
-
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal">
-
-            <EditText
-                android:id="@+id/request_url"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:inputType="textUri"
-                android:saveEnabled="true"
-                android:text="@string/default_url" />
-
-            <Button
-                android:id="@+id/request_get"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="@string/action_get" />
-
-        </LinearLayout>
-
-        <TextView
-            android:id="@+id/current_state"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#33000000"
-            android:padding="5dip"
-            android:text="@string/status_n_a" />
-
-        <TextView
-            android:id="@+id/return_code"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#11000000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_headers"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#33000000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_error"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#99FF0000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_data"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#11000000"
-            android:padding="5dip" />
-
-    </LinearLayout>
-</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
new file mode 100644
index 00000000..a7ad216e
--- /dev/null
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:fillViewport="true">
+
+    <LinearLayout
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <requestFocus />
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <EditText
+                android:id="@+id/edit_url"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:inputType="textUri" />
+
+            <Button
+                android:id="@+id/button_run"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Run" />
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Headers (key=val, one per line)" />
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false" />
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Request body" />
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false" />
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical" />
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/menu/main.xml b/sample/src/main/res/menu/main.xml
deleted file mode 100644
index f3b10b6c..00000000
--- a/sample/src/main/res/menu/main.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:id="@+id/action_settings"
-        android:title="@string/action_settings"
-        android:orderInCategory="100"
-        android:showAsAction="never" />
-</menu>
diff --git a/sample/src/main/res/values-sw600dp/dimens.xml b/sample/src/main/res/values-sw600dp/dimens.xml
deleted file mode 100644
index 886b05fa..00000000
--- a/sample/src/main/res/values-sw600dp/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<resources>
-    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
-         screen margins) for sw600dp devices (e.g. 7" tablets) here. -->
-</resources>
diff --git a/sample/src/main/res/values-sw720dp-land/dimens.xml b/sample/src/main/res/values-sw720dp-land/dimens.xml
deleted file mode 100644
index 00059fc5..00000000
--- a/sample/src/main/res/values-sw720dp-land/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
-         screen margins) for sw720dp devices (e.g. 10" tablets) in landscape here. -->
-    <dimen name="activity_horizontal_margin">128dp</dimen>
-</resources>
diff --git a/sample/src/main/res/values/dimens.xml b/sample/src/main/res/values/dimens.xml
deleted file mode 100644
index 47c82246..00000000
--- a/sample/src/main/res/values/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
-</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 86fe3bbb..b8d68899 100644
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -1,10 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 
-    <string name="app_name">Android Async Http Sample</string>
-    <string name="action_settings">Settings</string>
-    <string name="default_url">https://raw.github.com/loopj/android-async-http/master/README.md</string>
-    <string name="action_get">GET</string>
-    <string name="status_n_a">Not Yet Started</string>
-
+    <string name="app_name">Android Async Http Samples</string>
+    <string name="title_get_sample">GET</string>
+    <string name="title_json_sample">GET and JSON parse</string>
+    <string name="title_post_sample">POST</string>
+    <string name="title_put_sample">PUT</string>
+    <string name="title_delete_sample">DELETE</string>
+    <string name="title_file_sample">GET to File</string>
+    <string name="title_binary_sample">GET binary data</string>
 </resources>
