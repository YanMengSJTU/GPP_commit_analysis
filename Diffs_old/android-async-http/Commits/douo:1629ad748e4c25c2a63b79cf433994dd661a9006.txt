diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 5f0750d7..af956321 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -18,18 +18,7 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.zip.GZIPInputStream;
+import android.content.Context;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
@@ -67,7 +56,18 @@
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
-import android.content.Context;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
 
 
 /**
@@ -389,7 +389,7 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
+        post(context, url, null, params, null, responseHandler);
     }
 
     /**
@@ -420,7 +420,13 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
             AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
+        if (params != null) {
+            try {
+                request.setEntity(paramsToEntity(params));
+            } catch (IOException e) {
+                responseHandler.onFailure(e, null);
+            }
+        }
         if(headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
@@ -479,7 +485,11 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
+        try {
+            put(context, url, paramsToEntity(params), null, responseHandler);
+        } catch (IOException e) {
+            responseHandler.onFailure(e, null);
+        }
     }
 
     /**
@@ -584,7 +594,7 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
-    private HttpEntity paramsToEntity(RequestParams params) {
+    private HttpEntity paramsToEntity(RequestParams params) throws IOException {
         HttpEntity entity = null;
 
         if(params != null) {
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index 02bcf8a7..68561cda 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -25,8 +25,8 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
@@ -56,7 +56,10 @@
  */
 public class RequestParams {
 
+    private static final String TAG = "RequestParams";
+
     protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
     protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
 
@@ -128,7 +131,20 @@ public void put(String key, String value){
      * @param file the file to add.
      */
     public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
+        put(key, file, null);
+    }
+
+    /**
+     * Adds a file to the request.
+     * 
+     * @param key the key name for the new param.
+     * @param file the file to add.
+     * @param contentType the content type of the file, eg. application/json
+     */
+    public void put(String key, File file, String contentType) throws FileNotFoundException {
+        if (key != null && file != null) {
+            fileParams.put(key, new FileWrapper(file, contentType));
+        }
     }
 
     /**
@@ -155,22 +171,22 @@ public void put(String key, InputStream stream) {
      * Adds an input stream to the request.
      * @param key the key name for the new param.
      * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     * @param name the name of the stream.
      */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
+    public void put(String key, InputStream stream, String name) {
+        put(key, stream, name, null);
     }
 
     /**
      * Adds an input stream to the request.
      * @param key the key name for the new param.
      * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     * @param name the name of the stream.
      * @param contentType the content type of the file, eg. application/json
      */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
+    public void put(String key, InputStream stream, String name, String contentType) {
         if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+            streamParams.put(key, new StreamWrapper(stream, name, contentType));
         }
     }
 
@@ -180,6 +196,7 @@ public void put(String key, InputStream stream, String fileName, String contentT
      */
     public void remove(String key){
         urlParams.remove(key);
+        streamParams.remove(key);
         fileParams.remove(key);
         urlParamsWithArray.remove(key);
     }
@@ -196,10 +213,19 @@ public String toString() {
             result.append(entry.getValue());
         }
 
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
             if(result.length() > 0)
                 result.append("&");
 
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("STREAM");
+        }
+
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
             result.append(entry.getKey());
             result.append("=");
             result.append("FILE");
@@ -222,14 +248,16 @@ public String toString() {
         return result.toString();
     }
 
-   /**
+    /**
      * Returns an HttpEntity containing all request parameters
+     * 
+     * @throws IOException if one of the streams cannot be read
      */
-    public HttpEntity getEntity() {
-        if(!fileParams.isEmpty()) {
-            return createMultipartEntity();
-        } else {
+    public HttpEntity getEntity() throws IOException {
+        if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
+        } else {
+            return createMultipartEntity();
         }
     }
 
@@ -241,7 +269,7 @@ private HttpEntity createFormEntity() {
         }
     }
 
-    private HttpEntity createMultipartEntity() {
+    private HttpEntity createMultipartEntity() throws IOException {
         SimpleMultipartEntity entity = new SimpleMultipartEntity();
 
         // Add string params
@@ -258,18 +286,19 @@ private HttpEntity createMultipartEntity() {
             }
         }
 
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
+                        stream.contentType);
+            }
+        }
+
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper file = entry.getValue();
-            if (file.inputStream != null) {
-                if (file.contentType != null) {
-                    entity.addPart(entry.getKey(), file.getFileName(),
-                            file.inputStream, file.contentType);
-                } else {
-                    entity.addPart(entry.getKey(), file.getFileName(),
-                            file.inputStream);
-                }
-            }
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
         }
 
         return entity;
@@ -277,6 +306,7 @@ private HttpEntity createMultipartEntity() {
 
     private void init(){
         urlParams = new ConcurrentHashMap<String, String>();
+        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
         urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
     }
@@ -303,22 +333,24 @@ protected String getParamString() {
     }
 
     private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
+        public File file;
         public String contentType;
 
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
+        public FileWrapper(File file, String contentType) {
+            this.file = file;
             this.contentType = contentType;
         }
+    }
 
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
+    private static class StreamWrapper {
+        public InputStream inputStream;
+        public String name;
+        public String contentType;
+
+        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+            this.inputStream = inputStream;
+            this.name = name;
+            this.contentType = contentType;
         }
     }
 }
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index a9917807..80686f7b 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -23,6 +23,8 @@
 
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
@@ -30,10 +32,11 @@
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
 /**
@@ -41,6 +44,9 @@
  */
 class SimpleMultipartEntity implements HttpEntity {
 
+    private static final String TAG = "SimpleMultipartEntity";
+
+    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
     private static final byte[] CR_LF = ("\r\n").getBytes();
     private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
             .getBytes();
@@ -50,8 +56,11 @@
     private String boundary;
     private byte[] boundaryLine;
     private byte[] boundaryEnd;
+    
+    private List<FilePart> fileParts = new ArrayList<FilePart>();
 
-    // The buffer we use for building the message excluding the last boundary
+    // The buffer we use for building the message excluding files and the last
+    // boundary
     private ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     public SimpleMultipartEntity() {
@@ -62,7 +71,7 @@ public SimpleMultipartEntity() {
         }
         boundary = buf.toString();
         boundaryLine = ("--" + boundary + "\r\n").getBytes();
-        boundaryEnd = ("\r\n--" + boundary + "--\r\n").getBytes();
+        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
     }
 
     public void addPart(final String key, final String value) {
@@ -77,42 +86,47 @@ public void addPart(final String key, final String value) {
         }
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin) {
-        addPart(key, fileName, fin, "application/octet-stream");
+    public void addPart(String key, File file) {
+        addPart(key, file, null);
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type) {
-        try {
-            out.write(boundaryLine);
+    public void addPart(final String key, File file, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        fileParts.add(new FilePart(key, file, type));
+    }
 
-            // Headers
-            out.write(createContentDisposition(key, fileName));
-            out.write(createContentType(type));
-            out.write(TRANSFER_ENCODING_BINARY);
-            out.write(CR_LF);
+    public void addPart(String key, String streamName, InputStream inputStream, String type)
+            throws IOException {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        out.write(boundaryLine);
+
+        // Headers
+        out.write(createContentDisposition(key, streamName));
+        out.write(createContentType(type));
+        out.write(TRANSFER_ENCODING_BINARY);
+        out.write(CR_LF);
+
+        // Stream (file)
+        final byte[] tmp = new byte[4096];
+        int l = 0;
+        while ((l = inputStream.read(tmp)) != -1) {
+            out.write(tmp, 0, l);
+        }
 
-            final byte[] tmp = new byte[4096];
-            int l = 0;
-            while ((l = fin.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-            }
-            out.write(CR_LF);
+        out.write(CR_LF);
+        out.flush();
+        try {
+            inputStream.close();
         } catch (final IOException e) {
-            // Can't happen on ByteArrayOutputStream
-        } finally {
-            try {
-                fin.close();
-            } catch (final IOException e) {
-                // Ignore
-            }
+            // Not important, just log it
+            Log.w(TAG, "Cannot close input stream", e);
         }
     }
 
-    public void addPart(final String key, final File value)
-            throws FileNotFoundException {
-        addPart(key, value.getName(), new FileInputStream(value));
-    }
-
     private byte[] createContentType(String type) {
         String result = "Content-Type: " + type + "\r\n";
         return result.getBytes();
@@ -135,12 +149,71 @@ public void addPart(final String key, final File value)
         builder.append("\"\r\n");
         return builder.toString().getBytes();
     }
+    
+    private class FilePart {
+        public File file;
+        public byte[] header;
+
+        public FilePart(String key, File file, String type) {
+            header = createHeader(key, file.getName(), type);
+            this.file = file;
+        }
+
+        private byte[] createHeader(String key, String filename, String type) {
+            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
+            try {
+                headerStream.write(boundaryLine);
+
+                // Headers
+                headerStream.write(createContentDisposition(key, filename));
+                headerStream.write(createContentType(type));
+                headerStream.write(TRANSFER_ENCODING_BINARY);
+                headerStream.write(CR_LF);
+            } catch (IOException e) {
+                // Can't happen on ByteArrayOutputStream
+            }
+            return headerStream.toByteArray();
+        }
+
+        public long getTotalLength() {
+            long streamLength = file.length();
+            return header.length + streamLength;
+        }
+
+        public void writeTo(OutputStream out) throws IOException {
+            out.write(header);
+            
+            FileInputStream inputStream = new FileInputStream(file);
+            final byte[] tmp = new byte[4096];
+            int l = 0;
+            while ((l = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, l);
+            }
+            out.write(CR_LF);
+            out.flush();
+            try {
+                inputStream.close();
+            } catch (final IOException e) {
+                // Not important, just log it
+                Log.w(TAG, "Cannot close input stream", e);
+            }
+        }
+    }
 
     // The following methods are from the HttpEntity interface
 
     @Override
     public long getContentLength() {
-        return out.size() + boundaryEnd.length;
+        long contentLen = out.size();
+        for (FilePart filePart : fileParts) {
+            long len = filePart.getTotalLength();
+            if (len < 0) {
+                return -1; // Should normally not happen
+            }
+            contentLen += len;
+        }
+        contentLen += boundaryEnd.length;
+        return contentLen;
     }
 
     @Override
@@ -166,6 +239,9 @@ public boolean isStreaming() {
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
         out.writeTo(outstream);
+        for (FilePart filePart : fileParts) {
+            filePart.writeTo(outstream);
+        }
         outstream.write(boundaryEnd);
     }
 
@@ -175,8 +251,7 @@ public Header getContentEncoding() {
     }
 
     @Override
-    public void consumeContent() throws IOException,
-    UnsupportedOperationException {
+    public void consumeContent() throws IOException, UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
             "Streaming entity does not implement #consumeContent()");
