diff --git a/build.gradle b/build.gradle
index 35c9970e..cfa2b19b 100755
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:1.1.0'
     }
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 27a8a50e..5a5b38e6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Jul 02 18:01:59 CEST 2014
+#Thu Jan 22 17:47:44 CET 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 47d51479..d05b0b66 100755
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -14,7 +14,8 @@ android {
         warningsAsErrors true
         quiet false
         showAll true
-        disable 'OldTargetApi'
+        disable 'OldTargetApi', 'LongLogTag'
+        // TODO: long log tag should be fixed instead of ignored
     }
 
     compileOptions {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index a61d456e..f03c1423 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -307,6 +307,11 @@ public void onCancel() {
         Log.d(LOG_TAG, "Request got cancelled");
     }
 
+    public void onUserException(Throwable error) {
+        Log.e(LOG_TAG, "User-space exception detected!", error);
+        throw new RuntimeException(error);
+    }
+
     @Override
     final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
@@ -346,52 +351,56 @@ final public void sendCancelMessage() {
     protected void handleMessage(Message message) {
         Object[] response;
 
-        switch (message.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 3) {
-                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
-                } else {
-                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 4) {
-                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
-                } else {
-                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
-                }
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-            case PROGRESS_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 2) {
-                    try {
-                        onProgress((Integer) response[0], (Integer) response[1]);
-                    } catch (Throwable t) {
-                        Log.e(LOG_TAG, "custom onProgress contains an error", t);
+        try {
+            switch (message.what) {
+                case SUCCESS_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 3) {
+                        onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
+                    } else {
+                        Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
                     }
-                } else {
-                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case RETRY_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length == 1) {
-                    onRetry((Integer) response[0]);
-                } else {
-                    Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
-                }
-                break;
-            case CANCEL_MESSAGE:
-                onCancel();
-                break;
+                    break;
+                case FAILURE_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 4) {
+                        onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
+                    } else {
+                        Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
+                    }
+                    break;
+                case START_MESSAGE:
+                    onStart();
+                    break;
+                case FINISH_MESSAGE:
+                    onFinish();
+                    break;
+                case PROGRESS_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 2) {
+                        try {
+                            onProgress((Integer) response[0], (Integer) response[1]);
+                        } catch (Throwable t) {
+                            Log.e(LOG_TAG, "custom onProgress contains an error", t);
+                        }
+                    } else {
+                        Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                    }
+                    break;
+                case RETRY_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length == 1) {
+                        onRetry((Integer) response[0]);
+                    } else {
+                        Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                    }
+                    break;
+                case CANCEL_MESSAGE:
+                    onCancel();
+                    break;
+            }
+        } catch(Throwable error) {
+            onUserException(error);
         }
     }
 
@@ -416,7 +425,6 @@ protected void postRunnable(Runnable runnable) {
                 runnable.run();
             } else {
                 // Otherwise, run on provided handler
-                Utils.asserts(handler != null, "handler should not be null!");
                 handler.post(runnable);
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 52663a07..66ebcdac 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -39,6 +39,9 @@
 
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
+
+    private boolean useRFC5179CompatibilityMode = true;
+
     /**
      * Creates new JsonHttpResponseHandler, with JSON String encoding UTF-8
      */
@@ -47,7 +50,7 @@ public JsonHttpResponseHandler() {
     }
 
     /**
-     * Creates new JsonHttpRespnseHandler with given JSON String encoding
+     * Creates new JsonHttpResponseHandler with given JSON String encoding
      *
      * @param encoding String encoding to be used when parsing JSON
      */
@@ -55,6 +58,27 @@ public JsonHttpResponseHandler(String encoding) {
         super(encoding);
     }
 
+    /**
+     * Creates new JsonHttpResponseHandler with JSON String encoding UTF-8 and given RFC5179CompatibilityMode
+     *
+     * @param useRFC5179CompatibilityMode Boolean mode to use RFC5179 or latest
+     */
+    public JsonHttpResponseHandler(boolean useRFC5179CompatibilityMode) {
+        super(DEFAULT_CHARSET);
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
+    }
+
+    /**
+     * Creates new JsonHttpResponseHandler with given JSON String encoding and RFC5179CompatibilityMode
+     *
+     * @param encoding                    String encoding to be used when parsing JSON
+     * @param useRFC5179CompatibilityMode Boolean mode to use RFC5179 or latest
+     */
+    public JsonHttpResponseHandler(String encoding, boolean useRFC5179CompatibilityMode) {
+        super(encoding);
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
+    }
+
     /**
      * Returns when request succeeds
      *
@@ -122,16 +146,23 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                if (jsonResponse instanceof JSONObject) {
+                                // In RFC5179 a null value is not a valid JSON
+                                if (!useRFC5179CompatibilityMode && jsonResponse == null) {
+                                    onSuccess(statusCode, headers, (String) jsonResponse);
+                                } else if (jsonResponse instanceof JSONObject) {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
                                 } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
+                                    // In RFC5179 a simple string value is not a valid JSON
+                                    if (useRFC5179CompatibilityMode) {
+                                        onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
+                                    } else {
+                                        onSuccess(statusCode, headers, (String) jsonResponse);
+                                    }
                                 } else {
                                     onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
-
                             }
                         });
                     } catch (final JSONException ex) {
@@ -166,7 +197,10 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                if (jsonResponse instanceof JSONObject) {
+                                // In RFC5179 a null value is not a valid JSON
+                                if (!useRFC5179CompatibilityMode && jsonResponse == null) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
+                                } else if (jsonResponse instanceof JSONObject) {
                                     onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
@@ -217,11 +251,22 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
         String jsonString = getResponseString(responseBody, getCharset());
         if (jsonString != null) {
             jsonString = jsonString.trim();
-            if (jsonString.startsWith(UTF8_BOM)) {
-                jsonString = jsonString.substring(1);
-            }
-            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-                result = new JSONTokener(jsonString).nextValue();
+            if (useRFC5179CompatibilityMode) {
+                if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                    result = new JSONTokener(jsonString).nextValue();
+                }
+            } else {
+                // Check if the string is an JSONObject style {} or JSONArray style []
+                // If not we consider this as a string
+                if ((jsonString.startsWith("{") && jsonString.endsWith("}"))
+                        || jsonString.startsWith("[") && jsonString.endsWith("]")) {
+                    result = new JSONTokener(jsonString).nextValue();
+                }
+                // Check if this is a String "my String value" and remove quote
+                // Other value type (numerical, boolean) should be without quote
+                else if (jsonString.startsWith("\"") && jsonString.endsWith("\"")) {
+                    result = jsonString.substring(1, jsonString.length() - 1);
+                }
             }
         }
         if (result == null) {
@@ -229,4 +274,13 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
         }
         return result;
     }
+
+    public boolean isUseRFC5179CompatibilityMode() {
+        return useRFC5179CompatibilityMode;
+    }
+
+    public void setUseRFC5179CompatibilityMode(boolean useRFC5179CompatibilityMode) {
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
+    }
+
 }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index aea2d1d1..b65b4271 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -199,9 +199,9 @@ public void writeTo(final OutputStream out) throws IOException {
                         } else if (value instanceof JsonValueInterface) {
                             os.write(((JsonValueInterface) value).getEscapedJsonValue());
                         } else if (value instanceof org.json.JSONObject) {
-                            os.write(((org.json.JSONObject) value).toString().getBytes());
+                            os.write(value.toString().getBytes());
                         } else if (value instanceof org.json.JSONArray) {
-                            os.write(((org.json.JSONArray) value).toString().getBytes());
+                            os.write(value.toString().getBytes());
                         } else if (value instanceof Boolean) {
                             os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
                         } else if (value instanceof Long) {
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 4c4ce49e..b4e9ed06 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -38,6 +38,7 @@
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -567,7 +568,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
                 if (nestedKey instanceof String) {
                     Object nestedValue = map.get(nestedKey);
                     if (nestedValue != null) {
-                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format(Locale.US, "%s[%s]", key, nestedKey),
                                 nestedValue));
                     }
                 }
@@ -576,13 +577,13 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
             List list = (List) value;
             int listSize = list.size();
             for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
-                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
+                params.addAll(getParamsList(String.format(Locale.US, "%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
             }
         } else if (value instanceof Object[]) {
             Object[] array = (Object[]) value;
             int arrayLength = array.length;
             for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
-                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
+                params.addAll(getParamsList(String.format(Locale.US, "%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
             }
         } else if (value instanceof Set) {
             Set set = (Set) value;
diff --git a/sample/build.gradle b/sample/build.gradle
index 0d326e09..84507453 100755
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -26,7 +26,7 @@ android {
         warningsAsErrors true
         quiet false
         showAll true
-	disable 'OldTargetApi'
+        disable 'OldTargetApi', 'LongLogTag'
     }
 
     packagingOptions {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
index 779c2f0e..8cc05f43 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
@@ -45,6 +45,7 @@
 import java.security.cert.X509Certificate;
 
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
 
@@ -166,7 +167,12 @@ public Socket createSocket(Socket socket, String host, int port, boolean autoClo
             throws IOException {
 
         injectHostname(socket, host);
-        return sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
+        Socket sslSocket = sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
+        
+        // throw an exception if the hostname does not match the certificate
+        getHostnameVerifier().verify(host, (SSLSocket) sslSocket);
+        
+        return sslSocket;
     }
 
     @Override
