diff --git a/build.gradle b/build.gradle
index 8cd902d2..8fd5554b 100755
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:+'
+        classpath 'com.android.tools.build:gradle:0.12.2'
     }
 }
 
diff --git a/library/build.gradle b/library/build.gradle
index 231da11b..f68a9d92 100755
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -14,7 +14,7 @@ android {
         warningsAsErrors true
         quiet false
         showAll true
-	disable 'OldTargetApi'
+        disable 'OldTargetApi'
     }
 
     compileOptions {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index e5c6be3e..c77a91e9 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -130,7 +130,8 @@
     public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private int timeout = DEFAULT_SOCKET_TIMEOUT;
+    private int connectTimeout = DEFAULT_SOCKET_TIMEOUT;
+    private int responseTimeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
@@ -201,10 +202,11 @@ private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponse
         // Fix to SSL flaw in API < ICS
         // See https://code.google.com/p/android/issues/detail?id=13117
         SSLSocketFactory sslSocketFactory;
-        if (fixNoHttpResponseException)
+        if (fixNoHttpResponseException) {
             sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
-        else
+        } else {
             sslSocketFactory = SSLSocketFactory.getSocketFactory();
+        }
 
         SchemeRegistry schemeRegistry = new SchemeRegistry();
         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
@@ -222,12 +224,12 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         BasicHttpParams httpParams = new BasicHttpParams();
 
-        ConnManagerParams.setTimeout(httpParams, timeout);
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
         ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
 
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
         HttpConnectionParams.setTcpNoDelay(httpParams, true);
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
@@ -255,6 +257,9 @@ public void process(HttpRequest request, HttpContext context) {
                                         header, clientHeaderMap.get(header),
                                         overwritten.getName(), overwritten.getValue())
                         );
+
+                        //remove the overwritten header
+                        request.removeHeader(overwritten);
                     }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
@@ -454,27 +459,73 @@ public void setMaxConnections(int maxConnections) {
     }
 
     /**
-     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     * Returns current socket timeout limit (milliseconds). By default, this is
+     * set to 10 seconds.
      *
      * @return Socket Timeout limit in milliseconds
+     * @deprecated Use either {@link #getConnectTimeout()} or {@link #getResponseTimeout()}
      */
     public int getTimeout() {
-        return timeout;
+        return connectTimeout;
     }
 
     /**
-     * Set the connection and socket timeout. By default, 10 seconds.
+     * Set both the connection and socket timeouts. By default, both are set to
+     * 10 seconds.
      *
-     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
+     * @param value the connect/socket timeout in milliseconds, at least 1 second
+     * @see {@link #setConnectTimeout(int)} if you need further refinement for either value or
+     * or {@link #setResponseTimeout(int)} methods.
      */
-    public void setTimeout(int timeout) {
-        if (timeout < 1000)
-            timeout = DEFAULT_SOCKET_TIMEOUT;
-        this.timeout = timeout;
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
+    public void setTimeout(int value) {
+        value = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        setConnectTimeout(value);
+        setResponseTimeout(value);
+    }
+
+    /**
+     * Returns current connection timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
+     *
+     * @return Connection timeout limit in milliseconds
+     */
+    public int getConnectTimeout() {
+        return connectTimeout;
+    }
+
+    /**
+     * Set connection timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Connection timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setConnectTimeout(int value) {
+        connectTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
+    }
+
+    /**
+     * Returns current response timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
+     *
+     * @return Response timeout limit in milliseconds
+     */
+    public int getResponseTimeout() {
+        return responseTimeout;
+    }
+
+    /**
+     * Set response timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Response timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setResponseTimeout(int value) {
+        responseTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
     }
 
     /**
@@ -1237,10 +1288,11 @@ private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface
                 entity = params.getEntity(responseHandler);
             }
         } catch (IOException e) {
-            if (responseHandler != null)
+            if (responseHandler != null) {
                 responseHandler.sendFailureMessage(0, null, null, e);
-            else
+            } else {
                 e.printStackTrace();
+            }
         }
 
         return entity;
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 81786ceb..b7756d8f 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -39,9 +39,10 @@
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
-    private boolean isCancelled = false;
-    private boolean cancelIsNotified = false;
-    private boolean isFinished = false;
+    private boolean isCancelled;
+    private boolean cancelIsNotified;
+    private boolean isFinished;
+    private boolean isRequestPreProcessed;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
         this.client = client;
@@ -50,12 +51,52 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.responseHandler = responseHandler;
     }
 
+    /**
+     * This method is called once by the system when the request is about to be
+     * processed by the system. The library makes sure that a single request
+     * is pre-processed only once.
+     *
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to pre-process
+     */
+    public void onPreProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
+    }
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single request
+     * is post-processed only once.
+     *
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to post-process
+     */
+    public void onPostProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
+    }
+
     @Override
     public void run() {
         if (isCancelled()) {
             return;
         }
 
+        // Carry out pre-processing for this request only once.
+        if (!isRequestPreProcessed) {
+            isRequestPreProcessed = true;
+            onPreProcessRequest(this);
+        }
+
+        if (isCancelled()) {
+            return;
+        }
+
         if (responseHandler != null) {
             responseHandler.sendStartMessage();
         }
@@ -82,6 +123,13 @@ public void run() {
             responseHandler.sendFinishMessage();
         }
 
+        if (isCancelled()) {
+            return;
+        }
+
+        // Carry out post-processing for this request.
+        onPostProcessRequest(this);
+
         isFinished = true;
     }
 
@@ -89,6 +137,7 @@ private void makeRequest() throws IOException {
         if (isCancelled()) {
             return;
         }
+
         // Fixes #115
         if (request.getURI().getScheme() == null) {
             // subclass of IOException so processed in the caller
@@ -97,9 +146,26 @@ private void makeRequest() throws IOException {
 
         HttpResponse response = client.execute(request, context);
 
-        if (!isCancelled() && responseHandler != null) {
-            responseHandler.sendResponseMessage(response);
+        if (isCancelled() || responseHandler == null) {
+            return;
+        }
+
+        // Carry out pre-processing for this response.
+        responseHandler.onPreProcessResponse(responseHandler, response);
+
+        if (isCancelled()) {
+            return;
+        }
+
+        // The response is ready, handle it.
+        responseHandler.sendResponseMessage(response);
+
+        if (isCancelled()) {
+            return;
         }
+
+        // Carry out post-processing for this response.
+        responseHandler.onPostProcessResponse(responseHandler, response);
     }
 
     private void makeRequestWithRetries() throws IOException {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 761bfdc5..8462f5bc 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -79,6 +79,7 @@
  * </pre>
  */
 public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+
     private static final String LOG_TAG = "AsyncHttpResponseHandler";
 
     protected static final int SUCCESS_MESSAGE = 0;
@@ -92,12 +93,14 @@
     protected static final int BUFFER_SIZE = 4096;
 
     public static final String DEFAULT_CHARSET = "UTF-8";
+    public static final String UTF8_BOM = "\uFEFF";
     private String responseCharset = DEFAULT_CHARSET;
     private Handler handler;
     private boolean useSynchronousMode;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
+    private Looper looper = null;
 
     @Override
     public URI getRequestURI() {
@@ -125,7 +128,8 @@ public void setRequestHeaders(Header[] requestHeaders) {
     private static class ResponderHandler extends Handler {
         private final AsyncHttpResponseHandler mResponder;
 
-        ResponderHandler(AsyncHttpResponseHandler mResponder) {
+        ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) {
+            super(looper);
             this.mResponder = mResponder;
         }
 
@@ -143,7 +147,7 @@ public boolean getUseSynchronousMode() {
     @Override
     public void setUseSynchronousMode(boolean value) {
         // A looper must be prepared before setting asynchronous mode.
-        if (!value && Looper.myLooper() == null) {
+        if (!value && this.looper == null) {
             value = true;
             Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
         }
@@ -151,7 +155,7 @@ public void setUseSynchronousMode(boolean value) {
         // If using asynchronous mode.
         if (!value && handler == null) {
             // Create a handler on current thread to submit tasks
-            handler = new ResponderHandler(this);
+            handler = new ResponderHandler(this, this.looper);
         } else if (value && handler != null) {
             // TODO: Consider adding a flag to remove all queued messages.
             handler = null;
@@ -178,6 +182,18 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
+        this(null);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If
+     * the passed looper is null, the looper attached to the current thread will
+     * be used.
+     *
+     * @param looper The looper to work with
+     */
+    public AsyncHttpResponseHandler(Looper looper) {
+        this.looper = looper == null ? Looper.myLooper() : looper;
         // Use asynchronous mode by default.
         setUseSynchronousMode(false);
     }
@@ -207,6 +223,16 @@ public void onFinish() {
         // default log warning is not necessary, because this method is just optional notification
     }
 
+    @Override
+    public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
+    }
+
+    @Override
+    public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
+    }
+
     /**
      * Fired when a request returns successfully, override to handle in your own code
      *
@@ -239,30 +265,37 @@ public void onCancel() {
         Log.d(LOG_TAG, "Request got cancelled");
     }
 
+    @Override
     final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
+    @Override
     final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
     }
 
+    @Override
     final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
     }
 
+    @Override
     final public void sendStartMessage() {
         sendMessage(obtainMessage(START_MESSAGE, null));
     }
 
+    @Override
     final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
+    @Override
     final public void sendRetryMessage(int retryNo) {
         sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
     }
 
+    @Override
     final public void sendCancelMessage() {
         sendMessage(obtainMessage(CANCEL_MESSAGE, null));
     }
@@ -308,10 +341,11 @@ protected void handleMessage(Message message) {
                 break;
             case RETRY_MESSAGE:
                 response = (Object[]) message.obj;
-                if (response != null && response.length == 1)
+                if (response != null && response.length == 1) {
                     onRetry((Integer) response[0]);
-                else
+                } else {
                     Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                }
                 break;
             case CANCEL_MESSAGE:
                 onCancel();
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index 0fe6ec16..dae49c59 100755
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -97,10 +97,12 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode())
+            if (!getUseSynchronousMode()) {
                 new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
+            } else {
+                // In synchronous mode everything should be run on one thread
                 parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, null, null);
         }
@@ -131,10 +133,12 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode())
+            if (!getUseSynchronousMode()) {
                 new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
+            } else {
+                // In synchronous mode everything should be run on one thread
                 parser.run();
+            }
         } else {
             onFailure(statusCode, headers, throwable, null, null);
         }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index eaa30ec5..3b844dfc 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -53,11 +53,11 @@
 
     private static final String LOG_TAG = "BinaryHttpResponseHandler";
 
-    private String[] mAllowedContentTypes = new String[] {
-        RequestParams.APPLICATION_OCTET_STREAM,
-        "image/jpeg",
-        "image/png",
-        "image/gif"
+    private String[] mAllowedContentTypes = new String[]{
+            RequestParams.APPLICATION_OCTET_STREAM,
+            "image/jpeg",
+            "image/png",
+            "image/gif"
     };
 
     /**
@@ -85,10 +85,11 @@ public BinaryHttpResponseHandler() {
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
         super();
-        if (allowedContentTypes != null)
+        if (allowedContentTypes != null) {
             mAllowedContentTypes = allowedContentTypes;
-        else
+        } else {
             Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
+        }
     }
 
     @Override
@@ -104,13 +105,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
             sendFailureMessage(
-                status.getStatusCode(),
-                response.getAllHeaders(),
-                null,
-                new HttpResponseException(
                     status.getStatusCode(),
-                    "None, or more than one, Content-Type Header found!"
-                )
+                    response.getAllHeaders(),
+                    null,
+                    new HttpResponseException(
+                            status.getStatusCode(),
+                            "None, or more than one, Content-Type Header found!"
+                    )
             );
             return;
         }
@@ -128,13 +129,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
             sendFailureMessage(
-                status.getStatusCode(),
-                response.getAllHeaders(),
-                null,
-                new HttpResponseException(
                     status.getStatusCode(),
-                    "Content-Type not allowed!"
-                )
+                    response.getAllHeaders(),
+                    null,
+                    new HttpResponseException(
+                            status.getStatusCode(),
+                            "Content-Type not allowed!"
+                    )
             );
             return;
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 5b864f61..b12afce6 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -36,6 +36,7 @@
  * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends TextHttpResponseHandler {
+
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
     /**
@@ -143,10 +144,12 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode())
+            if (!getUseSynchronousMode()) {
                 new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
+            } else {
+                // In synchronous mode everything should be run on one thread
                 parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
@@ -186,10 +189,12 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode())
+            if (!getUseSynchronousMode()) {
                 new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
+            } else {
+                // In synchronous mode everything should be run on one thread
                 parser.run();
+            }
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
             onFailure(statusCode, headers, throwable, (JSONObject) null);
@@ -212,6 +217,9 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
         String jsonString = getResponseString(responseBody, getCharset());
         if (jsonString != null) {
             jsonString = jsonString.trim();
+            if (jsonString.startsWith(UTF8_BOM)) {
+                jsonString = jsonString.substring(1);
+            }
             if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
                 result = new JSONTokener(jsonString).nextValue();
             }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 5e490cdd..0df47d47 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -66,13 +66,13 @@
 
     private static final Header HEADER_JSON_CONTENT =
             new BasicHeader(
-                AsyncHttpClient.HEADER_CONTENT_TYPE,
-                RequestParams.APPLICATION_JSON);
+                    AsyncHttpClient.HEADER_CONTENT_TYPE,
+                    RequestParams.APPLICATION_JSON);
 
     private static final Header HEADER_GZIP_ENCODING =
             new BasicHeader(
-                AsyncHttpClient.HEADER_CONTENT_ENCODING,
-                AsyncHttpClient.ENCODING_GZIP);
+                    AsyncHttpClient.HEADER_CONTENT_ENCODING,
+                    AsyncHttpClient.ENCODING_GZIP);
 
     // JSON data and associated meta-data to be uploaded.
     private final Map<String, Object> jsonParams = new HashMap<String, Object>();
@@ -190,6 +190,12 @@ public void writeTo(final OutputStream out) throws IOException {
 
                 // End the file's object and prepare for next one.
                 os.write('}');
+            } else if (value instanceof JsonValueInterface) {
+                os.write(((JsonValueInterface) value).getEscapedJsonValue());
+            } else if (value instanceof org.json.JSONObject) {
+                os.write(((org.json.JSONObject) value).toString().getBytes());
+            } else if (value instanceof org.json.JSONArray) {
+                os.write(((org.json.JSONArray) value).toString().getBytes());
             } else if (value instanceof Boolean) {
                 os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
@@ -201,7 +207,7 @@ public void writeTo(final OutputStream out) throws IOException {
             } else if (value instanceof Integer) {
                 os.write((((Number) value).intValue() + "").getBytes());
             } else {
-                os.write(value.toString().getBytes());
+                os.write(escape(value.toString()));
             }
 
             os.write(',');
diff --git a/library/src/main/java/com/loopj/android/http/JsonValueInterface.java b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
new file mode 100644
index 00000000..110b5c1c
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
@@ -0,0 +1,37 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+/**
+ * This interface is used to encapsulate JSON values that are handled entirely
+ * by the app. For example, apps could manage any type of JSON on their own (and
+ * not rely on {@link org.json.JSONArray} or {@link org.json.JSONObject} to
+ * exchange data.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public interface JsonValueInterface {
+
+    /**
+     * Returns the escaped, ready-to-be used value of this encapsulated object.
+     *
+     * @return byte array holding the data to be used (as-is) in a JSON object
+     */
+    byte[] getEscapedJsonValue();
+}
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 0fefaf72..e5e99c8c 100755
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -28,11 +28,9 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-
-import java.io.IOException;
-
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
index 3d09aa38..7abffb1a 100755
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -66,8 +66,9 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                     if (header == null) {
                         append = false;
                         current = 0;
-                    } else
+                    } else {
                         Log.v(LOG_TAG, AsyncHttpClient.HEADER_CONTENT_RANGE + ": " + header.getValue());
+                    }
                     sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
                 }
             }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index a427f75c..195a8184 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -112,10 +112,11 @@
      * @param encoding String constant from {@link org.apache.http.protocol.HTTP}
      */
     public void setContentEncoding(final String encoding) {
-        if (encoding != null)
+        if (encoding != null) {
             this.contentEncoding = encoding;
-        else
+        } else {
             Log.d(LOG_TAG, "setContentEncoding called with null attribute");
+        }
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index 23a185d0..193f44fe 100755
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -127,4 +127,32 @@
      * @return boolean if the ResponseHandler is running in synchronous mode
      */
     boolean getUseSynchronousMode();
+
+    /**
+     * This method is called once by the system when the response is about to be
+     * processed by the system. The library makes sure that a single response
+     * is pre-processed only once.
+     *
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to pre-processed
+     */
+    void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single response
+     * is post-processed only once.
+     *
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to post-process
+     */
+    void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
 }
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index 47c67794..9bbc3e01 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -152,15 +152,15 @@ private String normalizeContentType(String type) {
 
     private byte[] createContentDisposition(String key) {
         return (
-            AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
-            ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
     }
 
     private byte[] createContentDisposition(String key, String fileName) {
         return (
-            AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
-            ": form-data; name=\"" + key + "\"" +
-            "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" +
+                        "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
     }
 
     private void updateProgress(int count) {
@@ -236,8 +236,8 @@ public long getContentLength() {
     @Override
     public Header getContentType() {
         return new BasicHeader(
-            AsyncHttpClient.HEADER_CONTENT_TYPE,
-            "multipart/form-data; boundary=" + boundary);
+                AsyncHttpClient.HEADER_CONTENT_TYPE,
+                "multipart/form-data; boundary=" + boundary);
     }
 
     @Override
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
index 1c354a6c..71f49459 100755
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -56,6 +56,7 @@
  * </pre>
  */
 public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+
     private static final String LOG_TAG = "TextHttpResponseHandler";
 
     /**
@@ -113,11 +114,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Th
      */
     public static String getResponseString(byte[] stringBytes, String charset) {
         try {
-            return stringBytes == null ? null : new String(stringBytes, charset);
+            String toReturn = (stringBytes == null) ? null : new String(stringBytes, charset);
+            if (toReturn != null && toReturn.startsWith(UTF8_BOM)) {
+                return toReturn.substring(1);
+            }
+            return toReturn;
         } catch (UnsupportedEncodingException e) {
             Log.e(LOG_TAG, "Encoding response into string failed", e);
             return null;
         }
     }
-
 }
diff --git a/sample/build.gradle b/sample/build.gradle
index 4ec13b7d..3f4166a7 100755
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.+'
+        classpath 'com.android.tools.build:gradle:0.12.2'
     }
 }
 apply plugin: 'com.android.application'
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index c4e37b1a..f3380bad 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -39,6 +39,7 @@
         <activity android:name=".RetryRequestSample"/>
         <activity android:name=".RangeResponseSample"/>
         <activity android:name=".Http401AuthSample"/>
+        <activity android:name=".AsyncBackgroundThreadSample"/>
 
         <service android:name=".services.ExampleIntentService"/>
     </application>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
new file mode 100755
index 00000000..eb3b7a2b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
@@ -0,0 +1,153 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.os.Looper;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+
+public class AsyncBackgroundThreadSample extends SampleParentActivity {
+    private static final String LOG_TAG = "AsyncBackgroundThreadSample";
+
+    private ExecutorService executor = Executors.newSingleThreadExecutor();
+
+    @Override
+    public void onStop()
+    {
+        super.onStop();
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+
+        final Activity ctx = this;
+        FutureTask<RequestHandle> future = new FutureTask<>(new Callable<RequestHandle>() {
+            public RequestHandle call() {
+                Log.d(LOG_TAG, "Executing GET request on background thread");
+                return client.get(ctx, URL, headers, null, responseHandler);
+            }
+        });
+
+        executor.execute(future);
+
+        RequestHandle handle = null;
+        try {
+            handle = future.get(5, TimeUnit.SECONDS);
+            Log.d(LOG_TAG, "Background thread for GET request has finished");
+        } catch (Exception e) {
+            Toast.makeText(ctx, e.getMessage(), Toast.LENGTH_LONG).show();
+            e.printStackTrace();
+        }
+
+        return handle;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_async_background_thread;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+
+        FutureTask<ResponseHandlerInterface> future = new FutureTask<>(new Callable<ResponseHandlerInterface>() {
+
+            @Override
+            public ResponseHandlerInterface call() throws Exception {
+                Log.d(LOG_TAG, "Creating AsyncHttpResponseHandler on background thread");
+                return new AsyncHttpResponseHandler(Looper.getMainLooper()) {
+
+                    @Override
+                    public void onStart() {
+                        clearOutputs();
+                    }
+
+                    @Override
+                    public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                        Log.d(LOG_TAG, String.format("onSuccess executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+
+                    @Override
+                    public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                        Log.d(LOG_TAG, String.format("onFailure executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+
+                    @Override
+                    public void onRetry(int retryNo) {
+                        Toast.makeText(AsyncBackgroundThreadSample.this,
+                                String.format("Request is retried, retry no. %d", retryNo),
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                };
+            }
+        });
+
+        executor.execute(future);
+
+        ResponseHandlerInterface responseHandler = null;
+        try {
+            responseHandler = future.get();
+            Log.d(LOG_TAG, "Background thread for AsyncHttpResponseHandler has finished");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return responseHandler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
new file mode 100644
index 00000000..bae03e9b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
@@ -0,0 +1,145 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.util.Log;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.util.Locale;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public class PrePostProcessingSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PrePostProcessingSample";
+
+    protected static final int LIGHTGREY = Color.parseColor("#E0E0E0");
+    protected static final int DARKGREY = Color.parseColor("#888888");
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_pre_post_processing;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/post";
+    }
+
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new PrePostProcessRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Pre",
+                    "Response is about to be pre-processed", LIGHTGREY);
+            }
+
+          @Override
+            public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Post",
+                    "Response is about to be post-processed", DARKGREY);
+            }
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+
+    protected void debugProcessing(String TAG, String state, String message, final int color) {
+        final String debugMessage = String.format(Locale.US, "%s-processing: %s", state, message);
+        Log.d(TAG, debugMessage);
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+              addView(getColoredView(color, debugMessage));
+            }
+        });
+    }
+
+    private class PrePostProcessRequest extends AsyncHttpRequest {
+
+        public PrePostProcessRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
+            super(client, context, request, responseHandler);
+        }
+
+        @Override
+        public void onPreProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Pre",
+                "Request is about to be pre-processed", LIGHTGREY);
+        }
+
+        @Override
+        public void onPostProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Post",
+                "Request is about to be post-processed", DARKGREY);
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
index 6c7fe6b5..0e8d2bdf 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -18,7 +18,9 @@
 
 package com.loopj.android.http.sample;
 
+import android.content.Context;
 import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
 import com.loopj.android.http.RequestHandle;
 import com.loopj.android.http.ResponseHandlerInterface;
 
@@ -26,6 +28,9 @@
 import org.apache.http.HttpEntity;
 
 import java.util.List;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
 
 public interface SampleInterface {
 
@@ -45,6 +50,8 @@
 
     void setAsyncHttpClient(AsyncHttpClient client);
 
+    AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context);
+
     ResponseHandlerInterface getResponseHandler();
 
     String getDefaultURL();
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index 546210cb..d596a5c3 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http.sample;
 
 import android.app.Activity;
+import android.content.Context;
 import android.graphics.Color;
 import android.os.Bundle;
 import android.util.Log;
@@ -30,7 +31,9 @@
 import android.widget.TextView;
 
 import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
 import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -44,10 +47,22 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
 
 public abstract class SampleParentActivity extends Activity implements SampleInterface {
 
-    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient() {
+
+      @Override
+      protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        AsyncHttpRequest httpRequest = getHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
+        return httpRequest == null
+            ? super.newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context)
+            : httpRequest;
+      }
+    };
     private EditText urlEditText, headersEditText, bodyEditText;
     private LinearLayout responseLayout;
     private final List<RequestHandle> requestHandles = new LinkedList<RequestHandle>();
@@ -88,6 +103,11 @@ protected void onCreate(Bundle savedInstanceState) {
         }
     }
 
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return null;
+    }
+
     public List<RequestHandle> getRequestHandles() {
         return requestHandles;
     }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index f586e5c6..24b11a24 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -52,7 +52,8 @@
         new SampleConfig(R.string.title_custom_ca, CustomCASample.class),
         new SampleConfig(R.string.title_retry_handler, RetryRequestSample.class),
         new SampleConfig(R.string.title_range_sample, RangeResponseSample.class),
-        new SampleConfig(R.string.title_401_unauth, Http401AuthSample.class)
+        new SampleConfig(R.string.title_401_unauth, Http401AuthSample.class),
+        new SampleConfig(R.string.title_pre_post_processing, PrePostProcessingSample.class)
     };
 
     @Override
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index cf3fefa3..61c0f0bf 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -35,4 +35,6 @@
     <string name="title_retry_handler">Retrying requests by Exception</string>
     <string name="title_range_sample">Range response handling</string>
     <string name="title_401_unauth">401 basic authentication</string>
+    <string name="title_pre_post_processing">Pre-/Post-processing</string>
+    <string name="title_async_background_thread">Async on background thread</string>
 </resources>
