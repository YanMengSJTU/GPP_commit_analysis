diff --git a/.classpath b/.classpath
deleted file mode 100644
index 14fcf527..00000000
--- a/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
index 8842bb26..d3b22564
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,40 @@
+# Custom
 _site
+
+# Ant
 MANIFEST.MF
 ./*.jar
 build.num
 build
+
+# ADT
+.classpath
+.project
+.settings
 local.properties
-bin/
-gen/
+bin
+gen
 _layouts
+proguard.cfg
+
+# OSX
 .DS_Store
+
+# Github
 gh-pages
+
+# Gradle
+.gradle
+build
+
+# IDEA
+*.iml
+*.ipr
+*.iws
+out
+.idea
+
+# Maven
+target
+release.properties
+pom.xml.*
diff --git a/.project b/.project
deleted file mode 100644
index a9793139..00000000
--- a/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>android-async-http</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.travis.yml b/.travis.yml
new file mode 100755
index 00000000..516e7ca9
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,38 @@
+branches:
+  only:
+    - master
+language:
+  - java
+jdk:
+  - openjdk7
+before_install:
+  # environment info
+  - mvn -version
+  - gradle -v
+  - uname -a
+  # required libs for android build tools
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+  # for gradle output style
+  - export TERM=dumb
+  # newer version of gradle
+  - wget http://services.gradle.org/distributions/gradle-1.11-bin.zip
+  - unzip -qq gradle-1.11-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.11
+  - export PATH=$GRADLE_HOME/bin:$PATH
+  # just to test gradle version, against our provided one
+  - gradle -v
+  # newest android SDK 22.6.1
+  - wget http://dl.google.com/android/android-sdk_r22.6.1-linux.tgz
+  - tar -zxf android-sdk_r22.6.1-linux.tgz
+  - export ANDROID_HOME=`pwd`/android-sdk-linux
+  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+  # manually set sdk.dir variable, according to local paths
+  - echo "sdk.dir=$ANDROID_HOME" > local.properties
+  # list packages for debug purpose
+  - android list sdk -a -e -u
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.3 --force --no-ui
+  # Sonatype bypass
+  - echo "nexusUsername=dummy" >> library/gradle.properties
+  - echo "nexusPassword=dummy" >> library/gradle.properties
+
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index 1602a534..182a9605
--- a/README.md
+++ b/README.md
@@ -1,5 +1,6 @@
 Asynchronous Http Client for Android
 ====================================
+[![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
 
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
@@ -11,15 +12,43 @@ Features
 - Requests use a **threadpool** to cap concurrent resource usage
 - GET/POST **params builder** (RequestParams)
 - **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **19kb** for everything
+- Tiny size overhead to your application, only **60kb** for everything
 - Automatic smart **request retries** optimized for spotty mobile connections
 - Automatic **gzip** response decoding support for super-fast requests
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
 - Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
 
+Maven
+-----
+You can now integrate this library in your project via Maven. There are available two kind of builds.
+
+**development snapshots**
+https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
+```
+Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
+GroupId: com.loopj.android
+ArtifactId: android-async-http
+Version: 1.4.5-SNAPSHOT
+Packaging: JAR or AAR
+```
+
+**releases, maven central**
+
+http://central.maven.org/maven2/com/loopj/android/android-async-http/
+```
+Maven URL: http://repo1.maven.org/maven2/
+GroupId: com.loopj.android
+ArtifactId: android-async-http
+Version: 1.4.4
+Packaging: JAR or AAR
+```
 
 Documentation, Features and Examples
 ------------------------------------
 Full details and documentation can be found on the project page here:
 
-http://loopj.com/android-async-http/
\ No newline at end of file
+http://loopj.com/android-async-http/
+
+
+[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/loopj/android-async-http/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
+
diff --git a/build.gradle b/build.gradle
new file mode 100755
index 00000000..21db9553
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,29 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:+'
+    }
+}
+
+def isReleaseBuild() {
+    return version.contains("SNAPSHOT") == false
+}
+
+allprojects {
+    group = 'com.loopj.android'
+    version = '1.4.5-SNAPSHOT'
+
+    repositories {
+        mavenCentral()
+    }
+
+    tasks.withType(JavaCompile) {
+        options.encoding = "UTF-8"
+        options.compilerArgs << "-Xlint:unchecked"
+    }
+}
+
+apply plugin: 'android-reporting'
diff --git a/build.xml b/build.xml
deleted file mode 100644
index 1cd94b37..00000000
--- a/build.xml
+++ /dev/null
@@ -1,98 +0,0 @@
-<project default="package">
-    <property file="local.properties"/>
-    <property file="project.properties"/>
-
-    <!-- Package properties -->
-    <property name="package.name" value="android-async-http" />
-    <property name="package.packagename" value="com.loopj.android.http" />
-    
-    <!-- Get git commit -->
-    <available file=".git" type="dir" property="git.present"/>
-
-    <target name="git-details">
-        <exec executable="git" outputproperty="git.status">
-            <arg value="status" />
-        </exec>
-        <echo message="${git.status}"/>
-        
-        <exec executable="git" outputproperty="package.versionname">
-          <arg value="describe"/>
-          <arg value="--tags"/>
-          <arg value="--dirty"/>
-          <arg value="--always"/>
-        </exec>
-        <echo message="${package.versionname}" />
-    </target>
-
-    <!-- Standard jar stuff -->
-    <property environment="env"/>
-    <condition property="android.base" value="${sdk.dir}" else="${env.ANDROID_HOME}">
-      <isset property="sdk.dir" />
-    </condition>
-    <fail message="Please set either the sdk.dir property or the ANDROID_HOME environment variable to point to your Android SDK installation.">
-      <condition>
-        <not>
-          <available file="${android.base}" type="dir"/>
-        </not>
-      </condition>
-    </fail>
-
-    <property name="lib.dir" value="${android.base}/platforms/${target}" />
-    <property name="build.dir" value="./build"/>
-    <property name="classes.dir"  value="${build.dir}/classes"/>
-    <buildnumber file="build.num" />
-
-    <!-- Set up classpath -->
-    <path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar" />
-    </path>
-
-    <!-- Build javadoc -->
-    <target name="doc">
-        <javadoc 
-            classpathref="classpath"
-            sourcepath="gen:src"
-            destdir="doc"
-            packagenames="${package.packagename}"
-            linkoffline="http://d.android.com/reference ${android.base}/docs/reference" 
-            additionalparam="-author  -version"
-            />
-    </target>
-
-    <!-- Compile java files into classes -->
-    <target name="compile">
-        <mkdir dir="${build.dir}" />
-        <mkdir dir="${classes.dir}" />
-
-        <javac
-            includeantruntime="false"
-            srcdir="src"
-            destdir="${classes.dir}"
-            classpathref="classpath"
-            debug="true"
-            debuglevel="lines,source" />
-    </target>
-
-    <!-- Package a jar from compiled class files -->
-    <target name="jar" depends="git-details,compile">
-        <manifest file="MANIFEST.MF">
-            <attribute name="Built-By" value="${user.name}" />
-            <attribute name="Implementation-Version" value="${package.versionname}"/> 
-        </manifest>
-
-        <jar destfile="${package.name}-${package.versionname}.jar" basedir="build/classes" includes="com/loopj/android/http/**/*.class" manifest="MANIFEST.MF" />
-    </target>
-
-    <!-- Clean out the build files -->
-    <target name="clean">
-        <delete dir="build" />
-        <delete dir="doc" />
-        <delete>
-            <fileset dir="." includes="*.jar"/>
-            <fileset file="MANIFEST.MF"/>
-        </delete>
-    </target>
-
-    <!-- Compile and package a jar -->
-    <target name="package" depends="compile,jar" />
-</project>
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
new file mode 100755
index 00000000..998daa1f
--- /dev/null
+++ b/examples/CookieVideoView.java
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.media.MediaPlayer.OnCompletionListener;
+import android.media.MediaPlayer.OnErrorListener;
+import android.media.MediaPlayer.OnInfoListener;
+import android.net.Uri;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.widget.MediaController;
+import android.widget.MediaController.MediaPlayerControl;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.http.cookie.Cookie;
+
+/**
+ * Displays a video file.  The VideoView class
+ * can load images from various sources (such as resources or content
+ * providers), takes care of computing its measurement from the video so that
+ * it can be used in any layout manager, and provides various display options
+ * such as scaling and tinting.
+ *
+ * @author Jungho Bang <me@bangtoven.com>
+ */
+public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
+    private String TAG = "CookieVideoView";
+    // settable by the client
+    private Uri         mUri;
+    private Map<String, String> mHeaders;
+
+    // all possible internal states
+    private static final int STATE_ERROR              = -1;
+    private static final int STATE_IDLE               = 0;
+    private static final int STATE_PREPARING          = 1;
+    private static final int STATE_PREPARED           = 2;
+    private static final int STATE_PLAYING            = 3;
+    private static final int STATE_PAUSED             = 4;
+    private static final int STATE_PLAYBACK_COMPLETED = 5;
+
+    // mCurrentState is a VideoView object's current state.
+    // mTargetState is the state that a method caller intends to reach.
+    // For instance, regardless the VideoView object's current state,
+    // calling pause() intends to bring the object to a target state
+    // of STATE_PAUSED.
+    private int mCurrentState = STATE_IDLE;
+    private int mTargetState  = STATE_IDLE;
+
+    // All the stuff we need for playing and showing a video
+    private SurfaceHolder mSurfaceHolder = null;
+    private MediaPlayer mMediaPlayer = null;
+    private int         mVideoWidth;
+    private int         mVideoHeight;
+    private int         mSurfaceWidth;
+    private int         mSurfaceHeight;
+    private MediaController mMediaController;
+    private OnCompletionListener mOnCompletionListener;
+    private MediaPlayer.OnPreparedListener mOnPreparedListener;
+    private int         mCurrentBufferPercentage;
+    private OnErrorListener mOnErrorListener;
+    private OnInfoListener  mOnInfoListener;
+    private int         mSeekWhenPrepared;  // recording the seek position while preparing
+    private boolean     mCanPause;
+    private boolean     mCanSeekBack;
+    private boolean     mCanSeekForward;
+	private Context 	mContext;
+
+    public CookieVideoView(Context context) {
+        super(context);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initVideoView(context);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        //Log.i("@@@@", "onMeasure");
+        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
+        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
+        if (mVideoWidth > 0 && mVideoHeight > 0) {
+            if ( mVideoWidth * height  > width * mVideoHeight ) {
+                //Log.i("@@@", "image too tall, correcting");
+                height = width * mVideoHeight / mVideoWidth;
+            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
+                //Log.i("@@@", "image too wide, correcting");
+                width = height * mVideoWidth / mVideoHeight;
+            } else {
+                //Log.i("@@@", "aspect ratio is correct: " +
+                        //width+"/"+height+"="+
+                        //mVideoWidth+"/"+mVideoHeight);
+            }
+        }
+        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
+        setMeasuredDimension(width, height);
+    }
+
+    @SuppressLint("NewApi")
+	@Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(CookieVideoView.class.getName());
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+	@Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(CookieVideoView.class.getName());
+    }
+
+    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
+        int result = desiredSize;
+        int specMode = MeasureSpec.getMode(measureSpec);
+        int specSize =  MeasureSpec.getSize(measureSpec);
+
+        switch (specMode) {
+            case MeasureSpec.UNSPECIFIED:
+                /* Parent says we can be as big as we want. Just don't be larger
+                 * than max size imposed on ourselves.
+                 */
+                result = desiredSize;
+                break;
+
+            case MeasureSpec.AT_MOST:
+                /* Parent says we can be as big as we want, up to specSize.
+                 * Don't be larger than specSize, and don't be larger than
+                 * the max size imposed on ourselves.
+                 */
+                result = Math.min(desiredSize, specSize);
+                break;
+
+            case MeasureSpec.EXACTLY:
+                // No choice. Do what we are told.
+                result = specSize;
+                break;
+        }
+        return result;
+}
+
+    private void initVideoView(Context context) {
+        mVideoWidth = 0;
+        mVideoHeight = 0;
+        getHolder().addCallback(mSHCallback);
+        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        mCurrentState = STATE_IDLE;
+        mTargetState  = STATE_IDLE;
+        mContext = context;
+    }
+
+    public void setVideoPath(String path) {
+        setVideoURI(Uri.parse(path));
+    }
+
+    public void setVideoURI(Uri uri) {
+    	mUri = uri;
+        mHeaders = getCookieHeader();
+    	mSeekWhenPrepared = 0;
+        openVideo();
+        requestLayout();
+        invalidate();
+    }
+    
+    private Map<String,String> getCookieHeader() {
+    	String hostDomain = mUri.getHost();
+    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
+    	for(Cookie cookie : cookieList) {
+    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
+    			Map<String,String> header = new HashMap<String, String>();
+    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
+    	    	Log.d(TAG,"Cookie: "+header.toString());
+    	        return header;
+    	    }
+    	}
+    	return null;
+    }
+    
+    public void stopPlayback() {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.stop();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            mTargetState  = STATE_IDLE;
+        }
+    }
+
+    private void openVideo() {
+        if (mUri == null || mSurfaceHolder == null) {
+            // not ready for playback just yet, will try again later
+            return;
+        }
+        // Tell the music playback service to pause
+        // TODO: these constants need to be published somewhere in the framework.
+        Intent i = new Intent("com.android.music.musicservicecommand");
+        i.putExtra("command", "pause");
+        mContext.sendBroadcast(i);
+
+        // we shouldn't clear the target state, because somebody might have
+        // called start() previously
+        release(false);
+        try {
+            mMediaPlayer = new MediaPlayer();
+            mMediaPlayer.setOnPreparedListener(mPreparedListener);
+            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
+            mMediaPlayer.setOnCompletionListener(mCompletionListener);
+            mMediaPlayer.setOnErrorListener(mErrorListener);
+            mMediaPlayer.setOnInfoListener(mOnInfoListener);
+            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
+            mCurrentBufferPercentage = 0;
+            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
+            mMediaPlayer.setDisplay(mSurfaceHolder);
+            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mMediaPlayer.setScreenOnWhilePlaying(true);
+            mMediaPlayer.prepareAsync();
+            // we don't set the target state here either, but preserve the
+            // target state that was there before.
+            mCurrentState = STATE_PREPARING;
+            attachMediaController();
+        } catch (IOException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        } catch (IllegalArgumentException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        }
+    }
+
+    public void setMediaController(MediaController controller) {
+        if (mMediaController != null) {
+            mMediaController.hide();
+        }
+        mMediaController = controller;
+        attachMediaController();
+    }
+
+    private void attachMediaController() {
+        if (mMediaPlayer != null && mMediaController != null) {
+            mMediaController.setMediaPlayer(this);
+            View anchorView = this.getParent() instanceof View ?
+                    (View)this.getParent() : this;
+            mMediaController.setAnchorView(anchorView);
+            mMediaController.setEnabled(isInPlaybackState());
+        }
+    }
+
+    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
+        new MediaPlayer.OnVideoSizeChangedListener() {
+            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
+                mVideoWidth = mp.getVideoWidth();
+                mVideoHeight = mp.getVideoHeight();
+                if (mVideoWidth != 0 && mVideoHeight != 0) {
+                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                    requestLayout();
+                }
+            }
+    };
+
+    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
+        public void onPrepared(MediaPlayer mp) {
+            mCurrentState = STATE_PREPARED;
+
+            // Get the capabilities of the player for this stream
+//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
+//                                      MediaPlayer.BYPASS_METADATA_FILTER);
+//            
+//          if (data != null) {
+//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
+//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
+//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
+//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
+//            } else {
+                mCanPause = mCanSeekBack = mCanSeekForward = true;
+//            }
+
+            if (mOnPreparedListener != null) {
+                mOnPreparedListener.onPrepared(mMediaPlayer);
+            }
+            if (mMediaController != null) {
+                mMediaController.setEnabled(true);
+            }
+            mVideoWidth = mp.getVideoWidth();
+            mVideoHeight = mp.getVideoHeight();
+
+            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
+            if (seekToPosition != 0) {
+                seekTo(seekToPosition);
+            }
+            if (mVideoWidth != 0 && mVideoHeight != 0) {
+                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
+                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
+                    // We didn't actually change the size (it was already at the size
+                    // we need), so we won't get a "surface changed" callback, so
+                    // start the video here instead of in the callback.
+                    if (mTargetState == STATE_PLAYING) {
+                        start();
+                        if (mMediaController != null) {
+                            mMediaController.show();
+                        }
+                    } else if (!isPlaying() &&
+                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
+                       if (mMediaController != null) {
+                           // Show the media controls when we're paused into a video and make 'em stick.
+                           mMediaController.show(0);
+                       }
+                   }
+                }
+            } else {
+                // We don't know the video size yet, but should start anyway.
+                // The video size might be reported to us later.
+                if (mTargetState == STATE_PLAYING) {
+                    start();
+                }
+            }
+        }
+    };
+
+    private MediaPlayer.OnCompletionListener mCompletionListener =
+        new MediaPlayer.OnCompletionListener() {
+        public void onCompletion(MediaPlayer mp) {
+            mCurrentState = STATE_PLAYBACK_COMPLETED;
+            mTargetState = STATE_PLAYBACK_COMPLETED;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+            if (mOnCompletionListener != null) {
+                mOnCompletionListener.onCompletion(mMediaPlayer);
+            }
+        }
+    };
+
+    private MediaPlayer.OnErrorListener mErrorListener =
+        new MediaPlayer.OnErrorListener() {
+        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
+            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+
+            /* If an error handler has been supplied, use it and finish. */
+            if (mOnErrorListener != null) {
+                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
+                    return true;
+                }
+            }
+
+            /* Otherwise, pop up an error dialog so the user knows that
+             * something bad has happened. Only try and pop up the dialog
+             * if we're attached to a window. When we're going away and no
+             * longer have a window, don't bother showing the user an error.
+             */
+            if (getWindowToken() != null) {
+//                Resources r = mContext.getResources();
+                int messageId;
+
+                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
+                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
+                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
+                } else {
+                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
+                    messageId = R.string.VideoView_error_text_unknown;
+                }
+
+                new AlertDialog.Builder(mContext)
+                        .setMessage(messageId)
+                        //eg. <string name="VideoView_error_button">OK</string>
+                        .setPositiveButton(R.string.VideoView_error_button,
+                                new DialogInterface.OnClickListener() {
+                                    public void onClick(DialogInterface dialog, int whichButton) {
+                                        /* If we get here, there is no onError listener, so
+                                         * at least inform them that the video is over.
+                                         */
+                                        if (mOnCompletionListener != null) {
+                                            mOnCompletionListener.onCompletion(mMediaPlayer);
+                                        }
+                                    }
+                                })
+                        .setCancelable(false)
+                        .show();
+            }
+            return true;
+        }
+    };
+
+    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
+        new MediaPlayer.OnBufferingUpdateListener() {
+        public void onBufferingUpdate(MediaPlayer mp, int percent) {
+            mCurrentBufferPercentage = percent;
+        }
+    };
+
+    /**
+     * Register a callback to be invoked when the media file
+     * is loaded and ready to go.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
+    {
+        mOnPreparedListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when the end of a media file
+     * has been reached during playback.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnCompletionListener(OnCompletionListener l)
+    {
+        mOnCompletionListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an error occurs
+     * during playback or setup.  If no listener is specified,
+     * or if the listener returned false, VideoView will inform
+     * the user of any errors.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnErrorListener(OnErrorListener l)
+    {
+        mOnErrorListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an informational event
+     * occurs during playback or setup.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnInfoListener(OnInfoListener l) {
+        mOnInfoListener = l;
+    }
+
+    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
+    {
+        public void surfaceChanged(SurfaceHolder holder, int format,
+                                    int w, int h)
+        {
+            mSurfaceWidth = w;
+            mSurfaceHeight = h;
+            boolean isValidState =  (mTargetState == STATE_PLAYING);
+            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
+            if (mMediaPlayer != null && isValidState && hasValidSize) {
+                if (mSeekWhenPrepared != 0) {
+                    seekTo(mSeekWhenPrepared);
+                }
+                start();
+            }
+        }
+
+        public void surfaceCreated(SurfaceHolder holder)
+        {
+            mSurfaceHolder = holder;
+            openVideo();
+        }
+
+        public void surfaceDestroyed(SurfaceHolder holder)
+        {
+            // after we return from this we can't use the surface any more
+            mSurfaceHolder = null;
+            if (mMediaController != null) mMediaController.hide();
+            release(true);
+        }
+    };
+
+    /*
+     * release the media player in any state
+     */
+    private void release(boolean cleartargetstate) {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.reset();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            if (cleartargetstate) {
+                mTargetState  = STATE_IDLE;
+            }
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTrackballEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event)
+    {
+        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
+                                     keyCode != KeyEvent.KEYCODE_MENU &&
+                                     keyCode != KeyEvent.KEYCODE_CALL &&
+                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
+        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
+            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
+                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                } else {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
+                if (!mMediaPlayer.isPlaying()) {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                }
+                return true;
+            } else {
+                toggleMediaControlsVisiblity();
+            }
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    private void toggleMediaControlsVisiblity() {
+        if (mMediaController.isShowing()) {
+            mMediaController.hide();
+        } else {
+            mMediaController.show();
+        }
+    }
+
+    public void start() {
+        if (isInPlaybackState()) {
+            mMediaPlayer.start();
+            mCurrentState = STATE_PLAYING;
+        }
+        mTargetState = STATE_PLAYING;
+    }
+
+    public void pause() {
+        if (isInPlaybackState()) {
+            if (mMediaPlayer.isPlaying()) {
+                mMediaPlayer.pause();
+                mCurrentState = STATE_PAUSED;
+            }
+        }
+        mTargetState = STATE_PAUSED;
+    }
+
+    public void suspend() {
+        release(false);
+    }
+
+    public void resume() {
+        openVideo();
+    }
+
+    public int getDuration() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getDuration();
+        }
+
+        return -1;
+    }
+
+    public int getCurrentPosition() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getCurrentPosition();
+        }
+        return 0;
+    }
+
+    public void seekTo(int msec) {
+        if (isInPlaybackState()) {
+            mMediaPlayer.seekTo(msec);
+            mSeekWhenPrepared = 0;
+        } else {
+            mSeekWhenPrepared = msec;
+        }
+    }
+
+    public boolean isPlaying() {
+        return isInPlaybackState() && mMediaPlayer.isPlaying();
+    }
+
+    public int getBufferPercentage() {
+        if (mMediaPlayer != null) {
+            return mCurrentBufferPercentage;
+        }
+        return 0;
+    }
+
+    private boolean isInPlaybackState() {
+        return (mMediaPlayer != null &&
+                mCurrentState != STATE_ERROR &&
+                mCurrentState != STATE_IDLE &&
+                mCurrentState != STATE_PREPARING);
+    }
+
+    public boolean canPause() {
+        return mCanPause;
+    }
+
+    public boolean canSeekBackward() {
+        return mCanSeekBack;
+    }
+
+    public boolean canSeekForward() {
+        return mCanSeekForward;
+    }
+}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
old mode 100644
new mode 100755
index 2b7a4fa0..b5c4fc6f
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -1,5 +1,3 @@
-import com.loopj.android.http.*;
-
 public class ExampleUsage {
     public static void makeRequest() {
         AsyncHttpClient client = new AsyncHttpClient();
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
new file mode 100755
index 00000000..ce949817
--- /dev/null
+++ b/examples/TestCaseExampleUsage.java
@@ -0,0 +1,63 @@
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import android.test.InstrumentationTestCase;
+import android.util.Log;
+
+// Credits to Wuyexiong <forever_crying@qq.com>
+// See: https://github.com/loopj/android-async-http/pull/236
+public class TestCaseExampleUsage extends InstrumentationTestCase
+{
+	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
+
+	public void testAsync() throws Throwable
+	{
+		final CountDownLatch signal = new CountDownLatch(1);
+		runTestOnUiThread(new Runnable()
+		{
+			@Override
+			public void run()
+			{
+				AsyncHttpClient client = new AsyncHttpClient();
+
+				client.get("http://www.google.com", new AsyncHttpResponseHandler()
+				{
+					@Override
+					public void onStart()
+					{
+						Log.v(TAG , "onStart");
+					}
+
+					@Override
+					public void onSuccess(String response)
+					{
+						Log.v(TAG , "onSuccess");
+						System.out.println(response);
+					}
+
+					@Override
+					public void onFailure(Throwable error, String content)
+					{
+						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
+					}
+
+					@Override
+					public void onFinish()
+					{
+						Log.v(TAG , "onFinish");
+						signal.countDown();
+					}
+				});
+
+				try {
+					signal.await(30, TimeUnit.SECONDS);
+				} catch (InterruptedException e) {
+				}
+				Log.v(TAG , "TestCaseExampleUsage Over");
+			}
+		});
+	}
+}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
old mode 100644
new mode 100755
index 387a8711..395273df
--- a/examples/TwitterRestClient.java
+++ b/examples/TwitterRestClient.java
@@ -1,7 +1,5 @@
 // Static wrapper library around AsyncHttpClient
 
-import com.loopj.android.http.*;
-
 public class TwitterRestClient {
     private static final String BASE_URL = "http://api.twitter.com/1/";
 
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
old mode 100644
new mode 100755
index a4c89c8c..297bfecc
--- a/examples/TwitterRestClientUsage.java
+++ b/examples/TwitterRestClientUsage.java
@@ -1,18 +1,15 @@
-import org.json.*;
-import com.loopj.android.http.*;
-
 class TwitterRestClientUsage {
     public void getPublicTimeline() {
         TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
             @Override
             public void onSuccess(JSONArray timeline) {
                 try {
-                    JSONObject firstEvent = (JSONObject)timeline.get(0);
+                    JSONObject firstEvent = (JSONObject) timeline.get(0);
                     String tweetText = firstEvent.getString("text");
 
                     // Do something with the response
                     System.out.println(tweetText);
-                } catch(JSONException e) {
+                } catch (JSONException e) {
                     e.printStackTrace();
                 }
             }
diff --git a/gradle.properties b/gradle.properties
new file mode 100755
index 00000000..faf4d955
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,12 @@
+VERSION_NAME=1.4.5-SNAPSHOT
+VERSION_CODE=145
+GROUP=com.loopj.android
+
+POM_DESCRIPTION=An Asynchronous HTTP Library for Android
+POM_URL=loopj.com/android-async-http/
+POM_SCM_URL=https://github.com/loopj/android-async-http
+POM_SCM_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100755
index 00000000..3ac2b0a6
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,46 @@
+import com.android.builder.BuilderConstants
+
+apply plugin: 'android-library'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion '19.0.3'
+
+    defaultConfig {
+        minSdkVersion 3
+        targetSdkVersion 19
+    }
+    
+    lintOptions {
+        abortOnError false
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+android.libraryVariants.all { variant ->
+  def name = variant.buildType.name
+  if (name.equals(BuilderConstants.DEBUG)) {
+    return; // Skip debug builds.
+  }
+  def task = project.tasks.create "android${name.capitalize()}Jar", Jar
+  task.dependsOn variant.javaCompile
+  task.from variant.javaCompile.destinationDir
+  artifacts.add('archives', task);
+}
+
+android.libraryVariants.all { variant ->
+
+    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
+        description "Generates Javadoc for $variant.name."
+        source = variant.javaCompile.source
+        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
+        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+    }
+
+}
+
+apply from: '../maven_push.gradle'
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100755
index 00000000..96e35d66
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=android-async-http Library
+POM_ARTIFACT_ID=android-async-http
+POM_PACKAGING=aar
diff --git a/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
similarity index 55%
rename from AndroidManifest.xml
rename to library/src/main/AndroidManifest.xml
index 5684532c..f45dcd47
--- a/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.3"
-    android:versionCode="1">
-    <application
-        android:name="android_async_http">
-    </application>
-    <uses-sdk android:minSdkVersion="3" />
+    android:versionName="1.4.5-SNAPSHOT"
+    android:versionCode="145">
+
     <uses-permission android:name="android.permission.INTERNET" />
+
+    <application />
+
 </manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
new file mode 100755
index 00000000..2e2f68c9
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -0,0 +1,1222 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.os.Looper;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpResponseInterceptor;
+import org.apache.http.HttpVersion;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CookieStore;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.RedirectHandler;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpHead;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.conn.params.ConnPerRouteBean;
+import org.apache.http.conn.params.ConnRoutePNames;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.SyncBasicHttpContext;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
+
+
+/**
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
+ * your Android applications. Requests can be made with additional parameters by passing a {@link
+ * RequestParams} instance, and responses can be handled by passing an anonymously overridden {@link
+ * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new ResponseHandlerInterface() {
+ *     &#064;Override
+ *     public void onSuccess(String response) {
+ *         System.out.println(response);
+ *     }
+ * });
+ * </pre>
+ */
+public class AsyncHttpClient {
+
+    public static final int DEFAULT_MAX_CONNECTIONS = 10;
+    public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+    public static final int DEFAULT_MAX_RETRIES = 5;
+    public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
+    public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+    public static final String LOG_TAG = "AsyncHttpClient";
+
+    private int maxConnections = DEFAULT_MAX_CONNECTIONS;
+    private int timeout = DEFAULT_SOCKET_TIMEOUT;
+
+    private final DefaultHttpClient httpClient;
+    private final HttpContext httpContext;
+    private ExecutorService threadPool;
+    private final Map<Context, List<RequestHandle>> requestMap;
+    private final Map<String, String> clientHeaderMap;
+    private boolean isUrlEncodingEnabled = true;
+
+    /**
+     * Creates a new AsyncHttpClient with default constructor arguments values
+     */
+    public AsyncHttpClient() {
+        this(false, 80, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public AsyncHttpClient(int httpPort) {
+        this(false, httpPort, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public AsyncHttpClient(int httpPort, int httpsPort) {
+        this(false, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates new AsyncHttpClient using given params
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));
+    }
+
+    /**
+     * Returns default instance of SchemeRegistry
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        if (fixNoHttpResponseException) {
+            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
+        }
+
+        if (httpPort < 1) {
+            httpPort = 80;
+            Log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
+        }
+
+        if (httpsPort < 1) {
+            httpsPort = 443;
+            Log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
+        }
+
+        // Fix to SSL flaw in API < ICS
+        // See https://code.google.com/p/android/issues/detail?id=13117
+        SSLSocketFactory sslSocketFactory;
+        if (fixNoHttpResponseException)
+            sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
+        else
+            sslSocketFactory = SSLSocketFactory.getSocketFactory();
+
+        SchemeRegistry schemeRegistry = new SchemeRegistry();
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
+        schemeRegistry.register(new Scheme("https", sslSocketFactory, httpsPort));
+
+        return schemeRegistry;
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
+     */
+    public AsyncHttpClient(SchemeRegistry schemeRegistry) {
+
+        BasicHttpParams httpParams = new BasicHttpParams();
+
+        ConnManagerParams.setTimeout(httpParams, timeout);
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
+        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+        HttpConnectionParams.setSoTimeout(httpParams, timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        HttpConnectionParams.setTcpNoDelay(httpParams, true);
+        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+
+        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+
+        threadPool = getDefaultThreadPool();
+        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
+        clientHeaderMap = new HashMap<String, String>();
+
+        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+        httpClient = new DefaultHttpClient(cm, httpParams);
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(HttpRequest request, HttpContext context) {
+                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+                }
+                for (String header : clientHeaderMap.keySet()) {
+                    if (request.containsHeader(header)) {
+                        Header overwritten = request.getFirstHeader(header);
+                        Log.d(LOG_TAG,
+                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
+                                        header, clientHeaderMap.get(header),
+                                        overwritten.getName(), overwritten.getValue())
+                        );
+                    }
+                    request.addHeader(header, clientHeaderMap.get(header));
+                }
+            }
+        });
+
+        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+            @Override
+            public void process(HttpResponse response, HttpContext context) {
+                final HttpEntity entity = response.getEntity();
+                if (entity == null) {
+                    return;
+                }
+                final Header encoding = entity.getContentEncoding();
+                if (encoding != null) {
+                    for (HeaderElement element : encoding.getElements()) {
+                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+                            response.setEntity(new InflatingEntity(entity));
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                        ClientContext.CREDS_PROVIDER);
+                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+                if (authState.getAuthScheme() == null) {
+                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+                    Credentials creds = credsProvider.getCredentials(authScope);
+                    if (creds != null) {
+                        authState.setAuthScheme(new BasicScheme());
+                        authState.setCredentials(creds);
+                    }
+                }
+            }
+        }, 0);
+
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
+    }
+
+    public static void allowRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToWhitelist(cls);
+        }
+    }
+
+    public static void blockRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToBlacklist(cls);
+        }
+    }
+
+    /**
+     * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
+     * settings for requests by accessing the client's ConnectionManager, HttpParams and
+     * SchemeRegistry.
+     *
+     * @return underlying HttpClient instance
+     */
+    public HttpClient getHttpClient() {
+        return this.httpClient;
+    }
+
+    /**
+     * Get the underlying HttpContext instance. This is useful for getting and setting fine-grained
+     * settings for requests by accessing the context's attributes such as the CookieStore.
+     *
+     * @return underlying HttpContext instance
+     */
+    public HttpContext getHttpContext() {
+        return this.httpContext;
+    }
+
+    /**
+     * Sets an optional CookieStore to use when making requests
+     *
+     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link
+     *                    PersistentCookieStore}
+     */
+    public void setCookieStore(CookieStore cookieStore) {
+        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+    }
+
+    /**
+     * Overrides the threadpool implementation used when queuing/pooling requests. By default,
+     * Executors.newFixedThreadPool() is used.
+     *
+     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling
+     *                   requests.
+     */
+    public void setThreadPool(ThreadPoolExecutor threadPool) {
+        this.threadPool = threadPool;
+    }
+
+    /**
+     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * used.
+     *
+     * @return current executor service used
+     */
+    public ExecutorService getThreadPool() {
+        return threadPool;
+    }
+
+    /**
+     * Get the default threading pool to be used for this HTTP client.
+     *
+     * @return The default threading pool to be used
+     */
+    protected ExecutorService getDefaultThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
+    /**
+     * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
+     * on underlying HttpClient, effects of this method will be canceled.
+     * <p/>
+     * Default setting is to disallow redirects.
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @param enableCircularRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
+        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
+        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
+        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
+    }
+
+    /**
+     * Circular redirects are enabled by default
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
+        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
+    }
+
+    /**
+     * @param enableRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects) {
+        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
+    }
+
+    /**
+     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
+     * your needs
+     *
+     * @param customRedirectHandler RedirectHandler instance
+     * @see com.loopj.android.http.MyRedirectHandler
+     */
+    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
+        httpClient.setRedirectHandler(customRedirectHandler);
+    }
+
+    /**
+     * Sets the User-Agent header to be sent with each request. By default, "Android Asynchronous
+     * Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     *
+     * @param userAgent the string to use in the User-Agent header.
+     */
+    public void setUserAgent(String userAgent) {
+        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+    }
+
+
+    /**
+     * Returns current limit of parallel connections
+     *
+     * @return maximum limit of parallel connections, default is 10
+     */
+    public int getMaxConnections() {
+        return maxConnections;
+    }
+
+    /**
+     * Sets maximum limit of parallel connections
+     *
+     * @param maxConnections maximum parallel connections, must be at least 1
+     */
+    public void setMaxConnections(int maxConnections) {
+        if (maxConnections < 1)
+            maxConnections = DEFAULT_MAX_CONNECTIONS;
+        this.maxConnections = maxConnections;
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(this.maxConnections));
+    }
+
+    /**
+     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     *
+     * @return Socket Timeout limit in milliseconds
+     */
+    public int getTimeout() {
+        return timeout;
+    }
+
+    /**
+     * Set the connection and socket timeout. By default, 10 seconds.
+     *
+     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
+     */
+    public void setTimeout(int timeout) {
+        if (timeout < 1000)
+            timeout = DEFAULT_SOCKET_TIMEOUT;
+        this.timeout = timeout;
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
+    }
+
+    /**
+     * Sets the Proxy by it's hostname and port
+     *
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
+     */
+    public void setProxy(String hostname, int port) {
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+    }
+
+    /**
+     * Sets the Proxy by it's hostname,port,username and password
+     *
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
+     * @param username the username
+     * @param password the password
+     */
+    public void setProxy(String hostname, int port, String username, String password) {
+        httpClient.getCredentialsProvider().setCredentials(
+                new AuthScope(hostname, port),
+                new UsernamePasswordCredentials(username, password));
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+    }
+
+    /**
+     * Sets the SSLSocketFactory to user when making requests. By default, a new, default
+     * SSLSocketFactory is used.
+     *
+     * @param sslSocketFactory the socket factory to use for https requests.
+     */
+    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
+    }
+
+    /**
+     * Sets the maximum number of retries and timeout for a particular Request.
+     *
+     * @param retries maximum number of retries per request
+     * @param timeout sleep between retries in milliseconds
+     */
+    public void setMaxRetriesAndTimeout(int retries, int timeout) {
+        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
+    }
+
+    /**
+     * Sets headers that will be added to all requests this client makes (before sending).
+     *
+     * @param header the name of the header
+     * @param value  the contents of the header
+     */
+    public void addHeader(String header, String value) {
+        clientHeaderMap.put(header, value);
+    }
+
+    /**
+     * Remove header from all requests this client makes (before sending).
+     *
+     * @param header the name of the header
+     */
+    public void removeHeader(String header) {
+        clientHeaderMap.remove(header);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username Basic Auth username
+     * @param password Basic Auth password
+     */
+    public void setBasicAuth(String username, String password) {
+        setBasicAuth(username, password, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, boolean preemtive) {
+        setBasicAuth(username, password, null, preemtive);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username Basic Auth username
+     * @param password Basic Auth password
+     * @param scope    - an AuthScope object
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope) {
+        setBasicAuth(username, password, scope, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param scope     an AuthScope object
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemtive) {
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
+        this.httpClient.getCredentialsProvider().setCredentials(scope == null ? AuthScope.ANY : scope, credentials);
+        setAuthenticationPreemptive(preemtive);
+    }
+
+    /**
+     * Sets HttpRequestInterceptor which handles authorization in preemtive way, as workaround you
+     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
+     *
+     * @param isPreemtive whether the authorization is processed in preemtive way
+     */
+    public void setAuthenticationPreemptive(boolean isPreemtive) {
+        if (isPreemtive) {
+            httpClient.addRequestInterceptor(new PreemtiveAuthorizationHttpRequestInterceptor(), 0);
+        } else {
+            httpClient.removeRequestInterceptorByClass(PreemtiveAuthorizationHttpRequestInterceptor.class);
+        }
+    }
+
+    /**
+     * Removes previously set basic auth credentials
+     */
+    public void clearBasicAuth() {
+        this.httpClient.getCredentialsProvider().clear();
+    }
+
+    /**
+     * Cancels any pending (or potentially active) requests associated with the passed Context.
+     * <p>&nbsp;</p> <b>Note:</b> This will only affect requests which were created with a non-null
+     * android Context. This method is intended to be used in the onDestroy method of your android
+     * activities to destroy all requests which are no longer required.
+     *
+     * @param context               the android Context instance associated to the request.
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
+        if (context == null) {
+            Log.e(LOG_TAG, "Passed null Context to cancelRequests");
+            return;
+        }
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                List<RequestHandle> requestList = requestMap.get(context);
+                if (requestList != null) {
+                    for (RequestHandle requestHandle : requestList) {
+                        requestHandle.cancel(mayInterruptIfRunning);
+                    }
+                    requestMap.remove(context);
+                }
+            }
+        };
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            new Thread(r).start();
+        } else {
+            r.run();
+        }
+    }
+
+    /**
+     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
+     * only affect requests which were created with a non-null android Context. This method is
+     * intended to be used in the onDestroy method of your android activities to destroy all
+     * requests which are no longer required.
+     *
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelAllRequests(boolean mayInterruptIfRunning) {
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    requestHandle.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.clear();
+    }
+
+    // [+] HTTP HEAD
+
+    /**
+     * Perform a HTTP HEAD request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle head(String url, ResponseHandlerInterface responseHandler) {
+        return head(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle head(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return head(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request without any parameters and track the Android Context which
+     * initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle head(Context context, String url, ResponseHandlerInterface responseHandler) {
+        return head(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle head(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated the request with
+     * customized headers
+     *
+     * @param context         Context to execute request against
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle head(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
+        HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
+    // [-] HTTP HEAD
+    // [+] HTTP GET
+
+    /**
+     * Perform a HTTP GET request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(String url, ResponseHandlerInterface responseHandler) {
+        return get(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return get(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request without any parameters and track the Android Context which
+     * initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, ResponseHandlerInterface responseHandler) {
+        return get(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request with
+     * customized headers
+     *
+     * @param context         Context to execute request against
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
+        HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
+    // [-] HTTP GET
+    // [+] HTTP POST
+
+    /**
+     * Perform a HTTP POST request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(String url, ResponseHandlerInterface responseHandler) {
+        return post(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return post(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
+     * headers only for this request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional POST parameters to send with the request.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+                              ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
+        if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType,
+                responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
+     * headers only for this request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+                              ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    // [-] HTTP POST
+    // [+] HTTP PUT
+
+    /**
+     * Perform a HTTP PUT request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle put(String url, ResponseHandlerInterface responseHandler) {
+        return put(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle put(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return put(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle put(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    // [-] HTTP PUT
+    // [+] HTTP DELETE
+
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(String url, ResponseHandlerInterface responseHandler) {
+        return delete(null, url, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        if (headers != null) delete.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param params          additional DELETE parameters or files to send along with request
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
+        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        if (headers != null) httpDelete.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
+    }
+
+    // [-] HTTP DELETE
+
+    /**
+     * Puts a new request in queue as a new thread in pool to be executed
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
+     *                        HttpPost, HttpGet, HttpPut, etc.
+     * @return RequestHandle of future request process
+     */
+    protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        if (uriRequest == null) {
+            throw new IllegalArgumentException("HttpUriRequest must not be null");
+        }
+
+        if (responseHandler == null) {
+            throw new IllegalArgumentException("ResponseHandler must not be null");
+        }
+
+        if (responseHandler.getUseSynchronousMode()) {
+            throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
+        }
+
+        if (contentType != null) {
+            uriRequest.setHeader("Content-Type", contentType);
+        }
+
+        responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
+        responseHandler.setRequestURI(uriRequest.getURI());
+
+        AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+        threadPool.submit(request);
+        RequestHandle requestHandle = new RequestHandle(request);
+
+        if (context != null) {
+            // Add request to request map
+            List<RequestHandle> requestList = requestMap.get(context);
+            if (requestList == null) {
+                requestList = new LinkedList();
+                requestMap.put(context, requestList);
+            }
+
+            if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
+                ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(uriRequest);
+
+            requestList.add(requestHandle);
+
+            Iterator<RequestHandle> iterator = requestList.iterator();
+            while (iterator.hasNext()) {
+                if (iterator.next().shouldBeGarbageCollected()) {
+                    iterator.remove();
+                }
+            }
+        }
+
+        return requestHandle;
+    }
+
+    /**
+     * Sets state of URL encoding feature, see bug #227, this method allows you to turn off and on
+     * this auto-magic feature on-demand.
+     *
+     * @param enabled desired state of feature
+     */
+    public void setURLEncodingEnabled(boolean enabled) {
+        this.isUrlEncodingEnabled = enabled;
+    }
+
+    /**
+     * Will encode url, if not disabled, and adds params on the end of it
+     *
+     * @param url             String with URL, should be valid URL without params
+     * @param params          RequestParams to be appended on the end of URL
+     * @param shouldEncodeUrl whether url should be encoded (replaces spaces with %20)
+     * @return encoded url if requested with params appended if any available
+     */
+    public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
+        if (shouldEncodeUrl)
+            url = url.replace(" ", "%20");
+
+        if (params != null) {
+            // Construct the query string and trim it, in case it
+            // includes any excessive white spaces.
+            String paramString = params.getParamString().trim();
+
+            // Only add the query string if it isn't empty and it
+            // isn't equal to '?'.
+            if (!paramString.equals("") && !paramString.equals("?")) {
+                url += url.contains("?") ? "&" : "?";
+                url += paramString;
+            }
+        }
+
+        return url;
+    }
+
+    /**
+     * A utility function to close an input stream without raising an exception.
+     *
+     * @param is input stream to close safely
+     */
+    public static void silentCloseInputStream(InputStream is) {
+        try {
+            if (is != null) {
+                is.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close input stream", e);
+        }
+    }
+
+    /**
+     * A utility function to close an output stream without raising an exception.
+     *
+     * @param os output stream to close safely
+     */
+    public static void silentCloseOutputStream(OutputStream os) {
+        try {
+            if (os != null) {
+                os.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close output stream", e);
+        }
+    }
+
+    /**
+     * Returns HttpEntity containing data from RequestParams included with request declaration.
+     * Allows also passing progress from upload via provided ResponseHandler
+     *
+     * @param params          additional request params
+     * @param responseHandler ResponseHandlerInterface or its subclass to be notified on progress
+     */
+    private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface responseHandler) {
+        HttpEntity entity = null;
+
+        try {
+            if (params != null) {
+                entity = params.getEntity(responseHandler);
+            }
+        } catch (Throwable t) {
+            if (responseHandler != null)
+                responseHandler.sendFailureMessage(0, null, null, t);
+            else
+                t.printStackTrace();
+        }
+
+        return entity;
+    }
+
+    public boolean isUrlEncodingEnabled() {
+        return isUrlEncodingEnabled;
+    }
+
+    /**
+     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for
+     * example not DELETE
+     *
+     * @param entity      entity to be included within the request
+     * @param requestBase HttpRequest instance, must not be null
+     */
+    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
+        if (entity != null) {
+            requestBase.setEntity(entity);
+        }
+
+        return requestBase;
+    }
+
+    /**
+     * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
+     */
+    private static class InflatingEntity extends HttpEntityWrapper {
+        public InflatingEntity(HttpEntity wrapped) {
+            super(wrapped);
+        }
+
+        @Override
+        public InputStream getContent() throws IOException {
+            return new GZIPInputStream(wrappedEntity.getContent());
+        }
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
new file mode 100755
index 00000000..81786ceb
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -0,0 +1,172 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpRequestRetryHandler;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
+
+/**
+ * Internal class, representing the HttpRequest, done in asynchronous manner
+ */
+public class AsyncHttpRequest implements Runnable {
+    private final AbstractHttpClient client;
+    private final HttpContext context;
+    private final HttpUriRequest request;
+    private final ResponseHandlerInterface responseHandler;
+    private int executionCount;
+    private boolean isCancelled = false;
+    private boolean cancelIsNotified = false;
+    private boolean isFinished = false;
+
+    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
+        this.client = client;
+        this.context = context;
+        this.request = request;
+        this.responseHandler = responseHandler;
+    }
+
+    @Override
+    public void run() {
+        if (isCancelled()) {
+            return;
+        }
+
+        if (responseHandler != null) {
+            responseHandler.sendStartMessage();
+        }
+
+        if (isCancelled()) {
+            return;
+        }
+
+        try {
+            makeRequestWithRetries();
+        } catch (IOException e) {
+            if (!isCancelled() && responseHandler != null) {
+                responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
+            }
+        }
+
+        if (isCancelled()) {
+            return;
+        }
+
+        if (responseHandler != null) {
+            responseHandler.sendFinishMessage();
+        }
+
+        isFinished = true;
+    }
+
+    private void makeRequest() throws IOException {
+        if (isCancelled()) {
+            return;
+        }
+        // Fixes #115
+        if (request.getURI().getScheme() == null) {
+            // subclass of IOException so processed in the caller
+            throw new MalformedURLException("No valid URI scheme was provided");
+        }
+
+        HttpResponse response = client.execute(request, context);
+
+        if (!isCancelled() && responseHandler != null) {
+            responseHandler.sendResponseMessage(response);
+        }
+    }
+
+    private void makeRequestWithRetries() throws IOException {
+        boolean retry = true;
+        IOException cause = null;
+        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
+        try {
+            while (retry) {
+                try {
+                    makeRequest();
+                    return;
+                } catch (UnknownHostException e) {
+                    // switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException
+                    // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
+                    // (to assist in genuine cases of unknown host) which seems better than outright failure
+                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
+                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (NullPointerException e) {
+                    // there's a bug in HttpClient 4.0.x that on some occasions causes
+                    // DefaultRequestExecutor to throw an NPE, see
+                    // http://code.google.com/p/android/issues/detail?id=5255
+                    cause = new IOException("NPE in HttpClient: " + e.getMessage());
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (IOException e) {
+                    if (isCancelled()) {
+                        // Eating exception, as the request was cancelled
+                        return;
+                    }
+                    cause = e;
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
+                }
+                if (retry && (responseHandler != null)) {
+                    responseHandler.sendRetryMessage(executionCount);
+                }
+            }
+        } catch (Exception e) {
+            // catch anything else to ensure failure message is propagated
+            Log.e("AsyncHttpRequest", "Unhandled exception origin cause", e);
+            cause = new IOException("Unhandled exception: " + e.getMessage());
+        }
+
+        // cleaned up to throw IOException
+        throw (cause);
+    }
+
+    public boolean isCancelled() {
+        if (isCancelled) {
+            sendCancelNotification();
+        }
+        return isCancelled;
+    }
+
+    private synchronized void sendCancelNotification() {
+        if (!isFinished && isCancelled && !cancelIsNotified) {
+            cancelIsNotified = true;
+            if (responseHandler != null)
+                responseHandler.sendCancelMessage();
+        }
+    }
+
+    public boolean isDone() {
+        return isCancelled() || isFinished;
+    }
+
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        isCancelled = true;
+        request.abort();
+        return isCancelled();
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
new file mode 100755
index 00000000..b345d872
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -0,0 +1,424 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.util.ByteArrayBuffer;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+
+/**
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
+ * #onFinish()}, {@link #onRetry(int)} and {@link #onProgress(int, int)} methods as required.
+ * <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
+ * {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onRetry() {
+ *         // Request was retried
+ *     }
+ *
+ *     &#064;Override
+ *     public void onProgress(int bytesWritten, int totalSize) {
+ *         // Progress notification
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+    private static final String LOG_TAG = "AsyncHttpResponseHandler";
+
+    protected static final int SUCCESS_MESSAGE = 0;
+    protected static final int FAILURE_MESSAGE = 1;
+    protected static final int START_MESSAGE = 2;
+    protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
+    protected static final int RETRY_MESSAGE = 5;
+    protected static final int CANCEL_MESSAGE = 6;
+
+    protected static final int BUFFER_SIZE = 4096;
+
+    public static final String DEFAULT_CHARSET = "UTF-8";
+    private String responseCharset = DEFAULT_CHARSET;
+    private Handler handler;
+    private boolean useSynchronousMode;
+
+    private URI requestURI = null;
+    private Header[] requestHeaders = null;
+
+    @Override
+    public URI getRequestURI() {
+        return this.requestURI;
+    }
+
+    @Override
+    public Header[] getRequestHeaders() {
+        return this.requestHeaders;
+    }
+
+    @Override
+    public void setRequestURI(URI requestURI) {
+        this.requestURI = requestURI;
+    }
+
+    @Override
+    public void setRequestHeaders(Header[] requestHeaders) {
+        this.requestHeaders = requestHeaders;
+    }
+
+    /**
+     * Avoid leaks by using a non-anonymous handler class.
+     */
+    private static class ResponderHandler extends Handler {
+        private final AsyncHttpResponseHandler mResponder;
+
+        ResponderHandler(AsyncHttpResponseHandler mResponder) {
+            this.mResponder = mResponder;
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            mResponder.handleMessage(msg);
+        }
+    }
+
+    @Override
+    public boolean getUseSynchronousMode() {
+        return useSynchronousMode;
+    }
+
+    @Override
+    public void setUseSynchronousMode(boolean value) {
+        // A looper must be prepared before setting asynchronous mode.
+        if (!value && Looper.myLooper() == null) {
+            value = true;
+            Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
+        }
+
+        // If using synchronous mode.
+        if (!value && handler == null) {
+            // Create a handler on current thread to submit tasks
+            handler = new ResponderHandler(this);
+        } else if (value && handler != null) {
+            // TODO: Consider adding a flag to remove all queued messages.
+            handler = null;
+        }
+
+        useSynchronousMode = value;
+    }
+
+    /**
+     * Sets the charset for the response string. If not set, the default is UTF-8.
+     *
+     * @param charset to be used for the response string.
+     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
+    public void setCharset(final String charset) {
+        this.responseCharset = charset;
+    }
+
+    public String getCharset() {
+        return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public AsyncHttpResponseHandler() {
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
+    }
+
+    /**
+     * Fired when the request progress, override to handle in your own code
+     *
+     * @param bytesWritten offset from start of file
+     * @param totalSize    total size of file
+     */
+    public void onProgress(int bytesWritten, int totalSize) {
+        Log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
+    }
+
+    /**
+     * Fired when the request is started, override to handle in your own code
+     */
+    public void onStart() {
+    }
+
+    /**
+     * Fired in all cases when the request is finished, after both success and failure, override to
+     * handle in your own code
+     */
+    public void onFinish() {
+    }
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     *
+     * @param statusCode   the status code of the response
+     * @param headers      return headers, if any
+     * @param responseBody the body of the HTTP response from the server
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] responseBody);
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode   return HTTP status code
+     * @param headers      return headers, if any
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
+
+    /**
+     * Fired when a retry occurs, override to handle in your own code
+     *
+     * @param retryNo number of retry
+     */
+    public void onRetry(int retryNo) {
+        Log.d(LOG_TAG, String.format("Request retry no. %d", retryNo));
+    }
+
+    public void onCancel() {
+        Log.d(LOG_TAG, "Request got cancelled");
+    }
+
+    final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
+    }
+
+    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
+    }
+
+    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
+    }
+
+    final public void sendStartMessage() {
+        sendMessage(obtainMessage(START_MESSAGE, null));
+    }
+
+    final public void sendFinishMessage() {
+        sendMessage(obtainMessage(FINISH_MESSAGE, null));
+    }
+
+    final public void sendRetryMessage(int retryNo) {
+        sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
+    }
+
+    final public void sendCancelMessage() {
+        sendMessage(obtainMessage(CANCEL_MESSAGE, null));
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message message) {
+        Object[] response;
+
+        switch (message.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 3) {
+                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
+                } else {
+                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
+                }
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 4) {
+                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
+                } else {
+                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
+                }
+                break;
+            case START_MESSAGE:
+                onStart();
+                break;
+            case FINISH_MESSAGE:
+                onFinish();
+                break;
+            case PROGRESS_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 2) {
+                    try {
+                        onProgress((Integer) response[0], (Integer) response[1]);
+                    } catch (Throwable t) {
+                        Log.e(LOG_TAG, "custom onProgress contains an error", t);
+                    }
+                } else {
+                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                }
+                break;
+            case RETRY_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length == 1)
+                    onRetry((Integer) response[0]);
+                else
+                    Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                break;
+            case CANCEL_MESSAGE:
+                onCancel();
+                break;
+        }
+    }
+
+    protected void sendMessage(Message msg) {
+        if (getUseSynchronousMode() || handler == null) {
+            handleMessage(msg);
+        } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
+            handler.sendMessage(msg);
+        }
+    }
+
+    /**
+     * Helper method to send runnable into local handler loop
+     *
+     * @param runnable runnable instance, can be null
+     */
+    protected void postRunnable(Runnable runnable) {
+        if (runnable != null) {
+            if (getUseSynchronousMode() || handler == null) {
+                // This response handler is synchronous, run on current thread
+                runnable.run();
+            } else {
+                // Otherwise, run on provided handler
+                handler.post(runnable);
+            }
+        }
+    }
+
+    /**
+     * Helper method to create Message instance from handler
+     *
+     * @param responseMessageId   constant to identify Handler message
+     * @param responseMessageData object to be passed to message receiver
+     * @return Message instance, should not be null
+     */
+    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
+        Message msg;
+        if (handler == null) {
+            msg = Message.obtain();
+            if (msg != null) {
+                msg.what = responseMessageId;
+                msg.obj = responseMessageData;
+            }
+        } else {
+            msg = Message.obtain(handler, responseMessageId, responseMessageData);
+        }
+        return msg;
+    }
+
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
+        // do not process if request has been cancelled
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            byte[] responseBody;
+            responseBody = getResponseData(response.getEntity());
+            // additional cancellation check as getResponseData() can take non-zero time to process
+            if (!Thread.currentThread().isInterrupted()) {
+                if (status.getStatusCode() >= 300) {
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+                } else {
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l, count = 0;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            count += l;
+                            buffer.append(tmp, 0, l);
+                            sendProgressMessage(count, (int) (contentLength <= 0 ? 1 : contentLength));
+                        }
+                    } finally {
+                        AsyncHttpClient.silentCloseInputStream(instream);
+                    }
+                    responseBody = buffer.toByteArray();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
+        }
+        return responseBody;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
new file mode 100755
index 00000000..0fae7e9a
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -0,0 +1,714 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
+     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
+     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
+     * /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
+     * stream it is wrapping when it itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is provided by the caller, and
+         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for this object.  Will finalize
+         *               the coder state and include any final bytes in the output.
+         * @return true if the input so far is good; false if some error has been detected in the
+         * input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process() could produce for the given
+         * number of input bytes.  This may be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
+     *
+     * @param str   the input String to decode, which is converted to bytes using the default
+     *              charset
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *               standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
+         * and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Non-data values in the DECODE arrays.
+         */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
+         * expecting exactly one more. State 5 is expecting no more data or padding characters in
+         * the input. State 6 is the error state; an error has been detected in the input and no
+         * future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3 / 4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if bad base-64 data has been
+         * detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p + 4 <= len &&
+                            (value = ((alphabet[input[p] & 0xff] << 18) |
+                                    (alphabet[input[p + 1] & 0xff] << 12) |
+                                    (alphabet[input[p + 2] & 0xff] << 6) |
+                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                        output[op + 2] = (byte) value;
+                        output[op + 1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                    case 0:
+                        if (d >= 0) {
+                            value = d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 1:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 2:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect exactly one more padding character.
+                            output[op++] = (byte) (value >> 4);
+                            state = 4;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 3:
+                        if (d >= 0) {
+                            // Emit the output triple and return to state 0.
+                            value = (value << 6) | d;
+                            output[op + 2] = (byte) value;
+                            output[op + 1] = (byte) (value >> 8);
+                            output[op] = (byte) (value >> 16);
+                            op += 3;
+                            state = 0;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect no further data or padding characters.
+                            output[op + 1] = (byte) (value >> 2);
+                            output[op] = (byte) (value >> 10);
+                            op += 2;
+                            state = 5;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 4:
+                        if (d == EQUALS) {
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 5:
+                        if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+                case 0:
+                    // Output length is a multiple of three.  Fine.
+                    break;
+                case 1:
+                    // Read one extra input byte, which isn't enough to
+                    // make another output byte.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 2:
+                    // Read two extra input bytes, enough to emit 1 more
+                    // output byte.  Fine.
+                    output[op++] = (byte) (value >> 4);
+                    break;
+                case 3:
+                    // Read three extra input bytes, enough to emit 2 more
+                    // output bytes.  Fine.
+                    output[op++] = (byte) (value >> 10);
+                    output[op++] = (byte) (value >> 2);
+                    break;
+                case 4:
+                    // Read one padding '=' when we expected 2.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 5:
+                    // Read all the padding '='s we expected and no more.
+                    // Fine.
+                    break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated String with the result.
+     *
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
+     *
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0:
+                    break;
+                case 1:
+                    output_len += 2;
+                    break;
+                case 2:
+                    output_len += 3;
+                    break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                    (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        if (BuildConfig.DEBUG && encoder.op != output_len) {
+            throw new AssertionError();
+        }
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
+         * (the maximum allowable according to <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC
+         * 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
+         */
+        private static final byte ENCODE[] = {
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8 / 5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p + 2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                                ((input[p++] & 0xff) << 8) |
+                                (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+
+                case 2:
+                    if (p + 1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                                ((tail[1] & 0xff) << 8) |
+                                (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p + 3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                        ((input[p + 1] & 0xff) << 8) |
+                        (input[p + 2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op + 1] = alphabet[(v >> 12) & 0x3f];
+                output[op + 2] = alphabet[(v >> 6) & 0x3f];
+                output[op + 3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p - tailLen == len - 1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p - tailLen == len - 2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
+                    throw new AssertionError();
+                }
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len - 1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len - 2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p + 1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() {
+    }   // don't instantiate
+}
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
new file mode 100755
index 00000000..ead54c56
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -0,0 +1,9 @@
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+public class Base64DataException extends IOException {
+    public Base64DataException(String detailMessage) {
+        super(detailMessage);
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
new file mode 100755
index 00000000..231d4036
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -0,0 +1,133 @@
+package com.loopj.android.http;
+
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class Base64OutputStream extends FilterOutputStream {
+    private final Base64.Coder coder;
+    private final int flags;
+
+    private byte[] buffer = null;
+    private int bpos = 0;
+
+    private static byte[] EMPTY = new byte[0];
+
+    /**
+     * Performs Base64 encoding on the data written to the stream, writing the encoded data to
+     * another OutputStream.
+     *
+     * @param out   the OutputStream to write the encoded data to
+     * @param flags bit flags for controlling the encoder; see the constants in {@link Base64}
+     */
+    public Base64OutputStream(OutputStream out, int flags) {
+        this(out, flags, true);
+    }
+
+    /**
+     * Performs Base64 encoding or decoding on the data written to the stream, writing the
+     * encoded/decoded data to another OutputStream.
+     *
+     * @param out    the OutputStream to write the encoded data to
+     * @param flags  bit flags for controlling the encoder; see the constants in {@link Base64}
+     * @param encode true to encode, false to decode
+     */
+    public Base64OutputStream(OutputStream out, int flags, boolean encode) {
+        super(out);
+        this.flags = flags;
+        if (encode) {
+            coder = new Base64.Encoder(flags, null);
+        } else {
+            coder = new Base64.Decoder(flags, null);
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        // To avoid invoking the encoder/decoder routines for single
+        // bytes, we buffer up calls to write(int) in an internal
+        // byte array to transform them into writes of decently-sized
+        // arrays.
+
+        if (buffer == null) {
+            buffer = new byte[1024];
+        }
+        if (bpos >= buffer.length) {
+            // internal buffer full; write it out.
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+        buffer[bpos++] = (byte) b;
+    }
+
+    /**
+     * Flush any buffered data from calls to write(int).  Needed before doing a write(byte[], int,
+     * int) or a close().
+     */
+    private void flushBuffer() throws IOException {
+        if (bpos > 0) {
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        if (len <= 0) return;
+        flushBuffer();
+        internalWrite(b, off, len, false);
+    }
+
+    @Override
+    public void close() throws IOException {
+        IOException thrown = null;
+        try {
+            flushBuffer();
+            internalWrite(EMPTY, 0, 0, true);
+        } catch (IOException e) {
+            thrown = e;
+        }
+
+        try {
+            if ((flags & Base64.NO_CLOSE) == 0) {
+                out.close();
+            } else {
+                out.flush();
+            }
+        } catch (IOException e) {
+            if (thrown != null) {
+                thrown = e;
+            }
+        }
+
+        if (thrown != null) {
+            throw thrown;
+        }
+    }
+
+    /**
+     * Write the given bytes to the encoder/decoder.
+     *
+     * @param finish true if this is the last batch of input, to cause encoder/decoder state to be
+     *               finalized.
+     */
+    private void internalWrite(byte[] b, int off, int len, boolean finish) throws IOException {
+        coder.output = embiggen(coder.output, coder.maxOutputSize(len));
+        if (!coder.process(b, off, len, finish)) {
+            throw new Base64DataException("bad base-64");
+        }
+        out.write(coder.output, 0, coder.op);
+    }
+
+    /**
+     * If b.length is at least len, return b.  Otherwise return a new byte array of length len.
+     */
+    private byte[] embiggen(byte[] b, int len) {
+        if (b == null || b.length < len) {
+            return new byte[len];
+        } else {
+            return b;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
new file mode 100755
index 00000000..bc5deabd
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -0,0 +1,152 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpStatus;
+
+/**
+ * Class meant to be used with custom JSON parser (such as GSON or Jackson JSON) <p>&nbsp;</p>
+ * {@link #parseResponse(String, boolean)} should be overriden and must return type of generic param
+ * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
+ * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
+ * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ * @param <JSON_TYPE>
+ */
+public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
+    private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
+
+    /**
+     * Creates a new JsonHttpResponseHandler with default charset "UTF-8"
+     */
+    public BaseJsonHttpResponseHandler() {
+        this(DEFAULT_CHARSET);
+    }
+
+    /**
+     * Creates a new JsonHttpResponseHandler with given string encoding
+     *
+     * @param encoding result string encoding, see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
+    public BaseJsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
+
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode      HTTP status line
+     * @param headers         response headers
+     * @param rawJsonResponse string of response, can be null
+     * @param response        response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, JSON_TYPE response);
+
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode    HTTP status line
+     * @param headers       response headers
+     * @param throwable     error thrown while processing request
+     * @param rawJsonData   raw string data returned if any
+     * @param errorResponse response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, JSON_TYPE errorResponse);
+
+    @Override
+    public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
+	    Runnable parser = new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, false);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onSuccess(statusCode, headers, responseString, jsonResponse);
+                            }
+                        });
+                    } catch (final Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, t, responseString, null);
+                            }
+                        });
+                    }
+                }
+	    };
+            if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
+        } else {
+            onSuccess(statusCode, headers, null, null);
+        }
+    }
+
+    @Override
+    public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
+        if (responseString != null) {
+	    Runnable parser = new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, true);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, throwable, responseString, jsonResponse);
+                            }
+                        });
+                    } catch (Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, throwable, responseString, null);
+                            }
+                        });
+                    }
+                }
+	    };
+            if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
+        } else {
+            onFailure(statusCode, headers, throwable, null, null);
+        }
+    }
+
+    /**
+     * Should return deserialized instance of generic type, may return object for more vague
+     * handling
+     *
+     * @param rawJsonData response string, may be null
+     * @param isFailure   indicating if this method is called from onFailure or not
+     * @return object of generic type or possibly null if you choose so
+     * @throws Throwable allows you to throw anything from within deserializing JSON response
+     */
+    protected abstract JSON_TYPE parseResponse(String rawJsonData, boolean isFailure) throws Throwable;
+}
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
new file mode 100755
index 00000000..1959ec6d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -0,0 +1,125 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+
+import java.io.IOException;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+/**
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}.
+ * Receives response body as byte array with a content-type whitelist. (e.g. checks Content-Type
+ * against allowed list, Content-length). <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * String[] allowedTypes = new String[] { "image/png" };
+ * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
+ *     &#064;Override
+ *     public void onSuccess(byte[] imageData) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(Throwable e, byte[] imageData) {
+ *         // Response failed :(
+ *     }
+ * });
+ * </pre>
+ */
+public abstract class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private static final String LOG_TAG = "BinaryHttpResponseHandler";
+
+    private String[] mAllowedContentTypes = new String[]{
+            "image/jpeg",
+            "image/png"
+    };
+
+    /**
+     * Method can be overriden to return allowed content types, can be sometimes better than passing
+     * data in constructor
+     *
+     * @return array of content-types or Pattern string templates (eg. '.*' to match every response)
+     */
+    public String[] getAllowedContentTypes() {
+        return mAllowedContentTypes;
+    }
+
+    /**
+     * Creates a new BinaryHttpResponseHandler
+     */
+    public BinaryHttpResponseHandler() {
+        super();
+    }
+
+    /**
+     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed content types with
+     * passed String array (hopefully) of content types.
+     *
+     * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
+     */
+    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
+        super();
+        if (allowedContentTypes != null)
+            mAllowedContentTypes = allowedContentTypes;
+        else
+            Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
+    }
+
+    @Override
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] binaryData);
+
+    @Override
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error);
+
+    @Override
+    public final void sendResponseMessage(HttpResponse response) throws IOException {
+        StatusLine status = response.getStatusLine();
+        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        if (contentTypeHeaders.length != 1) {
+            //malformed/ambiguous HTTP Header, ABORT!
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
+            return;
+        }
+        Header contentTypeHeader = contentTypeHeaders[0];
+        boolean foundAllowedContentType = false;
+        for (String anAllowedContentType : getAllowedContentTypes()) {
+            try {
+                if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
+                    foundAllowedContentType = true;
+                }
+            } catch (PatternSyntaxException e) {
+                Log.e("BinaryHttpResponseHandler", "Given pattern is not valid: " + anAllowedContentType, e);
+            }
+        }
+        if (!foundAllowedContentType) {
+            //Content-Type not in allowed list, ABORT!
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
+            return;
+        }
+        super.sendResponseMessage(response);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..b121835d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -0,0 +1,151 @@
+package com.loopj.android.http;
+
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+import android.os.Message;
+import android.util.Log;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.util.ByteArrayBuffer;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "DataAsyncHttpResponseHandler";
+
+    protected static final int PROGRESS_DATA_MESSAGE = 6;
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public DataAsyncHttpResponseHandler() {
+        super();
+    }
+
+    /**
+     * Fired when the request progress, override to handle in your own code
+     *
+     * @param responseBody response body received so far
+     */
+    public void onProgressData(byte[] responseBody) {
+    }
+
+
+    final public void sendProgressDataMessage(byte[] responseBytes) {
+        sendMessage(obtainMessage(PROGRESS_DATA_MESSAGE, new Object[]{responseBytes}));
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    @Override
+    protected void handleMessage(Message message) {
+        super.handleMessage(message);
+        Object[] response;
+
+        switch (message.what) {
+            case PROGRESS_DATA_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 1) {
+                    try {
+                        onProgressData((byte[]) response[0]);
+                    } catch (Throwable t) {
+                        Log.e(LOG_TAG, "custom onProgressData contains an error", t);
+                    }
+                } else {
+                    Log.e(LOG_TAG, "PROGRESS_DATA_MESSAGE didn't got enough params");
+                }
+                break;
+        }
+    }
+
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
+    @Override
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            buffer.append(tmp, 0, l);
+                            sendProgressDataMessage(copyOfRange(tmp, 0, l));
+                        }
+                    } finally {
+                        AsyncHttpClient.silentCloseInputStream(instream);
+                    }
+                    responseBody = buffer.toByteArray();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
+        }
+        return responseBody;
+    }
+
+    /**
+     * Copies elements from {@code original} into a new array, from indexes start (inclusive) to end
+     * (exclusive). The original order of elements is preserved. If {@code end} is greater than
+     * {@code original.length}, the result is padded with the value {@code (byte) 0}.
+     *
+     * @param original the original array
+     * @param start    the start index, inclusive
+     * @param end      the end index, exclusive
+     * @return the new array
+     * @throws ArrayIndexOutOfBoundsException if {@code start < 0 || start > original.length}
+     * @throws IllegalArgumentException       if {@code start > end}
+     * @throws NullPointerException           if {@code original == null}
+     * @see java.util.Arrays
+     * @since 1.6
+     */
+    public static byte[] copyOfRange(byte[] original, int start, int end) throws ArrayIndexOutOfBoundsException, IllegalArgumentException, NullPointerException {
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        int originalLength = original.length;
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        int resultLength = end - start;
+        int copyLength = Math.min(resultLength, originalLength - start);
+        byte[] result = new byte[resultLength];
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+}
+
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..be48f62b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,132 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    protected final File mFile;
+    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
+
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        assert (file != null);
+        this.mFile = file;
+    }
+
+    /**
+     * Obtains new FileAsyncHttpResponseHandler against context with target being temporary file
+     *
+     * @param context Context, must not be null
+     */
+    public FileAsyncHttpResponseHandler(Context context) {
+        super();
+        this.mFile = getTemporaryFile(context);
+    }
+
+    /**
+     * Attempts to delete file with stored response
+     *
+     * @return false if the file does not exist or is null, true if it was successfully deleted
+     */
+    public boolean deleteTargetFile() {
+        return getTargetFile() != null && getTargetFile().delete();
+    }
+
+    /**
+     * Used when there is no file to be used when calling constructor
+     *
+     * @param context Context, must not be null
+     * @return temporary file or null if creating file failed
+     */
+    protected File getTemporaryFile(Context context) {
+        assert (context != null);
+        try {
+            return File.createTempFile("temp_", "_handled", context.getCacheDir());
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "Cannot create temporary file", t);
+        }
+        return null;
+    }
+
+    /**
+     * Retrieves File object in which the response is stored
+     *
+     * @return File file in which the response is stored
+     */
+    protected File getTargetFile() {
+        assert (mFile != null);
+        return mFile;
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, throwable, getTargetFile());
+    }
+
+    /**
+     * Method to be overriden, receives as much of file as possible Called when the file is
+     * considered failure or if there is error when retrieving file
+     *
+     * @param statusCode http file status line
+     * @param headers    file http headers if any
+     * @param throwable  returned throwable
+     * @param file       file in which the file is stored
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, File file);
+
+    @Override
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getTargetFile());
+    }
+
+    /**
+     * Method to be overriden, receives as much of response as possible
+     *
+     * @param statusCode http response status line
+     * @param headers    response http headers if any
+     * @param file       file in which the response is stored
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, File file);
+
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength();
+            FileOutputStream buffer = new FileOutputStream(getTargetFile());
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l, count = 0;
+                    // do not send messages if request has been cancelled
+                    while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        count += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage(count, (int) contentLength);
+                    }
+                } finally {
+                    AsyncHttpClient.silentCloseInputStream(instream);
+                    buffer.flush();
+                    AsyncHttpClient.silentCloseOutputStream(buffer);
+                }
+            }
+        }
+        return null;
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
new file mode 100755
index 00000000..63648a15
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -0,0 +1,224 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpStatus;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+/**
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
+ * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
+ * designed to be passed to get, post, put and delete requests with the {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONArray)} or {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONObject)} methods anonymously overridden. <p>&nbsp;</p>
+ * Additionally, you can override the other event methods from the parent class.
+ */
+public class JsonHttpResponseHandler extends TextHttpResponseHandler {
+    private static final String LOG_TAG = "JsonHttpResponseHandler";
+
+    /**
+     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
+     */
+    public JsonHttpResponseHandler() {
+        super(DEFAULT_CHARSET);
+    }
+
+    /**
+     * Creates new JsonHttpRespnseHandler with given Json String encoding
+     *
+     * @param encoding String encoding to be used when parsing JSON
+     */
+    public JsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
+
+    /**
+     * Returns when request succeeds
+     *
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
+     */
+    public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
+
+    }
+
+    /**
+     * Returns when request succeeds
+     *
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
+     */
+    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
+
+    }
+
+    /**
+     * Returns when request failed
+     *
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
+     */
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
+
+    }
+
+    /**
+     * Returns when request failed
+     *
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
+     */
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
+
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
+
+    }
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseString) {
+
+    }
+
+    @Override
+    public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
+	    Runnable parser = new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final Object jsonResponse = parseResponse(responseBytes);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (jsonResponse instanceof JSONObject) {
+                                    onSuccess(statusCode, headers, (JSONObject) jsonResponse);
+                                } else if (jsonResponse instanceof JSONArray) {
+                                    onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
+                                } else {
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                }
+
+                            }
+                        });
+                    } catch (final JSONException ex) {
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
+                            }
+                        });
+                    }
+                }
+	    };
+	    if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
+        } else {
+            onSuccess(statusCode, headers, new JSONObject());
+        }
+    }
+
+    @Override
+    public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
+        if (responseBytes != null) {
+	    Runnable parser = new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final Object jsonResponse = parseResponse(responseBytes);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (jsonResponse instanceof JSONObject) {
+                                    onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
+                                } else if (jsonResponse instanceof JSONArray) {
+                                    onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
+                                } else {
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                }
+                            }
+                        });
+
+                    } catch (final JSONException ex) {
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
+                            }
+                        });
+
+                    }
+                }
+	    };
+	    if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
+        } else {
+            Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
+            onFailure(statusCode, headers, throwable, (JSONObject) null);
+        }
+    }
+
+    /**
+     * Returns Object of type {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
+     * Double or {@link JSONObject#NULL}, see {@link org.json.JSONTokener#nextValue()}
+     *
+     * @param responseBody response bytes to be assembled in String and parsed as JSON
+     * @return Object parsedResponse
+     * @throws org.json.JSONException exception if thrown while parsing JSON
+     */
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
+        if (null == responseBody)
+            return null;
+        Object result = null;
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        String jsonString = getResponseString(responseBody, getCharset());
+        if (jsonString != null) {
+            jsonString = jsonString.trim();
+            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                result = new JSONTokener(jsonString).nextValue();
+            }
+        }
+        if (result == null) {
+            result = jsonString;
+        }
+        return result;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
new file mode 100755
index 00000000..6db13641
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -0,0 +1,370 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * HTTP entity to upload JSON data using streams.
+ * This has very low memory footprint; suitable for uploading large
+ * files using base64 encoding.
+ */
+class JsonStreamerEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "JsonStreamerEntity";
+
+    private static final UnsupportedOperationException ERR_UNSUPPORTED =
+        new UnsupportedOperationException("Unsupported operation in this implementation.");
+
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
+
+    // Reusable StringBuilder used by escape() method.
+    // Its size is just initial, if more space is needed, the system will
+    // automatically enlarge the buffer.
+    private static final StringBuilder BUILDER = new StringBuilder(128);
+
+    private static final byte[] JSON_TRUE = "true".getBytes();
+    private static final byte[] JSON_FALSE = "false".getBytes();
+    private static final byte[] JSON_NULL = "null".getBytes();
+    private static final byte[] STREAM_NAME = escape("name");
+    private static final byte[] STREAM_TYPE = escape("type");
+    private static final byte[] STREAM_CONTENTS = escape("contents");
+    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
+
+    private static final Header HEADER_JSON_CONTENT =
+        new BasicHeader("Content-Type", "application/json");
+    private static final Header HEADER_GZIP_ENCODING =
+        new BasicHeader("Content-Encoding", "gzip");
+
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap();
+
+    // Whether to use gzip compression while uploading
+    private final Header contentEncoding;
+
+    private final ResponseHandlerInterface progressHandler;
+
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
+    }
+
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return contentEncoding;
+    }
+
+    @Override
+    public Header getContentType() {
+        return HEADER_JSON_CONTENT;
+    }
+
+    @Override
+    public void consumeContent() throws IOException, UnsupportedOperationException {
+    }
+
+    @Override
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw ERR_UNSUPPORTED;
+    }
+
+    @Override
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
+            throw new IllegalStateException("Output stream cannot be null.");
+        }
+
+        // Record the time when uploading started.
+        long now = System.currentTimeMillis();
+
+        // Use GZIP compression when sending streams, otherwise just use
+        // a buffered output stream to speed things up a bit.
+        OutputStream os = null != contentEncoding
+          ? new GZIPOutputStream(out, BUFFER_SIZE)
+          : out;
+
+        // Always send a JSON object.
+        os.write('{');
+
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        boolean isFileWrapper;
+
+        // Go over all keys and handle each's value.
+        for (String key : keys) {
+            // Evaluate the value (which cannot be null).
+            Object value = jsonParams.get(key);
+
+            // Bail out prematurely if value's null.
+            if (value == null) {
+                continue;
+            }
+
+            // Write the JSON object's key.
+            os.write(escape(key));
+            os.write(':');
+
+            // Check if this is a FileWrapper.
+            isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+            // If a file should be uploaded.
+            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                // All uploads are sent as an object containing the file's details.
+                os.write('{');
+
+                // Determine how to handle this entry.
+                if (isFileWrapper) {
+                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                } else {
+                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                }
+
+                // End the file's object and prepare for next one.
+                os.write('}');
+            } else if (value instanceof Boolean) {
+                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            } else if (value instanceof Long) {
+                os.write((((Number)value).longValue() + "").getBytes());
+            } else if (value instanceof Double) {
+                os.write((((Number)value).doubleValue() + "").getBytes());
+            } else if (value instanceof Float) {
+                os.write((((Number)value).floatValue() + "").getBytes());
+            } else if (value instanceof Integer) {
+                os.write((((Number)value).intValue() + "").getBytes());
+            } else {
+                os.write(value.toString().getBytes());
+            }
+
+            os.write(',');
+        }
+
+        // Include the elapsed time taken to upload everything.
+        // This might be useful for somebody, but it serves us well since
+        // there will almost always be a ',' as the last sent character.
+        os.write(STREAM_ELAPSED);
+        os.write(':');
+        long elapsedTime = System.currentTimeMillis() - now;
+        os.write((elapsedTime + "}").getBytes());
+
+        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+
+        // Flush the contents up the stream.
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
+    }
+
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
+      }
+
+    // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
+    // Changed a bit to suit our needs in this class.
+    static byte[] escape(String string) {
+        // If it's null, just return prematurely.
+        if (string == null) {
+          return JSON_NULL;
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        int length = string.length(), pos = -1;
+        while (++pos < length) {
+            char ch = string.charAt(pos);
+            switch (ch) {
+                case '"':
+                    BUILDER.append("\\\"");
+                    break;
+                case '\\':
+                    BUILDER.append("\\\\");
+                    break;
+                case '\b':
+                    BUILDER.append("\\b");
+                    break;
+                case '\f':
+                    BUILDER.append("\\f");
+                    break;
+                case '\n':
+                    BUILDER.append("\\n");
+                    break;
+                case '\r':
+                    BUILDER.append("\\r");
+                    break;
+                case '\t':
+                    BUILDER.append("\\t");
+                    break;
+                default:
+                    // Reference: http://www.unicode.org/versions/Unicode5.1.0/
+                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                        String intString = Integer.toHexString(ch);
+                        BUILDER.append("\\u");
+                        int intLength = 4 - intString.length();
+                        for (int zero = 0; zero < intLength; zero++) {
+                            BUILDER.append('0');
+                        }
+                        BUILDER.append(intString.toUpperCase(Locale.US));
+                    } else {
+                        BUILDER.append(ch);
+                    }
+                    break;
+            }
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        try {
+            return BUILDER.toString().getBytes();
+        } finally {
+            // Empty the String buffer.
+            // This is 20-30% faster than instantiating a new object.
+            BUILDER.setLength(0);
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
new file mode 100644
index 00000000..5ad3402b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -0,0 +1,141 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.ProtocolException;
+import org.apache.http.client.CircularRedirectException;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.utils.URIUtils;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.client.RedirectLocations;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+// taken from: https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception
+class MyRedirectHandler extends DefaultRedirectHandler {
+
+    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
+    private final boolean enableRedirects;
+
+    public MyRedirectHandler(final boolean allowRedirects) {
+        super();
+        this.enableRedirects = allowRedirects;
+    }
+
+    public boolean isRedirectRequested(
+            final HttpResponse response,
+            final HttpContext context) {
+        if (!enableRedirects) {
+            return false;
+        }
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        int statusCode = response.getStatusLine().getStatusCode();
+        switch (statusCode) {
+            case HttpStatus.SC_MOVED_TEMPORARILY:
+            case HttpStatus.SC_MOVED_PERMANENTLY:
+            case HttpStatus.SC_SEE_OTHER:
+            case HttpStatus.SC_TEMPORARY_REDIRECT:
+                return true;
+            default:
+                return false;
+        } //end of switch
+    }
+
+    public URI getLocationURI(
+            final HttpResponse response,
+            final HttpContext context) throws ProtocolException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        //get the location header to find out where to redirect to
+        Header locationHeader = response.getFirstHeader("location");
+        if (locationHeader == null) {
+            // got a redirect response, but no location header
+            throw new ProtocolException(
+                    "Received redirect response " + response.getStatusLine()
+                            + " but no location header"
+            );
+        }
+//HERE IS THE MODIFIED LINE OF CODE
+        String location = locationHeader.getValue().replaceAll(" ", "%20");
+
+        URI uri;
+        try {
+            uri = new URI(location);
+        } catch (URISyntaxException ex) {
+            throw new ProtocolException("Invalid redirect URI: " + location, ex);
+        }
+
+        HttpParams params = response.getParams();
+        // rfc2616 demands the location value be a complete URI
+        // Location       = "Location" ":" absoluteURI
+        if (!uri.isAbsolute()) {
+            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
+                throw new ProtocolException("Relative redirect location '"
+                        + uri + "' not allowed");
+            }
+            // Adjust location URI
+            HttpHost target = (HttpHost) context.getAttribute(
+                    ExecutionContext.HTTP_TARGET_HOST);
+            if (target == null) {
+                throw new IllegalStateException("Target host not available " +
+                        "in the HTTP context");
+            }
+
+            HttpRequest request = (HttpRequest) context.getAttribute(
+                    ExecutionContext.HTTP_REQUEST);
+
+            try {
+                URI requestURI = new URI(request.getRequestLine().getUri());
+                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
+                uri = URIUtils.resolve(absoluteRequestURI, uri);
+            } catch (URISyntaxException ex) {
+                throw new ProtocolException(ex.getMessage(), ex);
+            }
+        }
+
+        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
+
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
+                    REDIRECT_LOCATIONS);
+
+            if (redirectLocations == null) {
+                redirectLocations = new RedirectLocations();
+                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
+            }
+
+            URI redirectURI;
+            if (uri.getFragment() != null) {
+                try {
+                    HttpHost target = new HttpHost(
+                            uri.getHost(),
+                            uri.getPort(),
+                            uri.getScheme());
+                    redirectURI = URIUtils.rewriteURI(uri, target, true);
+                } catch (URISyntaxException ex) {
+                    throw new ProtocolException(ex.getMessage(), ex);
+                }
+            } else {
+                redirectURI = uri;
+            }
+
+            if (redirectLocations.contains(redirectURI)) {
+                throw new CircularRedirectException("Circular redirect to '" +
+                        redirectURI + "'");
+            } else {
+                redirectLocations.add(redirectURI);
+            }
+        }
+
+        return uri;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
new file mode 100755
index 00000000..4c4df9ce
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -0,0 +1,182 @@
+package com.loopj.android.http;
+
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Socket;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
+ * http://code.google.com/p/android/issues/detail?id=13117#c14 <p>&nbsp;</p> Warning! This omits SSL
+ * certificate validation on every device, use with caution
+ */
+public class MySSLSocketFactory extends SSLSocketFactory {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+
+    /**
+     * Creates a new SSL Socket Factory with the given KeyStore.
+     *
+     * @param truststore A KeyStore to create the SSL Socket Factory in context of
+     */
+    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
+        super(truststore);
+
+        X509TrustManager tm = new X509TrustManager() {
+            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            }
+
+            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            }
+
+            public X509Certificate[] getAcceptedIssuers() {
+                return null;
+            }
+        };
+
+        sslContext.init(null, new TrustManager[]{tm}, null);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
+        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslContext.getSocketFactory().createSocket();
+    }
+
+    /**
+     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
+     */
+    public void fixHttpsURLConnection() {
+        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+    }
+
+    /**
+     * Gets a KeyStore containing the Certificate
+     *
+     * @param cert InputStream of the Certificate
+     * @return KeyStore
+     */
+    public static KeyStore getKeystoreOfCA(InputStream cert) {
+
+        // Load CAs from an InputStream
+        InputStream caInput = null;
+        Certificate ca = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            caInput = new BufferedInputStream(cert);
+            ca = cf.generateCertificate(caInput);
+        } catch (CertificateException e1) {
+            e1.printStackTrace();
+        } finally {
+            try {
+                if (caInput != null) {
+                    caInput.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Create a KeyStore containing our trusted CAs
+        String keyStoreType = KeyStore.getDefaultType();
+        KeyStore keyStore = null;
+        try {
+            keyStore = KeyStore.getInstance(keyStoreType);
+            keyStore.load(null, null);
+            keyStore.setCertificateEntry("ca", ca);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return keyStore;
+    }
+
+    /**
+     * Gets a Default KeyStore
+     *
+     * @return KeyStore
+     */
+    public static KeyStore getKeystore() {
+        KeyStore trustStore = null;
+        try {
+            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            trustStore.load(null, null);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+        return trustStore;
+    }
+
+    /**
+     * Returns a SSlSocketFactory which trusts all certificates
+     *
+     * @return SSLSocketFactory
+     */
+    public static SSLSocketFactory getFixedSocketFactory() {
+        SSLSocketFactory socketFactory;
+        try {
+            socketFactory = new MySSLSocketFactory(getKeystore());
+            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+        } catch (Throwable t) {
+            t.printStackTrace();
+            socketFactory = SSLSocketFactory.getSocketFactory();
+        }
+        return socketFactory;
+    }
+
+    /**
+     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
+     *
+     * @param keyStore custom provided KeyStore instance
+     * @return DefaultHttpClient
+     */
+    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+
+        try {
+            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+            registry.register(new Scheme("https", sf, 443));
+
+            HttpParams params = new BasicHttpParams();
+            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+
+            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+
+            return new DefaultHttpClient(ccm, params);
+        } catch (Exception e) {
+            return new DefaultHttpClient();
+        }
+    }
+
+}
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
old mode 100644
new mode 100755
similarity index 56%
rename from src/com/loopj/android/http/PersistentCookieStore.java
rename to library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 11b2a2bf..2e0fdb8d
--- a/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -18,6 +18,14 @@
 
 package com.loopj.android.http;
 
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.apache.http.client.CookieStore;
+import org.apache.http.cookie.Cookie;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
@@ -25,49 +33,44 @@
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.client.CookieStore;
-import org.apache.http.cookie.Cookie;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.text.TextUtils;
-
 /**
- * A persistent cookie store which implements the Apache HttpClient
- * {@link CookieStore} interface. Cookies are stored and will persist on the
- * user's device between application sessions since they are serialized and
- * stored in {@link SharedPreferences}.
- * <p>
- * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
+ * A persistent cookie store which implements the Apache HttpClient {@link CookieStore} interface.
+ * Cookies are stored and will persist on the user's device between application sessions since they
+ * are serialized and stored in {@link SharedPreferences}. <p>&nbsp;</p> Instances of this class are
+ * designed to be used with {@link AsyncHttpClient#setCookieStore}, but can also be used with a
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
+    private static final String LOG_TAG = "PersistentCookieStore";
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
+    private boolean omitNonPersistentCookies = false;
 
     private final ConcurrentHashMap<String, Cookie> cookies;
     private final SharedPreferences cookiePrefs;
 
     /**
      * Construct a persistent cookie store.
+     *
+     * @param context Context to attach cookie store to
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
+        cookies = new ConcurrentHashMap();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if(storedCookieNames != null) {
+        if (storedCookieNames != null) {
             String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for(String name : cookieNames) {
+            for (String name : cookieNames) {
                 String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if(encodedCookie != null) {
+                if (encodedCookie != null) {
                     Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if(decodedCookie != null) {
+                    if (decodedCookie != null) {
                         cookies.put(name, decodedCookie);
                     }
                 }
@@ -80,10 +83,12 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
+        if (omitNonPersistentCookies && !cookie.isPersistent())
+            return;
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
-        if(!cookie.isExpired(new Date())) {
+        if (!cookie.isExpired(new Date())) {
             cookies.put(name, cookie);
         } else {
             cookies.remove(name);
@@ -100,7 +105,7 @@ public void addCookie(Cookie cookie) {
     public void clear() {
         // Clear cookies from persistent store
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for(String name : cookies.keySet()) {
+        for (String name : cookies.keySet()) {
             prefsWriter.remove(COOKIE_NAME_PREFIX + name);
         }
         prefsWriter.remove(COOKIE_NAME_STORE);
@@ -115,10 +120,10 @@ public boolean clearExpired(Date date) {
         boolean clearedAny = false;
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
 
-        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
             String name = entry.getKey();
             Cookie cookie = entry.getValue();
-            if(cookie.isExpired(date)) {
+            if (cookie.isExpired(date)) {
                 // Clear cookies from local store
                 cookies.remove(name);
 
@@ -131,7 +136,7 @@ public boolean clearExpired(Date date) {
         }
 
         // Update names in persistent store
-        if(clearedAny) {
+        if (clearedAny) {
             prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
         }
         prefsWriter.commit();
@@ -141,15 +146,41 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
+        return new ArrayList(cookies.values());
     }
 
+    /**
+     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
+     * signature (`Cookie.isPersistent`)
+     *
+     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
+     */
+    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
+        this.omitNonPersistentCookies = omitNonPersistentCookies;
+    }
 
-    //
-    // Cookie serialization/deserialization
-    //
+    /**
+     * Non-standard helper method, to delete cookie
+     *
+     * @param cookie cookie to be removed
+     */
+    public void deleteCookie(Cookie cookie) {
+        String name = cookie.getName();
+        cookies.remove(name);
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        prefsWriter.commit();
+    }
 
+    /**
+     * Serializes Cookie object into String
+     *
+     * @param cookie cookie to be encoded, can be null
+     * @return cookie encoded as String
+     */
     protected String encodeCookie(SerializableCookie cookie) {
+        if (cookie == null)
+            return null;
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
@@ -161,39 +192,56 @@ protected String encodeCookie(SerializableCookie cookie) {
         return byteArrayToHexString(os.toByteArray());
     }
 
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+    /**
+     * Returns cookie decoded from cookie string
+     *
+     * @param cookieString string of cookie as returned from http request
+     * @return decoded cookie or null if exception occured
+     */
+    protected Cookie decodeCookie(String cookieString) {
+        byte[] bytes = hexStringToByteArray(cookieString);
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-           ObjectInputStream ois = new ObjectInputStream(is);
-           cookie = ((SerializableCookie)ois.readObject()).getCookie();
-        } catch (Exception e) {
-           e.printStackTrace();
+            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
+            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
+        } catch (Exception exception) {
+            Log.d(LOG_TAG, "decodeCookie failed", exception);
         }
 
         return cookie;
     }
 
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuffer sb = new StringBuffer(b.length * 2);
-        for (byte element : b) {
+    /**
+     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any
+     * large Base64 libraries. Can be overridden if you like!
+     *
+     * @param bytes byte array to be converted
+     * @return string containing hex values
+     */
+    protected String byteArrayToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        for (byte element : bytes) {
             int v = element & 0xff;
-            if(v < 16) {
+            if (v < 16) {
                 sb.append('0');
             }
             sb.append(Integer.toHexString(v));
         }
-        return sb.toString().toUpperCase();
+        return sb.toString().toUpperCase(Locale.US);
     }
 
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
+    /**
+     * Converts hex values from strings to byte arra
+     *
+     * @param hexString string of hex-encoded values
+     * @return decoded byte array
+     */
+    protected byte[] hexStringToByteArray(String hexString) {
+        int len = hexString.length();
         byte[] data = new byte[len / 2];
-        for(int i=0; i<len; i+=2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
new file mode 100755
index 00000000..6f3756cf
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -0,0 +1,36 @@
+package com.loopj.android.http;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+public class PreemtiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
+
+    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                ClientContext.CREDS_PROVIDER);
+        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+        if (authState.getAuthScheme() == null) {
+            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+            Credentials creds = credsProvider.getCredentials(authScope);
+            if (creds != null) {
+                authState.setAuthScheme(new BasicScheme());
+                authState.setCredentials(creds);
+            }
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..f6348da4
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -0,0 +1,95 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
+	private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+
+	private long current = 0;
+	private boolean append = false;
+
+	/**
+	 * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+	 * 
+	 * @param file File to store response within, must not be null
+	 */
+	public RangeFileAsyncHttpResponseHandler(File file) {
+		super(file);
+	}
+
+	@Override
+	public void sendResponseMessage(HttpResponse response) throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			StatusLine status = response.getStatusLine();
+			if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE){
+				//already finished
+				if (!Thread.currentThread().isInterrupted())
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+			}
+			else if (status.getStatusCode() >= 300) {
+				if (!Thread.currentThread().isInterrupted())
+					sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+			}
+			else {
+				if (!Thread.currentThread().isInterrupted()) {
+					Header header = response.getFirstHeader("Content-Range");
+					if (header == null) {
+						append = false;
+						current = 0;
+					}
+					else
+						Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+				}
+			}
+		}
+	}
+
+	@Override
+	protected byte[] getResponseData(HttpEntity entity) throws IOException {
+		if (entity != null) {
+			InputStream instream = entity.getContent();
+			long contentLength = entity.getContentLength() + current;
+			FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+			if (instream != null) {
+				try {
+					byte[] tmp = new byte[BUFFER_SIZE];
+					int l;
+					while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted())
+					{
+						current += l;
+						buffer.write(tmp, 0, l);
+						sendProgressMessage((int)current, (int)contentLength);
+					}
+				} finally {
+					instream.close();
+					buffer.flush();
+					buffer.close();
+				}
+			}
+		}
+		return null;
+	}
+
+	public void updateRequestHeaders(HttpUriRequest uriRequest) {
+		if (mFile.exists() && mFile.canWrite())
+			current = mFile.length();
+		if (current > 0) {
+			append = true;
+			uriRequest.setHeader("Range", "bytes=" + current + "-");
+		}
+	}
+}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
new file mode 100755
index 00000000..a35aa634
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -0,0 +1,62 @@
+package com.loopj.android.http;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * A Handle to an AsyncRequest which can be used to cancel a running request.
+ */
+public class RequestHandle {
+    private final WeakReference<AsyncHttpRequest> request;
+
+    public RequestHandle(AsyncHttpRequest request) {
+        this.request = new WeakReference(request);
+    }
+
+    /**
+     * Attempts to cancel this request. This attempt will fail if the request has already completed,
+     * has already been cancelled, or could not be cancelled for some other reason. If successful,
+     * and this request has not started when cancel is called, this request should never run. If the
+     * request has already started, then the mayInterruptIfRunning parameter determines whether the
+     * thread executing this request should be interrupted in an attempt to stop the request.
+     * <p>&nbsp;</p> After this method returns, subsequent calls to isDone() will always return
+     * true. Subsequent calls to isCancelled() will always return true if this method returned
+     * true.
+     *
+     * @param mayInterruptIfRunning true if the thread executing this request should be interrupted;
+     *                              otherwise, in-progress requests are allowed to complete
+     * @return false if the request could not be cancelled, typically because it has already
+     * completed normally; true otherwise
+     */
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.cancel(mayInterruptIfRunning);
+    }
+
+    /**
+     * Returns true if this task completed. Completion may be due to normal termination, an
+     * exception, or cancellation -- in all of these cases, this method will return true.
+     *
+     * @return true if this task completed
+     */
+    public boolean isFinished() {
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isDone();
+    }
+
+    /**
+     * Returns true if this task was cancelled before it completed normally.
+     *
+     * @return true if this task was cancelled before it completed
+     */
+    public boolean isCancelled() {
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isCancelled();
+    }
+
+    public boolean shouldBeGarbageCollected() {
+        boolean should = isCancelled() || isFinished();
+        if (should)
+            request.clear();
+        return should;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
new file mode 100755
index 00000000..a6fdab8d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -0,0 +1,571 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.protocol.HTTP;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A collection of string request parameters or files to send along with requests made from an
+ * {@link AsyncHttpClient} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * RequestParams params = new RequestParams();
+ * params.put("username", "james");
+ * params.put("password", "123456");
+ * params.put("email", "my&#064;email.com");
+ * params.put("profile_picture", new File("pic.jpg")); // Upload a File
+ * params.put("profile_picture2", someInputStream); // Upload an InputStream
+ * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
+ *
+ * Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
+ * map.put("first_name", "James");
+ * map.put("last_name", "Smith");
+ * params.put("user", map); // url params: "user[first_name]=James&amp;user[last_name]=Smith"
+ *
+ * Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // unordered collection
+ * set.add("music");
+ * set.add("art");
+ * params.put("like", set); // url params: "like=music&amp;like=art"
+ *
+ * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
+ * list.add("Java");<>
+ * list.add("C");
+ * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
+ *
+ * String[] colors = { "blue", "yellow" }; // Ordered collection
+ * params.put("colors", colors); // url params: "colors[]=blue&amp;colors[]=yellow"
+ *
+ * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String,
+ * String&gt;&gt;();
+ * Map&lt;String, String&gt; user1 = new HashMap&lt;String, String&gt;();
+ * user1.put("age", "30");
+ * user1.put("gender", "male");
+ * Map&lt;String, String&gt; user2 = new HashMap&lt;String, String&gt;();
+ * user2.put("age", "25");
+ * user2.put("gender", "female");
+ * listOfMaps.add(user1);
+ * listOfMaps.add(user2);
+ * params.put("users", listOfMaps); // url params: "users[][age]=30&amp;users[][gender]=male&amp;users[][age]=25&amp;users[][gender]=female"
+ *
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.post("http://myendpoint.com", params, responseHandler);
+ * </pre>
+ */
+public class RequestParams {
+
+    public final static String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
+    protected final static String LOG_TAG = "RequestParams";
+    protected boolean isRepeatable;
+    protected boolean useJsonStreamer;
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
+    protected String contentEncoding = HTTP.UTF_8;
+
+    /**
+     * Sets content encoding for return value of {@link #getParamString()} and {@link
+     * #createFormEntity()} <p>&nbsp;</p> Default encoding is "UTF-8"
+     *
+     * @param encoding String constant from {@link org.apache.http.protocol.HTTP}
+     */
+    public void setContentEncoding(final String encoding) {
+        if (encoding != null)
+            this.contentEncoding = encoding;
+        else
+            Log.d(LOG_TAG, "setContentEncoding called with null attribute");
+    }
+
+    /**
+     * Constructs a new empty {@code RequestParams} instance.
+     */
+    public RequestParams() {
+        this((Map<String, String>) null);
+    }
+
+    /**
+     * Constructs a new RequestParams instance containing the key/value string params from the
+     * specified map.
+     *
+     * @param source the source key/value string map to add.
+     */
+    public RequestParams(Map<String, String> source) {
+        if (source != null) {
+            for (Map.Entry<String, String> entry : source.entrySet()) {
+                put(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with a single initial key/value
+     * string param.
+     *
+     * @param key   the key name for the intial param.
+     * @param value the value string for the initial param.
+     */
+    public RequestParams(final String key, final String value) {
+        this(new HashMap<String, String>() {{
+            put(key, value);
+        }});
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with multiple initial key/value
+     * string param.
+     *
+     * @param keysAndValues a sequence of keys and values. Objects are automatically converted to
+     *                      Strings (including the value {@code null}).
+     * @throws IllegalArgumentException if the number of arguments isn't even.
+     */
+    public RequestParams(Object... keysAndValues) {
+        int len = keysAndValues.length;
+        if (len % 2 != 0)
+            throw new IllegalArgumentException("Supplied arguments must be even");
+        for (int i = 0; i < len; i += 2) {
+            String key = String.valueOf(keysAndValues[i]);
+            String val = String.valueOf(keysAndValues[i + 1]);
+            put(key, val);
+        }
+    }
+
+    /**
+     * Adds a key/value string pair to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value string for the new param.
+     */
+    public void put(String key, String value) {
+        if (key != null && value != null) {
+            urlParams.put(key, value);
+        }
+    }
+
+    /**
+     * Adds a file to the request.
+     *
+     * @param key  the key name for the new param.
+     * @param file the file to add.
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
+     */
+    public void put(String key, File file) throws FileNotFoundException {
+        put(key, file, null);
+    }
+
+    /**
+     * Adds a file to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param file        the file to add.
+     * @param contentType the content type of the file, eg. application/json
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
+     */
+    public void put(String key, File file, String contentType) throws FileNotFoundException {
+        if (file == null || !file.exists()) {
+            throw new FileNotFoundException();
+        }
+        if (key != null) {
+            fileParams.put(key, new FileWrapper(file, contentType));
+        }
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key    the key name for the new param.
+     * @param stream the input stream to add.
+     */
+    public void put(String key, InputStream stream) {
+        put(key, stream, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key    the key name for the new param.
+     * @param stream the input stream to add.
+     * @param name   the name of the stream.
+     */
+    public void put(String key, InputStream stream, String name) {
+        put(key, stream, name, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     */
+    public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
+        if (key != null && stream != null) {
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
+        }
+    }
+
+    /**
+     * Adds param with non-string value (e.g. Map, List, Set).
+     *
+     * @param key   the key name for the new param.
+     * @param value the non-string value object for the new param.
+     */
+    public void put(String key, Object value) {
+        if (key != null && value != null) {
+            urlParamsWithObjects.put(key, value);
+        }
+    }
+
+    /**
+     * Adds a int value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value int for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds a long value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value long for the new param.
+     */
+    public void put(String key, long value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds string value to param which can have more than one value.
+     *
+     * @param key   the key name for the param, either existing or new.
+     * @param value the value string for the new param.
+     */
+    public void add(String key, String value) {
+        if (key != null && value != null) {
+            Object params = urlParamsWithObjects.get(key);
+            if (params == null) {
+                // Backward compatible, which will result in "k=v1&k=v2&k=v3"
+                params = new HashSet<String>();
+                this.put(key, params);
+            }
+            if (params instanceof List) {
+                ((List) params).add(value);
+            } else if (params instanceof Set) {
+                ((Set) params).add(value);
+            }
+        }
+    }
+
+    /**
+     * Removes a parameter from the request.
+     *
+     * @param key the key name for the parameter to remove.
+     */
+    public void remove(String key) {
+        urlParams.remove(key);
+        streamParams.remove(key);
+        fileParams.remove(key);
+        urlParamsWithObjects.remove(key);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append(entry.getValue());
+        }
+
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("STREAM");
+        }
+
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("FILE");
+        }
+
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(kv.getName());
+            result.append("=");
+            result.append(kv.getValue());
+        }
+
+        return result.toString();
+    }
+
+    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
+        this.isRepeatable = isRepeatable;
+    }
+
+    public void setUseJsonStreamer(boolean useJsonStreamer) {
+        this.useJsonStreamer = useJsonStreamer;
+    }
+
+    /**
+     * Set global flag which determines whether to automatically close input
+     * streams on successful upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
+     *
+     * @param progressHandler HttpResponseHandler for reporting progress on entity submit
+     * @return HttpEntity resulting HttpEntity to be included along with {@link
+     * org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
+     * @throws IOException if one of the streams cannot be read
+     */
+    public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        if (useJsonStreamer) {
+            return createJsonStreamerEntity(progressHandler);
+        } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
+            return createFormEntity();
+        } else {
+            return createMultipartEntity(progressHandler);
+        }
+    }
+
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty());
+
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add non-string params
+        for (ConcurrentHashMap.Entry<String, Object> entry : urlParamsWithObjects.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(),
+                    StreamWrapper.newInstance(
+                        stream.inputStream,
+                        stream.name,
+                        stream.contentType,
+                        stream.autoClose));
+            }
+        }
+
+        return entity;
+    }
+
+    private HttpEntity createFormEntity() {
+        try {
+            return new UrlEncodedFormEntity(getParamsList(), contentEncoding);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, "createFormEntity failed", e);
+            return null; // Can happen, if the 'contentEncoding' won't be HTTP.UTF_8
+        }
+    }
+
+    private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
+        entity.setIsRepeatable(isRepeatable);
+
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add non-string params
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
+            entity.addPart(kv.getName(), kv.getValue());
+        }
+
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
+                        stream.contentType);
+            }
+        }
+
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+        }
+
+        return entity;
+    }
+
+    protected List<BasicNameValuePair> getParamsList() {
+        List<BasicNameValuePair> lparams = new LinkedList();
+
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
+        }
+
+        lparams.addAll(getParamsList(null, urlParamsWithObjects));
+
+        return lparams;
+    }
+
+    private List<BasicNameValuePair> getParamsList(String key, Object value) {
+        List<BasicNameValuePair> params = new LinkedList();
+        if (value instanceof Map) {
+            Map map = (Map) value;
+            List list = new ArrayList<Object>(map.keySet());
+            // Ensure consistent ordering in query string
+            Collections.sort(list);
+            for (Object nestedKey : list) {
+                if (nestedKey instanceof String) {
+                    Object nestedValue = map.get(nestedKey);
+                    if (nestedValue != null) {
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
+                                nestedValue));
+                    }
+                }
+            }
+        } else if (value instanceof List) {
+            List list = (List) value;
+            int listSize = list.size();
+            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
+            }
+        } else if (value instanceof Object[]) {
+            Object[] array = (Object[]) value;
+            int arrayLength = array.length;
+            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
+            }
+        } else if (value instanceof Set) {
+            Set set = (Set) value;
+            for (Object nestedValue : set) {
+                params.addAll(getParamsList(key, nestedValue));
+            }
+        } else {
+            params.add(new BasicNameValuePair(key, value.toString()));
+        }
+        return params;
+    }
+
+    protected String getParamString() {
+        return URLEncodedUtils.format(getParamsList(), contentEncoding);
+    }
+
+    public static class FileWrapper {
+        public final File file;
+        public final String contentType;
+
+        public FileWrapper(File file, String contentType) {
+            this.file = file;
+            this.contentType = contentType;
+        }
+    }
+
+    public static class StreamWrapper {
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
+
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            this.inputStream = inputStream;
+            this.name = name;
+            this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                inputStream,
+                name,
+                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                autoClose);
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
new file mode 100755
index 00000000..fe5eacc0
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -0,0 +1,112 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.net.URI;
+
+/**
+ * Interface to standardize implementations
+ */
+public interface ResponseHandlerInterface {
+
+    /**
+     * Returns data whether request completed successfully
+     *
+     * @param response HttpResponse object with data
+     * @throws java.io.IOException if retrieving data from response fails
+     */
+    void sendResponseMessage(HttpResponse response) throws IOException;
+
+    /**
+     * Notifies callback, that request started execution
+     */
+    void sendStartMessage();
+
+    /**
+     * Notifies callback, that request was completed and is being removed from thread pool
+     */
+    void sendFinishMessage();
+
+    /**
+     * Notifies callback, that request (mainly uploading) has progressed
+     *
+     * @param bytesWritten number of written bytes
+     * @param bytesTotal   number of total bytes to be written
+     */
+    void sendProgressMessage(int bytesWritten, int bytesTotal);
+
+    /**
+     * Notifies callback, that request was cancelled
+     */
+    void sendCancelMessage();
+
+    /**
+     * Notifies callback, that request was handled successfully
+     *
+     * @param statusCode   HTTP status code
+     * @param headers      returned headers
+     * @param responseBody returned data
+     */
+    void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody);
+
+    /**
+     * Returns if request was completed with error code or failure of implementation
+     *
+     * @param statusCode   returned HTTP status code
+     * @param headers      returned headers
+     * @param responseBody returned data
+     * @param error        cause of request failure
+     */
+    void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
+
+    /**
+     * Notifies callback of retrying request
+     *
+     * @param retryNo number of retry within one request
+     */
+    void sendRetryMessage(int retryNo);
+
+    /**
+     * Returns URI which was used to request
+     *
+     * @return uri of origin request
+     */
+    public URI getRequestURI();
+
+    /**
+     * Returns Header[] which were used to request
+     *
+     * @return headers from origin request
+     */
+    public Header[] getRequestHeaders();
+
+    /**
+     * Helper for handlers to receive Request URI info
+     *
+     * @param requestURI claimed request URI
+     */
+    public void setRequestURI(URI requestURI);
+
+    /**
+     * Helper for handlers to receive Request Header[] info
+     *
+     * @param requestHeaders Headers, claimed to be from original request
+     */
+    public void setRequestHeaders(Header[] requestHeaders);
+
+    /**
+     * Can set, whether the handler should be asynchronous or synchronous
+     *
+     * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
+     */
+    void setUseSynchronousMode(boolean useSynchronousMode);
+
+    /**
+     * Returns whether the handler is asynchronous or synchronous
+     *
+     * @return boolean if the ResponseHandler is running in synchronous mode
+     */
+    boolean getUseSynchronousMode();
+}
diff --git a/src/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
old mode 100644
new mode 100755
similarity index 76%
rename from src/com/loopj/android/http/RetryHandler.java
rename to library/src/main/java/com/loopj/android/http/RetryHandler.java
index 5256aad2..a6968667
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -23,14 +23,7 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.util.HashSet;
-import java.util.Iterator;
-
-import javax.net.ssl.SSLException;
+import android.os.SystemClock;
 
 import org.apache.http.NoHttpResponseException;
 import org.apache.http.client.HttpRequestRetryHandler;
@@ -38,12 +31,17 @@
 import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 
-import android.os.SystemClock;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.HashSet;
+
+import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
 
     static {
         // Retry if the server dropped connection on us
@@ -60,9 +58,11 @@
     }
 
     private final int maxRetries;
+    private final int retrySleepTimeMS;
 
-    public RetryHandler(int maxRetries) {
+    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
         this.maxRetries = maxRetries;
+        this.retrySleepTimeMS = retrySleepTimeMS;
     }
 
     @Override
@@ -70,45 +70,53 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         boolean retry = true;
 
         Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
+        boolean sent = (b != null && b);
 
-        if(executionCount > maxRetries) {
+        if (executionCount > maxRetries) {
             // Do not retry if over max retry count
             retry = false;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
         } else if (isInList(exceptionWhitelist, exception)) {
             // immediately retry if error is whitelisted
             retry = true;
+        } else if (isInList(exceptionBlacklist, exception)) {
+            // immediately cancel retry if the error is blacklisted
+            retry = false;
         } else if (!sent) {
             // for most other errors, retry only if request hasn't been fully sent yet
             retry = true;
         }
 
-        if(retry) {
+        if (retry) {
             // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
+            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
+            if (currentReq == null) {
+                return false;
+            }
         }
 
-        if(retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+        if (retry) {
+            SystemClock.sleep(retrySleepTimeMS);
         } else {
             exception.printStackTrace();
         }
 
         return retry;
     }
-    
+
+    static void addClassToWhitelist(Class<?> cls) {
+        exceptionWhitelist.add(cls);
+    }
+
+    static void addClassToBlacklist(Class<?> cls) {
+        exceptionBlacklist.add(cls);
+    }
+
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-    	Iterator<Class<?>> itr = list.iterator();
-    	while (itr.hasNext()) {
-    		if (itr.next().isInstance(error)) {
-    			return true;
-    		}
-    	}
-    	return false;
+        for (Class<?> aList : list) {
+            if (aList.isInstance(error)) {
+                return true;
+            }
+        }
+        return false;
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
old mode 100644
new mode 100755
similarity index 83%
rename from src/com/loopj/android/http/SerializableCookie.java
rename to library/src/main/java/com/loopj/android/http/SerializableCookie.java
index cc12993c..855105b1
--- a/src/com/loopj/android/http/SerializableCookie.java
+++ b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
@@ -18,18 +18,18 @@
 
 package com.loopj.android.http;
 
-import java.io.Serializable;
+import org.apache.http.cookie.Cookie;
+import org.apache.http.impl.cookie.BasicClientCookie;
+
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import java.io.IOException;
+import java.io.Serializable;
 import java.util.Date;
 
-import org.apache.http.cookie.Cookie;
-import org.apache.http.impl.cookie.BasicClientCookie;
-
 /**
- * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
- * designed for use in {@link PersistentCookieStore}.
+ * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie} designed for use in {@link
+ * PersistentCookieStore}.
  */
 public class SerializableCookie implements Serializable {
     private static final long serialVersionUID = 6374381828722046732L;
@@ -43,7 +43,7 @@ public SerializableCookie(Cookie cookie) {
 
     public Cookie getCookie() {
         Cookie bestCookie = cookie;
-        if(clientCookie != null) {
+        if (clientCookie != null) {
             bestCookie = clientCookie;
         }
         return bestCookie;
@@ -61,13 +61,13 @@ private void writeObject(ObjectOutputStream out) throws IOException {
     }
 
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String)in.readObject();
-        String value = (String)in.readObject();
+        String name = (String) in.readObject();
+        String value = (String) in.readObject();
         clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String)in.readObject());
-        clientCookie.setDomain((String)in.readObject());
-        clientCookie.setExpiryDate((Date)in.readObject());
-        clientCookie.setPath((String)in.readObject());
+        clientCookie.setComment((String) in.readObject());
+        clientCookie.setDomain((String) in.readObject());
+        clientCookie.setExpiryDate((Date) in.readObject());
+        clientCookie.setPath((String) in.readObject());
         clientCookie.setVersion(in.readInt());
         clientCookie.setSecure(in.readBoolean());
     }
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
new file mode 100755
index 00000000..bffdf740
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -0,0 +1,283 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+/*
+    This code is taken from Rafael Sanches' blog.
+    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Simplified multipart entity mainly used for sending one or more files.
+ */
+class SimpleMultipartEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "SimpleMultipartEntity";
+
+    private static final String STR_CR_LF = "\r\n";
+    private static final byte[] CR_LF = STR_CR_LF.getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY =
+        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
+
+    private final static char[] MULTIPART_CHARS =
+        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+
+    private final String boundary;
+    private final byte[] boundaryLine;
+    private final byte[] boundaryEnd;
+    private boolean isRepeatable;
+
+    private final List<FilePart> fileParts = new ArrayList();
+
+    // The buffer we use for building the message excluding files and the last
+    // boundary
+    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    private final ResponseHandlerInterface progressHandler;
+
+    private int bytesWritten;
+
+    private int totalSize;
+
+    public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
+        final StringBuilder buf = new StringBuilder();
+        final Random rand = new Random();
+        for (int i = 0; i < 30; i++) {
+            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
+        }
+
+        boundary = buf.toString();
+        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
+        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
+
+        this.progressHandler = progressHandler;
+    }
+
+    public void addPart(String key, String value, String contentType) {
+        try {
+            out.write(boundaryLine);
+            out.write(createContentDisposition(key));
+            out.write(createContentType(contentType));
+            out.write(CR_LF);
+            out.write(value.getBytes());
+            out.write(CR_LF);
+        } catch (final IOException e) {
+            // Shall not happen on ByteArrayOutputStream
+            Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
+        }
+    }
+
+    public void addPart(String key, String value) {
+        addPart(key, value, "text/plain; charset=UTF-8");
+    }
+
+    public void addPart(String key, File file) {
+        addPart(key, file, null);
+    }
+
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
+    }
+
+    public void addPart(String key, String streamName, InputStream inputStream, String type)
+            throws IOException {
+
+        out.write(boundaryLine);
+
+        // Headers
+        out.write(createContentDisposition(key, streamName));
+        out.write(createContentType(type));
+        out.write(TRANSFER_ENCODING_BINARY);
+        out.write(CR_LF);
+
+        // Stream (file)
+        final byte[] tmp = new byte[4096];
+        int l;
+        while ((l = inputStream.read(tmp)) != -1) {
+            out.write(tmp, 0, l);
+        }
+
+        out.write(CR_LF);
+        out.flush();
+
+        AsyncHttpClient.silentCloseOutputStream(out);
+    }
+
+    private String normalizeContentType(String type) {
+       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
+    }
+
+    private byte[] createContentType(String type) {
+        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
+        return result.getBytes();
+    }
+
+    private byte[] createContentDisposition(String key) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
+            .getBytes();
+    }
+
+    private byte[] createContentDisposition(String key, String fileName) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
+            .getBytes();
+    }
+
+    private void updateProgress(int count) {
+        bytesWritten += count;
+        progressHandler.sendProgressMessage(bytesWritten, totalSize);
+    }
+
+    private class FilePart {
+        public File file;
+        public byte[] header;
+
+        public FilePart(String key, File file, String type) {
+            header = createHeader(key, file.getName(), type);
+            this.file = file;
+        }
+
+        private byte[] createHeader(String key, String filename, String type) {
+            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
+            try {
+                headerStream.write(boundaryLine);
+
+                // Headers
+                headerStream.write(createContentDisposition(key, filename));
+                headerStream.write(createContentType(type));
+                headerStream.write(TRANSFER_ENCODING_BINARY);
+                headerStream.write(CR_LF);
+            } catch (IOException e) {
+                // Can't happen on ByteArrayOutputStream
+                Log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
+            }
+            return headerStream.toByteArray();
+        }
+
+        public long getTotalLength() {
+            long streamLength = file.length() + CR_LF.length;
+            return header.length + streamLength;
+        }
+
+        public void writeTo(OutputStream out) throws IOException {
+            out.write(header);
+            updateProgress(header.length);
+
+            FileInputStream inputStream = new FileInputStream(file);
+            final byte[] tmp = new byte[4096];
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
+            }
+            out.write(CR_LF);
+            updateProgress(CR_LF.length);
+            out.flush();
+            AsyncHttpClient.silentCloseInputStream(inputStream);
+        }
+    }
+
+    // The following methods are from the HttpEntity interface
+
+    @Override
+    public long getContentLength() {
+        long contentLen = out.size();
+        for (FilePart filePart : fileParts) {
+            long len = filePart.getTotalLength();
+            if (len < 0) {
+                return -1; // Should normally not happen
+            }
+            contentLen += len;
+        }
+        contentLen += boundaryEnd.length;
+        return contentLen;
+    }
+
+    @Override
+    public Header getContentType() {
+        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    public void setIsRepeatable(boolean isRepeatable) {
+        this.isRepeatable = isRepeatable;
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return isRepeatable;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        bytesWritten = 0;
+        totalSize = (int) getContentLength();
+        out.writeTo(outstream);
+        updateProgress(out.size());
+
+        for (FilePart filePart : fileParts) {
+            filePart.writeTo(outstream);
+        }
+        outstream.write(boundaryEnd);
+        updateProgress(boundaryEnd.length);
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    @Override
+    public void consumeContent() throws IOException, UnsupportedOperationException {
+        if (isStreaming()) {
+            throw new UnsupportedOperationException(
+                    "Streaming entity does not implement #consumeContent()");
+        }
+    }
+
+    @Override
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw new UnsupportedOperationException(
+                "getContent() is not supported. Use writeTo() instead.");
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
new file mode 100755
index 00000000..ac5ca66d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -0,0 +1,84 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+/**
+ * Processes http requests in synchronous mode, so your caller thread will be blocked on each
+ * request
+ *
+ * @see com.loopj.android.http.AsyncHttpClient
+ */
+public class SyncHttpClient extends AsyncHttpClient {
+
+    /**
+     * Creates a new SyncHttpClient with default constructor arguments values
+     */
+    public SyncHttpClient() {
+        super(false, 80, 443);
+    }
+
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public SyncHttpClient(int httpPort) {
+        super(false, httpPort, 443);
+    }
+
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public SyncHttpClient(int httpPort, int httpsPort) {
+        super(false, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates new SyncHttpClient using given params
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    public SyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        super(fixNoHttpResponseException, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
+     */
+    public SyncHttpClient(SchemeRegistry schemeRegistry) {
+        super(schemeRegistry);
+    }
+
+    @Override
+    protected RequestHandle sendRequest(DefaultHttpClient client,
+                                        HttpContext httpContext, HttpUriRequest uriRequest,
+                                        String contentType, ResponseHandlerInterface responseHandler,
+                                        Context context) {
+        if (contentType != null) {
+            uriRequest.addHeader("Content-Type", contentType);
+        }
+
+        responseHandler.setUseSynchronousMode(true);
+
+		/*
+         * will execute the request directly
+		*/
+        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+
+        // Return a Request Handle that cannot be used to cancel the request
+        // because it is already complete by the time this returns
+        return new RequestHandle(null);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
new file mode 100755
index 00000000..b96a263a
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -0,0 +1,105 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(int, org.apache.http.Header[], String)} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], String, Throwable)}, {@link #onStart()}, and
+ * {@link #onFinish()} methods as required. <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new TextHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String responseBody) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(String responseBody, Throwable e) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "TextHttpResponseHandler";
+
+    /**
+     * Creates new instance with default UTF-8 encoding
+     */
+    public TextHttpResponseHandler() {
+        this(DEFAULT_CHARSET);
+    }
+
+    /**
+     * Creates new instance with given string encoding
+     *
+     * @param encoding String encoding, see {@link #setCharset(String)}
+     */
+    public TextHttpResponseHandler(String encoding) {
+        super();
+        setCharset(encoding);
+    }
+
+    /**
+     * Called when request fails
+     *
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     * @param throwable      throwable returned when processing request
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable);
+
+    /**
+     * Called when request succeeds
+     *
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String responseString);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getResponseString(responseBytes, getCharset()));
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, getResponseString(responseBytes, getCharset()), throwable);
+    }
+
+    /**
+     * Attempts to encode response bytes as string of set encoding
+     *
+     * @param charset     charset to create string with
+     * @param stringBytes response bytes
+     * @return String of set encoding or null
+     */
+    public static String getResponseString(byte[] stringBytes, String charset) {
+        try {
+            return stringBytes == null ? null : new String(stringBytes, charset);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, "Encoding response into string failed", e);
+            return null;
+        }
+    }
+
+}
diff --git a/maven_push.gradle b/maven_push.gradle
new file mode 100755
index 00000000..6fc6fb30
--- /dev/null
+++ b/maven_push.gradle
@@ -0,0 +1,100 @@
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+configurations {
+    archives {
+        extendsFrom configurations.default
+    }
+}
+
+def sonatypeRepositoryUrl
+if (isReleaseBuild()) {
+    println 'RELEASE BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+} else {
+    println 'DEBUG BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
+    if (System.console())
+        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
+    else
+        ext.set('signing.password', 'dummy')
+}
+
+if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
+    if (System.console())
+        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
+    else
+    	ext.set('nexusPassword', 'dummy')
+}
+
+afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+                pom.artifactId = POM_ARTIFACT_ID
+
+                repository(url: sonatypeRepositoryUrl) {
+                    authentication(userName: nexusUsername, password: nexusPassword)
+                }
+
+                pom.project {
+                    name POM_NAME
+                    packaging POM_PACKAGING
+                    description POM_DESCRIPTION
+                    url POM_URL
+
+                    scm {
+                        url POM_SCM_URL
+                        connection POM_SCM_CONNECTION
+                        developerConnection POM_SCM_DEV_CONNECTION
+                    }
+
+                    licenses {
+                        license {
+                            name POM_LICENCE_NAME
+                            url POM_LICENCE_URL
+                            distribution POM_LICENCE_DIST
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id "loopj"
+                            name "James Smith"
+                        }
+                        developer {
+                            id "smarek"
+                            name "Marek Sebera"
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: generateReleaseJavadoc) {
+        classifier = 'javadoc'
+        from generateReleaseJavadoc.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+        classifier = 'sources'
+        from android.sourceSets.main.allSource
+    }
+
+    artifacts {
+        archives androidReleaseJar
+        archives androidSourcesJar
+        archives androidJavadocsJar
+    }
+}
diff --git a/project.properties b/project.properties
deleted file mode 100644
index 1880987e..00000000
--- a/project.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-3
diff --git a/releases/android-async-http-1.2.0.jar b/releases/android-async-http-1.2.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.2.1.jar b/releases/android-async-http-1.2.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.0.jar b/releases/android-async-http-1.3.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.1.jar b/releases/android-async-http-1.3.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.2.jar b/releases/android-async-http-1.3.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.0.jar b/releases/android-async-http-1.4.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.1.jar b/releases/android-async-http-1.4.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.2.jar b/releases/android-async-http-1.4.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.3.jar b/releases/android-async-http-1.4.3.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.4.jar b/releases/android-async-http-1.4.4.jar
new file mode 100755
index 00000000..75af7015
Binary files /dev/null and b/releases/android-async-http-1.4.4.jar differ
diff --git a/sample/.gitignore b/sample/.gitignore
new file mode 100755
index 00000000..796b96d1
--- /dev/null
+++ b/sample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/sample/build.gradle b/sample/build.gradle
new file mode 100755
index 00000000..b4fdad60
--- /dev/null
+++ b/sample/build.gradle
@@ -0,0 +1,46 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.+'
+    }
+}
+apply plugin: 'android'
+
+repositories {
+    mavenCentral()
+    maven {
+        url "https://oss.sonatype.org/content/repositories/snapshots/"
+    }
+}
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion '19.0.3'
+
+    defaultConfig {
+        minSdkVersion 3
+        targetSdkVersion 19
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    packagingOptions {
+        exclude 'META-INF/DEPENDENCIES'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/NOTICE'
+    }
+}
+
+dependencies {
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
+    compile project(':library')
+}
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
new file mode 100755
index 00000000..b1cac259
--- /dev/null
+++ b/sample/src/main/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.loopj.android.http.sample"
+          android:versionCode="1"
+          android:versionName="1.0">
+
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <application
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity android:name=".WaypointsActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name=".GetSample"/>
+        <activity android:name=".PostSample"/>
+        <activity android:name=".DeleteSample"/>
+        <activity android:name=".PutSample"/>
+        <activity android:name=".JsonSample"/>
+        <activity android:name=".FileSample"/>
+        <activity android:name=".BinarySample"/>
+        <activity android:name=".GzipSample"/>
+        <activity android:name=".Redirect302Sample"/>
+        <activity android:name=".ThreadingTimeoutSample"/>
+        <activity android:name=".CancelAllRequestsSample"/>
+        <activity android:name=".CancelRequestHandleSample"/>
+        <activity android:name=".SynchronousClientSample"/>
+    </application>
+
+</manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
new file mode 100755
index 00000000..a01942fd
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -0,0 +1,70 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class BinarySample extends SampleParentActivity {
+    private static final String LOG_TAG = "BinarySample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_binary_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BinaryHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public String[] getAllowedContentTypes() {
+                // Allowing all data for debug purposes
+                return new String[]{".*"};
+            }
+
+            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
+                }
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
new file mode 100644
index 00000000..fa8df74b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http.sample;
+
+public class CancelAllRequestsSample extends ThreadingTimeoutSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_all;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        getAsyncHttpClient().cancelAllRequests(true);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
new file mode 100644
index 00000000..fd66c3a0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -0,0 +1,30 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.RequestHandle;
+
+public class CancelRequestHandleSample extends ThreadingTimeoutSample {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_handle;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        Log.d(LOG_TAG, String.format("Number of handles found: %d", getRequestHandles().size()));
+        int counter = 0;
+        for (RequestHandle handle : getRequestHandles()) {
+            if (!handle.isCancelled() && !handle.isFinished()) {
+                Log.d(LOG_TAG, String.format("Cancelling handle %d", counter));
+                Log.d(LOG_TAG, String.format("Handle %d cancel", counter) + (handle.cancel(true) ? " succeeded" : " failed"));
+            } else {
+                Log.d(LOG_TAG, String.format("Handle %d already non-cancellable", counter));
+            }
+            counter++;
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
new file mode 100755
index 00000000..bea35ca4
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -0,0 +1,67 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class DeleteSample extends SampleParentActivity {
+    private static final String LOG_TAG = "DeleteSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.delete(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_delete_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/delete";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
new file mode 100755
index 00000000..c554cc4d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -0,0 +1,83 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.FileUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+
+public class FileSample extends SampleParentActivity {
+    private static final String LOG_TAG = "FileSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_file_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/robots.txt";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new FileAsyncHttpResponseHandler(this) {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugFile(response);
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                debugFile(file);
+            }
+
+            private void debugFile(File file) {
+                if (file == null || !file.exists()) {
+                    debugResponse(LOG_TAG, "Response is null");
+                    return;
+                }
+                try {
+                    debugResponse(LOG_TAG, file.getAbsolutePath() + "\r\n\r\n" + FileUtil.getStringFromFile(file));
+                } catch (Throwable t) {
+                    Log.e(LOG_TAG, "Cannot debug file contents", t);
+                }
+                if (!deleteTargetFile()) {
+                    Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
+                }
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
new file mode 100755
index 00000000..5464cc6c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -0,0 +1,76 @@
+package com.loopj.android.http.sample;
+
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class GetSample extends SampleParentActivity {
+    private static final String LOG_TAG = "GetSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_get_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+
+            @Override
+            public void onRetry(int retryNo) {
+                Toast.makeText(GetSample.this,
+                        String.format("Request is retried, retry no. %d", retryNo),
+                        Toast.LENGTH_SHORT)
+                        .show();
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
new file mode 100644
index 00000000..ba242939
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http.sample;
+
+public class GzipSample extends JsonSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_gzip_sample;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
new file mode 100755
index 00000000..cde4e06f
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -0,0 +1,78 @@
+package com.loopj.android.http.sample;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class JsonSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "JsonSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_json_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/headers";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
new file mode 100755
index 00000000..2e183d9b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -0,0 +1,67 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class PostSample extends SampleParentActivity {
+    private static final String LOG_TAG = "PostSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_post_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/post";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
+
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
new file mode 100755
index 00000000..d32b5767
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -0,0 +1,67 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class PutSample extends SampleParentActivity {
+    private static final String LOG_TAG = "PutSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.put(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_put_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/put";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
new file mode 100644
index 00000000..1a10a1a3
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -0,0 +1,79 @@
+package com.loopj.android.http.sample;
+
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class Redirect302Sample extends GetSample {
+
+    private boolean enableRedirects = true;
+    private boolean enableRelativeRedirects = true;
+    private boolean enableCircularRedirects = true;
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, 0, Menu.NONE, "Enable redirects").setCheckable(true);
+        menu.add(Menu.NONE, 1, Menu.NONE, "Enable relative redirects").setCheckable(true);
+        menu.add(Menu.NONE, 2, Menu.NONE, "Enable circular redirects").setCheckable(true);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem menuItemEnableRedirects = menu.findItem(0);
+        if (menuItemEnableRedirects != null)
+            menuItemEnableRedirects.setChecked(enableRedirects);
+        MenuItem menuItemEnableRelativeRedirects = menu.findItem(1);
+        if (menuItemEnableRelativeRedirects != null)
+            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
+        MenuItem menuItemEnableCircularRedirects = menu.findItem(2);
+        if (menuItemEnableCircularRedirects != null)
+            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
+        return super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.isCheckable()) {
+            item.setChecked(!item.isChecked());
+            if (item.getItemId() == 0) {
+                enableRedirects = item.isChecked();
+            } else if (item.getItemId() == 1) {
+                enableRelativeRedirects = item.isChecked();
+            } else if (item.getItemId() == 2) {
+                enableCircularRedirects = item.isChecked();
+            }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/redirect/6";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_redirect_302;
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient() {
+        AsyncHttpClient ahc = super.getAsyncHttpClient();
+        HttpClient client = ahc.getHttpClient();
+        if (client instanceof DefaultHttpClient) {
+            Toast.makeText(this,
+                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
+                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
+                    Toast.LENGTH_SHORT
+            ).show();
+            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
+        }
+        return ahc;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
new file mode 100644
index 00000000..751823e9
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -0,0 +1,43 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.List;
+
+public interface SampleInterface {
+
+    List<RequestHandle> getRequestHandles();
+
+    void addRequestHandle(RequestHandle handle);
+
+    void onRunButtonPressed();
+
+    void onCancelButtonPressed();
+
+    Header[] getRequestHeaders();
+
+    HttpEntity getRequestEntity();
+
+    AsyncHttpClient getAsyncHttpClient();
+
+    void setAsyncHttpClient(AsyncHttpClient client);
+
+    ResponseHandlerInterface getResponseHandler();
+
+    String getDefaultURL();
+
+    boolean isRequestHeadersAllowed();
+
+    boolean isRequestBodyAllowed();
+
+    int getSampleTitle();
+
+    boolean isCancelButtonAllowed();
+
+    RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler);
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
new file mode 100755
index 00000000..3b26362c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -0,0 +1,220 @@
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+
+public abstract class SampleParentActivity extends Activity implements SampleInterface {
+
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+    private EditText urlEditText, headersEditText, bodyEditText;
+    private LinearLayout responseLayout;
+    private final List<RequestHandle> requestHandles = new LinkedList<>();
+
+    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    private static final int LIGHTRED = Color.parseColor("#FF3300");
+    private static final int YELLOW = Color.parseColor("#FFFF00");
+    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.parent_layout);
+        setTitle(getSampleTitle());
+
+        urlEditText = (EditText) findViewById(R.id.edit_url);
+        headersEditText = (EditText) findViewById(R.id.edit_headers);
+        bodyEditText = (EditText) findViewById(R.id.edit_body);
+        Button runButton = (Button) findViewById(R.id.button_run);
+        Button cancelButton = (Button) findViewById(R.id.button_cancel);
+        LinearLayout headersLayout = (LinearLayout) findViewById(R.id.layout_headers);
+        LinearLayout bodyLayout = (LinearLayout) findViewById(R.id.layout_body);
+        responseLayout = (LinearLayout) findViewById(R.id.layout_response);
+
+        urlEditText.setText(getDefaultURL());
+
+        bodyLayout.setVisibility(isRequestBodyAllowed() ? View.VISIBLE : View.GONE);
+        headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
+
+        runButton.setOnClickListener(onClickListener);
+        if (cancelButton != null) {
+            if (isCancelButtonAllowed()) {
+                cancelButton.setVisibility(View.VISIBLE);
+                cancelButton.setOnClickListener(onClickListener);
+            } else {
+                cancelButton.setEnabled(false);
+            }
+        }
+    }
+
+    public List<RequestHandle> getRequestHandles() {
+        return requestHandles;
+    }
+
+    @Override
+    public void addRequestHandle(RequestHandle handle) {
+        if (null != handle) {
+            requestHandles.add(handle);
+        }
+    }
+
+    public void onRunButtonPressed() {
+        addRequestHandle(executeSample(getAsyncHttpClient(),
+                (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
+                getRequestHeaders(),
+                getRequestEntity(),
+                getResponseHandler()));
+    }
+
+    public void onCancelButtonPressed() {
+        asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+    }
+
+    protected View.OnClickListener onClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            switch (v.getId()) {
+                case R.id.button_run:
+                    onRunButtonPressed();
+                    break;
+                case R.id.button_cancel:
+                    onCancelButtonPressed();
+                    break;
+            }
+        }
+    };
+
+    public Header[] getRequestHeaders() {
+        List<Header> headers = new ArrayList<>();
+        String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
+
+        if (headersRaw != null && headersRaw.length() > 3) {
+            String[] lines = headersRaw.split("\\r?\\n");
+            for (String line : lines) {
+                try {
+                    String[] kv = line.split("=");
+                    if (kv.length != 2)
+                        throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
+                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                } catch (Throwable t) {
+                    Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
+                }
+            }
+        }
+        return headers.toArray(new Header[headers.size()]);
+    }
+
+    public HttpEntity getRequestEntity() {
+        if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
+            try {
+                return new StringEntity(bodyEditText.getText().toString());
+            } catch (UnsupportedEncodingException e) {
+                Log.e("SampleParentActivity", "cannot create String entity", e);
+            }
+        }
+        return null;
+    }
+
+    protected final void debugHeaders(String TAG, Header[] headers) {
+        if (headers != null) {
+            Log.d(TAG, "Return Headers:");
+            StringBuilder builder = new StringBuilder();
+            for (Header h : headers) {
+                String _h = String.format(Locale.US, "%s : %s", h.getName(), h.getValue());
+                Log.d(TAG, _h);
+                builder.append(_h);
+                builder.append("\n");
+            }
+            addView(getColoredView(YELLOW, builder.toString()));
+        }
+    }
+
+    protected static String throwableToString(Throwable t) {
+        if (t == null)
+            return null;
+
+        StringWriter sw = new StringWriter();
+        t.printStackTrace(new PrintWriter(sw));
+        return sw.toString();
+    }
+
+    protected final void debugThrowable(String TAG, Throwable t) {
+        if (t != null) {
+            Log.e(TAG, "AsyncHttpClient returned error", t);
+            addView(getColoredView(LIGHTRED, throwableToString(t)));
+        }
+    }
+
+    protected final void debugResponse(String TAG, String response) {
+        if (response != null) {
+            Log.d(TAG, "Response data:");
+            Log.d(TAG, response);
+            addView(getColoredView(LIGHTGREEN, response));
+        }
+    }
+
+    protected final void debugStatusCode(String TAG, int statusCode) {
+        String msg = String.format(Locale.US, "Return Status Code: %d", statusCode);
+        Log.d(TAG, msg);
+        addView(getColoredView(LIGHTBLUE, msg));
+    }
+
+    public static int getContrastColor(int color) {
+        double y = (299 * Color.red(color) + 587 * Color.green(color) + 114 * Color.blue(color)) / 1000;
+        return y >= 128 ? Color.BLACK : Color.WHITE;
+    }
+
+    protected View getColoredView(int bgColor, String msg) {
+        TextView tv = new TextView(this);
+        tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        tv.setText(msg);
+        tv.setBackgroundColor(bgColor);
+        tv.setPadding(10, 10, 10, 10);
+        tv.setTextColor(getContrastColor(bgColor));
+        return tv;
+    }
+
+    protected final void addView(View v) {
+        responseLayout.addView(v);
+    }
+
+    protected final void clearOutputs() {
+        responseLayout.removeAllViews();
+    }
+
+    public boolean isCancelButtonAllowed() {
+        return false;
+    }
+
+    public AsyncHttpClient getAsyncHttpClient() {
+        return this.asyncHttpClient;
+    }
+
+    @Override
+    public void setAsyncHttpClient(AsyncHttpClient client) {
+        this.asyncHttpClient = client;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
new file mode 100644
index 00000000..d0756ad0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -0,0 +1,108 @@
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SyncHttpClient;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class SynchronousClientSample extends GetSample {
+    private static final String LOG_TAG = "SyncSample";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setAsyncHttpClient(new SyncHttpClient());
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_synchronous;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/delay/6";
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+        if (client instanceof SyncHttpClient) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Log.d(LOG_TAG, "Before Request");
+                    client.get(SynchronousClientSample.this, URL, headers, null, responseHandler);
+                    Log.d(LOG_TAG, "After Request");
+                }
+            }).start();
+        } else {
+            Log.e(LOG_TAG, "Error, not using SyncHttpClient");
+        }
+        /**
+         * SyncHttpClient does not return RequestHandle,
+         * it executes each request directly,
+         * therefore those requests are not in cancelable threads
+         * */
+        return null;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        clearOutputs();
+                    }
+                });
+            }
+
+            @Override
+            public void onSuccess(final int statusCode, final Header[] headers, final byte[] response) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(final int statusCode, final Header[] headers, final byte[] errorResponse, final Throwable e) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+                });
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
new file mode 100755
index 00000000..059adeac
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -0,0 +1,94 @@
+package com.loopj.android.http.sample;
+
+import android.util.SparseArray;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class ThreadingTimeoutSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+    private SparseArray<String> states = new SparseArray<>();
+    private int counter = 0;
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_threading_timeout;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isCancelButtonAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/delay/6";
+    }
+
+    private synchronized void setStatus(int id, String status) {
+        String current = states.get(id, null);
+        states.put(id, current == null ? status : current + "," + status);
+        clearOutputs();
+        for (int i = 0; i < states.size(); i++) {
+            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
+        }
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            private int id = counter++;
+
+            @Override
+            public void onStart() {
+                setStatus(id, "START");
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                setStatus(id, "SUCCESS");
+            }
+
+            @Override
+            public void onFinish() {
+                setStatus(id, "FINISH");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                setStatus(id, "FAILURE");
+            }
+
+            @Override
+            public void onCancel() {
+                setStatus(id, "CANCEL");
+            }
+        };
+    }
+
+    public int getCounter() {
+        return counter;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
new file mode 100755
index 00000000..dad700c2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -0,0 +1,54 @@
+package com.loopj.android.http.sample;
+
+import android.app.ListActivity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+public class WaypointsActivity extends ListActivity {
+
+    private static final String[] samples = new String[]{
+            "GET",
+            "POST",
+            "DELETE",
+            "PUT",
+            "JSON",
+            "FILE",
+            "BINARY",
+            "GZIP",
+            "302 REDIRECT",
+            "THREADING TIMEOUTS",
+            "CANCEL ALL REQUESTS",
+            "CANCEL REQUEST HANDLE",
+            "SYNCHRONOUS CLIENT"
+    };
+    private static final Class[] targets = {
+            GetSample.class,
+            PostSample.class,
+            DeleteSample.class,
+            PutSample.class,
+            JsonSample.class,
+            FileSample.class,
+            BinarySample.class,
+            GzipSample.class,
+            Redirect302Sample.class,
+            ThreadingTimeoutSample.class,
+            CancelAllRequestsSample.class,
+            CancelRequestHandleSample.class,
+            SynchronousClientSample.class
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, samples));
+    }
+
+    @Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        if (position >= 0 && position < targets.length)
+            startActivity(new Intent(this, targets[position]));
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
new file mode 100755
index 00000000..1398d9d9
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -0,0 +1,30 @@
+package com.loopj.android.http.sample.util;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+// Source: http://stackoverflow.com/questions/12910503/android-read-file-as-string
+public class FileUtil {
+
+    public static String convertStreamToString(InputStream is) throws Exception {
+        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+        StringBuilder sb = new StringBuilder();
+        String line;
+        while ((line = reader.readLine()) != null) {
+            sb.append(line).append("\n");
+        }
+        return sb.toString();
+    }
+
+    public static String getStringFromFile(File file) throws Exception {
+        FileInputStream fin = new FileInputStream(file);
+        String ret = convertStreamToString(fin);
+        //Make sure you close all streams.
+        fin.close();
+        return ret;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
new file mode 100755
index 00000000..e12c30fc
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -0,0 +1,59 @@
+package com.loopj.android.http.sample.util;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class SampleJSON {
+
+    private String Accept;
+    private String Referer;
+    private String AcceptLanguage;
+    private String Connection;
+    private String UserAgent;
+
+    public String getAccept() {
+        return Accept;
+    }
+
+    @JsonProperty("Accept")
+    public void setAccept(String accept) {
+        Accept = accept;
+    }
+
+    public String getReferer() {
+        return Referer;
+    }
+
+    @JsonProperty("Referer")
+    public void setReferer(String referer) {
+        Referer = referer;
+    }
+
+    public String getAcceptLanguage() {
+        return AcceptLanguage;
+    }
+
+    @JsonProperty("Accept-Language")
+    public void setAcceptLanguage(String acceptLanguage) {
+        AcceptLanguage = acceptLanguage;
+    }
+
+    public String getConnection() {
+        return Connection;
+    }
+
+    @JsonProperty("Connection")
+    public void setConnection(String connection) {
+        Connection = connection;
+    }
+
+    public String getUserAgent() {
+        return UserAgent;
+    }
+
+    @JsonProperty("User-Agent")
+    public void setUserAgent(String userAgent) {
+        UserAgent = userAgent;
+    }
+}
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100755
index 00000000..96a442e5
Binary files /dev/null and b/sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100755
index 00000000..359047df
Binary files /dev/null and b/sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100755
index 00000000..71c6d760
Binary files /dev/null and b/sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
new file mode 100755
index 00000000..97ba749b
--- /dev/null
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <EditText
+            android:id="@+id/edit_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:inputType="textUri"/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/button_cancel"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_cancel"/>
+
+            <Button
+                android:id="@+id/button_run"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_run"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
new file mode 100755
index 00000000..d2c7dad6
--- /dev/null
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <EditText
+                android:id="@+id/edit_url"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:inputType="textUri"/>
+
+            <Button
+                android:id="@+id/button_run"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/button_run"/>
+
+            <Button
+                android:id="@+id/button_cancel"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:visibility="gone"
+                android:text="@string/button_cancel"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
new file mode 100755
index 00000000..3c02242a
--- /dev/null
+++ b/sample/src/main/res/values-v11/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
new file mode 100755
index 00000000..a91fd037
--- /dev/null
+++ b/sample/src/main/res/values-v14/styles.xml
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
new file mode 100755
index 00000000..3507db19
--- /dev/null
+++ b/sample/src/main/res/values/strings.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Android Async Http Samples</string>
+    <string name="title_get_sample">GET</string>
+    <string name="title_json_sample">GET JSON and parse it</string>
+    <string name="title_post_sample">POST</string>
+    <string name="title_put_sample">PUT</string>
+    <string name="title_delete_sample">DELETE</string>
+    <string name="title_file_sample">GET to File</string>
+    <string name="title_binary_sample">GET binary data</string>
+    <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_cancel_handle">Cancel request handle</string>
+    <string name="title_synchronous">Synchronous GET request</string>
+    <string name="title_threading_timeout">Threading timeouts</string>
+    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
+    <string name="button_run">Run</string>
+    <string name="label_headers">Headers (key=val, one per line)</string>
+    <string name="label_req_body">Request body</string>
+    <string name="button_cancel">Cancel</string>
+    <string name="title_redirect_302">302 Redirect handling</string>
+</resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
new file mode 100755
index 00000000..6ce89c7b
--- /dev/null
+++ b/sample/src/main/res/values/styles.xml
@@ -0,0 +1,20 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
+    </style>
+
+</resources>
diff --git a/settings.gradle b/settings.gradle
new file mode 100755
index 00000000..612d9e44
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':library'
+include ':sample'
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
deleted file mode 100644
index 5f0750d7..00000000
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ /dev/null
@@ -1,620 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.zip.GZIPInputStream;
-
-import org.apache.http.Header;
-import org.apache.http.HeaderElement;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpResponseInterceptor;
-import org.apache.http.HttpVersion;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpDelete;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.client.protocol.ClientContext;
-import org.apache.http.conn.params.ConnManagerParams;
-import org.apache.http.conn.params.ConnPerRouteBean;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.entity.HttpEntityWrapper;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.BasicHttpContext;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.protocol.SyncBasicHttpContext;
-
-import android.content.Context;
-
-
-/**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
- * DELETE HTTP requests in your Android applications. Requests can be made
- * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
- * {@link AsyncHttpResponseHandler} instance.
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
- *     }
- * });
- * </pre>
- */
-public class AsyncHttpClient {
-    private static final String VERSION = "1.4.3";
-
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-
-
-    /**
-     * Creates a new AsyncHttpClient.
-     */
-    public AsyncHttpClient() {
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            @Override
-            public void process(HttpRequest request, HttpContext context) {
-                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-                }
-                for (String header : clientHeaderMap.keySet()) {
-                    request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            @Override
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                if (entity == null) {
-                    return;
-                }
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Get the underlying HttpContext instance. This is useful for getting 
-     * and setting fine-grained settings for requests by accessing the
-     * context's attributes such as the CookieStore.
-     */
-    public HttpContext getHttpContext() {
-        return this.httpContext;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
-     */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-    /**
-     * Sets the connection time oout. By default, 10 seconds
-     * @param timeout the connect/socket timeout in milliseconds
-     */
-    public void setTimeout(int timeout){
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-    
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     * @param header the name of the header
-     * @param value the contents of the header
-     */
-    public void addHeader(String header, String value) {
-        clientHeaderMap.put(header, value);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
-     * @param username
-     * @param password
-     */
-    public void setBasicAuth(String user, String pass){
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
-    }
-    
-   /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
-     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     * @param username
-     * @param password
-     * @param scope - an AuthScope object
-     *
-     */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
-     *
-     * @param context the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
-     */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.remove(context);
-    }
-
-
-    //
-    // HTTP GET Requests
-    //
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-
-    //
-    // HTTP POST Requests
-    //
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP PUT Requests
-    //
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-
-    // Private stuff
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
-
-        if(context != null) {
-            // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
-            }
-
-            requestList.add(new WeakReference<Future<?>>(request));
-
-            // TODO: Remove dead weakrefs from requestLists?
-        }
-    }
-
-    public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
-            String paramString = params.getParamString();
-            if (url.indexOf("?") == -1) {
-                url += "?" + paramString;
-            } else {
-                url += "&" + paramString;
-            }
-        }
-
-        return url;
-    }
-
-    private HttpEntity paramsToEntity(RequestParams params) {
-        HttpEntity entity = null;
-
-        if(params != null) {
-            entity = params.getEntity();
-        }
-
-        return entity;
-    }
-
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    private static class InflatingEntity extends HttpEntityWrapper {
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
-        public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
-        }
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
-}
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
deleted file mode 100644
index 48e6807e..00000000
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-class AsyncHttpRequest implements Runnable {
-    private final AbstractHttpClient client;
-    private final HttpContext context;
-    private final HttpUriRequest request;
-    private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
-    private int executionCount;
-
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
-    }
-
-    @Override
-    public void run() {
-        try {
-            if(responseHandler != null){
-                responseHandler.sendStartMessage();
-            }
-
-            makeRequestWithRetries();
-
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
-        } catch (IOException e) {
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                if(this.isBinaryRequest) {
-                    responseHandler.sendFailureMessage(e, (byte[]) null);
-                } else {
-                    responseHandler.sendFailureMessage(e, (String) null);
-                }
-            }
-        }
-    }
-
-    private void makeRequest() throws IOException {
-        if(!Thread.currentThread().isInterrupted()) {
-        	try {
-        		HttpResponse response = client.execute(request, context);
-        		if(!Thread.currentThread().isInterrupted()) {
-        			if(responseHandler != null) {
-        				responseHandler.sendResponseMessage(response);
-        			}
-        		} else{
-        			//TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
-        		}
-        	} catch (IOException e) {
-        		if(!Thread.currentThread().isInterrupted()) {
-        			throw e;
-        		}
-        	}
-        }
-    }
-
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
-        boolean retry = true;
-        IOException cause = null;
-        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
-                // Added to detect host unreachable
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
-                }
-                return;
-            }catch (SocketTimeoutException e){
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
-                }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient" + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            }
-        }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
-    }
-}
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
deleted file mode 100644
index 2030265f..00000000
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import org.apache.http.Header;
-import java.io.IOException;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-
-/**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
- * designed to be anonymously overridden with your own response handling code.
- * <p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         // Successfully got a response
- *     }
- * 
- *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public class AsyncHttpResponseHandler {
-    protected static final int SUCCESS_MESSAGE = 0;
-    protected static final int FAILURE_MESSAGE = 1;
-    protected static final int START_MESSAGE = 2;
-    protected static final int FINISH_MESSAGE = 3;
-
-    private Handler handler;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                @Override
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {}
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
-     */
-    public void onFinish() {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(String content) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, Header[] headers, String content) {
-        onSuccess(statusCode, content);
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, String content)
-    {
-        onSuccess(content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
-     */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), headers, responseBody}));
-    }
-
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-    
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    protected void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    protected void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, headers, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
-    }
-
-
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (Header[]) response[1], (String) response[2]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
-        }
-    }
-
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = Message.obtain();
-            msg.what = responseMessage;
-            msg.obj = response;
-        }
-        return msg;
-    }
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
-            }
-        } catch(IOException e) {
-            sendFailureMessage(e, (String) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
-        }
-    }
-}
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
deleted file mode 100644
index 7d675a59..00000000
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.util.regex.Pattern;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-import android.os.Message;
-
-/**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
- * Content-length).
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * String[] allowedTypes = new String[] { "image/png" };
- * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
- *     &#064;Override
- *     public void onSuccess(byte[] imageData) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(Throwable e, byte[] imageData) {
- *         // Response failed :(
- *     }
- * });
- * </pre>
- */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
-    // Allow images by default
-    private static String[] mAllowedContentTypes = new String[] {
-        "image/jpeg",
-        "image/png"
-    };
-
-    /**
-     * Creates a new BinaryHttpResponseHandler
-     */
-    public BinaryHttpResponseHandler() {
-        super();
-    }
-
-    /**
-     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
-     * content types with passed String array (hopefully) of content types.
-     */
-    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param binaryData the response body, if any
-     * @deprecated
-     */
-    @Deprecated
-    public void onFailure(Throwable error, byte[] binaryData) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
-    }
-
-    @Override
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    @Override
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], response[1].toString());
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
-
-    // Interface to AsyncHttpRequest
-    @Override
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        byte[] responseBody = null;
-        if(contentTypeHeaders.length != 1) {
-            //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
-            return;
-        }
-        Header contentTypeHeader = contentTypeHeaders[0];
-        boolean foundAllowedContentType = false;
-        for(String anAllowedContentType : mAllowedContentTypes) {
-            if(Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
-                foundAllowedContentType = true;
-            }
-        }
-        if(!foundAllowedContentType) {
-            //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
-            return;
-        }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, (byte[]) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/src/com/loopj/android/http/JsonHttpResponseHandler.java
deleted file mode 100644
index 433690af..00000000
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.HttpStatus;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-import org.apache.http.Header;
-import android.os.Message;
-
-/**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
- * or {@link JSONArray}.
- * <p>
- * This class is designed to be passed to get, post, put and delete requests
- * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
- * methods anonymously overridden.
- * <p>
- * Additionally, you can override the other event methods from the
- * parent class.
- */
-public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    protected static final int SUCCESS_JSON_MESSAGE = 100;
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {}
-
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(JSONArray response) {}
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-        onSuccess(statusCode, response);
-    }
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
-    }
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-        onSuccess(statusCode, response);
-    }
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(int statusCode,  JSONArray response) {
-        onSuccess(response);
-    }
-
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    @Override
-    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        if (statusCode != HttpStatus.SC_NO_CONTENT){        
-            try {
-                Object jsonResponse = parseResponse(responseBody);
-	        sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
-    	    } catch(JSONException e) {
-    	        sendFailureMessage(e, responseBody);
-    	    }
-        } else {
-            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
-    	}
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    @Override
-    protected void handleMessage(Message msg) {
-        switch(msg.what){
-            case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage(((Integer) response[0]).intValue(),(Header[]) response[1] ,response[2]);
-                break;
-            default:
-                super.handleMessage(msg);
-        }
-    }
-
-    protected void handleSuccessJsonMessage(int statusCode,Header[] headers, Object jsonResponse) {
-        if(jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, headers, (JSONObject)jsonResponse);
-        } else if(jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, headers, (JSONArray)jsonResponse);
-        } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
-        }
-    }
-
-    protected Object parseResponse(String responseBody) throws JSONException {
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-		responseBody = responseBody.trim();
-		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
-			result = new JSONTokener(responseBody).nextValue();
-		}
-		if (result == null) {
-			result = responseBody;
-		}
-		return result;
-    }
-
-    @Override
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        try {
-            if (responseBody != null) {
-                Object jsonResponse = parseResponse(responseBody);
-                if(jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject)jsonResponse);
-                } else if(jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray)jsonResponse);
-                } else {
-                    onFailure(e, responseBody);
-                }
-            }else {
-                onFailure(e, "");
-            }
-        }catch(JSONException ex) {
-            onFailure(e, responseBody);
-        }
-    }
-}
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
deleted file mode 100644
index cbb0c288..00000000
--- a/src/com/loopj/android/http/RequestParams.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.InputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-
-/**
- * A collection of string request parameters or files to send along with
- * requests made from an {@link AsyncHttpClient} instance.
- * <p>
- * For example:
- * <p>
- * <pre>
- * RequestParams params = new RequestParams();
- * params.put("username", "james");
- * params.put("password", "123456");
- * params.put("email", "my&#064;email.com");
- * params.put("profile_picture", new File("pic.jpg")); // Upload a File
- * params.put("profile_picture2", someInputStream); // Upload an InputStream
- * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- *
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.post("http://myendpoint.com", params, responseHandler);
- * </pre>
- */
-public class RequestParams {
-    private static String ENCODING = "UTF-8";
-
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
-
-    /**
-     * Constructs a new empty <code>RequestParams</code> instance.
-     */
-    public RequestParams() {
-        init();
-    }
-
-    /**
-     * Constructs a new RequestParams instance containing the key/value
-     * string params from the specified map.
-     * @param source the source key/value string map to add.
-     */
-    public RequestParams(Map<String, String> source) {
-        init();
-
-        for(Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with a single
-     * initial key/value string param.
-     * @param key the key name for the intial param.
-     * @param value the value string for the initial param.
-     */
-    public RequestParams(String key, String value) {
-        init();
-
-        put(key, value);
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with multiple
-     * initial key/value string param.
-     * @param keysAndValues a sequence of keys and values. Objects are
-     * automatically converted to Strings (including the value {@code null}).
-     * @throws IllegalArgumentException if the number of arguments isn't even.
-     */
-    public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
-    }
-
-    /**
-     * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
-     * @param value the value string for the new param.
-     */
-    public void put(String key, String value){
-        if(key != null && value != null) {
-            urlParams.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a file to the request.
-     * @param key the key name for the new param.
-     * @param file the file to add.
-     */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
-    }
-
-    /**
-     * Adds param with more than one value.
-     * @param key the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values)  {
-        if(key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     */
-    public void put(String key, InputStream stream) {
-        put(key, stream, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     * @param contentType the content type of the file, eg. application/json
-     */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
-        }
-    }
-
-    /**
-     * Removes a parameter from the request.
-     * @param key the key name for the parameter to remove.
-     */
-    public void remove(String key){
-        urlParams.remove(key);
-        fileParams.remove(key);
-        urlParamsWithArray.remove(key);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append(entry.getValue());
-        }
-
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("FILE");
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (int i = 0; i < values.size(); i++) {
-                if (i != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(values.get(i));
-            }
-        }
-
-        return result.toString();
-    }
-
-   /**
-     * Returns an HttpEntity containing all request parameters
-     */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
-
-        if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
-
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
-
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
-
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
-            }
-
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            }
-        }
-
-        return entity;
-    }
-
-    private void init(){
-        urlParams = new ConcurrentHashMap<String, String>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
-    }
-
-    protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
-
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
-        }
-
-        return lparams;
-    }
-
-    protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
-    }
-
-    private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
-        public String contentType;
-
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
-            this.contentType = contentType;
-        }
-
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
-        }
-    }
-}
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
deleted file mode 100644
index bff0efcc..00000000
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-/*
-    This code is taken from Rafael Sanches' blog.
-    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
-*/
-
-package com.loopj.android.http;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Random;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-
-class SimpleMultipartEntity implements HttpEntity {
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
-
-    private String boundary = null;
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
-
-    public SimpleMultipartEntity() {
-        final StringBuffer buf = new StringBuffer();
-        final Random rand = new Random();
-        for (int i = 0; i < 30; i++) {
-            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
-        }
-        this.boundary = buf.toString();
-
-    }
-
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
-            try {
-                out.write(("--" + boundary + "\r\n").getBytes());
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        isSetFirst = true;
-    }
-
-    public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
-            return;
-        }
-
-        try {
-            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-
-        isSetLast = true;
-    }
-
-    public void addPart(final String key, final String value) {
-        writeFirstBoundaryIfNeeds();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeFirstBoundaryIfNeeds();
-        try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
-
-            final byte[] tmp = new byte[4096];
-            int l = 0;
-            while ((l = fin.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-            }
-            if(!isLast)
-                out.write(("\r\n--" + boundary + "\r\n").getBytes());
-            out.flush();
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                fin.close();
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
-    }
-
-    @Override
-    public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
-    }
-
-    @Override
-    public boolean isChunked() {
-        return false;
-    }
-
-    @Override
-    public boolean isRepeatable() {
-        return false;
-    }
-
-    @Override
-    public boolean isStreaming() {
-        return false;
-    }
-
-    @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        outstream.write(out.toByteArray());
-    }
-
-    @Override
-    public Header getContentEncoding() {
-        return null;
-    }
-
-    @Override
-    public void consumeContent() throws IOException,
-    UnsupportedOperationException {
-        if (isStreaming()) {
-            throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
-        }
-    }
-
-    @Override
-    public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-        return new ByteArrayInputStream(out.toByteArray());
-    }
-}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SyncHttpClient.java b/src/com/loopj/android/http/SyncHttpClient.java
deleted file mode 100644
index 1fd4441f..00000000
--- a/src/com/loopj/android/http/SyncHttpClient.java
+++ /dev/null
@@ -1,123 +0,0 @@
-package com.loopj.android.http;
-
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-import android.content.Context;
-import android.os.Message;
-
-public abstract class SyncHttpClient extends AsyncHttpClient {
-	private int responseCode;
-	/*
-	 * as this is a synchronous request this is just a helping mechanism to pass
-	 * the result back to this method. Therefore the result object has to be a
-	 * field to be accessible
-	 */
-	protected String result;
-	protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
-
-        @Override
-        void sendResponseMessage(org.apache.http.HttpResponse response) {
-			responseCode = response.getStatusLine().getStatusCode();
-			super.sendResponseMessage(response);
-		};
-
-		@Override
-		protected void sendMessage(Message msg) {
-			/*
-			 * Dont use the handler and send it directly to the analysis
-			 * (because its all the same thread)
-			 */
-			handleMessage(msg);
-		}
-
-		@Override
-		public void onSuccess(String content) {
-			result = content;
-		}
-
-		@Override
-		public void onFailure(Throwable error, String content) {
-			result = onRequestFailed(error, content);
-		}
-	};
-
-	/**
-	 * @return the response code for the last request, might be usefull
-	 *         sometimes
-	 */
-	public int getResponseCode() {
-		return responseCode;
-	}
-
-	// Private stuff
-    @Override
-    protected void sendRequest(DefaultHttpClient client,
-			HttpContext httpContext, HttpUriRequest uriRequest,
-			String contentType, AsyncHttpResponseHandler responseHandler,
-			Context context) {
-		if (contentType != null) {
-			uriRequest.addHeader("Content-Type", contentType);
-		}
-
-		/*
-		 * will execute the request directly
-		 */
-		new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
-				.run();
-	}
-
-	public abstract String onRequestFailed(Throwable error, String content);
-
-	public void delete(String url, RequestParams queryParams,
-			AsyncHttpResponseHandler responseHandler) {
-		// TODO what about query params??
-		delete(url, responseHandler);
-	}
-
-	public String get(String url, RequestParams params) {
-		this.get(url, params, responseHandler);
-		/*
-		 * the response handler will have set the result when this line is
-		 * reached
-		 */
-		return result;
-	}
-
-	public String get(String url) {
-		this.get(url, null, responseHandler);
-		return result;
-	}
-
-	public String put(String url, RequestParams params) {
-		this.put(url, params, responseHandler);
-		return result;
-	}
-
-	public String put(String url) {
-		this.put(url, null, responseHandler);
-		return result;
-	}
-
-	public String post(String url, RequestParams params) {
-		this.post(url, params, responseHandler);
-		return result;
-	}
-
-	public String post(String url) {
-		this.post(url, null, responseHandler);
-		return result;
-	}
-
-	public String delete(String url, RequestParams params) {
-		this.delete(url, params, responseHandler);
-		return result;
-	}
-
-	public String delete(String url) {
-		this.delete(url, null, responseHandler);
-		return result;
-	}
-
-}
