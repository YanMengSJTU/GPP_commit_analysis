diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0566956b..948f7b1f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,12 @@
 ## 1.4.7 (future version)
 
   - Fixed crash when canceling through RequestHandle from UI Thread (NetworkOnMainThreadException)
+  - Fixed URL encoding feature, that was breaking whole URL, not just path and query parts
+  - FileAsyncHttpResponseHandler now checks that target file path is available or can be created
+  - DataAsyncHttpResponseHandler was sending cancel notification instead of progress notification, fixed
+  - Added support for HTTP PATCH requests
+  - Fixed Assert exception when mkdirs in FileAsyncHttpResponseHandler tries to create dirs that already exists
+  - Provided option to easily override ClientConnectionManager provision in AsyncHttpClient
 
 ## 1.4.6 (released 7. 9. 2014)
 
diff --git a/NOTICE.txt b/NOTICE.txt
new file mode 100644
index 00000000..283826a1
--- /dev/null
+++ b/NOTICE.txt
@@ -0,0 +1,6 @@
+Android Async Http Client library
+Copyright (c) 2011-2014 James Smith <james@loopj.com>
+http://loopj.com
+
+This product includes software developed by
+The Apache Software Foundation (http://www.apache.org/).
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 7575e716..dcbded5c 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -49,6 +49,7 @@
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
 import org.apache.http.conn.params.ConnRoutePNames;
@@ -237,7 +238,8 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
 
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+        ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);
+        Utils.asserts(cm != null, "Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null");
 
         threadPool = getDefaultThreadPool();
         requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
@@ -382,6 +384,17 @@ protected ExecutorService getDefaultThreadPool() {
         return Executors.newCachedThreadPool();
     }
 
+    /**
+     * Provided so it is easier for developers to provide custom ThreadSafeClientConnManager implementation
+     *
+     * @param schemeRegistry SchemeRegistry, usually provided by {@link #getDefaultSchemeRegistry(boolean, int, int)}
+     * @param httpParams     BasicHttpParams
+     * @return ClientConnectionManager instance
+     */
+    protected ClientConnectionManager createConnectionManager(SchemeRegistry schemeRegistry, BasicHttpParams httpParams) {
+        return new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
      * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
@@ -1066,6 +1079,75 @@ public RequestHandle put(Context context, String url, Header[] headers, HttpEnti
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP PATCH request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPatch(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(URI.create(url).normalize()), entity);
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
     // [-] HTTP PUT
     // [+] HTTP DELETE
 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 682a4f7b..6ae195e2 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Internal class, representing the HttpRequest, done in asynchronous manner
@@ -39,16 +40,16 @@
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
-    private boolean isCancelled;
+    private final AtomicBoolean isCancelled = new AtomicBoolean();
     private boolean cancelIsNotified;
-    private boolean isFinished;
+    private volatile boolean isFinished;
     private boolean isRequestPreProcessed;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
+        this.client = Utils.notNull(client, "client");
+        this.context = Utils.notNull(context, "context");
+        this.request = Utils.notNull(request, "request");
+        this.responseHandler = Utils.notNull(responseHandler, "responseHandler");
     }
 
     /**
@@ -97,9 +98,7 @@ public void run() {
             return;
         }
 
-        if (responseHandler != null) {
-            responseHandler.sendStartMessage();
-        }
+        responseHandler.sendStartMessage();
 
         if (isCancelled()) {
             return;
@@ -108,10 +107,10 @@ public void run() {
         try {
             makeRequestWithRetries();
         } catch (IOException e) {
-            if (!isCancelled() && responseHandler != null) {
+            if (!isCancelled()) {
                 responseHandler.sendFailureMessage(0, null, null, e);
             } else {
-                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
+                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error", e);
             }
         }
 
@@ -119,9 +118,7 @@ public void run() {
             return;
         }
 
-        if (responseHandler != null) {
-            responseHandler.sendFinishMessage();
-        }
+        responseHandler.sendFinishMessage();
 
         if (isCancelled()) {
             return;
@@ -150,7 +147,7 @@ private void makeRequest() throws IOException {
 
         HttpResponse response = client.execute(request, context);
 
-        if (isCancelled() || responseHandler == null) {
+        if (isCancelled()) {
             return;
         }
 
@@ -201,7 +198,7 @@ private void makeRequestWithRetries() throws IOException {
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                if (retry && (responseHandler != null)) {
+                if (retry) {
                     responseHandler.sendRetryMessage(executionCount);
                 }
             }
@@ -216,17 +213,17 @@ private void makeRequestWithRetries() throws IOException {
     }
 
     public boolean isCancelled() {
-        if (isCancelled) {
+        boolean cancelled = isCancelled.get();
+        if (cancelled) {
             sendCancelNotification();
         }
-        return isCancelled;
+        return cancelled;
     }
 
     private synchronized void sendCancelNotification() {
-        if (!isFinished && isCancelled && !cancelIsNotified) {
+        if (!isFinished && isCancelled.get() && !cancelIsNotified) {
             cancelIsNotified = true;
-            if (responseHandler != null)
-                responseHandler.sendCancelMessage();
+            responseHandler.sendCancelMessage();
         }
     }
 
@@ -235,7 +232,7 @@ public boolean isDone() {
     }
 
     public boolean cancel(boolean mayInterruptIfRunning) {
-        isCancelled = true;
+        isCancelled.set(true);
         request.abort();
         return isCancelled();
     }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 6943584a..1419cf3a 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -357,7 +357,7 @@ protected void sendMessage(Message msg) {
         if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
-            AssertUtils.asserts(handler != null, "handler should not be null!");
+            Utils.asserts(handler != null, "handler should not be null!");
             handler.sendMessage(msg);
         }
     }
@@ -374,7 +374,7 @@ protected void postRunnable(Runnable runnable) {
                 runnable.run();
             } else {
                 // Otherwise, run on provided handler
-                AssertUtils.asserts(handler != null, "handler should not be null!");
+                Utils.asserts(handler != null, "handler should not be null!");
                 handler.post(runnable);
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 6a546257..1a11a1a0 100755
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -52,8 +52,11 @@ public FileAsyncHttpResponseHandler(File file) {
      */
     public FileAsyncHttpResponseHandler(File file, boolean append) {
         super();
-        AssertUtils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
-        AssertUtils.asserts(getTargetFile().getParentFile().mkdirs(), "Cannot create parent directories for requested File location");
+        Utils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
+        Utils.asserts(!file.isDirectory(), "File passed into FileAsyncHttpResponseHandler constructor must not point to directory");
+        if (!file.getParentFile().isDirectory()) {
+            Utils.asserts(file.getParentFile().mkdirs(), "Cannot create parent directories for requested File location");
+        }
         this.mFile = file;
         this.append = append;
     }
@@ -85,7 +88,7 @@ public boolean deleteTargetFile() {
      * @return temporary file or null if creating file failed
      */
     protected File getTemporaryFile(Context context) {
-        AssertUtils.asserts(context != null, "Tried creating temporary file without having Context");
+        Utils.asserts(context != null, "Tried creating temporary file without having Context");
         try {
             // not effective in release mode
             assert context != null;
diff --git a/library/src/main/java/com/loopj/android/http/HttpPatch.java b/library/src/main/java/com/loopj/android/http/HttpPatch.java
new file mode 100644
index 00000000..a81cc2c5
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpPatch.java
@@ -0,0 +1,54 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.net.URI;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * the HTTP PATCH method. Until the Android version is updated this can serve in it's stead. 
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpPatch extends HttpEntityEnclosingRequestBase {
+	
+    public final static String METHOD_NAME = "PATCH";
+
+    public HttpPatch() {
+        super();
+    }
+
+    public HttpPatch(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpPatch(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/AssertUtils.java b/library/src/main/java/com/loopj/android/http/Utils.java
similarity index 50%
rename from library/src/main/java/com/loopj/android/http/AssertUtils.java
rename to library/src/main/java/com/loopj/android/http/Utils.java
index ddd7c6e4..196d5a46 100644
--- a/library/src/main/java/com/loopj/android/http/AssertUtils.java
+++ b/library/src/main/java/com/loopj/android/http/Utils.java
@@ -19,16 +19,38 @@
 package com.loopj.android.http;
 
 /**
- * Internal class, used to make some asserts, throw AssertError if asserts fail.
+ * Provides general assert utils, which are stripped by Android SDK on
+ * compile/runtime, to work on release builds
  */
-class AssertUtils {
+class Utils {
 
-    private AssertUtils() {
+    private Utils() {
     }
 
+    /**
+     * Will throw AssertionError, if expression is not true
+     *
+     * @param expression    result of your asserted condition
+     * @param failedMessage message to be included in error log
+     * @throws java.lang.AssertionError
+     */
     public static void asserts(final boolean expression, final String failedMessage) {
         if (!expression) {
             throw new AssertionError(failedMessage);
         }
     }
+
+    /**
+     * Will throw IllegalArgumentException if provided object is null on runtime
+     *
+     * @param argument object that should be asserted as not null
+     * @param name     name of the object asserted
+     * @throws java.lang.IllegalArgumentException
+     */
+    public static <T> T notNull(final T argument, final String name) {
+        if (argument == null) {
+            throw new IllegalArgumentException(name + " should not be null!");
+        }
+        return argument;
+    }
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index c3ebb2f1..a3563f58 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -21,6 +21,7 @@
         <activity android:name=".PostSample"/>
         <activity android:name=".DeleteSample"/>
         <activity android:name=".PutSample"/>
+        <activity android:name=".PatchSample"/>
         <activity android:name=".JsonSample"/>
         <activity android:name=".JsonStreamerSample"/>
         <activity android:name=".FileSample"/>
@@ -32,6 +33,7 @@
         <activity android:name=".CancelRequestHandleSample"/>
         <activity android:name=".SynchronousClientSample"/>
         <activity android:name=".IntentServiceSample"/>
+
         <activity android:name=".SaxSample"/>
         <activity android:name=".FilesSample"/>
         <activity android:name=".PersistentCookiesSample"/>
@@ -44,8 +46,8 @@
         <activity android:name=".ResumeDownloadSample"/>
         <activity android:name=".PrePostProcessingSample"/>
         <activity android:name=".DigestAuthSample"/>
-
         <service android:name=".services.ExampleIntentService"/>
+        
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
new file mode 100644
index 00000000..8bd8ab1e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
@@ -0,0 +1,68 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+public class PatchSample extends SampleParentActivity {
+
+	private static final String LOG_TAG = "PatchSample";
+	 
+	@Override
+	public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+		return client.patch(this, URL, entity, null, responseHandler);
+	}
+
+	@Override
+	public int getSampleTitle() {
+		return R.string.title_patch_sample;
+	}
+
+	@Override
+	public boolean isRequestBodyAllowed() {
+		return false;
+	}
+
+	@Override
+	public boolean isRequestHeadersAllowed() {
+		return false;
+	}
+
+	@Override
+	public String getDefaultURL() {
+		return PROTOCOL + "httpbin.org/patch";
+	}
+	
+	@Override
+	public ResponseHandlerInterface getResponseHandler() {
+		return new AsyncHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+	}
+
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
index 3daf055c..274b5e2b 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
@@ -21,16 +21,19 @@
 import android.os.Bundle;
 import android.util.Log;
 import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
 import com.loopj.android.http.RequestHandle;
 import com.loopj.android.http.ResponseHandlerInterface;
-import java.io.File;
-import java.io.IOException;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.client.methods.HttpUriRequest;
 
+import java.io.File;
+import java.io.IOException;
+
 /**
  * This sample demonstrates use of {@link RangeFileAsyncHttpResponseHandler} to
  * download a remote file in multiple requests. While this response handler
@@ -71,7 +74,9 @@ protected void onDestroy() {
 
         // Remove temporary file.
         if (file != null) {
-            file.delete();
+            if (!file.delete()) {
+                Log.e(LOG_TAG, String.format("Couldn't remove temporary file in path: %s", file.getAbsolutePath()));
+            }
             file = null;
         }
     }
@@ -133,9 +138,9 @@ public void onSuccess(int statusCode, Header[] headers, File file) {
                     // Is the content length known?
                     if (!supportsRange || fileSize < 1) {
                         Toast.makeText(
-                            RangeResponseSample.this,
-                            "Unable to determine remote file's size, or\nremote server doesn't support ranges",
-                            Toast.LENGTH_LONG
+                                RangeResponseSample.this,
+                                "Unable to determine remote file's size, or\nremote server doesn't support ranges",
+                                Toast.LENGTH_LONG
                         ).show();
                     }
                 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 099dc134..c8d6f063 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -35,6 +35,7 @@
             new SampleConfig(R.string.title_post_sample, PostSample.class),
             new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
             new SampleConfig(R.string.title_put_sample, PutSample.class),
+            new SampleConfig(R.string.title_patch_sample, PatchSample.class),
             new SampleConfig(R.string.title_json_sample, JsonSample.class),
             new SampleConfig(R.string.title_json_streamer_sample, JsonStreamerSample.class),
             new SampleConfig(R.string.title_sax_example, SaxSample.class),
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index f8465168..5cb9cd6c 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -21,6 +21,7 @@
     <string name="title_json_streamer_sample">POST JSON using streamer</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
+    <string name="title_patch_sample">PATCH</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
