diff --git a/.classpath b/.classpath
index 14fcf527..8f06e0e7 100644
--- a/.classpath
+++ b/.classpath
@@ -1,8 +1,10 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="examples"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="lib" path="lib/httpclientandroidlib-1.1.2.jar"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
index ff8a6e53..4fb1773d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,11 @@
-_site
-MANIFEST.MF
-./*.jar
-build.num
-build
-local.properties
-bin/
-gen/
-_layouts
-.DS_Store
+_site
+MANIFEST.MF
+./*.jar
+build.num
+build
+local.properties
+bin/
+gen/
+_layouts
+.DS_Store
 gh-pages
\ No newline at end of file
diff --git a/.project b/.project
index a9793139..5a165fee 100644
--- a/.project
+++ b/.project
@@ -1,33 +1,33 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>android-async-http</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>android-async-http</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index fbeab8b4..573f6dd7 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -1,11 +1,11 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http"
-    android:versionName="1.4.1"
-    android:versionCode="1">
-    <application
-        android:name="android_async_http">
-    </application>
-    <uses-sdk android:minSdkVersion="3" />
-    <uses-permission android:name="android.permission.INTERNET" />
-</manifest> 
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.loopj.android.http"
+    android:versionName="1.4.1"
+    android:versionCode="1">
+    <application
+        android:name="android_async_http">
+    </application>
+    <uses-sdk android:minSdkVersion="3" />
+    <uses-permission android:name="android.permission.INTERNET" />
+</manifest>
\ No newline at end of file
diff --git a/README.md b/README.md
index 1602a534..0d9946ab 100644
--- a/README.md
+++ b/README.md
@@ -1,25 +1,25 @@
-Asynchronous Http Client for Android
-====================================
-
-An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
-
-
-Features
---------
-- Make **asynchronous** HTTP requests, handle responses in **anonymous callbacks**
-- HTTP requests happen **outside the UI thread**
-- Requests use a **threadpool** to cap concurrent resource usage
-- GET/POST **params builder** (RequestParams)
-- **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **19kb** for everything
-- Automatic smart **request retries** optimized for spotty mobile connections
-- Automatic **gzip** response decoding support for super-fast requests
-- Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
-- Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
-
-
-Documentation, Features and Examples
-------------------------------------
-Full details and documentation can be found on the project page here:
-
+Asynchronous Http Client for Android
+====================================
+
+An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
+
+
+Features
+--------
+- Make **asynchronous** HTTP requests, handle responses in **anonymous callbacks**
+- HTTP requests happen **outside the UI thread**
+- Requests use a **threadpool** to cap concurrent resource usage
+- GET/POST **params builder** (RequestParams)
+- **Multipart file uploads** with no additional third party libraries
+- Tiny size overhead to your application, only **19kb** for everything
+- Automatic smart **request retries** optimized for spotty mobile connections
+- Automatic **gzip** response decoding support for super-fast requests
+- Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
+- Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
+
+
+Documentation, Features and Examples
+------------------------------------
+Full details and documentation can be found on the project page here:
+
 http://loopj.com/android-async-http/
\ No newline at end of file
diff --git a/build.xml b/build.xml
index 1cd94b37..930e8294 100644
--- a/build.xml
+++ b/build.xml
@@ -1,98 +1,98 @@
-<project default="package">
-    <property file="local.properties"/>
-    <property file="project.properties"/>
-
-    <!-- Package properties -->
-    <property name="package.name" value="android-async-http" />
-    <property name="package.packagename" value="com.loopj.android.http" />
-    
-    <!-- Get git commit -->
-    <available file=".git" type="dir" property="git.present"/>
-
-    <target name="git-details">
-        <exec executable="git" outputproperty="git.status">
-            <arg value="status" />
-        </exec>
-        <echo message="${git.status}"/>
-        
-        <exec executable="git" outputproperty="package.versionname">
-          <arg value="describe"/>
-          <arg value="--tags"/>
-          <arg value="--dirty"/>
-          <arg value="--always"/>
-        </exec>
-        <echo message="${package.versionname}" />
-    </target>
-
-    <!-- Standard jar stuff -->
-    <property environment="env"/>
-    <condition property="android.base" value="${sdk.dir}" else="${env.ANDROID_HOME}">
-      <isset property="sdk.dir" />
-    </condition>
-    <fail message="Please set either the sdk.dir property or the ANDROID_HOME environment variable to point to your Android SDK installation.">
-      <condition>
-        <not>
-          <available file="${android.base}" type="dir"/>
-        </not>
-      </condition>
-    </fail>
-
-    <property name="lib.dir" value="${android.base}/platforms/${target}" />
-    <property name="build.dir" value="./build"/>
-    <property name="classes.dir"  value="${build.dir}/classes"/>
-    <buildnumber file="build.num" />
-
-    <!-- Set up classpath -->
-    <path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar" />
-    </path>
-
-    <!-- Build javadoc -->
-    <target name="doc">
-        <javadoc 
-            classpathref="classpath"
-            sourcepath="gen:src"
-            destdir="doc"
-            packagenames="${package.packagename}"
-            linkoffline="http://d.android.com/reference ${android.base}/docs/reference" 
-            additionalparam="-author  -version"
-            />
-    </target>
-
-    <!-- Compile java files into classes -->
-    <target name="compile">
-        <mkdir dir="${build.dir}" />
-        <mkdir dir="${classes.dir}" />
-
-        <javac
-            includeantruntime="false"
-            srcdir="src"
-            destdir="${classes.dir}"
-            classpathref="classpath"
-            debug="true"
-            debuglevel="lines,source" />
-    </target>
-
-    <!-- Package a jar from compiled class files -->
-    <target name="jar" depends="git-details,compile">
-        <manifest file="MANIFEST.MF">
-            <attribute name="Built-By" value="${user.name}" />
-            <attribute name="Implementation-Version" value="${package.versionname}"/> 
-        </manifest>
-
-        <jar destfile="${package.name}-${package.versionname}.jar" basedir="build/classes" includes="com/loopj/android/http/**/*.class" manifest="MANIFEST.MF" />
-    </target>
-
-    <!-- Clean out the build files -->
-    <target name="clean">
-        <delete dir="build" />
-        <delete dir="doc" />
-        <delete>
-            <fileset dir="." includes="*.jar"/>
-            <fileset file="MANIFEST.MF"/>
-        </delete>
-    </target>
-
-    <!-- Compile and package a jar -->
-    <target name="package" depends="compile,jar" />
-</project>
+<project default="package">
+    <property file="local.properties"/>
+    <property file="project.properties"/>
+
+    <!-- Package properties -->
+    <property name="package.name" value="android-async-http" />
+    <property name="package.packagename" value="com.loopj.android.http" />
+    
+    <!-- Get git commit -->
+    <available file=".git" type="dir" property="git.present"/>
+
+    <target name="git-details">
+        <exec executable="git" outputproperty="git.status">
+            <arg value="status" />
+        </exec>
+        <echo message="${git.status}"/>
+        
+        <exec executable="git" outputproperty="package.versionname">
+          <arg value="describe"/>
+          <arg value="--tags"/>
+          <arg value="--dirty"/>
+          <arg value="--always"/>
+        </exec>
+        <echo message="${package.versionname}" />
+    </target>
+
+    <!-- Standard jar stuff -->
+    <property environment="env"/>
+    <condition property="android.base" value="${sdk.dir}" else="${env.ANDROID_HOME}">
+      <isset property="sdk.dir" />
+    </condition>
+    <fail message="Please set either the sdk.dir property or the ANDROID_HOME environment variable to point to your Android SDK installation.">
+      <condition>
+        <not>
+          <available file="${android.base}" type="dir"/>
+        </not>
+      </condition>
+    </fail>
+
+    <property name="lib.dir" value="${android.base}/platforms/${target}" />
+    <property name="build.dir" value="./build"/>
+    <property name="classes.dir"  value="${build.dir}/classes"/>
+    <buildnumber file="build.num" />
+
+    <!-- Set up classpath -->
+    <path id="classpath">
+        <fileset dir="${lib.dir}" includes="**/*.jar" />
+    </path>
+
+    <!-- Build javadoc -->
+    <target name="doc">
+        <javadoc 
+            classpathref="classpath"
+            sourcepath="gen:src"
+            destdir="doc"
+            packagenames="${package.packagename}"
+            linkoffline="http://d.android.com/reference ${android.base}/docs/reference" 
+            additionalparam="-author  -version"
+            />
+    </target>
+
+    <!-- Compile java files into classes -->
+    <target name="compile">
+        <mkdir dir="${build.dir}" />
+        <mkdir dir="${classes.dir}" />
+
+        <javac
+            includeantruntime="false"
+            srcdir="src"
+            destdir="${classes.dir}"
+            classpathref="classpath"
+            debug="true"
+            debuglevel="lines,source" />
+    </target>
+
+    <!-- Package a jar from compiled class files -->
+    <target name="jar" depends="git-details,compile">
+        <manifest file="MANIFEST.MF">
+            <attribute name="Built-By" value="${user.name}" />
+            <attribute name="Implementation-Version" value="${package.versionname}"/> 
+        </manifest>
+
+        <jar destfile="${package.name}-${package.versionname}.jar" basedir="build/classes" includes="com/loopj/android/http/**/*.class" manifest="MANIFEST.MF" />
+    </target>
+
+    <!-- Clean out the build files -->
+    <target name="clean">
+        <delete dir="build" />
+        <delete dir="doc" />
+        <delete>
+            <fileset dir="." includes="*.jar"/>
+            <fileset file="MANIFEST.MF"/>
+        </delete>
+    </target>
+
+    <!-- Compile and package a jar -->
+    <target name="package" depends="compile,jar" />
+</project>
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
index 2b7a4fa0..b8d9f776 100644
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -1,14 +1,14 @@
-import com.loopj.android.http.*;
-
-public class ExampleUsage {
-    public static void makeRequest() {
-        AsyncHttpClient client = new AsyncHttpClient();
-
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
-            @Override
-            public void onSuccess(String response) {
-                System.out.println(response);
-            }
-        });
-    }
+import com.loopj.android.http.*;
+
+public class ExampleUsage {
+    public static void makeRequest() {
+        AsyncHttpClient client = new AsyncHttpClient();
+
+        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+            @Override
+            public void onSuccess(String response) {
+                System.out.println(response);
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
index 387a8711..f1423826 100644
--- a/examples/TwitterRestClient.java
+++ b/examples/TwitterRestClient.java
@@ -1,21 +1,21 @@
-// Static wrapper library around AsyncHttpClient
-
-import com.loopj.android.http.*;
-
-public class TwitterRestClient {
-    private static final String BASE_URL = "http://api.twitter.com/1/";
-
-    private static AsyncHttpClient client = new AsyncHttpClient();
-
-    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.post(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    private static String getAbsoluteUrl(String relativeUrl) {
-        return BASE_URL + relativeUrl;
-    }
+// Static wrapper library around AsyncHttpClient
+
+import com.loopj.android.http.*;
+
+public class TwitterRestClient {
+    private static final String BASE_URL = "http://api.twitter.com/1/";
+
+    private static AsyncHttpClient client = new AsyncHttpClient();
+
+    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        client.get(getAbsoluteUrl(url), params, responseHandler);
+    }
+
+    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        client.post(getAbsoluteUrl(url), params, responseHandler);
+    }
+
+    private static String getAbsoluteUrl(String relativeUrl) {
+        return BASE_URL + relativeUrl;
+    }
 }
\ No newline at end of file
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
index a4c89c8c..473c9705 100644
--- a/examples/TwitterRestClientUsage.java
+++ b/examples/TwitterRestClientUsage.java
@@ -1,21 +1,21 @@
-import org.json.*;
-import com.loopj.android.http.*;
-
-class TwitterRestClientUsage {
-    public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
-            @Override
-            public void onSuccess(JSONArray timeline) {
-                try {
-                    JSONObject firstEvent = (JSONObject)timeline.get(0);
-                    String tweetText = firstEvent.getString("text");
-
-                    // Do something with the response
-                    System.out.println(tweetText);
-                } catch(JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
+import org.json.*;
+import com.loopj.android.http.*;
+
+class TwitterRestClientUsage {
+    public void getPublicTimeline() {
+        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
+            @Override
+            public void onSuccess(JSONArray timeline) {
+                try {
+                    JSONObject firstEvent = (JSONObject)timeline.get(0);
+                    String tweetText = firstEvent.getString("text");
+
+                    // Do something with the response
+                    System.out.println(tweetText);
+                } catch(JSONException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/lib/httpclientandroidlib-1.1.2.jar b/lib/httpclientandroidlib-1.1.2.jar
new file mode 100644
index 00000000..e4efbc10
Binary files /dev/null and b/lib/httpclientandroidlib-1.1.2.jar differ
diff --git a/project.properties b/project.properties
index 1880987e..91d81244 100644
--- a/project.properties
+++ b/project.properties
@@ -1,12 +1,12 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-3
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system use,
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+
+android.library=true
+# Project target.
+target=android-3
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 6053a569..6802479b 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -1,618 +1,620 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.zip.GZIPInputStream;
-
-import org.apache.http.Header;
-import org.apache.http.HeaderElement;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpResponseInterceptor;
-import org.apache.http.HttpVersion;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpDelete;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.client.protocol.ClientContext;
-import org.apache.http.conn.params.ConnManagerParams;
-import org.apache.http.conn.params.ConnPerRouteBean;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.entity.HttpEntityWrapper;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.BasicHttpContext;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.protocol.SyncBasicHttpContext;
-
-import android.content.Context;
-
-
-/**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
- * DELETE HTTP requests in your Android applications. Requests can be made
- * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
- * {@link AsyncHttpResponseHandler} instance.
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
- *     }
- * });
- * </pre>
- */
-public class AsyncHttpClient {
-    private static final String VERSION = "1.4.1";
-
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-
-
-    /**
-     * Creates a new AsyncHttpClient.
-     */
-    public AsyncHttpClient() {
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            public void process(HttpRequest request, HttpContext context) {
-                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-                }
-                for (String header : clientHeaderMap.keySet()) {
-                    request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                if (entity == null) {
-                    return;
-                }
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Get the underlying HttpContext instance. This is useful for getting 
-     * and setting fine-grained settings for requests by accessing the
-     * context's attributes such as the CookieStore.
-     */
-    public HttpContext getHttpContext() {
-        return this.httpContext;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
-     */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-    /**
-     * Sets the connection time oout. By default, 10 seconds
-     * @param timeout the connect/socket timeout in milliseconds
-     */
-    public void setTimeout(int timeout){
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-    
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     * @param header the name of the header
-     * @param value the contents of the header
-     */
-    public void addHeader(String header, String value) {
-        clientHeaderMap.put(header, value);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
-     * @param username
-     * @param password
-     */
-    public void setBasicAuth(String user, String pass){
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
-    }
-    
-   /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
-     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     * @param username
-     * @param password
-     * @param scope - an AuthScope object
-     *
-     */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
-     *
-     * @param context the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
-     */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.remove(context);
-    }
-
-
-    //
-    // HTTP GET Requests
-    //
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-
-    //
-    // HTTP POST Requests
-    //
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP PUT Requests
-    //
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-
-    // Private stuff
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
-
-        if(context != null) {
-            // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
-            }
-
-            requestList.add(new WeakReference<Future<?>>(request));
-
-            // TODO: Remove dead weakrefs from requestLists?
-        }
-    }
-
-    public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
-            String paramString = params.getParamString();
-            if (url.indexOf("?") == -1) {
-                url += "?" + paramString;
-            } else {
-                url += "&" + paramString;
-            }
-        }
-
-        return url;
-    }
-
-    private HttpEntity paramsToEntity(RequestParams params) {
-        HttpEntity entity = null;
-
-        if(params != null) {
-            entity = params.getEntity();
-        }
-
-        return entity;
-    }
-
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    private static class InflatingEntity extends HttpEntityWrapper {
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
-        public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
-        }
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
-}
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
+
+import android.content.Context;
+import ch.boye.httpclientandroidlib.Header;
+import ch.boye.httpclientandroidlib.HeaderElement;
+import ch.boye.httpclientandroidlib.HttpEntity;
+import ch.boye.httpclientandroidlib.HttpRequest;
+import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
+import ch.boye.httpclientandroidlib.HttpResponse;
+import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
+import ch.boye.httpclientandroidlib.HttpVersion;
+import ch.boye.httpclientandroidlib.auth.AuthScope;
+import ch.boye.httpclientandroidlib.auth.UsernamePasswordCredentials;
+import ch.boye.httpclientandroidlib.client.CookieStore;
+import ch.boye.httpclientandroidlib.client.HttpClient;
+import ch.boye.httpclientandroidlib.client.methods.HttpDelete;
+import ch.boye.httpclientandroidlib.client.methods.HttpEntityEnclosingRequestBase;
+import ch.boye.httpclientandroidlib.client.methods.HttpGet;
+import ch.boye.httpclientandroidlib.client.methods.HttpPost;
+import ch.boye.httpclientandroidlib.client.methods.HttpPut;
+import ch.boye.httpclientandroidlib.client.methods.HttpUriRequest;
+import ch.boye.httpclientandroidlib.client.protocol.ClientContext;
+import ch.boye.httpclientandroidlib.conn.params.ConnManagerParams;
+import ch.boye.httpclientandroidlib.conn.params.ConnPerRouteBean;
+import ch.boye.httpclientandroidlib.conn.scheme.PlainSocketFactory;
+import ch.boye.httpclientandroidlib.conn.scheme.Scheme;
+import ch.boye.httpclientandroidlib.conn.scheme.SchemeRegistry;
+import ch.boye.httpclientandroidlib.conn.ssl.SSLSocketFactory;
+import ch.boye.httpclientandroidlib.entity.HttpEntityWrapper;
+import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
+import ch.boye.httpclientandroidlib.impl.conn.tsccm.ThreadSafeClientConnManager;
+import ch.boye.httpclientandroidlib.params.BasicHttpParams;
+import ch.boye.httpclientandroidlib.params.HttpConnectionParams;
+import ch.boye.httpclientandroidlib.params.HttpParams;
+import ch.boye.httpclientandroidlib.params.HttpProtocolParams;
+import ch.boye.httpclientandroidlib.protocol.BasicHttpContext;
+import ch.boye.httpclientandroidlib.protocol.HttpContext;
+import ch.boye.httpclientandroidlib.protocol.SyncBasicHttpContext;
+
+
+/**
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
+ * DELETE HTTP requests in your Android applications. Requests can be made
+ * with additional parameters by passing a {@link RequestParams} instance,
+ * and responses can be handled by passing an anonymously overridden 
+ * {@link AsyncHttpResponseHandler} instance.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onSuccess(String response) {
+ *         System.out.println(response);
+ *     }
+ * });
+ * </pre>
+ */
+public class AsyncHttpClient {
+    private static final String VERSION = "1.4.1";
+
+    private static final int DEFAULT_MAX_CONNECTIONS = 10;
+    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+    private static final int DEFAULT_MAX_RETRIES = 5;
+    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    private static final String ENCODING_GZIP = "gzip";
+
+    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
+    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+    private final DefaultHttpClient httpClient;
+    private final HttpContext httpContext;
+    private ThreadPoolExecutor threadPool;
+    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+    private final Map<String, String> clientHeaderMap;
+
+
+    /**
+     * Creates a new AsyncHttpClient.
+     */
+    public AsyncHttpClient() {
+        BasicHttpParams httpParams = new BasicHttpParams();
+
+        ConnManagerParams.setTimeout(httpParams, socketTimeout);
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
+        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setTcpNoDelay(httpParams, true);
+        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+
+        SchemeRegistry schemeRegistry = new SchemeRegistry();
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+
+        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+        httpClient = new DefaultHttpClient(cm, httpParams);
+		
+        HttpProtocolParams.setUseExpectContinue(httpClient.getParams(), false);
+        
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            public void process(HttpRequest request, HttpContext context) {
+                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+                }
+                for (String header : clientHeaderMap.keySet()) {
+                    request.addHeader(header, clientHeaderMap.get(header));
+                }
+            }
+        });
+
+        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+            public void process(HttpResponse response, HttpContext context) {
+                final HttpEntity entity = response.getEntity();
+                if (entity == null) {
+                    return;
+                }
+                final Header encoding = entity.getContentEncoding();
+                if (encoding != null) {
+                    for (HeaderElement element : encoding.getElements()) {
+                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+                            response.setEntity(new InflatingEntity(response.getEntity()));
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+
+        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
+
+        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        clientHeaderMap = new HashMap<String, String>();
+    }
+
+    /**
+     * Get the underlying HttpClient instance. This is useful for setting
+     * additional fine-grained settings for requests by accessing the
+     * client's ConnectionManager, HttpParams and SchemeRegistry.
+     */
+    public HttpClient getHttpClient() {
+        return this.httpClient;
+    }
+
+    /**
+     * Get the underlying HttpContext instance. This is useful for getting 
+     * and setting fine-grained settings for requests by accessing the
+     * context's attributes such as the CookieStore.
+     */
+    public HttpContext getHttpContext() {
+        return this.httpContext;
+    }
+
+    /**
+     * Sets an optional CookieStore to use when making requests
+     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
+     */
+    public void setCookieStore(CookieStore cookieStore) {
+        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+    }
+
+    /**
+     * Overrides the threadpool implementation used when queuing/pooling
+     * requests. By default, Executors.newCachedThreadPool() is used.
+     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
+     */
+    public void setThreadPool(ThreadPoolExecutor threadPool) {
+        this.threadPool = threadPool;
+    }
+
+    /**
+     * Sets the User-Agent header to be sent with each request. By default,
+     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     * @param userAgent the string to use in the User-Agent header.
+     */
+    public void setUserAgent(String userAgent) {
+        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+    }
+
+    /**
+     * Sets the connection time oout. By default, 10 seconds
+     * @param timeout the connect/socket timeout in milliseconds
+     */
+    public void setTimeout(int timeout){
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+    }
+
+    /**
+     * Sets the SSLSocketFactory to user when making requests. By default,
+     * a new, default SSLSocketFactory is used.
+     * @param sslSocketFactory the socket factory to use for https requests.
+     */
+    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
+    }
+    
+    /**
+     * Sets headers that will be added to all requests this client makes (before sending).
+     * @param header the name of the header
+     * @param value the contents of the header
+     */
+    public void addHeader(String header, String value) {
+        clientHeaderMap.put(header, value);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY) 
+     * @param username
+     * @param password
+     */
+    public void setBasicAuth(String user, String pass){
+        AuthScope scope = AuthScope.ANY;
+        setBasicAuth(user, pass, scope);
+    }
+    
+   /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
+     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     * @param username
+     * @param password
+     * @param scope - an AuthScope object
+     *
+     */
+    public void setBasicAuth( String user, String pass, AuthScope scope){
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
+        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+    }
+
+    /**
+     * Cancels any pending (or potentially active) requests associated with the
+     * passed Context.
+     * <p>
+     * <b>Note:</b> This will only affect requests which were created with a non-null
+     * android Context. This method is intended to be used in the onDestroy
+     * method of your android activities to destroy all requests which are no
+     * longer required.
+     *
+     * @param context the android Context instance associated to the request.
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
+     */
+    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
+        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+        if(requestList != null) {
+            for(WeakReference<Future<?>> requestRef : requestList) {
+                Future<?> request = requestRef.get();
+                if(request != null) {
+                    request.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.remove(context);
+    }
+
+
+    //
+    // HTTP GET Requests
+    //
+
+    /**
+     * Perform a HTTP GET request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(String url, AsyncHttpResponseHandler responseHandler) {
+        get(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        get(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        get(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated
+     * the request with customized headers
+     * 
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
+
+    //
+    // HTTP POST Requests
+    //
+
+    /**
+     * Perform a HTTP POST request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(String url, AsyncHttpResponseHandler responseHandler) {
+        post(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        post(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        post(context, url, paramsToEntity(params), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated
+     * the request. Set headers only for this request
+     * 
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param params additional POST parameters to send with the request.
+     * @param contentType the content type of the payload you are sending, for
+     *        example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+            AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        if(params != null) request.setEntity(paramsToEntity(params));
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType,
+                responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated
+     * the request. Set headers only for this request
+     *
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param entity a raw {@link HttpEntity} to send with the request, for
+     *        example, use this to send string/json/xml payloads to a server by
+     *        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for
+     *        example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+            AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    //
+    // HTTP PUT Requests
+    //
+
+    /**
+     * Perform a HTTP PUT request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(String url, AsyncHttpResponseHandler responseHandler) {
+        put(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        put(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        put(context, url, paramsToEntity(params), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * And set one-time headers for the request
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * And set one-time headers for the request
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set one-time headers for this request
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    //
+    // HTTP DELETE Requests
+    //
+
+    /**
+     * Perform a HTTP DELETE request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
+        delete(null, url, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP DELETE request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(url);
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP DELETE request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set one-time headers for this request
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(url);
+        if(headers != null) delete.setHeaders(headers);
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+
+
+    // Private stuff
+    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
+        if(contentType != null) {
+            uriRequest.addHeader("Content-Type", contentType);
+        }
+
+        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
+
+        if(context != null) {
+            // Add request to request map
+            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+            if(requestList == null) {
+                requestList = new LinkedList<WeakReference<Future<?>>>();
+                requestMap.put(context, requestList);
+            }
+
+            requestList.add(new WeakReference<Future<?>>(request));
+
+            // TODO: Remove dead weakrefs from requestLists?
+        }
+    }
+
+    public static String getUrlWithQueryString(String url, RequestParams params) {
+        if(params != null) {
+            String paramString = params.getParamString();
+            if (url.indexOf("?") == -1) {
+                url += "?" + paramString;
+            } else {
+                url += "&" + paramString;
+            }
+        }
+
+        return url;
+    }
+
+    private HttpEntity paramsToEntity(RequestParams params) {
+        HttpEntity entity = null;
+
+        if(params != null) {
+            entity = params.getEntity();
+        }
+
+        return entity;
+    }
+
+    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
+        if(entity != null){
+            requestBase.setEntity(entity);
+        }
+
+        return requestBase;
+    }
+
+    private static class InflatingEntity extends HttpEntityWrapper {
+        public InflatingEntity(HttpEntity wrapped) {
+            super(wrapped);
+        }
+
+        @Override
+        public InputStream getContent() throws IOException {
+            return new GZIPInputStream(wrappedEntity.getContent());
+        }
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
index 9f4b19dc..de8ddb08 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -1,136 +1,145 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-class AsyncHttpRequest implements Runnable {
-    private final AbstractHttpClient client;
-    private final HttpContext context;
-    private final HttpUriRequest request;
-    private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
-    private int executionCount;
-
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
-    }
-
-    public void run() {
-        try {
-            if(responseHandler != null){
-                responseHandler.sendStartMessage();
-            }
-
-            makeRequestWithRetries();
-
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
-        } catch (IOException e) {
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                if(this.isBinaryRequest) {
-                    responseHandler.sendFailureMessage(e, (byte[]) null);
-                } else {
-                    responseHandler.sendFailureMessage(e, (String) null);
-                }
-            }
-        }
-    }
-
-    private void makeRequest() throws IOException {
-        if(!Thread.currentThread().isInterrupted()) {
-        	try {
-        		HttpResponse response = client.execute(request, context);
-        		if(!Thread.currentThread().isInterrupted()) {
-        			if(responseHandler != null) {
-        				responseHandler.sendResponseMessage(response);
-        			}
-        		} else{
-        			//TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
-        		}
-        	} catch (IOException e) {
-        		if(!Thread.currentThread().isInterrupted()) {
-        			throw e;
-        		}
-        	}
-        }
-    }
-
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
-        boolean retry = true;
-        IOException cause = null;
-        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
-                // Added to detect host unreachable
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
-                }
-                return;
-            }catch (SocketTimeoutException e){
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
-                }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient" + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            }
-        }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
-    }
-}
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
+import ch.boye.httpclientandroidlib.HttpResponse;
+import ch.boye.httpclientandroidlib.client.HttpRequestRetryHandler;
+import ch.boye.httpclientandroidlib.client.methods.HttpUriRequest;
+import ch.boye.httpclientandroidlib.client.params.ClientPNames;
+import ch.boye.httpclientandroidlib.conn.ConnectTimeoutException;
+import ch.boye.httpclientandroidlib.impl.client.AbstractHttpClient;
+import ch.boye.httpclientandroidlib.protocol.HttpContext;
+
+class AsyncHttpRequest implements Runnable {
+	private final AbstractHttpClient client;
+	private final HttpContext context;
+	private final HttpUriRequest request;
+	private final AsyncHttpResponseHandler responseHandler;
+	private boolean isBinaryRequest;
+	private int executionCount;
+
+	public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request,
+	        AsyncHttpResponseHandler responseHandler) {
+		this.client = client;
+		this.context = context;
+		this.request = request;
+		this.responseHandler = responseHandler;
+		if (responseHandler instanceof BinaryHttpResponseHandler) {
+			this.isBinaryRequest = true;
+		}
+	}
+
+	public void run() {
+		try {
+			if (responseHandler != null) {
+				responseHandler.sendStartMessage();
+			}
+
+			makeRequestWithRetries();
+
+			if (responseHandler != null) {
+				responseHandler.sendFinishMessage();
+			}
+		} catch (IOException e) {
+			if (responseHandler != null) {
+				responseHandler.sendFinishMessage();
+				if (this.isBinaryRequest) {
+					responseHandler.sendFailureMessage(e, (byte[]) null);
+				} else {
+					responseHandler.sendFailureMessage(e, (String) null);
+				}
+			}
+		}
+	}
+
+	private void makeRequest() throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			client.getParams().setParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, true);
+			try {
+				HttpResponse response = client.execute(request, context);
+				if (!Thread.currentThread().isInterrupted()) {
+					if (responseHandler != null) {
+						responseHandler.sendResponseMessage(response);
+					}
+				} else {
+					// TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
+				}
+			} catch (IOException e) {
+				if (!Thread.currentThread().isInterrupted()) {
+					throw e;
+				}
+			}
+		}
+	}
+
+	private void makeRequestWithRetries() throws ConnectException {
+		// This is an additional layer of retry logic lifted from droid-fu
+		// See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+		boolean retry = true;
+		IOException cause = null;
+		HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
+		while (retry) {
+			try {
+				makeRequest();
+				return;
+			} catch (UnknownHostException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketException e) {
+				// Added to detect host unreachable
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketTimeoutException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "socket time out");
+				}
+				return;
+			} catch (ConnectTimeoutException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "connection time out");
+				}
+				return;
+			} catch (IOException e) {
+				cause = e;
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			} catch (NullPointerException e) {
+				// there's a bug in HttpClient 4.0.x that on some occasions causes
+				// DefaultRequestExecutor to throw an NPE, see
+				// http://code.google.com/p/android/issues/detail?id=5255
+				cause = new IOException("NPE in HttpClient" + e.getMessage());
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			}
+		}
+
+		// no retries left, crap out with exception
+		ConnectException ex = new ConnectException();
+		ex.initCause(cause);
+		throw ex;
+	}
+}
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 86fbdec9..846d8084 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -1,240 +1,242 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-import java.io.IOException;
-
-/**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
- * designed to be anonymously overridden with your own response handling code.
- * <p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         // Successfully got a response
- *     }
- * 
- *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public class AsyncHttpResponseHandler {
-    protected static final int SUCCESS_MESSAGE = 0;
-    protected static final int FAILURE_MESSAGE = 1;
-    protected static final int START_MESSAGE = 2;
-    protected static final int FINISH_MESSAGE = 3;
-
-    private Handler handler;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {}
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
-     */
-    public void onFinish() {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(String content) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    public void onFailure(Throwable error) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
-     */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
-    }
-
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-    
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    protected void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    protected void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, String responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
-    }
-
-
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
-        }
-    }
-
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = Message.obtain();
-            msg.what = responseMessage;
-            msg.obj = response;
-        }
-        return msg;
-    }
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
-            }
-        } catch(IOException e) {
-            sendFailureMessage(e, (String) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import ch.boye.httpclientandroidlib.HttpEntity;
+import ch.boye.httpclientandroidlib.HttpResponse;
+import ch.boye.httpclientandroidlib.StatusLine;
+import ch.boye.httpclientandroidlib.client.HttpResponseException;
+import ch.boye.httpclientandroidlib.entity.BufferedHttpEntity;
+import ch.boye.httpclientandroidlib.util.EntityUtils;
+
+
+
+/**
+ * Used to intercept and handle the responses from requests made using 
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * designed to be anonymously overridden with your own response handling code.
+ * <p>
+ * Additionally, you can override the {@link #onFailure(Throwable, String)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String response) {
+ *         // Successfully got a response
+ *     }
+ * 
+ *     &#064;Override
+ *     public void onFailure(Throwable e, String response) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public class AsyncHttpResponseHandler {
+    protected static final int SUCCESS_MESSAGE = 0;
+    protected static final int FAILURE_MESSAGE = 1;
+    protected static final int START_MESSAGE = 2;
+    protected static final int FINISH_MESSAGE = 3;
+
+    private Handler handler;
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public AsyncHttpResponseHandler() {
+        // Set up a handler to post events back to the correct thread if possible
+        if(Looper.myLooper() != null) {
+            handler = new Handler(){
+                public void handleMessage(Message msg){
+                    AsyncHttpResponseHandler.this.handleMessage(msg);
+                }
+            };
+        }
+    }
+
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when the request is started, override to handle in your own code
+     */
+    public void onStart() {}
+
+    /**
+     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
+     */
+    public void onFinish() {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param content the body of the HTTP response from the server
+     */
+    public void onSuccess(String content) {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param statusCode the status code of the response
+     * @param content the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, String content) {
+        onSuccess(content);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @deprecated use {@link #onFailure(Throwable, String)}
+     */
+    public void onFailure(Throwable error) {}
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @param content the response body, if any
+     */
+    public void onFailure(Throwable error, String content) {
+        // By default, call the deprecated onFailure(Throwable) for compatibility
+        onFailure(error);
+    }
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    protected void sendSuccessMessage(int statusCode, String responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
+    }
+
+    protected void sendFailureMessage(Throwable e, String responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+    
+    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+
+    protected void sendStartMessage() {
+        sendMessage(obtainMessage(START_MESSAGE, null));
+    }
+
+    protected void sendFinishMessage() {
+        sendMessage(obtainMessage(FINISH_MESSAGE, null));
+    }
+
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    protected void handleSuccessMessage(int statusCode, String responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(Throwable e, String responseBody) {
+        onFailure(e, responseBody);
+    }
+
+
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+
+        switch(msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[])msg.obj;
+                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[])msg.obj;
+                handleFailureMessage((Throwable)response[0], (String)response[1]);
+                break;
+            case START_MESSAGE:
+                onStart();
+                break;
+            case FINISH_MESSAGE:
+                onFinish();
+                break;
+        }
+    }
+
+    protected void sendMessage(Message msg) {
+        if(handler != null){
+            handler.sendMessage(msg);
+        } else {
+            handleMessage(msg);
+        }
+    }
+
+    protected Message obtainMessage(int responseMessage, Object response) {
+        Message msg = null;
+        if(handler != null){
+            msg = this.handler.obtainMessage(responseMessage, response);
+        }else{
+            msg = Message.obtain();
+            msg.what = responseMessage;
+            msg.obj = response;
+        }
+        return msg;
+    }
+
+    // Interface to AsyncHttpRequest
+    void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+        String responseBody = null;
+        try {
+            HttpEntity entity = null;
+            HttpEntity temp = response.getEntity();
+            if(temp != null) {
+                entity = new BufferedHttpEntity(temp);
+                responseBody = EntityUtils.toString(entity, "UTF-8");
+            }
+        } catch(IOException e) {
+            sendFailureMessage(e, (String) null);
+        }
+
+        if(status.getStatusCode() >= 300) {
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), responseBody);
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index aff1c631..2aed2404 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -1,192 +1,192 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.os.Message;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-import java.io.IOException;
-
-/**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
- * Content-length).
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * String[] allowedTypes = new String[] { "image/png" };
- * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
- *     &#064;Override
- *     public void onSuccess(byte[] imageData) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(Throwable e, byte[] imageData) {
- *         // Response failed :(
- *     }
- * });
- * </pre>
- */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
-    // Allow images by default
-    private static String[] mAllowedContentTypes = new String[] {
-        "image/jpeg",
-        "image/png"
-    };
-
-    /**
-     * Creates a new BinaryHttpResponseHandler
-     */
-    public BinaryHttpResponseHandler() {
-        super();
-    }
-
-    /**
-     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
-     * content types with passed String array (hopefully) of content types.
-     */
-    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param binaryData the response body, if any
-     * @deprecated
-     */
-    public void onFailure(Throwable error, byte[] binaryData) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
-    }
-
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (byte[])response[1]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        byte[] responseBody = null;
-        if(contentTypeHeaders.length != 1) {
-            //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
-            return;
-        }
-        Header contentTypeHeader = contentTypeHeaders[0];
-        boolean foundAllowedContentType = false;
-        for(String anAllowedContentType : mAllowedContentTypes) {
-            if(anAllowedContentType.equals(contentTypeHeader.getValue())) {
-                foundAllowedContentType = true;
-            }
-        }
-        if(!foundAllowedContentType) {
-            //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
-            return;
-        }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, (byte[]) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+import android.os.Message;
+import ch.boye.httpclientandroidlib.Header;
+import ch.boye.httpclientandroidlib.HttpEntity;
+import ch.boye.httpclientandroidlib.HttpResponse;
+import ch.boye.httpclientandroidlib.StatusLine;
+import ch.boye.httpclientandroidlib.client.HttpResponseException;
+import ch.boye.httpclientandroidlib.entity.BufferedHttpEntity;
+import ch.boye.httpclientandroidlib.util.EntityUtils;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. Receives response body as byte array with a 
+ * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * Content-length).
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * String[] allowedTypes = new String[] { "image/png" };
+ * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
+ *     &#064;Override
+ *     public void onSuccess(byte[] imageData) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(Throwable e, byte[] imageData) {
+ *         // Response failed :(
+ *     }
+ * });
+ * </pre>
+ */
+public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+    // Allow images by default
+    private static String[] mAllowedContentTypes = new String[] {
+        "image/jpeg",
+        "image/png"
+    };
+
+    /**
+     * Creates a new BinaryHttpResponseHandler
+     */
+    public BinaryHttpResponseHandler() {
+        super();
+    }
+
+    /**
+     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
+     * content types with passed String array (hopefully) of content types.
+     */
+    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
+        this();
+        mAllowedContentTypes = allowedContentTypes;
+    }
+
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param binaryData the body of the HTTP response from the server
+     */
+    public void onSuccess(byte[] binaryData) {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param statusCode the status code of the response
+     * @param binaryData the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, byte[] binaryData) {
+        onSuccess(binaryData);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @param binaryData the response body, if any
+     * @deprecated
+     */
+    public void onFailure(Throwable error, byte[] binaryData) {
+        // By default, call the deprecated onFailure(Throwable) for compatibility
+        onFailure(error);
+    }
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
+    }
+
+    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
+        onFailure(e, responseBody);
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+        switch(msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[])msg.obj;
+                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[])msg.obj;
+                handleFailureMessage((Throwable)response[0], (byte[])response[1]);
+                break;
+            default:
+                super.handleMessage(msg);
+                break;
+        }
+    }
+
+    // Interface to AsyncHttpRequest
+    void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        byte[] responseBody = null;
+        if(contentTypeHeaders.length != 1) {
+            //malformed/ambiguous HTTP Header, ABORT!
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+            return;
+        }
+        Header contentTypeHeader = contentTypeHeaders[0];
+        boolean foundAllowedContentType = false;
+        for(String anAllowedContentType : mAllowedContentTypes) {
+            if(anAllowedContentType.equals(contentTypeHeader.getValue())) {
+                foundAllowedContentType = true;
+            }
+        }
+        if(!foundAllowedContentType) {
+            //Content-Type not in allowed list, ABORT!
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+            return;
+        }
+        try {
+            HttpEntity entity = null;
+            HttpEntity temp = response.getEntity();
+            if(temp != null) {
+                entity = new BufferedHttpEntity(temp);
+            }
+            responseBody = EntityUtils.toByteArray(entity);
+        } catch(IOException e) {
+            sendFailureMessage(e, (byte[]) null);
+        }
+
+        if(status.getStatusCode() >= 300) {
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), responseBody);
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 084bf339..e6231c9b 100644
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -1,169 +1,169 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.HttpStatus;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-import android.os.Message;
-
-/**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
- * or {@link JSONArray}.
- * <p>
- * This class is designed to be passed to get, post, put and delete requests
- * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
- * methods anonymously overridden.
- * <p>
- * Additionally, you can override the other event methods from the
- * parent class.
- */
-public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    protected static final int SUCCESS_JSON_MESSAGE = 100;
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {}
-
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(JSONArray response) {}
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
-    }
-
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, JSONArray response) {
-        onSuccess(response);
-    }
-
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    @Override
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-    	if (statusCode != HttpStatus.SC_NO_CONTENT){
-	        try {
-	            Object jsonResponse = parseResponse(responseBody);
-	            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, jsonResponse}));
-	        } catch(JSONException e) {
-	            sendFailureMessage(e, responseBody);
-	        }
-    	}else{
-    		sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
-    	}
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    @Override
-    protected void handleMessage(Message msg) {
-        switch(msg.what){
-            case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage(((Integer) response[0]).intValue(), response[1]);
-                break;
-            default:
-                super.handleMessage(msg);
-        }
-    }
-
-    protected void handleSuccessJsonMessage(int statusCode, Object jsonResponse) {
-        if(jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, (JSONObject)jsonResponse);
-        } else if(jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, (JSONArray)jsonResponse);
-        } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
-        }
-    }
-
-    protected Object parseResponse(String responseBody) throws JSONException {
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-		responseBody = responseBody.trim();
-		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
-			result = new JSONTokener(responseBody).nextValue();
-		}
-		if (result == null) {
-			result = responseBody;
-		}
-		return result;
-    }
-
-    @Override
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        try {
-            if (responseBody != null) {
-                Object jsonResponse = parseResponse(responseBody);
-                if(jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject)jsonResponse);
-                } else if(jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray)jsonResponse);
-                } else {
-                    onFailure(e, responseBody);
-                }
-            }else {
-                onFailure(e, "");
-            }
-        }catch(JSONException ex) {
-            onFailure(e, responseBody);
-        }
-    }
-}
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import android.os.Message;
+import ch.boye.httpclientandroidlib.HttpStatus;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
+ * or {@link JSONArray}.
+ * <p>
+ * This class is designed to be passed to get, post, put and delete requests
+ * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
+ * methods anonymously overridden.
+ * <p>
+ * Additionally, you can override the other event methods from the
+ * parent class.
+ */
+public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
+    protected static final int SUCCESS_JSON_MESSAGE = 100;
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param response the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(JSONObject response) {}
+
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param response the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(JSONArray response) {}
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param statusCode the status code of the response
+     * @param response the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONObject response) {
+        onSuccess(response);
+    }
+
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param statusCode the status code of the response
+     * @param response the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONArray response) {
+        onSuccess(response);
+    }
+
+    public void onFailure(Throwable e, JSONObject errorResponse) {}
+    public void onFailure(Throwable e, JSONArray errorResponse) {}
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    @Override
+    protected void sendSuccessMessage(int statusCode, String responseBody) {
+    	if (statusCode != HttpStatus.SC_NO_CONTENT){
+	        try {
+	            Object jsonResponse = parseResponse(responseBody);
+	            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, jsonResponse}));
+	        } catch(JSONException e) {
+	            sendFailureMessage(e, responseBody);
+	        }
+    	}else{
+    		sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
+    	}
+    }
+
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    @Override
+    protected void handleMessage(Message msg) {
+        switch(msg.what){
+            case SUCCESS_JSON_MESSAGE:
+                Object[] response = (Object[]) msg.obj;
+                handleSuccessJsonMessage(((Integer) response[0]).intValue(), response[1]);
+                break;
+            default:
+                super.handleMessage(msg);
+        }
+    }
+
+    protected void handleSuccessJsonMessage(int statusCode, Object jsonResponse) {
+        if(jsonResponse instanceof JSONObject) {
+            onSuccess(statusCode, (JSONObject)jsonResponse);
+        } else if(jsonResponse instanceof JSONArray) {
+            onSuccess(statusCode, (JSONArray)jsonResponse);
+        } else {
+            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
+        }
+    }
+
+    protected Object parseResponse(String responseBody) throws JSONException {
+        Object result = null;
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+		responseBody = responseBody.trim();
+		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
+			result = new JSONTokener(responseBody).nextValue();
+		}
+		if (result == null) {
+			result = responseBody;
+		}
+		return result;
+    }
+
+    @Override
+    protected void handleFailureMessage(Throwable e, String responseBody) {
+        try {
+            if (responseBody != null) {
+                Object jsonResponse = parseResponse(responseBody);
+                if(jsonResponse instanceof JSONObject) {
+                    onFailure(e, (JSONObject)jsonResponse);
+                } else if(jsonResponse instanceof JSONArray) {
+                    onFailure(e, (JSONArray)jsonResponse);
+                } else {
+                    onFailure(e, responseBody);
+                }
+            }else {
+                onFailure(e, "");
+            }
+        }catch(JSONException ex) {
+            onFailure(e, responseBody);
+        }
+    }
+}
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/src/com/loopj/android/http/PersistentCookieStore.java
index 3f98a00b..9c335ec9 100644
--- a/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/src/com/loopj/android/http/PersistentCookieStore.java
@@ -1,200 +1,199 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.http.client.CookieStore;
-import org.apache.http.cookie.Cookie;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.text.TextUtils;
-
-/**
- * A persistent cookie store which implements the Apache HttpClient
- * {@link CookieStore} interface. Cookies are stored and will persist on the
- * user's device between application sessions since they are serialized and
- * stored in {@link SharedPreferences}.
- * <p>
- * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
- * regular old apache HttpClient/HttpContext if you prefer.
- */
-public class PersistentCookieStore implements CookieStore {
-    private static final String COOKIE_PREFS = "CookiePrefsFile";
-    private static final String COOKIE_NAME_STORE = "names";
-    private static final String COOKIE_NAME_PREFIX = "cookie_";
-
-    private final ConcurrentHashMap<String, Cookie> cookies;
-    private final SharedPreferences cookiePrefs;
-
-    /**
-     * Construct a persistent cookie store.
-     */
-    public PersistentCookieStore(Context context) {
-        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
-
-        // Load any previously stored cookies into the store
-        String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if(storedCookieNames != null) {
-            String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for(String name : cookieNames) {
-                String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if(encodedCookie != null) {
-                    Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if(decodedCookie != null) {
-                        cookies.put(name, decodedCookie);
-                    }
-                }
-            }
-
-            // Clear out expired cookies
-            clearExpired(new Date());
-        }
-    }
-
-    @Override
-    public void addCookie(Cookie cookie) {
-        String name = cookie.getName() + cookie.getDomain();
-
-        // Save cookie into local store, or remove if expired
-        if(!cookie.isExpired(new Date())) {
-            cookies.put(name, cookie);
-        } else {
-            cookies.remove(name);
-        }
-
-        // Save cookie into persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));
-        prefsWriter.commit();
-    }
-
-    @Override
-    public void clear() {
-        // Clear cookies from local store
-        cookies.clear();
-
-        // Clear cookies from persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for(String name : cookies.keySet()) {
-            prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-        }
-        prefsWriter.remove(COOKIE_NAME_STORE);
-        prefsWriter.commit();
-    }
-
-    @Override
-    public boolean clearExpired(Date date) {
-        boolean clearedAny = false;
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-
-        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
-            String name = entry.getKey();
-            Cookie cookie = entry.getValue();
-            if(cookie.isExpired(date)) {
-                // Clear cookies from local store
-                cookies.remove(name);
-
-                // Clear cookies from persistent store
-                prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-
-                // We've cleared at least one
-                clearedAny = true;
-            }
-        }
-
-        // Update names in persistent store
-        if(clearedAny) {
-            prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        }
-        prefsWriter.commit();
-
-        return clearedAny;
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
-    }
-
-
-    //
-    // Cookie serialization/deserialization
-    //
-
-    protected String encodeCookie(SerializableCookie cookie) {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        try {
-            ObjectOutputStream outputStream = new ObjectOutputStream(os);
-            outputStream.writeObject(cookie);
-        } catch (Exception e) {
-            return null;
-        }
-
-        return byteArrayToHexString(os.toByteArray());
-    }
-
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
-        Cookie cookie = null;
-        try {
-           ObjectInputStream ois = new ObjectInputStream(is);
-           cookie = ((SerializableCookie)ois.readObject()).getCookie();
-        } catch (Exception e) {
-           e.printStackTrace();
-        }
-
-        return cookie;
-    }
-
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuffer sb = new StringBuffer(b.length * 2);
-        for (byte element : b) {
-            int v = element & 0xff;
-            if(v < 16) {
-                sb.append('0');
-            }
-            sb.append(Integer.toHexString(v));
-        }
-        return sb.toString().toUpperCase();
-    }
-
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
-        byte[] data = new byte[len / 2];
-        for(int i=0; i<len; i+=2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
-        }
-        return data;
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.text.TextUtils;
+import ch.boye.httpclientandroidlib.client.CookieStore;
+import ch.boye.httpclientandroidlib.cookie.Cookie;
+
+/**
+ * A persistent cookie store which implements the Apache HttpClient
+ * {@link CookieStore} interface. Cookies are stored and will persist on the
+ * user's device between application sessions since they are serialized and
+ * stored in {@link SharedPreferences}.
+ * <p>
+ * Instances of this class are designed to be used with
+ * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
+ * regular old apache HttpClient/HttpContext if you prefer.
+ */
+public class PersistentCookieStore implements CookieStore {
+    private static final String COOKIE_PREFS = "CookiePrefsFile";
+    private static final String COOKIE_NAME_STORE = "names";
+    private static final String COOKIE_NAME_PREFIX = "cookie_";
+
+    private final ConcurrentHashMap<String, Cookie> cookies;
+    private final SharedPreferences cookiePrefs;
+
+    /**
+     * Construct a persistent cookie store.
+     */
+    public PersistentCookieStore(Context context) {
+        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
+        cookies = new ConcurrentHashMap<String, Cookie>();
+
+        // Load any previously stored cookies into the store
+        String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
+        if(storedCookieNames != null) {
+            String[] cookieNames = TextUtils.split(storedCookieNames, ",");
+            for(String name : cookieNames) {
+                String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
+                if(encodedCookie != null) {
+                    Cookie decodedCookie = decodeCookie(encodedCookie);
+                    if(decodedCookie != null) {
+                        cookies.put(name, decodedCookie);
+                    }
+                }
+            }
+
+            // Clear out expired cookies
+            clearExpired(new Date());
+        }
+    }
+
+    @Override
+    public void addCookie(Cookie cookie) {
+        String name = cookie.getName() + cookie.getDomain();
+
+        // Save cookie into local store, or remove if expired
+        if(!cookie.isExpired(new Date())) {
+            cookies.put(name, cookie);
+        } else {
+            cookies.remove(name);
+        }
+
+        // Save cookie into persistent store
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));
+        prefsWriter.commit();
+    }
+
+    @Override
+    public void clear() {
+        // Clear cookies from local store
+        cookies.clear();
+
+        // Clear cookies from persistent store
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        for(String name : cookies.keySet()) {
+            prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        }
+        prefsWriter.remove(COOKIE_NAME_STORE);
+        prefsWriter.commit();
+    }
+
+    @Override
+    public boolean clearExpired(Date date) {
+        boolean clearedAny = false;
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+
+        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+            String name = entry.getKey();
+            Cookie cookie = entry.getValue();
+            if(cookie.isExpired(date)) {
+                // Clear cookies from local store
+                cookies.remove(name);
+
+                // Clear cookies from persistent store
+                prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+
+                // We've cleared at least one
+                clearedAny = true;
+            }
+        }
+
+        // Update names in persistent store
+        if(clearedAny) {
+            prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+        }
+        prefsWriter.commit();
+
+        return clearedAny;
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+        return new ArrayList<Cookie>(cookies.values());
+    }
+
+
+    //
+    // Cookie serialization/deserialization
+    //
+
+    protected String encodeCookie(SerializableCookie cookie) {
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        try {
+            ObjectOutputStream outputStream = new ObjectOutputStream(os);
+            outputStream.writeObject(cookie);
+        } catch (Exception e) {
+            return null;
+        }
+
+        return byteArrayToHexString(os.toByteArray());
+    }
+
+    protected Cookie decodeCookie(String cookieStr) {
+        byte[] bytes = hexStringToByteArray(cookieStr);
+        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+        Cookie cookie = null;
+        try {
+           ObjectInputStream ois = new ObjectInputStream(is);
+           cookie = ((SerializableCookie)ois.readObject()).getCookie();
+        } catch (Exception e) {
+           e.printStackTrace();
+        }
+
+        return cookie;
+    }
+
+    // Using some super basic byte array <-> hex conversions so we don't have
+    // to rely on any large Base64 libraries. Can be overridden if you like!
+    protected String byteArrayToHexString(byte[] b) {
+        StringBuffer sb = new StringBuffer(b.length * 2);
+        for (byte element : b) {
+            int v = element & 0xff;
+            if(v < 16) {
+                sb.append('0');
+            }
+            sb.append(Integer.toHexString(v));
+        }
+        return sb.toString().toUpperCase();
+    }
+
+    protected byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for(int i=0; i<len; i+=2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
+        }
+        return data;
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index cf5d1dc4..893640d6 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -1,321 +1,321 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.InputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-
-/**
- * A collection of string request parameters or files to send along with
- * requests made from an {@link AsyncHttpClient} instance.
- * <p>
- * For example:
- * <p>
- * <pre>
- * RequestParams params = new RequestParams();
- * params.put("username", "james");
- * params.put("password", "123456");
- * params.put("email", "my&#064;email.com");
- * params.put("profile_picture", new File("pic.jpg")); // Upload a File
- * params.put("profile_picture2", someInputStream); // Upload an InputStream
- * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- *
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.post("http://myendpoint.com", params, responseHandler);
- * </pre>
- */
-public class RequestParams {
-    private static String ENCODING = "UTF-8";
-
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
-
-    /**
-     * Constructs a new empty <code>RequestParams</code> instance.
-     */
-    public RequestParams() {
-        init();
-    }
-
-    /**
-     * Constructs a new RequestParams instance containing the key/value
-     * string params from the specified map.
-     * @param source the source key/value string map to add.
-     */
-    public RequestParams(Map<String, String> source) {
-        init();
-
-        for(Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with a single
-     * initial key/value string param.
-     * @param key the key name for the intial param.
-     * @param value the value string for the initial param.
-     */
-    public RequestParams(String key, String value) {
-        init();
-
-        put(key, value);
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with multiple
-     * initial key/value string param.
-     * @param keysAndValues a sequence of keys and values. Objects are
-     * automatically converted to Strings (including the value {@code null}).
-     * @throws IllegalArgumentException if the number of arguments isn't even.
-     */
-    public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
-    }
-
-    /**
-     * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
-     * @param value the value string for the new param.
-     */
-    public void put(String key, String value){
-        if(key != null && value != null) {
-            urlParams.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a file to the request.
-     * @param key the key name for the new param.
-     * @param file the file to add.
-     */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
-    }
-
-    /**
-     * Adds param with more than one value.
-     * @param key the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values)  {
-        if(key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     */
-    public void put(String key, InputStream stream) {
-        put(key, stream, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     * @param contentType the content type of the file, eg. application/json
-     */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
-        }
-    }
-
-    /**
-     * Removes a parameter from the request.
-     * @param key the key name for the parameter to remove.
-     */
-    public void remove(String key){
-        urlParams.remove(key);
-        fileParams.remove(key);
-        urlParamsWithArray.remove(key);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append(entry.getValue());
-        }
-
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("FILE");
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                if (values.indexOf(value) != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(value);
-            }
-        }
-
-        return result.toString();
-    }
-
-   /**
-     * Returns an HttpEntity containing all request parameters
-     */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
-
-        if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
-
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
-
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
-
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
-            }
-
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            }
-        }
-
-        return entity;
-    }
-
-    private void init(){
-        urlParams = new ConcurrentHashMap<String, String>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
-    }
-
-    protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
-
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
-        }
-
-        return lparams;
-    }
-
-    protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
-    }
-
-    private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
-        public String contentType;
-
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
-            this.contentType = contentType;
-        }
-
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
-        }
-    }
-}
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import ch.boye.httpclientandroidlib.HttpEntity;
+import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
+import ch.boye.httpclientandroidlib.client.utils.URLEncodedUtils;
+import ch.boye.httpclientandroidlib.message.BasicNameValuePair;
+
+/**
+ * A collection of string request parameters or files to send along with
+ * requests made from an {@link AsyncHttpClient} instance.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * RequestParams params = new RequestParams();
+ * params.put("username", "james");
+ * params.put("password", "123456");
+ * params.put("email", "my&#064;email.com");
+ * params.put("profile_picture", new File("pic.jpg")); // Upload a File
+ * params.put("profile_picture2", someInputStream); // Upload an InputStream
+ * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
+ *
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.post("http://myendpoint.com", params, responseHandler);
+ * </pre>
+ */
+public class RequestParams {
+    private static String ENCODING = "UTF-8";
+
+    protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, FileWrapper> fileParams;
+    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
+
+    /**
+     * Constructs a new empty <code>RequestParams</code> instance.
+     */
+    public RequestParams() {
+        init();
+    }
+
+    /**
+     * Constructs a new RequestParams instance containing the key/value
+     * string params from the specified map.
+     * @param source the source key/value string map to add.
+     */
+    public RequestParams(Map<String, String> source) {
+        init();
+
+        for(Map.Entry<String, String> entry : source.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with a single
+     * initial key/value string param.
+     * @param key the key name for the intial param.
+     * @param value the value string for the initial param.
+     */
+    public RequestParams(String key, String value) {
+        init();
+
+        put(key, value);
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with multiple
+     * initial key/value string param.
+     * @param keysAndValues a sequence of keys and values. Objects are
+     * automatically converted to Strings (including the value {@code null}).
+     * @throws IllegalArgumentException if the number of arguments isn't even.
+     */
+    public RequestParams(Object... keysAndValues) {
+      init();
+      int len = keysAndValues.length;
+      if (len % 2 != 0)
+        throw new IllegalArgumentException("Supplied arguments must be even");
+      for (int i = 0; i < len; i += 2) {
+        String key = String.valueOf(keysAndValues[i]);
+        String val = String.valueOf(keysAndValues[i + 1]);
+        put(key, val);
+      }
+    }
+
+    /**
+     * Adds a key/value string pair to the request.
+     * @param key the key name for the new param.
+     * @param value the value string for the new param.
+     */
+    public void put(String key, String value){
+        if(key != null && value != null) {
+            urlParams.put(key, value);
+        }
+    }
+
+    /**
+     * Adds a file to the request.
+     * @param key the key name for the new param.
+     * @param file the file to add.
+     */
+    public void put(String key, File file) throws FileNotFoundException {
+        put(key, new FileInputStream(file), file.getName());
+    }
+
+    /**
+     * Adds param with more than one value.
+     * @param key the key name for the new param.
+     * @param values is the ArrayList with values for the param.
+     */
+    public void put(String key, ArrayList<String> values)  {
+        if(key != null && values != null) {
+            urlParamsWithArray.put(key, values);
+        }
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     */
+    public void put(String key, InputStream stream) {
+        put(key, stream, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     * @param fileName the name of the file.
+     */
+    public void put(String key, InputStream stream, String fileName) {
+        put(key, stream, fileName, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     * @param fileName the name of the file.
+     * @param contentType the content type of the file, eg. application/json
+     */
+    public void put(String key, InputStream stream, String fileName, String contentType) {
+        if(key != null && stream != null) {
+            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+        }
+    }
+
+    /**
+     * Removes a parameter from the request.
+     * @param key the key name for the parameter to remove.
+     */
+    public void remove(String key){
+        urlParams.remove(key);
+        fileParams.remove(key);
+        urlParamsWithArray.remove(key);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append(entry.getValue());
+        }
+
+        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("FILE");
+        }
+
+        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                if (values.indexOf(value) != 0)
+                    result.append("&");
+                result.append(entry.getKey());
+                result.append("=");
+                result.append(value);
+            }
+        }
+
+        return result.toString();
+    }
+
+   /**
+     * Returns an HttpEntity containing all request parameters
+     */
+    public HttpEntity getEntity() {
+        HttpEntity entity = null;
+
+        if(!fileParams.isEmpty()) {
+            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+
+            // Add string params
+            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+                multipartEntity.addPart(entry.getKey(), entry.getValue());
+            }
+
+            // Add dupe params
+            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+                ArrayList<String> values = entry.getValue();
+                for (String value : values) {
+                    multipartEntity.addPart(entry.getKey(), value);
+                }
+            }
+
+            // Add file params
+            int currentIndex = 0;
+            int lastIndex = fileParams.entrySet().size() - 1;
+            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+                FileWrapper file = entry.getValue();
+                if(file.inputStream != null) {
+                    boolean isLast = currentIndex == lastIndex;
+                    if(file.contentType != null) {
+                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
+                    } else {
+                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
+                    }
+                }
+                currentIndex++;
+            }
+
+            entity = multipartEntity;
+        } else {
+            try {
+                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
+            } catch (UnsupportedEncodingException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return entity;
+    }
+
+    private void init(){
+        urlParams = new ConcurrentHashMap<String, String>();
+        fileParams = new ConcurrentHashMap<String, FileWrapper>();
+        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
+    }
+
+    protected List<BasicNameValuePair> getParamsList() {
+        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+
+        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
+        }
+
+        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                lparams.add(new BasicNameValuePair(entry.getKey(), value));
+            }
+        }
+
+        return lparams;
+    }
+
+    protected String getParamString() {
+        return URLEncodedUtils.format(getParamsList(), ENCODING);
+    }
+
+    private static class FileWrapper {
+        public InputStream inputStream;
+        public String fileName;
+        public String contentType;
+
+        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
+            this.inputStream = inputStream;
+            this.fileName = fileName;
+            this.contentType = contentType;
+        }
+
+        public String getFileName() {
+            if(fileName != null) {
+                return fileName;
+            } else {
+                return "nofilename";
+            }
+        }
+    }
+}
diff --git a/src/com/loopj/android/http/RetryHandler.java b/src/com/loopj/android/http/RetryHandler.java
index 715456fb..d0951075 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/src/com/loopj/android/http/RetryHandler.java
@@ -1,113 +1,112 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-/*
-    Some of the retry logic in this class is heavily borrowed from the
-    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
-*/
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.util.HashSet;
-import java.util.Iterator;
-
-import javax.net.ssl.SSLException;
-
-import org.apache.http.NoHttpResponseException;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-
-import android.os.SystemClock;
-
-class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
-
-    static {
-        // Retry if the server dropped connection on us
-        exceptionWhitelist.add(NoHttpResponseException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(UnknownHostException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(SocketException.class);
-
-        // never retry timeouts
-        exceptionBlacklist.add(InterruptedIOException.class);
-        // never retry SSL handshake failures
-        exceptionBlacklist.add(SSLException.class);
-    }
-
-    private final int maxRetries;
-
-    public RetryHandler(int maxRetries) {
-        this.maxRetries = maxRetries;
-    }
-
-    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-        boolean retry = true;
-
-        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
-
-        if(executionCount > maxRetries) {
-            // Do not retry if over max retry count
-            retry = false;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
-        } else if (isInList(exceptionWhitelist, exception)) {
-            // immediately retry if error is whitelisted
-            retry = true;
-        } else if (!sent) {
-            // for most other errors, retry only if request hasn't been fully sent yet
-            retry = true;
-        }
-
-        if(retry) {
-            // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
-        }
-
-        if(retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
-        } else {
-            exception.printStackTrace();
-        }
-
-        return retry;
-    }
-    
-    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-    	Iterator<Class<?>> itr = list.iterator();
-    	while (itr.hasNext()) {
-    		if (itr.next().isInstance(error)) {
-    			return true;
-    		}
-    	}
-    	return false;
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+/*
+    Some of the retry logic in this class is heavily borrowed from the
+    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.HashSet;
+import java.util.Iterator;
+
+import javax.net.ssl.SSLException;
+
+import android.os.SystemClock;
+import ch.boye.httpclientandroidlib.NoHttpResponseException;
+import ch.boye.httpclientandroidlib.client.HttpRequestRetryHandler;
+import ch.boye.httpclientandroidlib.client.methods.HttpUriRequest;
+import ch.boye.httpclientandroidlib.protocol.ExecutionContext;
+import ch.boye.httpclientandroidlib.protocol.HttpContext;
+
+class RetryHandler implements HttpRequestRetryHandler {
+    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
+    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+
+    static {
+        // Retry if the server dropped connection on us
+        exceptionWhitelist.add(NoHttpResponseException.class);
+        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
+        exceptionWhitelist.add(UnknownHostException.class);
+        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
+        exceptionWhitelist.add(SocketException.class);
+
+        // never retry timeouts
+        exceptionBlacklist.add(InterruptedIOException.class);
+        // never retry SSL handshake failures
+        exceptionBlacklist.add(SSLException.class);
+    }
+
+    private final int maxRetries;
+
+    public RetryHandler(int maxRetries) {
+        this.maxRetries = maxRetries;
+    }
+
+    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
+        boolean retry = true;
+
+        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
+        boolean sent = (b != null && b.booleanValue());
+
+        if(executionCount > maxRetries) {
+            // Do not retry if over max retry count
+            retry = false;
+        } else if (isInList(exceptionBlacklist, exception)) {
+            // immediately cancel retry if the error is blacklisted
+            retry = false;
+        } else if (isInList(exceptionWhitelist, exception)) {
+            // immediately retry if error is whitelisted
+            retry = true;
+        } else if (!sent) {
+            // for most other errors, retry only if request hasn't been fully sent yet
+            retry = true;
+        }
+
+        if(retry) {
+            // resend all idempotent requests
+            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
+            String requestType = currentReq.getMethod();
+            retry = !requestType.equals("POST");
+        }
+
+        if(retry) {
+            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+        } else {
+            exception.printStackTrace();
+        }
+
+        return retry;
+    }
+    
+    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
+    	Iterator<Class<?>> itr = list.iterator();
+    	while (itr.hasNext()) {
+    		if (itr.next().isInstance(error)) {
+    			return true;
+    		}
+    	}
+    	return false;
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/src/com/loopj/android/http/SerializableCookie.java
index cc12993c..4ee16a13 100644
--- a/src/com/loopj/android/http/SerializableCookie.java
+++ b/src/com/loopj/android/http/SerializableCookie.java
@@ -1,74 +1,75 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.io.Serializable;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.IOException;
-import java.util.Date;
-
-import org.apache.http.cookie.Cookie;
-import org.apache.http.impl.cookie.BasicClientCookie;
-
-/**
- * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
- * designed for use in {@link PersistentCookieStore}.
- */
-public class SerializableCookie implements Serializable {
-    private static final long serialVersionUID = 6374381828722046732L;
-
-    private transient final Cookie cookie;
-    private transient BasicClientCookie clientCookie;
-
-    public SerializableCookie(Cookie cookie) {
-        this.cookie = cookie;
-    }
-
-    public Cookie getCookie() {
-        Cookie bestCookie = cookie;
-        if(clientCookie != null) {
-            bestCookie = clientCookie;
-        }
-        return bestCookie;
-    }
-
-    private void writeObject(ObjectOutputStream out) throws IOException {
-        out.writeObject(cookie.getName());
-        out.writeObject(cookie.getValue());
-        out.writeObject(cookie.getComment());
-        out.writeObject(cookie.getDomain());
-        out.writeObject(cookie.getExpiryDate());
-        out.writeObject(cookie.getPath());
-        out.writeInt(cookie.getVersion());
-        out.writeBoolean(cookie.isSecure());
-    }
-
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String)in.readObject();
-        String value = (String)in.readObject();
-        clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String)in.readObject());
-        clientCookie.setDomain((String)in.readObject());
-        clientCookie.setExpiryDate((Date)in.readObject());
-        clientCookie.setPath((String)in.readObject());
-        clientCookie.setVersion(in.readInt());
-        clientCookie.setSecure(in.readBoolean());
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.Date;
+
+import ch.boye.httpclientandroidlib.cookie.Cookie;
+import ch.boye.httpclientandroidlib.impl.cookie.BasicClientCookie;
+
+
+/**
+ * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
+ * designed for use in {@link PersistentCookieStore}.
+ */
+public class SerializableCookie implements Serializable {
+    private static final long serialVersionUID = 6374381828722046732L;
+
+    private transient final Cookie cookie;
+    private transient BasicClientCookie clientCookie;
+
+    public SerializableCookie(Cookie cookie) {
+        this.cookie = cookie;
+    }
+
+    public Cookie getCookie() {
+        Cookie bestCookie = cookie;
+        if(clientCookie != null) {
+            bestCookie = clientCookie;
+        }
+        return bestCookie;
+    }
+
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        out.writeObject(cookie.getName());
+        out.writeObject(cookie.getValue());
+        out.writeObject(cookie.getComment());
+        out.writeObject(cookie.getDomain());
+        out.writeObject(cookie.getExpiryDate());
+        out.writeObject(cookie.getPath());
+        out.writeInt(cookie.getVersion());
+        out.writeBoolean(cookie.isSecure());
+    }
+
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        String name = (String)in.readObject();
+        String value = (String)in.readObject();
+        clientCookie = new BasicClientCookie(name, value);
+        clientCookie.setComment((String)in.readObject());
+        clientCookie.setDomain((String)in.readObject());
+        clientCookie.setExpiryDate((Date)in.readObject());
+        clientCookie.setPath((String)in.readObject());
+        clientCookie.setVersion(in.readInt());
+        clientCookie.setSecure(in.readBoolean());
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index bff0efcc..00593815 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -1,185 +1,186 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-/*
-    This code is taken from Rafael Sanches' blog.
-    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
-*/
-
-package com.loopj.android.http;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Random;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-
-class SimpleMultipartEntity implements HttpEntity {
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
-
-    private String boundary = null;
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
-
-    public SimpleMultipartEntity() {
-        final StringBuffer buf = new StringBuffer();
-        final Random rand = new Random();
-        for (int i = 0; i < 30; i++) {
-            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
-        }
-        this.boundary = buf.toString();
-
-    }
-
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
-            try {
-                out.write(("--" + boundary + "\r\n").getBytes());
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        isSetFirst = true;
-    }
-
-    public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
-            return;
-        }
-
-        try {
-            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-
-        isSetLast = true;
-    }
-
-    public void addPart(final String key, final String value) {
-        writeFirstBoundaryIfNeeds();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeFirstBoundaryIfNeeds();
-        try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
-
-            final byte[] tmp = new byte[4096];
-            int l = 0;
-            while ((l = fin.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-            }
-            if(!isLast)
-                out.write(("\r\n--" + boundary + "\r\n").getBytes());
-            out.flush();
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                fin.close();
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
-    }
-
-    @Override
-    public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
-    }
-
-    @Override
-    public boolean isChunked() {
-        return false;
-    }
-
-    @Override
-    public boolean isRepeatable() {
-        return false;
-    }
-
-    @Override
-    public boolean isStreaming() {
-        return false;
-    }
-
-    @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        outstream.write(out.toByteArray());
-    }
-
-    @Override
-    public Header getContentEncoding() {
-        return null;
-    }
-
-    @Override
-    public void consumeContent() throws IOException,
-    UnsupportedOperationException {
-        if (isStreaming()) {
-            throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
-        }
-    }
-
-    @Override
-    public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-        return new ByteArrayInputStream(out.toByteArray());
-    }
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+/*
+    This code is taken from Rafael Sanches' blog.
+    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
+*/
+
+package com.loopj.android.http;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Random;
+
+import ch.boye.httpclientandroidlib.Header;
+import ch.boye.httpclientandroidlib.HttpEntity;
+import ch.boye.httpclientandroidlib.message.BasicHeader;
+
+
+class SimpleMultipartEntity implements HttpEntity {
+    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+
+    private String boundary = null;
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    boolean isSetLast = false;
+    boolean isSetFirst = false;
+
+    public SimpleMultipartEntity() {
+        final StringBuffer buf = new StringBuffer();
+        final Random rand = new Random();
+        for (int i = 0; i < 30; i++) {
+            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
+        }
+        this.boundary = buf.toString();
+
+    }
+
+    public void writeFirstBoundaryIfNeeds(){
+        if(!isSetFirst){
+            try {
+                out.write(("--" + boundary + "\r\n").getBytes());
+            } catch (final IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        isSetFirst = true;
+    }
+
+    public void writeLastBoundaryIfNeeds() {
+        if(isSetLast){
+            return;
+        }
+
+        try {
+            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+
+        isSetLast = true;
+    }
+
+    public void addPart(final String key, final String value) {
+        writeFirstBoundaryIfNeeds();
+        try {
+            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
+            out.write(value.getBytes());
+            out.write(("\r\n--" + boundary + "\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
+        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    }
+
+    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
+        writeFirstBoundaryIfNeeds();
+        try {
+            type = "Content-Type: "+type+"\r\n";
+            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
+            out.write(type.getBytes());
+            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+
+            final byte[] tmp = new byte[4096];
+            int l = 0;
+            while ((l = fin.read(tmp)) != -1) {
+                out.write(tmp, 0, l);
+            }
+            if(!isLast)
+                out.write(("\r\n--" + boundary + "\r\n").getBytes());
+            out.flush();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                fin.close();
+            } catch (final IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void addPart(final String key, final File value, final boolean isLast) {
+        try {
+            addPart(key, value.getName(), new FileInputStream(value), isLast);
+        } catch (final FileNotFoundException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public long getContentLength() {
+        writeLastBoundaryIfNeeds();
+        return out.toByteArray().length;
+    }
+
+    @Override
+    public Header getContentType() {
+        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        outstream.write(out.toByteArray());
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    @Override
+    public void consumeContent() throws IOException,
+    UnsupportedOperationException {
+        if (isStreaming()) {
+            throw new UnsupportedOperationException(
+            "Streaming entity does not implement #consumeContent()");
+        }
+    }
+
+    @Override
+    public InputStream getContent() throws IOException,
+    UnsupportedOperationException {
+        return new ByteArrayInputStream(out.toByteArray());
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SyncHttpClient.java b/src/com/loopj/android/http/SyncHttpClient.java
index 84aeb6e5..d0521e58 100644
--- a/src/com/loopj/android/http/SyncHttpClient.java
+++ b/src/com/loopj/android/http/SyncHttpClient.java
@@ -1,11 +1,11 @@
 package com.loopj.android.http;
 
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.protocol.HttpContext;
-
 import android.content.Context;
 import android.os.Message;
+import ch.boye.httpclientandroidlib.HttpResponse;
+import ch.boye.httpclientandroidlib.client.methods.HttpUriRequest;
+import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
+import ch.boye.httpclientandroidlib.protocol.HttpContext;
 
 public abstract class SyncHttpClient extends AsyncHttpClient {
 	private int responseCode;
@@ -17,7 +17,7 @@
 	protected String result;
 	protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
 
-		void sendResponseMessage(org.apache.http.HttpResponse response) {
+		void sendResponseMessage(HttpResponse response) {
 			responseCode = response.getStatusLine().getStatusCode();
 			super.sendResponseMessage(response);
 		};
