diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 7e49df73..a122f742 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -113,14 +113,20 @@
  */
 public class AsyncHttpClient {
 
+    public static final String LOG_TAG = "AsyncHttpClient";
+
+    public static final String HEADER_CONTENT_TYPE = "Content-Type";
+    public static final String HEADER_CONTENT_RANGE = "Content-Range";
+    public static final String HEADER_CONTENT_ENCODING = "Content-Encoding";
+    public static final String HEADER_CONTENT_DISPOSITION = "Content-Disposition";
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+
     public static final int DEFAULT_MAX_CONNECTIONS = 10;
     public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     public static final int DEFAULT_MAX_RETRIES = 5;
     public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
     public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    public static final String ENCODING_GZIP = "gzip";
-    public static final String LOG_TAG = "AsyncHttpClient";
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
     private int timeout = DEFAULT_SOCKET_TIMEOUT;
@@ -340,7 +346,7 @@ public void setCookieStore(CookieStore cookieStore) {
 
     /**
      * Overrides the threadpool implementation used when queuing/pooling requests. By default,
-     * Executors.newFixedThreadPool() is used.
+     * Executors.newCachedThreadPool() is used.
      *
      * @param threadPool an instance of {@link ExecutorService} to use for queuing/pooling
      *                   requests.
@@ -350,7 +356,7 @@ public void setThreadPool(ExecutorService threadPool) {
     }
 
     /**
-     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * Returns the current executor service used. By default, Executors.newCachedThreadPool() is
      * used.
      *
      * @return current executor service used
@@ -1090,7 +1096,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
         }
 
         if (contentType != null) {
-            uriRequest.setHeader("Content-Type", contentType);
+            uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);
         }
 
         responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 256ab9c9..fde3cf87 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -148,7 +148,7 @@ public void setUseSynchronousMode(boolean value) {
             Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
         }
 
-        // If using synchronous mode.
+        // If using asynchronous mode.
         if (!value && handler == null) {
             // Create a handler on current thread to submit tasks
             handler = new ResponderHandler(this);
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index f4355caa..eaa30ec5 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -53,11 +53,11 @@
 
     private static final String LOG_TAG = "BinaryHttpResponseHandler";
 
-    private String[] mAllowedContentTypes = new String[]{
-            "image/jpeg",
-            "image/png",
-            "image/gif",
-            "application/octet-stream"
+    private String[] mAllowedContentTypes = new String[] {
+        RequestParams.APPLICATION_OCTET_STREAM,
+        "image/jpeg",
+        "image/png",
+        "image/gif"
     };
 
     /**
@@ -100,10 +100,18 @@ public BinaryHttpResponseHandler(String[] allowedContentTypes) {
     @Override
     public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        Header[] contentTypeHeaders = response.getHeaders(AsyncHttpClient.HEADER_CONTENT_TYPE);
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
+            sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
+                    status.getStatusCode(),
+                    "None, or more than one, Content-Type Header found!"
+                )
+            );
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -119,7 +127,15 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
+            sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
+                    status.getStatusCode(),
+                    "Content-Type not allowed!"
+                )
+            );
             return;
         }
         super.sendResponseMessage(response);
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index ab10821d..79262eff 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -39,14 +39,14 @@
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
     /**
-     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
+     * Creates new JsonHttpResponseHandler, with JSON String encoding UTF-8
      */
     public JsonHttpResponseHandler() {
         super(DEFAULT_CHARSET);
     }
 
     /**
-     * Creates new JsonHttpRespnseHandler with given Json String encoding
+     * Creates new JsonHttpRespnseHandler with given JSON String encoding
      *
      * @param encoding String encoding to be used when parsing JSON
      */
@@ -208,7 +208,7 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If JSON is not valid this will return null
         String jsonString = getResponseString(responseBody, getCharset());
         if (jsonString != null) {
             jsonString = jsonString.trim();
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index f033d4c0..5e490cdd 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -65,9 +65,14 @@
     private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
-            new BasicHeader("Content-Type", "application/json");
+            new BasicHeader(
+                AsyncHttpClient.HEADER_CONTENT_TYPE,
+                RequestParams.APPLICATION_JSON);
+
     private static final Header HEADER_GZIP_ENCODING =
-            new BasicHeader("Content-Encoding", "gzip");
+            new BasicHeader(
+                AsyncHttpClient.HEADER_CONTENT_ENCODING,
+                AsyncHttpClient.ENCODING_GZIP);
 
     // JSON data and associated meta-data to be uploaded.
     private final Map<String, Object> jsonParams = new HashMap<String, Object>();
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
index f5e21fc8..3d09aa38 100755
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -62,12 +62,12 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                     sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
             } else {
                 if (!Thread.currentThread().isInterrupted()) {
-                    Header header = response.getFirstHeader("Content-Range");
+                    Header header = response.getFirstHeader(AsyncHttpClient.HEADER_CONTENT_RANGE);
                     if (header == null) {
                         append = false;
                         current = 0;
                     } else
-                        Log.v(LOG_TAG, "Content-Range: " + header.getValue());
+                        Log.v(LOG_TAG, AsyncHttpClient.HEADER_CONTENT_RANGE + ": " + header.getValue());
                     sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
                 }
             }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index b115bdc3..a427f75c 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -92,6 +92,9 @@
     public final static String APPLICATION_OCTET_STREAM =
             "application/octet-stream";
 
+    public final static String APPLICATION_JSON =
+            "application/json";
+
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index baca2281..47c67794 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -146,18 +146,21 @@ private String normalizeContentType(String type) {
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
+        String result = AsyncHttpClient.HEADER_CONTENT_TYPE + ": " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
     private byte[] createContentDisposition(String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
-                .getBytes();
+        return (
+            AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+            ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
     }
 
     private byte[] createContentDisposition(String key, String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
-                .getBytes();
+        return (
+            AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+            ": form-data; name=\"" + key + "\"" +
+            "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
     }
 
     private void updateProgress(int count) {
@@ -232,7 +235,9 @@ public long getContentLength() {
 
     @Override
     public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+        return new BasicHeader(
+            AsyncHttpClient.HEADER_CONTENT_TYPE,
+            "multipart/form-data; boundary=" + boundary);
     }
 
     @Override
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index 89591461..9626a71c 100755
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -84,7 +84,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
                                         String contentType, ResponseHandlerInterface responseHandler,
                                         Context context) {
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            uriRequest.addHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, contentType);
         }
 
         responseHandler.setUseSynchronousMode(true);
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 0f14c9de..8ea2f2fd 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -33,6 +33,8 @@
         <activity android:name=".SaxSample"/>
         <activity android:name=".FilesSample"/>
         <activity android:name=".CustomCASample"/>
+        <activity android:name=".RetryRequestSample"/>
+        <activity android:name=".RangeResponseSample"/>
 
         <service android:name=".services.ExampleIntentService"/>
     </application>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
index 4ed75c4a..621c7f8c 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
@@ -20,14 +20,17 @@
 
 import android.app.AlertDialog;
 import android.content.DialogInterface;
+import android.content.res.Resources;
 import android.os.Bundle;
 import android.util.Log;
-import android.widget.Toast;
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
 import com.loopj.android.http.RequestHandle;
 import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
 import com.loopj.android.http.sample.util.SecureSocketFactory;
 
 import org.apache.http.Header;
@@ -53,9 +56,16 @@
 
     private static final String LOG_TAG = "CustomCASample";
 
-    private static final String SERVER_TEST_URL = "https://httpbin.org/get";
-    private static final String STORE_ALIAS = "TheAlias";
-    private static final String STORE_PASS = "ThePass";
+    // This is A TEST URL for use with AsyncHttpClient LIBRARY ONLY!
+    // It is provided courtesy of Fineswap (http://fineswap.com) and must never
+    // be used in ANY program except when running this sample (CustomCASample).
+    private static final String SERVER_TEST_URL = "https://api.fineswap.io/ahc";
+
+    // The certificate's alias.
+    private static final String STORE_ALIAS = "rootca";
+
+    // The certificate's password.
+    private static final String STORE_PASS = "Fineswap";
 
     // Instruct the library to retry connection when this exception is raised.
     static {
@@ -89,51 +99,10 @@ protected void onCreate(Bundle savedInstanceState) {
             }
         } catch (KeyStoreException e) {
             Log.e(LOG_TAG, "Unable to initialize key store", e);
-            Toast.makeText(
-                    this,
-                    "Please read res/raw/custom_ca.txt\nto learn how to create your own\nkey store containing a custom CA",
-                    Toast.LENGTH_LONG).show();
             showCustomCAHelp();
         }
     }
 
-    /**
-     * Returns contents of `custom_ca.txt` as CharSequence
-     *
-     * @return contents of custom_ca.txt from Assets
-     */
-    private CharSequence getReadmeText() {
-        String rtn = "";
-        try {
-            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
-            java.util.Scanner s = new java.util.Scanner(stream)
-                    .useDelimiter("\\A");
-            rtn = s.hasNext() ? s.next() : "";
-        } catch (Exception | Error e) {
-            Log.e(LOG_TAG, "License couldn't be retrieved", e);
-        }
-        return rtn;
-    }
-
-    /**
-     * Will display AlertDialog reading `custom_ca.txt` from Assets, to avoid strict Lint issue
-     */
-    private void showCustomCAHelp() {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle(R.string.title_custom_ca);
-        builder.setMessage(getReadmeText());
-        builder.setNeutralButton(android.R.string.cancel,
-                new DialogInterface.OnClickListener() {
-
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        dialog.dismiss();
-                    }
-                }
-        );
-        builder.show();
-    }
-
     @Override
     public int getSampleTitle() {
         return R.string.title_custom_ca;
@@ -141,7 +110,7 @@ public int getSampleTitle() {
 
     @Override
     public boolean isRequestBodyAllowed() {
-        return true;
+        return false;
     }
 
     @Override
@@ -156,33 +125,36 @@ public String getDefaultURL() {
 
     @Override
     public ResponseHandlerInterface getResponseHandler() {
-        return new BinaryHttpResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
             @Override
             public void onStart() {
                 clearOutputs();
             }
 
             @Override
-            public String[] getAllowedContentTypes() {
-                // Allowing all data for debug purposes
-                return new String[]{".*"};
-            }
-
-            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-                debugStatusCode(LOG_TAG, statusCode);
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
                 debugHeaders(LOG_TAG, headers);
-                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
+                debugThrowable(LOG_TAG, throwable);
                 if (errorResponse != null) {
-                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
+                    debugResponse(LOG_TAG, rawJsonData);
                 }
             }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
         };
     }
 
@@ -190,4 +162,41 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
     public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
         return client.get(this, URL, headers, null, responseHandler);
     }
+
+    /**
+     * Returns contents of `custom_ca.txt` file from assets as CharSequence.
+     *
+     * @return contents of custom_ca.txt file
+     */
+    private CharSequence getReadmeText() {
+        String rtn = "";
+        try {
+            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
+            java.util.Scanner s = new java.util.Scanner(stream)
+                    .useDelimiter("\\A");
+            rtn = s.hasNext() ? s.next() : "";
+        } catch (Resources.NotFoundException e) {
+            Log.e(LOG_TAG, "License couldn't be retrieved", e);
+        }
+        return rtn;
+    }
+
+    /**
+     * Displays a dialog showing contents of `custom_ca.txt` file from assets.
+     * This is needed to avoid Lint's strict mode.
+     */
+    private void showCustomCAHelp() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.title_custom_ca);
+        builder.setMessage(getReadmeText());
+        builder.setNeutralButton(android.R.string.cancel,
+            new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    dialog.dismiss();
+                }
+            }
+        );
+        builder.show();
+    }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
index 491c2b36..e56a1ed9 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
@@ -33,7 +33,7 @@ public boolean isRequestBodyAllowed() {
     public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
         try {
             RequestParams params = new RequestParams();
-            final String contentType = "application/octet-stream";
+            final String contentType = RequestParams.APPLICATION_OCTET_STREAM;
             params.put("fileOne", createTempFile("fileOne", 1020), contentType);
             params.put("fileTwo", createTempFile("fileTwo", 1030), contentType);
             params.put("fileThree", createTempFile("fileThree", 1040), contentType);
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
new file mode 100644
index 00000000..3daf055c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
@@ -0,0 +1,176 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.io.File;
+import java.io.IOException;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.methods.HttpUriRequest;
+
+/**
+ * This sample demonstrates use of {@link RangeFileAsyncHttpResponseHandler} to
+ * download a remote file in multiple requests. While this response handler
+ * class handles file storage, it's up to the app itself to request all chunks
+ * of the file.
+ *
+ * Also demonstrated a method to query the remote file's size prior to sending
+ * the actual GET requests. This ensures that the remote server is actually
+ * capable of supporting the "Range" header, necessary to make this sample work.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RangeResponseSample extends GetSample {
+
+    public static final String LOG_TAG = "RangeResponseSample";
+
+    private static final String CONTENT_LENGTH = "Content-Length";
+    private static final String ACCEPT_RANGES = "Accept-Ranges";
+    private static final int CHUNK_SIZE = 10240;
+
+    private File file;
+    private long fileSize = -1;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            // Temporary file to host the URL's downloaded contents.
+            file = File.createTempFile("temp_", "_handled", getCacheDir());
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot create temporary file", e);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+
+        // Remove temporary file.
+        if (file != null) {
+            file.delete();
+            file = null;
+        }
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://upload.wikimedia.org/wikipedia/commons/f/fa/Geysers_on_Mars.jpg";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_range_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        if (fileSize > 0) {
+            // Send a GET query when we know the size of the remote file.
+            return client.get(this, URL, headers, null, responseHandler);
+        } else {
+            // Send a HEAD query to know the size of the remote file.
+            return client.head(this, URL, headers, null, responseHandler);
+        }
+    }
+
+    public void sendNextRangeRequest() {
+        if (file.length() < fileSize) {
+            // File is still smaller than remote file; send a new request.
+            onRunButtonPressed();
+        }
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new RangeFileAsyncHttpResponseHandler(file) {
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+
+                if (fileSize < 1) {
+                    boolean supportsRange = false;
+                    // Cycle through the headers and look for the Content-Length header.
+                    for (Header header : headers) {
+                        String headerName = header.getName();
+                        if (CONTENT_LENGTH.equals(headerName)) {
+                            fileSize = Long.parseLong(header.getValue());
+                        } else if (ACCEPT_RANGES.equals(headerName)) {
+                            supportsRange = true;
+                        }
+                    }
+
+                    // Is the content length known?
+                    if (!supportsRange || fileSize < 1) {
+                        Toast.makeText(
+                            RangeResponseSample.this,
+                            "Unable to determine remote file's size, or\nremote server doesn't support ranges",
+                            Toast.LENGTH_LONG
+                        ).show();
+                    }
+                }
+
+                // If remote file size is known, request next portion.
+                if (fileSize > 0) {
+                    debugFileResponse(file);
+                    // Send a new request for the same resource.
+                    sendNextRangeRequest();
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable e, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                debugFileResponse(file);
+            }
+
+            @Override
+            public void updateRequestHeaders(HttpUriRequest uriRequest) {
+                // Call super so appending could work.
+                super.updateRequestHeaders(uriRequest);
+
+                // Length of the downloaded content thus far.
+                long length = file.length();
+
+                // Request the next portion of the file to be downloaded.
+                uriRequest.setHeader("Range", "bytes=" + length + "-" + (length + CHUNK_SIZE - 1));
+            }
+
+            void debugFileResponse(File file) {
+                debugResponse(LOG_TAG, "File size thus far: " + file.length() + " bytes");
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
new file mode 100644
index 00000000..ca3bab71
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
@@ -0,0 +1,84 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
+import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.ConnectionPoolTimeoutException;
+
+/**
+ * This sample demonstrates use of
+ * {@link AsyncHttpClient#allowRetryExceptionClass(java.lang.Class)} and
+ * {@link AsyncHttpClient#blockRetryExceptionClass(java.lang.Class)} to whitelist
+ * and blacklist certain Exceptions, respectively.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RetryRequestSample extends GetSample {
+
+    private static boolean wasToastShown;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // The following exceptions will be whitelisted, i.e.: When an exception
+        // of this type is raised, the request will be retried.
+        AsyncHttpClient.allowRetryExceptionClass(IOException.class);
+        AsyncHttpClient.allowRetryExceptionClass(SocketTimeoutException.class);
+        AsyncHttpClient.allowRetryExceptionClass(ConnectTimeoutException.class);
+
+        // The following exceptions will be blacklisted, i.e.: When an exception
+        // of this type is raised, the request will not be retried and it will
+        // fail immediately.
+        AsyncHttpClient.blockRetryExceptionClass(UnknownHostException.class);
+        AsyncHttpClient.blockRetryExceptionClass(ConnectionPoolTimeoutException.class);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        if(!wasToastShown) {
+            wasToastShown = true;
+            Toast.makeText(
+                this,
+                "Exceptions' whitelist and blacklist updated\nSee RetryRequestSample.java for details",
+                Toast.LENGTH_LONG
+            ).show();
+        }
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/ip";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_retry_handler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 6854a945..c9954750 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -48,7 +48,9 @@
         new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
         new SampleConfig(R.string.title_post_files, FilesSample.class),
         new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class),
-        new SampleConfig(R.string.title_custom_ca, CustomCASample.class)
+        new SampleConfig(R.string.title_custom_ca, CustomCASample.class),
+        new SampleConfig(R.string.title_retry_handler, RetryRequestSample.class),
+        new SampleConfig(R.string.title_range_sample, RangeResponseSample.class)
     };
 
     @Override
diff --git a/sample/src/main/res/raw/custom_ca.txt b/sample/src/main/res/raw/custom_ca.txt
index a601671d..b2760af9 100644
--- a/sample/src/main/res/raw/custom_ca.txt
+++ b/sample/src/main/res/raw/custom_ca.txt
@@ -1,6 +1,8 @@
 This is a short HOW-TO documenting the steps necessary to create a key store
 file that Android could use to connect to servers with a custom CA.
 
+This file's location is: 'res/raw/custom_ca.txt'
+
 Prerequisities:
 ---------------
 
@@ -23,6 +25,9 @@ Let's see the fun part:
 
    openssl req -newkey rsa:4096 -days 3650 -x509 -nodes -out ca.pem
 
+   This instructs openssl to create a 4096-bit RSA key and set its expiration
+   date 10 years later.
+
    You will be asked to provide details of the CA. When you're finished, a file
    called 'ca.pem' will exist in current directory.
 
diff --git a/sample/src/main/res/raw/store.bks b/sample/src/main/res/raw/store.bks
index e69de29b..6c2453bc 100644
Binary files a/sample/src/main/res/raw/store.bks and b/sample/src/main/res/raw/store.bks differ
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 4b4b9d9f..0dba336b 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -26,4 +26,6 @@
     <string name="title_redirect_302">302 Redirect handling</string>
     <string name="title_persistent_cookies">Handling persistent cookies</string>
     <string name="title_custom_ca">Custom CA Example</string>
+    <string name="title_retry_handler">Retrying requests by Exception</string>
+    <string name="title_range_sample">Range response handling</string>
 </resources>
