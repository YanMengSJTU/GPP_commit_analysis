diff --git a/.travis.yml b/.travis.yml
index 516e7ca9..6f48cc94 100755
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,38 +1,15 @@
-branches:
-  only:
-    - master
-language:
-  - java
-jdk:
-  - openjdk7
-before_install:
-  # environment info
-  - mvn -version
-  - gradle -v
-  - uname -a
-  # required libs for android build tools
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  # for gradle output style
-  - export TERM=dumb
-  # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.11-bin.zip
-  - unzip -qq gradle-1.11-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.11
-  - export PATH=$GRADLE_HOME/bin:$PATH
-  # just to test gradle version, against our provided one
-  - gradle -v
-  # newest android SDK 22.6.1
-  - wget http://dl.google.com/android/android-sdk_r22.6.1-linux.tgz
-  - tar -zxf android-sdk_r22.6.1-linux.tgz
-  - export ANDROID_HOME=`pwd`/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  # manually set sdk.dir variable, according to local paths
-  - echo "sdk.dir=$ANDROID_HOME" > local.properties
-  # list packages for debug purpose
-  - android list sdk -a -e -u
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.3 --force --no-ui
+language: android
+jdk: openjdk7
+android:
+  components:
+    - build-tools-19.1.0
+    - extra-android-support
+    - extra-android-m2repository
+    - android-19
+  licenses:
+    - '.+'
+script:
   # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
-
+  - ./gradlew clean assemble check
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..14d617a9
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,84 @@
+# CHANGELOG
+
+## 1.4.5 (released 22. 6. 2014)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.5](https://github.com/loopj/android-async-http/commits/1.4.5)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=2&state=closed](https://github.com/loopj/android-async-http/issues?milestone=2&state=closed)
+
+  - Support for circular and relative redirects
+  - Added support for SAX parsing, see `SaxAsyncHttpResponseHandler`
+  - Fixed Threading issue when used in Service or non-UI Thread context
+  - Fixed GZIPInputStream issue when running in StrictMode
+  - Removed unnecessary (ambiguous) callback methods (were deprecated in 1.4.4)
+  - Added JsonStreamerEntity to allow up streaming JSON data
+  - Added possibility to modify blacklisted/whitelisted exceptions (see `RetryHandler`)
+  - Using `newCachedThreadPool()` as default ExecutorService in library, with option to change it via main interface
+  - Added `ResponseHandlerInterface` to support completely custom implementations of response handlers
+  - Added `onProgress(int,int)` callback, which is used for upstream progress logging (eg. Progressbar dialogs)
+  - Fixed "division by zero" in default response handler
+  - Added DataAsyncHttpResponseHandler, which has extra callback method which receives partially received data
+  - Fixed problem with uploading more than 2 files (changes in SimpleMultipartEntity)
+  - Fixed problem where on GarbageCollectors activity there was no callback received
+  - Added warning for cases, where headers overwrite each other (between common headers and per-request headers)
+  - Safely closing IO streams (both upstream and downstream)
+  - Fixed PersistentCookieStore issue, where non-persistent cookies were stored and added option to delete stored cookie
+  - Fixed networkOnMainThreadException when canceling requests (`AsyncHttpClient#cancel(boolean)`)
+  - Removed default User-Agent definition from library
+  - Fixed handling null URLs in default interface calls
+  - Allowed to subclass AsyncHttpClient and simply provide custom AsyncHttpRequest object (`AsyncHttpClient#newAsyncHttpRequest`)
+  - Changed project structure to be default Intellij IDEA structure (eg. library/src/main/java)
+  - Catching UnsupportedEncodingException default Async and Text response handlers
+  - Added strict Lint checking for both Library and Sample application
+  - Added example implementations in Sample application
+    - Requests threading (ThreadPool usage, 6 seconds delay on response)
+    - Synchronous request (from Activity and IntentService)
+    - SAX Parsing the response
+    - Retry request sample
+    - Handling 302 redirects
+    - RangeResponse (working with partially received data)
+    - Basic usage of GET, POST, PUT, DELETE
+    - JSON response parsing
+    - GZIP compressed communication
+    - Binary handler (receives `byte[]` without parsing/converting)
+    - File response handler (saving response directly into given File)
+    - Self-signed CA sample (how to pin SSL certificate or add custom trust-chain for requests)
+    - Persistent cookies store (persisting cookies between requests)
+    - Post multi-part encoded Files (SimpleMultipartEntity)
+    - Jackson JSON integration
+
+## 1.4.4 (released 28. 10. 2013)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.4](https://github.com/loopj/android-async-http/commits/1.4.4)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=1&state=closed](https://github.com/loopj/android-async-http/issues?milestone=1&state=closed)
+
+  - Added FileAsyncHttpResponseHandler for direct saving response into File instead of device memory
+  - JsonHttpResponseHandler now parsing JSON in separate thread
+  - Interface method to allow/deny handling of http redirects
+  - Added method to delete previously set header (AsyncHttpClient.java)
+  - Not creating new Thread if call initiated outside of UI Thread (broken, fixed in 1.4.5)
+  - Support for changing response Charset (default still UTF-8)
+  - Allow setting maximum retries count (AsyncHttpClient.java)
+  - SimpleMultipartEntity now allows repeated usage (`HttpEntity.isRepeatable()`)
+  - Added custom SSLSocketFactory to allow certificate pinning and accepting self-signed or untrusted SSL certificates
+  - Callbacks to return HTTP status code and response Headers
+  - Added support for unsetting Basic Auth params
+  - Added support for non-standard HTTP and HTTPS ports (new constructors of `AsyncHttpClient`)
+  - Allowed to change dynamically allowed content-types for BinaryHttpResponseHandler per-response-handler (was static previously)
+  - Added support for setting proxy, optionally with authentication
+    - `AsyncHttpClient#setProxy(String hostname, int port, String username, String password)`
+  - Support for passing Maps, Sets and Lists via RequestParams
+  - Properly chaining callback methods (onSuccess, onFailure, ...) in descendant order by number of function params
+  - Fixed incorrect handling of URLs with spaces after redirect
+    - now sanitizes spaces within URL both on-request and on-redirect
+  - Added RequestHandle which can be used to cancel and/or check request status
+    - Is returned for each call (`.post(...)`, `.get(...)`, `.head(...)`, `.put(...)`, etc..)
+  - Added BaseJsonHttpResponseHandler to simplify integration with Jackson JSON, Gson and other JSON parsing libraries
+  - Added Sample application to demonstrate functions and usage
+    - Using [http://httpbin.org/](http://httpbin.org/) to test methods
+  - Enforcing INTERNET permission
+  - Support for Gradle buildscript
+  - Support for Travis CI (Continuous Integration) testing
+  - Dropped support for Eclipse ADT usage (obsolete)
+  - Added HTTP HEAD method support
+  - Releasing both AAR and JAR (+javadoc and sources) into Maven Central repository
+  - Added tons of mising Javadoc for both classes and methods
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..bc55a3b2
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,47 @@
+CONTRIBUTING
+============
+AsyncHttpClient is an open-source project made by developers for developers!
+
+If you would like to contribute to the project, it's really great. You can contribute in a variety of ways:
+
+  * Help us with test cases and examples for the Wiki (and kindly follow our [Coding Standards](#coding-standards))
+  * If you have a good idea/patch for the project, create a [pull request](#pull-requests)
+  * Found a bug? You're more than welcome to [submit an issue](#issues)
+  * Help other fellow developers solve their problems, you're welcome to do so in issues
+
+We do require certain guidelines to be followed so that the quality of the project remains top-notch:
+
+PULL requests
+-------------
+When you submit a patch or a new functionality for the project, you must open a pull request. We will get to the pull request as soon as possible, investigate what functionality or bug fixes have been added and decide whether to include it in the library or not -- for the benefit of everyone.
+
+**You agree that all contributions that you make to the library will be distributed further under the same license as the library itself (Apache V2).**
+
+Don't be discouraged if your pull request is rejected. This is not a deadline and sometimes with a proper explanation on your side, we are persuaded to merge in the request. Just remember that this is a library for everyone and as such must meet certain, generic rules that we would like to believe are following.  
+
+ISSUES
+---------
+
+![Read the ISSUES?](http://i.imgur.com/LPWyLe7.jpg "Read the ISSUES?")
+
+The issues system is the place to report bugs and not for submitting patches or new functionality. As helpful as we would like to be, we cannot replace the developer and we certainly do not see what you're seeing. So when you come to report an issue, follow these simple rules:  
+
+  * Report bugs in the English language only
+  * Use Markdown to format your issue in a fashionable way (easier to read): [Familiarize yourself](https://help.github.com/articles/github-flavored-markdown)
+  * If the issue is due to a crash, include the stack trace -- `throwable.printStackTrace()` -- and any other detail that will shed light on the problem
+  * We need to see the source code (minus certain details that you think are confidential) that caused the problem in the first place, so include it too
+
+Opening issues without providing us with the information necessary to debug and fix it is useless; so we will close such issues within 7 days period  
+
+CODING STANDARDS
+----------------
+We need you to follow certain rules when sending source code contributions. These are the basic principles that we ourselves abide to and we require that you do so as well:
+
+  * Do not use the Tab character (it's in first place for a reason)
+  * Indentation is 4 spaces
+  * Include the copyright info (as in other files) at the top of the class file
+  * You must provide proper Javadoc, including description, in English for both public and protected methods, classes and properties
+  * Group packages that belong to the same top-level package together, followed by an empty line
+  * Add an empty line after and before class/interface declarations, methods and constructors
+  * Add an empty line before and after a group of properties
+  * Do not catch generic Exception/Throwable errors, but always catch the most specific type of the exception/error
diff --git a/README.md b/README.md
index 182a9605..4c96ed3b 100755
--- a/README.md
+++ b/README.md
@@ -4,6 +4,19 @@ Asynchronous Http Client for Android
 
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
+Changelog
+---------
+
+See what is new in version 1.4.5 released on 22th June 2014
+
+https://github.com/loopj/android-async-http/blob/1.4.5/CHANGELOG.md
+
+Javadoc
+-------
+
+Latest Javadoc for 1.4.5 release are available here (also included in Maven repository):
+
+http://loopj.com/android-async-http/doc/
 
 Features
 --------
@@ -18,30 +31,44 @@ Features
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
 - Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
 
+Examples
+--------
+
+For inspiration and testing on device we've provided Sample Application.  
+See individual samples [here on Github](https://github.com/loopj/android-async-http/tree/1.4.5/sample/src/main/java/com/loopj/android/http/sample)  
+To run Sample application, simply clone the repository and run this command, to install it on connected device  
+
+```java
+gradle :sample:installDebug
+```
+
 Maven
 -----
 You can now integrate this library in your project via Maven. There are available two kind of builds.
 
-**development snapshots**
-https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
+**releases, maven central**
+
+http://central.maven.org/maven2/com/loopj/android/android-async-http/
 ```
-Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
+Maven URL: http://repo1.maven.org/maven2/
 GroupId: com.loopj.android
 ArtifactId: android-async-http
-Version: 1.4.5-SNAPSHOT
+Version: 1.4.5
 Packaging: JAR or AAR
 ```
+Gradle: `com.loopj.android:android-async-http:1.4.5`
 
-**releases, maven central**
+**development snapshots**
 
-http://central.maven.org/maven2/com/loopj/android/android-async-http/
+https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
 ```
-Maven URL: http://repo1.maven.org/maven2/
+Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
 ArtifactId: android-async-http
-Version: 1.4.4
+Version: 1.4.6-SNAPSHOT
 Packaging: JAR or AAR
 ```
+Gradle: `com.loopj.android:android-async-http:1.4.6-SNAPSHOT`
 
 Documentation, Features and Examples
 ------------------------------------
diff --git a/build.gradle b/build.gradle
index 21db9553..8fd5554b 100755
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:+'
+        classpath 'com.android.tools.build:gradle:0.12.2'
     }
 }
 
@@ -14,7 +14,7 @@ def isReleaseBuild() {
 
 allprojects {
     group = 'com.loopj.android'
-    version = '1.4.5-SNAPSHOT'
+    version = '1.4.5'
 
     repositories {
         mavenCentral()
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
deleted file mode 100755
index 998daa1f..00000000
--- a/examples/CookieVideoView.java
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.media.MediaPlayer.OnInfoListener;
-import android.net.Uri;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.widget.MediaController;
-import android.widget.MediaController.MediaPlayerControl;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.http.cookie.Cookie;
-
-/**
- * Displays a video file.  The VideoView class
- * can load images from various sources (such as resources or content
- * providers), takes care of computing its measurement from the video so that
- * it can be used in any layout manager, and provides various display options
- * such as scaling and tinting.
- *
- * @author Jungho Bang <me@bangtoven.com>
- */
-public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
-    private String TAG = "CookieVideoView";
-    // settable by the client
-    private Uri         mUri;
-    private Map<String, String> mHeaders;
-
-    // all possible internal states
-    private static final int STATE_ERROR              = -1;
-    private static final int STATE_IDLE               = 0;
-    private static final int STATE_PREPARING          = 1;
-    private static final int STATE_PREPARED           = 2;
-    private static final int STATE_PLAYING            = 3;
-    private static final int STATE_PAUSED             = 4;
-    private static final int STATE_PLAYBACK_COMPLETED = 5;
-
-    // mCurrentState is a VideoView object's current state.
-    // mTargetState is the state that a method caller intends to reach.
-    // For instance, regardless the VideoView object's current state,
-    // calling pause() intends to bring the object to a target state
-    // of STATE_PAUSED.
-    private int mCurrentState = STATE_IDLE;
-    private int mTargetState  = STATE_IDLE;
-
-    // All the stuff we need for playing and showing a video
-    private SurfaceHolder mSurfaceHolder = null;
-    private MediaPlayer mMediaPlayer = null;
-    private int         mVideoWidth;
-    private int         mVideoHeight;
-    private int         mSurfaceWidth;
-    private int         mSurfaceHeight;
-    private MediaController mMediaController;
-    private OnCompletionListener mOnCompletionListener;
-    private MediaPlayer.OnPreparedListener mOnPreparedListener;
-    private int         mCurrentBufferPercentage;
-    private OnErrorListener mOnErrorListener;
-    private OnInfoListener  mOnInfoListener;
-    private int         mSeekWhenPrepared;  // recording the seek position while preparing
-    private boolean     mCanPause;
-    private boolean     mCanSeekBack;
-    private boolean     mCanSeekForward;
-	private Context 	mContext;
-
-    public CookieVideoView(Context context) {
-        super(context);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initVideoView(context);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        //Log.i("@@@@", "onMeasure");
-        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
-        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
-        if (mVideoWidth > 0 && mVideoHeight > 0) {
-            if ( mVideoWidth * height  > width * mVideoHeight ) {
-                //Log.i("@@@", "image too tall, correcting");
-                height = width * mVideoHeight / mVideoWidth;
-            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
-                //Log.i("@@@", "image too wide, correcting");
-                width = height * mVideoWidth / mVideoHeight;
-            } else {
-                //Log.i("@@@", "aspect ratio is correct: " +
-                        //width+"/"+height+"="+
-                        //mVideoWidth+"/"+mVideoHeight);
-            }
-        }
-        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
-        setMeasuredDimension(width, height);
-    }
-
-    @SuppressLint("NewApi")
-	@Override
-    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-        super.onInitializeAccessibilityEvent(event);
-        event.setClassName(CookieVideoView.class.getName());
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-	@Override
-    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
-        super.onInitializeAccessibilityNodeInfo(info);
-        info.setClassName(CookieVideoView.class.getName());
-    }
-
-    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
-        int result = desiredSize;
-        int specMode = MeasureSpec.getMode(measureSpec);
-        int specSize =  MeasureSpec.getSize(measureSpec);
-
-        switch (specMode) {
-            case MeasureSpec.UNSPECIFIED:
-                /* Parent says we can be as big as we want. Just don't be larger
-                 * than max size imposed on ourselves.
-                 */
-                result = desiredSize;
-                break;
-
-            case MeasureSpec.AT_MOST:
-                /* Parent says we can be as big as we want, up to specSize.
-                 * Don't be larger than specSize, and don't be larger than
-                 * the max size imposed on ourselves.
-                 */
-                result = Math.min(desiredSize, specSize);
-                break;
-
-            case MeasureSpec.EXACTLY:
-                // No choice. Do what we are told.
-                result = specSize;
-                break;
-        }
-        return result;
-}
-
-    private void initVideoView(Context context) {
-        mVideoWidth = 0;
-        mVideoHeight = 0;
-        getHolder().addCallback(mSHCallback);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-        setFocusable(true);
-        setFocusableInTouchMode(true);
-        requestFocus();
-        mCurrentState = STATE_IDLE;
-        mTargetState  = STATE_IDLE;
-        mContext = context;
-    }
-
-    public void setVideoPath(String path) {
-        setVideoURI(Uri.parse(path));
-    }
-
-    public void setVideoURI(Uri uri) {
-    	mUri = uri;
-        mHeaders = getCookieHeader();
-    	mSeekWhenPrepared = 0;
-        openVideo();
-        requestLayout();
-        invalidate();
-    }
-    
-    private Map<String,String> getCookieHeader() {
-    	String hostDomain = mUri.getHost();
-    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
-    	for(Cookie cookie : cookieList) {
-    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
-    			Map<String,String> header = new HashMap<String, String>();
-    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
-    	    	Log.d(TAG,"Cookie: "+header.toString());
-    	        return header;
-    	    }
-    	}
-    	return null;
-    }
-    
-    public void stopPlayback() {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.stop();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            mTargetState  = STATE_IDLE;
-        }
-    }
-
-    private void openVideo() {
-        if (mUri == null || mSurfaceHolder == null) {
-            // not ready for playback just yet, will try again later
-            return;
-        }
-        // Tell the music playback service to pause
-        // TODO: these constants need to be published somewhere in the framework.
-        Intent i = new Intent("com.android.music.musicservicecommand");
-        i.putExtra("command", "pause");
-        mContext.sendBroadcast(i);
-
-        // we shouldn't clear the target state, because somebody might have
-        // called start() previously
-        release(false);
-        try {
-            mMediaPlayer = new MediaPlayer();
-            mMediaPlayer.setOnPreparedListener(mPreparedListener);
-            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
-            mMediaPlayer.setOnCompletionListener(mCompletionListener);
-            mMediaPlayer.setOnErrorListener(mErrorListener);
-            mMediaPlayer.setOnInfoListener(mOnInfoListener);
-            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
-            mCurrentBufferPercentage = 0;
-            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
-            mMediaPlayer.setDisplay(mSurfaceHolder);
-            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mMediaPlayer.setScreenOnWhilePlaying(true);
-            mMediaPlayer.prepareAsync();
-            // we don't set the target state here either, but preserve the
-            // target state that was there before.
-            mCurrentState = STATE_PREPARING;
-            attachMediaController();
-        } catch (IOException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        } catch (IllegalArgumentException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        }
-    }
-
-    public void setMediaController(MediaController controller) {
-        if (mMediaController != null) {
-            mMediaController.hide();
-        }
-        mMediaController = controller;
-        attachMediaController();
-    }
-
-    private void attachMediaController() {
-        if (mMediaPlayer != null && mMediaController != null) {
-            mMediaController.setMediaPlayer(this);
-            View anchorView = this.getParent() instanceof View ?
-                    (View)this.getParent() : this;
-            mMediaController.setAnchorView(anchorView);
-            mMediaController.setEnabled(isInPlaybackState());
-        }
-    }
-
-    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
-        new MediaPlayer.OnVideoSizeChangedListener() {
-            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-                mVideoWidth = mp.getVideoWidth();
-                mVideoHeight = mp.getVideoHeight();
-                if (mVideoWidth != 0 && mVideoHeight != 0) {
-                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                    requestLayout();
-                }
-            }
-    };
-
-    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
-        public void onPrepared(MediaPlayer mp) {
-            mCurrentState = STATE_PREPARED;
-
-            // Get the capabilities of the player for this stream
-//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
-//                                      MediaPlayer.BYPASS_METADATA_FILTER);
-//            
-//          if (data != null) {
-//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
-//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
-//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
-//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
-//            } else {
-                mCanPause = mCanSeekBack = mCanSeekForward = true;
-//            }
-
-            if (mOnPreparedListener != null) {
-                mOnPreparedListener.onPrepared(mMediaPlayer);
-            }
-            if (mMediaController != null) {
-                mMediaController.setEnabled(true);
-            }
-            mVideoWidth = mp.getVideoWidth();
-            mVideoHeight = mp.getVideoHeight();
-
-            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
-            if (seekToPosition != 0) {
-                seekTo(seekToPosition);
-            }
-            if (mVideoWidth != 0 && mVideoHeight != 0) {
-                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
-                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
-                    // We didn't actually change the size (it was already at the size
-                    // we need), so we won't get a "surface changed" callback, so
-                    // start the video here instead of in the callback.
-                    if (mTargetState == STATE_PLAYING) {
-                        start();
-                        if (mMediaController != null) {
-                            mMediaController.show();
-                        }
-                    } else if (!isPlaying() &&
-                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
-                       if (mMediaController != null) {
-                           // Show the media controls when we're paused into a video and make 'em stick.
-                           mMediaController.show(0);
-                       }
-                   }
-                }
-            } else {
-                // We don't know the video size yet, but should start anyway.
-                // The video size might be reported to us later.
-                if (mTargetState == STATE_PLAYING) {
-                    start();
-                }
-            }
-        }
-    };
-
-    private MediaPlayer.OnCompletionListener mCompletionListener =
-        new MediaPlayer.OnCompletionListener() {
-        public void onCompletion(MediaPlayer mp) {
-            mCurrentState = STATE_PLAYBACK_COMPLETED;
-            mTargetState = STATE_PLAYBACK_COMPLETED;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-            if (mOnCompletionListener != null) {
-                mOnCompletionListener.onCompletion(mMediaPlayer);
-            }
-        }
-    };
-
-    private MediaPlayer.OnErrorListener mErrorListener =
-        new MediaPlayer.OnErrorListener() {
-        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
-            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-
-            /* If an error handler has been supplied, use it and finish. */
-            if (mOnErrorListener != null) {
-                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
-                    return true;
-                }
-            }
-
-            /* Otherwise, pop up an error dialog so the user knows that
-             * something bad has happened. Only try and pop up the dialog
-             * if we're attached to a window. When we're going away and no
-             * longer have a window, don't bother showing the user an error.
-             */
-            if (getWindowToken() != null) {
-//                Resources r = mContext.getResources();
-                int messageId;
-
-                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
-                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
-                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
-                } else {
-                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
-                    messageId = R.string.VideoView_error_text_unknown;
-                }
-
-                new AlertDialog.Builder(mContext)
-                        .setMessage(messageId)
-                        //eg. <string name="VideoView_error_button">OK</string>
-                        .setPositiveButton(R.string.VideoView_error_button,
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int whichButton) {
-                                        /* If we get here, there is no onError listener, so
-                                         * at least inform them that the video is over.
-                                         */
-                                        if (mOnCompletionListener != null) {
-                                            mOnCompletionListener.onCompletion(mMediaPlayer);
-                                        }
-                                    }
-                                })
-                        .setCancelable(false)
-                        .show();
-            }
-            return true;
-        }
-    };
-
-    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
-        new MediaPlayer.OnBufferingUpdateListener() {
-        public void onBufferingUpdate(MediaPlayer mp, int percent) {
-            mCurrentBufferPercentage = percent;
-        }
-    };
-
-    /**
-     * Register a callback to be invoked when the media file
-     * is loaded and ready to go.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
-    {
-        mOnPreparedListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when the end of a media file
-     * has been reached during playback.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnCompletionListener(OnCompletionListener l)
-    {
-        mOnCompletionListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an error occurs
-     * during playback or setup.  If no listener is specified,
-     * or if the listener returned false, VideoView will inform
-     * the user of any errors.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnErrorListener(OnErrorListener l)
-    {
-        mOnErrorListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an informational event
-     * occurs during playback or setup.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnInfoListener(OnInfoListener l) {
-        mOnInfoListener = l;
-    }
-
-    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
-    {
-        public void surfaceChanged(SurfaceHolder holder, int format,
-                                    int w, int h)
-        {
-            mSurfaceWidth = w;
-            mSurfaceHeight = h;
-            boolean isValidState =  (mTargetState == STATE_PLAYING);
-            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
-            if (mMediaPlayer != null && isValidState && hasValidSize) {
-                if (mSeekWhenPrepared != 0) {
-                    seekTo(mSeekWhenPrepared);
-                }
-                start();
-            }
-        }
-
-        public void surfaceCreated(SurfaceHolder holder)
-        {
-            mSurfaceHolder = holder;
-            openVideo();
-        }
-
-        public void surfaceDestroyed(SurfaceHolder holder)
-        {
-            // after we return from this we can't use the surface any more
-            mSurfaceHolder = null;
-            if (mMediaController != null) mMediaController.hide();
-            release(true);
-        }
-    };
-
-    /*
-     * release the media player in any state
-     */
-    private void release(boolean cleartargetstate) {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.reset();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            if (cleartargetstate) {
-                mTargetState  = STATE_IDLE;
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onTrackballEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
-                                     keyCode != KeyEvent.KEYCODE_MENU &&
-                                     keyCode != KeyEvent.KEYCODE_CALL &&
-                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
-        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
-            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
-                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                } else {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
-                if (!mMediaPlayer.isPlaying()) {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
-                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                }
-                return true;
-            } else {
-                toggleMediaControlsVisiblity();
-            }
-        }
-
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void toggleMediaControlsVisiblity() {
-        if (mMediaController.isShowing()) {
-            mMediaController.hide();
-        } else {
-            mMediaController.show();
-        }
-    }
-
-    public void start() {
-        if (isInPlaybackState()) {
-            mMediaPlayer.start();
-            mCurrentState = STATE_PLAYING;
-        }
-        mTargetState = STATE_PLAYING;
-    }
-
-    public void pause() {
-        if (isInPlaybackState()) {
-            if (mMediaPlayer.isPlaying()) {
-                mMediaPlayer.pause();
-                mCurrentState = STATE_PAUSED;
-            }
-        }
-        mTargetState = STATE_PAUSED;
-    }
-
-    public void suspend() {
-        release(false);
-    }
-
-    public void resume() {
-        openVideo();
-    }
-
-    public int getDuration() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getDuration();
-        }
-
-        return -1;
-    }
-
-    public int getCurrentPosition() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getCurrentPosition();
-        }
-        return 0;
-    }
-
-    public void seekTo(int msec) {
-        if (isInPlaybackState()) {
-            mMediaPlayer.seekTo(msec);
-            mSeekWhenPrepared = 0;
-        } else {
-            mSeekWhenPrepared = msec;
-        }
-    }
-
-    public boolean isPlaying() {
-        return isInPlaybackState() && mMediaPlayer.isPlaying();
-    }
-
-    public int getBufferPercentage() {
-        if (mMediaPlayer != null) {
-            return mCurrentBufferPercentage;
-        }
-        return 0;
-    }
-
-    private boolean isInPlaybackState() {
-        return (mMediaPlayer != null &&
-                mCurrentState != STATE_ERROR &&
-                mCurrentState != STATE_IDLE &&
-                mCurrentState != STATE_PREPARING);
-    }
-
-    public boolean canPause() {
-        return mCanPause;
-    }
-
-    public boolean canSeekBackward() {
-        return mCanSeekBack;
-    }
-
-    public boolean canSeekForward() {
-        return mCanSeekForward;
-    }
-}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
deleted file mode 100755
index b5c4fc6f..00000000
--- a/examples/ExampleUsage.java
+++ /dev/null
@@ -1,12 +0,0 @@
-public class ExampleUsage {
-    public static void makeRequest() {
-        AsyncHttpClient client = new AsyncHttpClient();
-
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
-            @Override
-            public void onSuccess(String response) {
-                System.out.println(response);
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
deleted file mode 100755
index ce949817..00000000
--- a/examples/TestCaseExampleUsage.java
+++ /dev/null
@@ -1,63 +0,0 @@
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
-import android.test.InstrumentationTestCase;
-import android.util.Log;
-
-// Credits to Wuyexiong <forever_crying@qq.com>
-// See: https://github.com/loopj/android-async-http/pull/236
-public class TestCaseExampleUsage extends InstrumentationTestCase
-{
-	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
-
-	public void testAsync() throws Throwable
-	{
-		final CountDownLatch signal = new CountDownLatch(1);
-		runTestOnUiThread(new Runnable()
-		{
-			@Override
-			public void run()
-			{
-				AsyncHttpClient client = new AsyncHttpClient();
-
-				client.get("http://www.google.com", new AsyncHttpResponseHandler()
-				{
-					@Override
-					public void onStart()
-					{
-						Log.v(TAG , "onStart");
-					}
-
-					@Override
-					public void onSuccess(String response)
-					{
-						Log.v(TAG , "onSuccess");
-						System.out.println(response);
-					}
-
-					@Override
-					public void onFailure(Throwable error, String content)
-					{
-						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
-					}
-
-					@Override
-					public void onFinish()
-					{
-						Log.v(TAG , "onFinish");
-						signal.countDown();
-					}
-				});
-
-				try {
-					signal.await(30, TimeUnit.SECONDS);
-				} catch (InterruptedException e) {
-				}
-				Log.v(TAG , "TestCaseExampleUsage Over");
-			}
-		});
-	}
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
deleted file mode 100755
index 395273df..00000000
--- a/examples/TwitterRestClient.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// Static wrapper library around AsyncHttpClient
-
-public class TwitterRestClient {
-    private static final String BASE_URL = "http://api.twitter.com/1/";
-
-    private static AsyncHttpClient client = new AsyncHttpClient();
-
-    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.post(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    private static String getAbsoluteUrl(String relativeUrl) {
-        return BASE_URL + relativeUrl;
-    }
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
deleted file mode 100755
index 297bfecc..00000000
--- a/examples/TwitterRestClientUsage.java
+++ /dev/null
@@ -1,18 +0,0 @@
-class TwitterRestClientUsage {
-    public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
-            @Override
-            public void onSuccess(JSONArray timeline) {
-                try {
-                    JSONObject firstEvent = (JSONObject) timeline.get(0);
-                    String tweetText = firstEvent.getString("text");
-
-                    // Do something with the response
-                    System.out.println(tweetText);
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index faf4d955..b80c3224 100755
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
-VERSION_NAME=1.4.5-SNAPSHOT
+VERSION_NAME=1.4.5
 VERSION_CODE=145
 GROUP=com.loopj.android
 
@@ -10,3 +10,7 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=jamessmith
+POM_DEVELOPER_NAME=James Smith
+
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..0087cd3b
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..796a5111
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Jul 02 18:01:59 CEST 2014
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-bin.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..aec99730
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/build.gradle b/library/build.gradle
index 3ac2b0a6..f68a9d92 100755
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,46 +1,34 @@
-import com.android.builder.BuilderConstants
-
-apply plugin: 'android-library'
+apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.3'
+    buildToolsVersion '19.1'
 
     defaultConfig {
         minSdkVersion 3
         targetSdkVersion 19
     }
-    
+
     lintOptions {
-        abortOnError false
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
+        disable 'OldTargetApi'
     }
 
     compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_7
-        targetCompatibility JavaVersion.VERSION_1_7
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
     }
 }
 
 android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "android${name.capitalize()}Jar", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-android.libraryVariants.all { variant ->
-
-    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
-        description "Generates Javadoc for $variant.name."
-        source = variant.javaCompile.source
-        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
-    }
-
+    def name = variant.buildType.name
+    def task = project.tasks.create "jar${name.capitalize()}", Jar
+    task.dependsOn variant.javaCompile
+    task.from variant.javaCompile.destinationDir
+    artifacts.add('archives', task);
 }
 
 apply from: '../maven_push.gradle'
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index f45dcd47..ccb41e6e 100755
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http"
-    android:versionName="1.4.5-SNAPSHOT"
-    android:versionCode="145">
+          package="com.loopj.android.http"
+          android:versionName="1.4.5"
+          android:versionCode="145">
 
-    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
-    <application />
+    <application/>
 
 </manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AssertUtils.java b/library/src/main/java/com/loopj/android/http/AssertUtils.java
new file mode 100644
index 00000000..ddd7c6e4
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/AssertUtils.java
@@ -0,0 +1,34 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+/**
+ * Internal class, used to make some asserts, throw AssertError if asserts fail.
+ */
+class AssertUtils {
+
+    private AssertUtils() {
+    }
+
+    public static void asserts(final boolean expression, final String failedMessage) {
+        if (!expression) {
+            throw new AssertionError(failedMessage);
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 2e2f68c9..51843bdb 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -72,7 +72,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.PushbackInputStream;
+import java.lang.reflect.Field;
 import java.net.URI;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -81,7 +84,6 @@
 import java.util.WeakHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.zip.GZIPInputStream;
 
 
@@ -92,27 +94,44 @@
  * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new ResponseHandlerInterface() {
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
  *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+ *          System.out.println(response);
+ *     }
+ *     &#064;Override
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
+ * {
+ *          error.printStackTrace(System.out);
  *     }
  * });
  * </pre>
+ *
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ * @see com.loopj.android.http.ResponseHandlerInterface
+ * @see com.loopj.android.http.RequestParams
  */
 public class AsyncHttpClient {
 
+    public static final String LOG_TAG = "AsyncHttpClient";
+
+    public static final String HEADER_CONTENT_TYPE = "Content-Type";
+    public static final String HEADER_CONTENT_RANGE = "Content-Range";
+    public static final String HEADER_CONTENT_ENCODING = "Content-Encoding";
+    public static final String HEADER_CONTENT_DISPOSITION = "Content-Disposition";
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+
     public static final int DEFAULT_MAX_CONNECTIONS = 10;
     public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     public static final int DEFAULT_MAX_RETRIES = 5;
     public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
     public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    public static final String ENCODING_GZIP = "gzip";
-    public static final String LOG_TAG = "AsyncHttpClient";
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private int timeout = DEFAULT_SOCKET_TIMEOUT;
+    private int connectTimeout = DEFAULT_SOCKET_TIMEOUT;
+    private int responseTimeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
@@ -150,7 +169,7 @@ public AsyncHttpClient(int httpPort, int httpsPort) {
     /**
      * Creates new AsyncHttpClient using given params
      *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param fixNoHttpResponseException Whether to fix issue or not, by omitting SSL verification
      * @param httpPort                   HTTP port to be used, must be greater than 0
      * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
@@ -161,7 +180,7 @@ public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int htt
     /**
      * Returns default instance of SchemeRegistry
      *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param fixNoHttpResponseException Whether to fix issue or not, by omitting SSL verification
      * @param httpPort                   HTTP port to be used, must be greater than 0
      * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
@@ -183,10 +202,11 @@ private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponse
         // Fix to SSL flaw in API < ICS
         // See https://code.google.com/p/android/issues/detail?id=13117
         SSLSocketFactory sslSocketFactory;
-        if (fixNoHttpResponseException)
+        if (fixNoHttpResponseException) {
             sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
-        else
+        } else {
             sslSocketFactory = SSLSocketFactory.getSocketFactory();
+        }
 
         SchemeRegistry schemeRegistry = new SchemeRegistry();
         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
@@ -204,12 +224,12 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         BasicHttpParams httpParams = new BasicHttpParams();
 
-        ConnManagerParams.setTimeout(httpParams, timeout);
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
         ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
 
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
         HttpConnectionParams.setTcpNoDelay(httpParams, true);
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
@@ -218,7 +238,7 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         threadPool = getDefaultThreadPool();
-        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
+        requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
         clientHeaderMap = new HashMap<String, String>();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
@@ -237,6 +257,9 @@ public void process(HttpRequest request, HttpContext context) {
                                         header, clientHeaderMap.get(header),
                                         overwritten.getName(), overwritten.getValue())
                         );
+
+                        //remove the overwritten header
+                        request.removeHeader(overwritten);
                     }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
@@ -329,17 +352,17 @@ public void setCookieStore(CookieStore cookieStore) {
 
     /**
      * Overrides the threadpool implementation used when queuing/pooling requests. By default,
-     * Executors.newFixedThreadPool() is used.
+     * Executors.newCachedThreadPool() is used.
      *
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling
+     * @param threadPool an instance of {@link ExecutorService} to use for queuing/pooling
      *                   requests.
      */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
+    public void setThreadPool(ExecutorService threadPool) {
         this.threadPool = threadPool;
     }
 
     /**
-     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * Returns the current executor service used. By default, Executors.newCachedThreadPool() is
      * used.
      *
      * @return current executor service used
@@ -359,9 +382,8 @@ protected ExecutorService getDefaultThreadPool() {
 
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
-     * on underlying HttpClient, effects of this method will be canceled.
-     * <p/>
-     * Default setting is to disallow redirects.
+     * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
+     * setting is to disallow redirects.
      *
      * @param enableRedirects         boolean
      * @param enableRelativeRedirects boolean
@@ -437,27 +459,73 @@ public void setMaxConnections(int maxConnections) {
     }
 
     /**
-     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     * Returns current socket timeout limit (milliseconds). By default, this is
+     * set to 10 seconds.
      *
      * @return Socket Timeout limit in milliseconds
+     * @deprecated Use either {@link #getConnectTimeout()} or {@link #getResponseTimeout()}
      */
     public int getTimeout() {
-        return timeout;
+        return connectTimeout;
     }
 
     /**
-     * Set the connection and socket timeout. By default, 10 seconds.
+     * Set both the connection and socket timeouts. By default, both are set to
+     * 10 seconds.
      *
-     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
+     * @param value the connect/socket timeout in milliseconds, at least 1 second
+     * @see {@link #setConnectTimeout(int)} if you need further refinement for either value or
+     * or {@link #setResponseTimeout(int)} methods.
      */
-    public void setTimeout(int timeout) {
-        if (timeout < 1000)
-            timeout = DEFAULT_SOCKET_TIMEOUT;
-        this.timeout = timeout;
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
+    public void setTimeout(int value) {
+        value = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        setConnectTimeout(value);
+        setResponseTimeout(value);
+    }
+
+    /**
+     * Returns current connection timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
+     *
+     * @return Connection timeout limit in milliseconds
+     */
+    public int getConnectTimeout() {
+        return connectTimeout;
+    }
+
+    /**
+     * Set connection timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Connection timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setConnectTimeout(int value) {
+        connectTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
+    }
+
+    /**
+     * Returns current response timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
+     *
+     * @return Response timeout limit in milliseconds
+     */
+    public int getResponseTimeout() {
+        return responseTimeout;
+    }
+
+    /**
+     * Set response timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Response timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setResponseTimeout(int value) {
+        responseTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
     }
 
     /**
@@ -509,6 +577,14 @@ public void setMaxRetriesAndTimeout(int retries, int timeout) {
         this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
     }
 
+    /**
+     * Will, before sending, remove all headers currently present in AsyncHttpClient instance, which
+     * applies on all requests this client makes
+     */
+    public void removeAllHeaders() {
+        clientHeaderMap.clear();
+    }
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
      *
@@ -1030,6 +1106,22 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
 
     // [-] HTTP DELETE
 
+    /**
+     * Instantiate a new asynchronous HTTP request for the passed parameters.
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
+     *                        HttpPost, HttpGet, HttpPut, etc.
+     * @return AsyncHttpRequest ready to be dispatched
+     */
+    protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
     /**
      * Puts a new request in queue as a new thread in pool to be executed
      *
@@ -1056,22 +1148,24 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
         }
 
         if (contentType != null) {
-            uriRequest.setHeader("Content-Type", contentType);
+            uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);
         }
 
         responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
         responseHandler.setRequestURI(uriRequest.getURI());
 
-        AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+        AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
         threadPool.submit(request);
         RequestHandle requestHandle = new RequestHandle(request);
 
         if (context != null) {
             // Add request to request map
             List<RequestHandle> requestList = requestMap.get(context);
-            if (requestList == null) {
-                requestList = new LinkedList();
-                requestMap.put(context, requestList);
+            synchronized (requestMap) {
+                if (requestList == null) {
+                    requestList = Collections.synchronizedList(new LinkedList<RequestHandle>());
+                    requestMap.put(context, requestList);
+                }
             }
 
             if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
@@ -1109,6 +1203,9 @@ public void setURLEncodingEnabled(boolean enabled) {
      * @return encoded url if requested with params appended if any available
      */
     public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
+        if (url == null)
+            return null;
+
         if (shouldEncodeUrl)
             url = url.replace(" ", "%20");
 
@@ -1128,6 +1225,24 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
         return url;
     }
 
+    /**
+     * Checks the InputStream if it contains  GZIP compressed data
+     *
+     * @param inputStream InputStream to be checked
+     * @return true or false if the stream contains GZIP compressed data
+     * @throws java.io.IOException
+     */
+    public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {
+        if (inputStream == null)
+            return false;
+
+        byte[] signature = new byte[2];
+        int readStatus = inputStream.read(signature);
+        inputStream.unread(signature);
+        int streamHeader = ((int) signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);
+        return readStatus == 2 && GZIPInputStream.GZIP_MAGIC == streamHeader;
+    }
+
     /**
      * A utility function to close an input stream without raising an exception.
      *
@@ -1172,11 +1287,12 @@ private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface
             if (params != null) {
                 entity = params.getEntity(responseHandler);
             }
-        } catch (Throwable t) {
-            if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, null, t);
-            else
-                t.printStackTrace();
+        } catch (IOException e) {
+            if (responseHandler != null) {
+                responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                e.printStackTrace();
+            }
         }
 
         return entity;
@@ -1201,22 +1317,72 @@ private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosin
         return requestBase;
     }
 
+    /**
+     * This horrible hack is required on Android, due to implementation of BasicManagedEntity, which
+     * doesn't chain call consumeContent on underlying wrapped HttpEntity
+     *
+     * @param entity HttpEntity, may be null
+     */
+    public static void endEntityViaReflection(HttpEntity entity) {
+        if (entity instanceof HttpEntityWrapper) {
+            try {
+                Field f = null;
+                Field[] fields = HttpEntityWrapper.class.getDeclaredFields();
+                for (Field ff : fields) {
+                    if (ff.getName().equals("wrappedEntity")) {
+                        f = ff;
+                        break;
+                    }
+                }
+                if (f != null) {
+                    f.setAccessible(true);
+                    HttpEntity wrapped = (HttpEntity) f.get(entity);
+                    if (wrapped != null) {
+                        wrapped.consumeContent();
+                    }
+                }
+            } catch (Throwable t) {
+                Log.e(LOG_TAG, "wrappedEntity consume", t);
+            }
+        }
+    }
+
     /**
      * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
      */
     private static class InflatingEntity extends HttpEntityWrapper {
+
         public InflatingEntity(HttpEntity wrapped) {
             super(wrapped);
         }
 
+        InputStream wrappedStream;
+        PushbackInputStream pushbackStream;
+        GZIPInputStream gzippedStream;
+
         @Override
         public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
+            wrappedStream = wrappedEntity.getContent();
+            pushbackStream = new PushbackInputStream(wrappedStream, 2);
+            if (isInputStreamGZIPCompressed(pushbackStream)) {
+                gzippedStream = new GZIPInputStream(pushbackStream);
+                return gzippedStream;
+            } else {
+                return pushbackStream;
+            }
         }
 
         @Override
         public long getContentLength() {
             return -1;
         }
+
+        @Override
+        public void consumeContent() throws IOException {
+            AsyncHttpClient.silentCloseInputStream(wrappedStream);
+            AsyncHttpClient.silentCloseInputStream(pushbackStream);
+            AsyncHttpClient.silentCloseInputStream(gzippedStream);
+            super.consumeContent();
+        }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 81786ceb..b7756d8f 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -39,9 +39,10 @@
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
-    private boolean isCancelled = false;
-    private boolean cancelIsNotified = false;
-    private boolean isFinished = false;
+    private boolean isCancelled;
+    private boolean cancelIsNotified;
+    private boolean isFinished;
+    private boolean isRequestPreProcessed;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
         this.client = client;
@@ -50,12 +51,52 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.responseHandler = responseHandler;
     }
 
+    /**
+     * This method is called once by the system when the request is about to be
+     * processed by the system. The library makes sure that a single request
+     * is pre-processed only once.
+     *
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to pre-process
+     */
+    public void onPreProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
+    }
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single request
+     * is post-processed only once.
+     *
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to post-process
+     */
+    public void onPostProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
+    }
+
     @Override
     public void run() {
         if (isCancelled()) {
             return;
         }
 
+        // Carry out pre-processing for this request only once.
+        if (!isRequestPreProcessed) {
+            isRequestPreProcessed = true;
+            onPreProcessRequest(this);
+        }
+
+        if (isCancelled()) {
+            return;
+        }
+
         if (responseHandler != null) {
             responseHandler.sendStartMessage();
         }
@@ -82,6 +123,13 @@ public void run() {
             responseHandler.sendFinishMessage();
         }
 
+        if (isCancelled()) {
+            return;
+        }
+
+        // Carry out post-processing for this request.
+        onPostProcessRequest(this);
+
         isFinished = true;
     }
 
@@ -89,6 +137,7 @@ private void makeRequest() throws IOException {
         if (isCancelled()) {
             return;
         }
+
         // Fixes #115
         if (request.getURI().getScheme() == null) {
             // subclass of IOException so processed in the caller
@@ -97,9 +146,26 @@ private void makeRequest() throws IOException {
 
         HttpResponse response = client.execute(request, context);
 
-        if (!isCancelled() && responseHandler != null) {
-            responseHandler.sendResponseMessage(response);
+        if (isCancelled() || responseHandler == null) {
+            return;
+        }
+
+        // Carry out pre-processing for this response.
+        responseHandler.onPreProcessResponse(responseHandler, response);
+
+        if (isCancelled()) {
+            return;
+        }
+
+        // The response is ready, handle it.
+        responseHandler.sendResponseMessage(response);
+
+        if (isCancelled()) {
+            return;
         }
+
+        // Carry out post-processing for this response.
+        responseHandler.onPostProcessResponse(responseHandler, response);
     }
 
     private void makeRequestWithRetries() throws IOException {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index b345d872..6943584a 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -62,7 +62,7 @@
  *     }
  *
  *     &#064;Override
- *     public void onRetry() {
+ *     public void onRetry(int retryNo) {
  *         // Request was retried
  *     }
  *
@@ -79,6 +79,7 @@
  * </pre>
  */
 public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+
     private static final String LOG_TAG = "AsyncHttpResponseHandler";
 
     protected static final int SUCCESS_MESSAGE = 0;
@@ -92,12 +93,14 @@
     protected static final int BUFFER_SIZE = 4096;
 
     public static final String DEFAULT_CHARSET = "UTF-8";
+    public static final String UTF8_BOM = "\uFEFF";
     private String responseCharset = DEFAULT_CHARSET;
     private Handler handler;
     private boolean useSynchronousMode;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
+    private Looper looper = null;
 
     @Override
     public URI getRequestURI() {
@@ -125,7 +128,8 @@ public void setRequestHeaders(Header[] requestHeaders) {
     private static class ResponderHandler extends Handler {
         private final AsyncHttpResponseHandler mResponder;
 
-        ResponderHandler(AsyncHttpResponseHandler mResponder) {
+        ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) {
+            super(looper);
             this.mResponder = mResponder;
         }
 
@@ -141,23 +145,23 @@ public boolean getUseSynchronousMode() {
     }
 
     @Override
-    public void setUseSynchronousMode(boolean value) {
+    public void setUseSynchronousMode(boolean sync) {
         // A looper must be prepared before setting asynchronous mode.
-        if (!value && Looper.myLooper() == null) {
-            value = true;
+        if (!sync && looper == null) {
+            sync = true;
             Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
         }
 
-        // If using synchronous mode.
-        if (!value && handler == null) {
+        // If using asynchronous mode.
+        if (!sync && handler == null) {
             // Create a handler on current thread to submit tasks
-            handler = new ResponderHandler(this);
-        } else if (value && handler != null) {
+            handler = new ResponderHandler(this, looper);
+        } else if (sync && handler != null) {
             // TODO: Consider adding a flag to remove all queued messages.
             handler = null;
         }
 
-        useSynchronousMode = value;
+        useSynchronousMode = sync;
     }
 
     /**
@@ -178,6 +182,18 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
+        this(null);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If
+     * the passed looper is null, the looper attached to the current thread will
+     * be used.
+     *
+     * @param looper The looper to work with
+     */
+    public AsyncHttpResponseHandler(Looper looper) {
+        this.looper = looper == null ? Looper.myLooper() : looper;
         // Use asynchronous mode by default.
         setUseSynchronousMode(false);
     }
@@ -196,6 +212,7 @@ public void onProgress(int bytesWritten, int totalSize) {
      * Fired when the request is started, override to handle in your own code
      */
     public void onStart() {
+        // default log warning is not necessary, because this method is just optional notification
     }
 
     /**
@@ -203,6 +220,17 @@ public void onStart() {
      * handle in your own code
      */
     public void onFinish() {
+        // default log warning is not necessary, because this method is just optional notification
+    }
+
+    @Override
+    public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
+    }
+
+    @Override
+    public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
     }
 
     /**
@@ -237,30 +265,37 @@ public void onCancel() {
         Log.d(LOG_TAG, "Request got cancelled");
     }
 
+    @Override
     final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
+    @Override
     final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
     }
 
+    @Override
     final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
     }
 
+    @Override
     final public void sendStartMessage() {
         sendMessage(obtainMessage(START_MESSAGE, null));
     }
 
+    @Override
     final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
+    @Override
     final public void sendRetryMessage(int retryNo) {
         sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
     }
 
+    @Override
     final public void sendCancelMessage() {
         sendMessage(obtainMessage(CANCEL_MESSAGE, null));
     }
@@ -306,10 +341,11 @@ protected void handleMessage(Message message) {
                 break;
             case RETRY_MESSAGE:
                 response = (Object[]) message.obj;
-                if (response != null && response.length == 1)
+                if (response != null && response.length == 1) {
                     onRetry((Integer) response[0]);
-                else
+                } else {
                     Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                }
                 break;
             case CANCEL_MESSAGE:
                 onCancel();
@@ -321,6 +357,7 @@ protected void sendMessage(Message msg) {
         if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
+            AssertUtils.asserts(handler != null, "handler should not be null!");
             handler.sendMessage(msg);
         }
     }
@@ -337,6 +374,7 @@ protected void postRunnable(Runnable runnable) {
                 runnable.run();
             } else {
                 // Otherwise, run on provided handler
+                AssertUtils.asserts(handler != null, "handler should not be null!");
                 handler.post(runnable);
             }
         }
@@ -350,17 +388,7 @@ protected void postRunnable(Runnable runnable) {
      * @return Message instance, should not be null
      */
     protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
-        Message msg;
-        if (handler == null) {
-            msg = Message.obtain();
-            if (msg != null) {
-                msg.what = responseMessageId;
-                msg.obj = responseMessageData;
-            }
-        } else {
-            msg = Message.obtain(handler, responseMessageId, responseMessageData);
-        }
-        return msg;
+        return Message.obtain(handler, responseMessageId, responseMessageData);
     }
 
     @Override
@@ -411,6 +439,7 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                         }
                     } finally {
                         AsyncHttpClient.silentCloseInputStream(instream);
+                        AsyncHttpClient.endEntityViaReflection(entity);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
index 0fae7e9a..cc26d439 100755
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -90,14 +90,14 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p/>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param str   the input String to decode, which is converted to bytes using the default
      *              charset
      * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *              standard Base64.
+     * @return decoded bytes
      * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(String str, int flags) {
@@ -106,13 +106,13 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p/>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input the input array to decode
      * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *              standard Base64.
+     * @return decoded bytes
      * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int flags) {
@@ -121,15 +121,15 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p/>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input  the data to decode
      * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to decode
      * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *               standard Base64.
+     * @return decoded bytes for given offset and length
      * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int offset, int len, int flags) {
@@ -425,6 +425,7 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
      * @param input the data to encode
      * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
      *              in output that adheres to RFC 2045.
+     * @return base64 string containing encoded input
      */
     public static String encodeToString(byte[] input, int flags) {
         try {
@@ -443,6 +444,7 @@ public static String encodeToString(byte[] input, int flags) {
      * @param len    the number of bytes of input to encode
      * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
      *               results in output that adheres to RFC 2045.
+     * @return base64 string containing encoded range of input
      */
     public static String encodeToString(byte[] input, int offset, int len, int flags) {
         try {
@@ -459,6 +461,7 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
      * @param input the data to encode
      * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
      *              in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
      */
     public static byte[] encode(byte[] input, int flags) {
         return encode(input, 0, input.length, flags);
@@ -472,6 +475,7 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
      * @param len    the number of bytes of input to encode
      * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
      *               results in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
      */
     public static byte[] encode(byte[] input, int offset, int len, int flags) {
         Encoder encoder = new Encoder(flags, null);
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
index ead54c56..ea2af542 100755
--- a/library/src/main/java/com/loopj/android/http/Base64DataException.java
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.loopj.android.http;
 
 import java.io.IOException;
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
index 231d4036..036d4a28 100755
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -1,5 +1,20 @@
-package com.loopj.android.http;
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
+package com.loopj.android.http;
 
 import java.io.FilterOutputStream;
 import java.io.IOException;
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index bc5deabd..dae49c59 100755
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -29,7 +29,8 @@
  * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
  * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
  * Throwable, String, Object)}, depending of response HTTP status line (result http code)
- * @param <JSON_TYPE>
+ *
+ * @param <JSON_TYPE> Generic type meant to be returned in callback
  */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
@@ -74,7 +75,7 @@ public BaseJsonHttpResponseHandler(String encoding) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -95,11 +96,13 @@ public void run() {
                         });
                     }
                 }
-	    };
-            if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, null, null);
         }
@@ -108,7 +111,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
         if (responseString != null) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -129,11 +132,13 @@ public void run() {
                         });
                     }
                 }
-	    };
-            if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             onFailure(statusCode, headers, throwable, null, null);
         }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index 1959ec6d..3b844dfc 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -54,8 +54,10 @@
     private static final String LOG_TAG = "BinaryHttpResponseHandler";
 
     private String[] mAllowedContentTypes = new String[]{
+            RequestParams.APPLICATION_OCTET_STREAM,
             "image/jpeg",
-            "image/png"
+            "image/png",
+            "image/gif"
     };
 
     /**
@@ -83,10 +85,11 @@ public BinaryHttpResponseHandler() {
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
         super();
-        if (allowedContentTypes != null)
+        if (allowedContentTypes != null) {
             mAllowedContentTypes = allowedContentTypes;
-        else
+        } else {
             Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
+        }
     }
 
     @Override
@@ -98,10 +101,18 @@ public BinaryHttpResponseHandler(String[] allowedContentTypes) {
     @Override
     public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        Header[] contentTypeHeaders = response.getHeaders(AsyncHttpClient.HEADER_CONTENT_TYPE);
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
+            sendFailureMessage(
+                    status.getStatusCode(),
+                    response.getAllHeaders(),
+                    null,
+                    new HttpResponseException(
+                            status.getStatusCode(),
+                            "None, or more than one, Content-Type Header found!"
+                    )
+            );
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -117,7 +128,15 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
+            sendFailureMessage(
+                    status.getStatusCode(),
+                    response.getAllHeaders(),
+                    null,
+                    new HttpResponseException(
+                            status.getStatusCode(),
+                            "Content-Type not allowed!"
+                    )
+            );
             return;
         }
         super.sendResponseMessage(response);
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
index b121835d..31e7f702 100755
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -1,5 +1,3 @@
-package com.loopj.android.http;
-
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
@@ -18,6 +16,8 @@
     limitations under the License.
 */
 
+package com.loopj.android.http;
+
 import android.os.Message;
 import android.util.Log;
 
@@ -45,6 +45,7 @@ public DataAsyncHttpResponseHandler() {
      * @param responseBody response body received so far
      */
     public void onProgressData(byte[] responseBody) {
+        Log.d(LOG_TAG, "onProgressData(byte[]) was not overriden, but callback was received");
     }
 
 
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index be48f62b..5a005d6a 100755
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -11,7 +29,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-
 public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
     protected final File mFile;
@@ -57,8 +74,8 @@ protected File getTemporaryFile(Context context) {
         assert (context != null);
         try {
             return File.createTempFile("temp_", "_handled", context.getCacheDir());
-        } catch (Throwable t) {
-            Log.e(LOG_TAG, "Cannot create temporary file", t);
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot create temporary file", e);
         }
         return null;
     }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 63648a15..b12afce6 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -36,17 +36,18 @@
  * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends TextHttpResponseHandler {
+
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
     /**
-     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
+     * Creates new JsonHttpResponseHandler, with JSON String encoding UTF-8
      */
     public JsonHttpResponseHandler() {
         super(DEFAULT_CHARSET);
     }
 
     /**
-     * Creates new JsonHttpRespnseHandler with given Json String encoding
+     * Creates new JsonHttpRespnseHandler with given JSON String encoding
      *
      * @param encoding String encoding to be used when parsing JSON
      */
@@ -62,7 +63,7 @@ public JsonHttpResponseHandler(String encoding) {
      * @param response   parsed response if any
      */
     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-
+        Log.w(LOG_TAG, "onSuccess(int, Header[], JSONObject) was not overriden, but callback was received");
     }
 
     /**
@@ -73,7 +74,7 @@ public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
      * @param response   parsed response if any
      */
     public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-
+        Log.w(LOG_TAG, "onSuccess(int, Header[], JSONArray) was not overriden, but callback was received");
     }
 
     /**
@@ -85,7 +86,7 @@ public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
      * @param errorResponse parsed response if any
      */
     public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
-
+        Log.w(LOG_TAG, "onFailure(int, Header[], Throwable, JSONObject) was not overriden, but callback was received", throwable);
     }
 
     /**
@@ -97,23 +98,23 @@ public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSO
      * @param errorResponse parsed response if any
      */
     public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
-
+        Log.w(LOG_TAG, "onFailure(int, Header[], Throwable, JSONArray) was not overriden, but callback was received", throwable);
     }
 
     @Override
     public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
-
+        Log.w(LOG_TAG, "onFailure(int, Header[], String, Throwable) was not overriden, but callback was received", throwable);
     }
 
     @Override
     public void onSuccess(int statusCode, Header[] headers, String responseString) {
-
+        Log.w(LOG_TAG, "onSuccess(int, Header[], String) was not overriden, but callback was received");
     }
 
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -142,11 +143,13 @@ public void run() {
                         });
                     }
                 }
-	    };
-	    if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
@@ -155,7 +158,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
         if (responseBytes != null) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -185,11 +188,13 @@ public void run() {
 
                     }
                 }
-	    };
-	    if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
             onFailure(statusCode, headers, throwable, (JSONObject) null);
@@ -208,10 +213,13 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If JSON is not valid this will return null
         String jsonString = getResponseString(responseBody, getCharset());
         if (jsonString != null) {
             jsonString = jsonString.trim();
+            if (jsonString.startsWith(UTF8_BOM)) {
+                jsonString = jsonString.substring(1);
+            }
             if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
                 result = new JSONTokener(jsonString).nextValue();
             }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 6db13641..0df47d47 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -35,16 +35,15 @@
 import java.util.zip.GZIPOutputStream;
 
 /**
- * HTTP entity to upload JSON data using streams.
- * This has very low memory footprint; suitable for uploading large
- * files using base64 encoding.
+ * HTTP entity to upload JSON data using streams. This has very low memory footprint; suitable for
+ * uploading large files using base64 encoding.
  */
-class JsonStreamerEntity implements HttpEntity {
+public class JsonStreamerEntity implements HttpEntity {
 
     private static final String LOG_TAG = "JsonStreamerEntity";
 
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
-        new UnsupportedOperationException("Unsupported operation in this implementation.");
+            new UnsupportedOperationException("Unsupported operation in this implementation.");
 
     // Size of the byte-array buffer used in I/O streams.
     private static final int BUFFER_SIZE = 4096;
@@ -66,12 +65,17 @@
     private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
-        new BasicHeader("Content-Type", "application/json");
+            new BasicHeader(
+                    AsyncHttpClient.HEADER_CONTENT_TYPE,
+                    RequestParams.APPLICATION_JSON);
+
     private static final Header HEADER_GZIP_ENCODING =
-        new BasicHeader("Content-Encoding", "gzip");
+            new BasicHeader(
+                    AsyncHttpClient.HEADER_CONTENT_ENCODING,
+                    AsyncHttpClient.ENCODING_GZIP);
 
     // JSON data and associated meta-data to be uploaded.
-    private final Map<String, Object> jsonParams = new HashMap();
+    private final Map<String, Object> jsonParams = new HashMap<String, Object>();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
@@ -86,7 +90,7 @@ public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useG
     /**
      * Add content parameter, identified by the given key, to the request.
      *
-     * @param key entity's name
+     * @param key   entity's name
      * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
      */
     public void addPart(String key, Object value) {
@@ -144,8 +148,8 @@ public void writeTo(final OutputStream out) throws IOException {
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
         OutputStream os = null != contentEncoding
-          ? new GZIPOutputStream(out, BUFFER_SIZE)
-          : out;
+                ? new GZIPOutputStream(out, BUFFER_SIZE)
+                : out;
 
         // Always send a JSON object.
         os.write('{');
@@ -179,25 +183,31 @@ public void writeTo(final OutputStream out) throws IOException {
 
                 // Determine how to handle this entry.
                 if (isFileWrapper) {
-                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                    writeToFromFile(os, (RequestParams.FileWrapper) value);
                 } else {
-                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
                 }
 
                 // End the file's object and prepare for next one.
                 os.write('}');
+            } else if (value instanceof JsonValueInterface) {
+                os.write(((JsonValueInterface) value).getEscapedJsonValue());
+            } else if (value instanceof org.json.JSONObject) {
+                os.write(((org.json.JSONObject) value).toString().getBytes());
+            } else if (value instanceof org.json.JSONArray) {
+                os.write(((org.json.JSONArray) value).toString().getBytes());
             } else if (value instanceof Boolean) {
-                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                os.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number) value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                os.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number) value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                os.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number) value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                os.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number) value).intValue() + "").getBytes());
             } else {
-                os.write(value.toString().getBytes());
+                os.write(escape(value.toString()));
             }
 
             os.write(',');
@@ -228,7 +238,7 @@ private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entr
 
         // Upload the file's contents in Base64.
         Base64OutputStream bos =
-            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from input stream until no more data's left to read.
         while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
@@ -254,14 +264,14 @@ private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
         // Send the meta data.
         writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
 
-        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+        int bytesRead, bytesWritten = 0, totalSize = (int) wrapper.file.length();
 
         // Open the file for reading.
         FileInputStream in = new FileInputStream(wrapper.file);
 
         // Upload the file's contents in Base64.
         Base64OutputStream bos =
-            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from file until no more data's left to read.
         while ((bytesRead = in.read(buffer)) != -1) {
@@ -301,14 +311,14 @@ private void writeMetaData(OutputStream os, String name, String contentType) thr
 
     private void endMetaData(OutputStream os) throws IOException {
         os.write('"');
-      }
+    }
 
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
     // Changed a bit to suit our needs in this class.
     static byte[] escape(String string) {
         // If it's null, just return prematurely.
         if (string == null) {
-          return JSON_NULL;
+            return JSON_NULL;
         }
 
         // Surround with quotations.
@@ -341,7 +351,7 @@ private void endMetaData(OutputStream os) throws IOException {
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
-                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                    if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
                         BUILDER.append("\\u");
                         int intLength = 4 - intString.length();
diff --git a/library/src/main/java/com/loopj/android/http/JsonValueInterface.java b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
new file mode 100644
index 00000000..110b5c1c
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
@@ -0,0 +1,37 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+/**
+ * This interface is used to encapsulate JSON values that are handled entirely
+ * by the app. For example, apps could manage any type of JSON on their own (and
+ * not rely on {@link org.json.JSONArray} or {@link org.json.JSONObject} to
+ * exchange data.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public interface JsonValueInterface {
+
+    /**
+     * Returns the escaped, ready-to-be used value of this encapsulated object.
+     *
+     * @return byte array holding the data to be used (as-is) in a JSON object
+     */
+    byte[] getEscapedJsonValue();
+}
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
index 5ad3402b..dfc45ec0 100644
--- a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Aymon Fournier <aymon.fournier@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
@@ -18,7 +36,12 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
-// taken from: https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception
+/**
+ * Taken from StackOverflow
+ *
+ * @author Aymon Fournier, aymon.fournier@gmail.com
+ * @see <a href="https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception">https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception</a>
+ */
 class MyRedirectHandler extends DefaultRedirectHandler {
 
     private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
@@ -29,6 +52,7 @@ public MyRedirectHandler(final boolean allowRedirects) {
         this.enableRedirects = allowRedirects;
     }
 
+    @Override
     public boolean isRedirectRequested(
             final HttpResponse response,
             final HttpContext context) {
@@ -50,6 +74,7 @@ public boolean isRedirectRequested(
         } //end of switch
     }
 
+    @Override
     public URI getLocationURI(
             final HttpResponse response,
             final HttpContext context) throws ProtocolException {
@@ -65,7 +90,7 @@ public URI getLocationURI(
                             + " but no location header"
             );
         }
-//HERE IS THE MODIFIED LINE OF CODE
+        //HERE IS THE MODIFIED LINE OF CODE
         String location = locationHeader.getValue().replaceAll(" ", "%20");
 
         URI uri;
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
index 4c4df9ce..4808bcbf 100755
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.HttpVersion;
@@ -44,6 +62,10 @@
      * Creates a new SSL Socket Factory with the given KeyStore.
      *
      * @param truststore A KeyStore to create the SSL Socket Factory in context of
+     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
+     * @throws KeyManagementException    KeyManagementException
+     * @throws KeyStoreException         KeyStoreException
+     * @throws UnrecoverableKeyException UnrecoverableKeyException
      */
     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 2e0fdb8d..e5e99c8c 100755
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -28,6 +28,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.ArrayList;
@@ -60,7 +61,7 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap();
+        cookies = new ConcurrentHashMap<String, Cookie>();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -146,7 +147,7 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList(cookies.values());
+        return new ArrayList<Cookie>(cookies.values());
     }
 
     /**
@@ -165,7 +166,7 @@ public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
      * @param cookie cookie to be removed
      */
     public void deleteCookie(Cookie cookie) {
-        String name = cookie.getName();
+        String name = cookie.getName() + cookie.getDomain();
         cookies.remove(name);
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
         prefsWriter.remove(COOKIE_NAME_PREFIX + name);
@@ -185,7 +186,8 @@ protected String encodeCookie(SerializableCookie cookie) {
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
             outputStream.writeObject(cookie);
-        } catch (Exception e) {
+        } catch (IOException e) {
+            Log.d(LOG_TAG, "IOException in encodeCookie", e);
             return null;
         }
 
@@ -205,8 +207,10 @@ protected Cookie decodeCookie(String cookieString) {
         try {
             ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
             cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
-        } catch (Exception exception) {
-            Log.d(LOG_TAG, "decodeCookie failed", exception);
+        } catch (IOException e) {
+            Log.d(LOG_TAG, "IOException in decodeCookie", e);
+        } catch (ClassNotFoundException e) {
+            Log.d(LOG_TAG, "ClassNotFoundException in decodeCookie", e);
         }
 
         return cookie;
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
index 6f3756cf..3f52da79 100755
--- a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.HttpException;
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
index f6348da4..7abffb1a 100755
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -1,11 +1,30 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
 import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
 import org.apache.http.client.methods.HttpUriRequest;
 
@@ -16,80 +35,77 @@
 
 
 public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
-	private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+    private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
 
-	private long current = 0;
-	private boolean append = false;
+    private long current = 0;
+    private boolean append = false;
 
-	/**
-	 * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
-	 * 
-	 * @param file File to store response within, must not be null
-	 */
-	public RangeFileAsyncHttpResponseHandler(File file) {
-		super(file);
-	}
+    /**
+     * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public RangeFileAsyncHttpResponseHandler(File file) {
+        super(file);
+    }
 
-	@Override
-	public void sendResponseMessage(HttpResponse response) throws IOException {
-		if (!Thread.currentThread().isInterrupted()) {
-			StatusLine status = response.getStatusLine();
-			if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE){
-				//already finished
-				if (!Thread.currentThread().isInterrupted())
-					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
-			}
-			else if (status.getStatusCode() >= 300) {
-				if (!Thread.currentThread().isInterrupted())
-					sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
-			}
-			else {
-				if (!Thread.currentThread().isInterrupted()) {
-					Header header = response.getFirstHeader("Content-Range");
-					if (header == null) {
-						append = false;
-						current = 0;
-					}
-					else
-						Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
-					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
-				}
-			}
-		}
-	}
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
+                //already finished
+                if (!Thread.currentThread().isInterrupted())
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+            } else if (status.getStatusCode() >= 300) {
+                if (!Thread.currentThread().isInterrupted())
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+            } else {
+                if (!Thread.currentThread().isInterrupted()) {
+                    Header header = response.getFirstHeader(AsyncHttpClient.HEADER_CONTENT_RANGE);
+                    if (header == null) {
+                        append = false;
+                        current = 0;
+                    } else {
+                        Log.v(LOG_TAG, AsyncHttpClient.HEADER_CONTENT_RANGE + ": " + header.getValue());
+                    }
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+                }
+            }
+        }
+    }
 
-	@Override
-	protected byte[] getResponseData(HttpEntity entity) throws IOException {
-		if (entity != null) {
-			InputStream instream = entity.getContent();
-			long contentLength = entity.getContentLength() + current;
-			FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
-			if (instream != null) {
-				try {
-					byte[] tmp = new byte[BUFFER_SIZE];
-					int l;
-					while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted())
-					{
-						current += l;
-						buffer.write(tmp, 0, l);
-						sendProgressMessage((int)current, (int)contentLength);
-					}
-				} finally {
-					instream.close();
-					buffer.flush();
-					buffer.close();
-				}
-			}
-		}
-		return null;
-	}
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength() + current;
+            FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l;
+                    while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        current += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage((int) current, (int) contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
 
-	public void updateRequestHeaders(HttpUriRequest uriRequest) {
-		if (mFile.exists() && mFile.canWrite())
-			current = mFile.length();
-		if (current > 0) {
-			append = true;
-			uriRequest.setHeader("Range", "bytes=" + current + "-");
-		}
-	}
+    public void updateRequestHeaders(HttpUriRequest uriRequest) {
+        if (mFile.exists() && mFile.canWrite())
+            current = mFile.length();
+        if (current > 0) {
+            append = true;
+            uriRequest.setHeader("Range", "bytes=" + current + "-");
+        }
+    }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index a35aa634..290422a9 100755
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Jason Choy <jjwchoy@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import java.lang.ref.WeakReference;
@@ -9,7 +27,7 @@
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference(request);
+        this.request = new WeakReference<AsyncHttpRequest>(request);
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index a6fdab8d..195a8184 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -64,7 +64,7 @@
  * params.put("like", set); // url params: "like=music&amp;like=art"
  *
  * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
- * list.add("Java");<>
+ * list.add("Java");
  * list.add("C");
  * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
  *
@@ -90,16 +90,19 @@
 public class RequestParams {
 
     public final static String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
+            "application/octet-stream";
+
+    public final static String APPLICATION_JSON =
+            "application/json";
 
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
     protected boolean autoCloseInputStreams;
-    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -109,10 +112,11 @@
      * @param encoding String constant from {@link org.apache.http.protocol.HTTP}
      */
     public void setContentEncoding(final String encoding) {
-        if (encoding != null)
+        if (encoding != null) {
             this.contentEncoding = encoding;
-        else
+        } else {
             Log.d(LOG_TAG, "setContentEncoding called with null attribute");
+        }
     }
 
     /**
@@ -307,9 +311,9 @@ public void add(String key, String value) {
                 this.put(key, params);
             }
             if (params instanceof List) {
-                ((List) params).add(value);
+                ((List<Object>) params).add(value);
             } else if (params instanceof Set) {
-                ((Set) params).add(value);
+                ((Set<Object>) params).add(value);
             }
         }
     }
@@ -326,6 +330,19 @@ public void remove(String key) {
         urlParamsWithObjects.remove(key);
     }
 
+    /**
+     * Check if a parameter is defined.
+     *
+     * @param key the key name for the parameter to check existence.
+     * @return Boolean
+     */
+    public boolean has(String key) {
+        return urlParams.get(key) != null ||
+                streamParams.get(key) != null ||
+                fileParams.get(key) != null ||
+                urlParamsWithObjects.get(key) != null;
+    }
+
     @Override
     public String toString() {
         StringBuilder result = new StringBuilder();
@@ -378,8 +395,8 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Set global flag which determines whether to automatically close input
-     * streams on successful upload.
+     * Set global flag which determines whether to automatically close input streams on successful
+     * upload.
      *
      * @param flag boolean whether to automatically close input streams
      */
@@ -407,7 +424,7 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
 
     private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
         JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
-            !fileParams.isEmpty() || !streamParams.isEmpty());
+                !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -429,11 +446,12 @@ private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHan
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
-                    StreamWrapper.newInstance(
-                        stream.inputStream,
-                        stream.name,
-                        stream.contentType,
-                        stream.autoClose));
+                        StreamWrapper.newInstance(
+                                stream.inputStream,
+                                stream.name,
+                                stream.contentType,
+                                stream.autoClose)
+                );
             }
         }
 
@@ -455,13 +473,13 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
+            entity.addPartWithCharset(entry.getKey(), entry.getValue(), contentEncoding);
         }
 
         // Add non-string params
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
-            entity.addPart(kv.getName(), kv.getValue());
+            entity.addPartWithCharset(kv.getName(), kv.getValue(), contentEncoding);
         }
 
         // Add stream params
@@ -483,7 +501,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList();
+        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -495,12 +513,14 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList();
+        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
         if (value instanceof Map) {
             Map map = (Map) value;
             List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
-            Collections.sort(list);
+            if (list.size() > 0 && list.get(0) instanceof Comparable) {
+                Collections.sort(list);
+            }
             for (Object nestedKey : list) {
                 if (nestedKey instanceof String) {
                     Object nestedValue = map.get(nestedKey);
@@ -562,10 +582,10 @@ public StreamWrapper(InputStream inputStream, String name, String contentType, b
 
         static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
             return new StreamWrapper(
-                inputStream,
-                name,
-                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
-                autoClose);
+                    inputStream,
+                    name,
+                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                    autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index fe5eacc0..193f44fe 100755
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
@@ -109,4 +127,32 @@
      * @return boolean if the ResponseHandler is running in synchronous mode
      */
     boolean getUseSynchronousMode();
+
+    /**
+     * This method is called once by the system when the response is about to be
+     * processed by the system. The library makes sure that a single response
+     * is pre-processed only once.
+     *
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to pre-processed
+     */
+    void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single response
+     * is post-processed only once.
+     *
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to post-process
+     */
+    void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
 }
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index a6968667..3b6ad196 100755
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
-    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..f4663b7b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
@@ -0,0 +1,149 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+/**
+ * Provides interface to deserialize SAX responses, using AsyncHttpResponseHandler. Can be used like
+ * this
+ *
+ * <pre>
+ *     AsyncHttpClient ahc = new AsyncHttpClient();
+ *     FontHandler handlerInstance = ... ; // init handler instance
+ *     ahc.post("https://server.tld/api/call", new SaxAsyncHttpResponseHandler<FontHandler>(handlerInstance){
+ *         &#064;Override
+ *         public void onSuccess(int statusCode, Header[] headers, FontHandler t) {
+ *              // Request got HTTP success statusCode
+ *         }
+ *         &#064;Override
+ *         public void onFailure(int statusCode, Header[] headers, FontHandler t){
+ *              // Request got HTTP fail statusCode
+ *         }
+ *     });
+ * <pre/>
+ *
+ * @param <T> Handler extending {@link org.xml.sax.helpers.DefaultHandler}
+ * @see org.xml.sax.helpers.DefaultHandler
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ */
+public abstract class SaxAsyncHttpResponseHandler<T extends DefaultHandler> extends AsyncHttpResponseHandler {
+
+    /**
+     * Generic Type of handler
+     */
+    private T handler = null;
+    private final static String LOG_TAG = "SaxAsyncHttpResponseHandler";
+
+    /**
+     * Constructs new SaxAsyncHttpResponseHandler with given handler instance
+     *
+     * @param t instance of Handler extending DefaultHandler
+     * @see org.xml.sax.helpers.DefaultHandler
+     */
+    public SaxAsyncHttpResponseHandler(T t) {
+        super();
+        if (t == null) {
+            throw new Error("null instance of <T extends DefaultHandler> passed to constructor");
+        }
+        this.handler = t;
+    }
+
+    /**
+     * Deconstructs response into given content handler
+     *
+     * @param entity returned HttpEntity
+     * @return deconstructed response
+     * @throws java.io.IOException
+     * @see org.apache.http.HttpEntity
+     */
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            InputStreamReader inputStreamReader = null;
+            if (instream != null) {
+                try {
+                    SAXParserFactory sfactory = SAXParserFactory.newInstance();
+                    SAXParser sparser = sfactory.newSAXParser();
+                    XMLReader rssReader = sparser.getXMLReader();
+                    rssReader.setContentHandler(handler);
+                    inputStreamReader = new InputStreamReader(instream, DEFAULT_CHARSET);
+                    rssReader.parse(new InputSource(inputStreamReader));
+                } catch (SAXException e) {
+                    Log.e(LOG_TAG, "getResponseData exception", e);
+                } catch (ParserConfigurationException e) {
+                    Log.e(LOG_TAG, "getResponseData exception", e);
+                } finally {
+                    AsyncHttpClient.silentCloseInputStream(instream);
+                    if (inputStreamReader != null) {
+                        try {
+                            inputStreamReader.close();
+                        } catch (IOException e) { /*ignore*/ }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Default onSuccess method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, headers, handler);
+    }
+
+    /**
+     * Default onFailure method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers,
+                          byte[] responseBody, Throwable error) {
+        onSuccess(statusCode, headers, handler);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index bffdf740..9bbc3e01 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -28,6 +28,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -49,17 +50,17 @@
     private static final String STR_CR_LF = "\r\n";
     private static final byte[] CR_LF = STR_CR_LF.getBytes();
     private static final byte[] TRANSFER_ENCODING_BINARY =
-        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
+            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
     private final static char[] MULTIPART_CHARS =
-        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
     private final String boundary;
     private final byte[] boundaryLine;
     private final byte[] boundaryEnd;
     private boolean isRepeatable;
 
-    private final List<FilePart> fileParts = new ArrayList();
+    private final List<FilePart> fileParts = new ArrayList<FilePart>();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
@@ -99,8 +100,13 @@ public void addPart(String key, String value, String contentType) {
         }
     }
 
+    public void addPartWithCharset(String key, String value, String charset) {
+        if (charset == null) charset = HTTP.UTF_8;
+        addPart(key, value, "text/plain; charset=" + charset);
+    }
+
     public void addPart(String key, String value) {
-        addPart(key, value, "text/plain; charset=UTF-8");
+        addPartWithCharset(key, value, null);
     }
 
     public void addPart(String key, File file) {
@@ -136,22 +142,25 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
     }
 
     private String normalizeContentType(String type) {
-       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
+        return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
+        String result = AsyncHttpClient.HEADER_CONTENT_TYPE + ": " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
     private byte[] createContentDisposition(String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
-            .getBytes();
+        return (
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
     }
 
     private byte[] createContentDisposition(String key, String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
-            .getBytes();
+        return (
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" +
+                        "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
     }
 
     private void updateProgress(int count) {
@@ -226,7 +235,9 @@ public long getContentLength() {
 
     @Override
     public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+        return new BasicHeader(
+                AsyncHttpClient.HEADER_CONTENT_TYPE,
+                "multipart/form-data; boundary=" + boundary);
     }
 
     @Override
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index ac5ca66d..9626a71c 100755
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -1,3 +1,20 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -67,7 +84,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
                                         String contentType, ResponseHandlerInterface responseHandler,
                                         Context context) {
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            uriRequest.addHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, contentType);
         }
 
         responseHandler.setUseSynchronousMode(true);
@@ -75,7 +92,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
 		/*
          * will execute the request directly
 		*/
-        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+        newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context).run();
 
         // Return a Request Handle that cannot be used to cancel the request
         // because it is already complete by the time this returns
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
index b96a263a..71f49459 100755
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.util.Log;
@@ -38,6 +56,7 @@
  * </pre>
  */
 public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+
     private static final String LOG_TAG = "TextHttpResponseHandler";
 
     /**
@@ -95,11 +114,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Th
      */
     public static String getResponseString(byte[] stringBytes, String charset) {
         try {
-            return stringBytes == null ? null : new String(stringBytes, charset);
+            String toReturn = (stringBytes == null) ? null : new String(stringBytes, charset);
+            if (toReturn != null && toReturn.startsWith(UTF8_BOM)) {
+                return toReturn.substring(1);
+            }
+            return toReturn;
         } catch (UnsupportedEncodingException e) {
             Log.e(LOG_TAG, "Encoding response into string failed", e);
             return null;
         }
     }
-
 }
diff --git a/library/src/main/java/com/loopj/android/http/package-info.java b/library/src/main/java/com/loopj/android/http/package-info.java
new file mode 100644
index 00000000..40174b19
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
\ No newline at end of file
diff --git a/maven_push.gradle b/maven_push.gradle
index 6fc6fb30..27fff0d8 100755
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -1,33 +1,42 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 apply plugin: 'maven'
 apply plugin: 'signing'
 
-configurations {
-    archives {
-        extendsFrom configurations.default
-    }
+def isReleaseBuild() {
+    return VERSION_NAME.contains("SNAPSHOT") == false
 }
 
-def sonatypeRepositoryUrl
-if (isReleaseBuild()) {
-    println 'RELEASE BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-} else {
-    println 'DEBUG BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+def getReleaseRepositoryUrl() {
+    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
 }
 
-if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
-    if (System.console())
-        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
-    else
-        ext.set('signing.password', 'dummy')
+def getSnapshotRepositoryUrl() {
+    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : "https://oss.sonatype.org/content/repositories/snapshots/"
 }
 
-if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
-    if (System.console())
-        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
-    else
-    	ext.set('nexusPassword', 'dummy')
+def getRepositoryUsername() {
+    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+}
+
+def getRepositoryPassword() {
+    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -36,10 +45,15 @@ afterEvaluate { project ->
             mavenDeployer {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
+                pom.groupId = GROUP
                 pom.artifactId = POM_ARTIFACT_ID
+                pom.version = VERSION_NAME
 
-                repository(url: sonatypeRepositoryUrl) {
-                    authentication(userName: nexusUsername, password: nexusPassword)
+                repository(url: getReleaseRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+                snapshotRepository(url: getSnapshotRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
                 pom.project {
@@ -64,12 +78,8 @@ afterEvaluate { project ->
 
                     developers {
                         developer {
-                            id "loopj"
-                            name "James Smith"
-                        }
-                        developer {
-                            id "smarek"
-                            name "Marek Sebera"
+                            id POM_DEVELOPER_ID
+                            name POM_DEVELOPER_NAME
                         }
                     }
                 }
@@ -82,18 +92,22 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidJavadocsJar(type: Jar, dependsOn: generateReleaseJavadoc) {
+    task androidJavadocs(type: Javadoc) {
+        source = android.sourceSets.main.java.srcDirs
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
-        from generateReleaseJavadoc.destinationDir
+        from androidJavadocs.destinationDir
     }
 
     task androidSourcesJar(type: Jar) {
         classifier = 'sources'
-        from android.sourceSets.main.allSource
+        from android.sourceSets.main.java.srcDirs
     }
 
     artifacts {
-        archives androidReleaseJar
         archives androidSourcesJar
         archives androidJavadocsJar
     }
diff --git a/releases/android-async-http-1.4.5.jar b/releases/android-async-http-1.4.5.jar
new file mode 100755
index 00000000..d383f60e
Binary files /dev/null and b/releases/android-async-http-1.4.5.jar differ
diff --git a/sample/build.gradle b/sample/build.gradle
index b4fdad60..3f4166a7 100755
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,10 +3,10 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.+'
+        classpath 'com.android.tools.build:gradle:0.12.2'
     }
 }
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 repositories {
     mavenCentral()
@@ -17,7 +17,7 @@ repositories {
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.3'
+    buildToolsVersion '19.1'
 
     defaultConfig {
         minSdkVersion 3
@@ -30,7 +30,11 @@ android {
     }
 
     lintOptions {
-        abortOnError false
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
+	disable 'OldTargetApi'
     }
 
     packagingOptions {
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index b1cac259..f3380bad 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.loopj.android.http.sample"
           android:versionCode="1"
@@ -21,6 +22,7 @@
         <activity android:name=".DeleteSample"/>
         <activity android:name=".PutSample"/>
         <activity android:name=".JsonSample"/>
+        <activity android:name=".JsonStreamerSample"/>
         <activity android:name=".FileSample"/>
         <activity android:name=".BinarySample"/>
         <activity android:name=".GzipSample"/>
@@ -29,6 +31,17 @@
         <activity android:name=".CancelAllRequestsSample"/>
         <activity android:name=".CancelRequestHandleSample"/>
         <activity android:name=".SynchronousClientSample"/>
+        <activity android:name=".IntentServiceSample"/>
+        <activity android:name=".SaxSample"/>
+        <activity android:name=".FilesSample"/>
+        <activity android:name=".PersistentCookiesSample"/>
+        <activity android:name=".CustomCASample"/>
+        <activity android:name=".RetryRequestSample"/>
+        <activity android:name=".RangeResponseSample"/>
+        <activity android:name=".Http401AuthSample"/>
+        <activity android:name=".AsyncBackgroundThreadSample"/>
+
+        <service android:name=".services.ExampleIntentService"/>
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
new file mode 100755
index 00000000..eb3b7a2b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
@@ -0,0 +1,153 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.os.Looper;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+
+public class AsyncBackgroundThreadSample extends SampleParentActivity {
+    private static final String LOG_TAG = "AsyncBackgroundThreadSample";
+
+    private ExecutorService executor = Executors.newSingleThreadExecutor();
+
+    @Override
+    public void onStop()
+    {
+        super.onStop();
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+
+        final Activity ctx = this;
+        FutureTask<RequestHandle> future = new FutureTask<>(new Callable<RequestHandle>() {
+            public RequestHandle call() {
+                Log.d(LOG_TAG, "Executing GET request on background thread");
+                return client.get(ctx, URL, headers, null, responseHandler);
+            }
+        });
+
+        executor.execute(future);
+
+        RequestHandle handle = null;
+        try {
+            handle = future.get(5, TimeUnit.SECONDS);
+            Log.d(LOG_TAG, "Background thread for GET request has finished");
+        } catch (Exception e) {
+            Toast.makeText(ctx, e.getMessage(), Toast.LENGTH_LONG).show();
+            e.printStackTrace();
+        }
+
+        return handle;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_async_background_thread;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+
+        FutureTask<ResponseHandlerInterface> future = new FutureTask<>(new Callable<ResponseHandlerInterface>() {
+
+            @Override
+            public ResponseHandlerInterface call() throws Exception {
+                Log.d(LOG_TAG, "Creating AsyncHttpResponseHandler on background thread");
+                return new AsyncHttpResponseHandler(Looper.getMainLooper()) {
+
+                    @Override
+                    public void onStart() {
+                        clearOutputs();
+                    }
+
+                    @Override
+                    public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                        Log.d(LOG_TAG, String.format("onSuccess executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+
+                    @Override
+                    public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                        Log.d(LOG_TAG, String.format("onFailure executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+
+                    @Override
+                    public void onRetry(int retryNo) {
+                        Toast.makeText(AsyncBackgroundThreadSample.this,
+                                String.format("Request is retried, retry no. %d", retryNo),
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                };
+            }
+        });
+
+        executor.execute(future);
+
+        ResponseHandlerInterface responseHandler = null;
+        try {
+            responseHandler = future.get();
+            Log.d(LOG_TAG, "Background thread for AsyncHttpResponseHandler has finished");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return responseHandler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
index a01942fd..94417798 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
index fa8df74b..84d23b5f 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 public class CancelAllRequestsSample extends ThreadingTimeoutSample {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
index fd66c3a0..7db7ba72 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
new file mode 100644
index 00000000..621c7f8c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
@@ -0,0 +1,202 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.util.Log;
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+import com.loopj.android.http.sample.util.SecureSocketFactory;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+
+/**
+ * This sample demonstrates the implementation of self-signed CA's and connection to servers with
+ * such certificates. Be sure to read 'res/raw/custom_ca.txt' for how-to instructions on how to
+ * generate a BKS file necessary for this sample.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class CustomCASample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "CustomCASample";
+
+    // This is A TEST URL for use with AsyncHttpClient LIBRARY ONLY!
+    // It is provided courtesy of Fineswap (http://fineswap.com) and must never
+    // be used in ANY program except when running this sample (CustomCASample).
+    private static final String SERVER_TEST_URL = "https://api.fineswap.io/ahc";
+
+    // The certificate's alias.
+    private static final String STORE_ALIAS = "rootca";
+
+    // The certificate's password.
+    private static final String STORE_PASS = "Fineswap";
+
+    // Instruct the library to retry connection when this exception is raised.
+    static {
+        AsyncHttpClient.allowRetryExceptionClass(javax.net.ssl.SSLException.class);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            InputStream is = null;
+            try {
+                // Configure the library to use a custom 'bks' file to perform
+                // SSL negotiation.
+                KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());
+                is = getResources().openRawResource(R.raw.store);
+                store.load(is, STORE_PASS.toCharArray());
+                getAsyncHttpClient().setSSLSocketFactory(new SecureSocketFactory(store, STORE_ALIAS));
+            } catch (IOException e) {
+                throw new KeyStoreException(e);
+            } catch (CertificateException e) {
+                throw new KeyStoreException(e);
+            } catch (NoSuchAlgorithmException e) {
+                throw new KeyStoreException(e);
+            } catch (KeyManagementException e) {
+                throw new KeyStoreException(e);
+            } catch (UnrecoverableKeyException e) {
+                throw new KeyStoreException(e);
+            } finally {
+                AsyncHttpClient.silentCloseInputStream(is);
+            }
+        } catch (KeyStoreException e) {
+            Log.e(LOG_TAG, "Unable to initialize key store", e);
+            showCustomCAHelp();
+        }
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_custom_ca;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return SERVER_TEST_URL;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    /**
+     * Returns contents of `custom_ca.txt` file from assets as CharSequence.
+     *
+     * @return contents of custom_ca.txt file
+     */
+    private CharSequence getReadmeText() {
+        String rtn = "";
+        try {
+            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
+            java.util.Scanner s = new java.util.Scanner(stream)
+                    .useDelimiter("\\A");
+            rtn = s.hasNext() ? s.next() : "";
+        } catch (Resources.NotFoundException e) {
+            Log.e(LOG_TAG, "License couldn't be retrieved", e);
+        }
+        return rtn;
+    }
+
+    /**
+     * Displays a dialog showing contents of `custom_ca.txt` file from assets.
+     * This is needed to avoid Lint's strict mode.
+     */
+    private void showCustomCAHelp() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.title_custom_ca);
+        builder.setMessage(getReadmeText());
+        builder.setNeutralButton(android.R.string.cancel,
+            new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    dialog.dismiss();
+                }
+            }
+        );
+        builder.show();
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
index bea35ca4..0eea3740 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
index c554cc4d..4d774e60 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
new file mode 100644
index 00000000..e56a1ed9
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
@@ -0,0 +1,65 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.util.Random;
+
+public class FilesSample extends PostSample {
+
+    public static final String LOG_TAG = "PostFilesSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_post_files;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        try {
+            RequestParams params = new RequestParams();
+            final String contentType = RequestParams.APPLICATION_OCTET_STREAM;
+            params.put("fileOne", createTempFile("fileOne", 1020), contentType);
+            params.put("fileTwo", createTempFile("fileTwo", 1030), contentType);
+            params.put("fileThree", createTempFile("fileThree", 1040), contentType);
+            params.put("fileFour", createTempFile("fileFour", 1050), contentType);
+            params.put("fileFive", createTempFile("fileFive", 1060), contentType);
+            return client.post(this, URL, params, responseHandler);
+        } catch (FileNotFoundException fnfException) {
+            Log.e(LOG_TAG, "executeSample failed with FileNotFoundException", fnfException);
+        }
+        return null;
+    }
+
+    public File createTempFile(String namePart, int byteSize) {
+        try {
+            File f = File.createTempFile(namePart, "_handled", getCacheDir());
+            FileOutputStream fos = new FileOutputStream(f);
+            Random r = new Random();
+            byte[] buffer = new byte[byteSize];
+            r.nextBytes(buffer);
+            fos.write(buffer);
+            fos.flush();
+            fos.close();
+            return f;
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "createTempFile failed", t);
+        }
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
index 5464cc6c..ac11151a 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.widget.Toast;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
index ba242939..2664b6f0 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 public class GzipSample extends JsonSample {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java b/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java
new file mode 100644
index 00000000..1e89b65d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java
@@ -0,0 +1,228 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.Base64;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * This sample demonstrates how to implement HTTP 401 Basic Authentication.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class Http401AuthSample extends GetSample {
+
+    private static final String LOG_TAG = "Http401Auth";
+    private static final String HEADER_WWW_AUTHENTICATE = "WWW-Authenticate";
+    private static final String HEADER_AUTHORIZATION = "Authorization";
+    private static final String HEADER_REALM_PREFIX = "realm=";
+    private static final String HEADER_BASIC = "basic";
+
+    private static final String SECRET_USERNAME = "ahc";
+    private static final String SECRET_PASSWORD = "LetMeIn";
+
+    private String userName;
+    private String passWord;
+
+    public void retryRequest() {
+        // File is still smaller than remote file; send a new request.
+        onRunButtonPressed();
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/basic-auth/" + SECRET_USERNAME + "/" + SECRET_PASSWORD;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_401_unauth;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
+
+        // Add authentication header.
+        if (userName != null && passWord != null) {
+            byte[] base64bytes = Base64.encode(
+                    (userName + ":" + passWord).getBytes(),
+                    Base64.DEFAULT
+            );
+            String credentials = new String(base64bytes);
+            headers.add(new BasicHeader(HEADER_AUTHORIZATION, HEADER_BASIC + " " + credentials));
+        }
+
+        return headers.toArray(new Header[headers.size()]);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+
+                // Ask the user for credentials if required by the server.
+                if (statusCode == 401) {
+                    String realm = "Protected Page";
+                    String authType = null;
+
+                    // Cycle through the headers and look for the WWW-Authenticate header.
+                    for (Header header : headers) {
+                        String headerName = header.getName();
+                        if (HEADER_WWW_AUTHENTICATE.equalsIgnoreCase(headerName)) {
+                            String headerValue = header.getValue().trim();
+                            String headerValueLowerCase = headerValue.toLowerCase(Locale.US);
+
+                            // Get the type of auth requested.
+                            int charPos = headerValueLowerCase.indexOf(' ');
+                            if (0 < charPos) {
+                                authType = headerValueLowerCase.substring(0, charPos);
+
+                                // The second part should begin with a "realm=" prefix.
+                                if (headerValueLowerCase.substring(1 + charPos).startsWith(HEADER_REALM_PREFIX)) {
+                                    // The new realm value, including any possible wrapping quotation.
+                                    realm = headerValue.substring(1 + charPos + HEADER_REALM_PREFIX.length());
+
+                                    // If realm starts with a quote, remove surrounding quotes.
+                                    if (realm.charAt(0) == '"' || realm.charAt(0) == '\'') {
+                                        realm = realm.substring(1, realm.length() - 1);
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    // We will support basic auth in this sample.
+                    if (authType != null && HEADER_BASIC.equals(authType)) {
+                        // Show a dialog for the user and request user/pass.
+                        Log.d(LOG_TAG, HEADER_REALM_PREFIX + realm);
+
+                        // Present the dialog.
+                        postRunnable(new DialogRunnable(realm));
+                    }
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    private class DialogRunnable implements Runnable, DialogInterface.OnClickListener {
+
+        final String realm;
+        final View dialogView;
+
+        public DialogRunnable(String realm) {
+            this.realm = realm;
+            this.dialogView = LayoutInflater
+                    .from(Http401AuthSample.this)
+                    .inflate(R.layout.credentials, new LinearLayout(Http401AuthSample.this), false);
+
+            // Update the preface text with correct credentials.
+            TextView preface = (TextView) dialogView.findViewById(R.id.label_credentials);
+            String prefaceText = preface.getText().toString();
+
+            // Substitute placeholders, and re-set the value.
+            preface.setText(String.format(prefaceText, SECRET_USERNAME, SECRET_PASSWORD));
+        }
+
+        @Override
+        public void run() {
+            AlertDialog.Builder builder = new AlertDialog.Builder(Http401AuthSample.this);
+            builder.setTitle(realm);
+            builder.setView(dialogView);
+            builder.setPositiveButton(android.R.string.ok, this);
+            builder.setNegativeButton(android.R.string.cancel, this);
+            builder.show();
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            switch (which) {
+                case DialogInterface.BUTTON_POSITIVE:
+                    // Dismiss the dialog.
+                    dialog.dismiss();
+
+                    // Update the username and password variables.
+                    userName = ((EditText) dialogView.findViewById(R.id.field_username)).getText().toString();
+                    passWord = ((EditText) dialogView.findViewById(R.id.field_password)).getText().toString();
+
+                    // Refetch the remote file.
+                    retryRequest();
+
+                    break;
+
+                case DialogInterface.BUTTON_NEGATIVE:
+                    // Dismiss the dialog.
+                    dialog.dismiss();
+
+                    break;
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
new file mode 100644
index 00000000..7b7dde62
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
@@ -0,0 +1,106 @@
+package com.loopj.android.http.sample;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.services.ExampleIntentService;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class IntentServiceSample extends SampleParentActivity {
+
+    public static final String LOG_TAG = "IntentServiceSample";
+    public static final String ACTION_START = "SYNC_START";
+    public static final String ACTION_RETRY = "SYNC_RETRY";
+    public static final String ACTION_CANCEL = "SYNC_CANCEL";
+    public static final String ACTION_SUCCESS = "SYNC_SUCCESS";
+    public static final String ACTION_FAILURE = "SYNC_FAILURE";
+    public static final String ACTION_FINISH = "SYNC_FINISH";
+    public static final String[] ALLOWED_ACTIONS = {ACTION_START,
+            ACTION_RETRY, ACTION_CANCEL, ACTION_SUCCESS, ACTION_FAILURE, ACTION_FINISH};
+    private final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            // switch() doesn't support strings in older JDK.
+            if(ACTION_START.equals(action)) {
+                clearOutputs();
+                addView(getColoredView(LIGHTBLUE, "Request started"));
+            } else if(ACTION_FINISH.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request finished"));
+            } else if(ACTION_CANCEL.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request cancelled"));
+            } else if(ACTION_RETRY.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request retried"));
+            } else if(ACTION_FAILURE.equals(action) || ACTION_SUCCESS.equals(action)) {
+                debugThrowable(LOG_TAG, (Throwable) intent.getSerializableExtra(ExampleIntentService.INTENT_THROWABLE));
+                if(ACTION_SUCCESS.equals(action)) {
+                    debugStatusCode(LOG_TAG, intent.getIntExtra(ExampleIntentService.INTENT_STATUS_CODE, 0));
+                    debugHeaders(LOG_TAG, IntentUtil.deserializeHeaders(intent.getStringArrayExtra(ExampleIntentService.INTENT_HEADERS)));
+                    byte[] returnedBytes = intent.getByteArrayExtra(ExampleIntentService.INTENT_DATA);
+                    if (returnedBytes != null) {
+                        debugResponse(LOG_TAG, new String(returnedBytes));
+                    }
+                }
+            }
+        }
+    };
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        IntentFilter iFilter = new IntentFilter();
+        for (String action : ALLOWED_ACTIONS) {
+            iFilter.addAction(action);
+        }
+        registerReceiver(broadcastReceiver, iFilter);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        unregisterReceiver(broadcastReceiver);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        // no response handler on activity
+        return null;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_intent_service_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        Intent serviceCall = new Intent(this, ExampleIntentService.class);
+        serviceCall.putExtra(ExampleIntentService.INTENT_URL, URL);
+        startService(serviceCall);
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
index cde4e06f..4fcc07e0 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.fasterxml.jackson.core.JsonFactory;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java
new file mode 100644
index 00000000..e9ac0b70
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java
@@ -0,0 +1,97 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.util.Iterator;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * This sample demonstrates how to upload JSON data using streams, resulting
+ * in a low-memory footprint even with extremely large data.
+ *
+ * Please note: You must prepare a server-side end-point to consume the uploaded
+ * data. This is because the data is uploaded using "application/json" content
+ * type and regular methods, expecting a multi-form content type, will fail to
+ * retrieve the POST'ed data.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class JsonStreamerSample extends PostSample {
+
+    private static final String LOG_TAG = "JsonStreamSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        RequestParams params = new RequestParams();
+        params.setUseJsonStreamer(true);
+        JSONObject body;
+        if (isRequestBodyAllowed() && (body = getBodyTextAsJSON()) != null) {
+            try {
+                Iterator<String> keys = body.keys();
+                Log.d(LOG_TAG, "JSON data:");
+                while (keys.hasNext()) {
+                    String key = keys.next();
+                    Log.d(LOG_TAG, "  " + key + ": " + body.get(key));
+                    params.put(key, body.get(key).toString());
+                }
+            } catch (JSONException e) {
+                Log.w(LOG_TAG, "Unable to retrieve a JSON value", e);
+            }
+        }
+        return client.post(this, URL, headers, params,
+            RequestParams.APPLICATION_JSON, responseHandler);
+    }
+
+    @Override
+    public HttpEntity getRequestEntity() {
+        // Unused in this sample.
+        return null;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_json_streamer_sample;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    protected JSONObject getBodyTextAsJSON() {
+        String bodyText = getBodyText();
+        if (bodyText != null) {
+            try {
+                return new JSONObject(bodyText);
+            } catch(JSONException e) {
+                Log.e(LOG_TAG, "User's data is not a valid JSON object", e);
+            }
+        }
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
new file mode 100644
index 00000000..b30bb8b0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
@@ -0,0 +1,122 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.PersistentCookieStore;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.CookieStore;
+
+public class PersistentCookiesSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PersistentCookiesSample";
+
+    private CookieStore cookieStore;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        // Use the application's context so that memory leakage doesn't occur.
+        cookieStore = new PersistentCookieStore(getApplicationContext());
+
+        // Set the new cookie store.
+        getAsyncHttpClient().setCookieStore(cookieStore);
+
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_persistent_cookies;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        // The base URL for testing cookies.
+        String url = "http://httpbin.org/cookies";
+
+        // If the cookie store is empty, suggest a cookie.
+        if(cookieStore.getCookies().isEmpty()) {
+            url += "/set?time=" + System.currentTimeMillis();
+        }
+
+        return url;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        client.setEnableRedirects(true);
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
index 2e183d9b..311b4216 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
new file mode 100644
index 00000000..bae03e9b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
@@ -0,0 +1,145 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.util.Log;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.util.Locale;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public class PrePostProcessingSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PrePostProcessingSample";
+
+    protected static final int LIGHTGREY = Color.parseColor("#E0E0E0");
+    protected static final int DARKGREY = Color.parseColor("#888888");
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_pre_post_processing;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/post";
+    }
+
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new PrePostProcessRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Pre",
+                    "Response is about to be pre-processed", LIGHTGREY);
+            }
+
+          @Override
+            public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Post",
+                    "Response is about to be post-processed", DARKGREY);
+            }
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+
+    protected void debugProcessing(String TAG, String state, String message, final int color) {
+        final String debugMessage = String.format(Locale.US, "%s-processing: %s", state, message);
+        Log.d(TAG, debugMessage);
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+              addView(getColoredView(color, debugMessage));
+            }
+        });
+    }
+
+    private class PrePostProcessRequest extends AsyncHttpRequest {
+
+        public PrePostProcessRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
+            super(client, context, request, responseHandler);
+        }
+
+        @Override
+        public void onPreProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Pre",
+                "Request is about to be pre-processed", LIGHTGREY);
+        }
+
+        @Override
+        public void onPostProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Post",
+                "Request is about to be post-processed", DARKGREY);
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
index d32b5767..56260150 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
new file mode 100644
index 00000000..3daf055c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
@@ -0,0 +1,176 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.io.File;
+import java.io.IOException;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.methods.HttpUriRequest;
+
+/**
+ * This sample demonstrates use of {@link RangeFileAsyncHttpResponseHandler} to
+ * download a remote file in multiple requests. While this response handler
+ * class handles file storage, it's up to the app itself to request all chunks
+ * of the file.
+ *
+ * Also demonstrated a method to query the remote file's size prior to sending
+ * the actual GET requests. This ensures that the remote server is actually
+ * capable of supporting the "Range" header, necessary to make this sample work.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RangeResponseSample extends GetSample {
+
+    public static final String LOG_TAG = "RangeResponseSample";
+
+    private static final String CONTENT_LENGTH = "Content-Length";
+    private static final String ACCEPT_RANGES = "Accept-Ranges";
+    private static final int CHUNK_SIZE = 10240;
+
+    private File file;
+    private long fileSize = -1;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            // Temporary file to host the URL's downloaded contents.
+            file = File.createTempFile("temp_", "_handled", getCacheDir());
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot create temporary file", e);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+
+        // Remove temporary file.
+        if (file != null) {
+            file.delete();
+            file = null;
+        }
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://upload.wikimedia.org/wikipedia/commons/f/fa/Geysers_on_Mars.jpg";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_range_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        if (fileSize > 0) {
+            // Send a GET query when we know the size of the remote file.
+            return client.get(this, URL, headers, null, responseHandler);
+        } else {
+            // Send a HEAD query to know the size of the remote file.
+            return client.head(this, URL, headers, null, responseHandler);
+        }
+    }
+
+    public void sendNextRangeRequest() {
+        if (file.length() < fileSize) {
+            // File is still smaller than remote file; send a new request.
+            onRunButtonPressed();
+        }
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new RangeFileAsyncHttpResponseHandler(file) {
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+
+                if (fileSize < 1) {
+                    boolean supportsRange = false;
+                    // Cycle through the headers and look for the Content-Length header.
+                    for (Header header : headers) {
+                        String headerName = header.getName();
+                        if (CONTENT_LENGTH.equals(headerName)) {
+                            fileSize = Long.parseLong(header.getValue());
+                        } else if (ACCEPT_RANGES.equals(headerName)) {
+                            supportsRange = true;
+                        }
+                    }
+
+                    // Is the content length known?
+                    if (!supportsRange || fileSize < 1) {
+                        Toast.makeText(
+                            RangeResponseSample.this,
+                            "Unable to determine remote file's size, or\nremote server doesn't support ranges",
+                            Toast.LENGTH_LONG
+                        ).show();
+                    }
+                }
+
+                // If remote file size is known, request next portion.
+                if (fileSize > 0) {
+                    debugFileResponse(file);
+                    // Send a new request for the same resource.
+                    sendNextRangeRequest();
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable e, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                debugFileResponse(file);
+            }
+
+            @Override
+            public void updateRequestHeaders(HttpUriRequest uriRequest) {
+                // Call super so appending could work.
+                super.updateRequestHeaders(uriRequest);
+
+                // Length of the downloaded content thus far.
+                long length = file.length();
+
+                // Request the next portion of the file to be downloaded.
+                uriRequest.setHeader("Range", "bytes=" + length + "-" + (length + CHUNK_SIZE - 1));
+            }
+
+            void debugFileResponse(File file) {
+                debugResponse(LOG_TAG, "File size thus far: " + file.length() + " bytes");
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
index 1a10a1a3..766bc0f8 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.view.Menu;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
new file mode 100644
index 00000000..ca3bab71
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
@@ -0,0 +1,84 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
+import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.ConnectionPoolTimeoutException;
+
+/**
+ * This sample demonstrates use of
+ * {@link AsyncHttpClient#allowRetryExceptionClass(java.lang.Class)} and
+ * {@link AsyncHttpClient#blockRetryExceptionClass(java.lang.Class)} to whitelist
+ * and blacklist certain Exceptions, respectively.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RetryRequestSample extends GetSample {
+
+    private static boolean wasToastShown;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // The following exceptions will be whitelisted, i.e.: When an exception
+        // of this type is raised, the request will be retried.
+        AsyncHttpClient.allowRetryExceptionClass(IOException.class);
+        AsyncHttpClient.allowRetryExceptionClass(SocketTimeoutException.class);
+        AsyncHttpClient.allowRetryExceptionClass(ConnectTimeoutException.class);
+
+        // The following exceptions will be blacklisted, i.e.: When an exception
+        // of this type is raised, the request will not be retried and it will
+        // fail immediately.
+        AsyncHttpClient.blockRetryExceptionClass(UnknownHostException.class);
+        AsyncHttpClient.blockRetryExceptionClass(ConnectionPoolTimeoutException.class);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        if(!wasToastShown) {
+            wasToastShown = true;
+            Toast.makeText(
+                this,
+                "Exceptions' whitelist and blacklist updated\nSee RetryRequestSample.java for details",
+                Toast.LENGTH_LONG
+            ).show();
+        }
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/ip";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_retry_handler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleApplication.java b/sample/src/main/java/com/loopj/android/http/sample/SampleApplication.java
new file mode 100644
index 00000000..2ef13dc0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleApplication.java
@@ -0,0 +1,34 @@
+package com.loopj.android.http.sample;
+
+import android.annotation.TargetApi;
+import android.app.Application;
+import android.os.Build;
+import android.os.StrictMode;
+import android.util.Log;
+
+public class SampleApplication extends Application {
+
+    private static final String LOG_TAG = "SampleApplication";
+
+    @Override
+    public void onCreate() {
+        setStrictMode();
+        super.onCreate();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private void setStrictMode() {
+        if (Integer.valueOf(Build.VERSION.SDK) > 3) {
+            Log.d(LOG_TAG, "Enabling StrictMode policy over Sample application");
+            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .penaltyDeath()
+                    .build());
+            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .build());
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
index 751823e9..0e8d2bdf 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -1,6 +1,26 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
+import android.content.Context;
 import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
 import com.loopj.android.http.RequestHandle;
 import com.loopj.android.http.ResponseHandlerInterface;
 
@@ -8,6 +28,9 @@
 import org.apache.http.HttpEntity;
 
 import java.util.List;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
 
 public interface SampleInterface {
 
@@ -27,6 +50,8 @@
 
     void setAsyncHttpClient(AsyncHttpClient client);
 
+    AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context);
+
     ResponseHandlerInterface getResponseHandler();
 
     String getDefaultURL();
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index 3b26362c..d596a5c3 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -1,6 +1,25 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.Activity;
+import android.content.Context;
 import android.graphics.Color;
 import android.os.Bundle;
 import android.util.Log;
@@ -12,7 +31,9 @@
 import android.widget.TextView;
 
 import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
 import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -26,18 +47,30 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
 
 public abstract class SampleParentActivity extends Activity implements SampleInterface {
 
-    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient() {
+
+      @Override
+      protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        AsyncHttpRequest httpRequest = getHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
+        return httpRequest == null
+            ? super.newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context)
+            : httpRequest;
+      }
+    };
     private EditText urlEditText, headersEditText, bodyEditText;
     private LinearLayout responseLayout;
-    private final List<RequestHandle> requestHandles = new LinkedList<>();
+    private final List<RequestHandle> requestHandles = new LinkedList<RequestHandle>();
 
-    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
-    private static final int LIGHTRED = Color.parseColor("#FF3300");
-    private static final int YELLOW = Color.parseColor("#FFFF00");
-    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+    protected static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    protected static final int LIGHTRED = Color.parseColor("#FF3300");
+    protected static final int YELLOW = Color.parseColor("#FFFF00");
+    protected static final int LIGHTBLUE = Color.parseColor("#99CCFF");
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -70,6 +103,11 @@ protected void onCreate(Bundle savedInstanceState) {
         }
     }
 
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return null;
+    }
+
     public List<RequestHandle> getRequestHandles() {
         return requestHandles;
     }
@@ -83,7 +121,7 @@ public void addRequestHandle(RequestHandle handle) {
 
     public void onRunButtonPressed() {
         addRequestHandle(executeSample(getAsyncHttpClient(),
-                (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
+                getUrlText(getDefaultURL()),
                 getRequestHeaders(),
                 getRequestEntity(),
                 getResponseHandler()));
@@ -107,30 +145,41 @@ public void onClick(View v) {
         }
     };
 
-    public Header[] getRequestHeaders() {
-        List<Header> headers = new ArrayList<>();
+    public List<Header> getRequestHeadersList() {
+        List<Header> headers = new ArrayList<Header>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
         if (headersRaw != null && headersRaw.length() > 3) {
             String[] lines = headersRaw.split("\\r?\\n");
             for (String line : lines) {
                 try {
-                    String[] kv = line.split("=");
-                    if (kv.length != 2)
+                    int equalSignPos = line.indexOf('=');
+                    if (1 > equalSignPos) {
                         throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
-                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                    }
+
+                    String headerName = line.substring(0, equalSignPos).trim();
+                    String headerValue = line.substring(1 + equalSignPos).trim();
+
+                    headers.add(new BasicHeader(headerName, headerValue));
                 } catch (Throwable t) {
                     Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
                 }
             }
         }
+        return headers;
+    }
+
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
         return headers.toArray(new Header[headers.size()]);
     }
 
     public HttpEntity getRequestEntity() {
-        if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
+        String bodyText;
+        if (isRequestBodyAllowed() && (bodyText = getBodyText()) != null) {
             try {
-                return new StringEntity(bodyEditText.getText().toString());
+                return new StringEntity(bodyText);
             } catch (UnsupportedEncodingException e) {
                 Log.e("SampleParentActivity", "cannot create String entity", e);
             }
@@ -138,6 +187,36 @@ public HttpEntity getRequestEntity() {
         return null;
     }
 
+    public String getUrlText() {
+        return getUrlText(null);
+    }
+
+    public String getUrlText(String defaultText) {
+        return urlEditText != null && urlEditText.getText() != null
+            ? urlEditText.getText().toString()
+            : defaultText;
+    }
+
+    public String getBodyText() {
+        return getBodyText(null);
+    }
+
+    public String getBodyText(String defaultText) {
+        return bodyEditText != null && bodyEditText.getText() != null
+            ? bodyEditText.getText().toString()
+            : defaultText;
+    }
+
+    public String getHeadersText() {
+        return getHeadersText(null);
+    }
+
+    public String getHeadersText(String defaultText) {
+        return headersEditText != null && headersEditText.getText() != null
+            ? headersEditText.getText().toString()
+            : defaultText;
+    }
+
     protected final void debugHeaders(String TAG, Header[] headers) {
         if (headers != null) {
             Log.d(TAG, "Return Headers:");
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
new file mode 100644
index 00000000..ca85eb8d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SaxAsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class SaxSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "SaxSample";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return saxAsyncHttpResponseHandler;
+    }
+
+    private SaxAsyncHttpResponseHandler saxAsyncHttpResponseHandler = new SaxAsyncHttpResponseHandler<SAXTreeStructure>(new SAXTreeStructure()) {
+        @Override
+        public void onStart() {
+            clearOutputs();
+        }
+
+        @Override
+        public void onSuccess(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        @Override
+        public void onFailure(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        private void debugHandler(SAXTreeStructure handler) {
+            for (Tuple t : handler.responseViews) {
+                addView(getColoredView(t.color, t.text));
+            }
+        }
+    };
+
+    @Override
+    public String getDefaultURL() {
+        return "http://bin-iin.com/sitemap.xml";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_sax_example;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    private class Tuple {
+        public Integer color;
+        public String text;
+
+        public Tuple(int _color, String _text) {
+            this.color = _color;
+            this.text = _text;
+        }
+    }
+
+    private class SAXTreeStructure extends DefaultHandler {
+
+        public List<Tuple> responseViews = new ArrayList<Tuple>();
+
+        public void startElement(String namespaceURI, String localName,
+                                 String rawName, Attributes atts) {
+            responseViews.add(new Tuple(LIGHTBLUE, "Start Element: " + rawName));
+        }
+
+        public void endElement(String namespaceURI, String localName,
+                               String rawName) {
+            responseViews.add(new Tuple(LIGHTBLUE, "End Element  : " + rawName));
+        }
+
+        public void characters(char[] data, int off, int length) {
+            if (length > 0 && data[0] != '\n') {
+                responseViews.add(new Tuple(LIGHTGREEN, "Characters  :  " + new String(data,
+                        off, length)));
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
index d0756ad0..bb92f02c 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.os.Bundle;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
index 059adeac..752559e7 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.SparseArray;
@@ -13,7 +31,7 @@
 public class ThreadingTimeoutSample extends SampleParentActivity {
 
     private static final String LOG_TAG = "ThreadingTimeoutSample";
-    private SparseArray<String> states = new SparseArray<>();
+    private final SparseArray<String> states = new SparseArray<String>();
     private int counter = 0;
 
     @Override
@@ -54,7 +72,7 @@ private synchronized void setStatus(int id, String status) {
     public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
-            private int id = counter++;
+            private final int id = counter++;
 
             @Override
             public void onStart() {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index dad700c2..24b11a24 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.ListActivity;
@@ -7,48 +25,67 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{
-            "GET",
-            "POST",
-            "DELETE",
-            "PUT",
-            "JSON",
-            "FILE",
-            "BINARY",
-            "GZIP",
-            "302 REDIRECT",
-            "THREADING TIMEOUTS",
-            "CANCEL ALL REQUESTS",
-            "CANCEL REQUEST HANDLE",
-            "SYNCHRONOUS CLIENT"
-    };
-    private static final Class[] targets = {
-            GetSample.class,
-            PostSample.class,
-            DeleteSample.class,
-            PutSample.class,
-            JsonSample.class,
-            FileSample.class,
-            BinarySample.class,
-            GzipSample.class,
-            Redirect302Sample.class,
-            ThreadingTimeoutSample.class,
-            CancelAllRequestsSample.class,
-            CancelRequestHandleSample.class,
-            SynchronousClientSample.class
+    private static final SampleConfig[] samplesConfig = new SampleConfig[] {
+        new SampleConfig(R.string.title_get_sample, GetSample.class),
+        new SampleConfig(R.string.title_post_sample, PostSample.class),
+        new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
+        new SampleConfig(R.string.title_put_sample, PutSample.class),
+        new SampleConfig(R.string.title_json_sample, JsonSample.class),
+        new SampleConfig(R.string.title_json_streamer_sample, JsonStreamerSample.class),
+        new SampleConfig(R.string.title_sax_example, SaxSample.class),
+        new SampleConfig(R.string.title_file_sample, FileSample.class),
+        new SampleConfig(R.string.title_binary_sample, BinarySample.class),
+        new SampleConfig(R.string.title_gzip_sample, GzipSample.class),
+        new SampleConfig(R.string.title_redirect_302, Redirect302Sample.class),
+        new SampleConfig(R.string.title_threading_timeout, ThreadingTimeoutSample.class),
+        new SampleConfig(R.string.title_cancel_all, CancelAllRequestsSample.class),
+        new SampleConfig(R.string.title_cancel_handle, CancelRequestHandleSample.class),
+        new SampleConfig(R.string.title_synchronous, SynchronousClientSample.class),
+        new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
+        new SampleConfig(R.string.title_post_files, FilesSample.class),
+        new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class),
+        new SampleConfig(R.string.title_custom_ca, CustomCASample.class),
+        new SampleConfig(R.string.title_retry_handler, RetryRequestSample.class),
+        new SampleConfig(R.string.title_range_sample, RangeResponseSample.class),
+        new SampleConfig(R.string.title_401_unauth, Http401AuthSample.class),
+        new SampleConfig(R.string.title_pre_post_processing, PrePostProcessingSample.class)
     };
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, getTitlesList()));
+    }
+
+    private List<String> getTitlesList() {
+        List<String> titles = new ArrayList<String>();
+        for (SampleConfig config : samplesConfig) {
+            titles.add(getString(config.titleId));
+        }
+        return titles;
     }
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        if (position >= 0 && position < targets.length)
-            startActivity(new Intent(this, targets[position]));
+        if (position >= 0 && position < samplesConfig.length)
+            startActivity(new Intent(this, samplesConfig[position].targetClass));
     }
+
+    private static class SampleConfig {
+
+        final int titleId;
+        final Class targetClass;
+
+        SampleConfig(int titleId, Class targetClass) {
+          this.titleId = titleId;
+          this.targetClass = targetClass;
+        }
+
+    }
+
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
new file mode 100644
index 00000000..d2d743a5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
new file mode 100644
index 00000000..7fe49c71
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
@@ -0,0 +1,87 @@
+package com.loopj.android.http.sample.services;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.SyncHttpClient;
+import com.loopj.android.http.sample.IntentServiceSample;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+
+public class ExampleIntentService extends IntentService {
+
+    public static final String LOG_TAG = "ExampleIntentService:IntentServiceSample";
+    public static final String INTENT_URL = "INTENT_URL";
+    public static final String INTENT_STATUS_CODE = "INTENT_STATUS_CODE";
+    public static final String INTENT_HEADERS = "INTENT_HEADERS";
+    public static final String INTENT_DATA = "INTENT_DATA";
+    public static final String INTENT_THROWABLE = "INTENT_THROWABLE";
+
+    private AsyncHttpClient aClient = new SyncHttpClient();
+
+    public ExampleIntentService() {
+        super("ExampleIntentService");
+    }
+
+    @Override
+    public void onStart(Intent intent, int startId) {
+        Log.d(LOG_TAG, "onStart()");
+        super.onStart(intent, startId);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        if (intent != null && intent.hasExtra(INTENT_URL)) {
+            aClient.get(this, intent.getStringExtra(INTENT_URL), new AsyncHttpResponseHandler() {
+                @Override
+                public void onStart() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_START));
+                    Log.d(LOG_TAG, "onStart");
+                }
+
+                @Override
+                public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_SUCCESS);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onSuccess");
+                }
+
+                @Override
+                public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_FAILURE);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    broadcast.putExtra(INTENT_THROWABLE, error);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onFailure");
+                }
+
+                @Override
+                public void onCancel() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_CANCEL));
+                    Log.d(LOG_TAG, "onCancel");
+                }
+
+                @Override
+                public void onRetry(int retryNo) {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_RETRY));
+                    Log.d(LOG_TAG, String.format("onRetry: %d", retryNo));
+                }
+
+                @Override
+                public void onFinish() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_FINISH));
+                    Log.d(LOG_TAG, "onFinish");
+                }
+            });
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
new file mode 100644
index 00000000..df4ac428
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.services;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
index 1398d9d9..6838d595 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import java.io.BufferedReader;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
new file mode 100644
index 00000000..a0ccb54b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
@@ -0,0 +1,32 @@
+package com.loopj.android.http.sample.util;
+
+import org.apache.http.Header;
+import org.apache.http.message.BasicHeader;
+
+public class IntentUtil {
+
+    public static String[] serializeHeaders(Header[] headers) {
+        if (headers == null) {
+            return new String[0];
+        }
+        String[] rtn = new String[headers.length * 2];
+        int index = -1;
+        for (Header h : headers) {
+            rtn[++index] = h.getName();
+            rtn[++index] = h.getValue();
+        }
+        return rtn;
+    }
+
+    public static Header[] deserializeHeaders(String[] serialized) {
+        if (serialized == null || serialized.length % 2 != 0) {
+            return new Header[0];
+        }
+        Header[] headers = new Header[serialized.length / 2];
+        for (int i = 0, h = 0; h < headers.length; i++, h++) {
+            headers[h] = new BasicHeader(serialized[i], serialized[++i]);
+        }
+        return headers;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
index e12c30fc..8e6c4a91 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
new file mode 100644
index 00000000..779c2f0e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
@@ -0,0 +1,194 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
+
+import android.os.Build;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.InvalidKeyException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.security.SignatureException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * A class to authenticate a secured connection against a custom CA using a BKS store.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class SecureSocketFactory extends SSLSocketFactory {
+
+    private static final String LOG_TAG = "SecureSocketFactory";
+
+    private final SSLContext sslCtx;
+    private final X509Certificate[] acceptedIssuers;
+
+    /**
+     * Instantiate a new secured factory pertaining to the passed store. Be sure to initialize the
+     * store with the password using {@link java.security.KeyStore#load(java.io.InputStream,
+     * char[])} method.
+     *
+     * @param store The key store holding the certificate details
+     * @param alias The alias of the certificate to use
+     */
+    public SecureSocketFactory(KeyStore store, String alias)
+            throws
+            CertificateException,
+            NoSuchAlgorithmException,
+            KeyManagementException,
+            KeyStoreException,
+            UnrecoverableKeyException {
+
+        super(store);
+
+        // Loading the CA certificate from store.
+        final Certificate rootca = store.getCertificate(alias);
+
+        // Turn it to X509 format.
+        InputStream is = new ByteArrayInputStream(rootca.getEncoded());
+        X509Certificate x509ca = (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(is);
+        AsyncHttpClient.silentCloseInputStream(is);
+
+        if (null == x509ca) {
+            throw new CertificateException("Embedded SSL certificate has expired.");
+        }
+
+        // Check the CA's validity.
+        x509ca.checkValidity();
+
+        // Accepted CA is only the one installed in the store.
+        acceptedIssuers = new X509Certificate[]{x509ca};
+
+        sslCtx = SSLContext.getInstance("TLS");
+        sslCtx.init(
+                null,
+                new TrustManager[]{
+                        new X509TrustManager() {
+                            @Override
+                            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                            }
+
+                            @Override
+                            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                                Exception error = null;
+
+                                if (null == chain || 0 == chain.length) {
+                                    error = new CertificateException("Certificate chain is invalid.");
+                                } else if (null == authType || 0 == authType.length()) {
+                                    error = new CertificateException("Authentication type is invalid.");
+                                } else {
+                                    Log.i(LOG_TAG, "Chain includes " + chain.length + " certificates.");
+                                    try {
+                                        for (X509Certificate cert : chain) {
+                                            Log.i(LOG_TAG, "Server Certificate Details:");
+                                            Log.i(LOG_TAG, "---------------------------");
+                                            Log.i(LOG_TAG, "IssuerDN: " + cert.getIssuerDN().toString());
+                                            Log.i(LOG_TAG, "SubjectDN: " + cert.getSubjectDN().toString());
+                                            Log.i(LOG_TAG, "Serial Number: " + cert.getSerialNumber());
+                                            Log.i(LOG_TAG, "Version: " + cert.getVersion());
+                                            Log.i(LOG_TAG, "Not before: " + cert.getNotBefore().toString());
+                                            Log.i(LOG_TAG, "Not after: " + cert.getNotAfter().toString());
+                                            Log.i(LOG_TAG, "---------------------------");
+
+                                            // Make sure that it hasn't expired.
+                                            cert.checkValidity();
+
+                                            // Verify the certificate's public key chain.
+                                            cert.verify(rootca.getPublicKey());
+                                        }
+                                    } catch (InvalidKeyException e) {
+                                        error = e;
+                                    } catch (NoSuchAlgorithmException e) {
+                                        error = e;
+                                    } catch (NoSuchProviderException e) {
+                                        error = e;
+                                    } catch (SignatureException e) {
+                                        error = e;
+                                    }
+                                }
+                                if (null != error) {
+                                    Log.e(LOG_TAG, "Certificate error", error);
+                                    throw new CertificateException(error);
+                                }
+                            }
+
+                            @Override
+                            public X509Certificate[] getAcceptedIssuers() {
+                                return acceptedIssuers;
+                            }
+                        }
+                },
+                null
+        );
+
+        setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+            throws IOException {
+
+        injectHostname(socket, host);
+        return sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslCtx.getSocketFactory().createSocket();
+    }
+
+    /**
+     * Pre-ICS Android had a bug resolving HTTPS addresses. This workaround fixes that bug.
+     *
+     * @param socket The socket to alter
+     * @param host   Hostname to connect to
+     * @see <a href="https://code.google.com/p/android/issues/detail?id=13117#c14">https://code.google.com/p/android/issues/detail?id=13117#c14</a>
+     */
+    private void injectHostname(Socket socket, String host) {
+        try {
+            if (Integer.valueOf(Build.VERSION.SDK) >= 4) {
+                Field field = InetAddress.class.getDeclaredField("hostName");
+                field.setAccessible(true);
+                field.set(socket.getInetAddress(), host);
+            }
+        } catch (Exception ignored) {
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
new file mode 100644
index 00000000..4937f7f5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
\ No newline at end of file
diff --git a/sample/src/main/res/layout/credentials.xml b/sample/src/main/res/layout/credentials.xml
new file mode 100644
index 00000000..89ca0d9b
--- /dev/null
+++ b/sample/src/main/res/layout/credentials.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:layout_width="fill_parent"
+  android:layout_height="wrap_content"
+  android:paddingTop="10dp"
+  android:paddingBottom="0dp"
+  android:paddingLeft="10dp"
+  android:paddingRight="10dp"
+  android:orientation="vertical"
+>
+  <TextView
+    android:id="@+id/label_credentials"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="10dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:text="@string/label_credentials"
+    android:textColor="@color/dialog_color"
+  />
+  <EditText
+    android:id="@+id/field_username"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="5dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:inputType="text"
+    android:hint="@string/field_username"
+  />
+  <EditText
+    android:id="@+id/field_password"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="5dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:inputType="textPassword"
+    android:hint="@string/field_password"
+  />
+</LinearLayout>
diff --git a/sample/src/main/res/raw/custom_ca.txt b/sample/src/main/res/raw/custom_ca.txt
new file mode 100644
index 00000000..b2760af9
--- /dev/null
+++ b/sample/src/main/res/raw/custom_ca.txt
@@ -0,0 +1,60 @@
+This is a short HOW-TO documenting the steps necessary to create a key store
+file that Android could use to connect to servers with a custom CA.
+
+This file's location is: 'res/raw/custom_ca.txt'
+
+Prerequisities:
+---------------
+
+1) Access to a computer with 'openssl' command;
+2) The 'keytool' command available in Java SE 6 and above;
+3) BouncyCastle jar version 1.46 (http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)
+
+Important:
+----------
+
+If you use the wrong BouncyCastle jar (for example, a newer version), older
+Android handsets might fail with the error "Wrong version of key store". So we
+advise to use an older BouncyCastle jar to cover older handsets.
+
+Let's see the fun part:
+-----------------------
+
+1) Create a self-signed CA using the openssl tool. You may bypass this step if
+   you already have a self-signed CA from before:
+
+   openssl req -newkey rsa:4096 -days 3650 -x509 -nodes -out ca.pem
+
+   This instructs openssl to create a 4096-bit RSA key and set its expiration
+   date 10 years later.
+
+   You will be asked to provide details of the CA. When you're finished, a file
+   called 'ca.pem' will exist in current directory.
+
+2) Android has built-in support for the Bouncy Castle key store format (BKS).
+   You should have downloaded BouncyCastle's jar; we assume the path to that jar
+   is 'path/to/jar/bcprov.jar'. Now create a key store file containing your
+   self-signed CA:
+
+   keytool \
+      -import \
+      -v \
+      -trustcacerts \
+      -file ca.pem \
+      -keystore store.bks \
+      -storetype BKS \
+      -provider org.bouncycastle.jce.provider.BouncyCastleProvider \
+      -providerpath path/to/jar/bcprov.jar \
+      -alias TheAlias \
+      -storepass ThePass
+
+   keytool will ask to verify the certificate, naturally you should do so by
+   typing "yes" (without parentheses) and hitting Enter.
+
+   Note the alias and the password at the last two lines; you will need to enter
+   both in CustomCASample.java before running the sample app.
+
+3) If all went smoothly, you should have a file named store.bks which contains
+   the self-signed CA that we prepared in step 1. Move the resulting file to the
+   'res/raw/' directory, adjust the alias and password in CustomCASample.java
+   file, rebuild the app and run it.
diff --git a/sample/src/main/res/raw/store.bks b/sample/src/main/res/raw/store.bks
new file mode 100644
index 00000000..6c2453bc
Binary files /dev/null and b/sample/src/main/res/raw/store.bks differ
diff --git a/sample/src/main/res/values-v11/colors.xml b/sample/src/main/res/values-v11/colors.xml
new file mode 100644
index 00000000..02e02580
--- /dev/null
+++ b/sample/src/main/res/values-v11/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FF333333</color>
+
+</resources>
diff --git a/sample/src/main/res/values-v14/colors.xml b/sample/src/main/res/values-v14/colors.xml
new file mode 100644
index 00000000..02e02580
--- /dev/null
+++ b/sample/src/main/res/values-v14/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FF333333</color>
+
+</resources>
diff --git a/sample/src/main/res/values/colors.xml b/sample/src/main/res/values/colors.xml
new file mode 100644
index 00000000..eea0b2d7
--- /dev/null
+++ b/sample/src/main/res/values/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FFFFFFFF</color>
+
+</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 3507db19..61c0f0bf 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -1,22 +1,40 @@
 <?xml version="1.0" encoding="utf-8"?>
-<resources>
 
+<resources>
     <string name="app_name">Android Async Http Samples</string>
+
+    <string name="field_username">Username</string>
+    <string name="field_password">Password</string>
+
+    <string name="button_run">Run</string>
+    <string name="button_cancel">Cancel</string>
+
+    <string name="label_headers">Headers (key=val, one per line)</string>
+    <string name="label_req_body">Request body</string>
+    <string name="label_credentials">Server requests authentication.\nTo gain access, enter:\n\nUsername: %1$s\nPassword: %2$s</string>
+
     <string name="title_get_sample">GET</string>
     <string name="title_json_sample">GET JSON and parse it</string>
+    <string name="title_json_streamer_sample">POST JSON using streamer</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
-    <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_cancel_all">Cancel all requests</string>
+    <string name="title_sax_example">SAX Example</string>
     <string name="title_cancel_handle">Cancel request handle</string>
     <string name="title_synchronous">Synchronous GET request</string>
     <string name="title_threading_timeout">Threading timeouts</string>
     <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
-    <string name="button_run">Run</string>
-    <string name="label_headers">Headers (key=val, one per line)</string>
-    <string name="label_req_body">Request body</string>
-    <string name="button_cancel">Cancel</string>
+    <string name="title_intent_service_sample">IntentService Synchronised Request</string>
+    <string name="title_post_files">Post Multipart-encoded files</string>
     <string name="title_redirect_302">302 Redirect handling</string>
+    <string name="title_persistent_cookies">Handling persistent cookies</string>
+    <string name="title_custom_ca">Custom CA Example</string>
+    <string name="title_retry_handler">Retrying requests by Exception</string>
+    <string name="title_range_sample">Range response handling</string>
+    <string name="title_401_unauth">401 basic authentication</string>
+    <string name="title_pre_post_processing">Pre-/Post-processing</string>
+    <string name="title_async_background_thread">Async on background thread</string>
 </resources>
