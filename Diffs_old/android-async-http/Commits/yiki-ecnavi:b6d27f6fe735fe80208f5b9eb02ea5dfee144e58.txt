diff --git a/.classpath b/.classpath
index 14fcf527..c42b9fa4 100644
--- a/.classpath
+++ b/.classpath
@@ -1,8 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="examples"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/project.properties b/project.properties
index 1880987e..0e58ae1c 100644
--- a/project.properties
+++ b/project.properties
@@ -9,4 +9,4 @@
 
 android.library=true
 # Project target.
-target=android-3
+target=android-17
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 6053a569..372b8f4a 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -20,7 +20,9 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.lang.ref.WeakReference;
+import java.security.NoSuchAlgorithmException;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -335,7 +337,28 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
+
+    	String completeUrl = getUrlWithQueryString(url, params);
+    	
+    	responseHandler.setUrl(completeUrl);
+    	
+    	if(responseHandler.isForcedToReadFromCacheEnabled()){
+    		
+    		byte[] dataFromCache = null;
+    		
+    		try {
+    			dataFromCache = CacheManager.retrieveData(responseHandler.getAppContex(), CacheManager.SHA1(completeUrl));
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+    		
+    		if(dataFromCache!=null){
+    			responseHandler.handleSuccessMessage(2000, new String(dataFromCache) ,true);
+    			return;
+    		}
+    	}
+    	
+    	sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
     }
     
     /**
@@ -349,13 +372,34 @@ public void get(Context context, String url, RequestParams params, AsyncHttpResp
      *        the response.
      */
     public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+    	
+    	String completeUrl = getUrlWithQueryString(url, params);
+    	
+    	responseHandler.setUrl(completeUrl);
+    	
+    	if(responseHandler.isForcedToReadFromCacheEnabled()){
+    		
+    		byte[] dataFromCache = null;
+    		
+    		try {
+    			dataFromCache = CacheManager.retrieveData(responseHandler.getAppContex(), CacheManager.SHA1(completeUrl));
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+    		
+    		if(dataFromCache!=null){
+    			responseHandler.handleSuccessMessage(2000, new String(dataFromCache) ,true);
+    			return;
+    		}
+    	}
+
+
+    	HttpUriRequest request = new HttpGet(completeUrl);
         if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
+        sendRequest(httpClient, httpContext, request, null, responseHandler, context);
     }
 
-
+    
     //
     // HTTP POST Requests
     //
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 6c6ba088..f545554e 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -18,6 +18,8 @@
 
 package com.loopj.android.http;
 
+import android.content.Context;
+import android.net.http.HttpResponseCache;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -29,6 +31,8 @@
 import org.apache.http.util.EntityUtils;
 
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 
 /**
  * Used to intercept and handle the responses from requests made using 
@@ -72,6 +76,10 @@
     protected static final int FINISH_MESSAGE = 3;
 
     private Handler handler;
+    
+    private Context mContext;
+    private Boolean mCacheRequest = false;
+    private String mURL;
 
     /**
      * Creates a new AsyncHttpResponseHandler
@@ -87,7 +95,24 @@ public void handleMessage(Message msg){
         }
     }
 
-
+    public AsyncHttpResponseHandler(Context context,boolean cacheRequest) {
+    	this();
+    	mContext = context;
+    	mCacheRequest=cacheRequest;
+    }
+    
+    public Context getAppContex(){
+    	return mContext;
+    }
+    
+    public boolean isForcedToReadFromCacheEnabled(){
+    	return mCacheRequest;
+    }
+    
+    public void setUrl(String url){
+    	mURL = url;
+    }
+    
     //
     // Callbacks to be overridden, typically anonymously
     //
@@ -106,15 +131,18 @@ public void onFinish() {}
      * Fired when a request returns successfully, override to handle in your own code
      * @param content the body of the HTTP response from the server
      */
-    public void onSuccess(String content) {}
+    public void onSuccess(String content) {
+    	
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
      * @param statusCode the status code of the response
      * @param content the body of the HTTP response from the server
      */
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
+    public void onSuccess(int statusCode, String content,boolean isFromCache) {
+
+    		onSuccess(content);    		
     }
 
     /**
@@ -164,8 +192,10 @@ protected void sendFinishMessage() {
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
 
-    protected void handleSuccessMessage(int statusCode, String responseBody) {
-        onSuccess(statusCode, responseBody);
+    
+    protected void handleSuccessMessage(int statusCode, String responseBody,boolean isFromCache) {
+    	
+        onSuccess(statusCode, responseBody,isFromCache);
     }
 
     protected void handleFailureMessage(Throwable e, String responseBody) {
@@ -181,7 +211,12 @@ protected void handleMessage(Message msg) {
         switch(msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
+				try {
+					CacheManager.cacheData(mContext, ((String) response[1]).getBytes() ,CacheManager.SHA1(mURL));
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1],false);
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[])msg.obj;
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index aff1c631..00abf2b4 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -95,6 +95,7 @@ public void onSuccess(byte[] binaryData) {}
     public void onSuccess(int statusCode, byte[] binaryData) {
         onSuccess(binaryData);
     }
+    
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
diff --git a/src/com/loopj/android/http/CacheManager.java b/src/com/loopj/android/http/CacheManager.java
new file mode 100644
index 00000000..a3453a9d
--- /dev/null
+++ b/src/com/loopj/android/http/CacheManager.java
@@ -0,0 +1,116 @@
+package com.loopj.android.http;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import android.content.Context;
+import android.util.Log;
+
+public class CacheManager {
+
+    private static final long MAX_SIZE = 5242880L; // 5MB
+
+    private CacheManager() {
+
+    }
+
+    public static void cacheData(Context context, byte[] data, String name) throws IOException {
+
+        File cacheDir = context.getCacheDir();
+        long size = getDirSize(cacheDir);
+        long newSize = data.length + size;
+
+        if (newSize > MAX_SIZE) {
+            cleanDir(cacheDir, newSize - MAX_SIZE);
+        }
+        Log.i("hamid", "cacheData");
+        File file = new File(cacheDir, name);
+        FileOutputStream os = new FileOutputStream(file);
+        try {
+            os.write(data);
+        }finally {
+            os.flush();
+            os.close();
+        }
+    }
+
+    public static byte[] retrieveData(Context context, String name) throws IOException {
+
+        File cacheDir = context.getCacheDir();
+        File file = new File(cacheDir, name);
+
+        if (!file.exists()) {
+        	Log.i("hamid", "retrieveData cache does not exist");
+            // Data doesn't exist
+            return null;
+        }
+
+        Log.i("hamid", "retrieveData cache exist");
+        
+        byte[] data = new byte[(int) file.length()];
+        FileInputStream is = new FileInputStream(file);
+        try {
+            is.read(data);
+        }
+        finally {
+            is.close();
+        }
+
+        return data;
+    }
+
+    private static void cleanDir(File dir, long bytes) {
+
+        long bytesDeleted = 0;
+        File[] files = dir.listFiles();
+
+        for (File file : files) {
+            bytesDeleted += file.length();
+            file.delete();
+
+            if (bytesDeleted >= bytes) {
+                break;
+            }
+        }
+    }
+
+    private static long getDirSize(File dir) {
+
+        long size = 0;
+        File[] files = dir.listFiles();
+
+        for (File file : files) {
+            if (file.isFile()) {
+                size += file.length();
+            }
+        }
+
+        return size;
+    }
+    
+    private static String convertToHex(byte[] data) {
+        StringBuilder buf = new StringBuilder();
+        for (byte b : data) {
+            int halfbyte = (b >>> 4) & 0x0F;
+            int two_halfs = 0;
+            do {
+                buf.append((0 <= halfbyte) && (halfbyte <= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
+                halfbyte = b & 0x0F;
+            } while (two_halfs++ < 1);
+        }
+        return buf.toString();
+    }
+
+    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        MessageDigest md = MessageDigest.getInstance("SHA-1");
+        md.update(text.getBytes("iso-8859-1"), 0, text.length());
+        byte[] sha1hash = md.digest();
+        return convertToHex(sha1hash);
+    }
+    
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SyncHttpClient.java b/src/com/loopj/android/http/SyncHttpClient.java
index 8f55991e..f3dcb755 100644
--- a/src/com/loopj/android/http/SyncHttpClient.java
+++ b/src/com/loopj/android/http/SyncHttpClient.java
@@ -62,8 +62,7 @@ protected void sendRequest(DefaultHttpClient client,
 		/*
 		 * will execute the request directly
 		 */
-		new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
-				.run();
+		new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
 	}
 
 	public abstract String onRequestFailed(Throwable error, String content);
