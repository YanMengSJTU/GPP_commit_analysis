diff --git a/.travis.yml b/.travis.yml
index 69ae732e..2b3691f2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,7 +4,7 @@ branches:
 language:
   - java
 jdk:
-  - openjdk6
+  - openjdk7
 before_install:
   # environment info
   - mvn -version
@@ -22,16 +22,16 @@ before_install:
   - export PATH=$GRADLE_HOME/bin:$PATH
   # just to test gradle version, against our provided one
   - gradle -v
-  # newest android SDK 22.3
-  - wget http://dl.google.com/android/android-sdk_r22.3-linux.tgz
-  - tar -zxf android-sdk_r22.3-linux.tgz
+  # newest android SDK 22.6.1
+  - wget http://dl.google.com/android/android-sdk_r22.6.1-linux.tgz
+  - tar -zxf android-sdk_r22.6.1-linux.tgz
   - export ANDROID_HOME=`pwd`/android-sdk-linux
   - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
   # manually set sdk.dir variable, according to local paths
   - echo "sdk.dir=$ANDROID_HOME" > local.properties
   # list packages for debug purpose
   - android list sdk -a -e -u
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.1 --force --no-ui
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.3 --force --no-ui
   # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
diff --git a/README.md b/README.md
index fe5fed6b..676b80d4 100644
--- a/README.md
+++ b/README.md
@@ -28,7 +28,7 @@ https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/androi
 ```
 Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
+ArtifactId: android-async-http
 Version: 1.4.5-SNAPSHOT
 Packaging: JAR or AAR
 ```
diff --git a/build.gradle b/build.gradle
index ca484909..21db9553 100644
--- a/build.gradle
+++ b/build.gradle
@@ -22,6 +22,7 @@ allprojects {
 
     tasks.withType(JavaCompile) {
         options.encoding = "UTF-8"
+        options.compilerArgs << "-Xlint:unchecked"
     }
 }
 
diff --git a/library/build.gradle b/library/build.gradle
index e7b17970..3ac2b0a6 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,8 +1,10 @@
+import com.android.builder.BuilderConstants
+
 apply plugin: 'android-library'
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.1'
+    buildToolsVersion '19.0.3'
 
     defaultConfig {
         minSdkVersion 3
@@ -12,11 +14,16 @@ android {
     lintOptions {
         abortOnError false
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 android.libraryVariants.all { variant ->
   def name = variant.buildType.name
-  if (name.equals(com.android.builder.BuilderConstants.DEBUG)) {
+  if (name.equals(BuilderConstants.DEBUG)) {
     return; // Skip debug builds.
   }
   def task = project.tasks.create "android${name.capitalize()}Jar", Jar
@@ -27,7 +34,7 @@ android.libraryVariants.all { variant ->
 
 android.libraryVariants.all { variant ->
 
-    task("generate${variant.name}Javadoc", type: Javadoc) {
+    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
         description "Generates Javadoc for $variant.name."
         source = variant.javaCompile.source
         ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 7e9867c9..16c0b682 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -24,6 +24,7 @@
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpException;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
@@ -31,8 +32,11 @@
 import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
+import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
@@ -50,6 +54,7 @@
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.auth.BasicScheme;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
@@ -58,11 +63,14 @@
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -210,8 +218,8 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         threadPool = Executors.newCachedThreadPool();
-        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
-        clientHeaderMap = new HashMap<String, String>();
+        requestMap = new WeakHashMap();
+        clientHeaderMap = new HashMap();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
@@ -222,6 +230,14 @@ public void process(HttpRequest request, HttpContext context) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
                 }
                 for (String header : clientHeaderMap.keySet()) {
+                    if (request.containsHeader(header)) {
+                        Header overwritten = request.getFirstHeader(header);
+                        Log.d(LOG_TAG,
+                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
+                                        header, clientHeaderMap.get(header),
+                                        overwritten.getName(), overwritten.getValue())
+                        );
+                    }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
             }
@@ -246,6 +262,24 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                        ClientContext.CREDS_PROVIDER);
+                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+                if (authState.getAuthScheme() == null) {
+                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+                    Credentials creds = credsProvider.getCredentials(authScope);
+                    if (creds != null) {
+                        authState.setAuthScheme(new BasicScheme());
+                        authState.setCredentials(creds);
+                    }
+                }
+            }
+        }, 0);
+
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
@@ -404,7 +438,6 @@ public void setProxy(String hostname, int port, String username, String password
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
-
     /**
      * Sets the SSLSocketFactory to user when making requests. By default, a new, default
      * SSLSocketFactory is used.
@@ -452,8 +485,19 @@ public void removeHeader(String header) {
      * @param password Basic Auth password
      */
     public void setBasicAuth(String username, String password) {
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(username, password, scope);
+        setBasicAuth(username, password, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, boolean preemtive) {
+        setBasicAuth(username, password, null, preemtive);
     }
 
     /**
@@ -465,12 +509,40 @@ public void setBasicAuth(String username, String password) {
      * @param scope    - an AuthScope object
      */
     public void setBasicAuth(String username, String password, AuthScope scope) {
+        setBasicAuth(username, password, scope, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param scope     an AuthScope object
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemtive) {
         UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+        this.httpClient.getCredentialsProvider().setCredentials(scope == null ? AuthScope.ANY : scope, credentials);
+        setAuthenticationPreemptive(preemtive);
+    }
+
+    /**
+     * Sets HttpRequestInterceptor which handles authorization in preemtive way, as workaround you
+     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
+     *
+     * @param isPreemtive whether the authorization is processed in preemtive way
+     */
+    public void setAuthenticationPreemptive(boolean isPreemtive) {
+        if (isPreemtive) {
+            httpClient.addRequestInterceptor(new PreemtiveAuthorizationHttpRequestInterceptor(), 0);
+        } else {
+            httpClient.removeRequestInterceptorByClass(PreemtiveAuthorizationHttpRequestInterceptor.class);
+        }
     }
 
     /**
-     * Removes set basic auth credentials
+     * Removes previously set basic auth credentials
      */
     public void clearBasicAuth() {
         this.httpClient.getCredentialsProvider().clear();
@@ -496,6 +568,26 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         }
     }
 
+    /**
+     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
+     * only affect requests which were created with a non-null android Context. This method is
+     * intended to be used in the onDestroy method of your android activities to destroy all
+     * requests which are no longer required.
+     *
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelAllRequests(boolean mayInterruptIfRunning) {
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    requestHandle.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.clear();
+    }
+
     // [+] HTTP HEAD
 
     /**
@@ -688,7 +780,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -706,7 +798,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -730,7 +822,7 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -789,7 +881,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -808,7 +900,7 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -836,7 +928,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -850,7 +942,7 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
@@ -901,10 +993,13 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
             // Add request to request map
             List<RequestHandle> requestList = requestMap.get(context);
             if (requestList == null) {
-                requestList = new LinkedList<RequestHandle>();
+                requestList = new LinkedList();
                 requestMap.put(context, requestList);
             }
 
+            if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
+                ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(uriRequest);
+
             requestList.add(requestHandle);
 
             Iterator<RequestHandle> iterator = requestList.iterator();
@@ -956,6 +1051,36 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
         return url;
     }
 
+    /**
+     * A utility function to close an input stream without raising an exception.
+     *
+     * @param is input stream to close safely
+     */
+    public static void silentCloseInputStream(InputStream is) {
+        try {
+            if (is != null) {
+                is.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close input stream", e);
+        }
+    }
+
+    /**
+     * A utility function to close an output stream without raising an exception.
+     *
+     * @param os output stream to close safely
+     */
+    public static void silentCloseOutputStream(OutputStream os) {
+        try {
+            if (os != null) {
+                os.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close output stream", e);
+        }
+    }
+
     /**
      * Returns HttpEntity containing data from RequestParams included with request declaration.
      * Allows also passing progress from upload via provided ResponseHandler
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index b9dc45ca..721dd283 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -33,7 +33,7 @@
 /**
  * Internal class, representing the HttpRequest, done in asynchronous manner
  */
-class AsyncHttpRequest implements Runnable {
+public class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 985c5267..b59001a9 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -320,14 +320,14 @@ protected void sendMessage(Message msg) {
      */
     protected void postRunnable(Runnable runnable) {
         boolean missingLooper = null == Looper.myLooper();
-        if (missingLooper) {
-            Looper.prepare();
-        }
-        if (null != runnable) {
-            handler.post(runnable);
-        }
-        if (missingLooper) {
-            Looper.loop();
+        if (runnable != null) {
+            if (missingLooper) {
+                // If there is no looper, run on provided handler
+                handler.post(runnable);
+            } else {
+                // Otherwise, run on current thread
+                runnable.run();
+            }
         }
     }
 
@@ -376,7 +376,7 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                int buffersize = (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
+                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
                     ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
                     try {
@@ -386,10 +386,10 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                         while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
                             count += l;
                             buffer.append(tmp, 0, l);
-                            sendProgressMessage(count, (int) contentLength);
+                            sendProgressMessage(count, (int) (contentLength <= 0 ? 1 : contentLength));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
index e9bc1809..0fae7e9a 100644
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -19,10 +19,8 @@
 import java.io.UnsupportedEncodingException;
 
 /**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
  */
 public class Base64 {
     /**
@@ -31,36 +29,31 @@
     public static final int DEFAULT = 0;
 
     /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
+     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
      */
     public static final int NO_PADDING = 1;
 
     /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
+     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
      */
     public static final int NO_WRAP = 2;
 
     /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
+     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
+     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
      */
     public static final int CRLF = 4;
 
     /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
+     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
+     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
+     * /}.
      */
     public static final int URL_SAFE = 8;
 
     /**
-     * Flag to pass to {@link Base64OutputStream} to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
+     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
+     * stream it is wrapping when it itself is closed.
      */
     public static final int NO_CLOSE = 16;
 
@@ -73,24 +66,20 @@
         public int op;
 
         /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
+         * Encode/decode another block of input data.  this.output is provided by the caller, and
+         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
          * of the coded data.
          *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
+         * @param finish true if this is the final call to process for this object.  Will finalize
+         *               the coder state and include any final bytes in the output.
+         * @return true if the input so far is good; false if some error has been detected in the
+         * input stream..
          */
         public abstract boolean process(byte[] input, int offset, int len, boolean finish);
 
         /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
+         * @return the maximum number of bytes a call to process() could produce for the given
+         * number of input bytes.  This may be an overestimate.
          */
         public abstract int maxOutputSize(int len);
     }
@@ -100,62 +89,53 @@
     //  --------------------------------------------------------
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param str   the input String to decode, which is converted to bytes using the default
+     *              charset
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(String str, int flags) {
         return decode(str.getBytes(), flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
      * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int flags) {
         return decode(input, 0, input.length, flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
      * @param input  the data to decode
      * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *               standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int offset, int len, int flags) {
         // Allocate space for the most data the input could represent.
         // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
 
         if (!decoder.process(input, offset, len, true)) {
             throw new IllegalArgumentException("bad base-64");
@@ -175,63 +155,61 @@
 
     /* package */ static class Decoder extends Coder {
         /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
+         * Lookup table for turning bytes into their position in the Base64 alphabet.
          */
         private static final int DECODE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
         /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
+         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
+         * and /.
          */
         private static final int DECODE_WEBSAFE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
-        /** Non-data values in the DECODE arrays. */
+        /**
+         * Non-data values in the DECODE arrays.
+         */
         private static final int SKIP = -1;
         private static final int EQUALS = -2;
 
         /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
+         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
+         * expecting exactly one more. State 5 is expecting no more data or padding characters in
+         * the input. State 6 is the error state; an error has been detected in the input and no
+         * future input can "fix" it.
          */
         private int state;   // state number (0 to 6)
         private int value;
@@ -247,18 +225,17 @@ public Decoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
          */
         public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
+            return len * 3 / 4 + 10;
         }
 
         /**
          * Decode another block of input data.
          *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
+         * @return true if the state machine is still healthy.  false if bad base-64 data has been
+         * detected in the input stream.
          */
         public boolean process(byte[] input, int offset, int len, boolean finish) {
             if (this.state == 6) return false;
@@ -293,13 +270,13 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // You can remove this whole block and the output should
                 // be the same, just slower.
                 if (state == 0) {
-                    while (p+4 <= len &&
-                           (value = ((alphabet[input[p] & 0xff] << 18) |
-                                     (alphabet[input[p+1] & 0xff] << 12) |
-                                     (alphabet[input[p+2] & 0xff] << 6) |
-                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
+                    while (p + 4 <= len &&
+                            (value = ((alphabet[input[p] & 0xff] << 18) |
+                                    (alphabet[input[p + 1] & 0xff] << 12) |
+                                    (alphabet[input[p + 2] & 0xff] << 6) |
+                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                        output[op + 2] = (byte) value;
+                        output[op + 1] = (byte) (value >> 8);
                         output[op] = (byte) (value >> 16);
                         op += 3;
                         p += 4;
@@ -315,78 +292,78 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 int d = alphabet[input[p++] & 0xff];
 
                 switch (state) {
-                case 0:
-                    if (d >= 0) {
-                        value = d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 1:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 2:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect exactly one more padding character.
-                        output[op++] = (byte) (value >> 4);
-                        state = 4;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 3:
-                    if (d >= 0) {
-                        // Emit the output triple and return to state 0.
-                        value = (value << 6) | d;
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        state = 0;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect no further data or padding characters.
-                        output[op+1] = (byte) (value >> 2);
-                        output[op] = (byte) (value >> 10);
-                        op += 2;
-                        state = 5;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 4:
-                    if (d == EQUALS) {
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 5:
-                    if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
+                    case 0:
+                        if (d >= 0) {
+                            value = d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 1:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 2:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect exactly one more padding character.
+                            output[op++] = (byte) (value >> 4);
+                            state = 4;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 3:
+                        if (d >= 0) {
+                            // Emit the output triple and return to state 0.
+                            value = (value << 6) | d;
+                            output[op + 2] = (byte) value;
+                            output[op + 1] = (byte) (value >> 8);
+                            output[op] = (byte) (value >> 16);
+                            op += 3;
+                            state = 0;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect no further data or padding characters.
+                            output[op + 1] = (byte) (value >> 2);
+                            output[op] = (byte) (value >> 10);
+                            op += 2;
+                            state = 5;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 4:
+                        if (d == EQUALS) {
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 5:
+                        if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
                 }
             }
 
@@ -403,33 +380,33 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
             // the state machine and finish up.
 
             switch (state) {
-            case 0:
-                // Output length is a multiple of three.  Fine.
-                break;
-            case 1:
-                // Read one extra input byte, which isn't enough to
-                // make another output byte.  Illegal.
-                this.state = 6;
-                return false;
-            case 2:
-                // Read two extra input bytes, enough to emit 1 more
-                // output byte.  Fine.
-                output[op++] = (byte) (value >> 4);
-                break;
-            case 3:
-                // Read three extra input bytes, enough to emit 2 more
-                // output bytes.  Fine.
-                output[op++] = (byte) (value >> 10);
-                output[op++] = (byte) (value >> 2);
-                break;
-            case 4:
-                // Read one padding '=' when we expected 2.  Illegal.
-                this.state = 6;
-                return false;
-            case 5:
-                // Read all the padding '='s we expected and no more.
-                // Fine.
-                break;
+                case 0:
+                    // Output length is a multiple of three.  Fine.
+                    break;
+                case 1:
+                    // Read one extra input byte, which isn't enough to
+                    // make another output byte.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 2:
+                    // Read two extra input bytes, enough to emit 1 more
+                    // output byte.  Fine.
+                    output[op++] = (byte) (value >> 4);
+                    break;
+                case 3:
+                    // Read three extra input bytes, enough to emit 2 more
+                    // output bytes.  Fine.
+                    output[op++] = (byte) (value >> 10);
+                    output[op++] = (byte) (value >> 2);
+                    break;
+                case 4:
+                    // Read one padding '=' when we expected 2.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 5:
+                    // Read all the padding '='s we expected and no more.
+                    // Fine.
+                    break;
             }
 
             this.state = state;
@@ -443,13 +420,11 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
     //  --------------------------------------------------------
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
      */
     public static String encodeToString(byte[] input, int flags) {
         try {
@@ -461,16 +436,13 @@ public static String encodeToString(byte[] input, int flags) {
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
      */
     public static String encodeToString(byte[] input, int offset, int len, int flags) {
         try {
@@ -482,29 +454,24 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
      */
     public static byte[] encode(byte[] input, int flags) {
         return encode(input, 0, input.length, flags);
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
      */
     public static byte[] encode(byte[] input, int offset, int len, int flags) {
         Encoder encoder = new Encoder(flags, null);
@@ -519,54 +486,59 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
             }
         } else {
             switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
+                case 0:
+                    break;
+                case 1:
+                    output_len += 2;
+                    break;
+                case 2:
+                    output_len += 3;
+                    break;
             }
         }
 
         // Account for the newlines, if any.
         if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                (encoder.do_cr ? 2 : 1);
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                    (encoder.do_cr ? 2 : 1);
         }
 
         encoder.output = new byte[output_len];
         encoder.process(input, offset, len, true);
 
-        assert encoder.op == output_len;
+        if (BuildConfig.DEBUG && encoder.op != output_len) {
+            throw new AssertionError();
+        }
 
         return encoder.output;
     }
 
     /* package */ static class Encoder extends Coder {
         /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
+         * (the maximum allowable according to <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC
+         * 2045</a>).
          */
         public static final int LINE_GROUPS = 19;
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
         };
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE_WEBSAFE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
         };
 
         final private byte[] tail;
@@ -593,11 +565,10 @@ public Encoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
          */
         public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
+            return len * 8 / 5 + 10;
         }
 
         public boolean process(byte[] input, int offset, int len, boolean finish) {
@@ -621,22 +592,22 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     break;
 
                 case 1:
-                    if (p+2 <= len) {
+                    if (p + 2 <= len) {
                         // A 1-byte tail with at least 2 bytes of
                         // input available now.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((input[p++] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((input[p++] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
 
                 case 2:
-                    if (p+1 <= len) {
+                    if (p + 1 <= len) {
                         // A 2-byte tail with at least 1 byte of input.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((tail[1] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((tail[1] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
@@ -659,14 +630,14 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
 
             // The main loop, turning 3 input bytes into 4 output bytes on
             // each iteration.
-            while (p+3 <= len) {
+            while (p + 3 <= len) {
                 v = ((input[p] & 0xff) << 16) |
-                    ((input[p+1] & 0xff) << 8) |
-                    (input[p+2] & 0xff);
+                        ((input[p + 1] & 0xff) << 8) |
+                        (input[p + 2] & 0xff);
                 output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
+                output[op + 1] = alphabet[(v >> 12) & 0x3f];
+                output[op + 2] = alphabet[(v >> 6) & 0x3f];
+                output[op + 3] = alphabet[v & 0x3f];
                 p += 3;
                 op += 4;
                 if (--count == 0) {
@@ -682,7 +653,7 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // remaining in input; there should be at most two bytes
                 // total.
 
-                if (p-tailLen == len-1) {
+                if (p - tailLen == len - 1) {
                     int t = 0;
                     v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                     tailLen -= t;
@@ -696,10 +667,10 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                         if (do_cr) output[op++] = '\r';
                         output[op++] = '\n';
                     }
-                } else if (p-tailLen == len-2) {
+                } else if (p - tailLen == len - 2) {
                     int t = 0;
                     v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                     tailLen -= t;
                     output[op++] = alphabet[(v >> 12) & 0x3f];
                     output[op++] = alphabet[(v >> 6) & 0x3f];
@@ -716,17 +687,18 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     output[op++] = '\n';
                 }
 
-                assert tailLen == 0;
-                assert p == len;
+                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
+                    throw new AssertionError();
+                }
             } else {
                 // Save the leftovers in tail to be consumed on the next
                 // call to encodeInternal.
 
-                if (p == len-1) {
+                if (p == len - 1) {
                     tail[tailLen++] = input[p];
-                } else if (p == len-2) {
+                } else if (p == len - 2) {
                     tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
+                    tail[tailLen++] = input[p + 1];
                 }
             }
 
@@ -737,5 +709,6 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
         }
     }
 
-    private Base64() { }   // don't instantiate
+    private Base64() {
+    }   // don't instantiate
 }
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
index 61afb931..231d4036 100644
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -43,6 +43,7 @@ public Base64OutputStream(OutputStream out, int flags, boolean encode) {
         }
     }
 
+    @Override
     public void write(int b) throws IOException {
         // To avoid invoking the encoder/decoder routines for single
         // bytes, we buffer up calls to write(int) in an internal
@@ -71,12 +72,14 @@ private void flushBuffer() throws IOException {
         }
     }
 
+    @Override
     public void write(byte[] b, int off, int len) throws IOException {
         if (len <= 0) return;
         flushBuffer();
         internalWrite(b, off, len, false);
     }
 
+    @Override
     public void close() throws IOException {
         IOException thrown = null;
         try {
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index 03f98345..5aed5e4e 100644
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -29,6 +29,7 @@
  * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
  * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
  * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ * @param <JSON_TYPE>
  */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
index dc35b42d..b121835d 100644
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -41,6 +41,8 @@ public DataAsyncHttpResponseHandler() {
 
     /**
      * Fired when the request progress, override to handle in your own code
+     *
+     * @param responseBody response body received so far
      */
     public void onProgressData(byte[] responseBody) {
     }
@@ -104,7 +106,7 @@ protected void handleMessage(Message message) {
                             sendProgressDataMessage(copyOfRange(tmp, 0, l));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 6223890e..be48f62b 100644
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -14,7 +14,7 @@
 
 public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
-    private File mFile;
+    protected final File mFile;
     private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
 
     /**
@@ -120,9 +120,9 @@ public final void onSuccess(int statusCode, Header[] headers, byte[] responseByt
                         sendProgressMessage(count, (int) contentLength);
                     }
                 } finally {
-                    instream.close();
+                    AsyncHttpClient.silentCloseInputStream(instream);
                     buffer.flush();
-                    buffer.close();
+                    AsyncHttpClient.silentCloseOutputStream(buffer);
                 }
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 0b26fb1b..227f41cd 100644
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -125,6 +125,8 @@ public void run() {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
                                 } else {
                                     onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 49375061..6db13641 100644
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -24,7 +24,7 @@
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
 
-import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -46,15 +46,16 @@
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
         new UnsupportedOperationException("Unsupported operation in this implementation.");
 
-    // Size of the byte-array buffer used to read from streams.
-    private static final int BUFFER_SIZE = 2048;
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
 
     // Reusable StringBuilder used by escape() method.
-    // Base64, at worst, will make a binary stream grow in size by approximately
-    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
-    // large 'n'.
-    private static final StringBuilder BUILDER =
-        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+    // Its size is just initial, if more space is needed, the system will
+    // automatically enlarge the buffer.
+    private static final StringBuilder BUILDER = new StringBuilder(128);
 
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
@@ -68,33 +69,28 @@
         new BasicHeader("Content-Type", "application/json");
     private static final Header HEADER_GZIP_ENCODING =
         new BasicHeader("Content-Encoding", "gzip");
-    private static final String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
-
-    // K/V objects to be uploaded.
-    private final Map<String, Object> kvParams =
-        new HashMap<String, Object>();
 
-    // Streams and their associated meta-data to be uploaded.
-    private final Map<String, RequestParams.StreamWrapper> streamParams =
-        new HashMap<String, RequestParams.StreamWrapper>();
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
-    public JsonStreamerEntity(boolean contentEncoding) {
-        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
-    }
+    private final ResponseHandlerInterface progressHandler;
 
-    public void addPart(String key, Object value) {
-        kvParams.put(key, value);
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
     }
 
-    public void addPart(String key, InputStream inputStream, String name, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
     }
 
     @Override
@@ -137,122 +133,176 @@ public InputStream getContent() throws IOException, UnsupportedOperationExceptio
     }
 
     @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        if (outstream == null) {
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
             throw new IllegalStateException("Output stream cannot be null.");
         }
 
         // Record the time when uploading started.
         long now = System.currentTimeMillis();
 
-        // Keys used by the HashMaps.
-        Set<String> keys;
-
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream upload;
-        if (null != contentEncoding) {
-            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
-        } else {
-            upload = new BufferedOutputStream(outstream);
-        }
+        OutputStream os = null != contentEncoding
+          ? new GZIPOutputStream(out, BUFFER_SIZE)
+          : out;
 
         // Always send a JSON object.
-        upload.write('{');
+        os.write('{');
 
-        // Send the K/V values.
-        keys = kvParams.keySet();
-        for (String key : keys) {
-            // Write the JSON object's key.
-            upload.write(escape(key));
-            upload.write(':');
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        boolean isFileWrapper;
 
+        // Go over all keys and handle each's value.
+        for (String key : keys) {
             // Evaluate the value (which cannot be null).
-            Object value = kvParams.get(key);
+            Object value = jsonParams.get(key);
+
+            // Bail out prematurely if value's null.
+            if (value == null) {
+                continue;
+            }
 
-            if (value instanceof Boolean) {
-                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            // Write the JSON object's key.
+            os.write(escape(key));
+            os.write(':');
+
+            // Check if this is a FileWrapper.
+            isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+            // If a file should be uploaded.
+            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                // All uploads are sent as an object containing the file's details.
+                os.write('{');
+
+                // Determine how to handle this entry.
+                if (isFileWrapper) {
+                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                } else {
+                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                }
+
+                // End the file's object and prepare for next one.
+                os.write('}');
+            } else if (value instanceof Boolean) {
+                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                upload.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number)value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                upload.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number)value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                upload.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number)value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                upload.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number)value).intValue() + "").getBytes());
             } else {
-                upload.write(value.toString().getBytes());
+                os.write(value.toString().getBytes());
             }
 
-            upload.write(',');
-        }
-
-        // Buffer used for reading from input streams.
-        byte[] buffer = new byte[BUFFER_SIZE];
-
-        // Send the stream params.
-        keys = streamParams.keySet();
-        for (String key : keys) {
-            RequestParams.StreamWrapper entry = streamParams.get(key);
-
-            // Write the JSON object's key.
-            upload.write(escape(key));
-
-            // All uploads are sent as an object containing the file's details.
-            upload.write(':');
-            upload.write('{');
-
-            // Send the streams's name.
-            upload.write(STREAM_NAME);
-            upload.write(':');
-            upload.write(escape(entry.name));
-            upload.write(',');
-
-            // Send the streams's content type.
-            upload.write(STREAM_TYPE);
-            upload.write(':');
-            upload.write(escape(entry.contentType));
-            upload.write(',');
-
-            // Prepare the file content's key.
-            upload.write(STREAM_CONTENTS);
-            upload.write(':');
-            upload.write('"');
-
-            // Upload the file's contents in Base64.
-            Base64OutputStream outputStream =
-                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-            // Read from input stream until no more data's left to read.
-            int bytesRead;
-            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
-                outputStream.write(buffer, 0, bytesRead);
-            }
-
-            // Close the Base64 output stream.
-            outputStream.close();
-
-            // End the file's object and prepare for next one.
-            upload.write('"');
-            upload.write('}');
-            upload.write(',');
+            os.write(',');
         }
 
         // Include the elapsed time taken to upload everything.
         // This might be useful for somebody, but it serves us well since
         // there will almost always be a ',' as the last sent character.
-        upload.write(STREAM_ELAPSED);
-        upload.write(':');
+        os.write(STREAM_ELAPSED);
+        os.write(':');
         long elapsedTime = System.currentTimeMillis() - now;
-        upload.write((elapsedTime + "}").getBytes());
+        os.write((elapsedTime + "}").getBytes());
 
         Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
 
         // Flush the contents up the stream.
-        upload.flush();
-        upload.close();
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
     }
 
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
+      }
+
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
     // Changed a bit to suit our needs in this class.
     static byte[] escape(String string) {
@@ -310,11 +360,11 @@ public void writeTo(final OutputStream outstream) throws IOException {
         BUILDER.append('"');
 
         try {
-          return BUILDER.toString().getBytes();
+            return BUILDER.toString().getBytes();
         } finally {
-          // Empty the String buffer.
-          // This is 20-30% faster than instantiating a new object.
-          BUILDER.setLength(0);
+            // Empty the String buffer.
+            // This is 20-30% faster than instantiating a new object.
+            BUILDER.setLength(0);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
index 4ea14152..4c4df9ce 100644
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,10 +1,22 @@
 package com.loopj.android.http;
 
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
+
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
@@ -14,24 +26,11 @@
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
- 
+
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
- 
-import org.apache.http.HttpVersion;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.HTTP;
 
 /**
  * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
@@ -43,92 +42,90 @@
 
     /**
      * Creates a new SSL Socket Factory with the given KeyStore.
-     * 
+     *
      * @param truststore A KeyStore to create the SSL Socket Factory in context of
-     * @throws NoSuchAlgorithmException
-     * @throws KeyManagementException
-     * @throws KeyStoreException
-     * @throws UnrecoverableKeyException
      */
     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);
- 
+
         X509TrustManager tm = new X509TrustManager() {
             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public X509Certificate[] getAcceptedIssuers() {
                 return null;
             }
         };
- 
-        sslContext.init(null, new TrustManager[] { tm }, null);
+
+        sslContext.init(null, new TrustManager[]{tm}, null);
     }
-    
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }
- 
+
     @Override
     public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
-    }	
-    
+    }
+
     /**
      * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
      */
     public void fixHttpsURLConnection() {
-    	HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
     }
-    
+
     /**
      * Gets a KeyStore containing the Certificate
-     * 
+     *
      * @param cert InputStream of the Certificate
      * @return KeyStore
      */
-	public static KeyStore getKeystoreOfCA(InputStream cert) {
-		
-		// Load CAs from an InputStream
-		InputStream caInput = null;
-		Certificate ca = null;
-		try {
-			CertificateFactory cf = CertificateFactory.getInstance("X.509");
-			caInput = new BufferedInputStream(cert);
-			ca = (Certificate) cf.generateCertificate(caInput);
-		} catch (CertificateException e1) {
-			e1.printStackTrace();
-		} finally {
-			try {
-				caInput.close();
-			} catch (IOException e) {
-				e.printStackTrace();
-			}
-		}
- 
-		// Create a KeyStore containing our trusted CAs
-		String keyStoreType = KeyStore.getDefaultType();
-		KeyStore keyStore = null;
-		try {
-			keyStore = KeyStore.getInstance(keyStoreType);
-			keyStore.load(null, null);
-			keyStore.setCertificateEntry("ca",
-					(java.security.cert.Certificate) ca);
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		return keyStore;
-	}
-	
-	/**
-	 * Gets a Default KeyStore
-	 * 
-	 * @return KeyStore
-	 */
-	public static KeyStore getKeystore() {
+    public static KeyStore getKeystoreOfCA(InputStream cert) {
+
+        // Load CAs from an InputStream
+        InputStream caInput = null;
+        Certificate ca = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            caInput = new BufferedInputStream(cert);
+            ca = cf.generateCertificate(caInput);
+        } catch (CertificateException e1) {
+            e1.printStackTrace();
+        } finally {
+            try {
+                if (caInput != null) {
+                    caInput.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Create a KeyStore containing our trusted CAs
+        String keyStoreType = KeyStore.getDefaultType();
+        KeyStore keyStore = null;
+        try {
+            keyStore = KeyStore.getInstance(keyStoreType);
+            keyStore.load(null, null);
+            keyStore.setCertificateEntry("ca", ca);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return keyStore;
+    }
+
+    /**
+     * Gets a Default KeyStore
+     *
+     * @return KeyStore
+     */
+    public static KeyStore getKeystore() {
         KeyStore trustStore = null;
         try {
             trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -138,12 +135,12 @@ public static KeyStore getKeystore() {
         }
         return trustStore;
     }
- 
-	/**
-	 * Returns a SSlSocketFactory which trusts all certificates
-	 * 
-	 * @return
-	 */
+
+    /**
+     * Returns a SSlSocketFactory which trusts all certificates
+     *
+     * @return SSLSocketFactory
+     */
     public static SSLSocketFactory getFixedSocketFactory() {
         SSLSocketFactory socketFactory;
         try {
@@ -155,31 +152,31 @@ public static SSLSocketFactory getFixedSocketFactory() {
         }
         return socketFactory;
     }
-    
+
     /**
      * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
-     * 
-     * @param keyStore
-     * @return
+     *
+     * @param keyStore custom provided KeyStore instance
+     * @return DefaultHttpClient
      */
-	public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
-		
-	    try {
-		    SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
-		    SchemeRegistry registry = new SchemeRegistry();
-		    registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-		    registry.register(new Scheme("https", sf, 443));
- 
-	        HttpParams params = new BasicHttpParams();
-	        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
-	        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
- 
-	        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
- 
-	        return new DefaultHttpClient(ccm, params);
-	    } catch (Exception e) {
-	        return new DefaultHttpClient();
-	    }
-	}
+    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+
+        try {
+            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+            registry.register(new Scheme("https", sf, 443));
+
+            HttpParams params = new BasicHttpParams();
+            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+
+            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+
+            return new DefaultHttpClient(ccm, params);
+        } catch (Exception e) {
+            return new DefaultHttpClient();
+        }
+    }
 
 }
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index ee87bd23..2e0fdb8d 100644
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -48,6 +48,7 @@
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
+    private boolean omitNonPersistentCookies = false;
 
     private final ConcurrentHashMap<String, Cookie> cookies;
     private final SharedPreferences cookiePrefs;
@@ -59,7 +60,7 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
+        cookies = new ConcurrentHashMap();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -82,6 +83,8 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
+        if (omitNonPersistentCookies && !cookie.isPersistent())
+            return;
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
@@ -143,7 +146,30 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
+        return new ArrayList(cookies.values());
+    }
+
+    /**
+     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
+     * signature (`Cookie.isPersistent`)
+     *
+     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
+     */
+    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
+        this.omitNonPersistentCookies = omitNonPersistentCookies;
+    }
+
+    /**
+     * Non-standard helper method, to delete cookie
+     *
+     * @param cookie cookie to be removed
+     */
+    public void deleteCookie(Cookie cookie) {
+        String name = cookie.getName();
+        cookies.remove(name);
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        prefsWriter.commit();
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
new file mode 100644
index 00000000..6f3756cf
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -0,0 +1,36 @@
+package com.loopj.android.http;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+public class PreemtiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
+
+    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                ClientContext.CREDS_PROVIDER);
+        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+        if (authState.getAuthScheme() == null) {
+            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+            Credentials creds = credsProvider.getCredentials(authScope);
+            if (creds != null) {
+                authState.setAuthScheme(new BasicScheme());
+                authState.setCredentials(creds);
+            }
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..f6348da4
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -0,0 +1,95 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
+	private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+
+	private long current = 0;
+	private boolean append = false;
+
+	/**
+	 * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+	 * 
+	 * @param file File to store response within, must not be null
+	 */
+	public RangeFileAsyncHttpResponseHandler(File file) {
+		super(file);
+	}
+
+	@Override
+	public void sendResponseMessage(HttpResponse response) throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			StatusLine status = response.getStatusLine();
+			if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE){
+				//already finished
+				if (!Thread.currentThread().isInterrupted())
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+			}
+			else if (status.getStatusCode() >= 300) {
+				if (!Thread.currentThread().isInterrupted())
+					sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+			}
+			else {
+				if (!Thread.currentThread().isInterrupted()) {
+					Header header = response.getFirstHeader("Content-Range");
+					if (header == null) {
+						append = false;
+						current = 0;
+					}
+					else
+						Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+				}
+			}
+		}
+	}
+
+	@Override
+	protected byte[] getResponseData(HttpEntity entity) throws IOException {
+		if (entity != null) {
+			InputStream instream = entity.getContent();
+			long contentLength = entity.getContentLength() + current;
+			FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+			if (instream != null) {
+				try {
+					byte[] tmp = new byte[BUFFER_SIZE];
+					int l;
+					while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted())
+					{
+						current += l;
+						buffer.write(tmp, 0, l);
+						sendProgressMessage((int)current, (int)contentLength);
+					}
+				} finally {
+					instream.close();
+					buffer.flush();
+					buffer.close();
+				}
+			}
+		}
+		return null;
+	}
+
+	public void updateRequestHeaders(HttpUriRequest uriRequest) {
+		if (mFile.exists() && mFile.canWrite())
+			current = mFile.length();
+		if (current > 0) {
+			append = true;
+			uriRequest.setHeader("Range", "bytes=" + current + "-");
+		}
+	}
+}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index 1d56fb42..a35aa634 100644
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -5,7 +5,7 @@
 /**
  * A Handle to an AsyncRequest which can be used to cancel a running request.
  */
-class RequestHandle {
+public class RequestHandle {
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 42ba1706..ce263cf0 100644
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -27,7 +27,6 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -90,13 +89,17 @@
  */
 public class RequestParams {
 
+    public final static String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -126,7 +129,6 @@ public RequestParams() {
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
-        init();
         if (source != null) {
             for (Map.Entry<String, String> entry : source.entrySet()) {
                 put(entry.getKey(), entry.getValue());
@@ -156,7 +158,6 @@ public RequestParams(final String key, final String value) {
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-        init();
         int len = keysAndValues.length;
         if (len % 2 != 0)
             throw new IllegalArgumentException("Supplied arguments must be even");
@@ -237,8 +238,21 @@ public void put(String key, InputStream stream, String name) {
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
         if (key != null && stream != null) {
-            streamParams.put(key, new StreamWrapper(stream, name, contentType));
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
         }
     }
 
@@ -254,6 +268,30 @@ public void put(String key, Object value) {
         }
     }
 
+    /**
+     * Adds a int value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value int for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds a long value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value long for the new param.
+     */
+    public void put(String key, long value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds string value to param which can have more than one value.
      *
@@ -269,9 +307,9 @@ public void add(String key, String value) {
                 this.put(key, params);
             }
             if (params instanceof List) {
-                ((List<Object>) params).add(value);
+                ((List) params).add(value);
             } else if (params instanceof Set) {
-                ((Set<Object>) params).add(value);
+                ((Set) params).add(value);
             }
         }
     }
@@ -340,7 +378,17 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Returns an HttpEntity containing all request parameters
+     * Set global flag which determines whether to automatically close input
+     * streams on successful upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
      * @return HttpEntity resulting HttpEntity to be included along with {@link
@@ -349,7 +397,7 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
         if (useJsonStreamer) {
-            return createJsonStreamerEntity();
+            return createJsonStreamerEntity(progressHandler);
         } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
@@ -357,8 +405,9 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
         }
     }
 
-    private HttpEntity createJsonStreamerEntity() throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -372,11 +421,7 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
 
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(),
-                    new FileInputStream(fileWrapper.file),
-                    fileWrapper.file.getName(),
-                    fileWrapper.contentType);
+            entity.addPart(entry.getKey(), entry.getValue());
         }
 
         // Add stream params
@@ -384,9 +429,11 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
+                    StreamWrapper.newInstance(
                         stream.inputStream,
                         stream.name,
-                        stream.contentType);
+                        stream.contentType,
+                        stream.autoClose));
             }
         }
 
@@ -435,15 +482,8 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
         return entity;
     }
 
-    private void init() {
-        urlParams = new ConcurrentHashMap<String, String>();
-        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
-    }
-
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> lparams = new LinkedList();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -455,21 +495,23 @@ private void init() {
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> params = new LinkedList();
         if (value instanceof Map) {
-            Map<String, Object> map = (Map<String, Object>) value;
-            List<String> list = new ArrayList<String>(map.keySet());
+            Map map = (Map) value;
+            List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
             Collections.sort(list);
-            for (String nestedKey : list) {
-                Object nestedValue = map.get(nestedKey);
-                if (nestedValue != null) {
-                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
-                            nestedValue));
+            for (Object nestedKey : list) {
+                if (nestedKey instanceof String) {
+                    Object nestedValue = map.get(nestedKey);
+                    if (nestedValue != null) {
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
+                                nestedValue));
+                    }
                 }
             }
         } else if (value instanceof List) {
-            List<Object> list = (List<Object>) value;
+            List list = (List) value;
             for (Object nestedValue : list) {
                 params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
             }
@@ -479,7 +521,7 @@ private void init() {
                 params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
             }
         } else if (value instanceof Set) {
-            Set<Object> set = (Set<Object>) value;
+            Set set = (Set) value;
             for (Object nestedValue : set) {
                 params.addAll(getParamsList(key, nestedValue));
             }
@@ -494,8 +536,8 @@ protected String getParamString() {
     }
 
     public static class FileWrapper {
-        public File file;
-        public String contentType;
+        public final File file;
+        public final String contentType;
 
         public FileWrapper(File file, String contentType) {
             this.file = file;
@@ -504,14 +546,24 @@ public FileWrapper(File file, String contentType) {
     }
 
     public static class StreamWrapper {
-        public InputStream inputStream;
-        public String name;
-        public String contentType;
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
 
-        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
             this.inputStream = inputStream;
             this.name = name;
             this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                inputStream,
+                name,
+                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index d8dffa1d..a6968667 100644
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index 7d134599..bffdf740 100644
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -46,25 +46,26 @@
 
     private static final String LOG_TAG = "SimpleMultipartEntity";
 
-    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
-    private static final byte[] CR_LF = ("\r\n").getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
-            .getBytes();
+    private static final String STR_CR_LF = "\r\n";
+    private static final byte[] CR_LF = STR_CR_LF.getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY =
+        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+    private final static char[] MULTIPART_CHARS =
+        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary;
-    private byte[] boundaryLine;
-    private byte[] boundaryEnd;
-    private boolean isRepeatable = false;
+    private final String boundary;
+    private final byte[] boundaryLine;
+    private final byte[] boundaryEnd;
+    private boolean isRepeatable;
 
-    private List<FilePart> fileParts = new ArrayList<FilePart>();
+    private final List<FilePart> fileParts = new ArrayList();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
-    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    private ResponseHandlerInterface progressHandler;
+    private final ResponseHandlerInterface progressHandler;
 
     private int bytesWritten;
 
@@ -78,13 +79,13 @@ public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         }
 
         boundary = buf.toString();
-        boundaryLine = ("--" + boundary + "\r\n").getBytes();
-        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
+        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
 
         this.progressHandler = progressHandler;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
+    public void addPart(String key, String value, String contentType) {
         try {
             out.write(boundaryLine);
             out.write(createContentDisposition(key));
@@ -98,7 +99,7 @@ public void addPart(final String key, final String value, final String contentTy
         }
     }
 
-    public void addPart(final String key, final String value) {
+    public void addPart(String key, String value) {
         addPart(key, value, "text/plain; charset=UTF-8");
     }
 
@@ -106,18 +107,13 @@ public void addPart(String key, File file) {
         addPart(key, file, null);
     }
 
-    public void addPart(final String key, File file, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        fileParts.add(new FilePart(key, file, type));
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
     }
 
     public void addPart(String key, String streamName, InputStream inputStream, String type)
             throws IOException {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
+
         out.write(boundaryLine);
 
         // Headers
@@ -135,27 +131,27 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
 
         out.write(CR_LF);
         out.flush();
-        try {
-            inputStream.close();
-        } catch (final IOException e) {
-            // Not important, just log it
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
+
+        AsyncHttpClient.silentCloseOutputStream(out);
+    }
+
+    private String normalizeContentType(String type) {
+       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + type + "\r\n";
+        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
-    private byte[] createContentDisposition(final String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
+            .getBytes();
     }
 
-    private byte[] createContentDisposition(final String key, final String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key, String fileName) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
+            .getBytes();
     }
 
     private void updateProgress(int count) {
@@ -200,20 +196,15 @@ public void writeTo(OutputStream out) throws IOException {
 
             FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
-            int l;
-            while ((l = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-                updateProgress(l);
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
             }
             out.write(CR_LF);
             updateProgress(CR_LF.length);
             out.flush();
-            try {
-                inputStream.close();
-            } catch (final IOException e) {
-                // Not important, just log it
-                Log.w(LOG_TAG, "Cannot close input stream", e);
-            }
+            AsyncHttpClient.silentCloseInputStream(inputStream);
         }
     }
 
diff --git a/maven_push.gradle b/maven_push.gradle
index 7131da65..6fc6fb30 100644
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -15,7 +15,7 @@ if (isReleaseBuild()) {
     println 'DEBUG BUILD'
     sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
 }
-if(isReleaseBuild()){
+
 if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
     if (System.console())
         ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
@@ -98,4 +98,3 @@ afterEvaluate { project ->
         archives androidJavadocsJar
     }
 }
-}
diff --git a/sample/build.gradle b/sample/build.gradle
index af693013..b4fdad60 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.7.+'
+        classpath 'com.android.tools.build:gradle:0.+'
     }
 }
 apply plugin: 'android'
@@ -17,13 +17,18 @@ repositories {
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.1'
+    buildToolsVersion '19.0.3'
 
     defaultConfig {
         minSdkVersion 3
         targetSdkVersion 19
     }
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
     lintOptions {
         abortOnError false
     }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index 182425d2..6deff01f 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -83,7 +83,7 @@ public void onClick(View v) {
     };
 
     protected Header[] getRequestHeaders() {
-        List<Header> headers = new ArrayList<Header>();
+        List<Header> headers = new ArrayList<>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
         if (headersRaw != null && headersRaw.length() > 3) {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
index 568537fe..acf18279 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -11,7 +11,7 @@
 public class ThreadingTimeoutSample extends SampleParentActivity {
 
     private static final String LOG_TAG = "ThreadingTimeoutSample";
-    private SparseArray<String> states = new SparseArray<String>();
+    private SparseArray<String> states = new SparseArray<>();
     private int counter = 0;
 
     @Override
@@ -44,7 +44,7 @@ private synchronized void setStatus(int id, String status) {
         states.put(id, current == null ? status : current + "," + status);
         clearOutputs();
         for (int i = 0; i < states.size(); i++) {
-            debugResponse(LOG_TAG, states.keyAt(i) + ": " + states.get(states.keyAt(i)));
+            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
         }
     }
 
@@ -81,6 +81,10 @@ public void onCancel() {
         };
     }
 
+    public int getCounter() {
+        return counter;
+    }
+
     @Override
     protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
         client.get(this, URL, headers, null, responseHandler);
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 857a0ffb..baeceb96 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -14,7 +14,7 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, samples));
     }
 
     @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
index 2d9d5dda..1398d9d9 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -12,7 +12,7 @@
     public static String convertStreamToString(InputStream is) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(is));
         StringBuilder sb = new StringBuilder();
-        String line = null;
+        String line;
         while ((line = reader.readLine()) != null) {
             sb.append(line).append("\n");
         }
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
new file mode 100644
index 00000000..97ba749b
--- /dev/null
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <EditText
+            android:id="@+id/edit_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:inputType="textUri"/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/button_cancel"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_cancel"/>
+
+            <Button
+                android:id="@+id/button_run"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_run"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
index b32b7b74..d2c7dad6 100644
--- a/sample/src/main/res/layout/parent_layout.xml
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:fillViewport="true">
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
 
     <LinearLayout
         android:focusable="true"
@@ -11,7 +11,7 @@
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
-        <requestFocus />
+        <requestFocus/>
 
         <LinearLayout
             android:id="@+id/layout_url"
@@ -24,20 +24,20 @@
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:layout_weight="1"
-                android:inputType="textUri" />
+                android:inputType="textUri"/>
 
             <Button
                 android:id="@+id/button_run"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="@string/button_run" />
+                android:text="@string/button_run"/>
 
             <Button
                 android:id="@+id/button_cancel"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:visibility="gone"
-                android:text="@string/button_cancel" />
+                android:text="@string/button_cancel"/>
         </LinearLayout>
 
         <LinearLayout
@@ -49,7 +49,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_headers" />
+                android:text="@string/label_headers"/>
 
             <EditText
                 android:id="@+id/edit_headers"
@@ -57,7 +57,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -70,7 +70,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_req_body" />
+                android:text="@string/label_req_body"/>
 
             <EditText
                 android:id="@+id/edit_body"
@@ -78,7 +78,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -86,7 +86,7 @@
             android:id="@+id/layout_response"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:orientation="vertical" />
+            android:orientation="vertical"/>
 
     </LinearLayout>
 </ScrollView>
\ No newline at end of file
