diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 1ad7c0fc..dede71fe 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -5,8 +5,7 @@
     android:versionCode="144">
 
     <uses-sdk
-        android:minSdkVersion="3"
-        android:targetSdkVersion="18" />
+        android:minSdkVersion="3" />
 
     <uses-permission android:name="android.permission.INTERNET" />
 
diff --git a/library/build.gradle b/library/build.gradle
index 680db873..4126bb52 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,9 +1,5 @@
 apply plugin: 'android-library'
 
-dependencies {
-    compile 'com.android.support:support-v4:18.0.+'
-}
-
 android {
     compileSdkVersion 18
     buildToolsVersion '18.0.1'
diff --git a/library/gradle.properties b/library/gradle.properties
index d6aa0de5..96e35d66 100644
--- a/library/gradle.properties
+++ b/library/gradle.properties
@@ -1,3 +1,3 @@
-POM_NAME=ActionBar-PullToRefresh Library
+POM_NAME=android-async-http Library
 POM_ARTIFACT_ID=android-async-http
 POM_PACKAGING=aar
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index 36a7c572..ee695bdd 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -20,7 +20,7 @@
 
 import android.content.Context;
 import com.loopj.android.http.methods.HttpPatch;
-
+import android.util.Log;
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
@@ -104,9 +104,11 @@
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     private static final int DEFAULT_MAX_RETRIES = 5;
+    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
     private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
     private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
     private static final String ENCODING_GZIP = "gzip";
+    private static final String LOG_TAG = "AsyncHttpClient";
 
     private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
     private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
@@ -116,12 +118,90 @@
     private ThreadPoolExecutor threadPool;
     private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
     private final Map<String, String> clientHeaderMap;
+    private boolean isUrlEncodingEnabled = true;
 
 
     /**
-     * Creates a new AsyncHttpClient.
+     * Creates a new AsyncHttpClient with default constructor arguments values
      */
     public AsyncHttpClient() {
+        this(false, 80, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public AsyncHttpClient(int httpPort) {
+        this(false, httpPort, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public AsyncHttpClient(int httpPort, int httpsPort) {
+        this(false, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates new AsyncHttpClient using given params
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));
+    }
+
+    /**
+     * Returns default instance of SchemeRegistry
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        if (fixNoHttpResponseException) {
+            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
+        }
+
+        if (httpPort < 1) {
+            httpPort = 80;
+            Log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
+        }
+
+        if (httpsPort < 1) {
+            httpsPort = 443;
+            Log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
+        }
+
+        // Fix to SSL flaw in API < ICS
+        // See https://code.google.com/p/android/issues/detail?id=13117
+        SSLSocketFactory sslSocketFactory;
+        if (fixNoHttpResponseException)
+            sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
+        else
+            sslSocketFactory = SSLSocketFactory.getSocketFactory();
+
+        SchemeRegistry schemeRegistry = new SchemeRegistry();
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
+        schemeRegistry.register(new Scheme("https", sslSocketFactory, httpsPort));
+
+        return schemeRegistry;
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
+     */
+    public AsyncHttpClient(SchemeRegistry schemeRegistry) {
+
         BasicHttpParams httpParams = new BasicHttpParams();
 
         ConnManagerParams.setTimeout(httpParams, socketTimeout);
@@ -136,9 +216,6 @@ public AsyncHttpClient() {
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
         HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
@@ -170,7 +247,7 @@ public void process(HttpResponse response, HttpContext context) {
                 if (encoding != null) {
                     for (HeaderElement element : encoding.getElements()) {
                         if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
+                            response.setEntity(new InflatingEntity(entity));
                             break;
                         }
                     }
@@ -178,7 +255,7 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
     /**
@@ -262,15 +339,33 @@ public void setTimeout(int timeout) {
     /**
      * Sets the Proxy by it's hostname and port
      *
-     * @param hostname  the hostname (IP or DNS name)
-     * @param port  the port number. -1 indicates the scheme default port.
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
      */
-    public void setProxy(String hostname, int port){
+    public void setProxy(String hostname, int port) {
         final HttpHost proxy = new HttpHost(hostname, port);
         final HttpParams httpParams = this.httpClient.getParams();
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
+    /**
+     * Sets the Proxy by it's hostname,port,username and password
+     *
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
+     * @param username the username
+     * @param password the password
+     */
+    public void setProxy(String hostname, int port, String username, String password) {
+        httpClient.getCredentialsProvider().setCredentials(
+                new AuthScope(hostname, port),
+                new UsernamePasswordCredentials(username, password));
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+    }
+
+
     /**
      * Sets the SSLSocketFactory to user when making requests. By default,
      * a new, default SSLSocketFactory is used.
@@ -282,11 +377,12 @@ public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
     }
 
     /**
-     * Sets the maximum number of retries for a particular Request.
+     * Sets the maximum number of retries and timeout for a particular Request.
+     *
      * @param retries maximum number of retries per request
      */
-    public void setMaxRetries(int retries) {
-        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries));
+    public void setMaxRetriesAndTimeout(int retries, int timeout) {
+        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
     }
 
     /**
@@ -333,6 +429,13 @@ public void setBasicAuth(String username, String password, AuthScope scope) {
         this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
     }
 
+    /**
+     * Removes set basic auth credentials
+     */
+    public void clearBasicAuth() {
+        this.httpClient.getCredentialsProvider().clear();
+    }
+
     /**
      * Cancels any pending (or potentially active) requests associated with the
      * passed Context.
@@ -403,7 +506,7 @@ public void head(Context context, String url, AsyncHttpResponseHandler responseH
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(url, params)), null, responseHandler, context);
+        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -418,7 +521,7 @@ public void head(Context context, String url, RequestParams params, AsyncHttpRes
      *                        the response.
      */
     public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpHead(getUrlWithQueryString(url, params));
+        HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
@@ -470,7 +573,7 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
+        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -485,7 +588,7 @@ public void get(Context context, String url, RequestParams params, AsyncHttpResp
      *                        the response.
      */
     public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+        HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
@@ -526,7 +629,7 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
+        post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -558,7 +661,7 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                      AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if (params != null) request.setEntity(paramsToEntity(params));
+        if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
@@ -620,7 +723,7 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
+        put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -731,13 +834,21 @@ public void delete(Context context, String url, Header[] headers, AsyncHttpRespo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(url, params));
-        if(headers != null) httpDelete.setHeaders(headers);
+        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        if (headers != null) httpDelete.setHeaders(headers);
         sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
-
-    // Private stuff
+    /**
+     * Puts a new request in queue as a new thread in pool to be executed
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete, HttpPost, HttpGet, HttpPut, etc.
+     */
     protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
         if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
@@ -759,7 +870,26 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
         }
     }
 
-    public static String getUrlWithQueryString(String url, RequestParams params) {
+    /**
+     * Sets state of URL encoding feature, see bug #227, this method
+     * allows you to turn off and on this auto-magic feature on-demand.
+     *
+     * @param enabled desired state of feature
+     */
+    public void setURLEncodingEnabled(boolean enabled) {
+        this.isUrlEncodingEnabled = enabled;
+    }
+
+    /**
+     * Will encode url, if not disabled, and adds params on the end of it
+     *
+     * @param url    String with URL, should be valid URL without params
+     * @param params RequestParams to be appended on the end of URL
+     */
+    public static String getUrlWithQueryString(boolean isUrlEncodingEnabled, String url, RequestParams params) {
+        if (isUrlEncodingEnabled)
+            url = url.replace(" ", "%20");
+
         if (params != null) {
             String paramString = params.getParamString();
             if (!url.contains("?")) {
@@ -772,16 +902,40 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
-    private HttpEntity paramsToEntity(RequestParams params) {
+    /**
+     * Returns HttpEntity containing data from RequestParams included with request declaration.
+     * Allows also passing progress from upload via provided ResponseHandler
+     *
+     * @param params          additional request params
+     * @param responseHandler AsyncHttpResponseHandler or its subclass to be notified on progress
+     */
+    private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpEntity entity = null;
 
-        if (params != null) {
-            entity = params.getEntity();
+        try {
+            if (params != null) {
+                entity = params.getEntity(responseHandler);
+            }
+        } catch (Throwable t) {
+            if (responseHandler != null)
+                responseHandler.sendFailureMessage(0, null, t, (String) null);
+            else
+                t.printStackTrace();
         }
 
         return entity;
     }
 
+    public boolean isUrlEncodingEnabled(){
+        return isUrlEncodingEnabled;
+    }
+
+    /**
+     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for example not DELETE
+     *
+     * @param entity      entity to be included within the request
+     * @param requestBase HttpRequest instance, must not be null
+     */
     private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
         if (entity != null) {
             requestBase.setEntity(entity);
@@ -790,6 +944,9 @@ private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosin
         return requestBase;
     }
 
+    /**
+     * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
+     */
     private static class InflatingEntity extends HttpEntityWrapper {
         public InflatingEntity(HttpEntity wrapped) {
             super(wrapped);
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
index f7d9c6fb..339c6c0f 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http;
 
 import org.apache.http.HttpResponse;
+import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.conn.ConnectTimeoutException;
@@ -27,6 +28,7 @@
 
 import java.io.IOException;
 import java.net.ConnectException;
+import java.net.MalformedURLException;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -73,16 +75,19 @@ public void run() {
         }
     }
 
-    private void makeRequest() throws IOException {
+    private void makeRequest() throws IOException, InterruptedException {
         if (!Thread.currentThread().isInterrupted()) {
             try {
+                // Fixes #115
+                if (request.getURI().getScheme() == null)
+                    throw new MalformedURLException("No valid URI scheme was provided");
                 HttpResponse response = client.execute(request, context);
                 if (!Thread.currentThread().isInterrupted()) {
                     if (responseHandler != null) {
                         responseHandler.sendResponseMessage(response);
                     }
                 } else {
-                    //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
+                    throw new InterruptedException("makeRequest was interrupted");
                 }
             } catch (IOException e) {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -102,6 +107,11 @@ private void makeRequestWithRetries() throws ConnectException {
             try {
                 makeRequest();
                 return;
+            } catch (ClientProtocolException e) {
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "cannot repeat the request");
+                }
+                return;
             } catch (UnknownHostException e) {
                 if (responseHandler != null) {
                     responseHandler.sendFailureMessage(e, "can't resolve host");
@@ -131,6 +141,9 @@ private void makeRequestWithRetries() throws ConnectException {
                 // http://code.google.com/p/android/issues/detail?id=5255
                 cause = new IOException("NPE in HttpClient" + e.getMessage());
                 retry = retryHandler.retryRequest(cause, ++executionCount, context);
+            } catch (InterruptedException e) {
+                cause = new IOException("Request was interrupted while executing");
+                retry = retryHandler.retryRequest(cause, ++executionCount, context);
             }
         }
 
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index df297bb8..5525391a 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -72,20 +72,25 @@
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
 
     private Handler handler;
     private String responseCharset = "UTF-8";
 
     /**
      * Sets the charset for the response string. If not set, the default is UTF-8.
-     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
      *
      * @param charset to be used for the response string.
+     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
      */
     public void setCharset(final String charset) {
         this.responseCharset = charset;
     }
 
+    public String getCharset() {
+        return this.responseCharset;
+    }
+
     /**
      * Creates a new AsyncHttpResponseHandler
      */
@@ -106,6 +111,15 @@ public void handleMessage(Message msg) {
     // Callbacks to be overridden, typically anonymously
     //
 
+    /**
+     * Fired when the request progress, override to handle in your own code
+     *
+     * @param bytesWritten offset from start of file
+     * @param totalSize    total size of file
+     */
+    public void onProgress(int bytesWritten, int totalSize) {
+    }
+
     /**
      * Fired when the request is started, override to handle in your own code
      */
@@ -168,21 +182,60 @@ public void onFailure(Throwable error, String content) {
         onFailure(error);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode return HTTP status code
+     * @param error      the underlying cause of the failure
+     * @param content    the response body, if any
+     */
+    public void onFailure(int statusCode, Throwable error, String content) {
+        // By default, call the chain method onFailure(Throwable,String)
+        onFailure(error, content);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode return HTTP status code
+     * @param headers    return headers, if any
+     * @param error      the underlying cause of the failure
+     * @param content    the response body, if any
+     */
+    public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+        // By default, call the chain method onFailure(int,Throwable,String)
+        onFailure(statusCode, error, content);
+    }
+
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
     //
 
+    protected void sendProgressMessage(int bytesWritten, int totalSize) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, totalSize}));
+    }
+
     protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
 
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
+    }
+
+    @Deprecated
     protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
+    }
+
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
     }
 
+    @Deprecated
     protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
     }
 
     protected void sendStartMessage() {
@@ -202,8 +255,8 @@ protected void handleSuccessMessage(int statusCode, Header[] headers, String res
         onSuccess(statusCode, headers, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
     }
 
 
@@ -218,7 +271,7 @@ protected void handleMessage(Message msg) {
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleFailureMessage((Throwable) response[0], (String) response[1]);
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (String) response[3]);
                 break;
             case START_MESSAGE:
                 onStart();
@@ -226,6 +279,10 @@ protected void handleMessage(Message msg) {
             case FINISH_MESSAGE:
                 onFinish();
                 break;
+            case PROGRESS_MESSAGE:
+                response = (Object[]) msg.obj;
+                onProgress((Integer) response[0], (Integer) response[1]);
+                break;
         }
     }
 
@@ -237,10 +294,16 @@ protected void sendMessage(Message msg) {
         }
     }
 
+    protected void postRunnable(Runnable r) {
+        if (r != null) {
+            handler.post(r);
+        }
+    }
+
     protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
+        Message msg;
         if (handler != null) {
-            msg = this.handler.obtainMessage(responseMessage, response);
+            msg = handler.obtainMessage(responseMessage, response);
         } else {
             msg = Message.obtain();
             if (msg != null) {
@@ -253,22 +316,32 @@ protected Message obtainMessage(int responseMessage, Object response) {
 
     // Interface to AsyncHttpRequest
     protected void sendResponseMessage(HttpResponse response) {
+        if (response == null) {
+            sendFailureMessage(0, null, new IllegalStateException("No response"), (String) null);
+            return;
+        }
         StatusLine status = response.getStatusLine();
         String responseBody = null;
         try {
-            HttpEntity entity = null;
+            HttpEntity entity;
             HttpEntity temp = response.getEntity();
             if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, responseCharset);
+                responseBody = EntityUtils.toString(entity, getCharset());
             }
         } catch (IOException e) {
-            sendFailureMessage(e, (String) null);
+            try {
+                if (response.getEntity() != null)
+                    response.getEntity().consumeContent();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (String) null);
             return;
         }
 
         if (status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
             sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
         }
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 0ea4d5c3..aed1faa1 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -56,7 +56,7 @@
  */
 public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
     // Allow images by default
-    private static String[] mAllowedContentTypes = new String[]{
+    private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
             "image/png"
     };
@@ -105,14 +105,16 @@ public void onSuccess(int statusCode, byte[] binaryData) {
     /**
      * Fired when a request fails to complete, override to handle in your own code
      *
+     * @param statusCode response HTTP statuse code
+     * @param headers    response headers, if any
      * @param error      the underlying cause of the failure
      * @param binaryData the response body, if any
      * @deprecated
      */
     @Deprecated
-    public void onFailure(Throwable error, byte[] binaryData) {
+    public void onFailure(int statusCode, Header[] headers, Throwable error, byte[] binaryData) {
         // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
+        onFailure(statusCode, error, null);
     }
 
 
@@ -125,8 +127,8 @@ protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
     }
 
     @Override
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
     }
 
     //
@@ -137,8 +139,8 @@ protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
         onSuccess(statusCode, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
     }
 
     // Methods which emulate android's Handler and Message methods
@@ -152,7 +154,7 @@ protected void handleMessage(Message msg) {
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleFailureMessage((Throwable) response[0], (byte[]) response[1]);
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (byte[]) response[3]);
                 break;
             default:
                 super.handleMessage(msg);
@@ -168,7 +170,7 @@ protected void sendResponseMessage(HttpResponse response) {
         byte[] responseBody = null;
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -180,7 +182,7 @@ protected void sendResponseMessage(HttpResponse response) {
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
             return;
         }
         try {
@@ -191,11 +193,11 @@ protected void sendResponseMessage(HttpResponse response) {
             }
             responseBody = EntityUtils.toByteArray(entity);
         } catch (IOException e) {
-            sendFailureMessage(e, (byte[]) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (byte[]) null);
         }
 
         if (status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
             sendSuccessMessage(status.getStatusCode(), responseBody);
         }
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index b3d477ca..7bb674fc 100644
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -2,6 +2,7 @@
 
 import android.os.Message;
 
+import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
@@ -29,6 +30,18 @@ public void onSuccess(int statusCode, File file) {
     }
 
     public void onFailure(Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e, response);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(statusCode, e, response);
     }
 
 
@@ -36,16 +49,16 @@ protected void sendSuccessMessage(int statusCode, File file) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, file}));
     }
 
-    protected void sendFailureMessage(Throwable e, File file) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, file}));
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, File file) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, file}));
     }
 
     protected void handleSuccessMessage(int statusCode, File responseBody) {
         onSuccess(statusCode, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, File responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, File responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
     }
 
     // Methods which emulate android's Handler and Message methods
@@ -58,7 +71,7 @@ protected void handleMessage(Message msg) {
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleFailureMessage((Throwable) response[0], (File) response[1]);
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (File) response[3]);
                 break;
             default:
                 super.handleMessage(msg);
@@ -84,11 +97,11 @@ protected void sendResponseMessage(HttpResponse response) {
             buffer.close();
 
         } catch (IOException e) {
-            sendFailureMessage(e, this.mFile);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, this.mFile);
         }
 
         if (status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
         } else {
             sendSuccessMessage(status.getStatusCode(), this.mFile);
         }
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 72df100f..8eccbf85 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -117,9 +117,27 @@ public void onSuccess(int statusCode, JSONArray response) {
     }
 
     public void onFailure(Throwable e, JSONObject errorResponse) {
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, JSONObject errorResponse) {
+        onFailure(e, errorResponse);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONObject errorResponse) {
+        onFailure(statusCode, e, errorResponse);
     }
 
     public void onFailure(Throwable e, JSONArray errorResponse) {
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, JSONArray errorResponse) {
+        onFailure(e, errorResponse);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray errorResponse) {
+        onFailure(statusCode, e, errorResponse);
     }
 
 
@@ -134,15 +152,25 @@ protected void sendSuccessMessage(final int statusCode, final Header[] headers,
                 @Override
                 public void run() {
                     try {
-                        Object jsonResponse = parseResponse(responseBody);
-                        sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
-                    } catch (JSONException e) {
-                        sendFailureMessage(e, responseBody);
+                        final Object jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+                            }
+                        });
+                    } catch (final JSONException e) {
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                sendFailureMessage(statusCode, headers, e, responseBody);
+                            }
+                        });
                     }
                 }
             }).start();
         } else {
-            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
+            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, new JSONObject()}));
         }
     }
 
@@ -168,12 +196,16 @@ protected void handleSuccessJsonMessage(int statusCode, Header[] headers, Object
             onSuccess(statusCode, headers, (JSONObject) jsonResponse);
         } else if (jsonResponse instanceof JSONArray) {
             onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+        } else if (jsonResponse instanceof String) {
+            onSuccess(statusCode, headers, (String) jsonResponse);
         } else {
             onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
         }
     }
 
     protected Object parseResponse(String responseBody) throws JSONException {
+        if (null == responseBody)
+            return null;
         Object result = null;
         //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
         responseBody = responseBody.trim();
@@ -187,30 +219,42 @@ protected Object parseResponse(String responseBody) throws JSONException {
     }
 
     @Override
-    protected void handleFailureMessage(final Throwable e, final String responseBody) {
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    if (responseBody != null) {
-                        Object jsonResponse = parseResponse(responseBody);
-                        if (jsonResponse instanceof JSONObject) {
-                            onFailure(e, (JSONObject) jsonResponse);
-                        } else if (jsonResponse instanceof JSONArray) {
-                            onFailure(e, (JSONArray) jsonResponse);
-                        } else if (jsonResponse instanceof String) {
-                            onFailure(e, (String) jsonResponse);
-                        } else {
-                            onFailure(e, responseBody);
-                        }
-                    } else {
-                        onFailure(e, "");
+    protected void handleFailureMessage(final int statusCode, final Header[] headers, final Throwable e, final String responseBody) {
+        if (responseBody != null) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final Object jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (jsonResponse instanceof JSONObject) {
+                                    onFailure(statusCode, headers, e, (JSONObject) jsonResponse);
+                                } else if (jsonResponse instanceof JSONArray) {
+                                    onFailure(statusCode, headers, e, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, e, (String) jsonResponse);
+                                } else {
+                                    onFailure(statusCode, headers, e, responseBody);
+                                }
+                            }
+                        });
+
+                    } catch (JSONException ex) {
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, e, responseBody);
+                            }
+                        });
+
                     }
-                } catch (JSONException ex) {
-                    onFailure(e, responseBody);
                 }
-            }
-        }).start();
+            }).start();
+        } else {
+            onFailure(e, "");
+        }
 
     }
 }
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/com/loopj/android/http/MySSLSocketFactory.java
new file mode 100644
index 00000000..fdfbffc9
--- /dev/null
+++ b/library/src/com/loopj/android/http/MySSLSocketFactory.java
@@ -0,0 +1,83 @@
+package com.loopj.android.http;
+
+import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * This file is introduced to fix HTTPS Post bug on API &lt; ICS
+ * see http://code.google.com/p/android/issues/detail?id=13117#c14
+ */
+public class MySSLSocketFactory extends SSLSocketFactory {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+
+    public MySSLSocketFactory(KeyStore truststore)
+            throws NoSuchAlgorithmException, KeyManagementException,
+            KeyStoreException, UnrecoverableKeyException {
+        super(truststore);
+
+        TrustManager tm = new X509TrustManager() {
+            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                return null;
+            }
+
+            @Override
+            public void checkClientTrusted(
+                    java.security.cert.X509Certificate[] chain, String authType)
+                    throws java.security.cert.CertificateException {
+            }
+
+            @Override
+            public void checkServerTrusted(
+                    java.security.cert.X509Certificate[] chain, String authType)
+                    throws java.security.cert.CertificateException {
+            }
+        };
+        sslContext.init(null, new TrustManager[]{tm}, null);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslContext.getSocketFactory().createSocket();
+    }
+
+    public static KeyStore getKeystore() {
+        KeyStore trustStore = null;
+        try {
+            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            trustStore.load(null, null);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+        return trustStore;
+    }
+
+    public static SSLSocketFactory getFixedSocketFactory() {
+        SSLSocketFactory socketFactory;
+        try {
+            socketFactory = new MySSLSocketFactory(getKeystore());
+            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+        } catch (Throwable t) {
+            t.printStackTrace();
+            socketFactory = SSLSocketFactory.getSocketFactory();
+        }
+        return socketFactory;
+    }
+
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
index 7f9eae96..05a6e3d8 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -22,15 +22,19 @@
 import org.apache.http.client.entity.UrlEncodedFormEntity;
 import org.apache.http.client.utils.URLEncodedUtils;
 import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.protocol.HTTP;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -47,17 +51,48 @@
  * params.put("profile_picture", new File("pic.jpg")); // Upload a File
  * params.put("profile_picture2", someInputStream); // Upload an InputStream
  * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
+ * 
+ * Map<String, String> map = new HashMap<String, String>();
+ * map.put("first_name", "James");
+ * map.put("last_name", "Smith");
+ * params.put("user", map); // url params: "user[first_name]=James&user[last_name]=Smith"
+ *
+ * Set<String> set = new HashSet<String>(); // unordered collection
+ * set.add("music");
+ * set.add("art");
+ * params.put("like", set); // url params: "like=music&like=art"
+ * 
+ * List<String> list = new ArrayList<String>(); // Ordered collection
+ * list.add("Java");
+ * list.add("C");
+ * params.put("languages", list); // url params: "languages[]=Java&languages[]=C"
+ * 
+ * String[] colors = { "blue", "yellow" }; // Ordered collection
+ * params.put("colors", colors); // url params: "colors[]=blue&colors[]=yellow"
+ * 
+ * List<Map<String, String>> listOfMaps = new ArrayList<Map<String, String>>();
+ * Map<String, String> user1 = new HashMap<String, String>();
+ * user1.put("age", "30");
+ * user1.put("gender", "male");
+ * Map<String, String> user2 = new HashMap<String, String>();
+ * user2.put("age", "25");
+ * user2.put("gender", "female");
+ * listOfMaps.add(user1);
+ * listOfMaps.add(user2);
+ * params.put("users", listOfMaps); // url params: "users[][age]=30&users[][gender]=male&users[][age]=25&users[][gender]=female"
  *
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.post("http://myendpoint.com", params, responseHandler);
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
+
+    private static final String LOG_TAG = "RequestParams";
 
     protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
+    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
 
     /**
      * Constructs a new empty <code>RequestParams</code> instance.
@@ -125,56 +160,28 @@ public void put(String key, String value) {
         }
     }
 
-    /**
-     * Adds a integer param to the request.
-     *
-     * @param key   the key name for the new param.
-     * @param value the integer value for the new param.
-     */
-    public void put(String key, int value) {
-        if (key != null) {
-            urlParams.put(key, String.valueOf(value));
-        }
-    }
-
     /**
      * Adds a file to the request.
      *
      * @param key  the key name for the new param.
      * @param file the file to add.
-     *
-     * @throws java.io.FileNotFoundException if the file is not found
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
      */
     public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
-    }
-
-    /**
-     * Adds param with more than one value.
-     *
-     * @param key    the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values) {
-        if (key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
+        put(key, file, null);
     }
 
     /**
-     * Adds value to param which can have more than one value.
+     * Adds a file to the request.
      *
-     * @param key   the key name for the param, either existing or new.
-     * @param value the value string for the new param.
+     * @param key         the key name for the new param.
+     * @param file        the file to add.
+     * @param contentType the content type of the file, eg. application/json
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
      */
-    public void add(String key, String value) {
-        if (key != null && value != null) {
-            ArrayList<String> paramArray = urlParamsWithArray.get(key);
-            if (paramArray == null) {
-                paramArray = new ArrayList<String>();
-                this.put(key, paramArray);
-            }
-            paramArray.add(value);
+    public void put(String key, File file, String contentType) throws FileNotFoundException {
+        if (key != null && file != null) {
+            fileParams.put(key, new FileWrapper(file, contentType));
         }
     }
 
@@ -191,12 +198,12 @@ public void put(String key, InputStream stream) {
     /**
      * Adds an input stream to the request.
      *
-     * @param key      the key name for the new param.
-     * @param stream   the input stream to add.
-     * @param fileName the name of the file.
+     * @param key    the key name for the new param.
+     * @param stream the input stream to add.
+     * @param name   the name of the stream.
      */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
+    public void put(String key, InputStream stream, String name) {
+        put(key, stream, name, null);
     }
 
     /**
@@ -204,15 +211,47 @@ public void put(String key, InputStream stream, String fileName) {
      *
      * @param key         the key name for the new param.
      * @param stream      the input stream to add.
-     * @param fileName    the name of the file.
+     * @param name        the name of the stream.
      * @param contentType the content type of the file, eg. application/json
      */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
+    public void put(String key, InputStream stream, String name, String contentType) {
         if (key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+            streamParams.put(key, new StreamWrapper(stream, name, contentType));
         }
     }
 
+    /**
+     * Adds param with non-string value (e.g. Map, List, Set).
+     * @param key   the key name for the new param.
+     * @param value the non-string value object for the new param.
+     */
+    public void put(String key, Object value)  {
+        if (key != null && value != null) {
+            urlParamsWithObjects.put(key, value);
+        }
+    }
+            
+    /**
+     * Adds string value to param which can have more than one value.
+     * @param key   the key name for the param, either existing or new.
+     * @param value the value string for the new param.
+     */
+    public void add(String key, String value) {
+        if (key != null && value != null) {
+            Object params = urlParamsWithObjects.get(key);
+            if (params == null) {
+                // Backward compatible, which will result in "k=v1&k=v2&k=v3"
+                params = new HashSet<String>();
+                this.put(key, params);
+            }
+            if (params instanceof List) {
+                ((List<Object>) params).add(value);
+            } else if (params instanceof Set) {
+                ((Set<Object>) params).add(value);
+            }
+        }
+    }
+    
     /**
      * Removes a parameter from the request.
      *
@@ -220,8 +259,9 @@ public void put(String key, InputStream stream, String fileName, String contentT
      */
     public void remove(String key) {
         urlParams.remove(key);
+        streamParams.remove(key);
         fileParams.remove(key);
-        urlParamsWithArray.remove(key);
+        urlParamsWithObjects.remove(key);
     }
 
     @Override
@@ -236,6 +276,15 @@ public String toString() {
             result.append(entry.getValue());
         }
 
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("STREAM");
+        }
+
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
             if (result.length() > 0)
                 result.append("&");
@@ -245,18 +294,14 @@ public String toString() {
             result.append("FILE");
         }
 
-        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
             if (result.length() > 0)
                 result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (int i = 0; i < values.size(); i++) {
-                if (i != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(values.get(i));
-            }
+            
+            result.append(kv.getName());
+            result.append("=");
+            result.append(kv.getValue());
         }
 
         return result.toString();
@@ -265,59 +310,63 @@ public String toString() {
     /**
      * Returns an HttpEntity containing all request parameters
      *
-     * @return an HttpEntity containing all request parameters
+     * @param progressHandler HttpResponseHandler for reporting progress on entity submit
+     * @return HttpEntity resulting HttpEntity to be included along with {@link org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
+     * @throws IOException if one of the streams cannot be read
      */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
+    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+            return createFormEntity();
+        } else {
+            return createMultipartEntity(progressHandler);
+        }
+    }
 
-        if (!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+    private HttpEntity createFormEntity() {
+        try {
+            return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
+        } catch (UnsupportedEncodingException e) {
+            return null; // Actually cannot happen when using utf-8
+        }
+    }
 
-            // Add string params
-            for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
+    private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
 
-            // Add dupe params
-            for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
 
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if (file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if (file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
-            }
+        // Add non-string params
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
+        	entity.addPart(kv.getName(), kv.getValue());
+        }
 
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
+                        stream.contentType);
             }
         }
 
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+        }
+
         return entity;
     }
 
     private void init() {
         urlParams = new ConcurrentHashMap<String, String>();
+        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
+        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
     }
 
     protected List<BasicNameValuePair> getParamsList() {
@@ -327,37 +376,69 @@ private void init() {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
         }
 
-        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
-        }
+        lparams.addAll(getParamsList(null, urlParamsWithObjects));
 
         return lparams;
     }
 
+    private List<BasicNameValuePair> getParamsList(String key, Object value) {
+        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
+        if (value instanceof Map) {
+            Map<String, Object> map = (Map<String, Object>) value;
+            List<String> list = new ArrayList<String>(map.keySet());
+            // Ensure consistent ordering in query string
+            Collections.sort(list);
+            for (String nestedKey : list) {
+                Object nestedValue = map.get(nestedKey);
+                if (nestedValue != null) {
+                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
+                            nestedValue));
+                }
+            }
+        } else if (value instanceof List) {
+            List<Object> list = (List<Object>) value;
+            for (Object nestedValue : list) {
+                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            }
+        } else if (value instanceof Object[]) {
+            Object[] array = (Object[]) value;
+            for (Object nestedValue : array) {
+                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            }
+        } else if (value instanceof Set) {
+            Set<Object> set = (Set<Object>) value;
+            for (Object nestedValue : set) {
+                params.addAll(getParamsList(key, nestedValue));
+            }
+        } else if (value instanceof String) {
+            params.add(new BasicNameValuePair(key, (String) value));
+        }
+        return params;
+    }
+    
     protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
+        return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
 
     private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
+        public File file;
         public String contentType;
 
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
+        public FileWrapper(File file, String contentType) {
+            this.file = file;
             this.contentType = contentType;
         }
+    }
 
-        public String getFileName() {
-            if (fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
+    private static class StreamWrapper {
+        public InputStream inputStream;
+        public String name;
+        public String contentType;
+
+        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+            this.inputStream = inputStream;
+            this.name = name;
+            this.contentType = contentType;
         }
     }
 }
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
index 01c89495..967ac11b 100644
--- a/library/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -39,7 +39,6 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
     private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
     private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
@@ -58,9 +57,11 @@
     }
 
     private final int maxRetries;
+    private final int retrySleepTimeMS;
 
-    public RetryHandler(int maxRetries) {
+    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
         this.maxRetries = maxRetries;
+        this.retrySleepTimeMS = retrySleepTimeMS;
     }
 
     @Override
@@ -87,12 +88,15 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         if (retry) {
             // resend all idempotent requests
             HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
-            String requestType = currentReq != null ? currentReq.getMethod() : "";
+            if (currentReq == null) {
+                return false;
+            }
+            String requestType = currentReq.getMethod();
             retry = !requestType.equals("POST");
         }
 
         if (retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+            SystemClock.sleep(retrySleepTimeMS);
         } else {
             exception.printStackTrace();
         }
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
index c6e804b4..f060e64f 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -23,6 +23,8 @@
 
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
@@ -30,120 +32,214 @@
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
+/**
+ * Simplified multipart entity mainly used for sending one or more files.
+ */
 class SimpleMultipartEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "SimpleMultipartEntity";
+
+    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
+    private static final byte[] CR_LF = ("\r\n").getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
+            .getBytes();
+
     private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary = null;
+    private String boundary;
+    private byte[] boundaryLine;
+    private byte[] boundaryEnd;
+
+    private List<FilePart> fileParts = new ArrayList<FilePart>();
+
+    // The buffer we use for building the message excluding files and the last
+    // boundary
+    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    private AsyncHttpResponseHandler progressHandler;
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
+    private int bytesWritten;
 
-    public SimpleMultipartEntity() {
+    private int totalSize;
+
+    public SimpleMultipartEntity(AsyncHttpResponseHandler progressHandler) {
         final StringBuilder buf = new StringBuilder();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
         }
-        this.boundary = buf.toString();
 
+        boundary = buf.toString();
+        boundaryLine = ("--" + boundary + "\r\n").getBytes();
+        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+
+        this.progressHandler = progressHandler;
     }
 
-    public void writeFirstBoundaryIfNeeds() {
-        if (!isSetFirst) {
-            writeBoundary();
+    public void addPart(final String key, final String value, final String contentType) {
+        try {
+            out.write(boundaryLine);
+            out.write(createContentDisposition(key));
+            out.write(createContentType(contentType));
+            out.write(CR_LF);
+            out.write(value.getBytes());
+            out.write(CR_LF);
+        } catch (final IOException e) {
+            // Can't happen on ByteArrayOutputStream
+            Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
         }
+    }
 
-        isSetFirst = true;
+    public void addPart(final String key, final String value) {
+        addPart(key, value, "text/plain; charset=UTF-8");
     }
 
-    public void writeBoundary() {
-        try {
-            out.write(("--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
+    public void addPart(String key, File file) {
+        addPart(key, file, null);
+    }
+
+    public void addPart(final String key, File file, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
         }
+        fileParts.add(new FilePart(key, file, type));
     }
 
-    public void writeLastBoundaryIfNeeds() {
-        if (isSetLast) {
-            return;
+    public void addPart(String key, String streamName, InputStream inputStream, String type)
+            throws IOException {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        out.write(boundaryLine);
+
+        // Headers
+        out.write(createContentDisposition(key, streamName));
+        out.write(createContentType(type));
+        out.write(TRANSFER_ENCODING_BINARY);
+        out.write(CR_LF);
+
+        // Stream (file)
+        final byte[] tmp = new byte[4096];
+        int l;
+        while ((l = inputStream.read(tmp)) != -1) {
+            out.write(tmp, 0, l);
         }
 
+        out.write(CR_LF);
+        out.flush();
         try {
-            out.write(("--" + boundary + "--\r\n").getBytes());
-            out.flush();
+            inputStream.close();
         } catch (final IOException e) {
-            e.printStackTrace();
+            // Not important, just log it
+            Log.w(LOG_TAG, "Cannot close input stream", e);
         }
+    }
 
-        isSetLast = true;
+    private byte[] createContentType(String type) {
+        String result = "Content-Type: " + type + "\r\n";
+        return result.getBytes();
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
-        writeBoundary();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" + key + "\"\r\n").getBytes());
-            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
+    private byte[] createContentDisposition(final String key) {
+        return new StringBuilder()
+                .append("Content-Disposition: form-data; name=\"")
+                .append(key)
+                .append("\"\r\n")
+                .toString()
+                .getBytes();
     }
 
-    public void addPart(final String key, final String value) {
-        addPart(key, value, "text/plain; charset=UTF-8");
+    private byte[] createContentDisposition(final String key, final String fileName) {
+        return new StringBuilder()
+                .append("Content-Disposition: form-data; name=\"")
+                .append(key)
+                .append("\"; filename=\"")
+                .append(fileName)
+                .append("\"\r\n")
+                .toString()
+                .getBytes();
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast) {
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    private void updateProgress(int count) {
+        bytesWritten += count;
+        progressHandler.sendProgressMessage(bytesWritten, totalSize);
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast) {
-        writeBoundary();
-        try {
-            type = "Content-Type: " + type + "\r\n";
-            out.write(("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+    private class FilePart {
+        public File file;
+        public byte[] header;
 
+        public FilePart(String key, File file, String type) {
+            header = createHeader(key, file.getName(), type);
+            this.file = file;
+        }
+
+        private byte[] createHeader(String key, String filename, String type) {
+            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
+            try {
+                headerStream.write(boundaryLine);
+
+                // Headers
+                headerStream.write(createContentDisposition(key, filename));
+                headerStream.write(createContentType(type));
+                headerStream.write(TRANSFER_ENCODING_BINARY);
+                headerStream.write(CR_LF);
+            } catch (IOException e) {
+                // Can't happen on ByteArrayOutputStream
+                Log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
+            }
+            return headerStream.toByteArray();
+        }
+
+        public long getTotalLength() {
+            long streamLength = file.length();
+            return header.length + streamLength;
+        }
+
+        public void writeTo(OutputStream out) throws IOException {
+            out.write(header);
+            updateProgress(header.length);
+
+            FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
             int l;
-            while ((l = fin.read(tmp)) != -1) {
+            while ((l = inputStream.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
+                updateProgress(l);
             }
-            out.write(("\r\n").getBytes());
-
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
+            out.write(CR_LF);
+            updateProgress(CR_LF.length);
+            out.flush();
             try {
-                fin.close();
+                inputStream.close();
             } catch (final IOException e) {
-                e.printStackTrace();
+                // Not important, just log it
+                Log.w(LOG_TAG, "Cannot close input stream", e);
             }
         }
     }
 
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
+    // The following methods are from the HttpEntity interface
 
     @Override
     public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
+        long contentLen = out.size();
+        for (FilePart filePart : fileParts) {
+            long len = filePart.getTotalLength();
+            if (len < 0) {
+                return -1; // Should normally not happen
+            }
+            contentLen += len;
+        }
+        contentLen += boundaryEnd.length;
+        return contentLen;
     }
 
     @Override
@@ -168,8 +264,16 @@ public boolean isStreaming() {
 
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
-        writeLastBoundaryIfNeeds();
-        outstream.write(out.toByteArray());
+        bytesWritten = 0;
+        totalSize = (int) getContentLength();
+        out.writeTo(outstream);
+        updateProgress(out.size());
+
+        for (FilePart filePart : fileParts) {
+            filePart.writeTo(outstream);
+        }
+        outstream.write(boundaryEnd);
+        updateProgress(boundaryEnd.length);
     }
 
     @Override
@@ -178,8 +282,7 @@ public Header getContentEncoding() {
     }
 
     @Override
-    public void consumeContent() throws IOException,
-            UnsupportedOperationException {
+    public void consumeContent() throws IOException, UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
                     "Streaming entity does not implement #consumeContent()");
@@ -187,9 +290,8 @@ public void consumeContent() throws IOException,
     }
 
     @Override
-    public InputStream getContent() throws IOException,
-            UnsupportedOperationException {
-        writeLastBoundaryIfNeeds();
-        return new ByteArrayInputStream(out.toByteArray());
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw new UnsupportedOperationException(
+                "getContent() is not supported. Use writeTo() instead.");
     }
 }
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
index 99722b33..59a97566 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -4,6 +4,7 @@
 import android.os.Message;
 
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
@@ -19,7 +20,7 @@
     protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
 
         @Override
-        protected void sendResponseMessage(org.apache.http.HttpResponse response) {
+        protected void sendResponseMessage(HttpResponse response) {
             responseCode = response.getStatusLine().getStatusCode();
             super.sendResponseMessage(response);
         };
@@ -27,7 +28,7 @@ protected void sendResponseMessage(org.apache.http.HttpResponse response) {
         @Override
         protected void sendMessage(Message msg) {
             /*
-			 * Dont use the handler and send it directly to the analysis
+             * Dont use the handler and send it directly to the analysis
 			 * (because its all the same thread)
 			 */
             handleMessage(msg);
@@ -63,7 +64,7 @@ protected void sendRequest(DefaultHttpClient client,
         }
 
 		/*
-		 * will execute the request directly
+         * will execute the request directly
 		 */
         new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
                 .run();
@@ -73,13 +74,12 @@ protected void sendRequest(DefaultHttpClient client,
 
     public void delete(String url, RequestParams queryParams,
                        AsyncHttpResponseHandler responseHandler) {
-        // TODO what about query params??
-        delete(url, responseHandler);
+        delete(getUrlWithQueryString(isUrlEncodingEnabled(), url, queryParams), responseHandler);
     }
 
     public String get(String url, RequestParams params) {
         this.get(url, params, responseHandler);
-		/*
+        /*
 		 * the response handler will have set the result when this line is
 		 * reached
 		 */
@@ -101,7 +101,7 @@ public String put(String url) {
         return result;
     }
 
-    public String post(String url, HttpEntity entity){
+    public String post(String url, HttpEntity entity) {
         this.post(null, url, entity, null, responseHandler);
         return result;
     }
diff --git a/sample/.gitignore b/sample/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/sample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
new file mode 100644
index 00000000..d7ef938f
--- /dev/null
+++ b/sample/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.loopj.android.http.sample"
+    android:versionName="1.4.4-SNAPSHOT"
+    android:versionCode="144">
+
+    <uses-sdk
+        android:minSdkVersion="3"
+        android:targetSdkVersion="18" />
+
+    <application
+        android:name="Android Async Http Sample"
+        android:allowBackup="true"
+        android:allowClearUserData="true">
+        <activity android:name=".MainActivity" />
+    </application>
+
+</manifest> 
diff --git a/sample/build.gradle b/sample/build.gradle
new file mode 100644
index 00000000..20fdcb60
--- /dev/null
+++ b/sample/build.gradle
@@ -0,0 +1,30 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.6.+'
+    }
+}
+apply plugin: 'android'
+
+repositories {
+    mavenCentral()
+    maven {
+        url "https://oss.sonatype.org/content/repositories/snapshots/"
+    }
+}
+
+android {
+    compileSdkVersion 18
+    buildToolsVersion "18.0.1"
+
+    defaultConfig {
+        minSdkVersion 3
+        targetSdkVersion 18
+    }
+}
+
+dependencies {
+    compile project(':library')
+}
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..8ad41e76
--- /dev/null
+++ b/sample/src/main/AndroidManifest.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.loopj.android.http.sample"
+    android:versionCode="1"
+    android:versionName="1.0">
+
+    <permission android:name="android.permission.INTERNET" />
+
+    <uses-sdk
+        android:minSdkVersion="3"
+        android:targetSdkVersion="18" />
+
+    <application
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity android:name="com.loopj.android.http.sample.MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
new file mode 100644
index 00000000..f5096ae2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
@@ -0,0 +1,161 @@
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.URI;
+
+public class MainActivity extends Activity implements View.OnClickListener {
+
+    private AsyncHttpClient aclient = new AsyncHttpClient(false, 80, 443);
+    private TextView statusCode, headers, contents, state, error;
+    private EditText url;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        Button get = (Button) findViewById(R.id.request_get);
+        statusCode = (TextView) findViewById(R.id.return_code);
+        headers = (TextView) findViewById(R.id.return_headers);
+        contents = (TextView) findViewById(R.id.return_data);
+        state = (TextView) findViewById(R.id.current_state);
+        error = (TextView) findViewById(R.id.return_error);
+        url = (EditText) findViewById(R.id.request_url);
+
+        get.setOnClickListener(this);
+    }
+
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.main, menu);
+        return true;
+    }
+
+    @Override
+    public void onClick(View v) {
+        switch (v.getId()) {
+            case R.id.request_get:
+                if (verifyUrl()) {
+                    startRequest();
+                }
+                break;
+        }
+    }
+
+    private void startRequest() {
+        aclient.get(this, getURLString(), new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String content) {
+                setStatusMessage("Succeeded", Color.parseColor("#DD00FF00"));
+                printThrowable(null);
+                printHeaders(headers);
+                printContents(content);
+                printStatusCode(statusCode);
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+                setStatusMessage("Failed", Color.parseColor("#99FF0000"));
+                printThrowable(error);
+                printHeaders(headers);
+                printContents(content);
+                printStatusCode(statusCode);
+            }
+
+            @Override
+            public void onStart() {
+                setStatusMessage("Started", Color.parseColor("#EE00FF00"));
+            }
+
+            @Override
+            public void onFinish() {
+                setStatusMessage("Finished", 0);
+            }
+        });
+    }
+
+    private void printThrowable(Throwable error) {
+        if (this.error != null) {
+            if (error != null) {
+                StringWriter sw = new StringWriter();
+                error.printStackTrace(new PrintWriter(sw));
+                this.error.setText(sw.toString());
+            } else {
+                this.error.setText(null);
+            }
+        }
+    }
+
+    private void printStatusCode(int statusCode) {
+        if (this.statusCode != null) {
+            this.statusCode.setText(String.format("HTTP Status Code: %d", statusCode));
+        }
+    }
+
+    private void printContents(String content) {
+        if (this.contents != null) {
+            if (content == null)
+                contents.setText("Return is NULL");
+            else
+                contents.setText(content);
+        }
+    }
+
+    private void printHeaders(Header[] headers) {
+        if (this.headers != null) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("Headers:");
+            if (headers != null) {
+                for (Header h : headers) {
+                    sb.append("\n").append(h.getName()).append(": ").append(h.getValue());
+                }
+            }
+            this.headers.setText(sb.toString());
+        }
+    }
+
+    private void setStatusMessage(String message, int color) {
+        if (state != null) {
+            state.setText(String.format("Status: %s", message));
+            if (color != 0)
+                state.setBackgroundColor(color);
+        }
+    }
+
+    private String getURLString() {
+        return url.getText() != null ? url.getText().toString() : null;
+    }
+
+    private boolean verifyUrl() {
+        String contents = getURLString();
+        if (contents != null) {
+            try {
+                URI.create(contents);
+                return true;
+            } catch (Throwable t) {
+                Toast.makeText(this, "Given URL is not valid", Toast.LENGTH_SHORT).show();
+                t.printStackTrace();
+                return false;
+            }
+        }
+        Toast.makeText(this, "You must fill in URL", Toast.LENGTH_SHORT).show();
+        return false;
+    }
+}
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 00000000..96a442e5
Binary files /dev/null and b/sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 00000000..359047df
Binary files /dev/null and b/sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..71c6d760
Binary files /dev/null and b/sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
new file mode 100644
index 00000000..27cb01e6
--- /dev/null
+++ b/sample/src/main/res/layout/activity_main.xml
@@ -0,0 +1,75 @@
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        tools:context=".MainActivity">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <EditText
+                android:id="@+id/request_url"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:inputType="textUri"
+                android:saveEnabled="true"
+                android:text="https://raw.github.com/loopj/android-async-http/master/README.md" />
+
+            <Button
+                android:id="@+id/request_get"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="GET" />
+
+        </LinearLayout>
+
+        <TextView
+            android:id="@+id/current_state"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:background="#33000000"
+            android:padding="5dip"
+            android:text="Not Yet Started" />
+
+        <TextView
+            android:id="@+id/return_code"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:background="#11000000"
+            android:padding="5dip" />
+
+        <TextView
+            android:id="@+id/return_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:background="#33000000"
+            android:padding="5dip" />
+
+        <TextView
+            android:id="@+id/return_error"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:background="#99FF0000"
+            android:padding="5dip" />
+
+        <TextView
+            android:id="@+id/return_data"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:background="#11000000"
+            android:padding="5dip" />
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/menu/main.xml b/sample/src/main/res/menu/main.xml
new file mode 100644
index 00000000..f3b10b6c
--- /dev/null
+++ b/sample/src/main/res/menu/main.xml
@@ -0,0 +1,6 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/action_settings"
+        android:title="@string/action_settings"
+        android:orderInCategory="100"
+        android:showAsAction="never" />
+</menu>
diff --git a/sample/src/main/res/values-sw600dp/dimens.xml b/sample/src/main/res/values-sw600dp/dimens.xml
new file mode 100644
index 00000000..886b05fa
--- /dev/null
+++ b/sample/src/main/res/values-sw600dp/dimens.xml
@@ -0,0 +1,4 @@
+<resources>
+    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
+         screen margins) for sw600dp devices (e.g. 7" tablets) here. -->
+</resources>
diff --git a/sample/src/main/res/values-sw720dp-land/dimens.xml b/sample/src/main/res/values-sw720dp-land/dimens.xml
new file mode 100644
index 00000000..00059fc5
--- /dev/null
+++ b/sample/src/main/res/values-sw720dp-land/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
+         screen margins) for sw720dp devices (e.g. 10" tablets) in landscape here. -->
+    <dimen name="activity_horizontal_margin">128dp</dimen>
+</resources>
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
new file mode 100644
index 00000000..3c02242a
--- /dev/null
+++ b/sample/src/main/res/values-v11/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
new file mode 100644
index 00000000..a91fd037
--- /dev/null
+++ b/sample/src/main/res/values-v14/styles.xml
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/sample/src/main/res/values/dimens.xml b/sample/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/sample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
new file mode 100644
index 00000000..de2d6b37
--- /dev/null
+++ b/sample/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Android Async Http Sample</string>
+    <string name="action_settings">Settings</string>
+    <string name="hello_world">Hello world!</string>
+
+</resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
new file mode 100644
index 00000000..6ce89c7b
--- /dev/null
+++ b/sample/src/main/res/values/styles.xml
@@ -0,0 +1,20 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
+    </style>
+
+</resources>
diff --git a/settings.gradle b/settings.gradle
index e469038a..612d9e44 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1,2 @@
-include 'library'
+include ':library'
+include ':sample'
