diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
index 133398d4..8a86348a 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -19,8 +19,6 @@
 package com.loopj.android.http;
 
 import java.io.IOException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 
 import org.apache.http.HttpResponse;
@@ -89,12 +87,6 @@ private void makeRequestWithRetries() throws IOException {
                     // (to assist in genuine cases of unknown host) which seems better than outright failure
                     cause = new IOException("UnknownHostException exception: " + e.getMessage());
                     retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
-                } catch ( SocketException e ) {
-                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
-                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
-                } catch (SocketTimeoutException e) {
-                    cause = new IOException("SocketTimeoutException exception: " + e.getMessage());
-                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 } catch (IOException e) {
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
diff --git a/src/com/loopj/android/http/RetryHandler.java b/src/com/loopj/android/http/RetryHandler.java
index 70bef056..30759458 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/src/com/loopj/android/http/RetryHandler.java
@@ -14,12 +14,12 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 /*
-    Some of the retry logic in this class is heavily borrowed from the
-    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
-*/
+ Some of the retry logic in this class is heavily borrowed from the
+ fantastic droid-fu project: https://github.com/donnfelker/droid-fu
+ */
 
 package com.loopj.android.http;
 
@@ -41,74 +41,74 @@
 import android.os.SystemClock;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
-
-    static {
-        // Retry if the server dropped connection on us
-        exceptionWhitelist.add(NoHttpResponseException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(UnknownHostException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(SocketException.class);
-
-        // never retry timeouts
-        exceptionBlacklist.add(InterruptedIOException.class);
-        // never retry SSL handshake failures
-        exceptionBlacklist.add(SSLException.class);
-    }
-
-    private final int maxRetries;
-    private final int retrySleepTimeMS;
-
-    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
-        this.maxRetries = maxRetries;
-        this.retrySleepTimeMS = retrySleepTimeMS;
-    }
-
-    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-        boolean retry = true;
-
-        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
-
-        if(executionCount > maxRetries) {
-            // Do not retry if over max retry count
-            retry = false;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
-        } else if (isInList(exceptionWhitelist, exception)) {
-            // immediately retry if error is whitelisted
-            retry = true;
-        } else if (!sent) {
-            // for most other errors, retry only if request hasn't been fully sent yet
-            retry = true;
-        }
-
-        if(retry) {
-            // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
-        }
-
-        if (retry) {
-            SystemClock.sleep(retrySleepTimeMS);
-        } else {
-            exception.printStackTrace();
-        }
-
-        return retry;
-    }
-    
-    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-    	Iterator<Class<?>> itr = list.iterator();
-    	while (itr.hasNext()) {
-    		if (itr.next().isInstance(error)) {
-    			return true;
-    		}
-    	}
-    	return false;
-    }
+	private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+	private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+
+	static {
+		// Retry if the server dropped connection on us
+		exceptionWhitelist.add(NoHttpResponseException.class);
+		// retry-this, since it may happens as part of a Wi-Fi to 3G failover
+		exceptionWhitelist.add(UnknownHostException.class);
+		// retry-this, since it may happens as part of a Wi-Fi to 3G failover
+		exceptionWhitelist.add(SocketException.class);
+
+		// never retry timeouts
+		exceptionBlacklist.add(InterruptedIOException.class);
+		// never retry SSL handshake failures
+		exceptionBlacklist.add(SSLException.class);
+	}
+
+	private final int maxRetries;
+	private final int retrySleepTimeMS;
+
+	public RetryHandler(int maxRetries, int retrySleepTimeMS) {
+		this.maxRetries = maxRetries;
+		this.retrySleepTimeMS = retrySleepTimeMS;
+	}
+
+	public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
+		boolean retry = true;
+
+		Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
+		boolean sent = (b != null && b.booleanValue());
+
+		if (executionCount > maxRetries) {
+			// Do not retry if over max retry count
+			retry = false;
+		} else if (isInList(exceptionBlacklist, exception)) {
+			// immediately cancel retry if the error is blacklisted
+			retry = false;
+		} else if (isInList(exceptionWhitelist, exception)) {
+			// immediately retry if error is whitelisted
+			retry = true;
+		} else if (!sent) {
+			// for most other errors, retry only if request hasn't been fully sent yet
+			retry = true;
+		}
+
+		if (retry) {
+			// resend all idempotent requests
+			HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
+			String requestType = currentReq.getMethod();
+			retry = !requestType.equals("POST");
+		}
+
+		if (retry) {
+			SystemClock.sleep(retrySleepTimeMS);
+		} else {
+			exception.printStackTrace();
+		}
+
+		return retry;
+	}
+
+	protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
+		Iterator<Class<?>> itr = list.iterator();
+		while (itr.hasNext()) {
+			if (itr.next().isInstance(error)) {
+				return true;
+			}
+		}
+		return false;
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/TextHttpResponseHandler.java b/src/com/loopj/android/http/TextHttpResponseHandler.java
index f0acf050..bacf56b3 100644
--- a/src/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/src/com/loopj/android/http/TextHttpResponseHandler.java
@@ -110,6 +110,8 @@ protected void handleSuccessMessage(int statusCode,byte[] responseBody) {
             onSuccess(statusCode, new String(responseBody, _encoding));
         } catch (UnsupportedEncodingException e) {
             onFailure(0, (String) null, e);
+        } catch (NullPointerException e) {
+            onFailure(0, (String) null, e);
         }
     }
 
@@ -119,6 +121,8 @@ protected void handleFailureMessage(int statusCode, byte[] responseBody, Throwab
             onFailure(statusCode, new String(responseBody, _encoding), error);
         } catch (UnsupportedEncodingException e) {
             onFailure(0, (String) null, e);
+        } catch ( NullPointerException e ) {
+            onFailure(0, (String) null, error);
         }
     }
     
