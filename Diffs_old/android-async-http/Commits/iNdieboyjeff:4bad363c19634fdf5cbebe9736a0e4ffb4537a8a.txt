diff --git a/README.md b/README.md
index a576fb38..bcb46116 100644
--- a/README.md
+++ b/README.md
@@ -39,7 +39,7 @@ http://central.maven.org/maven2/com/loopj/android/android-async-http/
 ```
 Maven URL: http://repo1.maven.org/maven2/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
+ArtifactId: android-async-http
 Version: 1.4.3
 Packaging: JAR or AAR
 ```
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index c6df930c..41a4c961 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -95,8 +95,6 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    // This property won't be available soon, don't use it
-    @Deprecated
     private static final String VERSION = "1.4.4";
 
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
@@ -108,8 +106,8 @@
     private static final String ENCODING_GZIP = "gzip";
     private static final String LOG_TAG = "AsyncHttpClient";
 
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+    private int maxConnections = DEFAULT_MAX_CONNECTIONS;
+    private int timeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
@@ -118,7 +116,6 @@
     private final Map<String, String> clientHeaderMap;
     private boolean isUrlEncodingEnabled = true;
 
-
     /**
      * Creates a new AsyncHttpClient with default constructor arguments values
      */
@@ -202,12 +199,12 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         BasicHttpParams httpParams = new BasicHttpParams();
 
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
+        ConnManagerParams.setTimeout(httpParams, timeout);
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
         ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
 
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setSoTimeout(httpParams, timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
         HttpConnectionParams.setTcpNoDelay(httpParams, true);
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
@@ -322,16 +319,51 @@ public void setUserAgent(String userAgent) {
         HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
     }
 
+
+    /**
+     * Returns current limit of parallel connections
+     *
+     * @return maximum limit of parallel connections, default is 10
+     */
+    public int getMaxConnections() {
+        return maxConnections;
+    }
+
+    /**
+     * Sets maximum limit of parallel connections
+     *
+     * @param maxConnections maximum parallel connections, must be at least 1
+     */
+    public void setMaxConnections(int maxConnections) {
+        if (maxConnections < 1)
+            maxConnections = DEFAULT_MAX_CONNECTIONS;
+        this.maxConnections = maxConnections;
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(this.maxConnections));
+    }
+
+    /**
+     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     *
+     * @return Socket Timeout limit in milliseconds
+     */
+    public int getTimeout() {
+        return timeout;
+    }
+
     /**
-     * Set the connection timeout. By default, 10 seconds.
+     * Set the connection and socket timeout. By default, 10 seconds.
      *
-     * @param timeout the connect/socket timeout in milliseconds
+     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
      */
     public void setTimeout(int timeout) {
+        if (timeout < 1000)
+            timeout = DEFAULT_SOCKET_TIMEOUT;
+        this.timeout = timeout;
         final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        ConnManagerParams.setTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
     }
 
     /**
@@ -469,8 +501,8 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void head(String url, AsyncHttpResponseHandler responseHandler) {
-        head(null, url, null, responseHandler);
+    public RequestHandle head(String url, AsyncHttpResponseHandler responseHandler) {
+        return head(null, url, null, responseHandler);
     }
 
     /**
@@ -480,8 +512,8 @@ public void head(String url, AsyncHttpResponseHandler responseHandler) {
      * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        head(null, url, params, responseHandler);
+    public RequestHandle head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return head(null, url, params, responseHandler);
     }
 
     /**
@@ -491,8 +523,8 @@ public void head(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        head(context, url, null, responseHandler);
+    public RequestHandle head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        return head(context, url, null, responseHandler);
     }
 
     /**
@@ -503,8 +535,8 @@ public void head(Context context, String url, AsyncHttpResponseHandler responseH
      * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    public RequestHandle head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -518,10 +550,10 @@ public void head(Context context, String url, RequestParams params, AsyncHttpRes
      * @param responseHandler the response handler instance that should handle
      *                        the response.
      */
-    public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
 
@@ -536,8 +568,8 @@ public void head(Context context, String url, Header[] headers, RequestParams pa
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
+    public RequestHandle get(String url, AsyncHttpResponseHandler responseHandler) {
+        return get(null, url, null, responseHandler);
     }
 
     /**
@@ -547,8 +579,8 @@ public void get(String url, AsyncHttpResponseHandler responseHandler) {
      * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
+    public RequestHandle get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return get(null, url, params, responseHandler);
     }
 
     /**
@@ -558,8 +590,8 @@ public void get(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
+    public RequestHandle get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        return get(context, url, null, responseHandler);
     }
 
     /**
@@ -570,8 +602,8 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
      * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
+    public RequestHandle get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -585,10 +617,10 @@ public void get(Context context, String url, RequestParams params, AsyncHttpResp
      * @param responseHandler the response handler instance that should handle
      *                        the response.
      */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
+        return sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
 
@@ -603,8 +635,8 @@ public void get(Context context, String url, Header[] headers, RequestParams par
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
+    public RequestHandle post(String url, AsyncHttpResponseHandler responseHandler) {
+        return post(null, url, null, responseHandler);
     }
 
     /**
@@ -614,8 +646,8 @@ public void post(String url, AsyncHttpResponseHandler responseHandler) {
      * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
+    public RequestHandle post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return post(null, url, params, responseHandler);
     }
 
     /**
@@ -626,8 +658,8 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    public RequestHandle post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -639,8 +671,8 @@ public void post(Context context, String url, RequestParams params, AsyncHttpRes
      * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response ha   ndler instance that should handle the response.
      */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+    public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -656,12 +688,12 @@ public void post(Context context, String url, HttpEntity entity, String contentT
      * @param responseHandler the response handler instance that should handle
      *                        the response.
      */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                      AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
+        return sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
     }
 
@@ -680,11 +712,11 @@ public void post(Context context, String url, Header[] headers, RequestParams pa
      * @param responseHandler the response handler instance that should handle
      *                        the response.
      */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                      AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
     //
@@ -697,8 +729,8 @@ public void post(Context context, String url, Header[] headers, HttpEntity entit
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
+    public RequestHandle put(String url, AsyncHttpResponseHandler responseHandler) {
+        return put(null, url, null, responseHandler);
     }
 
     /**
@@ -708,8 +740,8 @@ public void put(String url, AsyncHttpResponseHandler responseHandler) {
      * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
+    public RequestHandle put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return put(null, url, params, responseHandler);
     }
 
     /**
@@ -720,8 +752,8 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    public RequestHandle put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        return put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -734,8 +766,8 @@ public void put(Context context, String url, RequestParams params, AsyncHttpResp
      * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+    public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -749,10 +781,10 @@ public void put(Context context, String url, HttpEntity entity, String contentTy
      * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
         if (headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
     //
@@ -765,8 +797,8 @@ public void put(Context context, String url, Header[] headers, HttpEntity entity
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
+    public RequestHandle delete(String url, AsyncHttpResponseHandler responseHandler) {
+        return delete(null, url, responseHandler);
     }
 
     /**
@@ -776,9 +808,9 @@ public void delete(String url, AsyncHttpResponseHandler responseHandler) {
      * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
     /**
@@ -789,10 +821,10 @@ public void delete(Context context, String url, AsyncHttpResponseHandler respons
      * @param headers         set one-time headers for this request
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
         if (headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
     /**
@@ -804,10 +836,10 @@ public void delete(Context context, String url, Header[] headers, AsyncHttpRespo
      * @param params          additional DELETE parameters or files to send along with request
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+    public RequestHandle delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) httpDelete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
+        return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
     /**
@@ -820,7 +852,7 @@ public void delete(Context context, String url, Header[] headers, RequestParams
      * @param responseHandler ResponseHandler or its subclass to put the response into
      * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete, HttpPost, HttpGet, HttpPut, etc.
      */
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
+    protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
         if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
         }
@@ -839,6 +871,8 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
 
             // TODO: Remove dead weakrefs from requestLists?
         }
+        
+        return new RequestHandle(request);
     }
 
     /**
@@ -889,7 +923,7 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
             }
         } catch (Throwable t) {
             if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, t, (String) null);
+                responseHandler.sendFailureMessage(0, null, null, t);
             else
                 t.printStackTrace();
         }
@@ -897,7 +931,7 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
         return entity;
     }
 
-    public boolean isUrlEncodingEnabled(){
+    public boolean isUrlEncodingEnabled() {
         return isUrlEncodingEnabled;
     }
 
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
index d235663b..1f7c8a3a 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -19,18 +19,13 @@
 package com.loopj.android.http;
 
 import org.apache.http.HttpResponse;
-import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.http.protocol.HttpContext;
 
 import java.io.IOException;
-import java.net.ConnectException;
 import java.net.MalformedURLException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 
 class AsyncHttpRequest implements Runnable {
@@ -38,7 +33,6 @@
     private final HttpContext context;
     private final HttpUriRequest request;
     private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
     private int executionCount;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
@@ -46,110 +40,81 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if (responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
     }
 
     @Override
     public void run() {
-        try {
-            if (responseHandler != null) {
-                responseHandler.sendStartMessage();
-            }
+        if (responseHandler != null) {
+            responseHandler.sendStartMessage();
+        }
 
+        try {
             makeRequestWithRetries();
-
-            if (responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
         } catch (IOException e) {
             if (responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                if (this.isBinaryRequest) {
-                    responseHandler.sendFailureMessage(e, (byte[]) null);
-                } else {
-                    responseHandler.sendFailureMessage(e, (String) null);
-                }
+                responseHandler.sendFailureMessage(0, null, null, e);
             }
         }
+        
+        if (responseHandler != null) {
+            responseHandler.sendFinishMessage();
+        }
     }
 
-    private void makeRequest() throws IOException, InterruptedException {
+    private void makeRequest() throws IOException {
         if (!Thread.currentThread().isInterrupted()) {
-            try {
-                // Fixes #115
-                if (request.getURI().getScheme() == null)
-                    throw new MalformedURLException("No valid URI scheme was provided");
-                HttpResponse response = client.execute(request, context);
-                if (!Thread.currentThread().isInterrupted()) {
-                    if (responseHandler != null) {
-                        responseHandler.sendResponseMessage(response);
-                    }
-                } else {
-                    throw new InterruptedException("makeRequest was interrupted");
-                }
-            } catch (IOException e) {
-                if (!Thread.currentThread().isInterrupted()) {
-                    throw e;
+            // Fixes #115
+            if (request.getURI().getScheme() == null) {
+                // subclass of IOException so processed in the caller
+                throw new MalformedURLException("No valid URI scheme was provided");
+            }
+
+            HttpResponse response = client.execute(request, context);
+
+            if (!Thread.currentThread().isInterrupted()) {
+                if (responseHandler != null) {
+                    responseHandler.sendResponseMessage(response);
                 }
             }
         }
     }
 
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+    private void makeRequestWithRetries() throws IOException {
         boolean retry = true;
         IOException cause = null;
         HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (ClientProtocolException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "cannot repeat the request");
-                }
-                return;
-            } catch (UnknownHostException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
+        try
+        {
+            while (retry) {
+                try {
+                    makeRequest();
+                    return;
+                } catch (UnknownHostException e) {
+                    // switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException
+                    // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
+                    // (to assist in genuine cases of unknown host) which seems better than outright failure
+                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
+                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (NullPointerException e) {
+                    // there's a bug in HttpClient 4.0.x that on some occasions causes
+                    // DefaultRequestExecutor to throw an NPE, see
+                    // http://code.google.com/p/android/issues/detail?id=5255
+                    cause = new IOException("NPE in HttpClient: " + e.getMessage());
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (IOException e) {
+                    cause = e;
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                return;
-            } catch (ConnectTimeoutException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "connection timed out");
-                }
-            } catch (SocketException e) {
-                // Added to detect host unreachable
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
+                if(retry && (responseHandler != null)) {
+                    responseHandler.sendRetryMessage();
                 }
-                return;
-            } catch (SocketTimeoutException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
-                }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient " + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (InterruptedException e) {
-                cause = new IOException("Request was interrupted while executing");
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
             }
+        } catch (Exception e) {
+            // catch anything else to ensure failure message is propagated
+            cause = new IOException("Unhandled exception: " + e.getMessage());
         }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
+        
+        // cleaned up to throw IOException
+        throw(cause);
     }
 }
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 5525391a..561913e9 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,24 +21,27 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
+import org.apache.http.util.ByteArrayBuffer;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.lang.ref.WeakReference;
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
+ * {@link AsyncHttpClient}. The {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is
  * designed to be anonymously overridden with your own response handling code.
  * <p>&nbsp;</p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * Additionally, you can override the {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)},
+ * {@link #onStart()}, {@link #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
  * <p>&nbsp;</p>
  * For example:
  * <p>&nbsp;</p>
@@ -51,16 +54,26 @@
  *     }
  *
  *     &#064;Override
- *     public void onSuccess(String response) {
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
  *         // Successfully got a response
  *     }
  *
  *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
  *         // Response failed :(
  *     }
  *
  *     &#064;Override
+ *     public void onRetry() {
+ *         // Request was retried
+ *     }
+ *
+ *     &#064;Override
+ *     public void onProgress(int bytesWritten, int totalSize) {
+ *         // Progress notification
+ *     }
+ *
+ *     &#064;Override
  *     public void onFinish() {
  *         // Completed the request (either success or failure)
  *     }
@@ -68,14 +81,52 @@
  * </pre>
  */
 public class AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "AsyncHttpResponseHandler";
+
     protected static final int SUCCESS_MESSAGE = 0;
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
     protected static final int PROGRESS_MESSAGE = 4;
+    protected static final int RETRY_MESSAGE = 5;
+
+    protected static final int BUFFER_SIZE = 4096;
 
     private Handler handler;
-    private String responseCharset = "UTF-8";
+    public static final String DEFAULT_CHARSET = "UTF-8";
+    private String responseCharset = DEFAULT_CHARSET;
+    private Boolean useSynchronousMode = false;
+
+    // avoid leaks by using a non-anonymous handler class
+    // with a weak reference
+    static class ResponderHandler extends Handler {
+        private final WeakReference<AsyncHttpResponseHandler> mResponder;
+
+        ResponderHandler(AsyncHttpResponseHandler service) {
+            mResponder = new WeakReference<AsyncHttpResponseHandler>(service);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncHttpResponseHandler service = mResponder.get();
+            if (service != null) {
+                service.handleMessage(msg);
+            }
+        }
+    }
+
+    public boolean getUseSynchronousMode() {
+        return (useSynchronousMode);
+    }
+
+    /**
+     * Set the response handler to use synchronous mode or not
+     *
+     * @param value true indicates that synchronous mode should be used
+     */
+    public void setUseSynchronousMode(Boolean value) {
+        useSynchronousMode = value;
+    }
 
     /**
      * Sets the charset for the response string. If not set, the default is UTF-8.
@@ -88,7 +139,7 @@ public void setCharset(final String charset) {
     }
 
     public String getCharset() {
-        return this.responseCharset;
+        return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
     }
 
     /**
@@ -97,12 +148,7 @@ public String getCharset() {
     public AsyncHttpResponseHandler() {
         // Set up a handler to post events back to the correct thread if possible
         if (Looper.myLooper() != null) {
-            handler = new Handler() {
-                @Override
-                public void handleMessage(Message msg) {
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
+            handler = new ResponderHandler(this);
         }
     }
 
@@ -136,7 +182,9 @@ public void onFinish() {
      * Fired when a request returns successfully, override to handle in your own code
      *
      * @param content the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
+    @Deprecated
     public void onSuccess(String content) {
     }
 
@@ -146,7 +194,9 @@ public void onSuccess(String content) {
      * @param statusCode the status code of the response
      * @param headers    the headers of the HTTP response
      * @param content    the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
+    @Deprecated
     public void onSuccess(int statusCode, Header[] headers, String content) {
         onSuccess(statusCode, content);
     }
@@ -156,11 +206,30 @@ public void onSuccess(int statusCode, Header[] headers, String content) {
      *
      * @param statusCode the status code of the response
      * @param content    the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
+    @Deprecated
     public void onSuccess(int statusCode, String content) {
         onSuccess(content);
     }
 
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     *
+     * @param statusCode   the status code of the response
+     * @param headers      return headers, if any
+     * @param responseBody the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        try {
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onSuccess(statusCode, headers, response);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, e.toString());
+            onFailure(statusCode, headers, e, null);
+        }
+    }
+
     /**
      * Fired when a request fails to complete, override to handle in your own code
      *
@@ -176,7 +245,9 @@ public void onFailure(Throwable error) {
      *
      * @param error   the underlying cause of the failure
      * @param content the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(Throwable error, String content) {
         // By default, call the deprecated onFailure(Throwable) for compatibility
         onFailure(error);
@@ -188,7 +259,9 @@ public void onFailure(Throwable error, String content) {
      * @param statusCode return HTTP status code
      * @param error      the underlying cause of the failure
      * @param content    the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(int statusCode, Throwable error, String content) {
         // By default, call the chain method onFailure(Throwable,String)
         onFailure(error, content);
@@ -201,12 +274,38 @@ public void onFailure(int statusCode, Throwable error, String content) {
      * @param headers    return headers, if any
      * @param error      the underlying cause of the failure
      * @param content    the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
         // By default, call the chain method onFailure(int,Throwable,String)
         onFailure(statusCode, error, content);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode   return HTTP status code
+     * @param headers      return headers, if any
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        try {
+            String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onFailure(statusCode, headers, error, response);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, e.toString());
+            onFailure(statusCode, headers, e, null);
+        }
+    }
+
+    /**
+     * Fired when a retry occurs, override to handle in your own code
+     */
+    public void onRetry() {
+    }
+
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
@@ -216,26 +315,12 @@ protected void sendProgressMessage(int bytesWritten, int totalSize) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, totalSize}));
     }
 
-    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
+    protected void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
 
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
-    }
-
-    @Deprecated
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
-    }
-
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
-    }
-
-    @Deprecated
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
+    protected void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
     }
 
     protected void sendStartMessage() {
@@ -246,20 +331,10 @@ protected void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, headers, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
+    protected void sendRetryMessage() {
+        sendMessage(obtainMessage(RETRY_MESSAGE, null));
     }
 
-
     // Methods which emulate android's Handler and Message methods
     protected void handleMessage(Message msg) {
         Object[] response;
@@ -267,11 +342,17 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (Header[]) response[1], (String) response[2]);
+                if (response != null && response.length >= 3)
+                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
+                else
+                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (String) response[3]);
+                if (response != null && response.length >= 4)
+                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
+                else
+                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
                 break;
             case START_MESSAGE:
                 onStart();
@@ -281,16 +362,22 @@ protected void handleMessage(Message msg) {
                 break;
             case PROGRESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                onProgress((Integer) response[0], (Integer) response[1]);
+                if (response != null && response.length >= 2)
+                    onProgress((Integer) response[0], (Integer) response[1]);
+                else
+                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                break;
+            case RETRY_MESSAGE:
+                onRetry();
                 break;
         }
     }
 
     protected void sendMessage(Message msg) {
-        if (handler != null) {
-            handler.sendMessage(msg);
-        } else {
+        if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
+        } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
+            handler.sendMessage(msg);
         }
     }
 
@@ -315,35 +402,56 @@ protected Message obtainMessage(int responseMessage, Object response) {
     }
 
     // Interface to AsyncHttpRequest
-    protected void sendResponseMessage(HttpResponse response) {
-        if (response == null) {
-            sendFailureMessage(0, null, new IllegalStateException("No response"), (String) null);
-            return;
-        }
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity;
-            HttpEntity temp = response.getEntity();
-            if (temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, getCharset());
-            }
-        } catch (IOException e) {
-            try {
-                if (response.getEntity() != null)
-                    response.getEntity().consumeContent();
-            } catch (Throwable t) {
-                t.printStackTrace();
+    void sendResponseMessage(HttpResponse response) throws IOException {
+        // do not process if request has been cancelled
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            byte[] responseBody;
+            responseBody = getResponseData(response.getEntity());
+            // additional cancellation check as getResponseData() can take non-zero time to process
+            if (!Thread.currentThread().isInterrupted()) {
+                if (status.getStatusCode() >= 300) {
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+                } else {
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+                }
             }
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (String) null);
-            return;
         }
+    }
 
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l, count = 0;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            count += l;
+                            buffer.append(tmp, 0, l);
+                            sendProgressMessage(count, (int) contentLength);
+                        }
+                    } finally {
+                        instream.close();
+                    }
+                    responseBody = buffer.buffer();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
         }
+        return responseBody;
     }
 }
diff --git a/library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java
new file mode 100644
index 00000000..c9a89091
--- /dev/null
+++ b/library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -0,0 +1,160 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpStatus;
+
+public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
+    private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
+
+    /**
+     * Creates a new JsonHttpResponseHandler
+     */
+
+    public BaseJsonHttpResponseHandler() {
+        super(DEFAULT_CHARSET);
+    }
+
+    public BaseJsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
+
+    @Override
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        // Disabling this method
+        super.onSuccess(statusCode, headers, responseBody);
+    }
+
+    @Override
+    public final void onSuccess(String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onSuccess(content);
+    }
+
+    @Override
+    public final void onSuccess(int statusCode, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onSuccess(statusCode, content);
+    }
+
+    @Override
+    public final void onFailure(String responseBody, Throwable error) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(responseBody, error);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        //Disabling this method
+        super.onFailure(statusCode, headers, responseBody, error);
+    }
+
+    @Override
+    public final void onFailure(Throwable error) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(error);
+    }
+
+    @Override
+    public final void onFailure(Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(error, content);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(statusCode, error, content);
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+        // Disabling usage of this method, until removed from parent
+        super.onFailure(statusCode, headers, error, content);
+    }
+
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawResponse, JSON_TYPE response);
+
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable e, String rawData, JSON_TYPE errorResponse);
+
+    @Override
+    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onSuccess(statusCode, headers, responseBody, jsonResponse);
+                            }
+                        });
+                    } catch (final Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, t, responseBody, null);
+                            }
+                        });
+                    }
+                }
+            }).start();
+        } else {
+            onSuccess(statusCode, headers, null, null);
+        }
+    }
+
+    @Override
+    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
+        if (responseBody != null) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, e, responseBody, jsonResponse);
+                            }
+                        });
+                    } catch (Throwable t) {
+                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                onFailure(statusCode, headers, e, responseBody, null);
+                            }
+                        });
+                    }
+                }
+            }).start();
+        } else {
+            onFailure(statusCode, headers, e, null, null);
+        }
+    }
+
+    protected abstract JSON_TYPE parseResponse(String responseBody) throws Throwable;
+}
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index d8e5cdda..5293b655 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -18,15 +18,10 @@
 
 package com.loopj.android.http;
 
-import android.os.Message;
-
 import org.apache.http.Header;
-import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
 
 import java.io.IOException;
 import java.util.regex.Pattern;
@@ -104,74 +99,44 @@ public void onSuccess(int statusCode, byte[] binaryData) {
     }
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Fired when a request returns successfully, override to handle in your own code
      *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param error      the underlying cause of the failure
-     * @param binaryData the response body, if any
-     * @deprecated
+     * @param statusCode    response HTTP statuse code
+     * @param headers       response headers, if any
+     * @param responseData  the response body, if any
      */
-    @Deprecated
-    public void onFailure(int statusCode, Header[] headers, Throwable error, byte[] binaryData) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(statusCode, error, null);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
 
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseData) {
+        onSuccess(statusCode, responseData);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode    response HTTP statuse code
+     * @param headers       response headers, if any
+     * @param responseData  the response body, if any
+     * @param error         the underlying cause of the failure
+     */
+
     @Override
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
+    public void onFailure(int statusCode, Header[] headers, byte[] responseData, Throwable error) {
+        onFailure(statusCode, error, null);
     }
 
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
 
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    @Override
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch (msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (byte[]) response[3]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
-
     // Interface to AsyncHttpRequest
     @Override
-    protected void sendResponseMessage(HttpResponse response) {
+    protected void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        byte[] responseBody = null;
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -183,24 +148,9 @@ protected void sendResponseMessage(HttpResponse response) {
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
             return;
         }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if (temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch (IOException e) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (byte[]) null);
-        }
-
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
+        super.sendResponseMessage( response );
     }
 }
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 7bb674fc..76049ccd 100644
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,11 +1,7 @@
 package com.loopj.android.http;
 
-import android.os.Message;
-
 import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
+import org.apache.http.HttpEntity;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -44,66 +40,40 @@ public void onFailure(int statusCode, Header[] headers, Throwable e, File respon
         onFailure(statusCode, e, response);
     }
 
-
-    protected void sendSuccessMessage(int statusCode, File file) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, file}));
-    }
-
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, File file) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, file}));
-    }
-
-    protected void handleSuccessMessage(int statusCode, File responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, File responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        onFailure(statusCode, headers, error, mFile);
     }
 
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch (msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (File) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (File) response[3]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, mFile);
     }
 
     @Override
-    protected void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-
-        try {
-            FileOutputStream buffer = new FileOutputStream(this.mFile);
-            InputStream is = response.getEntity().getContent();
-
-            int nRead;
-            byte[] data = new byte[16384];
-
-            while ((nRead = is.read(data, 0, data.length)) != -1)
-                buffer.write(data, 0, nRead);
-
-            buffer.flush();
-            buffer.close();
-
-        } catch (IOException e) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, this.mFile);
-        }
-
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), this.mFile);
-        }
-    }
-}
\ No newline at end of file
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+      if (entity != null) {
+          InputStream instream = entity.getContent();
+          long contentLength = entity.getContentLength();
+          FileOutputStream buffer = new FileOutputStream(this.mFile);
+          if (instream != null) {
+              try {
+                  byte[] tmp = new byte[BUFFER_SIZE];
+                  int l, count = 0;
+                  // do not send messages if request has been cancelled
+                  while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                      count += l;
+                      buffer.write(tmp, 0, l);
+                      sendProgressMessage(count, (int) contentLength);
+                  }
+              } finally {
+                  instream.close();
+                  buffer.flush();
+                  buffer.close();
+              }
+          }
+      }
+      return null;
+  }
+  
+}
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 138b6116..1e55eb35 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -18,7 +18,7 @@
 
 package com.loopj.android.http;
 
-import android.os.Message;
+import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
@@ -39,8 +39,20 @@
  * Additionally, you can override the other event methods from the
  * parent class.
  */
-public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    protected static final int SUCCESS_JSON_MESSAGE = 100;
+public class JsonHttpResponseHandler extends TextHttpResponseHandler {
+    private static final String LOG_TAG = "JsonHttpResponseHandler";
+
+    /**
+     * Creates a new JsonHttpResponseHandler
+     */
+
+    public JsonHttpResponseHandler() {
+        super(DEFAULT_CHARSET);
+    }
+
+    public JsonHttpResponseHandler(String encoding) {
+        super(encoding);
+    }
 
     //
     // Callbacks to be overridden, typically anonymously
@@ -141,13 +153,8 @@ public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray e
         onFailure(statusCode, e, errorResponse);
     }
 
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
     @Override
-    protected void sendSuccessMessage(final int statusCode, final Header[] headers, final String responseBody) {
+    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
@@ -157,70 +164,35 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+                                if (jsonResponse instanceof JSONObject) {
+                                    onSuccess(statusCode, headers, (JSONObject) jsonResponse);
+                                } else if (jsonResponse instanceof JSONArray) {
+                                    onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onSuccess(statusCode, headers, (String) jsonResponse);
+                                } else {
+                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                }
+
                             }
                         });
-                    } catch (final JSONException e) {
+                    } catch (final JSONException ex) {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                sendFailureMessage(statusCode, headers, e, responseBody);
+                                onFailure(ex, (JSONObject) null);
                             }
                         });
                     }
                 }
             }).start();
         } else {
-            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, new JSONObject()}));
-        }
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    @Override
-    protected void handleMessage(Message msg) {
-        switch (msg.what) {
-            case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage((Integer) response[0], (Header[]) response[1], response[2]);
-                break;
-            default:
-                super.handleMessage(msg);
-        }
-    }
-
-    protected void handleSuccessJsonMessage(int statusCode, Header[] headers, Object jsonResponse) {
-        if (jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, headers, (JSONObject) jsonResponse);
-        } else if (jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, headers, (JSONArray) jsonResponse);
-        } else if (jsonResponse instanceof String) {
-            onSuccess(statusCode, headers, (String) jsonResponse);
-        } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+            onSuccess(statusCode, headers, new JSONObject());
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
-        if (null == responseBody)
-            return null;
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        responseBody = responseBody.trim();
-        if (responseBody.startsWith("{") || responseBody.startsWith("[")) {
-            result = new JSONTokener(responseBody).nextValue();
-        }
-        if (result == null) {
-            result = responseBody;
-        }
-        return result;
-    }
-
     @Override
-    protected void handleFailureMessage(final int statusCode, final Header[] headers, final Throwable e, final String responseBody) {
+    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
         if (responseBody != null) {
             new Thread(new Runnable() {
                 @Override
@@ -237,16 +209,16 @@ public void run() {
                                 } else if (jsonResponse instanceof String) {
                                     onFailure(statusCode, headers, e, (String) jsonResponse);
                                 } else {
-                                    onFailure(statusCode, headers, e, responseBody);
+                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
                             }
                         });
 
-                    } catch (JSONException ex) {
+                    } catch (final JSONException ex) {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody);
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
                             }
                         });
 
@@ -254,8 +226,23 @@ public void run() {
                 }
             }).start();
         } else {
-            onFailure(e, "");
+            Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
+            onFailure(statusCode, headers, e, (JSONObject) null);
         }
+    }
 
+    protected Object parseResponse(String responseBody) throws JSONException {
+        if (null == responseBody)
+            return null;
+        Object result = null;
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        String jsonString = responseBody.trim();
+        if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+            result = new JSONTokener(jsonString).nextValue();
+        }
+        if (result == null) {
+            result = jsonString;
+        }
+        return result;
     }
 }
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/com/loopj/android/http/MySSLSocketFactory.java
index fdfbffc9..86eeaab9 100644
--- a/library/src/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/com/loopj/android/http/MySSLSocketFactory.java
@@ -4,7 +4,6 @@
 
 import java.io.IOException;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
@@ -48,7 +47,7 @@ public void checkServerTrusted(
     }
 
     @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }
 
diff --git a/library/src/com/loopj/android/http/RequestHandle.java b/library/src/com/loopj/android/http/RequestHandle.java
new file mode 100644
index 00000000..69b1975e
--- /dev/null
+++ b/library/src/com/loopj/android/http/RequestHandle.java
@@ -0,0 +1,60 @@
+package com.loopj.android.http;
+
+import java.util.concurrent.Future;
+
+/**
+ * A Handle to an AsyncRequest which can be used to cancel a running request.
+ * 
+ */
+public class RequestHandle {
+	private final Future<?> request;
+	
+	public RequestHandle(Future<?> request) {
+		this.request = request;
+	}
+	
+	/**
+	 * Attempts to cancel this request. This attempt will fail if the request has
+	 * already completed, has already been cancelled, or could not be cancelled
+	 * for some other reason. If successful, and this request has not started
+	 * when cancel is called, this request should never run. If the request has
+	 * already started, then the mayInterruptIfRunning parameter determines
+	 * whether the thread executing this request should be interrupted in an
+	 * attempt to stop the request.
+	 * 
+	 * After this method returns, subsequent calls to isDone() will always
+	 * return true. Subsequent calls to isCancelled() will always return true
+	 * if this method returned true.
+	 * 
+	 * @param mayInterruptIfRunning true if the thread executing this request should be interrupted; otherwise, in-progress requests are allowed to complete
+	 * @return false if the request could not be cancelled, typically because it has already completed normally; true otherwise
+	 */
+	public boolean cancel(boolean mayInterruptIfRunning) {
+		if (this.request == null) {
+			return false;
+		}
+		return request.cancel(mayInterruptIfRunning);
+	}
+	
+	/**
+	 * Returns true if this task completed. Completion may be due to normal termination, an exception, or cancellation -- in all of these cases, this method will return true.
+	 * @return true if this task completed
+	 */
+	public boolean isFinished() {
+		if (this.request == null) {
+			return true;
+		}
+		return request.isDone();
+	}
+	
+	/**
+	 * Returns true if this task was cancelled before it completed normally.
+	 * @return true if this task was cancelled before it completed
+	 */
+	public boolean isCancelled() {
+		if (this.request == null) {
+			return false;
+		}
+		return request.isCancelled();
+	}
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
index 30346ffe..9f8614af 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -148,22 +148,12 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
     }
 
     private byte[] createContentDisposition(final String key) {
-        return new StringBuilder()
-                .append("Content-Disposition: form-data; name=\"")
-                .append(key)
-                .append("\"\r\n")
-                .toString()
+        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
                 .getBytes();
     }
 
     private byte[] createContentDisposition(final String key, final String fileName) {
-        return new StringBuilder()
-                .append("Content-Disposition: form-data; name=\"")
-                .append(key)
-                .append("\"; filename=\"")
-                .append(fileName)
-                .append("\"\r\n")
-                .toString()
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
                 .getBytes();
     }
 
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
index 879abb1f..e3886eac 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -1,61 +1,61 @@
 package com.loopj.android.http;
 
 import android.content.Context;
-import android.os.Message;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
 
-public abstract class SyncHttpClient extends AsyncHttpClient {
-    private int responseCode;
-    /*
-     * as this is a synchronous request this is just a helping mechanism to pass
-     * the result back to this method. Therefore the result object has to be a
-     * field to be accessible
-     */
-    protected String result;
-    protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
+public class SyncHttpClient extends AsyncHttpClient {
 
-        @Override
-        protected void sendResponseMessage(HttpResponse response) {
-            responseCode = response.getStatusLine().getStatusCode();
-            super.sendResponseMessage(response);
-        }
+    /**
+     * Creates a new SyncHttpClient with default constructor arguments values
+     */
+    public SyncHttpClient() {
+        super(false, 80, 443);
+    }
 
-        @Override
-        protected void sendMessage(Message msg) {
-            /*
-             * Dont use the handler and send it directly to the analysis
-			 * (because its all the same thread)
-			 */
-            handleMessage(msg);
-        }
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public SyncHttpClient(int httpPort) {
+        super(false, httpPort, 443);
+    }
 
-        @Override
-        public void onSuccess(String content) {
-            result = content;
-        }
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public SyncHttpClient(int httpPort, int httpsPort) {
+        super(false, httpPort, httpsPort);
+    }
 
-        @Override
-        public void onFailure(Throwable error, String content) {
-            result = onRequestFailed(error, content);
-        }
-    };
+    /**
+     * Creates new SyncHttpClient using given params
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    public SyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        super(fixNoHttpResponseException, httpPort, httpsPort);
+    }
 
     /**
-     * @return the response code for the last request, might be usefull
-     * sometimes
+     * Creates a new SyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
      */
-    public int getResponseCode() {
-        return responseCode;
+    public SyncHttpClient(SchemeRegistry schemeRegistry) {
+        super(schemeRegistry);
     }
 
-    // Private stuff
     @Override
-    protected void sendRequest(DefaultHttpClient client,
+    protected RequestHandle sendRequest(DefaultHttpClient client,
                                HttpContext httpContext, HttpUriRequest uriRequest,
                                String contentType, AsyncHttpResponseHandler responseHandler,
                                Context context) {
@@ -63,67 +63,15 @@ protected void sendRequest(DefaultHttpClient client,
             uriRequest.addHeader("Content-Type", contentType);
         }
 
+        responseHandler.setUseSynchronousMode(true);
+
 		/*
          * will execute the request directly
-		 */
-        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
-                .run();
+		*/
+        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+        
+        // Return a Request Handle that cannot be used to cancel the request
+        // because it is already complete by the time this returns
+        return new RequestHandle(null);
     }
-
-    public abstract String onRequestFailed(Throwable error, String content);
-
-    public void delete(String url, RequestParams queryParams,
-                       AsyncHttpResponseHandler responseHandler) {
-        delete(getUrlWithQueryString(isUrlEncodingEnabled(), url, queryParams), responseHandler);
-    }
-
-    public String get(String url, RequestParams params) {
-        this.get(url, params, responseHandler);
-        /*
-		 * the response handler will have set the result when this line is
-		 * reached
-		 */
-        return result;
-    }
-
-    public String get(String url) {
-        this.get(url, null, responseHandler);
-        return result;
-    }
-
-    public String put(String url, RequestParams params) {
-        this.put(url, params, responseHandler);
-        return result;
-    }
-
-    public String put(String url) {
-        this.put(url, null, responseHandler);
-        return result;
-    }
-
-    public String post(String url, HttpEntity entity) {
-        this.post(null, url, entity, null, responseHandler);
-        return result;
-    }
-
-    public String post(String url, RequestParams params) {
-        this.post(url, params, responseHandler);
-        return result;
-    }
-
-    public String post(String url) {
-        this.post(url, null, responseHandler);
-        return result;
-    }
-
-    public String delete(String url, RequestParams params) {
-        this.delete(url, params, responseHandler);
-        return result;
-    }
-
-    public String delete(String url) {
-        this.delete(url, null, responseHandler);
-        return result;
-    }
-
 }
diff --git a/library/src/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/com/loopj/android/http/TextHttpResponseHandler.java
new file mode 100644
index 00000000..4eaf7636
--- /dev/null
+++ b/library/src/com/loopj/android/http/TextHttpResponseHandler.java
@@ -0,0 +1,122 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
+ * designed to be anonymously overridden with your own response handling code.
+ * <p/>
+ * Additionally, you can override the {@link #onFailure(String, Throwable)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p/>
+ * For example:
+ * <p/>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new TextHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String responseBody) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(String responseBody, Throwable e) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "TextHttpResponseHandler";
+
+    /**
+     * Creates a new TextHttpResponseHandler
+     */
+
+    public TextHttpResponseHandler() {
+        this(DEFAULT_CHARSET);
+    }
+
+    public TextHttpResponseHandler(String encoding) {
+        super();
+        setCharset(encoding);
+    }
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     *
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(String responseBody, Throwable error) {
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     *
+     * @param statusCode   the status code of the response
+     * @param headers      HTTP response headers
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
+        onFailure(responseBody, error);
+    }
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own
+     * code
+     *
+     * @param statusCode the status code of the response
+     * @param headers HTTP response headers
+     * @param responseBody the body of the HTTP response from the server
+     */
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseBody) {
+        onSuccess( statusCode, responseBody );
+    }
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        try {
+        	String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onSuccess(statusCode, headers, response);
+        } catch (UnsupportedEncodingException e) {
+            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
+            onFailure(0, headers, (String) null, e);
+        }
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        try {
+        	String response = responseBody == null ? null : new String(responseBody, getCharset());
+            onFailure(statusCode, headers, response, error);
+        } catch (UnsupportedEncodingException e) {
+            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
+            onFailure(0, headers, (String) null, e);
+        }
+    }
+
+}
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
deleted file mode 100644
index d7ef938f..00000000
--- a/sample/AndroidManifest.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http.sample"
-    android:versionName="1.4.4-SNAPSHOT"
-    android:versionCode="144">
-
-    <uses-sdk
-        android:minSdkVersion="3"
-        android:targetSdkVersion="18" />
-
-    <application
-        android:name="Android Async Http Sample"
-        android:allowBackup="true"
-        android:allowClearUserData="true">
-        <activity android:name=".MainActivity" />
-    </application>
-
-</manifest> 
diff --git a/sample/build.gradle b/sample/build.gradle
index 20fdcb60..d388761d 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -26,5 +26,6 @@ android {
 }
 
 dependencies {
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
     compile project(':library')
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/main/AndroidManifest.xml
similarity index 60%
rename from sample/src/main/AndroidManifest.xml
rename to sample/main/AndroidManifest.xml
index 8ad41e76..3e0a2fa8 100644
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
     android:versionCode="1"
     android:versionName="1.0">
 
-    <permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
     <uses-sdk
         android:minSdkVersion="3"
@@ -14,12 +14,19 @@
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
-        <activity android:name="com.loopj.android.http.sample.MainActivity">
+        <activity android:name=".WaypointsActivity">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+        <activity android:name=".GetSample" />
+        <activity android:name=".PostSample" />
+        <activity android:name=".DeleteSample" />
+        <activity android:name=".PutSample" />
+        <activity android:name=".JsonSample" />
+        <activity android:name=".FileSample" />
+        <activity android:name=".BinarySample" />
     </application>
 
 </manifest>
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/main/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from sample/src/main/res/drawable-hdpi/ic_launcher.png
rename to sample/main/res/drawable-hdpi/ic_launcher.png
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/main/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from sample/src/main/res/drawable-mdpi/ic_launcher.png
rename to sample/main/res/drawable-mdpi/ic_launcher.png
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/main/res/drawable-xhdpi/ic_launcher.png
similarity index 100%
rename from sample/src/main/res/drawable-xhdpi/ic_launcher.png
rename to sample/main/res/drawable-xhdpi/ic_launcher.png
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/main/res/values-v11/styles.xml
similarity index 100%
rename from sample/src/main/res/values-v11/styles.xml
rename to sample/main/res/values-v11/styles.xml
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/main/res/values-v14/styles.xml
similarity index 100%
rename from sample/src/main/res/values-v14/styles.xml
rename to sample/main/res/values-v14/styles.xml
diff --git a/sample/main/res/values/strings.xml b/sample/main/res/values/strings.xml
new file mode 100644
index 00000000..a2c55de5
--- /dev/null
+++ b/sample/main/res/values/strings.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Android Async Http Sample</string>
+    <string name="title_get_sample">GET Sample</string>
+    <string name="title_json_sample">JSON Sample</string>
+    <string name="title_post_sample">POST Sample</string>
+	<string name="title_put_sample">PUT Sample</string>
+	<string name="title_delete_sample">DELETE Sample</string>
+</resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/main/res/values/styles.xml
similarity index 100%
rename from sample/src/main/res/values/styles.xml
rename to sample/main/res/values/styles.xml
diff --git a/sample/main/src/com/loopj/android/http/sample/BinarySample.java b/sample/main/src/com/loopj/android/http/sample/BinarySample.java
new file mode 100644
index 00000000..a21c3815
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/BinarySample.java
@@ -0,0 +1,7 @@
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+
+public class BinarySample extends Activity {
+
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/DeleteSample.java b/sample/main/src/com/loopj/android/http/sample/DeleteSample.java
new file mode 100644
index 00000000..479c6fb5
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/DeleteSample.java
@@ -0,0 +1,63 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+public class DeleteSample extends SampleParentActivity {
+	private static final String LOG_TAG = "DeleteSample";
+
+	@Override
+	protected void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler) {
+		client.delete(this, URL, null, responseHandler);
+	}
+
+	@Override
+	protected int getSampleTitle() {
+		return R.string.title_delete_sample;
+	}
+
+	@Override
+	protected boolean isRequestBodyAllowed() {
+		return false;
+	}
+
+	@Override
+	protected boolean isRequestHeadersAllowed() {
+		return true;
+	}
+
+	@Override
+	protected String getDefaultURL() {
+		return "http://www.google.com";
+	}
+
+	@Override
+	protected AsyncHttpResponseHandler getResponseHandler() {
+		return new AsyncHttpResponseHandler() {
+
+			@Override
+			public void onStart() {
+				clearOutputs();
+			}
+
+			@Override
+			public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+				debugHeaders(LOG_TAG, headers);
+				debugStatusCode(LOG_TAG, statusCode);
+				debugResponse(LOG_TAG, new String(response));
+			}
+
+			@Override
+			public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+				debugHeaders(LOG_TAG, headers);
+				debugStatusCode(LOG_TAG, statusCode);
+				debugThrowable(LOG_TAG, e);
+				if (errorResponse != null) {
+					debugResponse(LOG_TAG, new String(errorResponse));
+				}
+			}
+		};
+	}
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/FileSample.java b/sample/main/src/com/loopj/android/http/sample/FileSample.java
new file mode 100644
index 00000000..b457ffbe
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/FileSample.java
@@ -0,0 +1,7 @@
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+
+public class FileSample extends Activity {
+
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/GetSample.java b/sample/main/src/com/loopj/android/http/sample/GetSample.java
new file mode 100644
index 00000000..b170e365
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/GetSample.java
@@ -0,0 +1,63 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+public class GetSample extends SampleParentActivity {
+    private static final String LOG_TAG = "GetSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_get_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "https://raw.github.com/loopj/android-async-http/master/README.md";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/JsonSample.java b/sample/main/src/com/loopj/android/http/sample/JsonSample.java
new file mode 100644
index 00000000..7c2f1071
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/JsonSample.java
@@ -0,0 +1,75 @@
+package com.loopj.android.http.sample;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+
+public class JsonSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "JsonSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_json_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://www.jsonip.com/";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable e, String rawResponse, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawResponse);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String responseBody) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(responseBody), SampleJSON.class).next();
+            }
+        };
+    }
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/PostSample.java b/sample/main/src/com/loopj/android/http/sample/PostSample.java
new file mode 100644
index 00000000..ea0aa4e7
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/PostSample.java
@@ -0,0 +1,64 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+public class PostSample extends SampleParentActivity {
+    private static final String LOG_TAG = "PostSample";
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler) {
+        client.post(this, URL, null, responseHandler);
+    }
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.title_post_sample;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://www.google.com";
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+}
+
diff --git a/sample/main/src/com/loopj/android/http/sample/PutSample.java b/sample/main/src/com/loopj/android/http/sample/PutSample.java
new file mode 100644
index 00000000..48e63a1e
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/PutSample.java
@@ -0,0 +1,63 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+public class PutSample extends SampleParentActivity {
+	private static final String LOG_TAG = "PutSample";
+
+	@Override
+	protected void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler) {
+		client.put(this, URL, null, responseHandler);
+	}
+
+	@Override
+	protected int getSampleTitle() {
+		return R.string.title_put_sample;
+	}
+
+	@Override
+	protected boolean isRequestBodyAllowed() {
+		return false;
+	}
+
+	@Override
+	protected boolean isRequestHeadersAllowed() {
+		return true;
+	}
+
+	@Override
+	protected String getDefaultURL() {
+		return "http://www.google.com";
+	}
+
+	@Override
+	protected AsyncHttpResponseHandler getResponseHandler() {
+		return new AsyncHttpResponseHandler() {
+
+			@Override
+			public void onStart() {
+				clearOutputs();
+			}
+
+			@Override
+			public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+				debugHeaders(LOG_TAG, headers);
+				debugStatusCode(LOG_TAG, statusCode);
+				debugResponse(LOG_TAG, new String(response));
+			}
+
+			@Override
+			public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+				debugHeaders(LOG_TAG, headers);
+				debugStatusCode(LOG_TAG, statusCode);
+				debugThrowable(LOG_TAG, e);
+				if (errorResponse != null) {
+					debugResponse(LOG_TAG, new String(errorResponse));
+				}
+			}
+		};
+	}
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/SampleParentActivity.java b/sample/main/src/com/loopj/android/http/sample/SampleParentActivity.java
new file mode 100644
index 00000000..e6808f91
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/SampleParentActivity.java
@@ -0,0 +1,170 @@
+package com.loopj.android.http.sample;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+import org.apache.http.Header;
+
+import android.app.Activity;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.text.InputType;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.ScrollView;
+import android.widget.TextView;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+public abstract class SampleParentActivity extends Activity {
+
+    private LinearLayout headers; // Sample header, inputs and buttons
+    private LinearLayout contents; // Sample output, states, errors, ...
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+    private EditText urlEditText;
+    private static final LinearLayout.LayoutParams lParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+
+    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    private static final int LIGHTRED = Color.parseColor("#FF3300");
+    private static final int YELLOW = Color.parseColor("#FFFF00");
+    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        final LinearLayout content_wrapper = new LinearLayout(this);
+        content_wrapper.setOrientation(LinearLayout.VERTICAL);
+        content_wrapper.setLayoutParams(lParams);
+        contents = new LinearLayout(this);
+        contents.setLayoutParams(lParams);
+        contents.setOrientation(LinearLayout.VERTICAL);
+        headers = new LinearLayout(this);
+        headers.setLayoutParams(lParams);
+        headers.setOrientation(LinearLayout.VERTICAL);
+        ScrollView contents_scroll = new ScrollView(this);
+        contents_scroll.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+        contents_scroll.setFillViewport(true);
+        content_wrapper.addView(headers);
+        content_wrapper.addView(contents);
+        contents_scroll.addView(content_wrapper);
+        setContentView(contents_scroll);
+        setTitle(getSampleTitle());
+        setupHeaders();
+    }
+
+    private void setupHeaders() {
+        LinearLayout urlLayout = new LinearLayout(this);
+        urlLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        urlLayout.setOrientation(LinearLayout.HORIZONTAL);
+        urlEditText = new EditText(this);
+        urlEditText.setHint("URL for request");
+        urlEditText.setText(getDefaultURL());
+        urlEditText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_URI);
+        urlEditText.setLayoutParams(new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f));
+        urlLayout.addView(urlEditText);
+        Button executeButton = new Button(this);
+        executeButton.setText("Run");
+        executeButton.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        urlLayout.addView(executeButton);
+        headers.addView(urlLayout);
+        if (isRequestHeadersAllowed()) {
+            LinearLayout headersLayout = new LinearLayout(this);
+            headersLayout.setOrientation(LinearLayout.VERTICAL);
+            headersLayout.setLayoutParams(lParams);
+        }
+        executeButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                executeSample(getAsyncHttpClient(), (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(), getResponseHandler());
+            }
+        });
+    }
+
+    protected final void debugHeaders(String TAG, Header[] headers) {
+        if (headers != null) {
+            Log.d(TAG, "Return Headers:");
+            StringBuilder builder = new StringBuilder();
+            for (Header h : headers) {
+                String _h = String.format("%s : %s", h.getName(), h.getValue());
+                Log.d(TAG, _h);
+                builder.append(_h);
+                builder.append("\n");
+            }
+            addView(getColoredView(YELLOW, builder.toString()));
+        }
+    }
+
+    protected static String throwableToString(Throwable t) {
+        if (t == null)
+            return null;
+        
+        StringWriter sw = new StringWriter();
+        t.printStackTrace(new PrintWriter(sw));
+        return sw.toString();
+    }
+
+    protected final void debugThrowable(String TAG, Throwable t) {
+        if (t != null) {
+            Log.e(TAG, "AsyncHttpClient returned error", t);
+            addView(getColoredView(LIGHTRED, throwableToString(t)));
+        }
+    }
+
+    protected final void debugResponse(String TAG, String response) {
+        if (response != null) {
+            Log.d(TAG, "Response data:");
+            Log.d(TAG, response);
+            addView(getColoredView(LIGHTGREEN, response));
+        }
+    }
+
+    protected final void debugStatusCode(String TAG, int statusCode) {
+        String msg = String.format("Return Status Code: %d", statusCode);
+        Log.d(TAG, msg);
+        addView(getColoredView(LIGHTBLUE, msg));
+    }
+
+    public static int getContrastColor(int color) {
+        double y = (299 * Color.red(color) + 587 * Color.green(color) + 114 * Color.blue(color)) / 1000;
+        return y >= 128 ? Color.BLACK : Color.WHITE;
+    }
+
+    private View getColoredView(int bgColor, String msg) {
+        TextView tv = new TextView(this);
+        tv.setLayoutParams(lParams);
+        tv.setText(msg);
+        tv.setBackgroundColor(bgColor);
+        tv.setPadding(10, 10, 10, 10);
+        tv.setTextColor(getContrastColor(bgColor));
+        return tv;
+    }
+
+    protected final void addView(View v) {
+        contents.addView(v);
+    }
+
+    protected final void clearOutputs() {
+        contents.removeAllViews();
+    }
+
+    protected abstract int getSampleTitle();
+
+    protected abstract boolean isRequestBodyAllowed();
+
+    protected abstract boolean isRequestHeadersAllowed();
+
+    protected abstract String getDefaultURL();
+
+    protected abstract AsyncHttpResponseHandler getResponseHandler();
+
+    protected AsyncHttpClient getAsyncHttpClient() {
+        return this.asyncHttpClient;
+    }
+
+    protected abstract void executeSample(AsyncHttpClient client, String URL, AsyncHttpResponseHandler responseHandler);
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/WaypointsActivity.java b/sample/main/src/com/loopj/android/http/sample/WaypointsActivity.java
new file mode 100644
index 00000000..736c5424
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/WaypointsActivity.java
@@ -0,0 +1,50 @@
+package com.loopj.android.http.sample;
+
+import android.app.ListActivity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+public class WaypointsActivity extends ListActivity {
+
+    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY"};
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+    }
+
+    @Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        Class<?> targetClass;
+        switch (position) {
+            case 0:
+            default:
+                targetClass = GetSample.class;
+                break;
+            case 1:
+                targetClass = PostSample.class;
+                break;
+            case 2:
+                targetClass = DeleteSample.class;
+                break;
+            case 3:
+                targetClass = PutSample.class;
+                break;
+            case 4:
+                targetClass = JsonSample.class;
+                break;
+            case 5:
+                targetClass = FileSample.class;
+                break;
+            case 6:
+                targetClass = BinarySample.class;
+                break;
+        }
+        if (targetClass != null)
+            startActivity(new Intent(this, targetClass));
+    }
+}
diff --git a/sample/main/src/com/loopj/android/http/sample/util/SampleJSON.java b/sample/main/src/com/loopj/android/http/sample/util/SampleJSON.java
new file mode 100644
index 00000000..7dc41782
--- /dev/null
+++ b/sample/main/src/com/loopj/android/http/sample/util/SampleJSON.java
@@ -0,0 +1,37 @@
+package com.loopj.android.http.sample.util;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class SampleJSON {
+
+    private String ip;
+    private String about;
+    @JsonProperty(value = "Pro!")
+    private String promo;
+
+    public String getPromo() {
+        return promo;
+    }
+
+    public void setPromo(String promo) {
+        this.promo = promo;
+    }
+
+    public String getAbout() {
+        return about;
+    }
+
+    public void setAbout(String about) {
+        this.about = about;
+    }
+
+    public String getIp() {
+        return ip;
+    }
+
+    public void setIp(String ip) {
+        this.ip = ip;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
deleted file mode 100644
index f5096ae2..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
+++ /dev/null
@@ -1,161 +0,0 @@
-package com.loopj.android.http.sample;
-
-import android.app.Activity;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.View;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
-import org.apache.http.Header;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.net.URI;
-
-public class MainActivity extends Activity implements View.OnClickListener {
-
-    private AsyncHttpClient aclient = new AsyncHttpClient(false, 80, 443);
-    private TextView statusCode, headers, contents, state, error;
-    private EditText url;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-        Button get = (Button) findViewById(R.id.request_get);
-        statusCode = (TextView) findViewById(R.id.return_code);
-        headers = (TextView) findViewById(R.id.return_headers);
-        contents = (TextView) findViewById(R.id.return_data);
-        state = (TextView) findViewById(R.id.current_state);
-        error = (TextView) findViewById(R.id.return_error);
-        url = (EditText) findViewById(R.id.request_url);
-
-        get.setOnClickListener(this);
-    }
-
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.main, menu);
-        return true;
-    }
-
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.request_get:
-                if (verifyUrl()) {
-                    startRequest();
-                }
-                break;
-        }
-    }
-
-    private void startRequest() {
-        aclient.get(this, getURLString(), new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, String content) {
-                setStatusMessage("Succeeded", Color.parseColor("#DD00FF00"));
-                printThrowable(null);
-                printHeaders(headers);
-                printContents(content);
-                printStatusCode(statusCode);
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-                setStatusMessage("Failed", Color.parseColor("#99FF0000"));
-                printThrowable(error);
-                printHeaders(headers);
-                printContents(content);
-                printStatusCode(statusCode);
-            }
-
-            @Override
-            public void onStart() {
-                setStatusMessage("Started", Color.parseColor("#EE00FF00"));
-            }
-
-            @Override
-            public void onFinish() {
-                setStatusMessage("Finished", 0);
-            }
-        });
-    }
-
-    private void printThrowable(Throwable error) {
-        if (this.error != null) {
-            if (error != null) {
-                StringWriter sw = new StringWriter();
-                error.printStackTrace(new PrintWriter(sw));
-                this.error.setText(sw.toString());
-            } else {
-                this.error.setText(null);
-            }
-        }
-    }
-
-    private void printStatusCode(int statusCode) {
-        if (this.statusCode != null) {
-            this.statusCode.setText(String.format("HTTP Status Code: %d", statusCode));
-        }
-    }
-
-    private void printContents(String content) {
-        if (this.contents != null) {
-            if (content == null)
-                contents.setText("Return is NULL");
-            else
-                contents.setText(content);
-        }
-    }
-
-    private void printHeaders(Header[] headers) {
-        if (this.headers != null) {
-            StringBuilder sb = new StringBuilder();
-            sb.append("Headers:");
-            if (headers != null) {
-                for (Header h : headers) {
-                    sb.append("\n").append(h.getName()).append(": ").append(h.getValue());
-                }
-            }
-            this.headers.setText(sb.toString());
-        }
-    }
-
-    private void setStatusMessage(String message, int color) {
-        if (state != null) {
-            state.setText(String.format("Status: %s", message));
-            if (color != 0)
-                state.setBackgroundColor(color);
-        }
-    }
-
-    private String getURLString() {
-        return url.getText() != null ? url.getText().toString() : null;
-    }
-
-    private boolean verifyUrl() {
-        String contents = getURLString();
-        if (contents != null) {
-            try {
-                URI.create(contents);
-                return true;
-            } catch (Throwable t) {
-                Toast.makeText(this, "Given URL is not valid", Toast.LENGTH_SHORT).show();
-                t.printStackTrace();
-                return false;
-            }
-        }
-        Toast.makeText(this, "You must fill in URL", Toast.LENGTH_SHORT).show();
-        return false;
-    }
-}
diff --git a/sample/src/main/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
deleted file mode 100644
index 27cb01e6..00000000
--- a/sample/src/main/res/layout/activity_main.xml
+++ /dev/null
@@ -1,75 +0,0 @@
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical"
-        tools:context=".MainActivity">
-
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal">
-
-            <EditText
-                android:id="@+id/request_url"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:inputType="textUri"
-                android:saveEnabled="true"
-                android:text="https://raw.github.com/loopj/android-async-http/master/README.md" />
-
-            <Button
-                android:id="@+id/request_get"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="GET" />
-
-        </LinearLayout>
-
-        <TextView
-            android:id="@+id/current_state"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#33000000"
-            android:padding="5dip"
-            android:text="Not Yet Started" />
-
-        <TextView
-            android:id="@+id/return_code"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#11000000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_headers"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#33000000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_error"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#99FF0000"
-            android:padding="5dip" />
-
-        <TextView
-            android:id="@+id/return_data"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:background="#11000000"
-            android:padding="5dip" />
-
-    </LinearLayout>
-</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/menu/main.xml b/sample/src/main/res/menu/main.xml
deleted file mode 100644
index f3b10b6c..00000000
--- a/sample/src/main/res/menu/main.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:id="@+id/action_settings"
-        android:title="@string/action_settings"
-        android:orderInCategory="100"
-        android:showAsAction="never" />
-</menu>
diff --git a/sample/src/main/res/values-sw600dp/dimens.xml b/sample/src/main/res/values-sw600dp/dimens.xml
deleted file mode 100644
index 886b05fa..00000000
--- a/sample/src/main/res/values-sw600dp/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<resources>
-    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
-         screen margins) for sw600dp devices (e.g. 7" tablets) here. -->
-</resources>
diff --git a/sample/src/main/res/values-sw720dp-land/dimens.xml b/sample/src/main/res/values-sw720dp-land/dimens.xml
deleted file mode 100644
index 00059fc5..00000000
--- a/sample/src/main/res/values-sw720dp-land/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Customize dimensions originally defined in res/values/dimens.xml (such as
-         screen margins) for sw720dp devices (e.g. 10" tablets) in landscape here. -->
-    <dimen name="activity_horizontal_margin">128dp</dimen>
-</resources>
diff --git a/sample/src/main/res/values/dimens.xml b/sample/src/main/res/values/dimens.xml
deleted file mode 100644
index 47c82246..00000000
--- a/sample/src/main/res/values/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
-</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
deleted file mode 100644
index de2d6b37..00000000
--- a/sample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">Android Async Http Sample</string>
-    <string name="action_settings">Settings</string>
-    <string name="hello_world">Hello world!</string>
-
-</resources>
diff --git a/settings.gradle b/settings.gradle
index 612d9e44..a64da16b 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,2 @@
 include ':library'
-include ':sample'
+include ':sample/main'
