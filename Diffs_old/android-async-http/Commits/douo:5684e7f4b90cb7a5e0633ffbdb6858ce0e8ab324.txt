diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 222dc67b..a2e985cc 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http;
 
 import android.content.Context;
+import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
@@ -105,7 +106,7 @@
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
     private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+    private final Map<Context, List<WeakReference<AsyncHttpRequest>>> requestMap;
     private final Map<String, String> clientHeaderMap;
 
 
@@ -169,7 +170,7 @@ public void process(HttpResponse response, HttpContext context) {
 
         threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
 
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        requestMap = new WeakHashMap<Context, List<WeakReference<AsyncHttpRequest>>>();
         clientHeaderMap = new HashMap<String, String>();
     }
 
@@ -283,18 +284,28 @@ public void setBasicAuth( String user, String pass, AuthScope scope){
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
      */
     public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+    	d("cancelRequests");
+    	d(context.getClass().getCanonicalName());
+        List<WeakReference<AsyncHttpRequest>> requestList = requestMap.get(context);
         if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
+            for(WeakReference<AsyncHttpRequest> requestRef : requestList) {
+                AsyncHttpRequest request = requestRef.get();
+                
                 if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
+                    request.cancel();
+                    d("canceled:"+request);
                 }
             }
         }
         requestMap.remove(context);
     }
 
+    private static final String TAG ="AsyncHttpClient";
+    private static void d(Object o){
+    	Log.d(TAG,o==null?"null":o.toString());
+    	
+    }
+    
 
     //
     // HTTP GET Requests
@@ -570,17 +581,18 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
             uriRequest.addHeader("Content-Type", contentType);
         }
 
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
+        AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+        Future<?> future = threadPool.submit(request);
 
         if(context != null) {
             // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+            List<WeakReference<AsyncHttpRequest>> requestList = requestMap.get(context);
             if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
+                requestList = new LinkedList<WeakReference<AsyncHttpRequest>>();
                 requestMap.put(context, requestList);
             }
 
-            requestList.add(new WeakReference<Future<?>>(request));
+            requestList.add(new WeakReference<AsyncHttpRequest>(request));
 
             // TODO: Remove dead weakrefs from requestLists?
         }
@@ -634,4 +646,6 @@ public long getContentLength() {
             return -1;
         }
     }
+    
+    
 }
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
index 48e6807e..284d1d31 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -30,6 +30,8 @@
 import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.http.protocol.HttpContext;
 
+import android.util.Log;
+
 class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
@@ -46,6 +48,18 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         if(responseHandler instanceof BinaryHttpResponseHandler) {
             this.isBinaryRequest = true;
         }
+        cancel = false;
+    }
+    
+    
+    private boolean cancel;
+    public void cancel(){
+    	cancel = true;
+    }
+    
+    public boolean isCancel(){
+    	return cancel;
+    	//Thread.currentThread().isInterrupted();
     }
 
     @Override
@@ -71,12 +85,20 @@ public void run() {
             }
         }
     }
+    
+    private static final String TAG ="AsyncHttpRequest";
+    private static void d(Object o){
+    	Log.d(TAG,o==null?"null":o.toString());
+    	
+    }
 
     private void makeRequest() throws IOException {
+    	d("makeRequest");
         if(!Thread.currentThread().isInterrupted()) {
         	try {
         		HttpResponse response = client.execute(request, context);
-        		if(!Thread.currentThread().isInterrupted()) {
+        		d("isInterrupted:"+isCancel());
+        		if(!isCancel()) {
         			if(responseHandler != null) {
         				responseHandler.sendResponseMessage(response);
         			}
@@ -84,7 +106,7 @@ private void makeRequest() throws IOException {
         			//TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
         		}
         	} catch (IOException e) {
-        		if(!Thread.currentThread().isInterrupted()) {
+        		if(!isCancel()) {
         			throw e;
         		}
         	}
