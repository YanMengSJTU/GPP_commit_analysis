diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/.travis.yml b/.travis.yml
old mode 100644
new mode 100755
index a7560a7b..ff2abb9d
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,43 +1,16 @@
-branches:
-  only:
-    - master
-language:
-  - java
-jdk:
-  - openjdk6
-before_install:
-  # environment info
-  - mvn -version
-  - gradle -v
-  - uname -a
-  # required libs for android build tools
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  # for gradle output style
-  - export TERM=dumb
-  # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.8-bin.zip
-  - unzip -qq gradle-1.8-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.8
-  - export PATH=$GRADLE_HOME/bin:$PATH
-  # just to test gradle version, against our provided one
-  - gradle -v
-  # newest android SDK 22.0.5
-  - wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz
-  - tar -zxf android-sdk_r22.0.5-linux.tgz
-  - export ANDROID_HOME=`pwd`/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  # manually set sdk.dir variable, according to local paths
-  - echo "sdk.dir=$ANDROID_HOME" > local.properties
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-18 --force --no-ui
-  # build tools cannot be installed through "android update sdk" as of now
-  - wget http://dl.google.com/android/repository/build-tools_r18.0.1-linux.zip
-  - mkdir -p $ANDROID_HOME/build-tools
-  - unzip -qq build-tools_r18.0.1-linux.zip -d $ANDROID_HOME/build-tools/
-  - mv $ANDROID_HOME/build-tools/android-4.3 $ANDROID_HOME/build-tools/18.0.1
-  # verify files exist in right paths
-  - find $ANDROID_HOME/build-tools
-  - file $ANDROID_HOME/build-tools/18.0.1/aapt
+language: android
+jdk: openjdk7
+android:
+  components:
+    - build-tools-22.0.1
+    - extra-android-support
+    - extra-android-m2repository
+    - android-22
+  licenses:
+    - '.+'
+script:
+  # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
-
+  - ./gradlew clean assemble check
+  - ./gradlew :library:androidJavadocs
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..fd8a4f6d
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,140 @@
+# CHANGELOG
+
+## 1.4.8 (released 17. 7. 2015)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.8](https://github.com/loopj/android-async-http/commits/1.4.8)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=7&state=closed](https://github.com/loopj/android-async-http/issues?milestone=7&state=closed)
+
+  - New constructor for BinaryHttpResponseHandler which takes Looper as argument (thanks to @ScottFrank)
+  - SaxAsyncHttpResponseHandler can be now provided with custom charset, instead of just using default one
+  - Library LogCat tags now use shorter form (forced through Lint checks), appendix "ResponseHandler" shortened to "RH"
+  - Updated documentation on `RequestHandle.cancel(boolean)` and returning correct response according to handle state
+  - SaxAsyncHttpResponseHandler onFailure(int, Header[], byte[], Throwable) used wrong fallback to onSuccess(int, Header[], T), fixed to onFailure(int, Header[], T), where T extends SAX DefaultHandler
+  - Regression fix on onProgress(int,int) documentation
+  - Sample application now can be built with LeakCanary, use i.e. `gradle :sample:installWithLeakCanaryDebug` to use it
+  - Updated RequestParams documentation on handling arrays, sets and maps, along with new RequestParamsDebug sample
+  - Added BlackholeHttpResponseHandler implementation, which discards all response contents and silents all various log messages (see #416)
+  - Added LogInterface, it's default implementation and interface option to disable/enable logging library-wide and set logging verbosity
+  - Added option to TAG RequestHandle and cancel all requests matching specified TAG through `AsyncHttpClient.cancelRequestsByTAG(Object TAG)`
+  - Removed deprecated `getTimeout()` replaced by `getConnectTimeout()` and `getResponseTimeout()` respectively
+  - Removed deprecated `clearBasicAuth()` replaced by `clearCredentialsProvider()`
+
+## 1.4.7 (released 9. 5. 2015)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.7](https://github.com/loopj/android-async-http/commits1.4.7)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=6&state=closed](https://github.com/loopj/android-async-http/issues?milestone=6&state=closed)
+
+  - Fixed crash when canceling through RequestHandle from UI Thread (NetworkOnMainThreadException)
+  - Fixed URL encoding feature, that was breaking whole URL, not just path and query parts
+  - FileAsyncHttpResponseHandler now checks that target file path is available or can be created
+  - DataAsyncHttpResponseHandler was sending cancel notification instead of progress notification, fixed
+  - Added support for HTTP PATCH requests
+  - Fixed Assert exception when mkdirs in FileAsyncHttpResponseHandler tries to create dirs that already exists
+  - Provided option to easily override ClientConnectionManager provision in AsyncHttpClient
+  - Changed onProgress from (int,int) to (long,long) for dealing with large transfers
+  - Renamed typo of `preemtive` to `preemptive` (preemptive basic auth)
+  - Added option to put File array in RequestParams
+  - RequestParams now support forcing Content-Type into `multipart/form-data` even if there are no files/streams to be multiparted
+  - Gradle added support for installing to local maven repository, through `gradle installArchives` task
+  - Added support for Json RFC5179 in JsonHttpResponseHandler
+
+## 1.4.6 (released 7. 9. 2014)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.6](https://github.com/loopj/android-async-http/commits/1.4.6)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=4&state=closed](https://github.com/loopj/android-async-http/issues?milestone=2&state=closed)
+
+  - Fixed missing boundary when passing content-type as call param along with HttpEntity
+  - Added warnings for not overriden calls in JsonHttpResponseHandler (and others)
+  - RequestParams now implement Serializable, to support storing them and passing them along
+  - Added option to add File part with custom file name (overriding the real file name)
+  - Fixed not-escaped contents in JsonStreamEntity
+  - Separated connect and response timeout settings
+  - Allowed to pass Looper into *HttpResponseHandler classes
+  - Fixed reporting progress on GZIP compressed down-streams
+  - Added more samples (eg. AsyncBackgroundThreadSample.java, ContentTypeForHttpEntitySample.java, PrePostProcessingSample.java)
+  - Added option to pre- and post- process data in AsyncHttpRequest.java via subclass (see PrePostProcessingSample.java)
+  - Fixed ConcurrentModificationException on AsyncHttpClient.cancelRequests
+  - Fixed handling BOM in decoding response in TextHttpResponseHandler and JsonHttpResponseHandler
+
+## 1.4.5 (released 22. 6. 2014)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.5](https://github.com/loopj/android-async-http/commits/1.4.5)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=2&state=closed](https://github.com/loopj/android-async-http/issues?milestone=2&state=closed)
+
+  - Support for circular and relative redirects
+  - Added support for SAX parsing, see `SaxAsyncHttpResponseHandler`
+  - Fixed Threading issue when used in Service or non-UI Thread context
+  - Fixed GZIPInputStream issue when running in StrictMode
+  - Removed unnecessary (ambiguous) callback methods (were deprecated in 1.4.4)
+  - Added JsonStreamerEntity to allow up streaming JSON data
+  - Added possibility to modify blacklisted/whitelisted exceptions (see `RetryHandler`)
+  - Using `newCachedThreadPool()` as default ExecutorService in library, with option to change it via main interface
+  - Added `ResponseHandlerInterface` to support completely custom implementations of response handlers
+  - Added `onProgress(int,int)` callback, which is used for upstream progress logging (eg. Progressbar dialogs)
+  - Fixed "division by zero" in default response handler
+  - Added DataAsyncHttpResponseHandler, which has extra callback method which receives partially received data
+  - Fixed problem with uploading more than 2 files (changes in SimpleMultipartEntity)
+  - Fixed problem where on GarbageCollectors activity there was no callback received
+  - Added warning for cases, where headers overwrite each other (between common headers and per-request headers)
+  - Safely closing IO streams (both upstream and downstream)
+  - Fixed PersistentCookieStore issue, where non-persistent cookies were stored and added option to delete stored cookie
+  - Fixed networkOnMainThreadException when canceling requests (`AsyncHttpClient#cancel(boolean)`)
+  - Removed default User-Agent definition from library
+  - Fixed handling null URLs in default interface calls
+  - Allowed to subclass AsyncHttpClient and simply provide custom AsyncHttpRequest object (`AsyncHttpClient#newAsyncHttpRequest`)
+  - Changed project structure to be default Intellij IDEA structure (eg. library/src/main/java)
+  - Catching UnsupportedEncodingException default Async and Text response handlers
+  - Added strict Lint checking for both Library and Sample application
+  - Added example implementations in Sample application
+    - Requests threading (ThreadPool usage, 6 seconds delay on response)
+    - Synchronous request (from Activity and IntentService)
+    - SAX Parsing the response
+    - Retry request sample
+    - Handling 302 redirects
+    - RangeResponse (working with partially received data)
+    - Basic usage of GET, POST, PUT, DELETE
+    - JSON response parsing
+    - GZIP compressed communication
+    - Binary handler (receives `byte[]` without parsing/converting)
+    - File response handler (saving response directly into given File)
+    - Self-signed CA sample (how to pin SSL certificate or add custom trust-chain for requests)
+    - Persistent cookies store (persisting cookies between requests)
+    - Post multi-part encoded Files (SimpleMultipartEntity)
+    - Jackson JSON integration
+
+## 1.4.4 (released 28. 10. 2013)
+
+Complete list of commits included is here [https://github.com/loopj/android-async-http/commits/1.4.4](https://github.com/loopj/android-async-http/commits/1.4.4)  
+List of closed issues is here [https://github.com/loopj/android-async-http/issues?milestone=1&state=closed](https://github.com/loopj/android-async-http/issues?milestone=1&state=closed)
+
+  - Added FileAsyncHttpResponseHandler for direct saving response into File instead of device memory
+  - JsonHttpResponseHandler now parsing JSON in separate thread
+  - Interface method to allow/deny handling of http redirects
+  - Added method to delete previously set header (AsyncHttpClient.java)
+  - Not creating new Thread if call initiated outside of UI Thread (broken, fixed in 1.4.5)
+  - Support for changing response Charset (default still UTF-8)
+  - Allow setting maximum retries count (AsyncHttpClient.java)
+  - SimpleMultipartEntity now allows repeated usage (`HttpEntity.isRepeatable()`)
+  - Added custom SSLSocketFactory to allow certificate pinning and accepting self-signed or untrusted SSL certificates
+  - Callbacks to return HTTP status code and response Headers
+  - Added support for unsetting Basic Auth params
+  - Added support for non-standard HTTP and HTTPS ports (new constructors of `AsyncHttpClient`)
+  - Allowed to change dynamically allowed content-types for BinaryHttpResponseHandler per-response-handler (was static previously)
+  - Added support for setting proxy, optionally with authentication
+    - `AsyncHttpClient#setProxy(String hostname, int port, String username, String password)`
+  - Support for passing Maps, Sets and Lists via RequestParams
+  - Properly chaining callback methods (onSuccess, onFailure, ...) in descendant order by number of function params
+  - Fixed incorrect handling of URLs with spaces after redirect
+    - now sanitizes spaces within URL both on-request and on-redirect
+  - Added RequestHandle which can be used to cancel and/or check request status
+    - Is returned for each call (`.post(...)`, `.get(...)`, `.head(...)`, `.put(...)`, etc..)
+  - Added BaseJsonHttpResponseHandler to simplify integration with Jackson JSON, Gson and other JSON parsing libraries
+  - Added Sample application to demonstrate functions and usage
+    - Using [https://httpbin.org/](https://httpbin.org/) to test methods
+  - Enforcing INTERNET permission
+  - Support for Gradle buildscript
+  - Support for Travis CI (Continuous Integration) testing
+  - Dropped support for Eclipse ADT usage (obsolete)
+  - Added HTTP HEAD method support
+  - Releasing both AAR and JAR (+javadoc and sources) into Maven Central repository
+  - Added tons of mising Javadoc for both classes and methods
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..fa99f584
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,47 @@
+CONTRIBUTING
+============
+AsyncHttpClient is an open-source project made by developers for developers!
+
+If you would like to contribute to the project, it's really great. You can contribute in a variety of ways:
+
+  * Help us with test cases and examples for the Wiki (and kindly follow our [Coding Standards](#coding-standards))
+  * If you have a good idea/patch for the project, create a [pull request](#pull-requests)
+  * Found a bug? You're more than welcome to [submit an issue](#issues)
+  * Help other fellow developers solve their problems, you're welcome to do so in issues
+
+We do require certain guidelines to be followed so that the quality of the project remains top-notch:
+
+PULL requests
+-------------
+When you submit a patch or a new functionality for the project, you must open a pull request. We will get to the pull request as soon as possible, investigate what functionality or bug fixes have been added and decide whether to include it in the library or not -- for the benefit of everyone.
+
+**You agree that all contributions that you make to the library will be distributed further under the same license as the library itself (Apache V2).**
+
+Don't be discouraged if your pull request is rejected. This is not a deadline and sometimes with a proper explanation on your side, we are persuaded to merge in the request. Just remember that this is a library for everyone and as such must meet certain, generic rules that we would like to believe are following.  
+
+ISSUES
+---------
+
+![Read the ISSUES?](https://i.imgur.com/LPWyLe7.jpg "Read the ISSUES?")
+
+The issues system is the place to report bugs and not for submitting patches or new functionality. As helpful as we would like to be, we cannot replace the developer and we certainly do not see what you're seeing. So when you come to report an issue, follow these simple rules:  
+
+  * Report bugs in the English language only
+  * Use Markdown to format your issue in a fashionable way (easier to read): [Familiarize yourself](https://help.github.com/articles/github-flavored-markdown)
+  * If the issue is due to a crash, include the stack trace -- `throwable.printStackTrace()` -- and any other detail that will shed light on the problem
+  * We need to see the source code (minus certain details that you think are confidential) that caused the problem in the first place, so include it too
+
+Opening issues without providing us with the information necessary to debug and fix it is useless; so we will close such issues within 7 days period  
+
+CODING STANDARDS
+----------------
+We need you to follow certain rules when sending source code contributions. These are the basic principles that we ourselves abide to and we require that you do so as well:
+
+  * Do not use the Tab character (it's in first place for a reason)
+  * Indentation is 4 spaces
+  * Include the copyright info (as in other files) at the top of the class file
+  * You must provide proper Javadoc, including description, in English for both public and protected methods, classes and properties
+  * Group packages that belong to the same top-level package together, followed by an empty line
+  * Add an empty line after and before class/interface declarations, methods and constructors
+  * Add an empty line before and after a group of properties
+  * Do not catch generic Exception/Throwable errors, but always catch the most specific type of the exception/error
diff --git a/NOTICE.txt b/NOTICE.txt
new file mode 100644
index 00000000..45deb101
--- /dev/null
+++ b/NOTICE.txt
@@ -0,0 +1,6 @@
+Android Async Http Client library
+Copyright (c) 2011-2015 James Smith <james@loopj.com>
+https://loopj.com
+
+This product includes software developed by
+The Apache Software Foundation (https://www.apache.org/).
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index 2dd17dd7..23e29fd6
--- a/README.md
+++ b/README.md
@@ -1,10 +1,22 @@
 Asynchronous Http Client for Android
 ====================================
+[![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
 
-Travis CI state : [![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
+An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](https://hc.apache.org/httpcomponents-client-ga/) libraries.
 
-An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
+Changelog
+---------
 
+See what is new in version 1.4.8 released on 17th July 2015
+
+https://github.com/loopj/android-async-http/blob/1.4.8/CHANGELOG.md
+
+Javadoc
+-------
+
+Latest Javadoc for 1.4.8 release are available here (also included in Maven repository):
+
+https://loopj.com/android-async-http/doc/
 
 Features
 --------
@@ -13,39 +25,74 @@ Features
 - Requests use a **threadpool** to cap concurrent resource usage
 - GET/POST **params builder** (RequestParams)
 - **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **19kb** for everything
+- Tiny size overhead to your application, only **60kb** for everything
 - Automatic smart **request retries** optimized for spotty mobile connections
 - Automatic **gzip** response decoding support for super-fast requests
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
 - Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
 
+Examples
+--------
+
+For inspiration and testing on device we've provided Sample Application.  
+See individual samples [here on Github](https://github.com/loopj/android-async-http/tree/1.4.8/sample/src/main/java/com/loopj/android/http/sample)  
+To run Sample application, simply clone the repository and run this command, to install it on connected device  
+
+```java
+gradle :sample:installDebug
+```
+
 Maven
 -----
 You can now integrate this library in your project via Maven. There are available two kind of builds.
 
-**development snapshots**
-https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
+**releases, maven central**
+
+https://repo1.maven.org/maven2/com/loopj/android/android-async-http/
 ```
-Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
+Maven URL: https://repo1.maven.org/maven2/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
-Version: 1.4.4-SNAPSHOT
+ArtifactId: android-async-http
+Version: 1.4.8
 Packaging: JAR or AAR
 ```
+Gradle
+```groovy
+repositories {
+  maven {
+    mavenCentral()
+  }
+}
+dependencies {
+  compile 'com.loopj.android:android-async-http:1.4.8'
+}
+```
 
-**releases, maven central**
+**development snapshots**
 
-http://central.maven.org/maven2/com/loopj/android/android-async-http/
+https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
 ```
-Maven URL: http://repo1.maven.org/maven2/
+Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
 ArtifactId: android-async-http
-Version: 1.4.4
+Version: 1.4.9-SNAPSHOT
 Packaging: JAR or AAR
 ```
+Gradle
+```groovy
+repositories {
+  maven {
+    url 'https://oss.sonatype.org/content/repositories/snapshots/'
+  }
+}
+dependencies {
+  compile 'com.loopj.android:android-async-http:1.4.9-SNAPSHOT'
+}
+```
 
 Documentation, Features and Examples
 ------------------------------------
 Full details and documentation can be found on the project page here:
 
-http://loopj.com/android-async-http/
+https://loopj.com/android-async-http/
+
diff --git a/build.gradle b/build.gradle
old mode 100644
new mode 100755
index 9fe1e6ad..97d2df08
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.6.+'
+        classpath 'com.android.tools.build:gradle:1.2.3'
     }
 }
 
@@ -14,7 +14,7 @@ def isReleaseBuild() {
 
 allprojects {
     group = 'com.loopj.android'
-    version = '1.4.4'
+    version = '1.4.9-SNAPSHOT'
 
     repositories {
         mavenCentral()
@@ -22,6 +22,7 @@ allprojects {
 
     tasks.withType(JavaCompile) {
         options.encoding = "UTF-8"
+        options.compilerArgs << "-Xlint:unchecked"
     }
 }
 
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
deleted file mode 100644
index 998daa1f..00000000
--- a/examples/CookieVideoView.java
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.media.MediaPlayer.OnInfoListener;
-import android.net.Uri;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.widget.MediaController;
-import android.widget.MediaController.MediaPlayerControl;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.http.cookie.Cookie;
-
-/**
- * Displays a video file.  The VideoView class
- * can load images from various sources (such as resources or content
- * providers), takes care of computing its measurement from the video so that
- * it can be used in any layout manager, and provides various display options
- * such as scaling and tinting.
- *
- * @author Jungho Bang <me@bangtoven.com>
- */
-public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
-    private String TAG = "CookieVideoView";
-    // settable by the client
-    private Uri         mUri;
-    private Map<String, String> mHeaders;
-
-    // all possible internal states
-    private static final int STATE_ERROR              = -1;
-    private static final int STATE_IDLE               = 0;
-    private static final int STATE_PREPARING          = 1;
-    private static final int STATE_PREPARED           = 2;
-    private static final int STATE_PLAYING            = 3;
-    private static final int STATE_PAUSED             = 4;
-    private static final int STATE_PLAYBACK_COMPLETED = 5;
-
-    // mCurrentState is a VideoView object's current state.
-    // mTargetState is the state that a method caller intends to reach.
-    // For instance, regardless the VideoView object's current state,
-    // calling pause() intends to bring the object to a target state
-    // of STATE_PAUSED.
-    private int mCurrentState = STATE_IDLE;
-    private int mTargetState  = STATE_IDLE;
-
-    // All the stuff we need for playing and showing a video
-    private SurfaceHolder mSurfaceHolder = null;
-    private MediaPlayer mMediaPlayer = null;
-    private int         mVideoWidth;
-    private int         mVideoHeight;
-    private int         mSurfaceWidth;
-    private int         mSurfaceHeight;
-    private MediaController mMediaController;
-    private OnCompletionListener mOnCompletionListener;
-    private MediaPlayer.OnPreparedListener mOnPreparedListener;
-    private int         mCurrentBufferPercentage;
-    private OnErrorListener mOnErrorListener;
-    private OnInfoListener  mOnInfoListener;
-    private int         mSeekWhenPrepared;  // recording the seek position while preparing
-    private boolean     mCanPause;
-    private boolean     mCanSeekBack;
-    private boolean     mCanSeekForward;
-	private Context 	mContext;
-
-    public CookieVideoView(Context context) {
-        super(context);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initVideoView(context);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        //Log.i("@@@@", "onMeasure");
-        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
-        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
-        if (mVideoWidth > 0 && mVideoHeight > 0) {
-            if ( mVideoWidth * height  > width * mVideoHeight ) {
-                //Log.i("@@@", "image too tall, correcting");
-                height = width * mVideoHeight / mVideoWidth;
-            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
-                //Log.i("@@@", "image too wide, correcting");
-                width = height * mVideoWidth / mVideoHeight;
-            } else {
-                //Log.i("@@@", "aspect ratio is correct: " +
-                        //width+"/"+height+"="+
-                        //mVideoWidth+"/"+mVideoHeight);
-            }
-        }
-        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
-        setMeasuredDimension(width, height);
-    }
-
-    @SuppressLint("NewApi")
-	@Override
-    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-        super.onInitializeAccessibilityEvent(event);
-        event.setClassName(CookieVideoView.class.getName());
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-	@Override
-    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
-        super.onInitializeAccessibilityNodeInfo(info);
-        info.setClassName(CookieVideoView.class.getName());
-    }
-
-    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
-        int result = desiredSize;
-        int specMode = MeasureSpec.getMode(measureSpec);
-        int specSize =  MeasureSpec.getSize(measureSpec);
-
-        switch (specMode) {
-            case MeasureSpec.UNSPECIFIED:
-                /* Parent says we can be as big as we want. Just don't be larger
-                 * than max size imposed on ourselves.
-                 */
-                result = desiredSize;
-                break;
-
-            case MeasureSpec.AT_MOST:
-                /* Parent says we can be as big as we want, up to specSize.
-                 * Don't be larger than specSize, and don't be larger than
-                 * the max size imposed on ourselves.
-                 */
-                result = Math.min(desiredSize, specSize);
-                break;
-
-            case MeasureSpec.EXACTLY:
-                // No choice. Do what we are told.
-                result = specSize;
-                break;
-        }
-        return result;
-}
-
-    private void initVideoView(Context context) {
-        mVideoWidth = 0;
-        mVideoHeight = 0;
-        getHolder().addCallback(mSHCallback);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-        setFocusable(true);
-        setFocusableInTouchMode(true);
-        requestFocus();
-        mCurrentState = STATE_IDLE;
-        mTargetState  = STATE_IDLE;
-        mContext = context;
-    }
-
-    public void setVideoPath(String path) {
-        setVideoURI(Uri.parse(path));
-    }
-
-    public void setVideoURI(Uri uri) {
-    	mUri = uri;
-        mHeaders = getCookieHeader();
-    	mSeekWhenPrepared = 0;
-        openVideo();
-        requestLayout();
-        invalidate();
-    }
-    
-    private Map<String,String> getCookieHeader() {
-    	String hostDomain = mUri.getHost();
-    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
-    	for(Cookie cookie : cookieList) {
-    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
-    			Map<String,String> header = new HashMap<String, String>();
-    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
-    	    	Log.d(TAG,"Cookie: "+header.toString());
-    	        return header;
-    	    }
-    	}
-    	return null;
-    }
-    
-    public void stopPlayback() {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.stop();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            mTargetState  = STATE_IDLE;
-        }
-    }
-
-    private void openVideo() {
-        if (mUri == null || mSurfaceHolder == null) {
-            // not ready for playback just yet, will try again later
-            return;
-        }
-        // Tell the music playback service to pause
-        // TODO: these constants need to be published somewhere in the framework.
-        Intent i = new Intent("com.android.music.musicservicecommand");
-        i.putExtra("command", "pause");
-        mContext.sendBroadcast(i);
-
-        // we shouldn't clear the target state, because somebody might have
-        // called start() previously
-        release(false);
-        try {
-            mMediaPlayer = new MediaPlayer();
-            mMediaPlayer.setOnPreparedListener(mPreparedListener);
-            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
-            mMediaPlayer.setOnCompletionListener(mCompletionListener);
-            mMediaPlayer.setOnErrorListener(mErrorListener);
-            mMediaPlayer.setOnInfoListener(mOnInfoListener);
-            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
-            mCurrentBufferPercentage = 0;
-            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
-            mMediaPlayer.setDisplay(mSurfaceHolder);
-            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mMediaPlayer.setScreenOnWhilePlaying(true);
-            mMediaPlayer.prepareAsync();
-            // we don't set the target state here either, but preserve the
-            // target state that was there before.
-            mCurrentState = STATE_PREPARING;
-            attachMediaController();
-        } catch (IOException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        } catch (IllegalArgumentException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        }
-    }
-
-    public void setMediaController(MediaController controller) {
-        if (mMediaController != null) {
-            mMediaController.hide();
-        }
-        mMediaController = controller;
-        attachMediaController();
-    }
-
-    private void attachMediaController() {
-        if (mMediaPlayer != null && mMediaController != null) {
-            mMediaController.setMediaPlayer(this);
-            View anchorView = this.getParent() instanceof View ?
-                    (View)this.getParent() : this;
-            mMediaController.setAnchorView(anchorView);
-            mMediaController.setEnabled(isInPlaybackState());
-        }
-    }
-
-    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
-        new MediaPlayer.OnVideoSizeChangedListener() {
-            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-                mVideoWidth = mp.getVideoWidth();
-                mVideoHeight = mp.getVideoHeight();
-                if (mVideoWidth != 0 && mVideoHeight != 0) {
-                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                    requestLayout();
-                }
-            }
-    };
-
-    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
-        public void onPrepared(MediaPlayer mp) {
-            mCurrentState = STATE_PREPARED;
-
-            // Get the capabilities of the player for this stream
-//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
-//                                      MediaPlayer.BYPASS_METADATA_FILTER);
-//            
-//          if (data != null) {
-//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
-//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
-//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
-//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
-//            } else {
-                mCanPause = mCanSeekBack = mCanSeekForward = true;
-//            }
-
-            if (mOnPreparedListener != null) {
-                mOnPreparedListener.onPrepared(mMediaPlayer);
-            }
-            if (mMediaController != null) {
-                mMediaController.setEnabled(true);
-            }
-            mVideoWidth = mp.getVideoWidth();
-            mVideoHeight = mp.getVideoHeight();
-
-            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
-            if (seekToPosition != 0) {
-                seekTo(seekToPosition);
-            }
-            if (mVideoWidth != 0 && mVideoHeight != 0) {
-                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
-                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
-                    // We didn't actually change the size (it was already at the size
-                    // we need), so we won't get a "surface changed" callback, so
-                    // start the video here instead of in the callback.
-                    if (mTargetState == STATE_PLAYING) {
-                        start();
-                        if (mMediaController != null) {
-                            mMediaController.show();
-                        }
-                    } else if (!isPlaying() &&
-                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
-                       if (mMediaController != null) {
-                           // Show the media controls when we're paused into a video and make 'em stick.
-                           mMediaController.show(0);
-                       }
-                   }
-                }
-            } else {
-                // We don't know the video size yet, but should start anyway.
-                // The video size might be reported to us later.
-                if (mTargetState == STATE_PLAYING) {
-                    start();
-                }
-            }
-        }
-    };
-
-    private MediaPlayer.OnCompletionListener mCompletionListener =
-        new MediaPlayer.OnCompletionListener() {
-        public void onCompletion(MediaPlayer mp) {
-            mCurrentState = STATE_PLAYBACK_COMPLETED;
-            mTargetState = STATE_PLAYBACK_COMPLETED;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-            if (mOnCompletionListener != null) {
-                mOnCompletionListener.onCompletion(mMediaPlayer);
-            }
-        }
-    };
-
-    private MediaPlayer.OnErrorListener mErrorListener =
-        new MediaPlayer.OnErrorListener() {
-        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
-            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-
-            /* If an error handler has been supplied, use it and finish. */
-            if (mOnErrorListener != null) {
-                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
-                    return true;
-                }
-            }
-
-            /* Otherwise, pop up an error dialog so the user knows that
-             * something bad has happened. Only try and pop up the dialog
-             * if we're attached to a window. When we're going away and no
-             * longer have a window, don't bother showing the user an error.
-             */
-            if (getWindowToken() != null) {
-//                Resources r = mContext.getResources();
-                int messageId;
-
-                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
-                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
-                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
-                } else {
-                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
-                    messageId = R.string.VideoView_error_text_unknown;
-                }
-
-                new AlertDialog.Builder(mContext)
-                        .setMessage(messageId)
-                        //eg. <string name="VideoView_error_button">OK</string>
-                        .setPositiveButton(R.string.VideoView_error_button,
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int whichButton) {
-                                        /* If we get here, there is no onError listener, so
-                                         * at least inform them that the video is over.
-                                         */
-                                        if (mOnCompletionListener != null) {
-                                            mOnCompletionListener.onCompletion(mMediaPlayer);
-                                        }
-                                    }
-                                })
-                        .setCancelable(false)
-                        .show();
-            }
-            return true;
-        }
-    };
-
-    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
-        new MediaPlayer.OnBufferingUpdateListener() {
-        public void onBufferingUpdate(MediaPlayer mp, int percent) {
-            mCurrentBufferPercentage = percent;
-        }
-    };
-
-    /**
-     * Register a callback to be invoked when the media file
-     * is loaded and ready to go.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
-    {
-        mOnPreparedListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when the end of a media file
-     * has been reached during playback.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnCompletionListener(OnCompletionListener l)
-    {
-        mOnCompletionListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an error occurs
-     * during playback or setup.  If no listener is specified,
-     * or if the listener returned false, VideoView will inform
-     * the user of any errors.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnErrorListener(OnErrorListener l)
-    {
-        mOnErrorListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an informational event
-     * occurs during playback or setup.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnInfoListener(OnInfoListener l) {
-        mOnInfoListener = l;
-    }
-
-    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
-    {
-        public void surfaceChanged(SurfaceHolder holder, int format,
-                                    int w, int h)
-        {
-            mSurfaceWidth = w;
-            mSurfaceHeight = h;
-            boolean isValidState =  (mTargetState == STATE_PLAYING);
-            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
-            if (mMediaPlayer != null && isValidState && hasValidSize) {
-                if (mSeekWhenPrepared != 0) {
-                    seekTo(mSeekWhenPrepared);
-                }
-                start();
-            }
-        }
-
-        public void surfaceCreated(SurfaceHolder holder)
-        {
-            mSurfaceHolder = holder;
-            openVideo();
-        }
-
-        public void surfaceDestroyed(SurfaceHolder holder)
-        {
-            // after we return from this we can't use the surface any more
-            mSurfaceHolder = null;
-            if (mMediaController != null) mMediaController.hide();
-            release(true);
-        }
-    };
-
-    /*
-     * release the media player in any state
-     */
-    private void release(boolean cleartargetstate) {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.reset();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            if (cleartargetstate) {
-                mTargetState  = STATE_IDLE;
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onTrackballEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
-                                     keyCode != KeyEvent.KEYCODE_MENU &&
-                                     keyCode != KeyEvent.KEYCODE_CALL &&
-                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
-        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
-            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
-                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                } else {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
-                if (!mMediaPlayer.isPlaying()) {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
-                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                }
-                return true;
-            } else {
-                toggleMediaControlsVisiblity();
-            }
-        }
-
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void toggleMediaControlsVisiblity() {
-        if (mMediaController.isShowing()) {
-            mMediaController.hide();
-        } else {
-            mMediaController.show();
-        }
-    }
-
-    public void start() {
-        if (isInPlaybackState()) {
-            mMediaPlayer.start();
-            mCurrentState = STATE_PLAYING;
-        }
-        mTargetState = STATE_PLAYING;
-    }
-
-    public void pause() {
-        if (isInPlaybackState()) {
-            if (mMediaPlayer.isPlaying()) {
-                mMediaPlayer.pause();
-                mCurrentState = STATE_PAUSED;
-            }
-        }
-        mTargetState = STATE_PAUSED;
-    }
-
-    public void suspend() {
-        release(false);
-    }
-
-    public void resume() {
-        openVideo();
-    }
-
-    public int getDuration() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getDuration();
-        }
-
-        return -1;
-    }
-
-    public int getCurrentPosition() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getCurrentPosition();
-        }
-        return 0;
-    }
-
-    public void seekTo(int msec) {
-        if (isInPlaybackState()) {
-            mMediaPlayer.seekTo(msec);
-            mSeekWhenPrepared = 0;
-        } else {
-            mSeekWhenPrepared = msec;
-        }
-    }
-
-    public boolean isPlaying() {
-        return isInPlaybackState() && mMediaPlayer.isPlaying();
-    }
-
-    public int getBufferPercentage() {
-        if (mMediaPlayer != null) {
-            return mCurrentBufferPercentage;
-        }
-        return 0;
-    }
-
-    private boolean isInPlaybackState() {
-        return (mMediaPlayer != null &&
-                mCurrentState != STATE_ERROR &&
-                mCurrentState != STATE_IDLE &&
-                mCurrentState != STATE_PREPARING);
-    }
-
-    public boolean canPause() {
-        return mCanPause;
-    }
-
-    public boolean canSeekBackward() {
-        return mCanSeekBack;
-    }
-
-    public boolean canSeekForward() {
-        return mCanSeekForward;
-    }
-}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
deleted file mode 100644
index b5c4fc6f..00000000
--- a/examples/ExampleUsage.java
+++ /dev/null
@@ -1,12 +0,0 @@
-public class ExampleUsage {
-    public static void makeRequest() {
-        AsyncHttpClient client = new AsyncHttpClient();
-
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
-            @Override
-            public void onSuccess(String response) {
-                System.out.println(response);
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
deleted file mode 100644
index ce949817..00000000
--- a/examples/TestCaseExampleUsage.java
+++ /dev/null
@@ -1,63 +0,0 @@
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
-import android.test.InstrumentationTestCase;
-import android.util.Log;
-
-// Credits to Wuyexiong <forever_crying@qq.com>
-// See: https://github.com/loopj/android-async-http/pull/236
-public class TestCaseExampleUsage extends InstrumentationTestCase
-{
-	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
-
-	public void testAsync() throws Throwable
-	{
-		final CountDownLatch signal = new CountDownLatch(1);
-		runTestOnUiThread(new Runnable()
-		{
-			@Override
-			public void run()
-			{
-				AsyncHttpClient client = new AsyncHttpClient();
-
-				client.get("http://www.google.com", new AsyncHttpResponseHandler()
-				{
-					@Override
-					public void onStart()
-					{
-						Log.v(TAG , "onStart");
-					}
-
-					@Override
-					public void onSuccess(String response)
-					{
-						Log.v(TAG , "onSuccess");
-						System.out.println(response);
-					}
-
-					@Override
-					public void onFailure(Throwable error, String content)
-					{
-						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
-					}
-
-					@Override
-					public void onFinish()
-					{
-						Log.v(TAG , "onFinish");
-						signal.countDown();
-					}
-				});
-
-				try {
-					signal.await(30, TimeUnit.SECONDS);
-				} catch (InterruptedException e) {
-				}
-				Log.v(TAG , "TestCaseExampleUsage Over");
-			}
-		});
-	}
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
deleted file mode 100644
index 395273df..00000000
--- a/examples/TwitterRestClient.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// Static wrapper library around AsyncHttpClient
-
-public class TwitterRestClient {
-    private static final String BASE_URL = "http://api.twitter.com/1/";
-
-    private static AsyncHttpClient client = new AsyncHttpClient();
-
-    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.post(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    private static String getAbsoluteUrl(String relativeUrl) {
-        return BASE_URL + relativeUrl;
-    }
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
deleted file mode 100644
index 297bfecc..00000000
--- a/examples/TwitterRestClientUsage.java
+++ /dev/null
@@ -1,18 +0,0 @@
-class TwitterRestClientUsage {
-    public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
-            @Override
-            public void onSuccess(JSONArray timeline) {
-                try {
-                    JSONObject firstEvent = (JSONObject) timeline.get(0);
-                    String tweetText = firstEvent.getString("text");
-
-                    // Do something with the response
-                    System.out.println(tweetText);
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
old mode 100644
new mode 100755
index 2c0fb8c8..ff934178
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,12 +1,16 @@
-VERSION_NAME=1.4.4
-VERSION_CODE=144
+VERSION_NAME=1.4.9-SNAPSHOT
+VERSION_CODE=149
 GROUP=com.loopj.android
 
 POM_DESCRIPTION=An Asynchronous HTTP Library for Android
-POM_URL=loopj.com/android-async-http/
+POM_URL=https://loopj.com/android-async-http/
 POM_SCM_URL=https://github.com/loopj/android-async-http
 POM_SCM_CONNECTION=scm:git@github.com:loopj/android-async-http.git
 POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_URL=https://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=jamessmith
+POM_DEVELOPER_NAME=James Smith
+
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..30d399d8
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..3af41f22
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Jul 31 10:35:35 CEST 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..aec99730
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/build.gradle b/library/build.gradle
old mode 100644
new mode 100755
index 3c059967..31d25004
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,30 +1,34 @@
-apply plugin: 'android-library'
+apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion '18.0.1'
-}
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "android${name.capitalize()}Jar", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
+    defaultConfig {
+        minSdkVersion 3
+        targetSdkVersion 22
+    }
 
-android.libraryVariants.all { variant ->
+    lintOptions {
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
+        disable 'OldTargetApi'
+    }
 
-    task("generate${variant.name}Javadoc", type: Javadoc) {
-        description "Generates Javadoc for $variant.name."
-        source = variant.javaCompile.source
-        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
     }
+}
 
+android.libraryVariants.all { variant ->
+    def name = variant.buildType.name
+    def task = project.tasks.create "jar${name.capitalize()}", Jar
+    task.dependsOn variant.javaCompile
+    task.from variant.javaCompile.destinationDir
+    artifacts.add('archives', task);
 }
 
 apply from: '../maven_push.gradle'
diff --git a/library/gradle.properties b/library/gradle.properties
old mode 100644
new mode 100755
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
index 0705929f..3049b2d6
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,14 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http"
-    android:versionName="1.4.4"
-    android:versionCode="144">
+          package="com.loopj.android.http">
 
-    <uses-sdk
-        android:minSdkVersion="3" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
-    <uses-permission android:name="android.permission.INTERNET" />
-
-    <application />
+    <application/>
 
 </manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
old mode 100644
new mode 100755
index 92116f4b..b9ee3135
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -19,11 +19,12 @@
 package com.loopj.android.http;
 
 import android.content.Context;
-import android.util.Log;
+import android.os.Looper;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpException;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
@@ -31,17 +32,21 @@
 import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
+import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.RedirectHandler;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpHead;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
 import org.apache.http.conn.params.ConnRoutePNames;
@@ -50,28 +55,35 @@
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.auth.BasicScheme;
 import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
+import java.io.OutputStream;
+import java.io.PushbackInputStream;
+import java.lang.reflect.Field;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.zip.GZIPInputStream;
 
 
@@ -82,36 +94,54 @@
  * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new ResponseHandlerInterface() {
+ * client.get("https://www.google.com", new AsyncHttpResponseHandler() {
  *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+ *          System.out.println(response);
+ *     }
+ *     &#064;Override
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
+ * {
+ *          error.printStackTrace(System.out);
  *     }
  * });
  * </pre>
+ *
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ * @see com.loopj.android.http.ResponseHandlerInterface
+ * @see com.loopj.android.http.RequestParams
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.4";
 
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-    private static final String LOG_TAG = "AsyncHttpClient";
+    public static final String LOG_TAG = "AsyncHttpClient";
+
+    public static final String HEADER_CONTENT_TYPE = "Content-Type";
+    public static final String HEADER_CONTENT_RANGE = "Content-Range";
+    public static final String HEADER_CONTENT_ENCODING = "Content-Encoding";
+    public static final String HEADER_CONTENT_DISPOSITION = "Content-Disposition";
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+
+    public static final int DEFAULT_MAX_CONNECTIONS = 10;
+    public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+    public static final int DEFAULT_MAX_RETRIES = 5;
+    public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
+    public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private int timeout = DEFAULT_SOCKET_TIMEOUT;
+    private int connectTimeout = DEFAULT_SOCKET_TIMEOUT;
+    private int responseTimeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+    private ExecutorService threadPool;
+    private final Map<Context, List<RequestHandle>> requestMap;
     private final Map<String, String> clientHeaderMap;
     private boolean isUrlEncodingEnabled = true;
 
+    public static LogInterface log = new LogHandler();
+
     /**
      * Creates a new AsyncHttpClient with default constructor arguments values
      */
@@ -141,7 +171,7 @@ public AsyncHttpClient(int httpPort, int httpsPort) {
     /**
      * Creates new AsyncHttpClient using given params
      *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param fixNoHttpResponseException Whether to fix issue or not, by omitting SSL verification
      * @param httpPort                   HTTP port to be used, must be greater than 0
      * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
@@ -152,32 +182,33 @@ public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int htt
     /**
      * Returns default instance of SchemeRegistry
      *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param fixNoHttpResponseException Whether to fix issue or not, by omitting SSL verification
      * @param httpPort                   HTTP port to be used, must be greater than 0
      * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
     private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
         if (fixNoHttpResponseException) {
-            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
+            log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
         }
 
         if (httpPort < 1) {
             httpPort = 80;
-            Log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
+            log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
         }
 
         if (httpsPort < 1) {
             httpsPort = 443;
-            Log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
+            log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
         }
 
         // Fix to SSL flaw in API < ICS
         // See https://code.google.com/p/android/issues/detail?id=13117
         SSLSocketFactory sslSocketFactory;
-        if (fixNoHttpResponseException)
+        if (fixNoHttpResponseException) {
             sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
-        else
+        } else {
             sslSocketFactory = SSLSocketFactory.getSocketFactory();
+        }
 
         SchemeRegistry schemeRegistry = new SchemeRegistry();
         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
@@ -195,22 +226,22 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         BasicHttpParams httpParams = new BasicHttpParams();
 
-        ConnManagerParams.setTimeout(httpParams, timeout);
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
         ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
 
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
         HttpConnectionParams.setTcpNoDelay(httpParams, true);
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+        ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);
+        Utils.asserts(cm != null, "Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null");
 
-        threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(DEFAULT_MAX_CONNECTIONS);
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        threadPool = getDefaultThreadPool();
+        requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
         clientHeaderMap = new HashMap<String, String>();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
@@ -222,6 +253,17 @@ public void process(HttpRequest request, HttpContext context) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
                 }
                 for (String header : clientHeaderMap.keySet()) {
+                    if (request.containsHeader(header)) {
+                        Header overwritten = request.getFirstHeader(header);
+                        log.d(LOG_TAG,
+                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
+                                        header, clientHeaderMap.get(header),
+                                        overwritten.getName(), overwritten.getValue())
+                        );
+
+                        //remove the overwritten header
+                        request.removeHeader(overwritten);
+                    }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
             }
@@ -246,9 +288,40 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                        ClientContext.CREDS_PROVIDER);
+                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+                if (authState.getAuthScheme() == null) {
+                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+                    Credentials creds = credsProvider.getCredentials(authScope);
+                    if (creds != null) {
+                        authState.setAuthScheme(new BasicScheme());
+                        authState.setCredentials(creds);
+                    }
+                }
+            }
+        }, 0);
+
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
+    public static void allowRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToWhitelist(cls);
+        }
+    }
+
+    public static void blockRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToBlacklist(cls);
+        }
+    }
+
     /**
      * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
      * settings for requests by accessing the client's ConnectionManager, HttpParams and
@@ -270,6 +343,67 @@ public HttpContext getHttpContext() {
         return this.httpContext;
     }
 
+    /**
+     * Will set logging enabled flag on underlying LogInterface instance.
+     * Default setting is logging enabled.
+     *
+     * @param loggingEnabled whether the logging should be enabled or not
+     */
+    public void setLoggingEnabled(boolean loggingEnabled) {
+        log.setLoggingEnabled(loggingEnabled);
+    }
+
+    /**
+     * Returns logging enabled flag from underlying LogInterface instance
+     * Default setting is logging enabled.
+     *
+     * @return boolean whether is logging across the library currently enabled
+     */
+    public boolean isLoggingEnabled() {
+        return log.isLoggingEnabled();
+    }
+
+    /**
+     * Sets log level to be used across all library default implementation
+     * Default setting is VERBOSE log level.
+     *
+     * @param logLevel int log level, either from LogInterface interface or from {@link android.util.Log}
+     */
+    public void setLoggingLevel(int logLevel) {
+        log.setLoggingLevel(logLevel);
+    }
+
+    /**
+     * Retrieves current log level from underlying LogInterface instance.
+     * Default setting is VERBOSE log level.
+     *
+     * @return int log level currently in effect
+     */
+    public int getLoggingLevel() {
+        return log.getLoggingLevel();
+    }
+
+    /**
+     * Will return current LogInterface used in AsyncHttpClient instance
+     *
+     * @return LogInterface currently used by AsyncHttpClient instance
+     */
+    public LogInterface getLogInterface() {
+        return log;
+    }
+
+    /**
+     * Sets default LogInterface (similar to std Android Log util class) instance,
+     * to be used in AsyncHttpClient instance
+     *
+     * @param logInterfaceInstance LogInterface instance, if null, nothing is done
+     */
+    public void setLogInterface(LogInterface logInterfaceInstance) {
+        if (logInterfaceInstance != null) {
+            log = logInterfaceInstance;
+        }
+    }
+
     /**
      * Sets an optional CookieStore to use when making requests
      *
@@ -282,33 +416,93 @@ public void setCookieStore(CookieStore cookieStore) {
 
     /**
      * Overrides the threadpool implementation used when queuing/pooling requests. By default,
-     * Executors.newFixedThreadPool() is used.
+     * Executors.newCachedThreadPool() is used.
      *
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling
+     * @param threadPool an instance of {@link ExecutorService} to use for queuing/pooling
      *                   requests.
      */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
+    public void setThreadPool(ExecutorService threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Returns the current executor service used. By default, Executors.newCachedThreadPool() is
+     * used.
+     *
+     * @return current executor service used
+     */
+    public ExecutorService getThreadPool() {
+        return threadPool;
+    }
+
+    /**
+     * Get the default threading pool to be used for this HTTP client.
+     *
+     * @return The default threading pool to be used
+     */
+    protected ExecutorService getDefaultThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
+    /**
+     * Provided so it is easier for developers to provide custom ThreadSafeClientConnManager implementation
+     *
+     * @param schemeRegistry SchemeRegistry, usually provided by {@link #getDefaultSchemeRegistry(boolean, int, int)}
+     * @param httpParams     BasicHttpParams
+     * @return ClientConnectionManager instance
+     */
+    protected ClientConnectionManager createConnectionManager(SchemeRegistry schemeRegistry, BasicHttpParams httpParams) {
+        return new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
-     * on underlying HttpClient, effects of this method will be canceled.
+     * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
+     * setting is to disallow redirects.
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @param enableCircularRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
+        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
+        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
+        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
+    }
+
+    /**
+     * Circular redirects are enabled by default
      *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
+        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
+    }
+
+    /**
      * @param enableRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
      */
     public void setEnableRedirects(final boolean enableRedirects) {
-        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
-            @Override
-            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
-                return enableRedirects;
-            }
-        });
+        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
+    }
+
+    /**
+     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
+     * your needs
+     *
+     * @param customRedirectHandler RedirectHandler instance
+     * @see com.loopj.android.http.MyRedirectHandler
+     */
+    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
+        httpClient.setRedirectHandler(customRedirectHandler);
     }
 
     /**
      * Sets the User-Agent header to be sent with each request. By default, "Android Asynchronous
-     * Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     * Http Client/VERSION (https://loopj.com/android-async-http/)" is used.
      *
      * @param userAgent the string to use in the User-Agent header.
      */
@@ -340,27 +534,62 @@ public void setMaxConnections(int maxConnections) {
     }
 
     /**
-     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     * Set both the connection and socket timeouts. By default, both are set to
+     * 10 seconds.
      *
-     * @return Socket Timeout limit in milliseconds
+     * @param value the connect/socket timeout in milliseconds, at least 1 second
+     * @see #setConnectTimeout(int)
+     * @see #setResponseTimeout(int)
      */
-    public int getTimeout() {
-        return timeout;
+    public void setTimeout(int value) {
+        value = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        setConnectTimeout(value);
+        setResponseTimeout(value);
     }
 
     /**
-     * Set the connection and socket timeout. By default, 10 seconds.
+     * Returns current connection timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
      *
-     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
+     * @return Connection timeout limit in milliseconds
      */
-    public void setTimeout(int timeout) {
-        if (timeout < 1000)
-            timeout = DEFAULT_SOCKET_TIMEOUT;
-        this.timeout = timeout;
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
+    public int getConnectTimeout() {
+        return connectTimeout;
+    }
+
+    /**
+     * Set connection timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Connection timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setConnectTimeout(int value) {
+        connectTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, connectTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);
+    }
+
+    /**
+     * Returns current response timeout limit (milliseconds). By default, this
+     * is set to 10 seconds.
+     *
+     * @return Response timeout limit in milliseconds
+     */
+    public int getResponseTimeout() {
+        return responseTimeout;
+    }
+
+    /**
+     * Set response timeout limit (milliseconds). By default, this is set to
+     * 10 seconds.
+     *
+     * @param value Response timeout in milliseconds, minimal value is 1000 (1 second).
+     */
+    public void setResponseTimeout(int value) {
+        responseTimeout = value < 1000 ? DEFAULT_SOCKET_TIMEOUT : value;
+        final HttpParams httpParams = httpClient.getParams();
+        HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);
     }
 
     /**
@@ -392,7 +621,6 @@ public void setProxy(String hostname, int port, String username, String password
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
-
     /**
      * Sets the SSLSocketFactory to user when making requests. By default, a new, default
      * SSLSocketFactory is used.
@@ -413,6 +641,14 @@ public void setMaxRetriesAndTimeout(int retries, int timeout) {
         this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
     }
 
+    /**
+     * Will, before sending, remove all headers currently present in AsyncHttpClient instance, which
+     * applies on all requests this client makes
+     */
+    public void removeAllHeaders() {
+        clientHeaderMap.clear();
+    }
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
      *
@@ -440,8 +676,19 @@ public void removeHeader(String header) {
      * @param password Basic Auth password
      */
     public void setBasicAuth(String username, String password) {
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(username, password, scope);
+        setBasicAuth(username, password, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username   Basic Auth username
+     * @param password   Basic Auth password
+     * @param preemptive sets authorization in preemptive manner
+     */
+    public void setBasicAuth(String username, String password, boolean preemptive) {
+        setBasicAuth(username, password, null, preemptive);
     }
 
     /**
@@ -453,14 +700,50 @@ public void setBasicAuth(String username, String password) {
      * @param scope    - an AuthScope object
      */
     public void setBasicAuth(String username, String password, AuthScope scope) {
+        setBasicAuth(username, password, scope, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username   Basic Auth username
+     * @param password   Basic Auth password
+     * @param scope      an AuthScope object
+     * @param preemptive sets authorization in preemptive manner
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemptive) {
         UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+        setCredentials(scope, credentials);
+        setAuthenticationPreemptive(preemptive);
+    }
+
+    public void setCredentials(AuthScope authScope, Credentials credentials) {
+        if (credentials == null) {
+            log.d(LOG_TAG, "Provided credentials are null, not setting");
+            return;
+        }
+        this.httpClient.getCredentialsProvider().setCredentials(authScope == null ? AuthScope.ANY : authScope, credentials);
     }
 
     /**
-     * Removes set basic auth credentials
+     * Sets HttpRequestInterceptor which handles authorization in preemptive way, as workaround you
+     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
+     *
+     * @param isPreemptive whether the authorization is processed in preemptive way
      */
-    public void clearBasicAuth() {
+    public void setAuthenticationPreemptive(boolean isPreemptive) {
+        if (isPreemptive) {
+            httpClient.addRequestInterceptor(new PreemptiveAuthorizationHttpRequestInterceptor(), 0);
+        } else {
+            httpClient.removeRequestInterceptorByClass(PreemptiveAuthorizationHttpRequestInterceptor.class);
+        }
+    }
+
+    /**
+     * Removes previously set auth credentials
+     */
+    public void clearCredentialsProvider() {
         this.httpClient.getCredentialsProvider().clear();
     }
 
@@ -474,22 +757,81 @@ public void clearBasicAuth() {
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
      *                              pending requests.
      */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
+        if (context == null) {
+            log.e(LOG_TAG, "Passed null Context to cancelRequests");
+            return;
+        }
+
+        final List<RequestHandle> requestList = requestMap.get(context);
+        requestMap.remove(context);
+
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    cancelRequests(requestList, mayInterruptIfRunning);
+                }
+            };
+            threadPool.submit(runnable);
+        } else {
+            cancelRequests(requestList, mayInterruptIfRunning);
+        }
+    }
+
+    private void cancelRequests(final List<RequestHandle> requestList, final boolean mayInterruptIfRunning) {
         if (requestList != null) {
-            for (WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if (request != null) {
-                    request.cancel(mayInterruptIfRunning);
+            for (RequestHandle requestHandle : requestList) {
+                requestHandle.cancel(mayInterruptIfRunning);
+            }
+        }
+    }
+
+    /**
+     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
+     * only affect requests which were created with a non-null android Context. This method is
+     * intended to be used in the onDestroy method of your android activities to destroy all
+     * requests which are no longer required.
+     *
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelAllRequests(boolean mayInterruptIfRunning) {
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    requestHandle.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.clear();
+    }
+
+    /**
+     * Allows you to cancel all requests currently in queue or running, by set TAG,
+     * if passed TAG is null, will not attempt to cancel any requests, if TAG is null
+     * on RequestHandle, it cannot be canceled by this call
+     *
+     * @param TAG                   TAG to be matched in RequestHandle
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelRequestsByTAG(Object TAG, boolean mayInterruptIfRunning) {
+        if (TAG == null) {
+            log.d(LOG_TAG, "cancelRequestsByTAG, passed TAG is null, cannot proceed");
+            return;
+        }
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    if (TAG.equals(requestHandle.getTag()))
+                        requestHandle.cancel(mayInterruptIfRunning);
                 }
             }
         }
-        requestMap.remove(context);
     }
 
-    //
-    // HTTP HEAD Requests
-    //
+    // [+] HTTP HEAD
 
     /**
      * Perform a HTTP HEAD request, without any parameters.
@@ -558,10 +900,8 @@ public RequestHandle head(Context context, String url, Header[] headers, Request
                 context);
     }
 
-
-    //
-    // HTTP GET Requests
-    //
+    // [-] HTTP HEAD
+    // [+] HTTP GET
 
     /**
      * Perform a HTTP GET request, without any parameters.
@@ -630,10 +970,25 @@ public RequestHandle get(Context context, String url, Header[] headers, RequestP
                 context);
     }
 
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
 
-    //
-    // HTTP POST Requests
-    //
+    // [-] HTTP GET
+    // [+] HTTP POST
 
     /**
      * Perform a HTTP POST request, without any parameters.
@@ -685,7 +1040,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -703,7 +1058,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        HttpEntityEnclosingRequestBase request = new HttpPost(getURI(url));
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -727,14 +1082,13 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP PUT Requests
-    //
+    // [-] HTTP POST
+    // [+] HTTP PUT
 
     /**
      * Perform a HTTP PUT request, without any parameters.
@@ -787,7 +1141,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -806,14 +1160,88 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP DELETE Requests
-    //
+    /**
+     * Perform a HTTP
+     * request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        "application/json" if sending a json payload.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPatch(getURI(url)), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(getURI(url)), entity);
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    // [-] HTTP PUT
+    // [+] HTTP DELETE
 
     /**
      * Perform a HTTP DELETE request.
@@ -835,7 +1263,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(getURI(url));
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -849,11 +1277,23 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(getURI(url));
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional DELETE parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, null);
+    }
+
     /**
      * Perform a HTTP DELETE request.
      *
@@ -870,6 +1310,41 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpDelete(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
+    // [-] HTTP DELETE
+
+    /**
+     * Instantiate a new asynchronous HTTP request for the passed parameters.
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
+     *                        HttpPost, HttpGet, HttpPut, etc.
+     * @return AsyncHttpRequest ready to be dispatched
+     */
+    protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
     /**
      * Puts a new request in queue as a new thread in pool to be executed
      *
@@ -883,29 +1358,65 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
      * @return RequestHandle of future request process
      */
     protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        if (uriRequest == null) {
+            throw new IllegalArgumentException("HttpUriRequest must not be null");
+        }
+
+        if (responseHandler == null) {
+            throw new IllegalArgumentException("ResponseHandler must not be null");
+        }
+
+        if (responseHandler.getUseSynchronousMode() && !responseHandler.getUsePoolThread()) {
+            throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
+        }
+
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            if (uriRequest instanceof HttpEntityEnclosingRequestBase && ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != null && uriRequest.containsHeader(HEADER_CONTENT_TYPE)) {
+                log.w(LOG_TAG, "Passed contentType will be ignored because HttpEntity sets content type");
+            } else {
+                uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);
+            }
         }
 
         responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
         responseHandler.setRequestURI(uriRequest.getURI());
 
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
+        AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
+        threadPool.submit(request);
+        RequestHandle requestHandle = new RequestHandle(request);
 
         if (context != null) {
+            List<RequestHandle> requestList;
             // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if (requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
+            synchronized (requestMap) {
+                requestList = requestMap.get(context);
+                if (requestList == null) {
+                    requestList = Collections.synchronizedList(new LinkedList<RequestHandle>());
+                    requestMap.put(context, requestList);
+                }
             }
 
-            requestList.add(new WeakReference<Future<?>>(request));
+            requestList.add(requestHandle);
 
-            // TODO: Remove dead weakrefs from requestLists?
+            Iterator<RequestHandle> iterator = requestList.iterator();
+            while (iterator.hasNext()) {
+                if (iterator.next().shouldBeGarbageCollected()) {
+                    iterator.remove();
+                }
+            }
         }
 
-        return new RequestHandle(request);
+        return requestHandle;
+    }
+
+    /**
+     * Returns a {@link URI} instance for the specified, absolute URL string.
+     *
+     * @param url absolute URL string, containing scheme, host and path
+     * @return URI instance for the URL string
+     */
+    protected URI getURI(String url) {
+        return URI.create(url).normalize();
     }
 
     /**
@@ -927,21 +1438,85 @@ public void setURLEncodingEnabled(boolean enabled) {
      * @return encoded url if requested with params appended if any available
      */
     public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
-        if (shouldEncodeUrl)
-            url = url.replace(" ", "%20");
+        if (url == null)
+            return null;
+
+        if (shouldEncodeUrl) {
+            try {
+                String decodedURL = URLDecoder.decode(url, "UTF-8");
+                URL _url = new URL(decodedURL);
+                URI _uri = new URI(_url.getProtocol(), _url.getUserInfo(), _url.getHost(), _url.getPort(), _url.getPath(), _url.getQuery(), _url.getRef());
+                url = _uri.toASCIIString();
+            } catch (Exception ex) {
+                // Should not really happen, added just for sake of validity
+                log.e(LOG_TAG, "getUrlWithQueryString encoding URL", ex);
+            }
+        }
 
         if (params != null) {
-            String paramString = params.getParamString();
-            if (!url.contains("?")) {
-                url += "?" + paramString;
-            } else {
-                url += "&" + paramString;
+            // Construct the query string and trim it, in case it
+            // includes any excessive white spaces.
+            String paramString = params.getParamString().trim();
+
+            // Only add the query string if it isn't empty and it
+            // isn't equal to '?'.
+            if (!paramString.equals("") && !paramString.equals("?")) {
+                url += url.contains("?") ? "&" : "?";
+                url += paramString;
             }
         }
 
         return url;
     }
 
+    /**
+     * Checks the InputStream if it contains  GZIP compressed data
+     *
+     * @param inputStream InputStream to be checked
+     * @return true or false if the stream contains GZIP compressed data
+     * @throws java.io.IOException if read from inputStream fails
+     */
+    public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {
+        if (inputStream == null)
+            return false;
+
+        byte[] signature = new byte[2];
+        int readStatus = inputStream.read(signature);
+        inputStream.unread(signature);
+        int streamHeader = ((int) signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);
+        return readStatus == 2 && GZIPInputStream.GZIP_MAGIC == streamHeader;
+    }
+
+    /**
+     * A utility function to close an input stream without raising an exception.
+     *
+     * @param is input stream to close safely
+     */
+    public static void silentCloseInputStream(InputStream is) {
+        try {
+            if (is != null) {
+                is.close();
+            }
+        } catch (IOException e) {
+            log.w(LOG_TAG, "Cannot close input stream", e);
+        }
+    }
+
+    /**
+     * A utility function to close an output stream without raising an exception.
+     *
+     * @param os output stream to close safely
+     */
+    public static void silentCloseOutputStream(OutputStream os) {
+        try {
+            if (os != null) {
+                os.close();
+            }
+        } catch (IOException e) {
+            log.w(LOG_TAG, "Cannot close output stream", e);
+        }
+    }
+
     /**
      * Returns HttpEntity containing data from RequestParams included with request declaration.
      * Allows also passing progress from upload via provided ResponseHandler
@@ -956,11 +1531,12 @@ private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface
             if (params != null) {
                 entity = params.getEntity(responseHandler);
             }
-        } catch (Throwable t) {
-            if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, null, t);
-            else
-                t.printStackTrace();
+        } catch (IOException e) {
+            if (responseHandler != null) {
+                responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                e.printStackTrace();
+            }
         }
 
         return entity;
@@ -985,22 +1561,72 @@ private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosin
         return requestBase;
     }
 
+    /**
+     * This horrible hack is required on Android, due to implementation of BasicManagedEntity, which
+     * doesn't chain call consumeContent on underlying wrapped HttpEntity
+     *
+     * @param entity HttpEntity, may be null
+     */
+    public static void endEntityViaReflection(HttpEntity entity) {
+        if (entity instanceof HttpEntityWrapper) {
+            try {
+                Field f = null;
+                Field[] fields = HttpEntityWrapper.class.getDeclaredFields();
+                for (Field ff : fields) {
+                    if (ff.getName().equals("wrappedEntity")) {
+                        f = ff;
+                        break;
+                    }
+                }
+                if (f != null) {
+                    f.setAccessible(true);
+                    HttpEntity wrapped = (HttpEntity) f.get(entity);
+                    if (wrapped != null) {
+                        wrapped.consumeContent();
+                    }
+                }
+            } catch (Throwable t) {
+                log.e(LOG_TAG, "wrappedEntity consume", t);
+            }
+        }
+    }
+
     /**
      * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
      */
     private static class InflatingEntity extends HttpEntityWrapper {
+
         public InflatingEntity(HttpEntity wrapped) {
             super(wrapped);
         }
 
+        InputStream wrappedStream;
+        PushbackInputStream pushbackStream;
+        GZIPInputStream gzippedStream;
+
         @Override
         public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
+            wrappedStream = wrappedEntity.getContent();
+            pushbackStream = new PushbackInputStream(wrappedStream, 2);
+            if (isInputStreamGZIPCompressed(pushbackStream)) {
+                gzippedStream = new GZIPInputStream(pushbackStream);
+                return gzippedStream;
+            } else {
+                return pushbackStream;
+            }
         }
 
         @Override
         public long getContentLength() {
-            return -1;
+            return wrappedEntity == null ? 0 : wrappedEntity.getContentLength();
+        }
+
+        @Override
+        public void consumeContent() throws IOException {
+            AsyncHttpClient.silentCloseInputStream(wrappedStream);
+            AsyncHttpClient.silentCloseInputStream(pushbackStream);
+            AsyncHttpClient.silentCloseInputStream(gzippedStream);
+            super.consumeContent();
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
old mode 100644
new mode 100755
index d6c36f2a..f8a49d5c
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,8 +18,6 @@
 
 package com.loopj.android.http;
 
-import android.util.Log;
-
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
@@ -29,56 +27,144 @@
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-class AsyncHttpRequest implements Runnable {
+/**
+ * Internal class, representing the HttpRequest, done in asynchronous manner
+ */
+public class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
+    private final AtomicBoolean isCancelled = new AtomicBoolean();
+    private boolean cancelIsNotified;
+    private volatile boolean isFinished;
+    private boolean isRequestPreProcessed;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
+        this.client = Utils.notNull(client, "client");
+        this.context = Utils.notNull(context, "context");
+        this.request = Utils.notNull(request, "request");
+        this.responseHandler = Utils.notNull(responseHandler, "responseHandler");
+    }
+
+    /**
+     * This method is called once by the system when the request is about to be
+     * processed by the system. The library makes sure that a single request
+     * is pre-processed only once.
+     * <p>&nbsp;</p>
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to pre-process
+     */
+    public void onPreProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
+    }
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single request
+     * is post-processed only once.
+     * <p>&nbsp;</p>
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param request The request to post-process
+     */
+    public void onPostProcessRequest(AsyncHttpRequest request) {
+        // default action is to do nothing...
     }
 
     @Override
     public void run() {
-        if (responseHandler != null) {
-            responseHandler.sendStartMessage();
+        if (isCancelled()) {
+            return;
+        }
+
+        // Carry out pre-processing for this request only once.
+        if (!isRequestPreProcessed) {
+            isRequestPreProcessed = true;
+            onPreProcessRequest(this);
+        }
+
+        if (isCancelled()) {
+            return;
+        }
+
+        responseHandler.sendStartMessage();
+
+        if (isCancelled()) {
+            return;
         }
 
         try {
             makeRequestWithRetries();
         } catch (IOException e) {
-            if (responseHandler != null) {
+            if (!isCancelled()) {
                 responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                AsyncHttpClient.log.e("AsyncHttpRequest", "makeRequestWithRetries returned error", e);
             }
         }
 
-        if (responseHandler != null) {
-            responseHandler.sendFinishMessage();
+        if (isCancelled()) {
+            return;
         }
+
+        responseHandler.sendFinishMessage();
+
+        if (isCancelled()) {
+            return;
+        }
+
+        // Carry out post-processing for this request.
+        onPostProcessRequest(this);
+
+        isFinished = true;
     }
 
     private void makeRequest() throws IOException {
-        if (!Thread.currentThread().isInterrupted()) {
-            // Fixes #115
-            if (request.getURI().getScheme() == null) {
-                // subclass of IOException so processed in the caller
-                throw new MalformedURLException("No valid URI scheme was provided");
-            }
+        if (isCancelled()) {
+            return;
+        }
 
-            HttpResponse response = client.execute(request, context);
+        // Fixes #115
+        if (request.getURI().getScheme() == null) {
+            // subclass of IOException so processed in the caller
+            throw new MalformedURLException("No valid URI scheme was provided");
+        }
 
-            if (!Thread.currentThread().isInterrupted()) {
-                if (responseHandler != null) {
-                    responseHandler.sendResponseMessage(response);
-                }
-            }
+        if (responseHandler instanceof RangeFileAsyncHttpResponseHandler) {
+            ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request);
+        }
+
+        HttpResponse response = client.execute(request, context);
+
+        if (isCancelled()) {
+            return;
+        }
+
+        // Carry out pre-processing for this response.
+        responseHandler.onPreProcessResponse(responseHandler, response);
+
+        if (isCancelled()) {
+            return;
+        }
+
+        // The response is ready, handle it.
+        responseHandler.sendResponseMessage(response);
+
+        if (isCancelled()) {
+            return;
         }
+
+        // Carry out post-processing for this response.
+        responseHandler.onPostProcessResponse(responseHandler, response);
     }
 
     private void makeRequestWithRetries() throws IOException {
@@ -95,28 +181,77 @@ private void makeRequestWithRetries() throws IOException {
                     // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
                     // (to assist in genuine cases of unknown host) which seems better than outright failure
                     cause = new IOException("UnknownHostException exception: " + e.getMessage());
-                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
+                    retry = (executionCount > 0) && retryHandler.retryRequest(e, ++executionCount, context);
                 } catch (NullPointerException e) {
                     // there's a bug in HttpClient 4.0.x that on some occasions causes
                     // DefaultRequestExecutor to throw an NPE, see
-                    // http://code.google.com/p/android/issues/detail?id=5255
+                    // https://code.google.com/p/android/issues/detail?id=5255
                     cause = new IOException("NPE in HttpClient: " + e.getMessage());
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 } catch (IOException e) {
+                    if (isCancelled()) {
+                        // Eating exception, as the request was cancelled
+                        return;
+                    }
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                if (retry && (responseHandler != null)) {
-                    responseHandler.sendRetryMessage();
+                if (retry) {
+                    responseHandler.sendRetryMessage(executionCount);
                 }
             }
         } catch (Exception e) {
             // catch anything else to ensure failure message is propagated
-            Log.e("AsyncHttpRequest", "Unhandled exception origin cause", e);
+            AsyncHttpClient.log.e("AsyncHttpRequest", "Unhandled exception origin cause", e);
             cause = new IOException("Unhandled exception: " + e.getMessage());
         }
 
         // cleaned up to throw IOException
         throw (cause);
     }
+
+    public boolean isCancelled() {
+        boolean cancelled = isCancelled.get();
+        if (cancelled) {
+            sendCancelNotification();
+        }
+        return cancelled;
+    }
+
+    private synchronized void sendCancelNotification() {
+        if (!isFinished && isCancelled.get() && !cancelIsNotified) {
+            cancelIsNotified = true;
+            responseHandler.sendCancelMessage();
+        }
+    }
+
+    public boolean isDone() {
+        return isCancelled() || isFinished;
+    }
+
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        isCancelled.set(true);
+        request.abort();
+        return isCancelled();
+    }
+
+    /**
+     * Will set Object as TAG to this request, wrapped by WeakReference
+     *
+     * @param TAG Object used as TAG to this RequestHandle
+     * @return this AsyncHttpRequest to allow fluid syntax
+     */
+    public AsyncHttpRequest setRequestTag(Object TAG) {
+        this.responseHandler.setTag(TAG);
+        return this;
+    }
+
+    /**
+     * Will return TAG of this AsyncHttpRequest
+     *
+     * @return Object TAG, can be null, if it's been already garbage collected
+     */
+    public Object getTag() {
+        return this.responseHandler.getTag();
+    }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 3937e1cc..5aa3524f
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,6 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -32,7 +31,6 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.ref.WeakReference;
 import java.net.URI;
 
@@ -41,11 +39,11 @@
  * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
  * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
  * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
- * #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
+ * #onFinish()}, {@link #onRetry(int)} and {@link #onProgress(long, long)} methods as required.
  * <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ * client.get("https://www.google.com", new AsyncHttpResponseHandler() {
  *     &#064;Override
  *     public void onStart() {
  *         // Initiated the request
@@ -57,18 +55,19 @@
  *     }
  *
  *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error)
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
  * {
  *         // Response failed :(
  *     }
  *
  *     &#064;Override
- *     public void onRetry() {
+ *     public void onRetry(int retryNo) {
  *         // Request was retried
  *     }
  *
  *     &#064;Override
- *     public void onProgress(int bytesWritten, int totalSize) {
+ *     public void onProgress(long bytesWritten, long totalSize) {
  *         // Progress notification
  *     }
  *
@@ -79,8 +78,10 @@
  * });
  * </pre>
  */
-public class AsyncHttpResponseHandler implements ResponseHandlerInterface {
-    private static final String LOG_TAG = "AsyncHttpResponseHandler";
+@SuppressWarnings("ALL")
+public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+
+    private static final String LOG_TAG = "AsyncHttpRH";
 
     protected static final int SUCCESS_MESSAGE = 0;
     protected static final int FAILURE_MESSAGE = 1;
@@ -88,16 +89,75 @@
     protected static final int FINISH_MESSAGE = 3;
     protected static final int PROGRESS_MESSAGE = 4;
     protected static final int RETRY_MESSAGE = 5;
+    protected static final int CANCEL_MESSAGE = 6;
 
     protected static final int BUFFER_SIZE = 4096;
 
-    private Handler handler;
     public static final String DEFAULT_CHARSET = "UTF-8";
+    public static final String UTF8_BOM = "\uFEFF";
     private String responseCharset = DEFAULT_CHARSET;
-    private Boolean useSynchronousMode = false;
+    private Handler handler;
+    private boolean useSynchronousMode;
+    private boolean usePoolThread;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
+    private Looper looper = null;
+    private WeakReference<Object> TAG = new WeakReference<Object>(null);
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public AsyncHttpResponseHandler() {
+        this(null);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If
+     * the passed looper is null, the looper attached to the current thread will
+     * be used.
+     *
+     * @param looper The looper to work with
+     */
+    public AsyncHttpResponseHandler(Looper looper) {
+        this.looper = looper == null ? Looper.myLooper() : looper;
+
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
+
+        // Do not use the pool's thread to fire callbacks by default.
+        setUsePoolThread(false);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler and decide whether the callbacks
+     * will be fired on current thread's looper or the pool thread's.
+     *
+     * @param usePoolThread Whether to use the pool's thread to fire callbacks
+     */
+    public AsyncHttpResponseHandler(boolean usePoolThread) {
+        // Whether to use the pool's thread to fire callbacks.
+        setUsePoolThread(usePoolThread);
+
+        // When using the pool's thread, there's no sense in having a looper.
+        if (!getUsePoolThread()) {
+            // Use the current thread's looper.
+            this.looper = Looper.myLooper();
+
+            // Use asynchronous mode by default.
+            setUseSynchronousMode(false);
+        }
+    }
+
+    @Override
+    public void setTag(Object TAG) {
+        this.TAG = new WeakReference<Object>(TAG);
+    }
+
+    @Override
+    public Object getTag() {
+        return this.TAG.get();
+    }
 
     @Override
     public URI getRequestURI() {
@@ -119,38 +179,70 @@ public void setRequestHeaders(Header[] requestHeaders) {
         this.requestHeaders = requestHeaders;
     }
 
-    // avoid leaks by using a non-anonymous handler class
-    // with a weak reference
-    static class ResponderHandler extends Handler {
-        private final WeakReference<AsyncHttpResponseHandler> mResponder;
+    /**
+     * Avoid leaks by using a non-anonymous handler class.
+     */
+    private static class ResponderHandler extends Handler {
+        private final AsyncHttpResponseHandler mResponder;
 
-        ResponderHandler(AsyncHttpResponseHandler service) {
-            mResponder = new WeakReference<AsyncHttpResponseHandler>(service);
+        ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) {
+            super(looper);
+            this.mResponder = mResponder;
         }
 
         @Override
         public void handleMessage(Message msg) {
-            AsyncHttpResponseHandler service = mResponder.get();
-            if (service != null) {
-                service.handleMessage(msg);
-            }
+            mResponder.handleMessage(msg);
         }
     }
 
+    @Override
     public boolean getUseSynchronousMode() {
-        return (useSynchronousMode);
+        return useSynchronousMode;
+    }
+
+    @Override
+    public void setUseSynchronousMode(boolean sync) {
+        // A looper must be prepared before setting asynchronous mode.
+        if (!sync && looper == null) {
+            sync = true;
+            AsyncHttpClient.log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
+        }
+
+        // If using asynchronous mode.
+        if (!sync && handler == null) {
+            // Create a handler on current thread to submit tasks
+            handler = new ResponderHandler(this, looper);
+        } else if (sync && handler != null) {
+            // TODO: Consider adding a flag to remove all queued messages.
+            handler = null;
+        }
+
+        useSynchronousMode = sync;
+    }
+
+    @Override
+    public boolean getUsePoolThread() {
+        return usePoolThread;
     }
 
     @Override
-    public void setUseSynchronousMode(boolean value) {
-        useSynchronousMode = value;
+    public void setUsePoolThread(boolean pool) {
+        // If pool thread is to be used, there's no point in keeping a reference
+        // to the looper and no need for a handler.
+        if (pool) {
+            looper = null;
+            handler = null;
+        }
+
+        usePoolThread = pool;
     }
 
     /**
      * Sets the charset for the response string. If not set, the default is UTF-8.
      *
      * @param charset to be used for the response string.
-     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
      */
     public void setCharset(final String charset) {
         this.responseCharset = charset;
@@ -160,34 +252,21 @@ public String getCharset() {
         return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
     }
 
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if (Looper.myLooper() != null) {
-            handler = new ResponderHandler(this);
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
     /**
      * Fired when the request progress, override to handle in your own code
      *
      * @param bytesWritten offset from start of file
      * @param totalSize    total size of file
      */
-    public void onProgress(int bytesWritten, int totalSize) {
+    public void onProgress(long bytesWritten, long totalSize) {
+        AsyncHttpClient.log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
     }
 
     /**
      * Fired when the request is started, override to handle in your own code
      */
     public void onStart() {
+        // default log warning is not necessary, because this method is just optional notification
     }
 
     /**
@@ -195,41 +274,17 @@ public void onStart() {
      * handle in your own code
      */
     public void onFinish() {
+        // default log warning is not necessary, because this method is just optional notification
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param content the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(String content) {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, Header[] headers, String content) {
-        onSuccess(statusCode, content);
+    @Override
+    public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
+    @Override
+    public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+        // default action is to do nothing...
     }
 
     /**
@@ -239,67 +294,7 @@ public void onSuccess(int statusCode, String content) {
      * @param headers      return headers, if any
      * @param responseBody the body of the HTTP response from the server
      */
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
-        }
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error) {
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error   the underlying cause of the failure
-     * @param content the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Throwable error, String content) {
-        // By default, call the chain method onFailure(Throwable,String)
-        onFailure(error, content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param headers    return headers, if any
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // By default, call the chain method onFailure(int,Throwable,String)
-        onFailure(statusCode, error, content);
-    }
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] responseBody);
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
@@ -309,93 +304,115 @@ public void onFailure(int statusCode, Header[] headers, Throwable error, String
      * @param responseBody the response body, if any
      * @param error        the underlying cause of the failure
      */
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, error, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
-        }
-    }
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
 
     /**
      * Fired when a retry occurs, override to handle in your own code
+     *
+     * @param retryNo number of retry
      */
-    public void onRetry() {
+    public void onRetry(int retryNo) {
+        AsyncHttpClient.log.d(LOG_TAG, String.format("Request retry no. %d", retryNo));
     }
 
+    public void onCancel() {
+        AsyncHttpClient.log.d(LOG_TAG, "Request got cancelled");
+    }
 
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
+    public void onUserException(Throwable error) {
+        AsyncHttpClient.log.e(LOG_TAG, "User-space exception detected!", error);
+        throw new RuntimeException(error);
+    }
 
-    final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
+    @Override
+    final public void sendProgressMessage(long bytesWritten, long bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
-    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
+    @Override
+    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
     }
 
-    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
+    @Override
+    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
     }
 
+    @Override
     final public void sendStartMessage() {
         sendMessage(obtainMessage(START_MESSAGE, null));
     }
 
+    @Override
     final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-    final public void sendRetryMessage() {
-        sendMessage(obtainMessage(RETRY_MESSAGE, null));
+    @Override
+    final public void sendRetryMessage(int retryNo) {
+        sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
+    }
+
+    @Override
+    final public void sendCancelMessage() {
+        sendMessage(obtainMessage(CANCEL_MESSAGE, null));
     }
 
     // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
+    protected void handleMessage(Message message) {
         Object[] response;
 
-        switch (msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                if (response != null && response.length >= 3) {
-                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
-                } else {
-                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
-                if (response != null && response.length >= 4) {
-                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
-                } else {
-                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
-                }
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-            case PROGRESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                if (response != null && response.length >= 2) {
-                    try {
-                        onProgress((Integer) response[0], (Integer) response[1]);
-                    } catch (Throwable t) {
-                        Log.e(LOG_TAG, "custom onProgress contains an error", t);
+        try {
+            switch (message.what) {
+                case SUCCESS_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 3) {
+                        onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
+                    } else {
+                        AsyncHttpClient.log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
                     }
-                } else {
-                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case RETRY_MESSAGE:
-                onRetry();
-                break;
+                    break;
+                case FAILURE_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 4) {
+                        onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
+                    } else {
+                        AsyncHttpClient.log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
+                    }
+                    break;
+                case START_MESSAGE:
+                    onStart();
+                    break;
+                case FINISH_MESSAGE:
+                    onFinish();
+                    break;
+                case PROGRESS_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length >= 2) {
+                        try {
+                            onProgress((Long) response[0], (Long) response[1]);
+                        } catch (Throwable t) {
+                            AsyncHttpClient.log.e(LOG_TAG, "custom onProgress contains an error", t);
+                        }
+                    } else {
+                        AsyncHttpClient.log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                    }
+                    break;
+                case RETRY_MESSAGE:
+                    response = (Object[]) message.obj;
+                    if (response != null && response.length == 1) {
+                        onRetry((Integer) response[0]);
+                    } else {
+                        AsyncHttpClient.log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                    }
+                    break;
+                case CANCEL_MESSAGE:
+                    onCancel();
+                    break;
+            }
+        } catch (Throwable error) {
+            onUserException(error);
         }
     }
 
@@ -403,28 +420,37 @@ protected void sendMessage(Message msg) {
         if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
+            Utils.asserts(handler != null, "handler should not be null!");
             handler.sendMessage(msg);
         }
     }
 
-    protected void postRunnable(Runnable r) {
-        if (r != null) {
-            handler.post(r);
+    /**
+     * Helper method to send runnable into local handler loop
+     *
+     * @param runnable runnable instance, can be null
+     */
+    protected void postRunnable(Runnable runnable) {
+        if (runnable != null) {
+            if (getUseSynchronousMode() || handler == null) {
+                // This response handler is synchronous, run on current thread
+                runnable.run();
+            } else {
+                // Otherwise, run on provided handler
+                handler.post(runnable);
+            }
         }
     }
 
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg;
-        if (handler != null) {
-            msg = handler.obtainMessage(responseMessage, response);
-        } else {
-            msg = Message.obtain();
-            if (msg != null) {
-                msg.what = responseMessage;
-                msg.obj = response;
-            }
-        }
-        return msg;
+    /**
+     * Helper method to create Message instance from handler
+     *
+     * @param responseMessageId   constant to identify Handler message
+     * @param responseMessageData object to be passed to message receiver
+     * @return Message instance, should not be null
+     */
+    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
+        return Message.obtain(handler, responseMessageId, responseMessageData);
     }
 
     @Override
@@ -445,6 +471,13 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
         }
     }
 
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
     byte[] getResponseData(HttpEntity entity) throws IOException {
         byte[] responseBody = null;
         if (entity != null) {
@@ -454,22 +487,22 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                if (contentLength < 0) {
-                    contentLength = BUFFER_SIZE;
-                }
+                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
                     try {
                         byte[] tmp = new byte[BUFFER_SIZE];
-                        int l, count = 0;
+                        long count = 0;
+                        int l;
                         // do not send messages if request has been cancelled
                         while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
                             count += l;
                             buffer.append(tmp, 0, l);
-                            sendProgressMessage(count, (int) contentLength);
+                            sendProgressMessage(count, (contentLength <= 0 ? 1 : contentLength));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
+                        AsyncHttpClient.endEntityViaReflection(entity);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
new file mode 100755
index 00000000..d994700f
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -0,0 +1,718 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
+ * href="https://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="https://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
+     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
+     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
+     * /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
+     * stream it is wrapping when it itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is provided by the caller, and
+         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for this object.  Will finalize
+         *               the coder state and include any final bytes in the output.
+         * @return true if the input so far is good; false if some error has been detected in the
+         * input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process() could produce for the given
+         * number of input bytes.  This may be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
+     *
+     * @param str   the input String to decode, which is converted to bytes using the default
+     *              charset
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *               standard Base64.
+     * @return decoded bytes for given offset and length
+     * @throws IllegalArgumentException if the input contains incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
+         * and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Non-data values in the DECODE arrays.
+         */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
+         * expecting exactly one more. State 5 is expecting no more data or padding characters in
+         * the input. State 6 is the error state; an error has been detected in the input and no
+         * future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3 / 4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if bad base-64 data has been
+         * detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p + 4 <= len &&
+                            (value = ((alphabet[input[p] & 0xff] << 18) |
+                                    (alphabet[input[p + 1] & 0xff] << 12) |
+                                    (alphabet[input[p + 2] & 0xff] << 6) |
+                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                        output[op + 2] = (byte) value;
+                        output[op + 1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                    case 0:
+                        if (d >= 0) {
+                            value = d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 1:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 2:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect exactly one more padding character.
+                            output[op++] = (byte) (value >> 4);
+                            state = 4;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 3:
+                        if (d >= 0) {
+                            // Emit the output triple and return to state 0.
+                            value = (value << 6) | d;
+                            output[op + 2] = (byte) value;
+                            output[op + 1] = (byte) (value >> 8);
+                            output[op] = (byte) (value >> 16);
+                            op += 3;
+                            state = 0;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect no further data or padding characters.
+                            output[op + 1] = (byte) (value >> 2);
+                            output[op] = (byte) (value >> 10);
+                            op += 2;
+                            state = 5;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 4:
+                        if (d == EQUALS) {
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 5:
+                        if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+                case 0:
+                    // Output length is a multiple of three.  Fine.
+                    break;
+                case 1:
+                    // Read one extra input byte, which isn't enough to
+                    // make another output byte.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 2:
+                    // Read two extra input bytes, enough to emit 1 more
+                    // output byte.  Fine.
+                    output[op++] = (byte) (value >> 4);
+                    break;
+                case 3:
+                    // Read three extra input bytes, enough to emit 2 more
+                    // output bytes.  Fine.
+                    output[op++] = (byte) (value >> 10);
+                    output[op++] = (byte) (value >> 2);
+                    break;
+                case 4:
+                    // Read one padding '=' when we expected 2.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 5:
+                    // Read all the padding '='s we expected and no more.
+                    // Fine.
+                    break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated String with the result.
+     *
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     * @return base64 string containing encoded input
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     * @return base64 string containing encoded range of input
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
+     *
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0:
+                    break;
+                case 1:
+                    output_len += 2;
+                    break;
+                case 2:
+                    output_len += 3;
+                    break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                    (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        if (BuildConfig.DEBUG && encoder.op != output_len) {
+            throw new AssertionError();
+        }
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
+         * (the maximum allowable according to <a href="https://www.ietf.org/rfc/rfc2045.txt">RFC
+         * 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
+         */
+        private static final byte ENCODE[] = {
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8 / 5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p + 2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                                ((input[p++] & 0xff) << 8) |
+                                (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+
+                case 2:
+                    if (p + 1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                                ((tail[1] & 0xff) << 8) |
+                                (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p + 3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                        ((input[p + 1] & 0xff) << 8) |
+                        (input[p + 2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op + 1] = alphabet[(v >> 12) & 0x3f];
+                output[op + 2] = alphabet[(v >> 6) & 0x3f];
+                output[op + 3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p - tailLen == len - 1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p - tailLen == len - 2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
+                    throw new AssertionError();
+                }
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len - 1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len - 2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p + 1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() {
+    }   // don't instantiate
+}
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
new file mode 100755
index 00000000..50127c1f
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+public class Base64DataException extends IOException {
+    public Base64DataException(String detailMessage) {
+        super(detailMessage);
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
new file mode 100755
index 00000000..af72f373
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class Base64OutputStream extends FilterOutputStream {
+    private final Base64.Coder coder;
+    private final int flags;
+
+    private byte[] buffer = null;
+    private int bpos = 0;
+
+    private static final byte[] EMPTY = new byte[0];
+
+    /**
+     * Performs Base64 encoding on the data written to the stream, writing the encoded data to
+     * another OutputStream.
+     *
+     * @param out   the OutputStream to write the encoded data to
+     * @param flags bit flags for controlling the encoder; see the constants in {@link Base64}
+     */
+    public Base64OutputStream(OutputStream out, int flags) {
+        this(out, flags, true);
+    }
+
+    /**
+     * Performs Base64 encoding or decoding on the data written to the stream, writing the
+     * encoded/decoded data to another OutputStream.
+     *
+     * @param out    the OutputStream to write the encoded data to
+     * @param flags  bit flags for controlling the encoder; see the constants in {@link Base64}
+     * @param encode true to encode, false to decode
+     */
+    public Base64OutputStream(OutputStream out, int flags, boolean encode) {
+        super(out);
+        this.flags = flags;
+        if (encode) {
+            coder = new Base64.Encoder(flags, null);
+        } else {
+            coder = new Base64.Decoder(flags, null);
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        // To avoid invoking the encoder/decoder routines for single
+        // bytes, we buffer up calls to write(int) in an internal
+        // byte array to transform them into writes of decently-sized
+        // arrays.
+
+        if (buffer == null) {
+            buffer = new byte[1024];
+        }
+        if (bpos >= buffer.length) {
+            // internal buffer full; write it out.
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+        buffer[bpos++] = (byte) b;
+    }
+
+    /**
+     * Flush any buffered data from calls to write(int).  Needed before doing a write(byte[], int,
+     * int) or a close().
+     */
+    private void flushBuffer() throws IOException {
+        if (bpos > 0) {
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        if (len <= 0) return;
+        flushBuffer();
+        internalWrite(b, off, len, false);
+    }
+
+    @Override
+    public void close() throws IOException {
+        IOException thrown = null;
+        try {
+            flushBuffer();
+            internalWrite(EMPTY, 0, 0, true);
+        } catch (IOException e) {
+            thrown = e;
+        }
+
+        try {
+            if ((flags & Base64.NO_CLOSE) == 0) {
+                out.close();
+            } else {
+                out.flush();
+            }
+        } catch (IOException e) {
+            if (thrown != null) {
+                thrown = e;
+            }
+        }
+
+        if (thrown != null) {
+            throw thrown;
+        }
+    }
+
+    /**
+     * Write the given bytes to the encoder/decoder.
+     *
+     * @param finish true if this is the last batch of input, to cause encoder/decoder state to be
+     *               finalized.
+     */
+    private void internalWrite(byte[] b, int off, int len, boolean finish) throws IOException {
+        coder.output = embiggen(coder.output, coder.maxOutputSize(len));
+        if (!coder.process(b, off, len, finish)) {
+            throw new Base64DataException("bad base-64");
+        }
+        out.write(coder.output, 0, coder.op);
+    }
+
+    /**
+     * If b.length is at least len, return b.  Otherwise return a new byte array of length len.
+     */
+    private byte[] embiggen(byte[] b, int len) {
+        if (b == null || b.length < len) {
+            return new byte[len];
+        } else {
+            return b;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
old mode 100644
new mode 100755
index c9a89091..02d7ec9b
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,143 +18,138 @@
 
 package com.loopj.android.http;
 
-import android.util.Log;
-
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
 
+/**
+ * Class meant to be used with custom JSON parser (such as GSON or Jackson JSON) <p>&nbsp;</p>
+ * {@link #parseResponse(String, boolean)} should be overriden and must return type of generic param
+ * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
+ * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
+ * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ *
+ * @param <JSON_TYPE> Generic type meant to be returned in callback
+ */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
-    private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
+    private static final String LOG_TAG = "BaseJsonHttpRH";
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates a new JsonHttpResponseHandler with default charset "UTF-8"
      */
-
     public BaseJsonHttpResponseHandler() {
-        super(DEFAULT_CHARSET);
+        this(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates a new JsonHttpResponseHandler with given string encoding
+     *
+     * @param encoding result string encoding, see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
     public BaseJsonHttpResponseHandler(String encoding) {
         super(encoding);
     }
 
-    @Override
-    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        // Disabling this method
-        super.onSuccess(statusCode, headers, responseBody);
-    }
-
-    @Override
-    public final void onSuccess(String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(content);
-    }
-
-    @Override
-    public final void onSuccess(int statusCode, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(statusCode, content);
-    }
-
-    @Override
-    public final void onFailure(String responseBody, Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        //Disabling this method
-        super.onFailure(statusCode, headers, responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, headers, error, content);
-    }
-
-    public abstract void onSuccess(int statusCode, Header[] headers, String rawResponse, JSON_TYPE response);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode      HTTP status line
+     * @param headers         response headers
+     * @param rawJsonResponse string of response, can be null
+     * @param response        response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, JSON_TYPE response);
 
-    public abstract void onFailure(int statusCode, Header[] headers, Throwable e, String rawData, JSON_TYPE errorResponse);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode    HTTP status line
+     * @param headers       response headers
+     * @param throwable     error thrown while processing request
+     * @param rawJsonData   raw string data returned if any
+     * @param errorResponse response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, JSON_TYPE errorResponse);
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, false);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onSuccess(statusCode, headers, responseBody, jsonResponse);
+                                onSuccess(statusCode, headers, responseString, jsonResponse);
                             }
                         });
                     } catch (final Throwable t) {
-                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        AsyncHttpClient.log.d(LOG_TAG, "parseResponse thrown an problem", t);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, t, responseBody, null);
+                                onFailure(statusCode, headers, t, responseString, null);
                             }
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, null, null);
         }
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
-            new Thread(new Runnable() {
+    public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
+        if (responseString != null) {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, true);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, jsonResponse);
+                                onFailure(statusCode, headers, throwable, responseString, jsonResponse);
                             }
                         });
                     } catch (Throwable t) {
-                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
+                        AsyncHttpClient.log.d(LOG_TAG, "parseResponse thrown an problem", t);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, null);
+                                onFailure(statusCode, headers, throwable, responseString, null);
                             }
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
-            onFailure(statusCode, headers, e, null, null);
+            onFailure(statusCode, headers, throwable, null, null);
         }
     }
 
-    protected abstract JSON_TYPE parseResponse(String responseBody) throws Throwable;
+    /**
+     * Should return deserialized instance of generic type, may return object for more vague
+     * handling
+     *
+     * @param rawJsonData response string, may be null
+     * @param isFailure   indicating if this method is called from onFailure or not
+     * @return object of generic type or possibly null if you choose so
+     * @throws Throwable allows you to throw anything from within deserializing JSON response
+     */
+    protected abstract JSON_TYPE parseResponse(String rawJsonData, boolean isFailure) throws Throwable;
 }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
old mode 100644
new mode 100755
index 58055ac3..a891af56
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,7 +18,7 @@
 
 package com.loopj.android.http;
 
-import android.util.Log;
+import android.os.Looper;
 
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
@@ -36,7 +36,7 @@
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * String[] allowedTypes = new String[] { "image/png" };
- * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
+ * client.get("https://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
  *     &#064;Override
  *     public void onSuccess(byte[] imageData) {
  *         // Successfully got a response
@@ -49,11 +49,15 @@
  * });
  * </pre>
  */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+public abstract class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private static final String LOG_TAG = "BinaryHttpRH";
 
     private String[] mAllowedContentTypes = new String[]{
+            RequestParams.APPLICATION_OCTET_STREAM,
             "image/jpeg",
-            "image/png"
+            "image/png",
+            "image/gif"
     };
 
     /**
@@ -80,72 +84,51 @@ public BinaryHttpResponseHandler() {
      * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {
+        super();
+        if (allowedContentTypes != null) {
+            mAllowedContentTypes = allowedContentTypes;
+        } else {
+            AsyncHttpClient.log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
+        }
     }
-
+    
     /**
-     * Fired when a request returns successfully, override to handle in your own code
+     * Creates a new BinaryHttpResponseHandler with a user-supplied looper, and overrides the default allowed content types with
+     * passed String array (hopefully) of content types.
      *
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
+     * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
+     * @param looper The looper to work with
      */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
+    public BinaryHttpResponseHandler(String[] allowedContentTypes, Looper looper) {
+        super(looper);
+        if (allowedContentTypes != null) {
+            mAllowedContentTypes = allowedContentTypes;
+        } else {
+            AsyncHttpClient.log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
+        }
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     */
-
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-        onSuccess(statusCode, binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     * @param error      the underlying cause of the failure
-     */
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] binaryData);
 
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error) {
-        onFailure(statusCode, error, null);
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error);
 
-    // Interface to AsyncHttpRequest
     @Override
     public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        Header[] contentTypeHeaders = response.getHeaders(AsyncHttpClient.HEADER_CONTENT_TYPE);
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
+            sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
+                    status.getStatusCode(),
+                    "None, or more than one, Content-Type Header found!"
+                )
+            );
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -156,12 +139,20 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
                     foundAllowedContentType = true;
                 }
             } catch (PatternSyntaxException e) {
-                Log.e("BinaryHttpResponseHandler", "Given pattern is not valid: " + anAllowedContentType, e);
+                AsyncHttpClient.log.e(LOG_TAG, "Given pattern is not valid: " + anAllowedContentType, e);
             }
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
+            sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
+                    status.getStatusCode(),
+                    "Content-Type (" + contentTypeHeader.getValue() + ") not allowed!"
+                )
+            );
             return;
         }
         super.sendResponseMessage(response);
diff --git a/library/src/main/java/com/loopj/android/http/BlackholeHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BlackholeHttpResponseHandler.java
new file mode 100644
index 00000000..8ff6bcdd
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/BlackholeHttpResponseHandler.java
@@ -0,0 +1,64 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+
+/**
+ * Blank implementation of ResponseHandlerInterface, which ignores all contents returned by
+ * remote HTTP endpoint, and discards all various log messages
+ * <p>&nbsp;</p>
+ * Use this implementation, if you deliberately want to ignore all response, because you cannot
+ * pass null ResponseHandlerInterface into AsyncHttpClient implementation
+ */
+public class BlackholeHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+
+    }
+
+    @Override
+    public void onProgress(long bytesWritten, long totalSize) {
+
+    }
+
+    @Override
+    public void onCancel() {
+
+    }
+
+    @Override
+    public void onFinish() {
+
+    }
+
+    @Override
+    public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+
+    }
+
+    @Override
+    public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+
+    }
+
+    @Override
+    public void onRetry(int retryNo) {
+
+    }
+
+    @Override
+    public void onStart() {
+
+    }
+
+    @Override
+    public void onUserException(Throwable error) {
+
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..1d3ade69
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -0,0 +1,153 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.os.Message;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.util.ByteArrayBuffer;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@SuppressWarnings("ALL")
+public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "DataAsyncHttpRH";
+
+    protected static final int PROGRESS_DATA_MESSAGE = 7;
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public DataAsyncHttpResponseHandler() {
+        super();
+    }
+
+    /**
+     * Fired when the request progress, override to handle in your own code
+     *
+     * @param responseBody response body received so far
+     */
+    public void onProgressData(byte[] responseBody) {
+        AsyncHttpClient.log.d(LOG_TAG, "onProgressData(byte[]) was not overriden, but callback was received");
+    }
+
+
+    final public void sendProgressDataMessage(byte[] responseBytes) {
+        sendMessage(obtainMessage(PROGRESS_DATA_MESSAGE, new Object[]{responseBytes}));
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    @Override
+    protected void handleMessage(Message message) {
+        super.handleMessage(message);
+        Object[] response;
+
+        switch (message.what) {
+            case PROGRESS_DATA_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 1) {
+                    try {
+                        onProgressData((byte[]) response[0]);
+                    } catch (Throwable t) {
+                        AsyncHttpClient.log.e(LOG_TAG, "custom onProgressData contains an error", t);
+                    }
+                } else {
+                    AsyncHttpClient.log.e(LOG_TAG, "PROGRESS_DATA_MESSAGE didn't got enough params");
+                }
+                break;
+        }
+    }
+
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
+    @Override
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l, count = 0;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            buffer.append(tmp, 0, l);
+                            sendProgressDataMessage(copyOfRange(tmp, 0, l));
+                            sendProgressMessage(count, contentLength);
+                        }
+                    } finally {
+                        AsyncHttpClient.silentCloseInputStream(instream);
+                    }
+                    responseBody = buffer.toByteArray();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
+        }
+        return responseBody;
+    }
+
+    /**
+     * Copies elements from {@code original} into a new array, from indexes start (inclusive) to end
+     * (exclusive). The original order of elements is preserved. If {@code end} is greater than
+     * {@code original.length}, the result is padded with the value {@code (byte) 0}.
+     *
+     * @param original the original array
+     * @param start    the start index, inclusive
+     * @param end      the end index, exclusive
+     * @return the new array
+     * @throws ArrayIndexOutOfBoundsException if {@code start < 0 || start > original.length}
+     * @throws IllegalArgumentException       if {@code start > end}
+     * @throws NullPointerException           if {@code original == null}
+     * @see java.util.Arrays
+     * @since 1.6
+     */
+    public static byte[] copyOfRange(byte[] original, int start, int end) throws ArrayIndexOutOfBoundsException, IllegalArgumentException, NullPointerException {
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        int originalLength = original.length;
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        int resultLength = end - start;
+        int copyLength = Math.min(resultLength, originalLength - start);
+        byte[] result = new byte[resultLength];
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+}
+
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 51177c93..0fc1bec4
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,7 +1,24 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.content.Context;
-import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,80 +28,183 @@
 import java.io.IOException;
 import java.io.InputStream;
 
+public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
-public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
-
-    private File mFile;
-    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
+    protected final File file;
+    protected final boolean append;
+    protected final boolean renameIfExists;
+    protected File frontendFile;
+    private static final String LOG_TAG = "FileAsyncHttpRH";
 
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
     public FileAsyncHttpResponseHandler(File file) {
-        super();
-        assert (file != null);
-        this.mFile = file;
+        this(file, false);
     }
 
-    public FileAsyncHttpResponseHandler(Context c) {
-        super();
-        assert (c != null);
-        this.mFile = getTemporaryFile(c);
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file   File to store response within, must not be null
+     * @param append whether data should be appended to existing file
+     */
+    public FileAsyncHttpResponseHandler(File file, boolean append) {
+        this(file, append, false);
     }
 
-    protected File getTemporaryFile(Context c) {
-        try {
-            return File.createTempFile("temp_", "_handled", c.getCacheDir());
-        } catch (Throwable t) {
-            Log.e(LOG_TAG, "Cannot create temporary file", t);
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file                     File to store response within, must not be null
+     * @param append                   whether data should be appended to existing file
+     * @param renameTargetFileIfExists whether target file should be renamed if it already exists
+     */
+    public FileAsyncHttpResponseHandler(File file, boolean append, boolean renameTargetFileIfExists) {
+        super();
+        Utils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
+        if (!file.isDirectory() && !file.getParentFile().isDirectory()) {
+            Utils.asserts(file.getParentFile().mkdirs(), "Cannot create parent directories for requested File location");
         }
-        return null;
-    }
-
-    protected File getTargetFile() {
-        assert (mFile != null);
-        return mFile;
+        if (file.isDirectory()) {
+            if (!file.mkdirs()) {
+                AsyncHttpClient.log.d(LOG_TAG, "Cannot create directories for requested Directory location, might not be a problem");
+            }
+        }
+        this.file = file;
+        this.append = append;
+        this.renameIfExists = renameTargetFileIfExists;
     }
 
-    public void onSuccess(File file) {
+    /**
+     * Obtains new FileAsyncHttpResponseHandler against context with target being temporary file
+     *
+     * @param context Context, must not be null
+     */
+    public FileAsyncHttpResponseHandler(Context context) {
+        super();
+        this.file = getTemporaryFile(context);
+        this.append = false;
+        this.renameIfExists = false;
     }
 
-    public void onSuccess(int statusCode, File file) {
-        onSuccess(file);
+    /**
+     * Attempts to delete file with stored response
+     *
+     * @return false if the file does not exist or is null, true if it was successfully deleted
+     */
+    public boolean deleteTargetFile() {
+        return getTargetFile() != null && getTargetFile().delete();
     }
 
-    public void onSuccess(int statusCode, Header[] headers, File file) {
-        onSuccess(statusCode, file);
+    /**
+     * Used when there is no file to be used when calling constructor
+     *
+     * @param context Context, must not be null
+     * @return temporary file or null if creating file failed
+     */
+    protected File getTemporaryFile(Context context) {
+        Utils.asserts(context != null, "Tried creating temporary file without having Context");
+        try {
+            return File.createTempFile("temp_", "_handled", context.getCacheDir());
+        } catch (IOException e) {
+            AsyncHttpClient.log.e(LOG_TAG, "Cannot create temporary file", e);
+        }
+        return null;
     }
 
-    public void onFailure(Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e);
+    /**
+     * Retrieves File object in which the response is stored
+     *
+     * @return File file in which the response was to be stored
+     */
+    protected File getOriginalFile() {
+        Utils.asserts(file != null, "Target file is null, fatal!");
+        return file;
     }
 
-    public void onFailure(int statusCode, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e, response);
+    /**
+     * Retrieves File which represents response final location after possible renaming
+     *
+     * @return File final target file
+     */
+    public File getTargetFile() {
+        if (frontendFile == null) {
+            frontendFile = getOriginalFile().isDirectory() ? getTargetFileByParsingURL() : getOriginalFile();
+        }
+        return frontendFile;
     }
 
-    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(statusCode, e, response);
+    /**
+     * Will return File instance for file representing last URL segment in given folder.
+     * If file already exists and renameTargetFileIfExists was set as true, will try to find file
+     * which doesn't exist, naming template for such cases is "filename.ext" =&gt; "filename (%d).ext",
+     * or without extension "filename" =&gt; "filename (%d)"
+     *
+     * @return File in given directory constructed by last segment of request URL
+     */
+    protected File getTargetFileByParsingURL() {
+        Utils.asserts(getOriginalFile().isDirectory(), "Target file is not a directory, cannot proceed");
+        Utils.asserts(getRequestURI() != null, "RequestURI is null, cannot proceed");
+        String requestURL = getRequestURI().toString();
+        String filename = requestURL.substring(requestURL.lastIndexOf('/') + 1, requestURL.length());
+        File targetFileRtn = new File(getOriginalFile(), filename);
+        if (targetFileRtn.exists() && renameIfExists) {
+            String format;
+            if (!filename.contains(".")) {
+                format = filename + " (%d)";
+            } else {
+                format = filename.substring(0, filename.lastIndexOf('.')) + " (%d)" + filename.substring(filename.lastIndexOf('.'), filename.length());
+            }
+            int index = 0;
+            while (true) {
+                targetFileRtn = new File(getOriginalFile(), String.format(format, index));
+                if (!targetFileRtn.exists())
+                    return targetFileRtn;
+                index++;
+            }
+        }
+        return targetFileRtn;
     }
 
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        onFailure(statusCode, headers, error, getTargetFile());
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, throwable, getTargetFile());
     }
 
+    /**
+     * Method to be overriden, receives as much of file as possible Called when the file is
+     * considered failure or if there is error when retrieving file
+     *
+     * @param statusCode http file status line
+     * @param headers    file http headers if any
+     * @param throwable  returned throwable
+     * @param file       file in which the file is stored
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, File file);
+
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
         onSuccess(statusCode, headers, getTargetFile());
     }
 
+    /**
+     * Method to be overriden, receives as much of response as possible
+     *
+     * @param statusCode http response status line
+     * @param headers    response http headers if any
+     * @param file       file in which the response is stored
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, File file);
+
     @Override
-    byte[] getResponseData(HttpEntity entity) throws IOException {
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
         if (entity != null) {
             InputStream instream = entity.getContent();
             long contentLength = entity.getContentLength();
-            FileOutputStream buffer = new FileOutputStream(getTargetFile());
+            FileOutputStream buffer = new FileOutputStream(getTargetFile(), this.append);
             if (instream != null) {
                 try {
                     byte[] tmp = new byte[BUFFER_SIZE];
@@ -93,12 +213,12 @@ public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
                     while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
                         count += l;
                         buffer.write(tmp, 0, l);
-                        sendProgressMessage(count, (int) contentLength);
+                        sendProgressMessage(count, contentLength);
                     }
                 } finally {
-                    instream.close();
+                    AsyncHttpClient.silentCloseInputStream(instream);
                     buffer.flush();
-                    buffer.close();
+                    AsyncHttpClient.silentCloseOutputStream(buffer);
                 }
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/HttpDelete.java b/library/src/main/java/com/loopj/android/http/HttpDelete.java
new file mode 100644
index 00000000..103a997b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpDelete.java
@@ -0,0 +1,59 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP DELETE method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpDelete extends HttpEntityEnclosingRequestBase {
+    public final static String METHOD_NAME = "DELETE";
+
+    public HttpDelete() {
+        super();
+    }
+
+    /**
+     * @param uri target url as URI
+     */
+    public HttpDelete(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @param uri target url as String
+     * @throws IllegalArgumentException if the uri is invalid.
+     */
+    public HttpDelete(final String uri) {
+        super();
+        setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/HttpGet.java b/library/src/main/java/com/loopj/android/http/HttpGet.java
new file mode 100644
index 00000000..b5582737
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpGet.java
@@ -0,0 +1,60 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP GET method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpGet extends HttpEntityEnclosingRequestBase {
+
+    public final static String METHOD_NAME = "GET";
+
+    public HttpGet() {
+        super();
+    }
+
+    /**
+     * @param uri target url as URI
+     */
+    public HttpGet(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @param uri target url as String
+     * @throws IllegalArgumentException if the uri is invalid.
+     */
+    public HttpGet(final String uri) {
+        super();
+        setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/HttpPatch.java b/library/src/main/java/com/loopj/android/http/HttpPatch.java
new file mode 100644
index 00000000..82e0c871
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpPatch.java
@@ -0,0 +1,59 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * the HTTP PATCH method. Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpPatch extends HttpEntityEnclosingRequestBase {
+
+    public final static String METHOD_NAME = "PATCH";
+
+    public HttpPatch() {
+        super();
+    }
+
+    /**
+     * @param uri target url as URI
+     */
+    public HttpPatch(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @param uri target url as String
+     * @throws IllegalArgumentException if the uri is invalid.
+     */
+    public HttpPatch(final String uri) {
+        super();
+        setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
old mode 100644
new mode 100755
index 6778596c..5fa92691
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,8 +18,6 @@
 
 package com.loopj.android.http;
 
-import android.util.Log;
-
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
 import org.json.JSONArray;
@@ -30,175 +28,184 @@
 /**
  * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
  * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
- * designed to be passed to get, post, put and delete requests with the {@link
- * #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)} methods anonymously overridden.
- * <p>&nbsp;</p> Additionally, you can override the other event methods from the parent class.
+ * designed to be passed to get, post, put and delete requests with the {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONArray)} or {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONObject)} methods anonymously overridden. <p>&nbsp;</p>
+ * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends TextHttpResponseHandler {
-    private static final String LOG_TAG = "JsonHttpResponseHandler";
+
+    private static final String LOG_TAG = "JsonHttpRH";
+
+
+    private boolean useRFC5179CompatibilityMode = true;
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates new JsonHttpResponseHandler, with JSON String encoding UTF-8
      */
-
     public JsonHttpResponseHandler() {
         super(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates new JsonHttpResponseHandler with given JSON String encoding
+     *
+     * @param encoding String encoding to be used when parsing JSON
+     */
     public JsonHttpResponseHandler(String encoding) {
         super(encoding);
     }
 
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Creates new JsonHttpResponseHandler with JSON String encoding UTF-8 and given RFC5179CompatibilityMode
      *
-     * @param response the parsed json object found in the server response (if any)
+     * @param useRFC5179CompatibilityMode Boolean mode to use RFC5179 or latest
      */
-    public void onSuccess(JSONObject response) {
+    public JsonHttpResponseHandler(boolean useRFC5179CompatibilityMode) {
+        super(DEFAULT_CHARSET);
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
     }
 
-
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Creates new JsonHttpResponseHandler with given JSON String encoding and RFC5179CompatibilityMode
      *
-     * @param response the parsed json array found in the server response (if any)
+     * @param encoding                    String encoding to be used when parsing JSON
+     * @param useRFC5179CompatibilityMode Boolean mode to use RFC5179 or latest
      */
-    public void onSuccess(JSONArray response) {
+    public JsonHttpResponseHandler(String encoding, boolean useRFC5179CompatibilityMode) {
+        super(encoding);
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-        onSuccess(statusCode, response);
+        AsyncHttpClient.log.w(LOG_TAG, "onSuccess(int, Header[], JSONObject) was not overriden, but callback was received");
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
+    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
+        AsyncHttpClient.log.w(LOG_TAG, "onSuccess(int, Header[], JSONArray) was not overriden, but callback was received");
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-        onSuccess(statusCode, response);
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
+        AsyncHttpClient.log.w(LOG_TAG, "onFailure(int, Header[], Throwable, JSONObject) was not overriden, but callback was received", throwable);
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, JSONArray response) {
-        onSuccess(response);
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
+        AsyncHttpClient.log.w(LOG_TAG, "onFailure(int, Header[], Throwable, JSONArray) was not overriden, but callback was received", throwable);
     }
 
-    public void onFailure(Throwable e, JSONObject errorResponse) {
-        onFailure(e);
-    }
-
-    public void onFailure(int statusCode, Throwable e, JSONObject errorResponse) {
-        onFailure(e, errorResponse);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONObject errorResponse) {
-        onFailure(statusCode, e, errorResponse);
-    }
-
-    public void onFailure(Throwable e, JSONArray errorResponse) {
-        onFailure(e);
-    }
-
-    public void onFailure(int statusCode, Throwable e, JSONArray errorResponse) {
-        onFailure(e, errorResponse);
+    @Override
+    public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
+        AsyncHttpClient.log.w(LOG_TAG, "onFailure(int, Header[], String, Throwable) was not overriden, but callback was received", throwable);
     }
 
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray errorResponse) {
-        onFailure(statusCode, e, errorResponse);
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseString) {
+        AsyncHttpClient.log.w(LOG_TAG, "onSuccess(int, Header[], String) was not overriden, but callback was received");
     }
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                if (jsonResponse instanceof JSONObject) {
+                                // In RFC5179 a null value is not a valid JSON
+                                if (!useRFC5179CompatibilityMode && jsonResponse == null) {
+                                    onSuccess(statusCode, headers, (String) null);
+                                } else if (jsonResponse instanceof JSONObject) {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
                                 } else if (jsonResponse instanceof String) {
-                                    onSuccess(statusCode, headers, (String) jsonResponse);
+                                    // In RFC5179 a simple string value is not a valid JSON
+                                    if (useRFC5179CompatibilityMode) {
+                                        onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
+                                    } else {
+                                        onSuccess(statusCode, headers, (String) jsonResponse);
+                                    }
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
-
                             }
                         });
                     } catch (final JSONException ex) {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(ex, (JSONObject) null);
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
                             }
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
-            new Thread(new Runnable() {
+    public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
+        if (responseBytes != null) {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                if (jsonResponse instanceof JSONObject) {
-                                    onFailure(statusCode, headers, e, (JSONObject) jsonResponse);
+                                // In RFC5179 a null value is not a valid JSON
+                                if (!useRFC5179CompatibilityMode && jsonResponse == null) {
+                                    onFailure(statusCode, headers, (String) null, throwable);
+                                } else if (jsonResponse instanceof JSONObject) {
+                                    onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
-                                    onFailure(statusCode, headers, e, (JSONArray) jsonResponse);
+                                    onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
                                 } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, e, (String) jsonResponse);
+                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
                             }
                         });
@@ -213,25 +220,65 @@ public void run() {
 
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
+                new Thread(parser).start();
+            } else {
+                // In synchronous mode everything should be run on one thread
+                parser.run();
+            }
         } else {
-            Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
-            onFailure(statusCode, headers, e, (JSONObject) null);
+            AsyncHttpClient.log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
+            onFailure(statusCode, headers, throwable, (JSONObject) null);
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
+    /**
+     * Returns Object of type {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
+     * Double or {@link JSONObject#NULL}, see {@link org.json.JSONTokener#nextValue()}
+     *
+     * @param responseBody response bytes to be assembled in String and parsed as JSON
+     * @return Object parsedResponse
+     * @throws org.json.JSONException exception if thrown while parsing JSON
+     */
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        String jsonString = responseBody.trim();
-        if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-            result = new JSONTokener(jsonString).nextValue();
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If JSON is not valid this will return null
+        String jsonString = getResponseString(responseBody, getCharset());
+        if (jsonString != null) {
+            jsonString = jsonString.trim();
+            if (useRFC5179CompatibilityMode) {
+                if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                    result = new JSONTokener(jsonString).nextValue();
+                }
+            } else {
+                // Check if the string is an JSONObject style {} or JSONArray style []
+                // If not we consider this as a string
+                if ((jsonString.startsWith("{") && jsonString.endsWith("}"))
+                        || jsonString.startsWith("[") && jsonString.endsWith("]")) {
+                    result = new JSONTokener(jsonString).nextValue();
+                }
+                // Check if this is a String "my String value" and remove quote
+                // Other value type (numerical, boolean) should be without quote
+                else if (jsonString.startsWith("\"") && jsonString.endsWith("\"")) {
+                    result = jsonString.substring(1, jsonString.length() - 1);
+                }
+            }
         }
         if (result == null) {
             result = jsonString;
         }
         return result;
     }
+
+    public boolean isUseRFC5179CompatibilityMode() {
+        return useRFC5179CompatibilityMode;
+    }
+
+    public void setUseRFC5179CompatibilityMode(boolean useRFC5179CompatibilityMode) {
+        this.useRFC5179CompatibilityMode = useRFC5179CompatibilityMode;
+    }
+
 }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
new file mode 100755
index 00000000..d191ab1e
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -0,0 +1,396 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.text.TextUtils;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * HTTP entity to upload JSON data using streams. This has very low memory footprint; suitable for
+ * uploading large files using base64 encoding.
+ */
+public class JsonStreamerEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "JsonStreamerEntity";
+
+    private static final UnsupportedOperationException ERR_UNSUPPORTED =
+            new UnsupportedOperationException("Unsupported operation in this implementation.");
+
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
+
+    private static final byte[] JSON_TRUE = "true".getBytes();
+    private static final byte[] JSON_FALSE = "false".getBytes();
+    private static final byte[] JSON_NULL = "null".getBytes();
+    private static final byte[] STREAM_NAME = escape("name");
+    private static final byte[] STREAM_TYPE = escape("type");
+    private static final byte[] STREAM_CONTENTS = escape("contents");
+
+    private static final Header HEADER_JSON_CONTENT =
+            new BasicHeader(
+                    AsyncHttpClient.HEADER_CONTENT_TYPE,
+                    RequestParams.APPLICATION_JSON);
+
+    private static final Header HEADER_GZIP_ENCODING =
+            new BasicHeader(
+                    AsyncHttpClient.HEADER_CONTENT_ENCODING,
+                    AsyncHttpClient.ENCODING_GZIP);
+
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap<String, Object>();
+
+    // Whether to use gzip compression while uploading
+    private final Header contentEncoding;
+
+    private final byte[] elapsedField;
+
+    private final ResponseHandlerInterface progressHandler;
+
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression, String elapsedField) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
+        this.elapsedField = TextUtils.isEmpty(elapsedField)
+                ? null
+                : escape(elapsedField);
+    }
+
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key   entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return contentEncoding;
+    }
+
+    @Override
+    public Header getContentType() {
+        return HEADER_JSON_CONTENT;
+    }
+
+    @Override
+    public void consumeContent() throws IOException, UnsupportedOperationException {
+    }
+
+    @Override
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw ERR_UNSUPPORTED;
+    }
+
+    @Override
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
+            throw new IllegalStateException("Output stream cannot be null.");
+        }
+
+        // Record the time when uploading started.
+        long now = System.currentTimeMillis();
+
+        // Use GZIP compression when sending streams, otherwise just use
+        // a buffered output stream to speed things up a bit.
+        OutputStream os = contentEncoding != null
+                ? new GZIPOutputStream(out, BUFFER_SIZE)
+                : out;
+
+        // Always send a JSON object.
+        os.write('{');
+
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        int keysCount = keys.size();
+        if (0 < keysCount) {
+            int keysProcessed = 0;
+            boolean isFileWrapper;
+
+            // Go over all keys and handle each's value.
+            for (String key : keys) {
+                // Indicate that this key has been processed.
+                keysProcessed++;
+
+                try {
+                    // Evaluate the value (which cannot be null).
+                    Object value = jsonParams.get(key);
+
+                    // Write the JSON object's key.
+                    os.write(escape(key));
+                    os.write(':');
+
+                    // Bail out prematurely if value's null.
+                    if (value == null) {
+                        os.write(JSON_NULL);
+                    } else {
+                        // Check if this is a FileWrapper.
+                        isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+                        // If a file should be uploaded.
+                        if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                            // All uploads are sent as an object containing the file's details.
+                            os.write('{');
+
+                            // Determine how to handle this entry.
+                            if (isFileWrapper) {
+                                writeToFromFile(os, (RequestParams.FileWrapper) value);
+                            } else {
+                                writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                            }
+
+                            // End the file's object and prepare for next one.
+                            os.write('}');
+                        } else if (value instanceof JsonValueInterface) {
+                            os.write(((JsonValueInterface) value).getEscapedJsonValue());
+                        } else if (value instanceof org.json.JSONObject) {
+                            os.write(value.toString().getBytes());
+                        } else if (value instanceof org.json.JSONArray) {
+                            os.write(value.toString().getBytes());
+                        } else if (value instanceof Boolean) {
+                            os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
+                        } else if (value instanceof Long) {
+                            os.write((((Number) value).longValue() + "").getBytes());
+                        } else if (value instanceof Double) {
+                            os.write((((Number) value).doubleValue() + "").getBytes());
+                        } else if (value instanceof Float) {
+                            os.write((((Number) value).floatValue() + "").getBytes());
+                        } else if (value instanceof Integer) {
+                            os.write((((Number) value).intValue() + "").getBytes());
+                        } else {
+                            os.write(escape(value.toString()));
+                        }
+                    }
+                } finally {
+                    // Separate each K:V with a comma, except the last one.
+                    if (elapsedField != null || keysProcessed < keysCount) {
+                        os.write(',');
+                    }
+                }
+            }
+
+            // Calculate how many milliseconds it took to upload the contents.
+            long elapsedTime = System.currentTimeMillis() - now;
+
+            // Include the elapsed time taken to upload everything.
+            // This might be useful for somebody, but it serves us well since
+            // there will almost always be a ',' as the last sent character.
+            if (elapsedField != null) {
+                os.write(elapsedField);
+                os.write(':');
+                os.write((elapsedTime + "").getBytes());
+            }
+
+            AsyncHttpClient.log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+        }
+
+        // Close the JSON object.
+        os.write('}');
+
+        // Flush the contents up the stream.
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
+    }
+
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead;
+        long bytesWritten = 0, totalSize = wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
+    }
+
+    // Curtosy of Simple-JSON: https://goo.gl/XoW8RF
+    // Changed a bit to suit our needs in this class.
+    static byte[] escape(String string) {
+        // If it's null, just return prematurely.
+        if (string == null) {
+            return JSON_NULL;
+        }
+
+        // Create a string builder to generate the escaped string.
+        StringBuilder sb = new StringBuilder(128);
+
+        // Surround with quotations.
+        sb.append('"');
+
+        int length = string.length(), pos = -1;
+        while (++pos < length) {
+            char ch = string.charAt(pos);
+            switch (ch) {
+                case '"':
+                    sb.append("\\\"");
+                    break;
+                case '\\':
+                    sb.append("\\\\");
+                    break;
+                case '\b':
+                    sb.append("\\b");
+                    break;
+                case '\f':
+                    sb.append("\\f");
+                    break;
+                case '\n':
+                    sb.append("\\n");
+                    break;
+                case '\r':
+                    sb.append("\\r");
+                    break;
+                case '\t':
+                    sb.append("\\t");
+                    break;
+                default:
+                    // Reference: https://www.unicode.org/versions/Unicode5.1.0/
+                    if ((ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                        String intString = Integer.toHexString(ch);
+                        sb.append("\\u");
+                        int intLength = 4 - intString.length();
+                        for (int zero = 0; zero < intLength; zero++) {
+                            sb.append('0');
+                        }
+                        sb.append(intString.toUpperCase(Locale.US));
+                    } else {
+                        sb.append(ch);
+                    }
+                    break;
+            }
+        }
+
+        // Surround with quotations.
+        sb.append('"');
+
+        return sb.toString().getBytes();
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonValueInterface.java b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
new file mode 100644
index 00000000..e7b01362
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonValueInterface.java
@@ -0,0 +1,37 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+/**
+ * This interface is used to encapsulate JSON values that are handled entirely
+ * by the app. For example, apps could manage any type of JSON on their own (and
+ * not rely on {@link org.json.JSONArray} or {@link org.json.JSONObject} to
+ * exchange data.
+ *
+ * @author Noor Dawod {@literal <github@fineswap.com>}
+ */
+public interface JsonValueInterface {
+
+    /**
+     * Returns the escaped, ready-to-be used value of this encapsulated object.
+     *
+     * @return byte array holding the data to be used (as-is) in a JSON object
+     */
+    byte[] getEscapedJsonValue();
+}
diff --git a/library/src/main/java/com/loopj/android/http/LogHandler.java b/library/src/main/java/com/loopj/android/http/LogHandler.java
new file mode 100644
index 00000000..dc7ffd2b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/LogHandler.java
@@ -0,0 +1,134 @@
+package com.loopj.android.http;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.util.Log;
+
+public class LogHandler implements LogInterface {
+
+    boolean mLoggingEnabled = true;
+    int mLoggingLevel = VERBOSE;
+
+    @Override
+    public boolean isLoggingEnabled() {
+        return mLoggingEnabled;
+    }
+
+    @Override
+    public void setLoggingEnabled(boolean loggingEnabled) {
+        this.mLoggingEnabled = loggingEnabled;
+    }
+
+    @Override
+    public int getLoggingLevel() {
+        return mLoggingLevel;
+    }
+
+    @Override
+    public void setLoggingLevel(int loggingLevel) {
+        this.mLoggingLevel = loggingLevel;
+    }
+
+    @Override
+    public boolean shouldLog(int logLevel) {
+        return logLevel >= mLoggingLevel;
+    }
+
+    public void log(int logLevel, String tag, String msg) {
+        logWithThrowable(logLevel, tag, msg, null);
+    }
+
+    public void logWithThrowable(int logLevel, String tag, String msg, Throwable t) {
+        if (isLoggingEnabled() && shouldLog(logLevel)) {
+            switch (logLevel) {
+                case VERBOSE:
+                    Log.v(tag, msg, t);
+                    break;
+                case WARN:
+                    Log.w(tag, msg, t);
+                    break;
+                case ERROR:
+                    Log.e(tag, msg, t);
+                    break;
+                case DEBUG:
+                    Log.d(tag, msg, t);
+                    break;
+                case WTF:
+                    if (Integer.valueOf(Build.VERSION.SDK) > 8) {
+                        checkedWtf(tag, msg, t);
+                    } else {
+                        Log.e(tag, msg, t);
+                    }
+                    break;
+                case INFO:
+                    Log.i(tag, msg, t);
+                    break;
+            }
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.FROYO)
+    private void checkedWtf(String tag, String msg, Throwable t) {
+        Log.wtf(tag, msg, t);
+    }
+
+    @Override
+    public void v(String tag, String msg) {
+        log(VERBOSE, tag, msg);
+    }
+
+    @Override
+    public void v(String tag, String msg, Throwable t) {
+        logWithThrowable(VERBOSE, tag, msg, t);
+    }
+
+    @Override
+    public void d(String tag, String msg) {
+        log(VERBOSE, tag, msg);
+    }
+
+    @Override
+    public void d(String tag, String msg, Throwable t) {
+        logWithThrowable(DEBUG, tag, msg, t);
+    }
+
+    @Override
+    public void i(String tag, String msg) {
+        log(INFO, tag, msg);
+    }
+
+    @Override
+    public void i(String tag, String msg, Throwable t) {
+        logWithThrowable(INFO, tag, msg, t);
+    }
+
+    @Override
+    public void w(String tag, String msg) {
+        log(WARN, tag, msg);
+    }
+
+    @Override
+    public void w(String tag, String msg, Throwable t) {
+        logWithThrowable(WARN, tag, msg, t);
+    }
+
+    @Override
+    public void e(String tag, String msg) {
+        log(ERROR, tag, msg);
+    }
+
+    @Override
+    public void e(String tag, String msg, Throwable t) {
+        logWithThrowable(ERROR, tag, msg, t);
+    }
+
+    @Override
+    public void wtf(String tag, String msg) {
+        log(WTF, tag, msg);
+    }
+
+    @Override
+    public void wtf(String tag, String msg, Throwable t) {
+        logWithThrowable(WTF, tag, msg, t);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/LogInterface.java b/library/src/main/java/com/loopj/android/http/LogInterface.java
new file mode 100644
index 00000000..f5a06b19
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/LogInterface.java
@@ -0,0 +1,51 @@
+package com.loopj.android.http;
+
+/**
+ * Interface independent to any library, which currently uses same interface as {@link android.util.Log} implementation
+ * You can change currently used LogInterface through {@link AsyncHttpClient#setLogInterface(LogInterface)}
+ */
+public interface LogInterface {
+
+    int VERBOSE = 2;
+    int DEBUG = 3;
+    int INFO = 4;
+    int WARN = 5;
+    int ERROR = 6;
+    int WTF = 8;
+
+    boolean isLoggingEnabled();
+
+    void setLoggingEnabled(boolean loggingEnabled);
+
+    int getLoggingLevel();
+
+    void setLoggingLevel(int loggingLevel);
+
+    boolean shouldLog(int logLevel);
+
+    void v(String tag, String msg);
+
+    void v(String tag, String msg, Throwable t);
+
+    void d(String tag, String msg);
+
+    void d(String tag, String msg, Throwable t);
+
+    void i(String tag, String msg);
+
+    void i(String tag, String msg, Throwable t);
+
+    void w(String tag, String msg);
+
+    void w(String tag, String msg, Throwable t);
+
+    void e(String tag, String msg);
+
+    void e(String tag, String msg, Throwable t);
+
+    void wtf(String tag, String msg);
+
+    void wtf(String tag, String msg, Throwable t);
+
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
new file mode 100644
index 00000000..80a5eb61
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -0,0 +1,166 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Aymon Fournier <aymon.fournier@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.ProtocolException;
+import org.apache.http.client.CircularRedirectException;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.utils.URIUtils;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.client.RedirectLocations;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Taken from StackOverflow
+ *
+ * @author Aymon Fournier, aymon.fournier@gmail.com
+ * @see <a href="https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception">https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception</a>
+ */
+class MyRedirectHandler extends DefaultRedirectHandler {
+
+    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
+    private final boolean enableRedirects;
+
+    public MyRedirectHandler(final boolean allowRedirects) {
+        super();
+        this.enableRedirects = allowRedirects;
+    }
+
+    @Override
+    public boolean isRedirectRequested(
+            final HttpResponse response,
+            final HttpContext context) {
+        if (!enableRedirects) {
+            return false;
+        }
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        int statusCode = response.getStatusLine().getStatusCode();
+        switch (statusCode) {
+            case HttpStatus.SC_MOVED_TEMPORARILY:
+            case HttpStatus.SC_MOVED_PERMANENTLY:
+            case HttpStatus.SC_SEE_OTHER:
+            case HttpStatus.SC_TEMPORARY_REDIRECT:
+                return true;
+            default:
+                return false;
+        } //end of switch
+    }
+
+    @Override
+    public URI getLocationURI(
+            final HttpResponse response,
+            final HttpContext context) throws ProtocolException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        //get the location header to find out where to redirect to
+        Header locationHeader = response.getFirstHeader("location");
+        if (locationHeader == null) {
+            // got a redirect response, but no location header
+            throw new ProtocolException(
+                    "Received redirect response " + response.getStatusLine()
+                            + " but no location header"
+            );
+        }
+        //HERE IS THE MODIFIED LINE OF CODE
+        String location = locationHeader.getValue().replaceAll(" ", "%20");
+
+        URI uri;
+        try {
+            uri = new URI(location);
+        } catch (URISyntaxException ex) {
+            throw new ProtocolException("Invalid redirect URI: " + location, ex);
+        }
+
+        HttpParams params = response.getParams();
+        // rfc2616 demands the location value be a complete URI
+        // Location       = "Location" ":" absoluteURI
+        if (!uri.isAbsolute()) {
+            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
+                throw new ProtocolException("Relative redirect location '"
+                        + uri + "' not allowed");
+            }
+            // Adjust location URI
+            HttpHost target = (HttpHost) context.getAttribute(
+                    ExecutionContext.HTTP_TARGET_HOST);
+            if (target == null) {
+                throw new IllegalStateException("Target host not available " +
+                        "in the HTTP context");
+            }
+
+            HttpRequest request = (HttpRequest) context.getAttribute(
+                    ExecutionContext.HTTP_REQUEST);
+
+            try {
+                URI requestURI = new URI(request.getRequestLine().getUri());
+                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
+                uri = URIUtils.resolve(absoluteRequestURI, uri);
+            } catch (URISyntaxException ex) {
+                throw new ProtocolException(ex.getMessage(), ex);
+            }
+        }
+
+        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
+
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
+                    REDIRECT_LOCATIONS);
+
+            if (redirectLocations == null) {
+                redirectLocations = new RedirectLocations();
+                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
+            }
+
+            URI redirectURI;
+            if (uri.getFragment() != null) {
+                try {
+                    HttpHost target = new HttpHost(
+                            uri.getHost(),
+                            uri.getPort(),
+                            uri.getScheme());
+                    redirectURI = URIUtils.rewriteURI(uri, target, true);
+                } catch (URISyntaxException ex) {
+                    throw new ProtocolException(ex.getMessage(), ex);
+                }
+            } else {
+                redirectURI = uri;
+            }
+
+            if (redirectLocations.contains(redirectURI)) {
+                throw new CircularRedirectException("Circular redirect to '" +
+                        redirectURI + "'");
+            } else {
+                redirectLocations.add(redirectURI);
+            }
+        }
+
+        return uri;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
old mode 100644
new mode 100755
index eb4aa97e..67d6becc
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,48 +1,87 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
 
+import java.io.BufferedInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.Socket;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
 import java.security.NoSuchAlgorithmException;
 import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
 
+import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
 
 /**
  * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
- * http://code.google.com/p/android/issues/detail?id=13117#c14
+ * https://code.google.com/p/android/issues/detail?id=13117#c14 <p>&nbsp;</p> Warning! This omits SSL
+ * certificate validation on every device, use with caution
  */
 public class MySSLSocketFactory extends SSLSocketFactory {
-    SSLContext sslContext = SSLContext.getInstance("TLS");
+    final SSLContext sslContext = SSLContext.getInstance("TLS");
 
-    public MySSLSocketFactory(KeyStore truststore)
-            throws NoSuchAlgorithmException, KeyManagementException,
-            KeyStoreException, UnrecoverableKeyException {
+    /**
+     * Creates a new SSL Socket Factory with the given KeyStore.
+     *
+     * @param truststore A KeyStore to create the SSL Socket Factory in context of
+     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
+     * @throws KeyManagementException    KeyManagementException
+     * @throws KeyStoreException         KeyStoreException
+     * @throws UnrecoverableKeyException UnrecoverableKeyException
+     */
+    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);
 
-        TrustManager tm = new X509TrustManager() {
-            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
-                return null;
+        X509TrustManager tm = new X509TrustManager() {
+            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
 
-            @Override
-            public void checkClientTrusted(
-                    java.security.cert.X509Certificate[] chain, String authType)
-                    throws java.security.cert.CertificateException {
+            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
 
-            @Override
-            public void checkServerTrusted(
-                    java.security.cert.X509Certificate[] chain, String authType)
-                    throws java.security.cert.CertificateException {
+            public X509Certificate[] getAcceptedIssuers() {
+                return null;
             }
         };
+
         sslContext.init(null, new TrustManager[]{tm}, null);
     }
 
@@ -56,6 +95,58 @@ public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
     }
 
+    /**
+     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
+     */
+    public void fixHttpsURLConnection() {
+        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+    }
+
+    /**
+     * Gets a KeyStore containing the Certificate
+     *
+     * @param cert InputStream of the Certificate
+     * @return KeyStore
+     */
+    public static KeyStore getKeystoreOfCA(InputStream cert) {
+
+        // Load CAs from an InputStream
+        InputStream caInput = null;
+        Certificate ca = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            caInput = new BufferedInputStream(cert);
+            ca = cf.generateCertificate(caInput);
+        } catch (CertificateException e1) {
+            e1.printStackTrace();
+        } finally {
+            try {
+                if (caInput != null) {
+                    caInput.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Create a KeyStore containing our trusted CAs
+        String keyStoreType = KeyStore.getDefaultType();
+        KeyStore keyStore = null;
+        try {
+            keyStore = KeyStore.getInstance(keyStoreType);
+            keyStore.load(null, null);
+            keyStore.setCertificateEntry("ca", ca);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return keyStore;
+    }
+
+    /**
+     * Gets a Default KeyStore
+     *
+     * @return KeyStore
+     */
     public static KeyStore getKeystore() {
         KeyStore trustStore = null;
         try {
@@ -67,6 +158,11 @@ public static KeyStore getKeystore() {
         return trustStore;
     }
 
+    /**
+     * Returns a SSlSocketFactory which trusts all certificates
+     *
+     * @return SSLSocketFactory
+     */
     public static SSLSocketFactory getFixedSocketFactory() {
         SSLSocketFactory socketFactory;
         try {
@@ -79,4 +175,30 @@ public static SSLSocketFactory getFixedSocketFactory() {
         return socketFactory;
     }
 
-}
\ No newline at end of file
+    /**
+     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
+     *
+     * @param keyStore custom provided KeyStore instance
+     * @return DefaultHttpClient
+     */
+    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+
+        try {
+            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+            registry.register(new Scheme("https", sf, 443));
+
+            HttpParams params = new BasicHttpParams();
+            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+
+            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+
+            return new DefaultHttpClient(ccm, params);
+        } catch (Exception e) {
+            return new DefaultHttpClient();
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
old mode 100644
new mode 100755
index 96316991..04708281
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -27,11 +27,13 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -42,9 +44,11 @@
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
+    private static final String LOG_TAG = "PersistentCookieStore";
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
+    private boolean omitNonPersistentCookies = false;
 
     private final ConcurrentHashMap<String, Cookie> cookies;
     private final SharedPreferences cookiePrefs;
@@ -79,6 +83,8 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
+        if (omitNonPersistentCookies && !cookie.isPersistent())
+            return;
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
@@ -143,56 +149,102 @@ public boolean clearExpired(Date date) {
         return new ArrayList<Cookie>(cookies.values());
     }
 
+    /**
+     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
+     * signature (`Cookie.isPersistent`)
+     *
+     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
+     */
+    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
+        this.omitNonPersistentCookies = omitNonPersistentCookies;
+    }
 
-    //
-    // Cookie serialization/deserialization
-    //
+    /**
+     * Non-standard helper method, to delete cookie
+     *
+     * @param cookie cookie to be removed
+     */
+    public void deleteCookie(Cookie cookie) {
+        String name = cookie.getName() + cookie.getDomain();
+        cookies.remove(name);
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        prefsWriter.commit();
+    }
 
+    /**
+     * Serializes Cookie object into String
+     *
+     * @param cookie cookie to be encoded, can be null
+     * @return cookie encoded as String
+     */
     protected String encodeCookie(SerializableCookie cookie) {
+        if (cookie == null)
+            return null;
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
             outputStream.writeObject(cookie);
-        } catch (Exception e) {
+        } catch (IOException e) {
+            AsyncHttpClient.log.d(LOG_TAG, "IOException in encodeCookie", e);
             return null;
         }
 
         return byteArrayToHexString(os.toByteArray());
     }
 
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+    /**
+     * Returns cookie decoded from cookie string
+     *
+     * @param cookieString string of cookie as returned from http request
+     * @return decoded cookie or null if exception occured
+     */
+    protected Cookie decodeCookie(String cookieString) {
+        byte[] bytes = hexStringToByteArray(cookieString);
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-            ObjectInputStream ois = new ObjectInputStream(is);
-            cookie = ((SerializableCookie) ois.readObject()).getCookie();
-        } catch (Exception e) {
-            e.printStackTrace();
+            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
+            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
+        } catch (IOException e) {
+            AsyncHttpClient.log.d(LOG_TAG, "IOException in decodeCookie", e);
+        } catch (ClassNotFoundException e) {
+            AsyncHttpClient.log.d(LOG_TAG, "ClassNotFoundException in decodeCookie", e);
         }
 
         return cookie;
     }
 
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuilder sb = new StringBuilder(b.length * 2);
-        for (byte element : b) {
+    /**
+     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any
+     * large Base64 libraries. Can be overridden if you like!
+     *
+     * @param bytes byte array to be converted
+     * @return string containing hex values
+     */
+    protected String byteArrayToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        for (byte element : bytes) {
             int v = element & 0xff;
             if (v < 16) {
                 sb.append('0');
             }
             sb.append(Integer.toHexString(v));
         }
-        return sb.toString().toUpperCase();
+        return sb.toString().toUpperCase(Locale.US);
     }
 
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
+    /**
+     * Converts hex values from strings to byte arra
+     *
+     * @param hexString string of hex-encoded values
+     * @return decoded byte array
+     */
+    protected byte[] hexStringToByteArray(String hexString) {
+        int len = hexString.length();
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
+            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java
new file mode 100644
index 00000000..06abdf0d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java
@@ -0,0 +1,54 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+public class PreemptiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
+
+    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                ClientContext.CREDS_PROVIDER);
+        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+        if (authState.getAuthScheme() == null) {
+            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+            Credentials creds = credsProvider.getCredentials(authScope);
+            if (creds != null) {
+                authState.setAuthScheme(new BasicScheme());
+                authState.setCredentials(creds);
+            }
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..ba8a666c
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -0,0 +1,109 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
+    private static final String LOG_TAG = "RangeFileAsyncHttpRH";
+
+    private long current = 0;
+    private boolean append = false;
+
+    /**
+     * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public RangeFileAsyncHttpResponseHandler(File file) {
+        super(file);
+    }
+
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
+                //already finished
+                if (!Thread.currentThread().isInterrupted())
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+            } else if (status.getStatusCode() >= 300) {
+                if (!Thread.currentThread().isInterrupted())
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+            } else {
+                if (!Thread.currentThread().isInterrupted()) {
+                    Header header = response.getFirstHeader(AsyncHttpClient.HEADER_CONTENT_RANGE);
+                    if (header == null) {
+                        append = false;
+                        current = 0;
+                    } else {
+                        AsyncHttpClient.log.v(LOG_TAG, AsyncHttpClient.HEADER_CONTENT_RANGE + ": " + header.getValue());
+                    }
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+                }
+            }
+        }
+    }
+
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength() + current;
+            FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l;
+                    while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        current += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage(current, contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
+
+    public void updateRequestHeaders(HttpUriRequest uriRequest) {
+        if (file.exists() && file.canWrite())
+            current = file.length();
+        if (current > 0) {
+            append = true;
+            uriRequest.setHeader("Range", "bytes=" + current + "-");
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
old mode 100644
new mode 100755
index 08cb7824..3992185c
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -1,15 +1,35 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Jason Choy <jjwchoy@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
-import java.util.concurrent.Future;
+import android.os.Looper;
+
+import java.lang.ref.WeakReference;
 
 /**
  * A Handle to an AsyncRequest which can be used to cancel a running request.
  */
 public class RequestHandle {
-    private final Future<?> request;
+    private final WeakReference<AsyncHttpRequest> request;
 
-    public RequestHandle(Future<?> request) {
-        this.request = request;
+    public RequestHandle(AsyncHttpRequest request) {
+        this.request = new WeakReference<AsyncHttpRequest>(request);
     }
 
     /**
@@ -20,15 +40,32 @@ public RequestHandle(Future<?> request) {
      * thread executing this request should be interrupted in an attempt to stop the request.
      * <p>&nbsp;</p> After this method returns, subsequent calls to isDone() will always return
      * true. Subsequent calls to isCancelled() will always return true if this method returned
-     * true.
+     * true. Subsequent calls to isDone() will return true either if the request got cancelled by
+     * this method, or if the request completed normally
      *
      * @param mayInterruptIfRunning true if the thread executing this request should be interrupted;
      *                              otherwise, in-progress requests are allowed to complete
      * @return false if the request could not be cancelled, typically because it has already
      * completed normally; true otherwise
      */
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        return this.request != null && request.cancel(mayInterruptIfRunning);
+    public boolean cancel(final boolean mayInterruptIfRunning) {
+        final AsyncHttpRequest _request = request.get();
+        if (_request != null) {
+            if (Looper.myLooper() == Looper.getMainLooper()) {
+                new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        _request.cancel(mayInterruptIfRunning);
+                    }
+                }).start();
+                // Cannot reliably tell if the request got immediately canceled at this point
+                // we'll assume it got cancelled
+                return true;
+            } else {
+                return _request.cancel(mayInterruptIfRunning);
+            }
+        }
+        return false;
     }
 
     /**
@@ -38,7 +75,8 @@ public boolean cancel(boolean mayInterruptIfRunning) {
      * @return true if this task completed
      */
     public boolean isFinished() {
-        return this.request == null || request.isDone();
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isDone();
     }
 
     /**
@@ -47,6 +85,37 @@ public boolean isFinished() {
      * @return true if this task was cancelled before it completed
      */
     public boolean isCancelled() {
-        return this.request != null && request.isCancelled();
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isCancelled();
+    }
+
+    public boolean shouldBeGarbageCollected() {
+        boolean should = isCancelled() || isFinished();
+        if (should)
+            request.clear();
+        return should;
+    }
+
+    /**
+     * Will set Object as TAG to underlying AsyncHttpRequest
+     *
+     * @param tag Object used as TAG to underlying AsyncHttpRequest
+     * @return this RequestHandle to allow fluid syntax
+     */
+    public RequestHandle setTag(Object tag) {
+        AsyncHttpRequest _request = request.get();
+        if (_request != null)
+            _request.setRequestTag(tag);
+        return this;
+    }
+
+    /**
+     * Will return TAG of underlying AsyncHttpRequest if it's not already GCed
+     *
+     * @return Object TAG, can be null
+     */
+    public Object getTag() {
+        AsyncHttpRequest _request = request.get();
+        return _request == null ? null : _request.getTag();
     }
 }
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
old mode 100644
new mode 100755
index c7eedce6..1536ab2d
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -28,6 +28,7 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -35,6 +36,7 @@
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -64,12 +66,16 @@
  * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
  * list.add("Java");
  * list.add("C");
- * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
+ * params.put("languages", list); // url params: "languages[0]=Java&amp;languages[1]=C"
  *
  * String[] colors = { "blue", "yellow" }; // Ordered collection
- * params.put("colors", colors); // url params: "colors[]=blue&amp;colors[]=yellow"
+ * params.put("colors", colors); // url params: "colors[0]=blue&amp;colors[1]=yellow"
  *
- * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
+ * File[] files = { new File("pic.jpg"), new File("pic1.jpg") }; // Ordered collection
+ * params.put("files", files); // url params: "files[]=pic.jpg&amp;files[]=pic1.jpg"
+ *
+ * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String,
+ * String&gt;&gt;();
  * Map&lt;String, String&gt; user1 = new HashMap&lt;String, String&gt;();
  * user1.put("age", "30");
  * user1.put("gender", "male");
@@ -81,16 +87,55 @@
  * params.put("users", listOfMaps); // url params: "users[][age]=30&amp;users[][gender]=male&amp;users[][age]=25&amp;users[][gender]=female"
  *
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.post("http://myendpoint.com", params, responseHandler);
+ * client.post("https://myendpoint.com", params, responseHandler);
  * </pre>
  */
-public class RequestParams {
+public class RequestParams implements Serializable {
+
+    public final static String APPLICATION_OCTET_STREAM =
+            "application/octet-stream";
+
+    public final static String APPLICATION_JSON =
+            "application/json";
+
+    protected final static String LOG_TAG = "RequestParams";
+    protected boolean isRepeatable;
+    protected boolean forceMultipartEntity = false;
+    protected boolean useJsonStreamer;
+    protected String elapsedFieldInJsonStreamer = "_elapsed";
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
+    protected final ConcurrentHashMap<String, List<FileWrapper>> fileArrayParams = new ConcurrentHashMap<String, List<FileWrapper>>();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
+    protected String contentEncoding = HTTP.UTF_8;
+
+    /**
+     * Sets content encoding for return value of {@link #getParamString()} and {@link
+     * #createFormEntity()} <p>&nbsp;</p> Default encoding is "UTF-8"
+     *
+     * @param encoding String constant from {@link HTTP}
+     */
+    public void setContentEncoding(final String encoding) {
+        if (encoding != null) {
+            this.contentEncoding = encoding;
+        } else {
+            AsyncHttpClient.log.d(LOG_TAG, "setContentEncoding called with null attribute");
+        }
+    }
 
-    protected boolean isRepeatable = false;
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
+    /**
+     * If set to true will force Content-Type header to `multipart/form-data`
+     * even if there are not Files or Streams to be send
+     * <p>&nbsp;</p>
+     * Default value is false
+     *
+     * @param force boolean, should declare content-type multipart/form-data even without files or streams present
+     */
+    public void setForceMultipartEntityContentType(boolean force) {
+        this.forceMultipartEntity = force;
+    }
 
     /**
      * Constructs a new empty {@code RequestParams} instance.
@@ -106,7 +151,6 @@ public RequestParams() {
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
-        init();
         if (source != null) {
             for (Map.Entry<String, String> entry : source.entrySet()) {
                 put(entry.getKey(), entry.getValue());
@@ -136,7 +180,6 @@ public RequestParams(final String key, final String value) {
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-        init();
         int len = keysAndValues.length;
         if (len % 2 != 0)
             throw new IllegalArgumentException("Supplied arguments must be even");
@@ -159,28 +202,90 @@ public void put(String key, String value) {
         }
     }
 
+    /**
+     * Adds files array to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param files the files array to add.
+     * @throws FileNotFoundException if one of passed files is not found at time of assembling the requestparams into request
+     */
+    public void put(String key, File files[]) throws FileNotFoundException {
+        put(key, files, null, null);
+    }
+
+    /**
+     * Adds files array to the request with both custom provided file content-type and files name
+     *
+     * @param key            the key name for the new param.
+     * @param files          the files array to add.
+     * @param contentType    the content type of the file, eg. application/json
+     * @param customFileName file name to use instead of real file name
+     * @throws FileNotFoundException throws if wrong File argument was passed
+     */
+    public void put(String key, File files[], String contentType, String customFileName) throws FileNotFoundException {
+
+        if (key != null) {
+            List<FileWrapper> fileWrappers = new ArrayList<FileWrapper>();
+            for (File file : files) {
+                if (file == null || !file.exists()) {
+                    throw new FileNotFoundException();
+                }
+                fileWrappers.add(new FileWrapper(file, contentType, customFileName));
+            }
+            fileArrayParams.put(key, fileWrappers);
+        }
+    }
+
     /**
      * Adds a file to the request.
      *
      * @param key  the key name for the new param.
      * @param file the file to add.
-     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
+     * @throws FileNotFoundException throws if wrong File argument was passed
      */
     public void put(String key, File file) throws FileNotFoundException {
-        put(key, file, null);
+        put(key, file, null, null);
     }
 
     /**
-     * Adds a file to the request.
+     * Adds a file to the request with custom provided file name
+     *
+     * @param key            the key name for the new param.
+     * @param file           the file to add.
+     * @param customFileName file name to use instead of real file name
+     * @throws FileNotFoundException throws if wrong File argument was passed
+     */
+    public void put(String key, String customFileName, File file) throws FileNotFoundException {
+        put(key, file, null, customFileName);
+    }
+
+    /**
+     * Adds a file to the request with custom provided file content-type
      *
      * @param key         the key name for the new param.
      * @param file        the file to add.
      * @param contentType the content type of the file, eg. application/json
-     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
+     * @throws FileNotFoundException throws if wrong File argument was passed
      */
     public void put(String key, File file, String contentType) throws FileNotFoundException {
-        if (key != null && file != null) {
-            fileParams.put(key, new FileWrapper(file, contentType));
+        put(key, file, contentType, null);
+    }
+
+    /**
+     * Adds a file to the request with both custom provided file content-type and file name
+     *
+     * @param key            the key name for the new param.
+     * @param file           the file to add.
+     * @param contentType    the content type of the file, eg. application/json
+     * @param customFileName file name to use instead of real file name
+     * @throws FileNotFoundException throws if wrong File argument was passed
+     */
+    public void put(String key, File file, String contentType, String customFileName) throws FileNotFoundException {
+        if (file == null || !file.exists()) {
+            throw new FileNotFoundException();
+        }
+        if (key != null) {
+            fileParams.put(key, new FileWrapper(file, contentType, customFileName));
         }
     }
 
@@ -214,8 +319,21 @@ public void put(String key, InputStream stream, String name) {
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
         if (key != null && stream != null) {
-            streamParams.put(key, new StreamWrapper(stream, name, contentType));
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
         }
     }
 
@@ -231,6 +349,30 @@ public void put(String key, Object value) {
         }
     }
 
+    /**
+     * Adds a int value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value int for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds a long value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value long for the new param.
+     */
+    public void put(String key, long value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds string value to param which can have more than one value.
      *
@@ -263,6 +405,21 @@ public void remove(String key) {
         streamParams.remove(key);
         fileParams.remove(key);
         urlParamsWithObjects.remove(key);
+        fileArrayParams.remove(key);
+    }
+
+    /**
+     * Check if a parameter is defined.
+     *
+     * @param key the key name for the parameter to check existence.
+     * @return Boolean
+     */
+    public boolean has(String key) {
+        return urlParams.get(key) != null ||
+                streamParams.get(key) != null ||
+                fileParams.get(key) != null ||
+                urlParamsWithObjects.get(key) != null ||
+                fileArrayParams.get(key) != null;
     }
 
     @Override
@@ -295,6 +452,15 @@ public String toString() {
             result.append("FILE");
         }
 
+        for (ConcurrentHashMap.Entry<String, List<FileWrapper>> entry : fileArrayParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("FILES(SIZE=").append(entry.getValue().size()).append(")");
+        }
+
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
             if (result.length() > 0)
@@ -308,12 +474,39 @@ public String toString() {
         return result.toString();
     }
 
-    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
-        this.isRepeatable = isRepeatable;
+    public void setHttpEntityIsRepeatable(boolean flag) {
+        this.isRepeatable = flag;
+    }
+
+    public void setUseJsonStreamer(boolean flag) {
+        this.useJsonStreamer = flag;
     }
 
     /**
-     * Returns an HttpEntity containing all request parameters
+     * Sets an additional field when upload a JSON object through the streamer
+     * to hold the time, in milliseconds, it took to upload the payload. By
+     * default, this field is set to "_elapsed".
+     * <p>&nbsp;</p>
+     * To disable this feature, call this method with null as the field value.
+     *
+     * @param value field name to add elapsed time, or null to disable
+     */
+    public void setElapsedFieldInJsonStreamer(String value) {
+        this.elapsedFieldInJsonStreamer = value;
+    }
+
+    /**
+     * Set global flag which determines whether to automatically close input streams on successful
+     * upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
      * @return HttpEntity resulting HttpEntity to be included along with {@link
@@ -321,18 +514,59 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
      * @throws IOException if one of the streams cannot be read
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+        if (useJsonStreamer) {
+            return createJsonStreamerEntity(progressHandler);
+        } else if (!forceMultipartEntity && streamParams.isEmpty() && fileParams.isEmpty() && fileArrayParams.isEmpty()) {
             return createFormEntity();
         } else {
             return createMultipartEntity(progressHandler);
         }
     }
 
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(
+                progressHandler,
+                !fileParams.isEmpty() || !streamParams.isEmpty(),
+                elapsedFieldInJsonStreamer);
+
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add non-string params
+        for (ConcurrentHashMap.Entry<String, Object> entry : urlParamsWithObjects.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(),
+                        StreamWrapper.newInstance(
+                                stream.inputStream,
+                                stream.name,
+                                stream.contentType,
+                                stream.autoClose)
+                );
+            }
+        }
+
+        return entity;
+    }
+
     private HttpEntity createFormEntity() {
         try {
-            return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
+            return new UrlEncodedFormEntity(getParamsList(), contentEncoding);
         } catch (UnsupportedEncodingException e) {
-            return null; // Actually cannot happen when using utf-8
+            AsyncHttpClient.log.e(LOG_TAG, "createFormEntity failed", e);
+            return null; // Can happen, if the 'contentEncoding' won't be HTTP.UTF_8
         }
     }
 
@@ -342,13 +576,13 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
+            entity.addPartWithCharset(entry.getKey(), entry.getValue(), contentEncoding);
         }
 
         // Add non-string params
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
-            entity.addPart(kv.getName(), kv.getValue());
+            entity.addPartWithCharset(kv.getName(), kv.getValue(), contentEncoding);
         }
 
         // Add stream params
@@ -363,17 +597,18 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
             FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType, fileWrapper.customFileName);
         }
 
-        return entity;
-    }
+        // Add file collection
+        for (ConcurrentHashMap.Entry<String, List<FileWrapper>> entry : fileArrayParams.entrySet()) {
+            List<FileWrapper> fileWrapper = entry.getValue();
+            for (FileWrapper fw : fileWrapper) {
+                entity.addPart(entry.getKey(), fw.file, fw.contentType, fw.customFileName);
+            }
+        }
 
-    private void init() {
-        urlParams = new ConcurrentHashMap<String, String>();
-        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
+        return entity;
     }
 
     protected List<BasicNameValuePair> getParamsList() {
@@ -391,61 +626,79 @@ private void init() {
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
         List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
         if (value instanceof Map) {
-            Map<String, Object> map = (Map<String, Object>) value;
-            List<String> list = new ArrayList<String>(map.keySet());
+            Map map = (Map) value;
+            List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
-            Collections.sort(list);
-            for (String nestedKey : list) {
-                Object nestedValue = map.get(nestedKey);
-                if (nestedValue != null) {
-                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
-                            nestedValue));
+            if (list.size() > 0 && list.get(0) instanceof Comparable) {
+                Collections.sort(list);
+            }
+            for (Object nestedKey : list) {
+                if (nestedKey instanceof String) {
+                    Object nestedValue = map.get(nestedKey);
+                    if (nestedValue != null) {
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format(Locale.US, "%s[%s]", key, nestedKey),
+                                nestedValue));
+                    }
                 }
             }
         } else if (value instanceof List) {
-            List<Object> list = (List<Object>) value;
-            for (Object nestedValue : list) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            List list = (List) value;
+            int listSize = list.size();
+            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format(Locale.US, "%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
             }
         } else if (value instanceof Object[]) {
             Object[] array = (Object[]) value;
-            for (Object nestedValue : array) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            int arrayLength = array.length;
+            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format(Locale.US, "%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
             }
         } else if (value instanceof Set) {
-            Set<Object> set = (Set<Object>) value;
+            Set set = (Set) value;
             for (Object nestedValue : set) {
                 params.addAll(getParamsList(key, nestedValue));
             }
-        } else if (value instanceof String) {
-            params.add(new BasicNameValuePair(key, (String) value));
+        } else {
+            params.add(new BasicNameValuePair(key, value.toString()));
         }
         return params;
     }
 
     protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
+        return URLEncodedUtils.format(getParamsList(), contentEncoding);
     }
 
-    private static class FileWrapper {
-        public File file;
-        public String contentType;
+    public static class FileWrapper implements Serializable {
+        public final File file;
+        public final String contentType;
+        public final String customFileName;
 
-        public FileWrapper(File file, String contentType) {
+        public FileWrapper(File file, String contentType, String customFileName) {
             this.file = file;
             this.contentType = contentType;
+            this.customFileName = customFileName;
         }
     }
 
-    private static class StreamWrapper {
-        public InputStream inputStream;
-        public String name;
-        public String contentType;
+    public static class StreamWrapper {
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
 
-        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
             this.inputStream = inputStream;
             this.name = name;
             this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                    inputStream,
+                    name,
+                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                    autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
old mode 100644
new mode 100755
index 06b2145b..82fbc1bc
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
@@ -35,7 +53,12 @@
      * @param bytesWritten number of written bytes
      * @param bytesTotal   number of total bytes to be written
      */
-    void sendProgressMessage(int bytesWritten, int bytesTotal);
+    void sendProgressMessage(long bytesWritten, long bytesTotal);
+
+    /**
+     * Notifies callback, that request was cancelled
+     */
+    void sendCancelMessage();
 
     /**
      * Notifies callback, that request was handled successfully
@@ -58,36 +81,38 @@
 
     /**
      * Notifies callback of retrying request
+     *
+     * @param retryNo number of retry within one request
      */
-    void sendRetryMessage();
+    void sendRetryMessage(int retryNo);
 
     /**
      * Returns URI which was used to request
      *
      * @return uri of origin request
      */
-    public URI getRequestURI();
+    URI getRequestURI();
 
     /**
      * Returns Header[] which were used to request
      *
      * @return headers from origin request
      */
-    public Header[] getRequestHeaders();
+    Header[] getRequestHeaders();
 
     /**
      * Helper for handlers to receive Request URI info
      *
      * @param requestURI claimed request URI
      */
-    public void setRequestURI(URI requestURI);
+    void setRequestURI(URI requestURI);
 
     /**
      * Helper for handlers to receive Request Header[] info
      *
      * @param requestHeaders Headers, claimed to be from original request
      */
-    public void setRequestHeaders(Header[] requestHeaders);
+    void setRequestHeaders(Header[] requestHeaders);
 
     /**
      * Can set, whether the handler should be asynchronous or synchronous
@@ -95,4 +120,70 @@
      * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
      */
     void setUseSynchronousMode(boolean useSynchronousMode);
+
+    /**
+     * Returns whether the handler is asynchronous or synchronous
+     *
+     * @return boolean if the ResponseHandler is running in synchronous mode
+     */
+    boolean getUseSynchronousMode();
+
+    /**
+     * Sets whether the handler should be executed on the pool's thread or the
+     * UI thread
+     *
+     * @param usePoolThread if the ResponseHandler should run on pool's thread
+     */
+    void setUsePoolThread(boolean usePoolThread);
+
+    /**
+     * Returns whether the handler should be executed on the pool's thread
+     * or the UI thread
+     *
+     * @return boolean if the ResponseHandler should run on pool's thread
+     */
+    boolean getUsePoolThread();
+
+    /**
+     * This method is called once by the system when the response is about to be
+     * processed by the system. The library makes sure that a single response
+     * is pre-processed only once.
+     * <p>&nbsp;</p>
+     * Please note: pre-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to pre-processed
+     */
+    void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
+
+    /**
+     * This method is called once by the system when the request has been fully
+     * sent, handled and finished. The library makes sure that a single response
+     * is post-processed only once.
+     * <p>&nbsp;</p>
+     * Please note: post-processing does NOT run on the main thread, and thus
+     * any UI activities that you must perform should be properly dispatched to
+     * the app's UI thread.
+     *
+     * @param instance An instance of this response object
+     * @param response The response to post-process
+     */
+    void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response);
+
+    /**
+     * Will set TAG to ResponseHandlerInterface implementation, which can be then obtained
+     * in implemented methods, such as onSuccess, onFailure, ...
+     *
+     * @param TAG Object to be set as TAG, will be placed in WeakReference
+     */
+    void setTag(Object TAG);
+
+    /**
+     * Will retrieve TAG Object if it's not already freed from memory
+     *
+     * @return Object TAG or null if it's been garbage collected
+     */
+    Object getTag();
 }
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
old mode 100644
new mode 100755
index e8ea7cca..7dba7a45
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
     static {
         // Retry if the server dropped connection on us
@@ -75,12 +75,12 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         if (executionCount > maxRetries) {
             // Do not retry if over max retry count
             retry = false;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
         } else if (isInList(exceptionWhitelist, exception)) {
             // immediately retry if error is whitelisted
             retry = true;
+        } else if (isInList(exceptionBlacklist, exception)) {
+            // immediately cancel retry if the error is blacklisted
+            retry = false;
         } else if (!sent) {
             // for most other errors, retry only if request hasn't been fully sent yet
             retry = true;
@@ -92,8 +92,6 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             if (currentReq == null) {
                 return false;
             }
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
         }
 
         if (retry) {
@@ -105,6 +103,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         return retry;
     }
 
+    static void addClassToWhitelist(Class<?> cls) {
+        exceptionWhitelist.add(cls);
+    }
+
+    static void addClassToBlacklist(Class<?> cls) {
+        exceptionBlacklist.add(cls);
+    }
+
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
         for (Class<?> aList : list) {
             if (aList.isInstance(error)) {
@@ -113,4 +119,4 @@ protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
         }
         return false;
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..fd0a2b58
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
@@ -0,0 +1,147 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+/**
+ * Provides interface to deserialize SAX responses, using AsyncHttpResponseHandler. Can be used like
+ * this
+ * <p>&nbsp;</p>
+ * <pre>
+ *     AsyncHttpClient ahc = new AsyncHttpClient();
+ *     FontHandler handlerInstance = ... ; // init handler instance
+ *     ahc.post("https://server.tld/api/call", new SaxAsyncHttpResponseHandler{@literal <}FontHandler{@literal >}(handlerInstance){
+ *         &#064;Override
+ *         public void onSuccess(int statusCode, Header[] headers, FontHandler t) {
+ *              // Request got HTTP success statusCode
+ *         }
+ *         &#064;Override
+ *         public void onFailure(int statusCode, Header[] headers, FontHandler t){
+ *              // Request got HTTP fail statusCode
+ *         }
+ *     });
+ * </pre>
+ *
+ * @param <T> Handler extending {@link org.xml.sax.helpers.DefaultHandler}
+ * @see org.xml.sax.helpers.DefaultHandler
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ */
+public abstract class SaxAsyncHttpResponseHandler<T extends DefaultHandler> extends AsyncHttpResponseHandler {
+
+    /**
+     * Generic Type of handler
+     */
+    private T handler = null;
+    private final static String LOG_TAG = "SaxAsyncHttpRH";
+
+    /**
+     * Constructs new SaxAsyncHttpResponseHandler with given handler instance
+     *
+     * @param t instance of Handler extending DefaultHandler
+     * @see org.xml.sax.helpers.DefaultHandler
+     */
+    public SaxAsyncHttpResponseHandler(T t) {
+        super();
+        if (t == null) {
+            throw new Error("null instance of <T extends DefaultHandler> passed to constructor");
+        }
+        this.handler = t;
+    }
+
+    /**
+     * Deconstructs response into given content handler
+     *
+     * @param entity returned HttpEntity
+     * @return deconstructed response
+     * @throws java.io.IOException if there is problem assembling SAX response from stream
+     * @see org.apache.http.HttpEntity
+     */
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            InputStreamReader inputStreamReader = null;
+            if (instream != null) {
+                try {
+                    SAXParserFactory sfactory = SAXParserFactory.newInstance();
+                    SAXParser sparser = sfactory.newSAXParser();
+                    XMLReader rssReader = sparser.getXMLReader();
+                    rssReader.setContentHandler(handler);
+                    inputStreamReader = new InputStreamReader(instream, getCharset());
+                    rssReader.parse(new InputSource(inputStreamReader));
+                } catch (SAXException e) {
+                    AsyncHttpClient.log.e(LOG_TAG, "getResponseData exception", e);
+                } catch (ParserConfigurationException e) {
+                    AsyncHttpClient.log.e(LOG_TAG, "getResponseData exception", e);
+                } finally {
+                    AsyncHttpClient.silentCloseInputStream(instream);
+                    if (inputStreamReader != null) {
+                        try {
+                            inputStreamReader.close();
+                        } catch (IOException e) { /*ignore*/ }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Default onSuccess method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, headers, handler);
+    }
+
+    /**
+     * Default onFailure method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers,
+                          byte[] responseBody, Throwable error) {
+        onFailure(statusCode, headers, handler);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
old mode 100644
new mode 100755
index 855105b1..ef8895eb
--- a/library/src/main/java/com/loopj/android/http/SerializableCookie.java
+++ b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -61,9 +61,9 @@ private void writeObject(ObjectOutputStream out) throws IOException {
     }
 
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String) in.readObject();
+        String key = (String) in.readObject();
         String value = (String) in.readObject();
-        clientCookie = new BasicClientCookie(name, value);
+        clientCookie = new BasicClientCookie(key, value);
         clientCookie.setComment((String) in.readObject());
         clientCookie.setDomain((String) in.readObject());
         clientCookie.setExpiryDate((Date) in.readObject());
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
old mode 100644
new mode 100755
index d4135139..541b3d5a
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -1,13 +1,13 @@
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
+    https://loopj.com
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
 
-        http://www.apache.org/licenses/LICENSE-2.0
+        https://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,17 +17,18 @@
 */
 
 /*
-    This code is taken from Rafael Sanches' blog.
-    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
+    This code is taken from Rafael Sanches' blog. Link is no longer working (as of 17th July 2015)
+    https://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
 */
 
 package com.loopj.android.http;
 
-import android.util.Log;
+import android.text.TextUtils;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -46,29 +47,30 @@
 
     private static final String LOG_TAG = "SimpleMultipartEntity";
 
-    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
-    private static final byte[] CR_LF = ("\r\n").getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
-            .getBytes();
+    private static final String STR_CR_LF = "\r\n";
+    private static final byte[] CR_LF = STR_CR_LF.getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY =
+            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+    private final static char[] MULTIPART_CHARS =
+            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary;
-    private byte[] boundaryLine;
-    private byte[] boundaryEnd;
-    private boolean isRepeatable = false;
+    private final String boundary;
+    private final byte[] boundaryLine;
+    private final byte[] boundaryEnd;
+    private boolean isRepeatable;
 
-    private List<FilePart> fileParts = new ArrayList<FilePart>();
+    private final List<FilePart> fileParts = new ArrayList<FilePart>();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
-    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    private ResponseHandlerInterface progressHandler;
+    private final ResponseHandlerInterface progressHandler;
 
-    private int bytesWritten;
+    private long bytesWritten;
 
-    private int totalSize;
+    private long totalSize;
 
     public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         final StringBuilder buf = new StringBuilder();
@@ -78,13 +80,13 @@ public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         }
 
         boundary = buf.toString();
-        boundaryLine = ("--" + boundary + "\r\n").getBytes();
-        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
+        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
 
         this.progressHandler = progressHandler;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
+    public void addPart(String key, String value, String contentType) {
         try {
             out.write(boundaryLine);
             out.write(createContentDisposition(key));
@@ -93,31 +95,35 @@ public void addPart(final String key, final String value, final String contentTy
             out.write(value.getBytes());
             out.write(CR_LF);
         } catch (final IOException e) {
-            // Can't happen on ByteArrayOutputStream
-            Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
+            // Shall not happen on ByteArrayOutputStream
+            AsyncHttpClient.log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
         }
     }
 
-    public void addPart(final String key, final String value) {
-        addPart(key, value, "text/plain; charset=UTF-8");
+    public void addPartWithCharset(String key, String value, String charset) {
+        if (charset == null) charset = HTTP.UTF_8;
+        addPart(key, value, "text/plain; charset=" + charset);
+    }
+
+    public void addPart(String key, String value) {
+        addPartWithCharset(key, value, null);
     }
 
     public void addPart(String key, File file) {
         addPart(key, file, null);
     }
 
-    public void addPart(final String key, File file, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        fileParts.add(new FilePart(key, file, type));
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
+    }
+
+    public void addPart(String key, File file, String type, String customFileName) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type), customFileName));
     }
 
     public void addPart(String key, String streamName, InputStream inputStream, String type)
             throws IOException {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
+
         out.write(boundaryLine);
 
         // Headers
@@ -135,37 +141,43 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
 
         out.write(CR_LF);
         out.flush();
-        try {
-            inputStream.close();
-        } catch (final IOException e) {
-            // Not important, just log it
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
+    }
+
+    private String normalizeContentType(String type) {
+        return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + type + "\r\n";
+        String result = AsyncHttpClient.HEADER_CONTENT_TYPE + ": " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
-    private byte[] createContentDisposition(final String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key) {
+        return (
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
     }
 
-    private byte[] createContentDisposition(final String key, final String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key, String fileName) {
+        return (
+                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                        ": form-data; name=\"" + key + "\"" +
+                        "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
     }
 
-    private void updateProgress(int count) {
+    private void updateProgress(long count) {
         bytesWritten += count;
         progressHandler.sendProgressMessage(bytesWritten, totalSize);
     }
 
     private class FilePart {
-        public File file;
-        public byte[] header;
+        public final File file;
+        public final byte[] header;
+
+        public FilePart(String key, File file, String type, String customFileName) {
+            header = createHeader(key, TextUtils.isEmpty(customFileName) ? file.getName() : customFileName, type);
+            this.file = file;
+        }
 
         public FilePart(String key, File file, String type) {
             header = createHeader(key, file.getName(), type);
@@ -184,13 +196,13 @@ public FilePart(String key, File file, String type) {
                 headerStream.write(CR_LF);
             } catch (IOException e) {
                 // Can't happen on ByteArrayOutputStream
-                Log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
+                AsyncHttpClient.log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
             }
             return headerStream.toByteArray();
         }
 
         public long getTotalLength() {
-            long streamLength = file.length();
+            long streamLength = file.length() + CR_LF.length;
             return header.length + streamLength;
         }
 
@@ -200,20 +212,15 @@ public void writeTo(OutputStream out) throws IOException {
 
             FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
-            int l;
-            while ((l = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-                updateProgress(l);
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
             }
             out.write(CR_LF);
             updateProgress(CR_LF.length);
             out.flush();
-            try {
-                inputStream.close();
-            } catch (final IOException e) {
-                // Not important, just log it
-                Log.w(LOG_TAG, "Cannot close input stream", e);
-            }
+            AsyncHttpClient.silentCloseInputStream(inputStream);
         }
     }
 
@@ -235,7 +242,9 @@ public long getContentLength() {
 
     @Override
     public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+        return new BasicHeader(
+                AsyncHttpClient.HEADER_CONTENT_TYPE,
+                "multipart/form-data; boundary=" + boundary);
     }
 
     @Override
@@ -289,4 +298,4 @@ public InputStream getContent() throws IOException, UnsupportedOperationExceptio
         throw new UnsupportedOperationException(
                 "getContent() is not supported. Use writeTo() instead.");
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
old mode 100644
new mode 100755
index 22466edd..6d969134
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -1,3 +1,20 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -7,6 +24,12 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
 
+/**
+ * Processes http requests in synchronous mode, so your caller thread will be blocked on each
+ * request
+ *
+ * @see com.loopj.android.http.AsyncHttpClient
+ */
 public class SyncHttpClient extends AsyncHttpClient {
 
     /**
@@ -61,7 +84,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
                                         String contentType, ResponseHandlerInterface responseHandler,
                                         Context context) {
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            uriRequest.addHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, contentType);
         }
 
         responseHandler.setUseSynchronousMode(true);
@@ -69,7 +92,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
 		/*
          * will execute the request directly
 		*/
-        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+        newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context).run();
 
         // Return a Request Handle that cannot be used to cancel the request
         // because it is already complete by the time this returns
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
old mode 100644
new mode 100755
index bf93d843..709123ff
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -1,6 +1,22 @@
-package com.loopj.android.http;
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
 
-import android.util.Log;
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
 
 import org.apache.http.Header;
 
@@ -8,13 +24,13 @@
 
 /**
  * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
- * {@link #onSuccess(String)} method is designed to be anonymously overridden with your own response
- * handling code. <p>&nbsp;</p> Additionally, you can override the {@link #onFailure(String,
- * Throwable)}, {@link #onStart()}, and {@link #onFinish()} methods as required. <p>&nbsp;</p> For
- * example: <p>&nbsp;</p>
+ * {@link #onSuccess(int, org.apache.http.Header[], String)} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], String, Throwable)}, {@link #onStart()}, and
+ * {@link #onFinish()} methods as required. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new TextHttpResponseHandler() {
+ * client.get("https://www.google.com", new TextHttpResponseHandler() {
  *     &#064;Override
  *     public void onStart() {
  *         // Initiated the request
@@ -37,79 +53,73 @@
  * });
  * </pre>
  */
-public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
-    private static final String LOG_TAG = "TextHttpResponseHandler";
+public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private static final String LOG_TAG = "TextHttpRH";
 
     /**
-     * Creates a new TextHttpResponseHandler
+     * Creates new instance with default UTF-8 encoding
      */
-
     public TextHttpResponseHandler() {
         this(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates new instance with given string encoding
+     *
+     * @param encoding String encoding, see {@link #setCharset(String)}
+     */
     public TextHttpResponseHandler(String encoding) {
         super();
         setCharset(encoding);
     }
 
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Called when request fails
      *
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     * @param throwable      throwable returned when processing request
      */
-    public void onFailure(String responseBody, Throwable error) {
-    }
+    public abstract void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable);
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Called when request succeeds
      *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
      */
-    public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
-        onFailure(responseBody, error);
-    }
+    public abstract void onSuccess(int statusCode, Header[] headers, String responseString);
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the body of the HTTP response from the server
-     */
     @Override
-    public void onSuccess(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, responseBody);
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getResponseString(responseBytes, getCharset()));
     }
 
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
-            onFailure(0, headers, (String) null, e);
-        }
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, getResponseString(responseBytes, getCharset()), throwable);
     }
 
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+    /**
+     * Attempts to encode response bytes as string of set encoding
+     *
+     * @param charset     charset to create string with
+     * @param stringBytes response bytes
+     * @return String of set encoding or null
+     */
+    public static String getResponseString(byte[] stringBytes, String charset) {
         try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, response, error);
+            String toReturn = (stringBytes == null) ? null : new String(stringBytes, charset);
+            if (toReturn != null && toReturn.startsWith(UTF8_BOM)) {
+                return toReturn.substring(1);
+            }
+            return toReturn;
         } catch (UnsupportedEncodingException e) {
-            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
-            onFailure(0, headers, (String) null, e);
+            AsyncHttpClient.log.e(LOG_TAG, "Encoding response into string failed", e);
+            return null;
         }
     }
-
 }
diff --git a/library/src/main/java/com/loopj/android/http/Utils.java b/library/src/main/java/com/loopj/android/http/Utils.java
new file mode 100644
index 00000000..d8311e99
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Utils.java
@@ -0,0 +1,56 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+/**
+ * Provides general assert utils, which are stripped by Android SDK on
+ * compile/runtime, to work on release builds
+ */
+class Utils {
+
+    private Utils() {
+    }
+
+    /**
+     * Will throw AssertionError, if expression is not true
+     *
+     * @param expression    result of your asserted condition
+     * @param failedMessage message to be included in error log
+     * @throws java.lang.AssertionError
+     */
+    public static void asserts(final boolean expression, final String failedMessage) {
+        if (!expression) {
+            throw new AssertionError(failedMessage);
+        }
+    }
+
+    /**
+     * Will throw IllegalArgumentException if provided object is null on runtime
+     *
+     * @param argument object that should be asserted as not null
+     * @param name     name of the object asserted
+     * @throws java.lang.IllegalArgumentException
+     */
+    public static <T> T notNull(final T argument, final String name) {
+        if (argument == null) {
+            throw new IllegalArgumentException(name + " should not be null!");
+        }
+        return argument;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/package-info.java b/library/src/main/java/com/loopj/android/http/package-info.java
new file mode 100644
index 00000000..7d6224e1
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
\ No newline at end of file
diff --git a/maven_push.gradle b/maven_push.gradle
old mode 100644
new mode 100755
index 6fc6fb30..b56473b2
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -1,33 +1,42 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 apply plugin: 'maven'
 apply plugin: 'signing'
 
-configurations {
-    archives {
-        extendsFrom configurations.default
-    }
+def isReleaseBuild() {
+    return VERSION_NAME.contains("SNAPSHOT") == false
 }
 
-def sonatypeRepositoryUrl
-if (isReleaseBuild()) {
-    println 'RELEASE BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-} else {
-    println 'DEBUG BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+def getReleaseRepositoryUrl() {
+    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
 }
 
-if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
-    if (System.console())
-        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
-    else
-        ext.set('signing.password', 'dummy')
+def getSnapshotRepositoryUrl() {
+    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : "https://oss.sonatype.org/content/repositories/snapshots/"
 }
 
-if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
-    if (System.console())
-        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
-    else
-    	ext.set('nexusPassword', 'dummy')
+def getRepositoryUsername() {
+    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+}
+
+def getRepositoryPassword() {
+    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -36,10 +45,15 @@ afterEvaluate { project ->
             mavenDeployer {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
+                pom.groupId = GROUP
                 pom.artifactId = POM_ARTIFACT_ID
+                pom.version = VERSION_NAME
 
-                repository(url: sonatypeRepositoryUrl) {
-                    authentication(userName: nexusUsername, password: nexusPassword)
+                repository(url: getReleaseRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+                snapshotRepository(url: getSnapshotRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
                 pom.project {
@@ -64,12 +78,8 @@ afterEvaluate { project ->
 
                     developers {
                         developer {
-                            id "loopj"
-                            name "James Smith"
-                        }
-                        developer {
-                            id "smarek"
-                            name "Marek Sebera"
+                            id POM_DEVELOPER_ID
+                            name POM_DEVELOPER_NAME
                         }
                     }
                 }
@@ -77,23 +87,41 @@ afterEvaluate { project ->
         }
     }
 
+    task installArchives(type: Upload) {
+        description "Installs the artifacts to the local Maven repository."
+        configuration = configurations['archives']
+        repositories {
+            mavenDeployer {
+                pom.groupId = GROUP
+                pom.artifactId = POM_ARTIFACT_ID
+                pom.version = VERSION_NAME
+
+                repository url: "file://${System.properties['user.home']}/.m2/repository"
+            }
+        }
+    }
+
     signing {
         required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
         sign configurations.archives
     }
 
-    task androidJavadocsJar(type: Jar, dependsOn: generateReleaseJavadoc) {
+    task androidJavadocs(type: Javadoc) {
+        source = android.sourceSets.main.java.srcDirs
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
-        from generateReleaseJavadoc.destinationDir
+        from androidJavadocs.destinationDir
     }
 
     task androidSourcesJar(type: Jar) {
         classifier = 'sources'
-        from android.sourceSets.main.allSource
+        from android.sourceSets.main.java.srcDirs
     }
 
     artifacts {
-        archives androidReleaseJar
         archives androidSourcesJar
         archives androidJavadocsJar
     }
diff --git a/releases/android-async-http-1.4.5.jar b/releases/android-async-http-1.4.5.jar
new file mode 100644
index 00000000..d383f60e
Binary files /dev/null and b/releases/android-async-http-1.4.5.jar differ
diff --git a/releases/android-async-http-1.4.6.jar b/releases/android-async-http-1.4.6.jar
new file mode 100644
index 00000000..70391cb9
Binary files /dev/null and b/releases/android-async-http-1.4.6.jar differ
diff --git a/releases/android-async-http-1.4.7.jar b/releases/android-async-http-1.4.7.jar
new file mode 100644
index 00000000..d9e203e5
Binary files /dev/null and b/releases/android-async-http-1.4.7.jar differ
diff --git a/releases/android-async-http-1.4.8.jar b/releases/android-async-http-1.4.8.jar
new file mode 100644
index 00000000..74664cca
Binary files /dev/null and b/releases/android-async-http-1.4.8.jar differ
diff --git a/sample/.gitignore b/sample/.gitignore
old mode 100644
new mode 100755
diff --git a/sample/build.gradle b/sample/build.gradle
old mode 100644
new mode 100755
index d388761d..9ddfff4f
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -1,12 +1,4 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:0.6.+'
-    }
-}
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 repositories {
     mavenCentral()
@@ -16,16 +8,46 @@ repositories {
 }
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion "18.0.1"
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
         minSdkVersion 3
-        targetSdkVersion 18
+        targetSdkVersion 22
+    }
+
+    productFlavors {
+        standard {
+        }
+        withLeakCanary {
+            minSdkVersion 8
+            targetSdkVersion 22
+        }
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    lintOptions {
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
+        disable 'OldTargetApi', 'UnusedAttribute', 'LongLogTag'
+    }
+
+    packagingOptions {
+        exclude 'META-INF/DEPENDENCIES'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/NOTICE'
     }
 }
 
 dependencies {
-    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.5.3'
     compile project(':library')
+    // LeakCanary
+    withLeakCanaryCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
index 3e0a2fa8..e6fee30c
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,32 +1,61 @@
 <?xml version="1.0" encoding="utf-8"?>
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http.sample"
-    android:versionCode="1"
-    android:versionName="1.0">
-
-    <uses-permission android:name="android.permission.INTERNET"/>
+    android:versionCode="5"
+    android:versionName="1.4.9-SNAPSHOT">
 
-    <uses-sdk
-        android:minSdkVersion="3"
-        android:targetSdkVersion="18" />
+    <uses-permission android:name="android.permission.INTERNET" />
 
     <application
+        android:name=".SampleApplication"
+        android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
+
         <activity android:name=".WaypointsActivity">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+
         <activity android:name=".GetSample" />
         <activity android:name=".PostSample" />
         <activity android:name=".DeleteSample" />
         <activity android:name=".PutSample" />
+        <activity android:name=".PatchSample" />
         <activity android:name=".JsonSample" />
+        <activity android:name=".JsonStreamerSample" />
         <activity android:name=".FileSample" />
+        <activity android:name=".DirectorySample" />
         <activity android:name=".BinarySample" />
+        <activity android:name=".GzipSample" />
+        <activity android:name=".Redirect302Sample" />
+        <activity android:name=".ThreadingTimeoutSample" />
+        <activity android:name=".CancelAllRequestsSample" />
+        <activity android:name=".CancelRequestByTagSample" />
+        <activity android:name=".CancelRequestHandleSample" />
+        <activity android:name=".SynchronousClientSample" />
+        <activity android:name=".IntentServiceSample" />
+        <activity android:name=".SaxSample" />
+        <activity android:name=".FilesSample" />
+        <activity android:name=".PersistentCookiesSample" />
+        <activity android:name=".CustomCASample" />
+        <activity android:name=".RetryRequestSample" />
+        <activity android:name=".RangeResponseSample" />
+        <activity android:name=".Http401AuthSample" />
+        <activity android:name=".AsyncBackgroundThreadSample" />
+        <activity android:name=".ContentTypeForHttpEntitySample" />
+        <activity android:name=".ResumeDownloadSample" />
+        <activity android:name=".PrePostProcessingSample" />
+        <activity android:name=".DigestAuthSample" />
+        <activity android:name=".UsePoolThreadSample" />
+        <activity android:name=".RequestParamsDebug" />
+
+        <service android:name=".services.ExampleIntentService" />
+
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
new file mode 100755
index 00000000..9ba4d9dd
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/AsyncBackgroundThreadSample.java
@@ -0,0 +1,153 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.Activity;
+import android.os.Looper;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+
+public class AsyncBackgroundThreadSample extends SampleParentActivity {
+    private static final String LOG_TAG = "AsyncBackgroundThreadSample";
+
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
+
+    @Override
+    public void onStop()
+    {
+        super.onStop();
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+
+        final Activity ctx = this;
+        FutureTask<RequestHandle> future = new FutureTask<>(new Callable<RequestHandle>() {
+            public RequestHandle call() {
+                Log.d(LOG_TAG, "Executing GET request on background thread");
+                return client.get(ctx, URL, headers, null, responseHandler);
+            }
+        });
+
+        executor.execute(future);
+
+        RequestHandle handle = null;
+        try {
+            handle = future.get(5, TimeUnit.SECONDS);
+            Log.d(LOG_TAG, "Background thread for GET request has finished");
+        } catch (Exception e) {
+            Toast.makeText(ctx, e.getMessage(), Toast.LENGTH_LONG).show();
+            e.printStackTrace();
+        }
+
+        return handle;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_async_background_thread;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/get";
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+
+        FutureTask<ResponseHandlerInterface> future = new FutureTask<>(new Callable<ResponseHandlerInterface>() {
+
+            @Override
+            public ResponseHandlerInterface call() throws Exception {
+                Log.d(LOG_TAG, "Creating AsyncHttpResponseHandler on background thread");
+                return new AsyncHttpResponseHandler(Looper.getMainLooper()) {
+
+                    @Override
+                    public void onStart() {
+                        clearOutputs();
+                    }
+
+                    @Override
+                    public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                        Log.d(LOG_TAG, String.format("onSuccess executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+
+                    @Override
+                    public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                        Log.d(LOG_TAG, String.format("onFailure executing on main thread : %B", Looper.myLooper() == Looper.getMainLooper()));
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+
+                    @Override
+                    public void onRetry(int retryNo) {
+                        Toast.makeText(AsyncBackgroundThreadSample.this,
+                                String.format("Request is retried, retry no. %d", retryNo),
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                };
+            }
+        });
+
+        executor.execute(future);
+
+        ResponseHandlerInterface responseHandler = null;
+        try {
+            responseHandler = future.get();
+            Log.d(LOG_TAG, "Background thread for AsyncHttpResponseHandler has finished");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return responseHandler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
old mode 100644
new mode 100755
index e134a1b6..7123b7fe
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -1,8 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,27 +30,27 @@
     private static final String LOG_TAG = "BinarySample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_binary_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
-        return "http://httpbin.org/gzip";
+    public String getDefaultURL() {
+        return "https://httpbin.org/gzip";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BinaryHttpResponseHandler() {
             @Override
             public void onStart() {
@@ -63,7 +82,7 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
new file mode 100644
index 00000000..ac69e69a
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -0,0 +1,32 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+public class CancelAllRequestsSample extends ThreadingTimeoutSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_all;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        getAsyncHttpClient().cancelAllRequests(true);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestByTagSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestByTagSample.java
new file mode 100644
index 00000000..25ee6bd0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestByTagSample.java
@@ -0,0 +1,84 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class CancelRequestByTagSample extends ThreadingTimeoutSample {
+
+    private static final String LOG_TAG = "CancelRequestByTagSample";
+    private static final Integer REQUEST_TAG = 132435;
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_tag;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        Log.d(LOG_TAG, "Canceling requests by TAG: " + REQUEST_TAG);
+        getAsyncHttpClient().cancelRequestsByTAG(REQUEST_TAG, false);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            private final int id = counter++;
+
+            @Override
+            public void onStart() {
+                setStatus(id, "TAG:" + getTag() + ", START");
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                setStatus(id, "SUCCESS");
+            }
+
+            @Override
+            public void onFinish() {
+                setStatus(id, "FINISH");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                setStatus(id, "FAILURE");
+            }
+
+            @Override
+            public void onCancel() {
+                setStatus(id, "CANCEL");
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler).setTag(REQUEST_TAG);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
new file mode 100644
index 00000000..5266a50e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -0,0 +1,48 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.RequestHandle;
+
+public class CancelRequestHandleSample extends ThreadingTimeoutSample {
+
+    private static final String LOG_TAG = "CancelRequestHandleSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_handle;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        Log.d(LOG_TAG, String.format("Number of handles found: %d", getRequestHandles().size()));
+        int counter = 0;
+        for (RequestHandle handle : getRequestHandles()) {
+            if (!handle.isCancelled() && !handle.isFinished()) {
+                Log.d(LOG_TAG, String.format("Cancelling handle %d", counter));
+                Log.d(LOG_TAG, String.format("Handle %d cancel", counter) + (handle.cancel(true) ? " succeeded" : " failed"));
+            } else {
+                Log.d(LOG_TAG, String.format("Handle %d already non-cancellable", counter));
+            }
+            counter++;
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ContentTypeForHttpEntitySample.java b/sample/src/main/java/com/loopj/android/http/sample/ContentTypeForHttpEntitySample.java
new file mode 100644
index 00000000..111b91be
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ContentTypeForHttpEntitySample.java
@@ -0,0 +1,72 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.TextHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.IOException;
+
+public class ContentTypeForHttpEntitySample extends SampleParentActivity {
+    private static final String LOG_TAG = "ContentTypeForHttpEntitySample";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new TextHttpResponseHandler() {
+            @Override
+            public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, responseString);
+                debugThrowable(LOG_TAG, throwable);
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String responseString) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, responseString);
+            }
+        };
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/post";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_content_type_http_entity;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        RequestParams rParams = new RequestParams();
+        rParams.put("sample_key", "Sample String");
+        try {
+            File sample_file = File.createTempFile("temp_", "_handled", getCacheDir());
+            rParams.put("sample_file", sample_file);
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot add sample file", e);
+        }
+        return client.post(this, URL, headers, rParams, "multipart/form-data", responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
new file mode 100644
index 00000000..83ef5c8f
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
@@ -0,0 +1,202 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.util.Log;
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+import com.loopj.android.http.sample.util.SecureSocketFactory;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+
+/**
+ * This sample demonstrates the implementation of self-signed CA's and connection to servers with
+ * such certificates. Be sure to read 'res/raw/custom_ca.txt' for how-to instructions on how to
+ * generate a BKS file necessary for this sample.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class CustomCASample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "CustomCASample";
+
+    // This is A TEST URL for use with AsyncHttpClient LIBRARY ONLY!
+    // It is provided courtesy of Fineswap (https://fineswap.com) and must never
+    // be used in ANY program except when running this sample (CustomCASample).
+    private static final String SERVER_TEST_URL = "https://api.fineswap.io/ahc";
+
+    // The certificate's alias.
+    private static final String STORE_ALIAS = "rootca";
+
+    // The certificate's password.
+    private static final String STORE_PASS = "Fineswap";
+
+    // Instruct the library to retry connection when this exception is raised.
+    static {
+        AsyncHttpClient.allowRetryExceptionClass(javax.net.ssl.SSLException.class);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            InputStream is = null;
+            try {
+                // Configure the library to use a custom 'bks' file to perform
+                // SSL negotiation.
+                KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());
+                is = getResources().openRawResource(R.raw.store);
+                store.load(is, STORE_PASS.toCharArray());
+                getAsyncHttpClient().setSSLSocketFactory(new SecureSocketFactory(store, STORE_ALIAS));
+            } catch (IOException e) {
+                throw new KeyStoreException(e);
+            } catch (CertificateException e) {
+                throw new KeyStoreException(e);
+            } catch (NoSuchAlgorithmException e) {
+                throw new KeyStoreException(e);
+            } catch (KeyManagementException e) {
+                throw new KeyStoreException(e);
+            } catch (UnrecoverableKeyException e) {
+                throw new KeyStoreException(e);
+            } finally {
+                AsyncHttpClient.silentCloseInputStream(is);
+            }
+        } catch (KeyStoreException e) {
+            Log.e(LOG_TAG, "Unable to initialize key store", e);
+            showCustomCAHelp();
+        }
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_custom_ca;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return SERVER_TEST_URL;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    /**
+     * Returns contents of `custom_ca.txt` file from assets as CharSequence.
+     *
+     * @return contents of custom_ca.txt file
+     */
+    private CharSequence getReadmeText() {
+        String rtn = "";
+        try {
+            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
+            java.util.Scanner s = new java.util.Scanner(stream)
+                    .useDelimiter("\\A");
+            rtn = s.hasNext() ? s.next() : "";
+        } catch (Resources.NotFoundException e) {
+            Log.e(LOG_TAG, "License couldn't be retrieved", e);
+        }
+        return rtn;
+    }
+
+    /**
+     * Displays a dialog showing contents of `custom_ca.txt` file from assets.
+     * This is needed to avoid Lint's strict mode.
+     */
+    private void showCustomCAHelp() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.title_custom_ca);
+        builder.setMessage(getReadmeText());
+        builder.setNeutralButton(android.R.string.cancel,
+            new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    dialog.dismiss();
+                }
+            }
+        );
+        builder.show();
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
old mode 100644
new mode 100755
index 42104356..97d652bf
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,33 +30,33 @@
     private static final String LOG_TAG = "DeleteSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.delete(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.delete(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_delete_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
-        return "http://httpbin.org/delete";
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/delete";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DigestAuthSample.java b/sample/src/main/java/com/loopj/android/http/sample/DigestAuthSample.java
new file mode 100644
index 00000000..14fa5a7f
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/DigestAuthSample.java
@@ -0,0 +1,75 @@
+package com.loopj.android.http.sample;
+
+import android.net.Uri;
+import android.os.Bundle;
+import android.widget.EditText;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+
+public class DigestAuthSample extends GetSample {
+
+    private EditText usernameField, passwordField;
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/digest-auth/auth/user/passwd2";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_digest_auth;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        usernameField = new EditText(this);
+        passwordField = new EditText(this);
+        usernameField.setHint("Username");
+        passwordField.setHint("Password");
+        usernameField.setText("user");
+        passwordField.setText("passwd2");
+        customFieldsLayout.addView(usernameField);
+        customFieldsLayout.addView(passwordField);
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        setCredentials(client, URL);
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public boolean isCancelButtonAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    private void setCredentials(AsyncHttpClient client, String URL) {
+        Uri parsed = Uri.parse(URL);
+        client.clearCredentialsProvider();
+        client.setCredentials(
+                new AuthScope(parsed.getHost(), parsed.getPort() == -1 ? 80 : parsed.getPort()),
+                new UsernamePasswordCredentials(
+                        usernameField.getText().toString(),
+                        passwordField.getText().toString()
+                )
+        );
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DirectorySample.java b/sample/src/main/java/com/loopj/android/http/sample/DirectorySample.java
new file mode 100755
index 00000000..56bce894
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/DirectorySample.java
@@ -0,0 +1,134 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+import android.widget.CheckBox;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.FileUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+
+public class DirectorySample extends SampleParentActivity {
+    private static final String LOG_TAG = "DirectorySample";
+    private FileAsyncHttpResponseHandler lastResponseHandler = null;
+    private CheckBox cbAppend, cbRename;
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_directory_sample;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/robots.txt";
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Button deleteTargetFile = new Button(this);
+        deleteTargetFile.setText(R.string.button_delete_target_file);
+        deleteTargetFile.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                clearOutputs();
+                if (lastResponseHandler != null) {
+                    File toBeDeleted = lastResponseHandler.getTargetFile();
+                    debugResponse(LOG_TAG, String.format("File was deleted? %b", toBeDeleted.delete()));
+                    debugResponse(LOG_TAG, String.format("Delete file path: %s", toBeDeleted.getAbsolutePath()));
+                } else {
+                    debugThrowable(LOG_TAG, new Error("You have to Run example first"));
+                }
+            }
+        });
+        cbAppend = new CheckBox(this);
+        cbAppend.setText("Constructor \"append\" is true?");
+        cbAppend.setChecked(false);
+        cbRename = new CheckBox(this);
+        cbRename.setText("Constructor \"renameTargetFileIfExists\" is true?");
+        cbRename.setChecked(true);
+        customFieldsLayout.addView(deleteTargetFile);
+        customFieldsLayout.addView(cbAppend);
+        customFieldsLayout.addView(cbRename);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        lastResponseHandler = new FileAsyncHttpResponseHandler(getCacheDir(), cbAppend.isChecked(), cbRename.isChecked()) {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugFile(response);
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                debugFile(file);
+            }
+
+            private void debugFile(File file) {
+                if (file == null || !file.exists()) {
+                    debugResponse(LOG_TAG, "Response is null");
+                    return;
+                }
+                try {
+                    debugResponse(LOG_TAG, file.getAbsolutePath() + "\r\n\r\n" + FileUtil.getStringFromFile(file));
+                } catch (Throwable t) {
+                    Log.e(LOG_TAG, "Cannot debug file contents", t);
+                }
+            }
+        };
+        return lastResponseHandler;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
old mode 100644
new mode 100755
index 46912aaa..957cc9fe
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -1,10 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.FileUtil;
 
 import org.apache.http.Header;
@@ -16,27 +35,27 @@
     private static final String LOG_TAG = "FileSample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_file_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/robots.txt";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new FileAsyncHttpResponseHandler(this) {
             @Override
             public void onStart() {
@@ -44,18 +63,18 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, File file) {
+            public void onSuccess(int statusCode, Header[] headers, File response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugFile(getTargetFile());
+                debugFile(response);
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                debugFile(getTargetFile());
+                debugThrowable(LOG_TAG, throwable);
+                debugFile(file);
             }
 
             private void debugFile(File file) {
@@ -68,7 +87,7 @@ private void debugFile(File file) {
                 } catch (Throwable t) {
                     Log.e(LOG_TAG, "Cannot debug file contents", t);
                 }
-                if (!file.delete()) {
+                if (!deleteTargetFile()) {
                     Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
                 }
             }
@@ -76,7 +95,7 @@ private void debugFile(File file) {
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
new file mode 100644
index 00000000..1167aa4f
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
@@ -0,0 +1,67 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.util.Random;
+
+public class FilesSample extends PostSample {
+
+    public static final String LOG_TAG = "FilesSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_post_files;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        try {
+            RequestParams params = new RequestParams();
+            final String contentType = RequestParams.APPLICATION_OCTET_STREAM;
+            params.put("fileOne", createTempFile("fileOne", 1020), contentType, "fileOne");
+            params.put("fileTwo", createTempFile("fileTwo", 1030), contentType);
+            params.put("fileThree", createTempFile("fileThree", 1040), contentType, "customFileThree");
+            params.put("fileFour", createTempFile("fileFour", 1050), contentType);
+            params.put("fileFive", createTempFile("fileFive", 1060), contentType, "testingFileFive");
+            params.setHttpEntityIsRepeatable(true);
+            params.setUseJsonStreamer(false);
+            return client.post(this, URL, params, responseHandler);
+        } catch (FileNotFoundException fnfException) {
+            Log.e(LOG_TAG, "executeSample failed with FileNotFoundException", fnfException);
+        }
+        return null;
+    }
+
+    public File createTempFile(String namePart, int byteSize) {
+        try {
+            File f = File.createTempFile(namePart, "_handled", getCacheDir());
+            FileOutputStream fos = new FileOutputStream(f);
+            Random r = new Random();
+            byte[] buffer = new byte[byteSize];
+            r.nextBytes(buffer);
+            fos.write(buffer);
+            fos.flush();
+            fos.close();
+            return f;
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "createTempFile failed", t);
+        }
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
old mode 100644
new mode 100755
index 96ab3e64..6b13f5a9
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,7 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
+import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +32,32 @@
     private static final String LOG_TAG = "GetSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_get_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/get";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -59,6 +81,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
                     debugResponse(LOG_TAG, new String(errorResponse));
                 }
             }
+
+            @Override
+            public void onRetry(int retryNo) {
+                Toast.makeText(GetSample.this,
+                        String.format("Request is retried, retry no. %d", retryNo),
+                        Toast.LENGTH_SHORT)
+                        .show();
+            }
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
new file mode 100644
index 00000000..9025a300
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -0,0 +1,32 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+public class GzipSample extends JsonSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_gzip_sample;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/gzip";
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java b/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java
new file mode 100644
index 00000000..c8bf4d3d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Http401AuthSample.java
@@ -0,0 +1,228 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.Base64;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * This sample demonstrates how to implement HTTP 401 Basic Authentication.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class Http401AuthSample extends GetSample {
+
+    private static final String LOG_TAG = "Http401AuthSample";
+    private static final String HEADER_WWW_AUTHENTICATE = "WWW-Authenticate";
+    private static final String HEADER_AUTHORIZATION = "Authorization";
+    private static final String HEADER_REALM_PREFIX = "realm=";
+    private static final String HEADER_BASIC = "basic";
+
+    private static final String SECRET_USERNAME = "ahc";
+    private static final String SECRET_PASSWORD = "LetMeIn";
+
+    private String userName;
+    private String passWord;
+
+    public void retryRequest() {
+        // File is still smaller than remote file; send a new request.
+        onRunButtonPressed();
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/basic-auth/" + SECRET_USERNAME + "/" + SECRET_PASSWORD;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_401_unauth;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    @Override
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
+
+        // Add authentication header.
+        if (userName != null && passWord != null) {
+            byte[] base64bytes = Base64.encode(
+                    (userName + ":" + passWord).getBytes(),
+                    Base64.DEFAULT
+            );
+            String credentials = new String(base64bytes);
+            headers.add(new BasicHeader(HEADER_AUTHORIZATION, HEADER_BASIC + " " + credentials));
+        }
+
+        return headers.toArray(new Header[headers.size()]);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+
+                // Ask the user for credentials if required by the server.
+                if (statusCode == 401) {
+                    String realm = "Protected Page";
+                    String authType = null;
+
+                    // Cycle through the headers and look for the WWW-Authenticate header.
+                    for (Header header : headers) {
+                        String headerName = header.getName();
+                        if (HEADER_WWW_AUTHENTICATE.equalsIgnoreCase(headerName)) {
+                            String headerValue = header.getValue().trim();
+                            String headerValueLowerCase = headerValue.toLowerCase(Locale.US);
+
+                            // Get the type of auth requested.
+                            int charPos = headerValueLowerCase.indexOf(' ');
+                            if (0 < charPos) {
+                                authType = headerValueLowerCase.substring(0, charPos);
+
+                                // The second part should begin with a "realm=" prefix.
+                                if (headerValueLowerCase.substring(1 + charPos).startsWith(HEADER_REALM_PREFIX)) {
+                                    // The new realm value, including any possible wrapping quotation.
+                                    realm = headerValue.substring(1 + charPos + HEADER_REALM_PREFIX.length());
+
+                                    // If realm starts with a quote, remove surrounding quotes.
+                                    if (realm.charAt(0) == '"' || realm.charAt(0) == '\'') {
+                                        realm = realm.substring(1, realm.length() - 1);
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    // We will support basic auth in this sample.
+                    if (authType != null && HEADER_BASIC.equals(authType)) {
+                        // Show a dialog for the user and request user/pass.
+                        Log.d(LOG_TAG, HEADER_REALM_PREFIX + realm);
+
+                        // Present the dialog.
+                        postRunnable(new DialogRunnable(realm));
+                    }
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    private class DialogRunnable implements Runnable, DialogInterface.OnClickListener {
+
+        final String realm;
+        final View dialogView;
+
+        public DialogRunnable(String realm) {
+            this.realm = realm;
+            this.dialogView = LayoutInflater
+                    .from(Http401AuthSample.this)
+                    .inflate(R.layout.credentials, new LinearLayout(Http401AuthSample.this), false);
+
+            // Update the preface text with correct credentials.
+            TextView preface = (TextView) dialogView.findViewById(R.id.label_credentials);
+            String prefaceText = preface.getText().toString();
+
+            // Substitute placeholders, and re-set the value.
+            preface.setText(String.format(prefaceText, SECRET_USERNAME, SECRET_PASSWORD));
+        }
+
+        @Override
+        public void run() {
+            AlertDialog.Builder builder = new AlertDialog.Builder(Http401AuthSample.this);
+            builder.setTitle(realm);
+            builder.setView(dialogView);
+            builder.setPositiveButton(android.R.string.ok, this);
+            builder.setNegativeButton(android.R.string.cancel, this);
+            builder.show();
+        }
+
+        @Override
+        public void onClick(DialogInterface dialog, int which) {
+            switch (which) {
+                case DialogInterface.BUTTON_POSITIVE:
+                    // Dismiss the dialog.
+                    dialog.dismiss();
+
+                    // Update the username and password variables.
+                    userName = ((EditText) dialogView.findViewById(R.id.field_username)).getText().toString();
+                    passWord = ((EditText) dialogView.findViewById(R.id.field_password)).getText().toString();
+
+                    // Refetch the remote file.
+                    retryRequest();
+
+                    break;
+
+                case DialogInterface.BUTTON_NEGATIVE:
+                    // Dismiss the dialog.
+                    dialog.dismiss();
+
+                    break;
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
new file mode 100644
index 00000000..7b7dde62
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
@@ -0,0 +1,106 @@
+package com.loopj.android.http.sample;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.services.ExampleIntentService;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class IntentServiceSample extends SampleParentActivity {
+
+    public static final String LOG_TAG = "IntentServiceSample";
+    public static final String ACTION_START = "SYNC_START";
+    public static final String ACTION_RETRY = "SYNC_RETRY";
+    public static final String ACTION_CANCEL = "SYNC_CANCEL";
+    public static final String ACTION_SUCCESS = "SYNC_SUCCESS";
+    public static final String ACTION_FAILURE = "SYNC_FAILURE";
+    public static final String ACTION_FINISH = "SYNC_FINISH";
+    public static final String[] ALLOWED_ACTIONS = {ACTION_START,
+            ACTION_RETRY, ACTION_CANCEL, ACTION_SUCCESS, ACTION_FAILURE, ACTION_FINISH};
+    private final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            // switch() doesn't support strings in older JDK.
+            if(ACTION_START.equals(action)) {
+                clearOutputs();
+                addView(getColoredView(LIGHTBLUE, "Request started"));
+            } else if(ACTION_FINISH.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request finished"));
+            } else if(ACTION_CANCEL.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request cancelled"));
+            } else if(ACTION_RETRY.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request retried"));
+            } else if(ACTION_FAILURE.equals(action) || ACTION_SUCCESS.equals(action)) {
+                debugThrowable(LOG_TAG, (Throwable) intent.getSerializableExtra(ExampleIntentService.INTENT_THROWABLE));
+                if(ACTION_SUCCESS.equals(action)) {
+                    debugStatusCode(LOG_TAG, intent.getIntExtra(ExampleIntentService.INTENT_STATUS_CODE, 0));
+                    debugHeaders(LOG_TAG, IntentUtil.deserializeHeaders(intent.getStringArrayExtra(ExampleIntentService.INTENT_HEADERS)));
+                    byte[] returnedBytes = intent.getByteArrayExtra(ExampleIntentService.INTENT_DATA);
+                    if (returnedBytes != null) {
+                        debugResponse(LOG_TAG, new String(returnedBytes));
+                    }
+                }
+            }
+        }
+    };
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        IntentFilter iFilter = new IntentFilter();
+        for (String action : ALLOWED_ACTIONS) {
+            iFilter.addAction(action);
+        }
+        registerReceiver(broadcastReceiver, iFilter);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        unregisterReceiver(broadcastReceiver);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        // no response handler on activity
+        return null;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_intent_service_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        Intent serviceCall = new Intent(this, ExampleIntentService.class);
+        serviceCall.putExtra(ExampleIntentService.INTENT_URL, URL);
+        startService(serviceCall);
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
old mode 100644
new mode 100755
index 154804f8..2858e914
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -1,10 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.SampleJSON;
 
 import org.apache.http.Header;
@@ -15,32 +34,32 @@
     private static final String LOG_TAG = "JsonSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_json_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return false;
     }
 
     @Override
-    protected String getDefaultURL() {
-        return "http://httpbin.org/headers";
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/headers";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BaseJsonHttpResponseHandler<SampleJSON>() {
 
             @Override
@@ -49,28 +68,29 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, String rawResponse, SampleJSON response) {
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 if (response != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonResponse);
                 }
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable e, String rawResponse, SampleJSON errorResponse) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
+                debugThrowable(LOG_TAG, throwable);
                 if (errorResponse != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonData);
                 }
             }
 
             @Override
-            protected SampleJSON parseResponse(String responseBody) throws Throwable {
-                return new ObjectMapper().readValues(new JsonFactory().createParser(responseBody), SampleJSON.class).next();
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
             }
+
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java
new file mode 100644
index 00000000..d05cf223
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonStreamerSample.java
@@ -0,0 +1,100 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Iterator;
+
+/**
+ * This sample demonstrates how to upload JSON data using streams, resulting
+ * in a low-memory footprint even with extremely large data.
+ *
+ * Please note: You must prepare a server-side end-point to consume the uploaded
+ * data. This is because the data is uploaded using "application/json" content
+ * type and regular methods, expecting a multi-form content type, will fail to
+ * retrieve the POST'ed data.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class JsonStreamerSample extends PostSample {
+
+    private static final String LOG_TAG = "JsonStreamSample";
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        RequestParams params = new RequestParams();
+        params.setUseJsonStreamer(true);
+        JSONObject body;
+        if (isRequestBodyAllowed() && (body = getBodyTextAsJSON()) != null) {
+            try {
+                Iterator keys = body.keys();
+                Log.d(LOG_TAG, "JSON data:");
+                while (keys.hasNext()) {
+                    String key = (String) keys.next();
+                    Log.d(LOG_TAG, "  " + key + ": " + body.get(key));
+                    params.put(key, body.get(key).toString());
+                }
+            } catch (JSONException e) {
+                Log.w(LOG_TAG, "Unable to retrieve a JSON value", e);
+            }
+        }
+        return client.post(this, URL, headers, params,
+                RequestParams.APPLICATION_JSON, responseHandler);
+    }
+
+    @Override
+    public HttpEntity getRequestEntity() {
+        // Unused in this sample.
+        return null;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_json_streamer_sample;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    protected JSONObject getBodyTextAsJSON() {
+        String bodyText = getBodyText();
+        if (bodyText != null && !TextUtils.isEmpty(bodyText)) {
+            try {
+                return new JSONObject(bodyText);
+            } catch (JSONException e) {
+                Log.e(LOG_TAG, "User's data is not a valid JSON object", e);
+            }
+        }
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
new file mode 100644
index 00000000..8bd8ab1e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
@@ -0,0 +1,68 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+public class PatchSample extends SampleParentActivity {
+
+	private static final String LOG_TAG = "PatchSample";
+	 
+	@Override
+	public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+		return client.patch(this, URL, entity, null, responseHandler);
+	}
+
+	@Override
+	public int getSampleTitle() {
+		return R.string.title_patch_sample;
+	}
+
+	@Override
+	public boolean isRequestBodyAllowed() {
+		return false;
+	}
+
+	@Override
+	public boolean isRequestHeadersAllowed() {
+		return false;
+	}
+
+	@Override
+	public String getDefaultURL() {
+		return PROTOCOL + "httpbin.org/patch";
+	}
+	
+	@Override
+	public ResponseHandlerInterface getResponseHandler() {
+		return new AsyncHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+	}
+
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
new file mode 100644
index 00000000..4c7270de
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
@@ -0,0 +1,122 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.PersistentCookieStore;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.CookieStore;
+
+public class PersistentCookiesSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PersistentCookiesSample";
+
+    private CookieStore cookieStore;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        // Use the application's context so that memory leakage doesn't occur.
+        cookieStore = new PersistentCookieStore(getApplicationContext());
+
+        // Set the new cookie store.
+        getAsyncHttpClient().setCookieStore(cookieStore);
+
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_persistent_cookies;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        // The base URL for testing cookies.
+        String url = PROTOCOL + "httpbin.org/cookies";
+
+        // If the cookie store is empty, suggest a cookie.
+        if(cookieStore.getCookies().isEmpty()) {
+            url += "/set?time=" + System.currentTimeMillis();
+        }
+
+        return url;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        client.setEnableRedirects(true);
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
old mode 100644
new mode 100755
index 202fd480..234887dc
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +30,32 @@
     private static final String LOG_TAG = "PostSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.post(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_post_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
-        return "http://httpbin.org/post";
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/post";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -51,7 +71,7 @@ public void onSuccess(int statusCode, Header[] headers, byte[] response) {
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 debugThrowable(LOG_TAG, e);
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
new file mode 100644
index 00000000..2a7c5726
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PrePostProcessingSample.java
@@ -0,0 +1,145 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.util.Log;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import java.util.Locale;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public class PrePostProcessingSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PrePostProcessingSample";
+
+    protected static final int LIGHTGREY = Color.parseColor("#E0E0E0");
+    protected static final int DARKGREY = Color.parseColor("#888888");
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_pre_post_processing;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/post";
+    }
+
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new PrePostProcessRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onPreProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Pre",
+                    "Response is about to be pre-processed", LIGHTGREY);
+            }
+
+          @Override
+            public void onPostProcessResponse(ResponseHandlerInterface instance, HttpResponse response) {
+                debugProcessing(LOG_TAG, "Post",
+                    "Response is about to be post-processed", DARKGREY);
+            }
+
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+    }
+
+    protected void debugProcessing(String TAG, String state, String message, final int color) {
+        final String debugMessage = String.format(Locale.US, "%s-processing: %s", state, message);
+        Log.d(TAG, debugMessage);
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+              addView(getColoredView(color, debugMessage));
+            }
+        });
+    }
+
+    private class PrePostProcessRequest extends AsyncHttpRequest {
+
+        public PrePostProcessRequest(AbstractHttpClient client, HttpContext httpContext, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
+            super(client, httpContext, request, responseHandler);
+        }
+
+        @Override
+        public void onPreProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Pre",
+                "Request is about to be pre-processed", LIGHTGREY);
+        }
+
+        @Override
+        public void onPostProcessRequest(AsyncHttpRequest request) {
+            debugProcessing(LOG_TAG, "Post",
+                "Request is about to be post-processed", DARKGREY);
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
old mode 100644
new mode 100755
index f9e6b5dc..f93d383b
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +30,32 @@
     private static final String LOG_TAG = "PutSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.put(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.put(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_put_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
-        return "http://httpbin.org/put";
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/put";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
new file mode 100644
index 00000000..21774e59
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
@@ -0,0 +1,181 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * This sample demonstrates use of {@link RangeFileAsyncHttpResponseHandler} to
+ * download a remote file in multiple requests. While this response handler
+ * class handles file storage, it's up to the app itself to request all chunks
+ * of the file.
+ *
+ * Also demonstrated a method to query the remote file's size prior to sending
+ * the actual GET requests. This ensures that the remote server is actually
+ * capable of supporting the "Range" header, necessary to make this sample work.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RangeResponseSample extends GetSample {
+
+    public static final String LOG_TAG = "RangeResponseSample";
+
+    private static final String CONTENT_LENGTH = "Content-Length";
+    private static final String ACCEPT_RANGES = "Accept-Ranges";
+    private static final int CHUNK_SIZE = 10240;
+
+    private File file;
+    private long fileSize = -1;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            // Temporary file to host the URL's downloaded contents.
+            file = File.createTempFile("temp_", "_handled", getCacheDir());
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot create temporary file", e);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+
+        // Remove temporary file.
+        if (file != null) {
+            if (!file.delete()) {
+                Log.e(LOG_TAG, String.format("Couldn't remove temporary file in path: %s", file.getAbsolutePath()));
+            }
+            file = null;
+        }
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://upload.wikimedia.org/wikipedia/commons/f/fa/Geysers_on_Mars.jpg";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_range_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        if (fileSize > 0) {
+            // Send a GET query when we know the size of the remote file.
+            return client.get(this, URL, headers, null, responseHandler);
+        } else {
+            // Send a HEAD query to know the size of the remote file.
+            return client.head(this, URL, headers, null, responseHandler);
+        }
+    }
+
+    public void sendNextRangeRequest() {
+        if (file.length() < fileSize) {
+            // File is still smaller than remote file; send a new request.
+            onRunButtonPressed();
+        }
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new RangeFileAsyncHttpResponseHandler(file) {
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+
+                if (fileSize < 1) {
+                    boolean supportsRange = false;
+                    // Cycle through the headers and look for the Content-Length header.
+                    for (Header header : headers) {
+                        String headerName = header.getName();
+                        if (CONTENT_LENGTH.equals(headerName)) {
+                            fileSize = Long.parseLong(header.getValue());
+                        } else if (ACCEPT_RANGES.equals(headerName)) {
+                            supportsRange = true;
+                        }
+                    }
+
+                    // Is the content length known?
+                    if (!supportsRange || fileSize < 1) {
+                        Toast.makeText(
+                                RangeResponseSample.this,
+                                "Unable to determine remote file's size, or\nremote server doesn't support ranges",
+                                Toast.LENGTH_LONG
+                        ).show();
+                    }
+                }
+
+                // If remote file size is known, request next portion.
+                if (fileSize > 0) {
+                    debugFileResponse(file);
+                    // Send a new request for the same resource.
+                    sendNextRangeRequest();
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable e, File file) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                debugFileResponse(file);
+            }
+
+            @Override
+            public void updateRequestHeaders(HttpUriRequest uriRequest) {
+                // Call super so appending could work.
+                super.updateRequestHeaders(uriRequest);
+
+                // Length of the downloaded content thus far.
+                long length = file.length();
+
+                // Request the next portion of the file to be downloaded.
+                uriRequest.setHeader("Range", "bytes=" + length + "-" + (length + CHUNK_SIZE - 1));
+            }
+
+            void debugFileResponse(File file) {
+                debugResponse(LOG_TAG, "File size thus far: " + file.length() + " bytes");
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
new file mode 100644
index 00000000..3a964f35
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -0,0 +1,101 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class Redirect302Sample extends GetSample {
+
+    private boolean enableRedirects = true;
+    private boolean enableRelativeRedirects = true;
+    private boolean enableCircularRedirects = true;
+
+    private static final int MENU_ENABLE_REDIRECTS = 10;
+    private static final int MENU_ENABLE_CIRCULAR_REDIRECTS = 11;
+    private static final int MENU_ENABLE_RELATIVE_REDIRECTs = 12;
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, MENU_ENABLE_REDIRECTS, Menu.NONE, "Enable redirects").setCheckable(true);
+        menu.add(Menu.NONE, MENU_ENABLE_RELATIVE_REDIRECTs, Menu.NONE, "Enable relative redirects").setCheckable(true);
+        menu.add(Menu.NONE, MENU_ENABLE_CIRCULAR_REDIRECTS, Menu.NONE, "Enable circular redirects").setCheckable(true);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem menuItemEnableRedirects = menu.findItem(MENU_ENABLE_REDIRECTS);
+        if (menuItemEnableRedirects != null)
+            menuItemEnableRedirects.setChecked(enableRedirects);
+        MenuItem menuItemEnableRelativeRedirects = menu.findItem(MENU_ENABLE_RELATIVE_REDIRECTs);
+        if (menuItemEnableRelativeRedirects != null)
+            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
+        MenuItem menuItemEnableCircularRedirects = menu.findItem(MENU_ENABLE_CIRCULAR_REDIRECTS);
+        if (menuItemEnableCircularRedirects != null)
+            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
+        return super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.isCheckable()) {
+            item.setChecked(!item.isChecked());
+            if (item.getItemId() == MENU_ENABLE_REDIRECTS) {
+                enableRedirects = item.isChecked();
+            } else if (item.getItemId() == MENU_ENABLE_RELATIVE_REDIRECTs) {
+                enableRelativeRedirects = item.isChecked();
+            } else if (item.getItemId() == MENU_ENABLE_CIRCULAR_REDIRECTS) {
+                enableCircularRedirects = item.isChecked();
+            }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/redirect/6";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_redirect_302;
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient() {
+        AsyncHttpClient ahc = super.getAsyncHttpClient();
+        HttpClient client = ahc.getHttpClient();
+        if (client instanceof DefaultHttpClient) {
+            Toast.makeText(this,
+                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
+                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
+                    Toast.LENGTH_SHORT
+            ).show();
+            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
+        }
+        return ahc;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RequestParamsDebug.java b/sample/src/main/java/com/loopj/android/http/sample/RequestParamsDebug.java
new file mode 100644
index 00000000..3341887c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RequestParamsDebug.java
@@ -0,0 +1,160 @@
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.widget.EditText;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.TextHttpResponseHandler;
+import com.loopj.android.http.sample.util.API8Util;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class RequestParamsDebug extends SampleParentActivity {
+
+    public static final String LOG_TAG = "RequestParamsDebug";
+    private EditText customParams;
+    private static final String DEMO_RP_CONTENT = "array=java\n" +
+            "array=C\n" +
+            "list=blue\n" +
+            "list=yellow\n" +
+            "set=music\n" +
+            "set=art\n" +
+            "map=first_name\n" +
+            "map=last_name\n";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new TextHttpResponseHandler() {
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugResponse(LOG_TAG, responseString);
+                debugThrowable(LOG_TAG, throwable);
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String responseString) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugResponse(LOG_TAG, responseString);
+            }
+        };
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        customParams = new EditText(this);
+        customParams.setLines(8);
+        customParams.setText(DEMO_RP_CONTENT);
+        customFieldsLayout.addView(customParams);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/get";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_request_params_debug;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return getAsyncHttpClient().get(this, getDefaultURL(), getRequestParams(), getResponseHandler());
+    }
+
+    // TODO: allow parsing multiple values for each type, maybe like "type.key=value" ?
+    private RequestParams getRequestParams() {
+        RequestParams rp = new RequestParams();
+        // contents of customParams custom field view
+        String customParamsText = customParams.getText().toString();
+        String[] pairs = customParamsText.split("\n");
+        // temp content holders
+        Map<String, Map<String, String>> mapOfMaps = new HashMap<>();
+        Map<String, List<String>> mapOfLists = new HashMap<>();
+        Map<String, String[]> mapOfArrays = new HashMap<>();
+        Map<String, Set<String>> mapOfSets = new HashMap<>();
+        for (String pair : pairs) {
+            String[] kv = pair.split("=");
+            if (kv.length != 2)
+                continue;
+            String key = kv[0].trim();
+            String value = kv[1].trim();
+            if ("array".equals(key)) {
+                String[] values = mapOfArrays.get(key);
+                if (values == null) {
+                    values = new String[]{value};
+                } else {
+                    values = API8Util.copyOfRange(values, 0, values.length + 1);
+                    values[values.length - 1] = value;
+                }
+                mapOfArrays.put(key, values);
+            } else if ("list".equals(key)) {
+                List<String> values = mapOfLists.get(key);
+                if (values == null) {
+                    values = new ArrayList<>();
+                }
+                values.add(value);
+                mapOfLists.put(key, values);
+            } else if ("set".equals(key)) {
+                Set<String> values = mapOfSets.get(key);
+                if (values == null) {
+                    values = new HashSet<>();
+                }
+                values.add(value);
+                mapOfSets.put(key, values);
+            } else if ("map".equals(key)) {
+                Map<String, String> values = mapOfMaps.get(key);
+                if (values == null) {
+                    values = new HashMap<>();
+                }
+                values.put(key + values.size(), value);
+                mapOfMaps.put(key, values);
+            }
+        }
+        // fill in string list
+        for (Map.Entry<String, List<String>> entry : mapOfLists.entrySet()) {
+            rp.put(entry.getKey(), entry.getValue());
+        }
+        // fill in string array
+        for (Map.Entry<String, String[]> entry : mapOfArrays.entrySet()) {
+            rp.put(entry.getKey(), entry.getValue());
+        }
+        // fill in string set
+        for (Map.Entry<String, Set<String>> entry : mapOfSets.entrySet()) {
+            rp.put(entry.getKey(), entry.getValue());
+        }
+        // fill in string map
+        for (Map.Entry<String, Map<String, String>> entry : mapOfMaps.entrySet()) {
+            rp.put(entry.getKey(), entry.getValue());
+        }
+        // debug final URL construction into UI
+        debugResponse(LOG_TAG, rp.toString());
+        return rp;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ResumeDownloadSample.java b/sample/src/main/java/com/loopj/android/http/sample/ResumeDownloadSample.java
new file mode 100644
index 00000000..f7d332a9
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ResumeDownloadSample.java
@@ -0,0 +1,85 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.IOException;
+
+public class ResumeDownloadSample extends SampleParentActivity {
+
+    private File downloadTarget;
+    private static final String LOG_TAG = "ResumeDownloadSample";
+
+    private File getDownloadTarget() {
+        try {
+            if (downloadTarget == null) {
+                downloadTarget = File.createTempFile("download_", "_resume", getCacheDir());
+            }
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Couldn't create cache file to download to");
+        }
+        return downloadTarget;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new RangeFileAsyncHttpResponseHandler(getDownloadTarget()) {
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugThrowable(LOG_TAG, throwable);
+                if (file != null) {
+                    addView(getColoredView(LIGHTGREEN, "Download interrupted (" + statusCode + "): (bytes=" + file.length() + "), path: " + file.getAbsolutePath()));
+                }
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, File file) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                if (file != null) {
+                    addView(getColoredView(LIGHTGREEN, "Request succeeded (" + statusCode + "): (bytes=" + file.length() + "), path: " + file.getAbsolutePath()));
+                }
+            }
+        };
+    }
+
+    @Override
+    public String getDefaultHeaders() {
+        return "Range=bytes=10-20";
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "www.google.com/images/srpr/logo11w.png";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_resume_download;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
new file mode 100644
index 00000000..8add61ca
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/RetryRequestSample.java
@@ -0,0 +1,84 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
+import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.ConnectionPoolTimeoutException;
+
+/**
+ * This sample demonstrates use of
+ * {@link AsyncHttpClient#allowRetryExceptionClass(java.lang.Class)} and
+ * {@link AsyncHttpClient#blockRetryExceptionClass(java.lang.Class)} to whitelist
+ * and blacklist certain Exceptions, respectively.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class RetryRequestSample extends GetSample {
+
+    private static boolean wasToastShown;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // The following exceptions will be whitelisted, i.e.: When an exception
+        // of this type is raised, the request will be retried.
+        AsyncHttpClient.allowRetryExceptionClass(IOException.class);
+        AsyncHttpClient.allowRetryExceptionClass(SocketTimeoutException.class);
+        AsyncHttpClient.allowRetryExceptionClass(ConnectTimeoutException.class);
+
+        // The following exceptions will be blacklisted, i.e.: When an exception
+        // of this type is raised, the request will not be retried and it will
+        // fail immediately.
+        AsyncHttpClient.blockRetryExceptionClass(UnknownHostException.class);
+        AsyncHttpClient.blockRetryExceptionClass(ConnectionPoolTimeoutException.class);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        if(!wasToastShown) {
+            wasToastShown = true;
+            Toast.makeText(
+                this,
+                "Exceptions' whitelist and blacklist updated\nSee RetryRequestSample.java for details",
+                Toast.LENGTH_LONG
+            ).show();
+        }
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/ip";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_retry_handler;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
new file mode 100644
index 00000000..18cbca1e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -0,0 +1,70 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.content.Context;
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpRequest;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.List;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public interface SampleInterface {
+
+    List<RequestHandle> getRequestHandles();
+
+    void addRequestHandle(RequestHandle handle);
+
+    void onRunButtonPressed();
+
+    void onCancelButtonPressed();
+
+    Header[] getRequestHeaders();
+
+    HttpEntity getRequestEntity();
+
+    AsyncHttpClient getAsyncHttpClient();
+
+    void setAsyncHttpClient(AsyncHttpClient client);
+
+    AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context);
+
+    ResponseHandlerInterface getResponseHandler();
+
+    String getDefaultURL();
+
+    String getDefaultHeaders();
+
+    boolean isRequestHeadersAllowed();
+
+    boolean isRequestBodyAllowed();
+
+    int getSampleTitle();
+
+    boolean isCancelButtonAllowed();
+
+    RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler);
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
old mode 100644
new mode 100755
index eae9011b..6accb557
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -1,9 +1,34 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
 import android.graphics.Color;
+import android.os.Build;
 import android.os.Bundle;
 import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
@@ -12,29 +37,60 @@
 import android.widget.TextView;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.AsyncHttpRequest;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
+import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HttpContext;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
+
+public abstract class SampleParentActivity extends Activity implements SampleInterface {
 
-public abstract class SampleParentActivity extends Activity {
+    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient() {
 
-    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+        @Override
+        protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+            AsyncHttpRequest httpRequest = getHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
+            return httpRequest == null
+                    ? super.newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context)
+                    : httpRequest;
+        }
+    };
     private EditText urlEditText, headersEditText, bodyEditText;
     private LinearLayout responseLayout;
+    public LinearLayout customFieldsLayout;
+    private final List<RequestHandle> requestHandles = new LinkedList<RequestHandle>();
+    private static final String LOG_TAG = "SampleParentActivity";
+
+    private static final int MENU_USE_HTTPS = 0;
+    private static final int MENU_CLEAR_VIEW = 1;
+    private static final int MENU_LOGGING_VERBOSITY = 2;
+    private static final int MENU_ENABLE_LOGGING = 3;
+
+    private boolean useHttps = true;
+    private boolean enableLogging = true;
 
-    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
-    private static final int LIGHTRED = Color.parseColor("#FF3300");
-    private static final int YELLOW = Color.parseColor("#FFFF00");
-    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+    protected static final String PROTOCOL_HTTP = "http://";
+    protected static final String PROTOCOL_HTTPS = "https://";
+
+    protected static String PROTOCOL = PROTOCOL_HTTPS;
+    protected static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    protected static final int LIGHTRED = Color.parseColor("#FF3300");
+    protected static final int YELLOW = Color.parseColor("#FFFF00");
+    protected static final int LIGHTBLUE = Color.parseColor("#99CCFF");
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -42,38 +98,148 @@ protected void onCreate(Bundle savedInstanceState) {
         setContentView(R.layout.parent_layout);
         setTitle(getSampleTitle());
 
+        setHomeAsUpEnabled();
+
         urlEditText = (EditText) findViewById(R.id.edit_url);
         headersEditText = (EditText) findViewById(R.id.edit_headers);
         bodyEditText = (EditText) findViewById(R.id.edit_body);
+        customFieldsLayout = (LinearLayout) findViewById(R.id.layout_custom);
         Button runButton = (Button) findViewById(R.id.button_run);
+        Button cancelButton = (Button) findViewById(R.id.button_cancel);
         LinearLayout headersLayout = (LinearLayout) findViewById(R.id.layout_headers);
         LinearLayout bodyLayout = (LinearLayout) findViewById(R.id.layout_body);
         responseLayout = (LinearLayout) findViewById(R.id.layout_response);
 
         urlEditText.setText(getDefaultURL());
+        headersEditText.setText(getDefaultHeaders());
 
         bodyLayout.setVisibility(isRequestBodyAllowed() ? View.VISIBLE : View.GONE);
         headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
 
         runButton.setOnClickListener(onClickListener);
+        if (cancelButton != null) {
+            if (isCancelButtonAllowed()) {
+                cancelButton.setVisibility(View.VISIBLE);
+                cancelButton.setOnClickListener(onClickListener);
+            } else {
+                cancelButton.setEnabled(false);
+            }
+        }
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem useHttpsMenuItem = menu.findItem(MENU_USE_HTTPS);
+        if (useHttpsMenuItem != null) {
+            useHttpsMenuItem.setChecked(useHttps);
+        }
+        MenuItem enableLoggingMenuItem = menu.findItem(MENU_ENABLE_LOGGING);
+        if (enableLoggingMenuItem != null) {
+            enableLoggingMenuItem.setChecked(enableLogging);
+        }
+        return super.onPrepareOptionsMenu(menu);
     }
 
-    private View.OnClickListener onClickListener = new View.OnClickListener() {
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, MENU_USE_HTTPS, Menu.NONE, R.string.menu_use_https).setCheckable(true);
+        menu.add(Menu.NONE, MENU_CLEAR_VIEW, Menu.NONE, R.string.menu_clear_view);
+        menu.add(Menu.NONE, MENU_ENABLE_LOGGING, Menu.NONE, "Enable Logging").setCheckable(true);
+        menu.add(Menu.NONE, MENU_LOGGING_VERBOSITY, Menu.NONE, "Set Logging Verbosity");
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_USE_HTTPS:
+                useHttps = !useHttps;
+                PROTOCOL = useHttps ? PROTOCOL_HTTPS : PROTOCOL_HTTP;
+                urlEditText.setText(getDefaultURL());
+                return true;
+            case MENU_ENABLE_LOGGING:
+                enableLogging = !enableLogging;
+                getAsyncHttpClient().setLoggingEnabled(enableLogging);
+                return true;
+            case MENU_LOGGING_VERBOSITY:
+                showLoggingVerbosityDialog();
+                return true;
+            case MENU_CLEAR_VIEW:
+                clearOutputs();
+                return true;
+            case android.R.id.home:
+                finish();
+                return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public AsyncHttpRequest getHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return null;
+    }
+
+    public List<RequestHandle> getRequestHandles() {
+        return requestHandles;
+    }
+
+    @Override
+    public void addRequestHandle(RequestHandle handle) {
+        if (null != handle) {
+            requestHandles.add(handle);
+        }
+    }
+
+    private void showLoggingVerbosityDialog() {
+        AlertDialog ad = new AlertDialog.Builder(this)
+                .setTitle("Set Logging Verbosity")
+                .setSingleChoiceItems(new String[]{
+                        "VERBOSE",
+                        "DEBUG",
+                        "INFO",
+                        "WARN",
+                        "ERROR",
+                        "WTF"
+                }, getAsyncHttpClient().getLoggingLevel() - 2, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        getAsyncHttpClient().setLoggingLevel(which + 2);
+                        dialog.dismiss();
+                    }
+                })
+                .setCancelable(true)
+                .setNeutralButton("Cancel", null)
+                .create();
+        ad.show();
+    }
+
+    public void onRunButtonPressed() {
+        addRequestHandle(executeSample(getAsyncHttpClient(),
+                getUrlText(getDefaultURL()),
+                getRequestHeaders(),
+                getRequestEntity(),
+                getResponseHandler()));
+    }
+
+    public void onCancelButtonPressed() {
+        asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+    }
+
+    protected final View.OnClickListener onClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
             switch (v.getId()) {
                 case R.id.button_run:
-                    executeSample(getAsyncHttpClient(),
-                            (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
-                            getRequestHeaders(),
-                            getRequestEntity(),
-                            getResponseHandler());
+                    onRunButtonPressed();
+                    break;
+                case R.id.button_cancel:
+                    onCancelButtonPressed();
                     break;
             }
         }
     };
 
-    protected Header[] getRequestHeaders() {
+    public List<Header> getRequestHeadersList() {
         List<Header> headers = new ArrayList<Header>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
@@ -81,35 +247,77 @@ public void onClick(View v) {
             String[] lines = headersRaw.split("\\r?\\n");
             for (String line : lines) {
                 try {
-                    String[] kv = line.split("=");
-                    if (kv.length != 2)
+                    int equalSignPos = line.indexOf('=');
+                    if (1 > equalSignPos) {
                         throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
-                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                    }
+
+                    String headerName = line.substring(0, equalSignPos).trim();
+                    String headerValue = line.substring(1 + equalSignPos).trim();
+                    Log.d(LOG_TAG, String.format("Added header: [%s:%s]", headerName, headerValue));
+
+                    headers.add(new BasicHeader(headerName, headerValue));
                 } catch (Throwable t) {
-                    Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
+                    Log.e(LOG_TAG, "Not a valid header line: " + line, t);
                 }
             }
         }
+        return headers;
+    }
+
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
         return headers.toArray(new Header[headers.size()]);
     }
 
-    protected HttpEntity getRequestEntity() {
-        if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
+    public HttpEntity getRequestEntity() {
+        String bodyText;
+        if (isRequestBodyAllowed() && (bodyText = getBodyText()) != null) {
             try {
-                return new StringEntity(bodyEditText.getText().toString());
+                return new StringEntity(bodyText);
             } catch (UnsupportedEncodingException e) {
-                Log.e("SampleParentActivity", "cannot create String entity", e);
+                Log.e(LOG_TAG, "cannot create String entity", e);
             }
         }
         return null;
     }
 
+    public String getUrlText() {
+        return getUrlText(null);
+    }
+
+    public String getUrlText(String defaultText) {
+        return urlEditText != null && urlEditText.getText() != null
+                ? urlEditText.getText().toString()
+                : defaultText;
+    }
+
+    public String getBodyText() {
+        return getBodyText(null);
+    }
+
+    public String getBodyText(String defaultText) {
+        return bodyEditText != null && bodyEditText.getText() != null
+                ? bodyEditText.getText().toString()
+                : defaultText;
+    }
+
+    public String getHeadersText() {
+        return getHeadersText(null);
+    }
+
+    public String getHeadersText(String defaultText) {
+        return headersEditText != null && headersEditText.getText() != null
+                ? headersEditText.getText().toString()
+                : defaultText;
+    }
+
     protected final void debugHeaders(String TAG, Header[] headers) {
         if (headers != null) {
             Log.d(TAG, "Return Headers:");
             StringBuilder builder = new StringBuilder();
             for (Header h : headers) {
-                String _h = String.format("%s : %s", h.getName(), h.getValue());
+                String _h = String.format(Locale.US, "%s : %s", h.getName(), h.getValue());
                 Log.d(TAG, _h);
                 builder.append(_h);
                 builder.append("\n");
@@ -143,7 +351,7 @@ protected final void debugResponse(String TAG, String response) {
     }
 
     protected final void debugStatusCode(String TAG, int statusCode) {
-        String msg = String.format("Return Status Code: %d", statusCode);
+        String msg = String.format(Locale.US, "Return Status Code: %d", statusCode);
         Log.d(TAG, msg);
         addView(getColoredView(LIGHTBLUE, msg));
     }
@@ -153,7 +361,7 @@ public static int getContrastColor(int color) {
         return y >= 128 ? Color.BLACK : Color.WHITE;
     }
 
-    private View getColoredView(int bgColor, String msg) {
+    protected View getColoredView(int bgColor, String msg) {
         TextView tv = new TextView(this);
         tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
         tv.setText(msg);
@@ -163,6 +371,11 @@ private View getColoredView(int bgColor, String msg) {
         return tv;
     }
 
+    @Override
+    public String getDefaultHeaders() {
+        return null;
+    }
+
     protected final void addView(View v) {
         responseLayout.addView(v);
     }
@@ -171,19 +384,24 @@ protected final void clearOutputs() {
         responseLayout.removeAllViews();
     }
 
-    protected abstract int getSampleTitle();
-
-    protected abstract boolean isRequestBodyAllowed();
-
-    protected abstract boolean isRequestHeadersAllowed();
-
-    protected abstract String getDefaultURL();
-
-    protected abstract AsyncHttpResponseHandler getResponseHandler();
+    public boolean isCancelButtonAllowed() {
+        return false;
+    }
 
-    protected AsyncHttpClient getAsyncHttpClient() {
+    public AsyncHttpClient getAsyncHttpClient() {
         return this.asyncHttpClient;
     }
 
-    protected abstract void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler);
+    @Override
+    public void setAsyncHttpClient(AsyncHttpClient client) {
+        this.asyncHttpClient = client;
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private void setHomeAsUpEnabled() {
+        if (Integer.valueOf(Build.VERSION.SDK) >= 11) {
+            if (getActionBar() != null)
+                getActionBar().setDisplayHomeAsUpEnabled(true);
+        }
+    }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
new file mode 100644
index 00000000..aa22c0b1
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SaxAsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class SaxSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "SaxSample";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return saxAsyncHttpResponseHandler;
+    }
+
+    private final SaxAsyncHttpResponseHandler saxAsyncHttpResponseHandler = new SaxAsyncHttpResponseHandler<SAXTreeStructure>(new SAXTreeStructure()) {
+        @Override
+        public void onStart() {
+            clearOutputs();
+        }
+
+        @Override
+        public void onSuccess(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        @Override
+        public void onFailure(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        private void debugHandler(SAXTreeStructure handler) {
+            for (Tuple t : handler.responseViews) {
+                addView(getColoredView(t.color, t.text));
+            }
+        }
+    };
+
+    @Override
+    public String getDefaultURL() {
+        return "http://bin-iin.com/sitemap.xml";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_sax_example;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    private class Tuple {
+        public final Integer color;
+        public final String text;
+
+        public Tuple(int _color, String _text) {
+            this.color = _color;
+            this.text = _text;
+        }
+    }
+
+    private class SAXTreeStructure extends DefaultHandler {
+
+        public final List<Tuple> responseViews = new ArrayList<Tuple>();
+
+        public void startElement(String namespaceURI, String localName,
+                                 String rawName, Attributes atts) {
+            responseViews.add(new Tuple(LIGHTBLUE, "Start Element: " + rawName));
+        }
+
+        public void endElement(String namespaceURI, String localName,
+                               String rawName) {
+            responseViews.add(new Tuple(LIGHTBLUE, "End Element  : " + rawName));
+        }
+
+        public void characters(char[] data, int off, int length) {
+            if (length > 0 && data[0] != '\n') {
+                responseViews.add(new Tuple(LIGHTGREEN, "Characters  :  " + new String(data,
+                        off, length)));
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
new file mode 100644
index 00000000..3f80ddb7
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SyncHttpClient;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class SynchronousClientSample extends GetSample {
+    private static final String LOG_TAG = "SyncSample";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setAsyncHttpClient(new SyncHttpClient());
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_synchronous;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/delay/6";
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+        if (client instanceof SyncHttpClient) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Log.d(LOG_TAG, "Before Request");
+                    client.get(SynchronousClientSample.this, URL, headers, null, responseHandler);
+                    Log.d(LOG_TAG, "After Request");
+                }
+            }).start();
+        } else {
+            Log.e(LOG_TAG, "Error, not using SyncHttpClient");
+        }
+        /**
+         * SyncHttpClient does not return RequestHandle,
+         * it executes each request directly,
+         * therefore those requests are not in cancelable threads
+         * */
+        return null;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        clearOutputs();
+                    }
+                });
+            }
+
+            @Override
+            public void onSuccess(final int statusCode, final Header[] headers, final byte[] response) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(final int statusCode, final Header[] headers, final byte[] errorResponse, final Throwable e) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+                });
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
new file mode 100755
index 00000000..3bec476d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -0,0 +1,112 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.util.SparseArray;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class ThreadingTimeoutSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+    protected final SparseArray<String> states = new SparseArray<String>();
+    protected int counter = 0;
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_threading_timeout;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isCancelButtonAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/delay/6";
+    }
+
+    protected synchronized void setStatus(int id, String status) {
+        String current = states.get(id, null);
+        states.put(id, current == null ? status : current + "," + status);
+        clearOutputs();
+        for (int i = 0; i < states.size(); i++) {
+            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
+        }
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            private final int id = counter++;
+
+            @Override
+            public void onStart() {
+                setStatus(id, "START");
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                setStatus(id, "SUCCESS");
+            }
+
+            @Override
+            public void onFinish() {
+                setStatus(id, "FINISH");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                setStatus(id, "FAILURE");
+            }
+
+            @Override
+            public void onCancel() {
+                setStatus(id, "CANCEL");
+            }
+        };
+    }
+
+    public int getCounter() {
+        return counter;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java b/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java
new file mode 100644
index 00000000..45dd61fd
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java
@@ -0,0 +1,114 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+
+import java.io.File;
+
+public class UsePoolThreadSample extends GetSample {
+
+    private static final String LOG_TAG = "UsePoolThreadSample";
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/bytes/1024000";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_use_pool_thread;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new UsePoolThreadResponseHandler();
+    }
+
+    private class UsePoolThreadResponseHandler extends AsyncHttpResponseHandler {
+
+        private final File destFile;
+
+        public UsePoolThreadResponseHandler() {
+            super();
+
+            // Destination file to save the downloaded bytes to.
+            destFile = getRandomCacheFile();
+            Log.d(LOG_TAG, "Bytes will be saved in file: " + destFile.getAbsolutePath());
+
+            // We wish to use the same pool thread to run the response.
+            setUsePoolThread(true);
+        }
+
+        @Override
+        public void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBody) {
+            // Response body includes 1MB of data, and it might take few
+            // milliseconds, maybe a second or two on old devices, to save it in
+            // the filesystem. However, since this callback method is running
+            // within the pool thread's execution scope, the UI thread will be
+            // relaxed to continue its work of updating the UI while this
+            // handler saves the bytes on disk.
+
+            // Save the response body's bytes on disk.
+            saveBytesOnDisk(destFile, responseBody);
+
+            // This callback is now running within the pool thread execution
+            // scope and not within Android's UI thread, so if we must update
+            // the UI, we'll have to dispatch a runnable to the UI thread.
+            runOnUiThread(new Runnable() {
+
+                @Override
+                public void run() {
+                    debugStatusCode(LOG_TAG, statusCode);
+                    debugHeaders(LOG_TAG, headers);
+                    if (responseBody != null) {
+                        addView(getColoredView(LIGHTGREEN, "Request succeeded (" + statusCode + "): (bytes=" + destFile.length() + "), path: " + destFile.getAbsolutePath()));
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void onFailure(final int statusCode, final Header[] headers, final byte[] responseBody, final Throwable error) {
+            // This callback is now running within the pool thread execution
+            // scope and not within Android's UI thread, so if we must update
+            // the UI, we'll have to dispatch a runnable to the UI thread.
+            runOnUiThread(new Runnable() {
+
+                @Override
+                public void run() {
+                    debugStatusCode(LOG_TAG, statusCode);
+                    debugHeaders(LOG_TAG, headers);
+                    debugThrowable(LOG_TAG, error);
+                    if (responseBody != null) {
+                        addView(getColoredView(LIGHTGREEN, "Download interrupted (" + statusCode + "): (bytes=" + responseBody.length + "), path: " + destFile.getAbsolutePath()));
+                    }
+                }
+            });
+        }
+
+        private File getRandomCacheFile() {
+            File dir = getCacheDir();
+            if (dir == null) {
+                dir = getFilesDir();
+            }
+
+            return new File(dir, "sample-" + System.currentTimeMillis() + ".bin");
+        }
+
+        private void saveBytesOnDisk(File destination, byte[] bytes) {
+            // TODO: Spin your own implementation to save the bytes on disk/SD card.
+            if (bytes != null && destination != null) {
+                Log.d(LOG_TAG, "Saved " + bytes.length + " bytes into file: " + destination.getAbsolutePath());
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
old mode 100644
new mode 100755
index 736c5424..ff5a22fe
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.ListActivity;
@@ -7,44 +25,75 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY"};
+    private static final SampleConfig[] samplesConfig = new SampleConfig[]{
+            new SampleConfig(R.string.title_get_sample, GetSample.class),
+            new SampleConfig(R.string.title_post_sample, PostSample.class),
+            new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
+            new SampleConfig(R.string.title_put_sample, PutSample.class),
+            new SampleConfig(R.string.title_patch_sample, PatchSample.class),
+            new SampleConfig(R.string.title_json_sample, JsonSample.class),
+            new SampleConfig(R.string.title_json_streamer_sample, JsonStreamerSample.class),
+            new SampleConfig(R.string.title_sax_example, SaxSample.class),
+            new SampleConfig(R.string.title_file_sample, FileSample.class),
+            new SampleConfig(R.string.title_directory_sample, DirectorySample.class),
+            new SampleConfig(R.string.title_binary_sample, BinarySample.class),
+            new SampleConfig(R.string.title_gzip_sample, GzipSample.class),
+            new SampleConfig(R.string.title_redirect_302, Redirect302Sample.class),
+            new SampleConfig(R.string.title_threading_timeout, ThreadingTimeoutSample.class),
+            new SampleConfig(R.string.title_cancel_all, CancelAllRequestsSample.class),
+            new SampleConfig(R.string.title_cancel_handle, CancelRequestHandleSample.class),
+            new SampleConfig(R.string.title_cancel_tag, CancelRequestByTagSample.class),
+            new SampleConfig(R.string.title_synchronous, SynchronousClientSample.class),
+            new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
+            new SampleConfig(R.string.title_post_files, FilesSample.class),
+            new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class),
+            new SampleConfig(R.string.title_custom_ca, CustomCASample.class),
+            new SampleConfig(R.string.title_retry_handler, RetryRequestSample.class),
+            new SampleConfig(R.string.title_range_sample, RangeResponseSample.class),
+            new SampleConfig(R.string.title_401_unauth, Http401AuthSample.class),
+            new SampleConfig(R.string.title_pre_post_processing, PrePostProcessingSample.class),
+            new SampleConfig(R.string.title_content_type_http_entity, ContentTypeForHttpEntitySample.class),
+            new SampleConfig(R.string.title_resume_download, ResumeDownloadSample.class),
+            new SampleConfig(R.string.title_digest_auth, DigestAuthSample.class),
+            new SampleConfig(R.string.title_use_pool_thread, UsePoolThreadSample.class),
+            new SampleConfig(R.string.title_request_params_debug, RequestParamsDebug.class)
+    };
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, getTitlesList()));
+    }
+
+    private List<String> getTitlesList() {
+        List<String> titles = new ArrayList<>();
+        for (SampleConfig config : samplesConfig) {
+            titles.add(getString(config.titleId));
+        }
+        return titles;
     }
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        Class<?> targetClass;
-        switch (position) {
-            case 0:
-            default:
-                targetClass = GetSample.class;
-                break;
-            case 1:
-                targetClass = PostSample.class;
-                break;
-            case 2:
-                targetClass = DeleteSample.class;
-                break;
-            case 3:
-                targetClass = PutSample.class;
-                break;
-            case 4:
-                targetClass = JsonSample.class;
-                break;
-            case 5:
-                targetClass = FileSample.class;
-                break;
-            case 6:
-                targetClass = BinarySample.class;
-                break;
+        if (position >= 0 && position < samplesConfig.length)
+            startActivity(new Intent(this, samplesConfig[position].targetClass));
+    }
+
+    private static class SampleConfig {
+
+        final int titleId;
+        final Class targetClass;
+
+        SampleConfig(int titleId, Class targetClass) {
+            this.titleId = titleId;
+            this.targetClass = targetClass;
         }
-        if (targetClass != null)
-            startActivity(new Intent(this, targetClass));
+
     }
+
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
new file mode 100644
index 00000000..c22f5a8d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
new file mode 100644
index 00000000..63e2ede2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
@@ -0,0 +1,87 @@
+package com.loopj.android.http.sample.services;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.SyncHttpClient;
+import com.loopj.android.http.sample.IntentServiceSample;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+
+public class ExampleIntentService extends IntentService {
+
+    public static final String LOG_TAG = "ExampleIntentService:IntentServiceSample";
+    public static final String INTENT_URL = "INTENT_URL";
+    public static final String INTENT_STATUS_CODE = "INTENT_STATUS_CODE";
+    public static final String INTENT_HEADERS = "INTENT_HEADERS";
+    public static final String INTENT_DATA = "INTENT_DATA";
+    public static final String INTENT_THROWABLE = "INTENT_THROWABLE";
+
+    private final AsyncHttpClient aClient = new SyncHttpClient();
+
+    public ExampleIntentService() {
+        super("ExampleIntentService");
+    }
+
+    @Override
+    public void onStart(Intent intent, int startId) {
+        Log.d(LOG_TAG, "onStart()");
+        super.onStart(intent, startId);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        if (intent != null && intent.hasExtra(INTENT_URL)) {
+            aClient.get(this, intent.getStringExtra(INTENT_URL), new AsyncHttpResponseHandler() {
+                @Override
+                public void onStart() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_START));
+                    Log.d(LOG_TAG, "onStart");
+                }
+
+                @Override
+                public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_SUCCESS);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onSuccess");
+                }
+
+                @Override
+                public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_FAILURE);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    broadcast.putExtra(INTENT_THROWABLE, error);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onFailure");
+                }
+
+                @Override
+                public void onCancel() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_CANCEL));
+                    Log.d(LOG_TAG, "onCancel");
+                }
+
+                @Override
+                public void onRetry(int retryNo) {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_RETRY));
+                    Log.d(LOG_TAG, String.format("onRetry: %d", retryNo));
+                }
+
+                @Override
+                public void onFinish() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_FINISH));
+                    Log.d(LOG_TAG, "onFinish");
+                }
+            });
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
new file mode 100644
index 00000000..c7c54db2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.services;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/API8Util.java b/sample/src/main/java/com/loopj/android/http/sample/util/API8Util.java
new file mode 100644
index 00000000..5f7364f4
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/API8Util.java
@@ -0,0 +1,23 @@
+package com.loopj.android.http.sample.util;
+
+import java.lang.reflect.Array;
+
+public class API8Util {
+
+    @SuppressWarnings("unchecked")
+    public static <T> T[] copyOfRange(T[] original, int start, int end) {
+        int originalLength = original.length; // For exception priority compatibility.
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        int resultLength = end - start;
+        int copyLength = Math.min(resultLength, originalLength - start);
+        T[] result = (T[]) Array.newInstance(original.getClass().getComponentType(), resultLength);
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
old mode 100644
new mode 100755
index 2d9d5dda..18f4334d
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import java.io.BufferedReader;
@@ -6,13 +24,13 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 
-// Source: http://stackoverflow.com/questions/12910503/android-read-file-as-string
+// Source: https://stackoverflow.com/questions/12910503/android-read-file-as-string
 public class FileUtil {
 
     public static String convertStreamToString(InputStream is) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(is));
         StringBuilder sb = new StringBuilder();
-        String line = null;
+        String line;
         while ((line = reader.readLine()) != null) {
             sb.append(line).append("\n");
         }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
new file mode 100644
index 00000000..a0ccb54b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
@@ -0,0 +1,32 @@
+package com.loopj.android.http.sample.util;
+
+import org.apache.http.Header;
+import org.apache.http.message.BasicHeader;
+
+public class IntentUtil {
+
+    public static String[] serializeHeaders(Header[] headers) {
+        if (headers == null) {
+            return new String[0];
+        }
+        String[] rtn = new String[headers.length * 2];
+        int index = -1;
+        for (Header h : headers) {
+            rtn[++index] = h.getName();
+            rtn[++index] = h.getValue();
+        }
+        return rtn;
+    }
+
+    public static Header[] deserializeHeaders(String[] serialized) {
+        if (serialized == null || serialized.length % 2 != 0) {
+            return new Header[0];
+        }
+        Header[] headers = new Header[serialized.length / 2];
+        for (int i = 0, h = 0; h < headers.length; i++, h++) {
+            headers[h] = new BasicHeader(serialized[i], serialized[++i]);
+        }
+        return headers;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
old mode 100644
new mode 100755
index e12c30fc..e9f10941
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
new file mode 100644
index 00000000..a6380ccd
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
@@ -0,0 +1,200 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
+
+import android.os.Build;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.InvalidKeyException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.security.SignatureException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * A class to authenticate a secured connection against a custom CA using a BKS store.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class SecureSocketFactory extends SSLSocketFactory {
+
+    private static final String LOG_TAG = "SecureSocketFactory";
+
+    private final SSLContext sslCtx;
+    private final X509Certificate[] acceptedIssuers;
+
+    /**
+     * Instantiate a new secured factory pertaining to the passed store. Be sure to initialize the
+     * store with the password using {@link java.security.KeyStore#load(java.io.InputStream,
+     * char[])} method.
+     *
+     * @param store The key store holding the certificate details
+     * @param alias The alias of the certificate to use
+     */
+    public SecureSocketFactory(KeyStore store, String alias)
+            throws
+            CertificateException,
+            NoSuchAlgorithmException,
+            KeyManagementException,
+            KeyStoreException,
+            UnrecoverableKeyException {
+
+        super(store);
+
+        // Loading the CA certificate from store.
+        final Certificate rootca = store.getCertificate(alias);
+
+        // Turn it to X509 format.
+        InputStream is = new ByteArrayInputStream(rootca.getEncoded());
+        X509Certificate x509ca = (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(is);
+        AsyncHttpClient.silentCloseInputStream(is);
+
+        if (null == x509ca) {
+            throw new CertificateException("Embedded SSL certificate has expired.");
+        }
+
+        // Check the CA's validity.
+        x509ca.checkValidity();
+
+        // Accepted CA is only the one installed in the store.
+        acceptedIssuers = new X509Certificate[]{x509ca};
+
+        sslCtx = SSLContext.getInstance("TLS");
+        sslCtx.init(
+                null,
+                new TrustManager[]{
+                        new X509TrustManager() {
+                            @Override
+                            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                            }
+
+                            @Override
+                            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                                Exception error = null;
+
+                                if (null == chain || 0 == chain.length) {
+                                    error = new CertificateException("Certificate chain is invalid.");
+                                } else if (null == authType || 0 == authType.length()) {
+                                    error = new CertificateException("Authentication type is invalid.");
+                                } else {
+                                    Log.i(LOG_TAG, "Chain includes " + chain.length + " certificates.");
+                                    try {
+                                        for (X509Certificate cert : chain) {
+                                            Log.i(LOG_TAG, "Server Certificate Details:");
+                                            Log.i(LOG_TAG, "---------------------------");
+                                            Log.i(LOG_TAG, "IssuerDN: " + cert.getIssuerDN().toString());
+                                            Log.i(LOG_TAG, "SubjectDN: " + cert.getSubjectDN().toString());
+                                            Log.i(LOG_TAG, "Serial Number: " + cert.getSerialNumber());
+                                            Log.i(LOG_TAG, "Version: " + cert.getVersion());
+                                            Log.i(LOG_TAG, "Not before: " + cert.getNotBefore().toString());
+                                            Log.i(LOG_TAG, "Not after: " + cert.getNotAfter().toString());
+                                            Log.i(LOG_TAG, "---------------------------");
+
+                                            // Make sure that it hasn't expired.
+                                            cert.checkValidity();
+
+                                            // Verify the certificate's public key chain.
+                                            cert.verify(rootca.getPublicKey());
+                                        }
+                                    } catch (InvalidKeyException e) {
+                                        error = e;
+                                    } catch (NoSuchAlgorithmException e) {
+                                        error = e;
+                                    } catch (NoSuchProviderException e) {
+                                        error = e;
+                                    } catch (SignatureException e) {
+                                        error = e;
+                                    }
+                                }
+                                if (null != error) {
+                                    Log.e(LOG_TAG, "Certificate error", error);
+                                    throw new CertificateException(error);
+                                }
+                            }
+
+                            @Override
+                            public X509Certificate[] getAcceptedIssuers() {
+                                return acceptedIssuers;
+                            }
+                        }
+                },
+                null
+        );
+
+        setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+            throws IOException {
+
+        injectHostname(socket, host);
+        Socket sslSocket = sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
+        
+        // throw an exception if the hostname does not match the certificate
+        getHostnameVerifier().verify(host, (SSLSocket) sslSocket);
+        
+        return sslSocket;
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslCtx.getSocketFactory().createSocket();
+    }
+
+    /**
+     * Pre-ICS Android had a bug resolving HTTPS addresses. This workaround fixes that bug.
+     *
+     * @param socket The socket to alter
+     * @param host   Hostname to connect to
+     * @see <a href="https://code.google.com/p/android/issues/detail?id=13117#c14">https://code.google.com/p/android/issues/detail?id=13117#c14</a>
+     */
+    private void injectHostname(Socket socket, String host) {
+        try {
+            if (Integer.valueOf(Build.VERSION.SDK) >= 4) {
+                Field field = InetAddress.class.getDeclaredField("hostName");
+                field.setAccessible(true);
+                field.set(socket.getInetAddress(), host);
+            }
+        } catch (Exception ignored) {
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
new file mode 100644
index 00000000..bc0c7263
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    https://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        https://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
\ No newline at end of file
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
index 96a442e5..d95d16f9 100644
Binary files a/sample/src/main/res/drawable-hdpi/ic_launcher.png and b/sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
index 359047df..75b78337 100644
Binary files a/sample/src/main/res/drawable-mdpi/ic_launcher.png and b/sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
index 71c6d760..52a6abdd 100644
Binary files a/sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..d75067ca
Binary files /dev/null and b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
new file mode 100644
index 00000000..927c4a26
Binary files /dev/null and b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
new file mode 100755
index 00000000..cef3029d
--- /dev/null
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <EditText
+            android:id="@+id/edit_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:inputType="textUri"/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/button_cancel"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_cancel"/>
+
+            <Button
+                android:id="@+id/button_run"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_run"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_custom"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/credentials.xml b/sample/src/main/res/layout/credentials.xml
new file mode 100644
index 00000000..89ca0d9b
--- /dev/null
+++ b/sample/src/main/res/layout/credentials.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:layout_width="fill_parent"
+  android:layout_height="wrap_content"
+  android:paddingTop="10dp"
+  android:paddingBottom="0dp"
+  android:paddingLeft="10dp"
+  android:paddingRight="10dp"
+  android:orientation="vertical"
+>
+  <TextView
+    android:id="@+id/label_credentials"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="10dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:text="@string/label_credentials"
+    android:textColor="@color/dialog_color"
+  />
+  <EditText
+    android:id="@+id/field_username"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="5dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:inputType="text"
+    android:hint="@string/field_username"
+  />
+  <EditText
+    android:id="@+id/field_password"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="0dp"
+    android:layout_marginBottom="5dp"
+    android:layout_marginLeft="0dp"
+    android:layout_marginRight="0dp"
+    android:inputType="textPassword"
+    android:hint="@string/field_password"
+  />
+</LinearLayout>
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
old mode 100644
new mode 100755
index a7ad216e..3a54fcd9
--- a/sample/src/main/res/layout/parent_layout.xml
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:fillViewport="true">
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
 
     <LinearLayout
         android:focusable="true"
@@ -11,7 +11,7 @@
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
-        <requestFocus />
+        <requestFocus/>
 
         <LinearLayout
             android:id="@+id/layout_url"
@@ -24,13 +24,20 @@
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:layout_weight="1"
-                android:inputType="textUri" />
+                android:inputType="textUri"/>
 
             <Button
                 android:id="@+id/button_run"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="Run" />
+                android:text="@string/button_run"/>
+
+            <Button
+                android:id="@+id/button_cancel"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:visibility="gone"
+                android:text="@string/button_cancel"/>
         </LinearLayout>
 
         <LinearLayout
@@ -42,7 +49,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="Headers (key=val, one per line)" />
+                android:text="@string/label_headers"/>
 
             <EditText
                 android:id="@+id/edit_headers"
@@ -50,7 +57,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -63,7 +70,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="Request body" />
+                android:text="@string/label_req_body"/>
 
             <EditText
                 android:id="@+id/edit_body"
@@ -71,15 +78,22 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
+        <LinearLayout
+            android:id="@+id/layout_custom"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        </LinearLayout>
+
         <LinearLayout
             android:id="@+id/layout_response"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:orientation="vertical" />
+            android:orientation="vertical"/>
 
     </LinearLayout>
 </ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/raw/custom_ca.txt b/sample/src/main/res/raw/custom_ca.txt
new file mode 100644
index 00000000..b2760af9
--- /dev/null
+++ b/sample/src/main/res/raw/custom_ca.txt
@@ -0,0 +1,60 @@
+This is a short HOW-TO documenting the steps necessary to create a key store
+file that Android could use to connect to servers with a custom CA.
+
+This file's location is: 'res/raw/custom_ca.txt'
+
+Prerequisities:
+---------------
+
+1) Access to a computer with 'openssl' command;
+2) The 'keytool' command available in Java SE 6 and above;
+3) BouncyCastle jar version 1.46 (http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)
+
+Important:
+----------
+
+If you use the wrong BouncyCastle jar (for example, a newer version), older
+Android handsets might fail with the error "Wrong version of key store". So we
+advise to use an older BouncyCastle jar to cover older handsets.
+
+Let's see the fun part:
+-----------------------
+
+1) Create a self-signed CA using the openssl tool. You may bypass this step if
+   you already have a self-signed CA from before:
+
+   openssl req -newkey rsa:4096 -days 3650 -x509 -nodes -out ca.pem
+
+   This instructs openssl to create a 4096-bit RSA key and set its expiration
+   date 10 years later.
+
+   You will be asked to provide details of the CA. When you're finished, a file
+   called 'ca.pem' will exist in current directory.
+
+2) Android has built-in support for the Bouncy Castle key store format (BKS).
+   You should have downloaded BouncyCastle's jar; we assume the path to that jar
+   is 'path/to/jar/bcprov.jar'. Now create a key store file containing your
+   self-signed CA:
+
+   keytool \
+      -import \
+      -v \
+      -trustcacerts \
+      -file ca.pem \
+      -keystore store.bks \
+      -storetype BKS \
+      -provider org.bouncycastle.jce.provider.BouncyCastleProvider \
+      -providerpath path/to/jar/bcprov.jar \
+      -alias TheAlias \
+      -storepass ThePass
+
+   keytool will ask to verify the certificate, naturally you should do so by
+   typing "yes" (without parentheses) and hitting Enter.
+
+   Note the alias and the password at the last two lines; you will need to enter
+   both in CustomCASample.java before running the sample app.
+
+3) If all went smoothly, you should have a file named store.bks which contains
+   the self-signed CA that we prepared in step 1. Move the resulting file to the
+   'res/raw/' directory, adjust the alias and password in CustomCASample.java
+   file, rebuild the app and run it.
diff --git a/sample/src/main/res/raw/store.bks b/sample/src/main/res/raw/store.bks
new file mode 100644
index 00000000..6c2453bc
Binary files /dev/null and b/sample/src/main/res/raw/store.bks differ
diff --git a/sample/src/main/res/values-v11/colors.xml b/sample/src/main/res/values-v11/colors.xml
new file mode 100644
index 00000000..02e02580
--- /dev/null
+++ b/sample/src/main/res/values-v11/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FF333333</color>
+
+</resources>
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values-v14/colors.xml b/sample/src/main/res/values-v14/colors.xml
new file mode 100644
index 00000000..02e02580
--- /dev/null
+++ b/sample/src/main/res/values-v14/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FF333333</color>
+
+</resources>
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values/colors.xml b/sample/src/main/res/values/colors.xml
new file mode 100644
index 00000000..eea0b2d7
--- /dev/null
+++ b/sample/src/main/res/values/colors.xml
@@ -0,0 +1,5 @@
+<resources>
+
+    <color name="dialog_color">#FFFFFFFF</color>
+
+</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
old mode 100644
new mode 100755
index b8d68899..8486e50b
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -1,12 +1,52 @@
 <?xml version="1.0" encoding="utf-8"?>
-<resources>
 
+<resources>
     <string name="app_name">Android Async Http Samples</string>
+
+    <string name="field_username">Username</string>
+    <string name="field_password">Password</string>
+
+    <string name="button_run">Run</string>
+    <string name="button_cancel">Cancel</string>
+    <string name="button_delete_target_file">Delete original target file</string>
+
+    <string name="menu_use_https">Use HTTPS</string>
+    <string name="menu_clear_view">Clear Outputs</string>
+
+    <string name="label_headers">Headers (key=val, one per line)</string>
+    <string name="label_req_body">Request body</string>
+    <string name="label_credentials">Server requests authentication.\nTo gain access, enter:\n\nUsername: %1$s\nPassword: %2$s</string>
+
     <string name="title_get_sample">GET</string>
-    <string name="title_json_sample">GET and JSON parse</string>
+    <string name="title_json_sample">GET JSON and parse it</string>
+    <string name="title_json_streamer_sample">POST JSON using streamer</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
+    <string name="title_patch_sample">PATCH</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
+    <string name="title_directory_sample">GET to Directory</string>
     <string name="title_binary_sample">GET binary data</string>
+    <string name="title_cancel_all">Cancel all requests</string>
+    <string name="title_sax_example">SAX Example</string>
+    <string name="title_cancel_handle">Cancel request handle</string>
+    <string name="title_cancel_tag">Cancel by TAG</string>
+    <string name="title_synchronous">Synchronous GET request</string>
+    <string name="title_threading_timeout">Threading timeouts</string>
+    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
+    <string name="title_intent_service_sample">IntentService Synchronised Request</string>
+    <string name="title_post_files">Post Multipart-encoded files</string>
+    <string name="title_redirect_302">302 Redirect handling</string>
+    <string name="title_persistent_cookies">Handling persistent cookies</string>
+    <string name="title_custom_ca">Custom CA Example</string>
+    <string name="title_retry_handler">Retrying requests by Exception</string>
+    <string name="title_range_sample">Range response handling</string>
+    <string name="title_401_unauth">401 basic authentication</string>
+    <string name="title_pre_post_processing">Pre-/Post-processing</string>
+    <string name="title_async_background_thread">Async on background thread</string>
+    <string name="title_content_type_http_entity">Content-Type with HttpEntity</string>
+    <string name="title_resume_download">Resuming Download</string>
+    <string name="title_digest_auth">Digest Authentication</string>
+    <string name="title_use_pool_thread">Use Pool Thread in Response</string>
+    <string name="title_request_params_debug">Request Params debug</string>
 </resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/standard/java/com/loopj/android/http/sample/SampleApplication.java b/sample/src/standard/java/com/loopj/android/http/sample/SampleApplication.java
new file mode 100644
index 00000000..2ef13dc0
--- /dev/null
+++ b/sample/src/standard/java/com/loopj/android/http/sample/SampleApplication.java
@@ -0,0 +1,34 @@
+package com.loopj.android.http.sample;
+
+import android.annotation.TargetApi;
+import android.app.Application;
+import android.os.Build;
+import android.os.StrictMode;
+import android.util.Log;
+
+public class SampleApplication extends Application {
+
+    private static final String LOG_TAG = "SampleApplication";
+
+    @Override
+    public void onCreate() {
+        setStrictMode();
+        super.onCreate();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private void setStrictMode() {
+        if (Integer.valueOf(Build.VERSION.SDK) > 3) {
+            Log.d(LOG_TAG, "Enabling StrictMode policy over Sample application");
+            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .penaltyDeath()
+                    .build());
+            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .build());
+        }
+    }
+}
diff --git a/sample/src/withLeakCanary/java/com/loopj/android/http/sample/SampleApplication.java b/sample/src/withLeakCanary/java/com/loopj/android/http/sample/SampleApplication.java
new file mode 100644
index 00000000..26949393
--- /dev/null
+++ b/sample/src/withLeakCanary/java/com/loopj/android/http/sample/SampleApplication.java
@@ -0,0 +1,37 @@
+package com.loopj.android.http.sample;
+
+import android.annotation.TargetApi;
+import android.app.Application;
+import android.os.Build;
+import android.os.StrictMode;
+import android.util.Log;
+
+import com.squareup.leakcanary.LeakCanary;
+
+public class SampleApplication extends Application {
+
+    private static final String LOG_TAG = "SampleApplication";
+
+    @Override
+    public void onCreate() {
+        setStrictMode();
+        super.onCreate();
+        LeakCanary.install(this);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private void setStrictMode() {
+        if (Integer.valueOf(Build.VERSION.SDK) > 3) {
+            Log.d(LOG_TAG, "Enabling StrictMode policy over Sample application");
+            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .penaltyDeath()
+                    .build());
+            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                    .detectAll()
+                    .penaltyLog()
+                    .build());
+        }
+    }
+}
diff --git a/settings.gradle b/settings.gradle
old mode 100644
new mode 100755
