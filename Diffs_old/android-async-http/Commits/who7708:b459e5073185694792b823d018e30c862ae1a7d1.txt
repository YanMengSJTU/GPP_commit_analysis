diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 6644f5c2..bbf02df1 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -86,7 +86,6 @@
 import cz.msebera.android.httpclient.protocol.HttpContext;
 import cz.msebera.android.httpclient.protocol.SyncBasicHttpContext;
 
-
 /**
  * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
  * your Android applications. Requests can be made with additional parameters by passing a {@link
@@ -214,11 +213,7 @@ public void process(HttpRequest request, HttpContext context) {
                 for (String header : clientHeaderMap.keySet()) {
                     if (request.containsHeader(header)) {
                         Header overwritten = request.getFirstHeader(header);
-                        log.d(LOG_TAG,
-                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
-                                        header, clientHeaderMap.get(header),
-                                        overwritten.getName(), overwritten.getValue())
-                        );
+                        log.d(LOG_TAG, String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)", header, clientHeaderMap.get(header), overwritten.getName(), overwritten.getValue()));
 
                         //remove the overwritten header
                         request.removeHeader(overwritten);
@@ -256,8 +251,7 @@ public void process(final HttpRequest request, final HttpContext context) throws
                 context.setAttribute(ClientContext.AUTHSCHEME_REGISTRY, authSchemeRegistry);
 
                 AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
-                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
-                        ClientContext.CREDS_PROVIDER);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(ClientContext.CREDS_PROVIDER);
                 HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
 
                 if (authState.getAuthScheme() == null) {
@@ -336,8 +330,9 @@ public static void blockRetryExceptionClass(Class<?> cls) {
      * @return encoded url if requested with params appended if any available
      */
     public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
-        if (url == null)
+        if (url == null) {
             return null;
+        }
 
         if (shouldEncodeUrl) {
             try {
@@ -375,15 +370,18 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
      * @throws java.io.IOException if read from inputStream fails
      */
     public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {
-        if (inputStream == null)
+        if (inputStream == null) {
             return false;
+        }
 
         byte[] signature = new byte[2];
         int count = 0;
         try {
             while (count < 2) {
                 int readCount = inputStream.read(signature, count, 2 - count);
-                if (readCount < 0) return false;
+                if (readCount < 0) {
+                    return false;
+                }
                 count = count + readCount;
             }
         } finally {
@@ -656,8 +654,9 @@ public int getMaxConnections() {
      * @param maxConnections maximum parallel connections, must be at least 1
      */
     public void setMaxConnections(int maxConnections) {
-        if (maxConnections < 1)
+        if (maxConnections < 1) {
             maxConnections = DEFAULT_MAX_CONNECTIONS;
+        }
         this.maxConnections = maxConnections;
         final HttpParams httpParams = this.httpClient.getParams();
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(this.maxConnections));
@@ -743,9 +742,7 @@ public void setProxy(String hostname, int port) {
      * @param password the password
      */
     public void setProxy(String hostname, int port, String username, String password) {
-        httpClient.getCredentialsProvider().setCredentials(
-                new AuthScope(hostname, port),
-                new UsernamePasswordCredentials(username, password));
+        httpClient.getCredentialsProvider().setCredentials(new AuthScope(hostname, port), new UsernamePasswordCredentials(username, password));
         final HttpHost proxy = new HttpHost(hostname, port);
         final HttpParams httpParams = this.httpClient.getParams();
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
@@ -808,7 +805,6 @@ public void setBearerAuth(String token) {
         setBearerAuth(token, AuthScope.ANY, false);
     }
 
-
     /**
      * Sets bearer authentication for the request. You should pass in your AuthScope for security. It
      * should be like this setBearerAuth("token", new AuthScope("host",port,AuthScope.ANY_REALM), false)
@@ -981,8 +977,9 @@ public void cancelRequestsByTAG(Object TAG, boolean mayInterruptIfRunning) {
         for (List<RequestHandle> requestList : requestMap.values()) {
             if (requestList != null) {
                 for (RequestHandle requestHandle : requestList) {
-                    if (TAG.equals(requestHandle.getTag()))
+                    if (TAG.equals(requestHandle.getTag())) {
                         requestHandle.cancel(mayInterruptIfRunning);
+                    }
                 }
             }
         }
@@ -1071,9 +1068,10 @@ public RequestHandle head(Context context, String url, RequestParams params, Res
      */
     public RequestHandle head(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
+        return sendRequest(httpClient, httpContext, request, null, responseHandler, context);
     }
 
     /**
@@ -1141,9 +1139,10 @@ public RequestHandle get(Context context, String url, RequestParams params, Resp
      */
     public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
+        return sendRequest(httpClient, httpContext, request, null, responseHandler, context);
     }
 
     /**
@@ -1232,13 +1231,15 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      * @param responseHandler the response handler instance that should handle the response.
      * @return RequestHandle of future request process
      */
-    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-                              ResponseHandlerInterface responseHandler) {
+    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType, ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(getURI(url));
-        if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
+        if (params != null) {
+            request.setEntity(paramsToEntity(params, responseHandler));
+        }
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
     /**
@@ -1256,10 +1257,11 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      * @param responseHandler the response handler instance that should handle the response.
      * @return RequestHandle of future request process
      */
-    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-                              ResponseHandlerInterface responseHandler) {
+    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(getURI(url)), entity);
-        if (headers != null) request.setHeaders(headers);
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -1334,7 +1336,9 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(getURI(url)), entity);
-        if (headers != null) request.setHeaders(headers);
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -1412,7 +1416,9 @@ public RequestHandle patch(Context context, String url, HttpEntity entity, Strin
      */
     public RequestHandle patch(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(getURI(url)), entity);
-        if (headers != null) request.setHeaders(headers);
+        if (headers != null) {
+            request.setHeaders(headers);
+        }
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -1453,7 +1459,9 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
         final HttpDelete delete = new HttpDelete(getURI(url));
-        if (headers != null) delete.setHeaders(headers);
+        if (headers != null) {
+            delete.setHeaders(headers);
+        }
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -1482,7 +1490,9 @@ public RequestHandle delete(String url, RequestParams params, AsyncHttpResponseH
      */
     public RequestHandle delete(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
         HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) httpDelete.setHeaders(headers);
+        if (headers != null) {
+            httpDelete.setHeaders(headers);
+        }
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
index 045b46ea..453ae76d 100755
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -221,8 +221,7 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
 
         // Account for the newlines, if any.
         if (encoder.do_newline && len > 0) {
-            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                    (encoder.do_cr ? 2 : 1);
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) * (encoder.do_cr ? 2 : 1);
         }
 
         encoder.output = new byte[output_len];
@@ -262,47 +261,13 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
         /**
          * Lookup table for turning bytes into their position in the Base64 alphabet.
          */
-        private static final int DECODE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
+        private static final int DECODE[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,};
 
         /**
          * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
          * and /.
          */
-        private static final int DECODE_WEBSAFE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
+        private static final int DECODE_WEBSAFE[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,};
 
         /**
          * Non-data values in the DECODE arrays.
@@ -341,7 +306,9 @@ public int maxOutputSize(int len) {
          * detected in the input stream.
          */
         public boolean process(byte[] input, int offset, int len, boolean finish) {
-            if (this.state == 6) return false;
+            if (this.state == 6) {
+                return false;
+            }
 
             int p = offset;
             len += offset;
@@ -373,18 +340,19 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // You can remove this whole block and the output should
                 // be the same, just slower.
                 if (state == 0) {
-                    while (p + 4 <= len &&
-                            (value = ((alphabet[input[p] & 0xff] << 18) |
-                                    (alphabet[input[p + 1] & 0xff] << 12) |
-                                    (alphabet[input[p + 2] & 0xff] << 6) |
-                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                    while (p + 4 <= len && (value = ((alphabet[input[p] & 0xff] << 18) |
+                            (alphabet[input[p + 1] & 0xff] << 12) |
+                            (alphabet[input[p + 2] & 0xff] << 6) |
+                            (alphabet[input[p + 3] & 0xff]))) >= 0) {
                         output[op + 2] = (byte) value;
                         output[op + 1] = (byte) (value >> 8);
                         output[op] = (byte) (value >> 16);
                         op += 3;
                         p += 4;
                     }
-                    if (p >= len) break;
+                    if (p >= len) {
+                        break;
+                    }
                 }
 
                 // The fast path isn't available -- either we've read a
@@ -529,22 +497,12 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
         /**
          * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
-        private static final byte ENCODE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
-        };
+        private static final byte ENCODE[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',};
 
         /**
          * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
-        private static final byte ENCODE_WEBSAFE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
-        };
+        private static final byte ENCODE_WEBSAFE[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',};
         final public boolean do_padding;
         final public boolean do_newline;
         final public boolean do_cr;
@@ -622,7 +580,9 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 output[op++] = alphabet[(v >> 6) & 0x3f];
                 output[op++] = alphabet[v & 0x3f];
                 if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
+                    if (do_cr) {
+                        output[op++] = '\r';
+                    }
                     output[op++] = '\n';
                     count = LINE_GROUPS;
                 }
@@ -644,7 +604,9 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 p += 3;
                 op += 4;
                 if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
+                    if (do_cr) {
+                        output[op++] = '\r';
+                    }
                     output[op++] = '\n';
                     count = LINE_GROUPS;
                 }
@@ -667,13 +629,14 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                         output[op++] = '=';
                     }
                     if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
+                        if (do_cr) {
+                            output[op++] = '\r';
+                        }
                         output[op++] = '\n';
                     }
                 } else if (p - tailLen == len - 2) {
                     int t = 0;
-                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) | (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                     tailLen -= t;
                     output[op++] = alphabet[(v >> 12) & 0x3f];
                     output[op++] = alphabet[(v >> 6) & 0x3f];
@@ -682,11 +645,15 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                         output[op++] = '=';
                     }
                     if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
+                        if (do_cr) {
+                            output[op++] = '\r';
+                        }
                         output[op++] = '\n';
                     }
                 } else if (do_newline && op > 0 && count != LINE_GROUPS) {
-                    if (do_cr) output[op++] = '\r';
+                    if (do_cr) {
+                        output[op++] = '\r';
+                    }
                     output[op++] = '\n';
                 }
 
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
index 07fb6f7c..40ebefa5 100755
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -87,7 +87,9 @@ private void flushBuffer() throws IOException {
 
     @Override
     public void write(byte[] b, int off, int len) throws IOException {
-        if (len <= 0) return;
+        if (len <= 0) {
+            return;
+        }
         flushBuffer();
         internalWrite(b, off, len, false);
     }
diff --git a/library/src/main/java/com/loopj/android/http/BearerAuthSchemeFactory.java b/library/src/main/java/com/loopj/android/http/BearerAuthSchemeFactory.java
index f3106527..c796af9f 100644
--- a/library/src/main/java/com/loopj/android/http/BearerAuthSchemeFactory.java
+++ b/library/src/main/java/com/loopj/android/http/BearerAuthSchemeFactory.java
@@ -52,8 +52,7 @@ public Header authenticate(Credentials credentials, HttpRequest request) throws
         }
 
         @Override
-        public Header authenticate(Credentials credentials, HttpRequest request, HttpContext httpContext)
-                throws AuthenticationException {
+        public Header authenticate(Credentials credentials, HttpRequest request, HttpContext httpContext) throws AuthenticationException {
             CharArrayBuffer buffer = new CharArrayBuffer(32);
             buffer.append(AUTH.WWW_AUTH_RESP);
             buffer.append(": Bearer ");
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index 865fd5ef..072d10de 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -53,12 +53,7 @@
 
     private static final String LOG_TAG = "BinaryHttpRH";
 
-    private String[] mAllowedContentTypes = new String[]{
-            RequestParams.APPLICATION_OCTET_STREAM,
-            "image/jpeg",
-            "image/png",
-            "image/gif"
-    };
+    private String[] mAllowedContentTypes = new String[]{RequestParams.APPLICATION_OCTET_STREAM, "image/jpeg", "image/png", "image/gif"};
 
     /**
      * Creates a new BinaryHttpResponseHandler
@@ -120,15 +115,7 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         Header[] contentTypeHeaders = response.getHeaders(AsyncHttpClient.HEADER_CONTENT_TYPE);
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(
-                    status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "None, or more than one, Content-Type Header found!"
-                    )
-            );
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -144,15 +131,7 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(
-                    status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "Content-Type (" + contentTypeHeader.getValue() + ") not allowed!"
-                    )
-            );
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type (" + contentTypeHeader.getValue() + ") not allowed!"));
             return;
         }
         super.sendResponseMessage(response);
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 96bf9aea..1893a6cd 100755
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -63,19 +63,18 @@ public FileAsyncHttpResponseHandler(File file, boolean append) {
      * @param renameTargetFileIfExists whether target file should be renamed if it already exists
      */
     public FileAsyncHttpResponseHandler(File file, boolean append, boolean renameTargetFileIfExists) {
-        this(file,append,renameTargetFileIfExists,false);
+        this(file, append, renameTargetFileIfExists, false);
     }
 
-
     /**
      * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
      *
      * @param file                     File to store response within, must not be null
      * @param append                   whether data should be appended to existing file
      * @param renameTargetFileIfExists whether target file should be renamed if it already exists
-     * @param usePoolThread Whether to use the pool's thread to fire callbacks
+     * @param usePoolThread            Whether to use the pool's thread to fire callbacks
      */
-    public FileAsyncHttpResponseHandler(File file, boolean append, boolean renameTargetFileIfExists,boolean usePoolThread) {
+    public FileAsyncHttpResponseHandler(File file, boolean append, boolean renameTargetFileIfExists, boolean usePoolThread) {
         super(usePoolThread);
         Utils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
         if (!file.isDirectory() && !file.getParentFile().isDirectory()) {
@@ -174,8 +173,9 @@ protected File getTargetFileByParsingURL() {
             int index = 0;
             while (true) {
                 targetFileRtn = new File(getOriginalFile(), String.format(format, index));
-                if (!targetFileRtn.exists())
+                if (!targetFileRtn.exists()) {
                     return targetFileRtn;
+                }
                 index++;
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index b5bbe0a8..bbafc22d 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -38,7 +38,6 @@
 
     private static final String LOG_TAG = "JsonHttpRH";
 
-
     private boolean useRFC5179CompatibilityMode = true;
 
     /**
@@ -243,8 +242,9 @@ public void run() {
      * @throws org.json.JSONException exception if thrown while parsing JSON
      */
     protected Object parseResponse(byte[] responseBody) throws JSONException {
-        if (null == responseBody)
+        if (null == responseBody) {
             return null;
+        }
         Object result = null;
         //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If JSON is not valid this will return null
         String jsonString = getResponseString(responseBody, getCharset());
@@ -257,8 +257,7 @@ protected Object parseResponse(byte[] responseBody) throws JSONException {
             } else {
                 // Check if the string is an JSONObject style {} or JSONArray style []
                 // If not we consider this as a string
-                if ((jsonString.startsWith("{") && jsonString.endsWith("}"))
-                        || jsonString.startsWith("[") && jsonString.endsWith("]")) {
+                if ((jsonString.startsWith("{") && jsonString.endsWith("}")) || jsonString.startsWith("[") && jsonString.endsWith("]")) {
                     result = new JSONTokener(jsonString).nextValue();
                 }
                 // Check if this is a String "my String value" and remove quote
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 56514bc7..f96fa64d 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -42,8 +42,7 @@
 
     private static final String LOG_TAG = "JsonStreamerEntity";
 
-    private static final UnsupportedOperationException ERR_UNSUPPORTED =
-            new UnsupportedOperationException("Unsupported operation in this implementation.");
+    private static final UnsupportedOperationException ERR_UNSUPPORTED = new UnsupportedOperationException("Unsupported operation in this implementation.");
 
     // Size of the byte-array buffer used in I/O streams.
     private static final int BUFFER_SIZE = 4096;
@@ -53,14 +52,8 @@
     private static final byte[] STREAM_NAME = escape("name");
     private static final byte[] STREAM_TYPE = escape("type");
     private static final byte[] STREAM_CONTENTS = escape("contents");
-    private static final Header HEADER_JSON_CONTENT =
-            new BasicHeader(
-                    AsyncHttpClient.HEADER_CONTENT_TYPE,
-                    RequestParams.APPLICATION_JSON);
-    private static final Header HEADER_GZIP_ENCODING =
-            new BasicHeader(
-                    AsyncHttpClient.HEADER_CONTENT_ENCODING,
-                    AsyncHttpClient.ENCODING_GZIP);
+    private static final Header HEADER_JSON_CONTENT = new BasicHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, RequestParams.APPLICATION_JSON);
+    private static final Header HEADER_GZIP_ENCODING = new BasicHeader(AsyncHttpClient.HEADER_CONTENT_ENCODING, AsyncHttpClient.ENCODING_GZIP);
     // Buffer used for reading from input streams.
     private final byte[] buffer = new byte[BUFFER_SIZE];
     // JSON data and associated meta-data to be uploaded.
@@ -76,9 +69,7 @@
     public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression, String elapsedField) {
         this.progressHandler = progressHandler;
         this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
-        this.elapsedField = TextUtils.isEmpty(elapsedField)
-                ? null
-                : escape(elapsedField);
+        this.elapsedField = TextUtils.isEmpty(elapsedField) ? null : escape(elapsedField);
     }
 
     // Curtosy of Simple-JSON: https://goo.gl/XoW8RF
@@ -203,9 +194,7 @@ public void writeTo(final OutputStream out) throws IOException {
 
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream os = contentEncoding != null
-                ? new GZIPOutputStream(out, BUFFER_SIZE)
-                : out;
+        OutputStream os = contentEncoding != null ? new GZIPOutputStream(out, BUFFER_SIZE) : out;
 
         // Always send a JSON object.
         os.write('{');
@@ -303,8 +292,7 @@ public void writeTo(final OutputStream out) throws IOException {
         AsyncHttpClient.silentCloseOutputStream(os);
     }
 
-    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
-            throws IOException {
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry) throws IOException {
 
         // Send the meta data.
         writeMetaData(os, entry.name, entry.contentType);
@@ -312,8 +300,7 @@ private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entr
         int bytesRead;
 
         // Upload the file's contents in Base64.
-        Base64OutputStream bos =
-                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+        Base64OutputStream bos = new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from input stream until no more data's left to read.
         while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
@@ -333,8 +320,7 @@ private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entr
         }
     }
 
-    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
-            throws IOException {
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper) throws IOException {
 
         // Send the meta data.
         writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
@@ -346,8 +332,7 @@ private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
         FileInputStream in = new FileInputStream(wrapper.file);
 
         // Upload the file's contents in Base64.
-        Base64OutputStream bos =
-                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+        Base64OutputStream bos = new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from file until no more data's left to read.
         while ((bytesRead = in.read(buffer)) != -1) {
diff --git a/library/src/main/java/com/loopj/android/http/LogInterface.java b/library/src/main/java/com/loopj/android/http/LogInterface.java
index f5a06b19..13e18db5 100644
--- a/library/src/main/java/com/loopj/android/http/LogInterface.java
+++ b/library/src/main/java/com/loopj/android/http/LogInterface.java
@@ -47,5 +47,4 @@
 
     void wtf(String tag, String msg, Throwable t);
 
-
 }
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
index 5ee6f6d0..f8e08fb5 100644
--- a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -53,9 +53,7 @@ public MyRedirectHandler(final boolean allowRedirects) {
     }
 
     @Override
-    public boolean isRedirectRequested(
-            final HttpResponse response,
-            final HttpContext context) {
+    public boolean isRedirectRequested(final HttpResponse response, final HttpContext context) {
         if (!enableRedirects) {
             return false;
         }
@@ -75,9 +73,7 @@ public boolean isRedirectRequested(
     }
 
     @Override
-    public URI getLocationURI(
-            final HttpResponse response,
-            final HttpContext context) throws ProtocolException {
+    public URI getLocationURI(final HttpResponse response, final HttpContext context) throws ProtocolException {
         if (response == null) {
             throw new IllegalArgumentException("HTTP response may not be null");
         }
@@ -85,10 +81,7 @@ public URI getLocationURI(
         Header locationHeader = response.getFirstHeader("location");
         if (locationHeader == null) {
             // got a redirect response, but no location header
-            throw new ProtocolException(
-                    "Received redirect response " + response.getStatusLine()
-                            + " but no location header"
-            );
+            throw new ProtocolException("Received redirect response " + response.getStatusLine() + " but no location header");
         }
         //HERE IS THE MODIFIED LINE OF CODE
         String location = locationHeader.getValue().replaceAll(" ", "%20");
@@ -105,19 +98,15 @@ public URI getLocationURI(
         // Location       = "Location" ":" absoluteURI
         if (!uri.isAbsolute()) {
             if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
-                throw new ProtocolException("Relative redirect location '"
-                        + uri + "' not allowed");
+                throw new ProtocolException("Relative redirect location '" + uri + "' not allowed");
             }
             // Adjust location URI
-            HttpHost target = (HttpHost) context.getAttribute(
-                    ExecutionContext.HTTP_TARGET_HOST);
+            HttpHost target = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
             if (target == null) {
-                throw new IllegalStateException("Target host not available " +
-                        "in the HTTP context");
+                throw new IllegalStateException("Target host not available " + "in the HTTP context");
             }
 
-            HttpRequest request = (HttpRequest) context.getAttribute(
-                    ExecutionContext.HTTP_REQUEST);
+            HttpRequest request = (HttpRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
 
             try {
                 URI requestURI = new URI(request.getRequestLine().getUri());
@@ -130,8 +119,7 @@ public URI getLocationURI(
 
         if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
 
-            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
-                    REDIRECT_LOCATIONS);
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(REDIRECT_LOCATIONS);
 
             if (redirectLocations == null) {
                 redirectLocations = new RedirectLocations();
@@ -141,10 +129,7 @@ public URI getLocationURI(
             URI redirectURI;
             if (uri.getFragment() != null) {
                 try {
-                    HttpHost target = new HttpHost(
-                            uri.getHost(),
-                            uri.getPort(),
-                            uri.getScheme());
+                    HttpHost target = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());
                     redirectURI = URIUtils.rewriteURI(uri, target, true);
                 } catch (URISyntaxException ex) {
                     throw new ProtocolException(ex.getMessage(), ex);
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index b3419ea1..139107ae 100755
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -82,8 +82,9 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
-        if (omitNonPersistentCookies && !cookie.isPersistent())
+        if (omitNonPersistentCookies && !cookie.isPersistent()) {
             return;
+        }
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
@@ -178,8 +179,9 @@ public void deleteCookie(Cookie cookie) {
      * @return cookie encoded as String
      */
     protected String encodeCookie(SerializableCookie cookie) {
-        if (cookie == null)
+        if (cookie == null) {
             return null;
+        }
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
diff --git a/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java
index 09a265b6..3ecc1cda 100644
--- a/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java
+++ b/library/src/main/java/com/loopj/android/http/PreemptiveAuthorizationHttpRequestInterceptor.java
@@ -37,8 +37,7 @@
 
     public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
         AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
-        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
-                ClientContext.CREDS_PROVIDER);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(ClientContext.CREDS_PROVIDER);
         HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
 
         if (authState.getAuthScheme() == null) {
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
index 2e6e8233..4a580324 100755
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -31,7 +31,6 @@
 import cz.msebera.android.httpclient.client.HttpResponseException;
 import cz.msebera.android.httpclient.client.methods.HttpUriRequest;
 
-
 public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
     private static final String LOG_TAG = "RangeFileAsyncHttpRH";
 
@@ -53,11 +52,13 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
             StatusLine status = response.getStatusLine();
             if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
                 //already finished
-                if (!Thread.currentThread().isInterrupted())
+                if (!Thread.currentThread().isInterrupted()) {
                     sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+                }
             } else if (status.getStatusCode() >= 300) {
-                if (!Thread.currentThread().isInterrupted())
+                if (!Thread.currentThread().isInterrupted()) {
                     sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+                }
             } else {
                 if (!Thread.currentThread().isInterrupted()) {
                     Header header = response.getFirstHeader(AsyncHttpClient.HEADER_CONTENT_RANGE);
@@ -99,8 +100,9 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
     }
 
     public void updateRequestHeaders(HttpUriRequest uriRequest) {
-        if (file.exists() && file.canWrite())
+        if (file.exists() && file.canWrite()) {
             current = file.length();
+        }
         if (current > 0) {
             append = true;
             uriRequest.setHeader("Range", "bytes=" + current + "-");
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index 6908ae93..7fd0b7b9 100755
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -91,8 +91,9 @@ public boolean isCancelled() {
 
     public boolean shouldBeGarbageCollected() {
         boolean should = isCancelled() || isFinished();
-        if (should)
+        if (should) {
             request.clear();
+        }
         return should;
     }
 
@@ -114,8 +115,9 @@ public Object getTag() {
      */
     public RequestHandle setTag(Object tag) {
         AsyncHttpRequest _request = request.get();
-        if (_request != null)
+        if (_request != null) {
             _request.setRequestTag(tag);
+        }
         return this;
     }
 }
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 0387b928..cb3ce74b 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -92,11 +92,9 @@
  */
 public class RequestParams implements Serializable {
 
-    public final static String APPLICATION_OCTET_STREAM =
-            "application/octet-stream";
+    public final static String APPLICATION_OCTET_STREAM = "application/octet-stream";
 
-    public final static String APPLICATION_JSON =
-            "application/json";
+    public final static String APPLICATION_JSON = "application/json";
 
     protected final static String LOG_TAG = "RequestParams";
     protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
@@ -155,8 +153,9 @@ public RequestParams(final String key, final String value) {
      */
     public RequestParams(Object... keysAndValues) {
         int len = keysAndValues.length;
-        if (len % 2 != 0)
+        if (len % 2 != 0) {
             throw new IllegalArgumentException("Supplied arguments must be even");
+        }
         for (int i = 0; i < len; i += 2) {
             String key = String.valueOf(keysAndValues[i]);
             String val = String.valueOf(keysAndValues[i + 1]);
@@ -426,8 +425,9 @@ public boolean has(String key) {
     public String toString() {
         StringBuilder result = new StringBuilder();
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if (result.length() > 0)
+            if (result.length() > 0) {
                 result.append("&");
+            }
 
             result.append(entry.getKey());
             result.append("=");
@@ -435,8 +435,9 @@ public String toString() {
         }
 
         for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
-            if (result.length() > 0)
+            if (result.length() > 0) {
                 result.append("&");
+            }
 
             result.append(entry.getKey());
             result.append("=");
@@ -444,8 +445,9 @@ public String toString() {
         }
 
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if (result.length() > 0)
+            if (result.length() > 0) {
                 result.append("&");
+            }
 
             result.append(entry.getKey());
             result.append("=");
@@ -453,8 +455,9 @@ public String toString() {
         }
 
         for (ConcurrentHashMap.Entry<String, List<FileWrapper>> entry : fileArrayParams.entrySet()) {
-            if (result.length() > 0)
+            if (result.length() > 0) {
                 result.append("&");
+            }
 
             result.append(entry.getKey());
             result.append("=");
@@ -463,8 +466,9 @@ public String toString() {
 
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
-            if (result.length() > 0)
+            if (result.length() > 0) {
                 result.append("&");
+            }
 
             result.append(kv.getName());
             result.append("=");
@@ -524,10 +528,7 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
     }
 
     private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(
-                progressHandler,
-                !fileParams.isEmpty() || !streamParams.isEmpty(),
-                elapsedFieldInJsonStreamer);
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler, !fileParams.isEmpty() || !streamParams.isEmpty(), elapsedFieldInJsonStreamer);
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -548,13 +549,7 @@ private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHan
         for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
-                entity.addPart(entry.getKey(),
-                        StreamWrapper.newInstance(
-                                stream.inputStream,
-                                stream.name,
-                                stream.contentType,
-                                stream.autoClose)
-                );
+                entity.addPart(entry.getKey(), StreamWrapper.newInstance(stream.inputStream, stream.name, stream.contentType, stream.autoClose));
             }
         }
 
@@ -589,8 +584,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
         for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
-                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
-                        stream.contentType);
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream, stream.contentType);
             }
         }
 
@@ -636,8 +630,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
                 if (nestedKey instanceof String) {
                     Object nestedValue = map.get(nestedKey);
                     if (nestedValue != null) {
-                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format(Locale.US, "%s[%s]", key, nestedKey),
-                                nestedValue));
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format(Locale.US, "%s[%s]", key, nestedKey), nestedValue));
                     }
                 }
             }
@@ -694,11 +687,7 @@ public StreamWrapper(InputStream inputStream, String name, String contentType, b
         }
 
         static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
-            return new StreamWrapper(
-                    inputStream,
-                    name,
-                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
-                    autoClose);
+            return new StreamWrapper(inputStream, name, contentType == null ? APPLICATION_OCTET_STREAM : contentType, autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
index c1342862..5febeab8 100644
--- a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
@@ -141,8 +141,7 @@ public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
     public abstract void onFailure(int statusCode, Header[] headers, T t);
 
     @Override
-    public void onFailure(int statusCode, Header[] headers,
-                          byte[] responseBody, Throwable error) {
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
         onFailure(statusCode, headers, handler);
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index a9c41679..a604f127 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -49,11 +49,9 @@
 
     private static final String STR_CR_LF = "\r\n";
     private static final byte[] CR_LF = STR_CR_LF.getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY =
-            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY = ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
-    private final static char[] MULTIPART_CHARS =
-            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
     private final String boundary;
     private final byte[] boundaryLine;
@@ -97,7 +95,9 @@ public void addPart(String key, String value, String contentType) {
     }
 
     public void addPartWithCharset(String key, String value, String charset) {
-        if (charset == null) charset = HTTP.UTF_8;
+        if (charset == null) {
+            charset = HTTP.UTF_8;
+        }
         addPart(key, value, "text/plain; charset=" + charset);
     }
 
@@ -117,8 +117,7 @@ public void addPart(String key, File file, String type, String customFileName) {
         fileParts.add(new FilePart(key, file, normalizeContentType(type), customFileName));
     }
 
-    public void addPart(String key, String streamName, InputStream inputStream, String type)
-            throws IOException {
+    public void addPart(String key, String streamName, InputStream inputStream, String type) throws IOException {
 
         out.write(boundaryLine);
 
@@ -149,16 +148,14 @@ private String normalizeContentType(String type) {
     }
 
     private byte[] createContentDisposition(String key) {
-        return (
-                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
-                        ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
+        return (AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                ": form-data; name=\"" + key + "\"" + STR_CR_LF).getBytes();
     }
 
     private byte[] createContentDisposition(String key, String fileName) {
-        return (
-                AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
-                        ": form-data; name=\"" + key + "\"" +
-                        "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
+        return (AsyncHttpClient.HEADER_CONTENT_DISPOSITION +
+                ": form-data; name=\"" + key + "\"" +
+                "; filename=\"" + fileName + "\"" + STR_CR_LF).getBytes();
     }
 
     private void updateProgress(long count) {
@@ -184,9 +181,7 @@ public long getContentLength() {
 
     @Override
     public Header getContentType() {
-        return new BasicHeader(
-                AsyncHttpClient.HEADER_CONTENT_TYPE,
-                "multipart/form-data; boundary=" + boundary);
+        return new BasicHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);
     }
 
     @Override
@@ -230,15 +225,13 @@ public Header getContentEncoding() {
     @Override
     public void consumeContent() throws IOException, UnsupportedOperationException {
         if (isStreaming()) {
-            throw new UnsupportedOperationException(
-                    "Streaming entity does not implement #consumeContent()");
+            throw new UnsupportedOperationException("Streaming entity does not implement #consumeContent()");
         }
     }
 
     @Override
     public InputStream getContent() throws IOException, UnsupportedOperationException {
-        throw new UnsupportedOperationException(
-                "getContent() is not supported. Use writeTo() instead.");
+        throw new UnsupportedOperationException("getContent() is not supported. Use writeTo() instead.");
     }
 
     private class FilePart {
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index 2d67f806..a0fd18c4 100755
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -79,10 +79,7 @@ public SyncHttpClient(SchemeRegistry schemeRegistry) {
     }
 
     @Override
-    protected RequestHandle sendRequest(DefaultHttpClient client,
-                                        HttpContext httpContext, HttpUriRequest uriRequest,
-                                        String contentType, ResponseHandlerInterface responseHandler,
-                                        Context context) {
+    protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
         if (contentType != null) {
             uriRequest.addHeader(AsyncHttpClient.HEADER_CONTENT_TYPE, contentType);
         }
