diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index e367303f..f1fbf8bf 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -68,530 +68,652 @@
 import android.content.Context;
 import android.util.Base64;
 
-
 /**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
- * DELETE HTTP requests in your Android applications. Requests can be made
- * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
+ * your Android applications. Requests can be made with additional parameters by passing a
+ * {@link RequestParams} instance, and responses can be handled by passing an anonymously overridden
  * {@link AsyncHttpResponseHandler} instance.
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
- *     }
+ * client.get(&quot;http://www.google.com&quot;, new AsyncHttpResponseHandler() {
+ * 	&#064;Override
+ * 	public void onSuccess(String response) {
+ * 		System.out.println(response);
+ * 	}
  * });
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.3.2";
-
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 2;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-
-
-    /**
-     * Creates a new AsyncHttpClient.
-     */
-    public AsyncHttpClient() {
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            public void process(HttpRequest request, HttpContext context) {
-//                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-//                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-//                }
-                for (String header : clientHeaderMap.keySet()) {
-                	request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
-     */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-    /**
-     * Sets the connection time oout. By default, 10 seconds
-     * @param timeout the connect/socket timeout in milliseconds
-     */
-    public void setTimeout(int timeout){
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-    
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     * @param header the name of the header
-     * @param value the contents of the header
-     */
-    public void addHeader(String header, String value) {
-    	clientHeaderMap.put(header, value);
-    }
-    
-    /**
-     * Sets basic auth credentials
-     */
-    public void setBasicAuthCredentials(String user, String pass) {
-    	final String authKey = "Authorization";
-
-    	clientHeaderMap.remove(authKey);
-    	if (user == null && pass == null) return;
-    	
-    	if (user == null) user = "";
-    	String credentialText;
-    	if (pass != null) {
-    		credentialText = String.format("%s:%s", user, pass);
-    	}
-    	else {
-    		credentialText = user;
-    	}
-    	String credentialB64 = Base64.encodeToString(credentialText.getBytes(), Base64.NO_WRAP);
-    	String authToken =  String.format("Basic %s", credentialB64);
-    	clientHeaderMap.put(authKey, authToken);
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
-     *
-     * @param context the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
-     */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.remove(context);
-    }
-
-
-    //
-    // HTTP GET Requests
-    //
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-
-    //
-    // HTTP POST Requests
-    //
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    //
-    // HTTP PUT Requests
-    //
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-
-    // Private stuff
-    private void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
-
-        if(context != null) {
-            // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
-            }
-
-            requestList.add(new WeakReference<Future<?>>(request));
-
-            // TODO: Remove dead weakrefs from requestLists?
-        }
-    }
-
-    private String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
-            String paramString = params.getParamString();
-            url += "?" + paramString;
-        }
-
-        return url;
-    }
-
-    private HttpEntity paramsToEntity(RequestParams params) {
-        HttpEntity entity = null;
-
-        if(params != null) {
-            entity = params.getEntity();
-        }
-
-        return entity;
-    }
-
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    private static class InflatingEntity extends HttpEntityWrapper {
-    	GZIPInputStream inputStream;
-    	
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
+	private static final String VERSION = "1.3.2";
+
+	private static final int DEFAULT_MAX_CONNECTIONS = 10;
+	private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+	private static final int DEFAULT_MAX_RETRIES = 2;
+	private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+	static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+	private static final String ENCODING_GZIP = "gzip";
+
+	private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
+	private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+	private final DefaultHttpClient httpClient;
+	private final HttpContext httpContext;
+	private ThreadPoolExecutor threadPool;
+	private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+	private final Map<String, String> clientHeaderMap;
+
+	/**
+	 * Creates a new AsyncHttpClient.
+	 */
+	public AsyncHttpClient() {
+		BasicHttpParams httpParams = new BasicHttpParams();
+
+		ConnManagerParams.setTimeout(httpParams, socketTimeout);
+		ConnManagerParams.setMaxConnectionsPerRoute(httpParams,
+				new ConnPerRouteBean(maxConnections));
+		ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+		HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setTcpNoDelay(httpParams, true);
+		HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+		HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+		HttpProtocolParams.setUserAgent(httpParams, String.format(
+				"android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+
+		SchemeRegistry schemeRegistry = new SchemeRegistry();
+		schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+		schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+		ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+
+		httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+		httpClient = new DefaultHttpClient(cm, httpParams);
+		httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+			public void process(HttpRequest request, HttpContext context) {
+				// if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+				// request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+				// }
+				for (String header : clientHeaderMap.keySet()) {
+					request.addHeader(header, clientHeaderMap.get(header));
+				}
+			}
+		});
+
+		httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+			public void process(HttpResponse response, HttpContext context) {
+				final HttpEntity entity = response.getEntity();
+				final Header encoding = entity.getContentEncoding();
+				if (encoding != null) {
+					for (HeaderElement element : encoding.getElements()) {
+						if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+							response.setEntity(new InflatingEntity(response.getEntity()));
+							break;
+						}
+					}
+				}
+			}
+		});
+
+		httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+
+		threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+
+		requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+		clientHeaderMap = new HashMap<String, String>();
+	}
+
+	/**
+	 * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
+	 * settings for requests by accessing the client's ConnectionManager, HttpParams and
+	 * SchemeRegistry.
+	 */
+	public HttpClient getHttpClient() {
+		return this.httpClient;
+	}
+
+	/**
+	 * Sets an optional CookieStore to use when making requests
+	 * 
+	 * @param cookieStore
+	 *            The CookieStore implementation to use, usually an instance of
+	 *            {@link PersistentCookieStore}
+	 */
+	public void setCookieStore(CookieStore cookieStore) {
+		httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+	}
+
+	/**
+	 * Overrides the threadpool implementation used when queuing/pooling requests. By default,
+	 * Executors.newCachedThreadPool() is used.
+	 * 
+	 * @param threadPool
+	 *            an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
+	 */
+	public void setThreadPool(ThreadPoolExecutor threadPool) {
+		this.threadPool = threadPool;
+	}
+
+	/**
+	 * Sets the User-Agent header to be sent with each request. By default,
+	 * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+	 * 
+	 * @param userAgent
+	 *            the string to use in the User-Agent header.
+	 */
+	public void setUserAgent(String userAgent) {
+		HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+	}
+
+	/**
+	 * Sets the connection time oout. By default, 10 seconds
+	 * 
+	 * @param timeout
+	 *            the connect/socket timeout in milliseconds
+	 */
+	public void setTimeout(int timeout) {
+		final HttpParams httpParams = this.httpClient.getParams();
+		ConnManagerParams.setTimeout(httpParams, timeout);
+		HttpConnectionParams.setSoTimeout(httpParams, timeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+	}
+
+	/**
+	 * Sets the SSLSocketFactory to user when making requests. By default, a new, default
+	 * SSLSocketFactory is used.
+	 * 
+	 * @param sslSocketFactory
+	 *            the socket factory to use for https requests.
+	 */
+	public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+		this.httpClient.getConnectionManager().getSchemeRegistry()
+				.register(new Scheme("https", sslSocketFactory, 443));
+	}
+
+	/**
+	 * Sets headers that will be added to all requests this client makes (before sending).
+	 * 
+	 * @param header
+	 *            the name of the header
+	 * @param value
+	 *            the contents of the header
+	 */
+	public void addHeader(String header, String value) {
+		clientHeaderMap.put(header, value);
+	}
+
+	/**
+	 * Sets basic auth credentials
+	 */
+	public void setBasicAuthCredentials(String user, String pass) {
+		final String authKey = "Authorization";
+
+		clientHeaderMap.remove(authKey);
+		if (user == null && pass == null)
+			return;
+
+		if (user == null)
+			user = "";
+		String credentialText;
+		if (pass != null) {
+			credentialText = String.format("%s:%s", user, pass);
+		} else {
+			credentialText = user;
+		}
+		String credentialB64 = Base64.encodeToString(credentialText.getBytes(), Base64.NO_WRAP);
+		String authToken = String.format("Basic %s", credentialB64);
+		clientHeaderMap.put(authKey, authToken);
+	}
+
+	/**
+	 * Cancels any pending (or potentially active) requests associated with the passed Context.
+	 * <p>
+	 * <b>Note:</b> This will only affect requests which were created with a non-null android
+	 * Context. This method is intended to be used in the onDestroy method of your android
+	 * activities to destroy all requests which are no longer required.
+	 * 
+	 * @param context
+	 *            the android Context instance associated to the request.
+	 * @param mayInterruptIfRunning
+	 *            specifies if active requests should be cancelled along with pending requests.
+	 */
+	public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
+		List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+		if (requestList != null) {
+			for (WeakReference<Future<?>> requestRef : requestList) {
+				Future<?> request = requestRef.get();
+				if (request != null) {
+					request.cancel(mayInterruptIfRunning);
+				}
+			}
+		}
+		requestMap.remove(context);
+	}
+
+	//
+	// HTTP GET Requests
+	//
+
+	/**
+	 * Perform a HTTP GET request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, AsyncHttpResponseHandler responseHandler) {
+		get(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		get(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request without any parameters and track the Android Context which
+	 * initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+		get(context, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null,
+				responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated the request with
+	 * customized headers
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, Header[] headers, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, null, responseHandler, context);
+	}
+
+	//
+	// HTTP POST Requests
+	//
+
+	/**
+	 * Perform a HTTP POST request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, AsyncHttpResponseHandler responseHandler) {
+		post(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		post(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		post(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if
+	 *            sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, HttpEntity entity, String contentType,
+			AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity),
+				contentType, responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated the request. Set
+	 * headers only for this request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if
+	 *            sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, Header[] headers, RequestParams params,
+			String contentType, AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = new HttpPost(url);
+		if (params != null)
+			request.setEntity(paramsToEntity(params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+	}
+
+	//
+	// HTTP PUT Requests
+	//
+
+	/**
+	 * Perform a HTTP PUT request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, AsyncHttpResponseHandler responseHandler) {
+		put(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		put(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		put(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+	 * one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if
+	 *            sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, HttpEntity entity, String contentType,
+			AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity),
+				contentType, responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
+	 * one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if
+	 *            sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, Header[] headers, HttpEntity entity,
+			String contentType, AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+	}
+
+	//
+	// HTTP DELETE Requests
+	//
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(String url, AsyncHttpResponseHandler responseHandler) {
+		delete(null, url, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url, Header[] headers,
+			AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		if (headers != null)
+			delete.setHeaders(headers);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+	}
+
+	// Private stuff
+	private void sendRequest(DefaultHttpClient client, HttpContext httpContext,
+			HttpUriRequest uriRequest, String contentType,
+			AsyncHttpResponseHandler responseHandler, Context context) {
+		if (contentType != null) {
+			uriRequest.addHeader("Content-Type", contentType);
+		}
+
+		Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest,
+				responseHandler));
+
+		if (context != null) {
+			// Add request to request map
+			List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+			if (requestList == null) {
+				requestList = new LinkedList<WeakReference<Future<?>>>();
+				requestMap.put(context, requestList);
+			}
+
+			requestList.add(new WeakReference<Future<?>>(request));
+
+			// TODO: Remove dead weakrefs from requestLists?
+		}
+	}
+
+	private String getUrlWithQueryString(String url, RequestParams params) {
+		if (params != null) {
+			String paramString = params.getParamString();
+			url += "?" + paramString;
+		}
+
+		return url;
+	}
+
+	private HttpEntity paramsToEntity(RequestParams params) {
+		HttpEntity entity = null;
+
+		if (params != null) {
+			entity = params.getEntity();
+		}
+
+		return entity;
+	}
+
+	private HttpEntityEnclosingRequestBase addEntityToRequestBase(
+			HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
+		if (entity != null) {
+			requestBase.setEntity(entity);
+		}
+
+		return requestBase;
+	}
+
+	private static class InflatingEntity extends HttpEntityWrapper {
+		GZIPInputStream inputStream;
+
+		public InflatingEntity(HttpEntity wrapped) {
+			super(wrapped);
+		}
+
+		@Override
 		public InputStream getContent() throws IOException {
-        	if (inputStream == null) {
-        		inputStream = new GZIPInputStream(wrappedEntity.getContent());
-        	}
-            return inputStream;
-        }
-
-        /* TODO: we might think that implementing this method would solve our leaking closable,
-         * but this is never called.
-         * 
-         * @see org.apache.http.entity.HttpEntityWrapper#consumeContent()
-         */
-        @Override
-        public void consumeContent() throws IOException {
-        	// TODO: see the doc note that this method name is misleading and will be renamed finish()
-        	inputStream.close();
-        	inputStream = null;
-        	super.consumeContent();
-        }
-        
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
+			if (inputStream == null) {
+				inputStream = new GZIPInputStream(wrappedEntity.getContent());
+			}
+			return inputStream;
+		}
+
+		/*
+		 * TODO: we might think that implementing this method would solve our leaking closable, but
+		 * this is never called.
+		 * 
+		 * @see org.apache.http.entity.HttpEntityWrapper#consumeContent()
+		 */
+		@Override
+		public void consumeContent() throws IOException {
+			// TODO: see the doc note that this method name is misleading and will be renamed
+			// finish()
+			inputStream.close();
+			inputStream = null;
+			super.consumeContent();
+		}
+
+		@Override
+		public long getContentLength() {
+			return -1;
+		}
+	}
 }
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
index 9f778f8b..d69112f4 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -31,79 +31,81 @@
 
 class AsyncHttpRequest implements Runnable {
 	final static String TAG = "AsyncHttpRequest";
-	
-    private final AbstractHttpClient client;
-    private final HttpContext context;
-    private final HttpUriRequest request;
-    private final AsyncHttpResponseHandler responseHandler;
-    private int executionCount;
-
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
-    }
-
-    public void run() {
-        try {
-            if(responseHandler != null){
-                responseHandler.sendStartMessage();
-            }
-
-            makeRequestWithRetries();
-
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
-        } catch (IOException e) {
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                responseHandler.sendFailureMessage(e, null);
-            }
-        }
-    }
-    
-    private void makeRequest() throws IOException {
-    	if(!Thread.currentThread().isInterrupted()) {
-    		HttpResponse response = client.execute(request, context);
-    		if(!Thread.currentThread().isInterrupted()) {
-    			if(responseHandler != null) {
-    				responseHandler.sendResponseMessage(response);
-    			}
-    		} else{
-    			//TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
-    		}
-    	}
-    }
-
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
-        boolean retry = true;
-        IOException cause = null;
-        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (IOException e) {
-                cause = e;
-                Log.w(TAG, "problem making request... retrying: " + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } 
-            catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient " + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } 
-        }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
-    }
+
+	private final AbstractHttpClient client;
+	private final HttpContext context;
+	private final HttpUriRequest request;
+	private final AsyncHttpResponseHandler responseHandler;
+	private int executionCount;
+
+	public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request,
+			AsyncHttpResponseHandler responseHandler) {
+		this.client = client;
+		this.context = context;
+		this.request = request;
+		this.responseHandler = responseHandler;
+	}
+
+	public void run() {
+		try {
+			if (responseHandler != null) {
+				responseHandler.sendStartMessage();
+			}
+
+			makeRequestWithRetries();
+
+			if (responseHandler != null) {
+				responseHandler.sendFinishMessage();
+			}
+		} catch (IOException e) {
+			if (responseHandler != null) {
+				responseHandler.sendFinishMessage();
+				responseHandler.sendFailureMessage(e, null);
+			}
+		}
+	}
+
+	private void makeRequest() throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			HttpResponse response = client.execute(request, context);
+			if (!Thread.currentThread().isInterrupted()) {
+				if (responseHandler != null) {
+					responseHandler.sendResponseMessage(response);
+				}
+			} else {
+				// TODO: should raise InterruptedException? this block is reached whenever the
+				// request is cancelled before its response is received
+			}
+		}
+	}
+
+	private void makeRequestWithRetries() throws ConnectException {
+		// This is an additional layer of retry logic lifted from droid-fu
+		// See:
+		// https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+		boolean retry = true;
+		IOException cause = null;
+		HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
+		while (retry) {
+			try {
+				makeRequest();
+				return;
+			} catch (IOException e) {
+				cause = e;
+				Log.w(TAG, "problem making request... retrying: " + e.getMessage());
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			} catch (NullPointerException e) {
+				// there's a bug in HttpClient 4.0.x that on some occasions causes
+				// DefaultRequestExecutor to throw an NPE, see
+				// http://code.google.com/p/android/issues/detail?id=5255
+				cause = new IOException("NPE in HttpClient " + e.getMessage());
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			}
+		}
+
+		// no retries left, crap out with exception
+		ConnectException ex = new ConnectException();
+		ex.initCause(cause);
+		throw ex;
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 32db4feb..27cf96a5 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -32,199 +32,210 @@
 import android.os.Looper;
 
 /**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
- * designed to be anonymously overridden with your own response handling code.
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(String)} method is designed to be anonymously overridden with your own response
+ * handling code.
  * <p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * Additionally, you can override the {@link #onFailure(Throwable, String)}, {@link #onStart()}, and
+ * {@link #onFinish()} methods as required.
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         // Successfully got a response
- *     }
+ * client.get(&quot;http://www.google.com&quot;, new AsyncHttpResponseHandler() {
+ * 	&#064;Override
+ * 	public void onStart() {
+ * 		// Initiated the request
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onSuccess(String response) {
+ * 		// Successfully got a response
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onFailure(Throwable e, String response) {
+ * 		// Response failed :(
+ * 	}
  * 
- *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
+ * 	&#064;Override
+ * 	public void onFinish() {
+ * 		// Completed the request (either success or failure)
+ * 	}
  * });
  * </pre>
  */
 public class AsyncHttpResponseHandler {
-    private static final int SUCCESS_MESSAGE = 0;
-    private static final int FAILURE_MESSAGE = 1;
-    private static final int START_MESSAGE = 2;
-    private static final int FINISH_MESSAGE = 3;
-
-    private Handler handler;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {}
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
-     */
-    public void onFinish() {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(String content) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    public void onFailure(Throwable error) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
-     */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int httpStatus, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, responseBody));
-    }
-
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    protected void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    protected void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(String responseBody) {
-        onSuccess(responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
-    }
-
-
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                handleSuccessMessage((String)msg.obj);
-                break;
-            case FAILURE_MESSAGE:
-                Object[] repsonse = (Object[])msg.obj;
-                handleFailureMessage((Throwable)repsonse[0], (String)repsonse[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
-        }
-    }
-
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = Message.obtain(); // The preferred way to get a new Message.
-            msg.what = responseMessage;
-            msg.obj = response;
-        }
-        return msg;
-    }
-
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toString(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, null);
-        }
-
-        /* According to http://developer.android.com/reference/org/apache/http/client/HttpResponseException.html
-         * This exception should be thrown for non HTTP 2** responses.
-         */
-        int httpStatus = status.getStatusCode();
-        if(httpStatus < 200 || 300 <= httpStatus) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(httpStatus, responseBody);
-        }
-    }
+	private static final int SUCCESS_MESSAGE = 0;
+	private static final int FAILURE_MESSAGE = 1;
+	private static final int START_MESSAGE = 2;
+	private static final int FINISH_MESSAGE = 3;
+
+	private Handler handler;
+
+	/**
+	 * Creates a new AsyncHttpResponseHandler
+	 */
+	public AsyncHttpResponseHandler() {
+		// Set up a handler to post events back to the correct thread if possible
+		if (Looper.myLooper() != null) {
+			handler = new Handler() {
+				public void handleMessage(Message msg) {
+					AsyncHttpResponseHandler.this.handleMessage(msg);
+				}
+			};
+		}
+	}
+
+	//
+	// Callbacks to be overridden, typically anonymously
+	//
+
+	/**
+	 * Fired when the request is started, override to handle in your own code
+	 */
+	public void onStart() {
+	}
+
+	/**
+	 * Fired in all cases when the request is finished, after both success and failure, override to
+	 * handle in your own code
+	 */
+	public void onFinish() {
+	}
+
+	/**
+	 * Fired when a request returns successfully, override to handle in your own code
+	 * 
+	 * @param content
+	 *            the body of the HTTP response from the server
+	 */
+	public void onSuccess(String content) {
+	}
+
+	/**
+	 * Fired when a request fails to complete, override to handle in your own code
+	 * 
+	 * @param error
+	 *            the underlying cause of the failure
+	 * @deprecated use {@link #onFailure(Throwable, String)}
+	 */
+	public void onFailure(Throwable error) {
+	}
+
+	/**
+	 * Fired when a request fails to complete, override to handle in your own code
+	 * 
+	 * @param error
+	 *            the underlying cause of the failure
+	 * @param content
+	 *            the response body, if any
+	 */
+	public void onFailure(Throwable error, String content) {
+		// By default, call the deprecated onFailure(Throwable) for compatibility
+		onFailure(error);
+	}
+
+	//
+	// Pre-processing of messages (executes in background threadpool thread)
+	//
+
+	protected void sendSuccessMessage(int httpStatus, String responseBody) {
+		sendMessage(obtainMessage(SUCCESS_MESSAGE, responseBody));
+	}
+
+	protected void sendFailureMessage(Throwable e, String responseBody) {
+		sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] { e, responseBody }));
+	}
+
+	protected void sendStartMessage() {
+		sendMessage(obtainMessage(START_MESSAGE, null));
+	}
+
+	protected void sendFinishMessage() {
+		sendMessage(obtainMessage(FINISH_MESSAGE, null));
+	}
+
+	//
+	// Pre-processing of messages (in original calling thread, typically the UI thread)
+	//
+
+	protected void handleSuccessMessage(String responseBody) {
+		onSuccess(responseBody);
+	}
+
+	protected void handleFailureMessage(Throwable e, String responseBody) {
+		onFailure(e, responseBody);
+	}
+
+	// Methods which emulate android's Handler and Message methods
+	protected void handleMessage(Message msg) {
+		switch (msg.what) {
+		case SUCCESS_MESSAGE:
+			handleSuccessMessage((String) msg.obj);
+			break;
+		case FAILURE_MESSAGE:
+			Object[] repsonse = (Object[]) msg.obj;
+			handleFailureMessage((Throwable) repsonse[0], (String) repsonse[1]);
+			break;
+		case START_MESSAGE:
+			onStart();
+			break;
+		case FINISH_MESSAGE:
+			onFinish();
+			break;
+		}
+	}
+
+	protected void sendMessage(Message msg) {
+		if (handler != null) {
+			handler.sendMessage(msg);
+		} else {
+			handleMessage(msg);
+		}
+	}
+
+	protected Message obtainMessage(int responseMessage, Object response) {
+		Message msg = null;
+		if (handler != null) {
+			msg = this.handler.obtainMessage(responseMessage, response);
+		} else {
+			msg = Message.obtain(); // The preferred way to get a new Message.
+			msg.what = responseMessage;
+			msg.obj = response;
+		}
+		return msg;
+	}
+
+	// Interface to AsyncHttpRequest
+	void sendResponseMessage(HttpResponse response) {
+		StatusLine status = response.getStatusLine();
+		String responseBody = null;
+		try {
+			HttpEntity entity = null;
+			HttpEntity temp = response.getEntity();
+			if (temp != null) {
+				entity = new BufferedHttpEntity(temp);
+			}
+			responseBody = EntityUtils.toString(entity);
+		} catch (IOException e) {
+			sendFailureMessage(e, null);
+		}
+
+		/*
+		 * According to
+		 * http://developer.android.com/reference/org/apache/http/client/HttpResponseException.html
+		 * This exception should be thrown for non HTTP 2** responses.
+		 */
+		int httpStatus = status.getStatusCode();
+		if (httpStatus < 200 || 300 <= httpStatus) {
+			sendFailureMessage(
+					new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()),
+					responseBody);
+		} else {
+			sendSuccessMessage(httpStatus, responseBody);
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 355a6a17..6a1c46e8 100644
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -24,85 +24,87 @@
 import org.json.JSONTokener;
 
 /**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
- * or {@link JSONArray}.
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
+ * automatic parsing into a {@link JSONObject} or {@link JSONArray}.
  * <p>
- * This class is designed to be passed to get, post, put and delete requests
- * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
- * methods anonymously overridden.
+ * This class is designed to be passed to get, post, put and delete requests with the
+ * {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)} methods anonymously overridden.
  * <p>
- * Additionally, you can override the other event methods from the 
- * parent class.
+ * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
+	//
+	// Callbacks to be overridden, typically anonymously
+	//
 
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {}
+	/**
+	 * Fired when a request returns successfully and contains a json object at the base of the
+	 * response string. Override to handle in your own code.
+	 * 
+	 * @param response
+	 *            the parsed json object found in the server response (if any)
+	 */
+	public void onSuccess(JSONObject response) {
+	}
 
+	/**
+	 * Fired when a request returns successfully and contains a json array at the base of the
+	 * response string. Override to handle in your own code.
+	 * 
+	 * @param response
+	 *            the parsed json array found in the server response (if any)
+	 */
+	public void onSuccess(JSONArray response) {
+	}
 
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(JSONArray response) {}
+	// Utility methods
+	@Override
+	protected void handleSuccessMessage(String responseBody) {
+		super.handleSuccessMessage(responseBody);
 
+		try {
+			Object jsonResponse = parseResponse(responseBody);
+			if (jsonResponse instanceof JSONObject) {
+				onSuccess((JSONObject) jsonResponse);
+			} else if (jsonResponse instanceof JSONArray) {
+				onSuccess((JSONArray) jsonResponse);
+			} else {
+				throw new JSONException("Unexpected type " + jsonResponse.getClass().getName());
+			}
+		} catch (JSONException e) {
+			onFailure(e, responseBody);
+		}
+	}
 
-    // Utility methods
-    @Override
-    protected void handleSuccessMessage(String responseBody) {
-        super.handleSuccessMessage(responseBody);
+	protected Object parseResponse(String responseBody) throws JSONException {
+		return new JSONTokener(responseBody).nextValue();
+	}
 
-        try {
-            Object jsonResponse = parseResponse(responseBody);
-            if(jsonResponse instanceof JSONObject) {
-                onSuccess((JSONObject)jsonResponse);
-            } else if(jsonResponse instanceof JSONArray) {
-                onSuccess((JSONArray)jsonResponse);
-            } else {
-                throw new JSONException("Unexpected type " + jsonResponse.getClass().getName());
-            }
-        } catch(JSONException e) {
-            onFailure(e, responseBody);
-        }
-    }
+	/**
+	 * Handle cases where a failure is returned as JSON
+	 */
+	public void onFailure(Throwable e, JSONObject errorResponse) {
+	}
 
-    protected Object parseResponse(String responseBody) throws JSONException {
-        return new JSONTokener(responseBody).nextValue();
-    }
+	public void onFailure(Throwable e, JSONArray errorResponse) {
+	}
 
-    /**
-     * Handle cases where a failure is returned as JSON
-     */
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
-    
-    @Override 
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        super.handleFailureMessage(e, responseBody);
-        if (responseBody != null) try {
-            Object jsonResponse = parseResponse(responseBody);
-            if(jsonResponse instanceof JSONObject) {
-                onFailure(e, (JSONObject)jsonResponse);
-            } else if(jsonResponse instanceof JSONArray) {
-                onFailure(e, (JSONArray)jsonResponse);
-            }
-        } 
-        catch(JSONException ex) {
-            onFailure(e, responseBody);
-        }
-        else {
-        	onFailure(e, "");
-        }
-    }
+	@Override
+	protected void handleFailureMessage(Throwable e, String responseBody) {
+		super.handleFailureMessage(e, responseBody);
+		if (responseBody != null)
+			try {
+				Object jsonResponse = parseResponse(responseBody);
+				if (jsonResponse instanceof JSONObject) {
+					onFailure(e, (JSONObject) jsonResponse);
+				} else if (jsonResponse instanceof JSONArray) {
+					onFailure(e, (JSONArray) jsonResponse);
+				}
+			} catch (JSONException ex) {
+				onFailure(e, responseBody);
+			}
+		else {
+			onFailure(e, "");
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/src/com/loopj/android/http/PersistentCookieStore.java
index 94076682..4922d515 100644
--- a/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/src/com/loopj/android/http/PersistentCookieStore.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -35,166 +35,165 @@
 import android.text.TextUtils;
 
 /**
- * A persistent cookie store which implements the Apache HttpClient
- * {@link CookieStore} interface. Cookies are stored and will persist on the
- * user's device between application sessions since they are serialized and
- * stored in {@link SharedPreferences}.
+ * A persistent cookie store which implements the Apache HttpClient {@link CookieStore} interface.
+ * Cookies are stored and will persist on the user's device between application sessions since they
+ * are serialized and stored in {@link SharedPreferences}.
  * <p>
- * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
- * regular old apache HttpClient/HttpContext if you prefer.
+ * Instances of this class are designed to be used with {@link AsyncHttpClient#setCookieStore}, but
+ * can also be used with a regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
-    private static final String COOKIE_PREFS = "CookiePrefsFile";
-    private static final String COOKIE_NAME_STORE = "names";
-    private static final String COOKIE_NAME_PREFIX = "cookie_";
-
-    private final ConcurrentHashMap<String, Cookie> cookies;
-    private final SharedPreferences cookiePrefs;
-
-    /**
-     * Construct a persistent cookie store.
-     */
-    public PersistentCookieStore(Context context) {
-        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
-
-        // Load any previously stored cookies into the store
-        String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if(storedCookieNames != null) {
-            String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for(String name : cookieNames) {
-                String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if(encodedCookie != null) {
-                    Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if(decodedCookie != null) {
-                        cookies.put(name, decodedCookie);
-                    }
-                }
-            }
-
-            // Clear out expired cookies
-            clearExpired(new Date());
-        }
-    }
-
-    @Override
-    public void addCookie(Cookie cookie) {
-        String name = cookie.getName();
-
-        // Save cookie into local store, or remove if expired
-        if(!cookie.isExpired(new Date())) {
-            cookies.put(name, cookie);
-        } else {
-            cookies.remove(name);
-        }
-
-        // Save cookie into persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));
-        prefsWriter.commit();
-    }
-
-    @Override
-    public void clear() {
-        // Clear cookies from local store
-        cookies.clear();
-
-        // Clear cookies from persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for(String name : cookies.keySet()) {
-            prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-        }
-        prefsWriter.remove(COOKIE_NAME_STORE);
-        prefsWriter.commit();
-    }
-
-    @Override
-    public boolean clearExpired(Date date) {
-        boolean clearedAny = false;
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-
-        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
-            String name = entry.getKey();
-            Cookie cookie = entry.getValue();
-            if(cookie.isExpired(date)) {
-                // Clear cookies from local store
-                cookies.remove(name);
-
-                // Clear cookies from persistent store
-                prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-
-                // We've cleared at least one
-                clearedAny = true;
-            }
-        }
-
-        // Update names in persistent store
-        if(clearedAny) {
-            prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        }
-        prefsWriter.commit();
-
-        return clearedAny;
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
-    }
-
-
-    //
-    // Cookie serialization/deserialization
-    //
-
-    protected String encodeCookie(SerializableCookie cookie) {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        try {
-            ObjectOutputStream outputStream = new ObjectOutputStream(os);
-            outputStream.writeObject(cookie);
-        } catch (Exception e) {
-            return null;
-        }
-
-        return byteArrayToHexString(os.toByteArray());
-    }
-
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
-        Cookie cookie = null;
-        try {
-           ObjectInputStream ois = new ObjectInputStream(is);
-           cookie = ((SerializableCookie)ois.readObject()).getCookie();
-        } catch (Exception e) {
-           e.printStackTrace();
-        }
-
-        return cookie;
-    }
-
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuffer sb = new StringBuffer(b.length * 2);
-        for (byte element : b) {
-            int v = element & 0xff;
-            if(v < 16) {
-                sb.append('0');
-            }
-            sb.append(Integer.toHexString(v));
-        }
-        return sb.toString().toUpperCase();
-    }
-
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
-        byte[] data = new byte[len / 2];
-        for(int i=0; i<len; i+=2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
-        }
-        return data;
-    }
+	private static final String COOKIE_PREFS = "CookiePrefsFile";
+	private static final String COOKIE_NAME_STORE = "names";
+	private static final String COOKIE_NAME_PREFIX = "cookie_";
+
+	private final ConcurrentHashMap<String, Cookie> cookies;
+	private final SharedPreferences cookiePrefs;
+
+	/**
+	 * Construct a persistent cookie store.
+	 */
+	public PersistentCookieStore(Context context) {
+		cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
+		cookies = new ConcurrentHashMap<String, Cookie>();
+
+		// Load any previously stored cookies into the store
+		String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
+		if (storedCookieNames != null) {
+			String[] cookieNames = TextUtils.split(storedCookieNames, ",");
+			for (String name : cookieNames) {
+				String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
+				if (encodedCookie != null) {
+					Cookie decodedCookie = decodeCookie(encodedCookie);
+					if (decodedCookie != null) {
+						cookies.put(name, decodedCookie);
+					}
+				}
+			}
+
+			// Clear out expired cookies
+			clearExpired(new Date());
+		}
+	}
+
+	@Override
+	public void addCookie(Cookie cookie) {
+		String name = cookie.getName();
+
+		// Save cookie into local store, or remove if expired
+		if (!cookie.isExpired(new Date())) {
+			cookies.put(name, cookie);
+		} else {
+			cookies.remove(name);
+		}
+
+		// Save cookie into persistent store
+		SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+		prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+		prefsWriter.putString(COOKIE_NAME_PREFIX + name,
+				encodeCookie(new SerializableCookie(cookie)));
+		prefsWriter.commit();
+	}
+
+	@Override
+	public void clear() {
+		// Clear cookies from local store
+		cookies.clear();
+
+		// Clear cookies from persistent store
+		SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+		for (String name : cookies.keySet()) {
+			prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+		}
+		prefsWriter.remove(COOKIE_NAME_STORE);
+		prefsWriter.commit();
+	}
+
+	@Override
+	public boolean clearExpired(Date date) {
+		boolean clearedAny = false;
+		SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+
+		for (ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+			String name = entry.getKey();
+			Cookie cookie = entry.getValue();
+			if (cookie.isExpired(date)) {
+				// Clear cookies from local store
+				cookies.remove(name);
+
+				// Clear cookies from persistent store
+				prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+
+				// We've cleared at least one
+				clearedAny = true;
+			}
+		}
+
+		// Update names in persistent store
+		if (clearedAny) {
+			prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+		}
+		prefsWriter.commit();
+
+		return clearedAny;
+	}
+
+	@Override
+	public List<Cookie> getCookies() {
+		return new ArrayList<Cookie>(cookies.values());
+	}
+
+	//
+	// Cookie serialization/deserialization
+	//
+
+	protected String encodeCookie(SerializableCookie cookie) {
+		ByteArrayOutputStream os = new ByteArrayOutputStream();
+		try {
+			ObjectOutputStream outputStream = new ObjectOutputStream(os);
+			outputStream.writeObject(cookie);
+		} catch (Exception e) {
+			return null;
+		}
+
+		return byteArrayToHexString(os.toByteArray());
+	}
+
+	protected Cookie decodeCookie(String cookieStr) {
+		byte[] bytes = hexStringToByteArray(cookieStr);
+		ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+		Cookie cookie = null;
+		try {
+			ObjectInputStream ois = new ObjectInputStream(is);
+			cookie = ((SerializableCookie) ois.readObject()).getCookie();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+		return cookie;
+	}
+
+	// Using some super basic byte array <-> hex conversions so we don't have
+	// to rely on any large Base64 libraries. Can be overridden if you like!
+	protected String byteArrayToHexString(byte[] b) {
+		StringBuffer sb = new StringBuffer(b.length * 2);
+		for (byte element : b) {
+			int v = element & 0xff;
+			if (v < 16) {
+				sb.append('0');
+			}
+			sb.append(Integer.toHexString(v));
+		}
+		return sb.toString().toUpperCase();
+	}
+
+	protected byte[] hexStringToByteArray(String s) {
+		int len = s.length();
+		byte[] data = new byte[len / 2];
+		for (int i = 0; i < len; i += 2) {
+			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(
+					s.charAt(i + 1), 16));
+		}
+		return data;
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index e976a16f..e56d5748 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -34,225 +34,253 @@
 import org.apache.http.message.BasicNameValuePair;
 
 /**
- * A collection of string request parameters or files to send along with
- * requests made from an {@link AsyncHttpClient} instance.
+ * A collection of string request parameters or files to send along with requests made from an
+ * {@link AsyncHttpClient} instance.
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * RequestParams params = new RequestParams();
- * params.put("username", "james");
- * params.put("password", "123456");
- * params.put("email", "my&#064;email.com");
- * params.put("profile_picture", new File("pic.jpg")); // Upload a File
- * params.put("profile_picture2", someInputStream); // Upload an InputStream
- * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- *
+ * params.put(&quot;username&quot;, &quot;james&quot;);
+ * params.put(&quot;password&quot;, &quot;123456&quot;);
+ * params.put(&quot;email&quot;, &quot;my@email.com&quot;);
+ * params.put(&quot;profile_picture&quot;, new File(&quot;pic.jpg&quot;)); // Upload a File
+ * params.put(&quot;profile_picture2&quot;, someInputStream); // Upload an InputStream
+ * params.put(&quot;profile_picture3&quot;, new ByteArrayInputStream(someBytes)); // Upload some bytes
+ * 
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.post("http://myendpoint.com", params, responseHandler);
+ * client.post(&quot;http://myendpoint.com&quot;, params, responseHandler);
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
-
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-
-    /**
-     * Constructs a new empty <code>RequestParams</code> instance.
-     */
-    public RequestParams() {
-        init();
-    }
-
-    /**
-     * Constructs a new RequestParams instance containing the key/value
-     * string params from the specified map.
-     * @param source the source key/value string map to add.
-     */
-    public RequestParams(Map<String, String> source) {
-        init();
-
-        for(Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with a single
-     * initial key/value string param.
-     * @param key the key name for the intial param.
-     * @param value the value string for the initial param.
-     */
-    public RequestParams(String key, String value) {
-        init();
-
-        put(key, value);
-    }
-
-    /**
-     * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
-     * @param value the value string for the new param.
-     */
-    public void put(String key, String value){
-        if(key != null && value != null) {
-            urlParams.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a file to the request.
-     * @param key the key name for the new param.
-     * @param file the file to add.
-     */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     */
-    public void put(String key, InputStream stream) {
-        put(key, stream, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     * @param contentType the content type of the file, eg. application/json
-     */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
-        }
-    }
-
-    /**
-     * Removes a parameter from the request.
-     * @param key the key name for the parameter to remove.
-     */
-    public void remove(String key){
-        urlParams.remove(key);
-        fileParams.remove(key);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append(entry.getValue());
-        }
-
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("FILE");
-        }
-
-        return result.toString();
-    }
- 
-   /**
-     * Returns an HttpEntity containing all request parameters
-     */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
-
-        if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
-
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
-
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                	boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
-            }
-
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            }
-        }
-
-        return entity;
-    }
-
-    private void init(){
-        urlParams = new ConcurrentHashMap<String, String>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-    }
-
-    protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
-
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        return lparams;
-    }
-
-    protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
-    }
-
-    private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
-        public String contentType;
-
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
-            this.contentType = contentType;
-        }
-
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
-        }
-    }
+	private static String ENCODING = "UTF-8";
+
+	protected ConcurrentHashMap<String, String> urlParams;
+	protected ConcurrentHashMap<String, FileWrapper> fileParams;
+
+	/**
+	 * Constructs a new empty <code>RequestParams</code> instance.
+	 */
+	public RequestParams() {
+		init();
+	}
+
+	/**
+	 * Constructs a new RequestParams instance containing the key/value string params from the
+	 * specified map.
+	 * 
+	 * @param source
+	 *            the source key/value string map to add.
+	 */
+	public RequestParams(Map<String, String> source) {
+		init();
+
+		for (Map.Entry<String, String> entry : source.entrySet()) {
+			put(entry.getKey(), entry.getValue());
+		}
+	}
+
+	/**
+	 * Constructs a new RequestParams instance and populate it with a single initial key/value
+	 * string param.
+	 * 
+	 * @param key
+	 *            the key name for the intial param.
+	 * @param value
+	 *            the value string for the initial param.
+	 */
+	public RequestParams(String key, String value) {
+		init();
+
+		put(key, value);
+	}
+
+	/**
+	 * Adds a key/value string pair to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param value
+	 *            the value string for the new param.
+	 */
+	public void put(String key, String value) {
+		if (key != null && value != null) {
+			urlParams.put(key, value);
+		}
+	}
+
+	/**
+	 * Adds a file to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param file
+	 *            the file to add.
+	 */
+	public void put(String key, File file) throws FileNotFoundException {
+		put(key, new FileInputStream(file), file.getName());
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 */
+	public void put(String key, InputStream stream) {
+		put(key, stream, null);
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 * @param fileName
+	 *            the name of the file.
+	 */
+	public void put(String key, InputStream stream, String fileName) {
+		put(key, stream, fileName, null);
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 * @param fileName
+	 *            the name of the file.
+	 * @param contentType
+	 *            the content type of the file, eg. application/json
+	 */
+	public void put(String key, InputStream stream, String fileName, String contentType) {
+		if (key != null && stream != null) {
+			fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+		}
+	}
+
+	/**
+	 * Removes a parameter from the request.
+	 * 
+	 * @param key
+	 *            the key name for the parameter to remove.
+	 */
+	public void remove(String key) {
+		urlParams.remove(key);
+		fileParams.remove(key);
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder result = new StringBuilder();
+		for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+			if (result.length() > 0)
+				result.append("&");
+
+			result.append(entry.getKey());
+			result.append("=");
+			result.append(entry.getValue());
+		}
+
+		for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+			if (result.length() > 0)
+				result.append("&");
+
+			result.append(entry.getKey());
+			result.append("=");
+			result.append("FILE");
+		}
+
+		return result.toString();
+	}
+
+	/**
+	 * Returns an HttpEntity containing all request parameters
+	 */
+	public HttpEntity getEntity() {
+		HttpEntity entity = null;
+
+		if (!fileParams.isEmpty()) {
+			SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+
+			// Add string params
+			for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+				multipartEntity.addPart(entry.getKey(), entry.getValue());
+			}
+
+			// Add file params
+			int currentIndex = 0;
+			int lastIndex = fileParams.entrySet().size() - 1;
+			for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+				FileWrapper file = entry.getValue();
+				if (file.inputStream != null) {
+					boolean isLast = currentIndex == lastIndex;
+					if (file.contentType != null) {
+						multipartEntity.addPart(entry.getKey(), file.getFileName(),
+								file.inputStream, file.contentType, isLast);
+					} else {
+						multipartEntity.addPart(entry.getKey(), file.getFileName(),
+								file.inputStream, isLast);
+					}
+				}
+				currentIndex++;
+			}
+
+			entity = multipartEntity;
+		} else {
+			try {
+				entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
+			} catch (UnsupportedEncodingException e) {
+				e.printStackTrace();
+			}
+		}
+
+		return entity;
+	}
+
+	private void init() {
+		urlParams = new ConcurrentHashMap<String, String>();
+		fileParams = new ConcurrentHashMap<String, FileWrapper>();
+	}
+
+	protected List<BasicNameValuePair> getParamsList() {
+		List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+
+		for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+			lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
+		}
+
+		return lparams;
+	}
+
+	protected String getParamString() {
+		return URLEncodedUtils.format(getParamsList(), ENCODING);
+	}
+
+	private static class FileWrapper {
+		public InputStream inputStream;
+		public String fileName;
+		public String contentType;
+
+		public FileWrapper(InputStream inputStream, String fileName, String contentType) {
+			this.inputStream = inputStream;
+			this.fileName = fileName;
+			this.contentType = contentType;
+		}
+
+		public String getFileName() {
+			if (fileName != null) {
+				return fileName;
+			} else {
+				return "nofilename";
+			}
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/RetryHandler.java b/src/com/loopj/android/http/RetryHandler.java
index 37b74344..953a7b9f 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/src/com/loopj/android/http/RetryHandler.java
@@ -14,12 +14,12 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 /*
-    Some of the retry logic in this class is heavily borrowed from the
-    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
-*/
+ Some of the retry logic in this class is heavily borrowed from the
+ fantastic droid-fu project: https://github.com/donnfelker/droid-fu
+ */
 
 package com.loopj.android.http;
 
@@ -40,66 +40,67 @@
 import android.os.SystemClock;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
-
-    static {
-        // Retry if the server dropped connection on us
-        exceptionWhitelist.add(NoHttpResponseException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(UnknownHostException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(SocketException.class);
-
-        // never retry timeouts
-        exceptionBlacklist.add(InterruptedIOException.class);
-        // never retry SSL handshake failures
-        exceptionBlacklist.add(SSLHandshakeException.class);
-    }
-
-    private final int maxRetries;
-
-    public RetryHandler(int maxRetries) {
-        this.maxRetries = maxRetries;
-    }
-
-    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-        boolean retry;
-
-        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
-
-        if(executionCount > maxRetries) {
-            // Do not retry if over max retry count
-            retry = false;
-        } else if (exceptionBlacklist.contains(exception.getClass())) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
-        } else if (exceptionWhitelist.contains(exception.getClass())) {
-            // immediately retry if error is whitelisted
-            retry = true;
-        } else if (!sent) {
-            // for most other errors, retry only if request hasn't been fully sent yet
-            retry = true;
-        } else {
-            // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
-            String requestType = currentReq.getMethod();
-            if(!requestType.equals("POST")) {
-                retry = true;
-            } else {
-                // otherwise do not retry
-                retry = false;
-            }
-        }
-
-        if(retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
-        } else {
-            exception.printStackTrace();
-        }
-
-        return retry;
-    }
+	private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
+	private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+	private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+
+	static {
+		// Retry if the server dropped connection on us
+		exceptionWhitelist.add(NoHttpResponseException.class);
+		// retry-this, since it may happens as part of a Wi-Fi to 3G failover
+		exceptionWhitelist.add(UnknownHostException.class);
+		// retry-this, since it may happens as part of a Wi-Fi to 3G failover
+		exceptionWhitelist.add(SocketException.class);
+
+		// never retry timeouts
+		exceptionBlacklist.add(InterruptedIOException.class);
+		// never retry SSL handshake failures
+		exceptionBlacklist.add(SSLHandshakeException.class);
+	}
+
+	private final int maxRetries;
+
+	public RetryHandler(int maxRetries) {
+		this.maxRetries = maxRetries;
+	}
+
+	public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
+		boolean retry;
+
+		Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
+		boolean sent = (b != null && b.booleanValue());
+
+		if (executionCount > maxRetries) {
+			// Do not retry if over max retry count
+			retry = false;
+		} else if (exceptionBlacklist.contains(exception.getClass())) {
+			// immediately cancel retry if the error is blacklisted
+			retry = false;
+		} else if (exceptionWhitelist.contains(exception.getClass())) {
+			// immediately retry if error is whitelisted
+			retry = true;
+		} else if (!sent) {
+			// for most other errors, retry only if request hasn't been fully sent yet
+			retry = true;
+		} else {
+			// resend all idempotent requests
+			HttpUriRequest currentReq = (HttpUriRequest) context
+					.getAttribute(ExecutionContext.HTTP_REQUEST);
+			String requestType = currentReq.getMethod();
+			if (!requestType.equals("POST")) {
+				retry = true;
+			} else {
+				// otherwise do not retry
+				retry = false;
+			}
+		}
+
+		if (retry) {
+			SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+		} else {
+			exception.printStackTrace();
+		}
+
+		return retry;
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/src/com/loopj/android/http/SerializableCookie.java
index cc12993c..3562938f 100644
--- a/src/com/loopj/android/http/SerializableCookie.java
+++ b/src/com/loopj/android/http/SerializableCookie.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -28,47 +28,47 @@
 import org.apache.http.impl.cookie.BasicClientCookie;
 
 /**
- * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
- * designed for use in {@link PersistentCookieStore}.
+ * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie} designed for use in
+ * {@link PersistentCookieStore}.
  */
 public class SerializableCookie implements Serializable {
-    private static final long serialVersionUID = 6374381828722046732L;
+	private static final long serialVersionUID = 6374381828722046732L;
 
-    private transient final Cookie cookie;
-    private transient BasicClientCookie clientCookie;
+	private transient final Cookie cookie;
+	private transient BasicClientCookie clientCookie;
 
-    public SerializableCookie(Cookie cookie) {
-        this.cookie = cookie;
-    }
+	public SerializableCookie(Cookie cookie) {
+		this.cookie = cookie;
+	}
 
-    public Cookie getCookie() {
-        Cookie bestCookie = cookie;
-        if(clientCookie != null) {
-            bestCookie = clientCookie;
-        }
-        return bestCookie;
-    }
+	public Cookie getCookie() {
+		Cookie bestCookie = cookie;
+		if (clientCookie != null) {
+			bestCookie = clientCookie;
+		}
+		return bestCookie;
+	}
 
-    private void writeObject(ObjectOutputStream out) throws IOException {
-        out.writeObject(cookie.getName());
-        out.writeObject(cookie.getValue());
-        out.writeObject(cookie.getComment());
-        out.writeObject(cookie.getDomain());
-        out.writeObject(cookie.getExpiryDate());
-        out.writeObject(cookie.getPath());
-        out.writeInt(cookie.getVersion());
-        out.writeBoolean(cookie.isSecure());
-    }
+	private void writeObject(ObjectOutputStream out) throws IOException {
+		out.writeObject(cookie.getName());
+		out.writeObject(cookie.getValue());
+		out.writeObject(cookie.getComment());
+		out.writeObject(cookie.getDomain());
+		out.writeObject(cookie.getExpiryDate());
+		out.writeObject(cookie.getPath());
+		out.writeInt(cookie.getVersion());
+		out.writeBoolean(cookie.isSecure());
+	}
 
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String)in.readObject();
-        String value = (String)in.readObject();
-        clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String)in.readObject());
-        clientCookie.setDomain((String)in.readObject());
-        clientCookie.setExpiryDate((Date)in.readObject());
-        clientCookie.setPath((String)in.readObject());
-        clientCookie.setVersion(in.readInt());
-        clientCookie.setSecure(in.readBoolean());
-    }
+	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+		String name = (String) in.readObject();
+		String value = (String) in.readObject();
+		clientCookie = new BasicClientCookie(name, value);
+		clientCookie.setComment((String) in.readObject());
+		clientCookie.setDomain((String) in.readObject());
+		clientCookie.setExpiryDate((Date) in.readObject());
+		clientCookie.setPath((String) in.readObject());
+		clientCookie.setVersion(in.readInt());
+		clientCookie.setSecure(in.readBoolean());
+	}
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index 42fdebf2..2815156c 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -14,12 +14,12 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 /*
-    This code is taken from Rafael Sanches' blog.
-    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
-*/
+ This code is taken from Rafael Sanches' blog.
+ http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
+ */
 
 package com.loopj.android.http;
 
@@ -38,148 +38,150 @@
 import org.apache.http.message.BasicHeader;
 
 class SimpleMultipartEntity implements HttpEntity {
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
-
-    private String boundary = null;
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
-
-    public SimpleMultipartEntity() {
-        final StringBuffer buf = new StringBuffer();
-        final Random rand = new Random();
-        for (int i = 0; i < 30; i++) {
-            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
-        }
-        this.boundary = buf.toString();
-
-    }
-
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
-            try {
-                out.write(("--" + boundary + "\r\n").getBytes());
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        isSetFirst = true;
-    }
-
-    public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
-            return;
-        }
-
-        try {
-            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-
-        isSetLast = true;
-    }
-
-    public void addPart(final String key, final String value) {
-        writeFirstBoundaryIfNeeds();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
-    }
-
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeFirstBoundaryIfNeeds();
-        try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
-
-            final byte[] tmp = new byte[4096];
-            int l = 0;
-            while ((l = fin.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-            }
-            if(!isLast)
-            	out.write(("\r\n--" + boundary + "\r\n").getBytes());
-            out.flush();
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                fin.close();
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
-    }
-
-    @Override
-    public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
-    }
-
-    @Override
-    public boolean isChunked() {
-        return false;
-    }
-
-    @Override
-    public boolean isRepeatable() {
-        return false;
-    }
-
-    @Override
-    public boolean isStreaming() {
-        return false;
-    }
-
-    @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        outstream.write(out.toByteArray());
-    }
-
-    @Override
-    public Header getContentEncoding() {
-        return null;
-    }
-
-    @Override
-    public void consumeContent() throws IOException,
-    UnsupportedOperationException {
-        if (isStreaming()) {
-            throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
-        }
-    }
-
-    @Override
-    public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-        return new ByteArrayInputStream(out.toByteArray());
-    }
+	private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
+			.toCharArray();
+
+	private String boundary = null;
+
+	ByteArrayOutputStream out = new ByteArrayOutputStream();
+	boolean isSetLast = false;
+	boolean isSetFirst = false;
+
+	public SimpleMultipartEntity() {
+		final StringBuffer buf = new StringBuffer();
+		final Random rand = new Random();
+		for (int i = 0; i < 30; i++) {
+			buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
+		}
+		this.boundary = buf.toString();
+
+	}
+
+	public void writeFirstBoundaryIfNeeds() {
+		if (!isSetFirst) {
+			try {
+				out.write(("--" + boundary + "\r\n").getBytes());
+			} catch (final IOException e) {
+				e.printStackTrace();
+			}
+		}
+
+		isSetFirst = true;
+	}
+
+	public void writeLastBoundaryIfNeeds() {
+		if (isSetLast) {
+			return;
+		}
+
+		try {
+			out.write(("\r\n--" + boundary + "--\r\n").getBytes());
+		} catch (final IOException e) {
+			e.printStackTrace();
+		}
+
+		isSetLast = true;
+	}
+
+	public void addPart(final String key, final String value) {
+		writeFirstBoundaryIfNeeds();
+		try {
+			out.write(("Content-Disposition: form-data; name=\"" + key + "\"\r\n\r\n").getBytes());
+			out.write(value.getBytes());
+			out.write(("\r\n--" + boundary + "\r\n").getBytes());
+		} catch (final IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void addPart(final String key, final String fileName, final InputStream fin,
+			final boolean isLast) {
+		addPart(key, fileName, fin, "application/octet-stream", isLast);
+	}
+
+	public void addPart(final String key, final String fileName, final InputStream fin,
+			String type, final boolean isLast) {
+		writeFirstBoundaryIfNeeds();
+		try {
+			type = "Content-Type: " + type + "\r\n";
+			out.write(("Content-Disposition: form-data; name=\"" + key + "\"; filename=\""
+					+ fileName + "\"\r\n").getBytes());
+			out.write(type.getBytes());
+			out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+
+			final byte[] tmp = new byte[4096];
+			int l = 0;
+			while ((l = fin.read(tmp)) != -1) {
+				out.write(tmp, 0, l);
+			}
+			if (!isLast)
+				out.write(("\r\n--" + boundary + "\r\n").getBytes());
+			out.flush();
+		} catch (final IOException e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				fin.close();
+			} catch (final IOException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	public void addPart(final String key, final File value, final boolean isLast) {
+		try {
+			addPart(key, value.getName(), new FileInputStream(value), isLast);
+		} catch (final FileNotFoundException e) {
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public long getContentLength() {
+		writeLastBoundaryIfNeeds();
+		return out.toByteArray().length;
+	}
+
+	@Override
+	public Header getContentType() {
+		return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+	}
+
+	@Override
+	public boolean isChunked() {
+		return false;
+	}
+
+	@Override
+	public boolean isRepeatable() {
+		return false;
+	}
+
+	@Override
+	public boolean isStreaming() {
+		return false;
+	}
+
+	@Override
+	public void writeTo(final OutputStream outstream) throws IOException {
+		outstream.write(out.toByteArray());
+	}
+
+	@Override
+	public Header getContentEncoding() {
+		return null;
+	}
+
+	@Override
+	public void consumeContent() throws IOException, UnsupportedOperationException {
+		if (isStreaming()) {
+			throw new UnsupportedOperationException(
+					"Streaming entity does not implement #consumeContent()");
+		}
+	}
+
+	@Override
+	public InputStream getContent() throws IOException, UnsupportedOperationException {
+		return new ByteArrayInputStream(out.toByteArray());
+	}
 }
\ No newline at end of file
