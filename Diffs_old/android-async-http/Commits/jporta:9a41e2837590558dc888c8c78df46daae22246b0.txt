diff --git a/.travis.yml b/.travis.yml
index a7560a7b..69ae732e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -16,28 +16,23 @@ before_install:
   # for gradle output style
   - export TERM=dumb
   # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.8-bin.zip
-  - unzip -qq gradle-1.8-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.8
+  - wget http://services.gradle.org/distributions/gradle-1.10-bin.zip
+  - unzip -qq gradle-1.10-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.10
   - export PATH=$GRADLE_HOME/bin:$PATH
   # just to test gradle version, against our provided one
   - gradle -v
-  # newest android SDK 22.0.5
-  - wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz
-  - tar -zxf android-sdk_r22.0.5-linux.tgz
+  # newest android SDK 22.3
+  - wget http://dl.google.com/android/android-sdk_r22.3-linux.tgz
+  - tar -zxf android-sdk_r22.3-linux.tgz
   - export ANDROID_HOME=`pwd`/android-sdk-linux
   - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
   # manually set sdk.dir variable, according to local paths
   - echo "sdk.dir=$ANDROID_HOME" > local.properties
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-18 --force --no-ui
-  # build tools cannot be installed through "android update sdk" as of now
-  - wget http://dl.google.com/android/repository/build-tools_r18.0.1-linux.zip
-  - mkdir -p $ANDROID_HOME/build-tools
-  - unzip -qq build-tools_r18.0.1-linux.zip -d $ANDROID_HOME/build-tools/
-  - mv $ANDROID_HOME/build-tools/android-4.3 $ANDROID_HOME/build-tools/18.0.1
-  # verify files exist in right paths
-  - find $ANDROID_HOME/build-tools
-  - file $ANDROID_HOME/build-tools/18.0.1/aapt
+  # list packages for debug purpose
+  - android list sdk -a -e -u
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.1 --force --no-ui
+  # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
 
diff --git a/README.md b/README.md
index 2dd17dd7..fe5fed6b 100644
--- a/README.md
+++ b/README.md
@@ -29,7 +29,7 @@ https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/androi
 Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
 ArtifactId: async-http-client
-Version: 1.4.4-SNAPSHOT
+Version: 1.4.5-SNAPSHOT
 Packaging: JAR or AAR
 ```
 
@@ -49,3 +49,7 @@ Documentation, Features and Examples
 Full details and documentation can be found on the project page here:
 
 http://loopj.com/android-async-http/
+
+
+[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/loopj/android-async-http/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
+
diff --git a/build.gradle b/build.gradle
index 9fe1e6ad..ca484909 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.6.+'
+        classpath 'com.android.tools.build:gradle:+'
     }
 }
 
@@ -14,7 +14,7 @@ def isReleaseBuild() {
 
 allprojects {
     group = 'com.loopj.android'
-    version = '1.4.4'
+    version = '1.4.5-SNAPSHOT'
 
     repositories {
         mavenCentral()
diff --git a/gradle.properties b/gradle.properties
index 2c0fb8c8..faf4d955 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
-VERSION_NAME=1.4.4
-VERSION_CODE=144
+VERSION_NAME=1.4.5-SNAPSHOT
+VERSION_CODE=145
 GROUP=com.loopj.android
 
 POM_DESCRIPTION=An Asynchronous HTTP Library for Android
diff --git a/library/build.gradle b/library/build.gradle
index 30abc6b2..e7b17970 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,15 +1,16 @@
 apply plugin: 'android-library'
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion '18.0.1'
+    compileSdkVersion 19
+    buildToolsVersion '19.0.1'
 
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
+    defaultConfig {
+        minSdkVersion 3
+        targetSdkVersion 19
+    }
+    
+    lintOptions {
+        abortOnError false
     }
 }
 
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
deleted file mode 100644
index 51177c93..00000000
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package com.loopj.android.http;
-
-import android.content.Context;
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-
-public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
-
-    private File mFile;
-    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
-
-    public FileAsyncHttpResponseHandler(File file) {
-        super();
-        assert (file != null);
-        this.mFile = file;
-    }
-
-    public FileAsyncHttpResponseHandler(Context c) {
-        super();
-        assert (c != null);
-        this.mFile = getTemporaryFile(c);
-    }
-
-    protected File getTemporaryFile(Context c) {
-        try {
-            return File.createTempFile("temp_", "_handled", c.getCacheDir());
-        } catch (Throwable t) {
-            Log.e(LOG_TAG, "Cannot create temporary file", t);
-        }
-        return null;
-    }
-
-    protected File getTargetFile() {
-        assert (mFile != null);
-        return mFile;
-    }
-
-    public void onSuccess(File file) {
-    }
-
-    public void onSuccess(int statusCode, File file) {
-        onSuccess(file);
-    }
-
-    public void onSuccess(int statusCode, Header[] headers, File file) {
-        onSuccess(statusCode, file);
-    }
-
-    public void onFailure(Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e);
-    }
-
-    public void onFailure(int statusCode, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e, response);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(statusCode, e, response);
-    }
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        onFailure(statusCode, headers, error, getTargetFile());
-    }
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        onSuccess(statusCode, headers, getTargetFile());
-    }
-
-    @Override
-    byte[] getResponseData(HttpEntity entity) throws IOException {
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            long contentLength = entity.getContentLength();
-            FileOutputStream buffer = new FileOutputStream(getTargetFile());
-            if (instream != null) {
-                try {
-                    byte[] tmp = new byte[BUFFER_SIZE];
-                    int l, count = 0;
-                    // do not send messages if request has been cancelled
-                    while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                        count += l;
-                        buffer.write(tmp, 0, l);
-                        sendProgressMessage(count, (int) contentLength);
-                    }
-                } finally {
-                    instream.close();
-                    buffer.flush();
-                    buffer.close();
-                }
-            }
-        }
-        return null;
-    }
-
-}
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/com/loopj/android/http/MySSLSocketFactory.java
deleted file mode 100644
index eb4aa97e..00000000
--- a/library/src/com/loopj/android/http/MySSLSocketFactory.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package com.loopj.android.http;
-
-import org.apache.http.conn.ssl.SSLSocketFactory;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.security.KeyManagementException;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.UnrecoverableKeyException;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
- * http://code.google.com/p/android/issues/detail?id=13117#c14
- */
-public class MySSLSocketFactory extends SSLSocketFactory {
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-
-    public MySSLSocketFactory(KeyStore truststore)
-            throws NoSuchAlgorithmException, KeyManagementException,
-            KeyStoreException, UnrecoverableKeyException {
-        super(truststore);
-
-        TrustManager tm = new X509TrustManager() {
-            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
-                return null;
-            }
-
-            @Override
-            public void checkClientTrusted(
-                    java.security.cert.X509Certificate[] chain, String authType)
-                    throws java.security.cert.CertificateException {
-            }
-
-            @Override
-            public void checkServerTrusted(
-                    java.security.cert.X509Certificate[] chain, String authType)
-                    throws java.security.cert.CertificateException {
-            }
-        };
-        sslContext.init(null, new TrustManager[]{tm}, null);
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
-        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return sslContext.getSocketFactory().createSocket();
-    }
-
-    public static KeyStore getKeystore() {
-        KeyStore trustStore = null;
-        try {
-            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
-            trustStore.load(null, null);
-        } catch (Throwable t) {
-            t.printStackTrace();
-        }
-        return trustStore;
-    }
-
-    public static SSLSocketFactory getFixedSocketFactory() {
-        SSLSocketFactory socketFactory;
-        try {
-            socketFactory = new MySSLSocketFactory(getKeystore());
-            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
-        } catch (Throwable t) {
-            t.printStackTrace();
-            socketFactory = SSLSocketFactory.getSocketFactory();
-        }
-        return socketFactory;
-    }
-
-}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/com/loopj/android/http/TextHttpResponseHandler.java
deleted file mode 100644
index bf93d843..00000000
--- a/library/src/com/loopj/android/http/TextHttpResponseHandler.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
- * {@link #onSuccess(String)} method is designed to be anonymously overridden with your own response
- * handling code. <p>&nbsp;</p> Additionally, you can override the {@link #onFailure(String,
- * Throwable)}, {@link #onStart()}, and {@link #onFinish()} methods as required. <p>&nbsp;</p> For
- * example: <p>&nbsp;</p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new TextHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String responseBody) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(String responseBody, Throwable e) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
-    private static final String LOG_TAG = "TextHttpResponseHandler";
-
-    /**
-     * Creates a new TextHttpResponseHandler
-     */
-
-    public TextHttpResponseHandler() {
-        this(DEFAULT_CHARSET);
-    }
-
-    public TextHttpResponseHandler(String encoding) {
-        super();
-        setCharset(encoding);
-    }
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
-     */
-    public void onFailure(String responseBody, Throwable error) {
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
-     */
-    public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
-        onFailure(responseBody, error);
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the body of the HTTP response from the server
-     */
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
-            onFailure(0, headers, (String) null, e);
-        }
-    }
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, response, error);
-        } catch (UnsupportedEncodingException e) {
-            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
-            onFailure(0, headers, (String) null, e);
-        }
-    }
-
-}
diff --git a/library/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
similarity index 68%
rename from library/AndroidManifest.xml
rename to library/src/main/AndroidManifest.xml
index 0705929f..f45dcd47 100644
--- a/library/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.4"
-    android:versionCode="144">
-
-    <uses-sdk
-        android:minSdkVersion="3" />
+    android:versionName="1.4.5-SNAPSHOT"
+    android:versionCode="145">
 
     <uses-permission android:name="android.permission.INTERNET" />
 
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
similarity index 93%
rename from library/src/com/loopj/android/http/AsyncHttpClient.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 92116f4b..7e9867c9 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -63,14 +63,14 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.zip.GZIPInputStream;
 
@@ -91,24 +91,24 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.4";
 
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-    private static final String LOG_TAG = "AsyncHttpClient";
+    public static final String VERSION = "1.4.5";
+    public static final int DEFAULT_MAX_CONNECTIONS = 10;
+    public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+    public static final int DEFAULT_MAX_RETRIES = 5;
+    public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
+    public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+    public static final String LOG_TAG = "AsyncHttpClient";
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
     private int timeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+    private ExecutorService threadPool;
+    private final Map<Context, List<RequestHandle>> requestMap;
     private final Map<String, String> clientHeaderMap;
     private boolean isUrlEncodingEnabled = true;
 
@@ -209,8 +209,8 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(DEFAULT_MAX_CONNECTIONS);
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        threadPool = Executors.newCachedThreadPool();
+        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
         clientHeaderMap = new HashMap<String, String>();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
@@ -249,6 +249,18 @@ public void process(HttpResponse response, HttpContext context) {
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
+    public static void allowRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToWhitelist(cls);
+        }
+    }
+
+    public static void blockRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToBlacklist(cls);
+        }
+    }
+
     /**
      * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
      * settings for requests by accessing the client's ConnectionManager, HttpParams and
@@ -475,21 +487,16 @@ public void clearBasicAuth() {
      *                              pending requests.
      */
     public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+        List<RequestHandle> requestList = requestMap.get(context);
         if (requestList != null) {
-            for (WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if (request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
+            for (RequestHandle requestHandle : requestList) {
+                requestHandle.cancel(mayInterruptIfRunning);
             }
+            requestMap.remove(context);
         }
-        requestMap.remove(context);
     }
 
-    //
-    // HTTP HEAD Requests
-    //
+    // [+] HTTP HEAD
 
     /**
      * Perform a HTTP HEAD request, without any parameters.
@@ -558,10 +565,8 @@ public RequestHandle head(Context context, String url, Header[] headers, Request
                 context);
     }
 
-
-    //
-    // HTTP GET Requests
-    //
+    // [-] HTTP HEAD
+    // [+] HTTP GET
 
     /**
      * Perform a HTTP GET request, without any parameters.
@@ -630,10 +635,8 @@ public RequestHandle get(Context context, String url, Header[] headers, RequestP
                 context);
     }
 
-
-    //
-    // HTTP POST Requests
-    //
+    // [-] HTTP GET
+    // [+] HTTP POST
 
     /**
      * Perform a HTTP POST request, without any parameters.
@@ -732,9 +735,8 @@ public RequestHandle post(Context context, String url, Header[] headers, HttpEnt
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP PUT Requests
-    //
+    // [-] HTTP POST
+    // [+] HTTP PUT
 
     /**
      * Perform a HTTP PUT request, without any parameters.
@@ -811,9 +813,8 @@ public RequestHandle put(Context context, String url, Header[] headers, HttpEnti
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP DELETE Requests
-    //
+    // [-] HTTP PUT
+    // [+] HTTP DELETE
 
     /**
      * Perform a HTTP DELETE request.
@@ -870,6 +871,8 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
+    // [-] HTTP DELETE
+
     /**
      * Puts a new request in queue as a new thread in pool to be executed
      *
@@ -884,28 +887,35 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
      */
     protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
         if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
+            uriRequest.setHeader("Content-Type", contentType);
         }
 
         responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
         responseHandler.setRequestURI(uriRequest.getURI());
 
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
+        AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+        threadPool.submit(request);
+        RequestHandle requestHandle = new RequestHandle(request);
 
         if (context != null) {
             // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+            List<RequestHandle> requestList = requestMap.get(context);
             if (requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
+                requestList = new LinkedList<RequestHandle>();
                 requestMap.put(context, requestList);
             }
 
-            requestList.add(new WeakReference<Future<?>>(request));
+            requestList.add(requestHandle);
 
-            // TODO: Remove dead weakrefs from requestLists?
+            Iterator<RequestHandle> iterator = requestList.iterator();
+            while (iterator.hasNext()) {
+                if (iterator.next().shouldBeGarbageCollected()) {
+                    iterator.remove();
+                }
+            }
         }
 
-        return new RequestHandle(request);
+        return requestHandle;
     }
 
     /**
@@ -931,11 +941,15 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
             url = url.replace(" ", "%20");
 
         if (params != null) {
-            String paramString = params.getParamString();
-            if (!url.contains("?")) {
-                url += "?" + paramString;
-            } else {
-                url += "&" + paramString;
+            // Construct the query string and trim it, in case it
+            // includes any excessive white spaces.
+            String paramString = params.getParamString().trim();
+
+            // Only add the query string if it isn't empty and it
+            // isn't equal to '?'.
+            if (!paramString.equals("") && !paramString.equals("?")) {
+                url += url.contains("?") ? "&" : "?";
+                url += paramString;
             }
         }
 
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
similarity index 67%
rename from library/src/com/loopj/android/http/AsyncHttpRequest.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index d6c36f2a..b9dc45ca 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -30,12 +30,18 @@
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
 
+/**
+ * Internal class, representing the HttpRequest, done in asynchronous manner
+ */
 class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
+    private boolean isCancelled = false;
+    private boolean cancelIsNotified = false;
+    private boolean isFinished = false;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
         this.client = client;
@@ -46,38 +52,53 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
 
     @Override
     public void run() {
+        if (isCancelled()) {
+            return;
+        }
+
         if (responseHandler != null) {
             responseHandler.sendStartMessage();
         }
 
+        if (isCancelled()) {
+            return;
+        }
+
         try {
             makeRequestWithRetries();
         } catch (IOException e) {
-            if (responseHandler != null) {
+            if (!isCancelled() && responseHandler != null) {
                 responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
             }
         }
 
+        if (isCancelled()) {
+            return;
+        }
+
         if (responseHandler != null) {
             responseHandler.sendFinishMessage();
         }
+
+        isFinished = true;
     }
 
     private void makeRequest() throws IOException {
-        if (!Thread.currentThread().isInterrupted()) {
-            // Fixes #115
-            if (request.getURI().getScheme() == null) {
-                // subclass of IOException so processed in the caller
-                throw new MalformedURLException("No valid URI scheme was provided");
-            }
+        if (isCancelled()) {
+            return;
+        }
+        // Fixes #115
+        if (request.getURI().getScheme() == null) {
+            // subclass of IOException so processed in the caller
+            throw new MalformedURLException("No valid URI scheme was provided");
+        }
 
-            HttpResponse response = client.execute(request, context);
+        HttpResponse response = client.execute(request, context);
 
-            if (!Thread.currentThread().isInterrupted()) {
-                if (responseHandler != null) {
-                    responseHandler.sendResponseMessage(response);
-                }
-            }
+        if (!isCancelled() && responseHandler != null) {
+            responseHandler.sendResponseMessage(response);
         }
     }
 
@@ -103,11 +124,15 @@ private void makeRequestWithRetries() throws IOException {
                     cause = new IOException("NPE in HttpClient: " + e.getMessage());
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 } catch (IOException e) {
+                    if (isCancelled()) {
+                        // Eating exception, as the request was cancelled
+                        return;
+                    }
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
                 if (retry && (responseHandler != null)) {
-                    responseHandler.sendRetryMessage();
+                    responseHandler.sendRetryMessage(executionCount);
                 }
             }
         } catch (Exception e) {
@@ -119,4 +144,31 @@ private void makeRequestWithRetries() throws IOException {
         // cleaned up to throw IOException
         throw (cause);
     }
+
+    public boolean isCancelled() {
+        if (isCancelled) {
+            sendCancelNotification();
+        }
+        return isCancelled;
+    }
+
+    private synchronized void sendCancelNotification() {
+        if (!isFinished && isCancelled && !cancelIsNotified) {
+            cancelIsNotified = true;
+            if (responseHandler != null)
+                responseHandler.sendCancelMessage();
+        }
+    }
+
+    public boolean isDone() {
+        return isCancelled() || isFinished;
+    }
+
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        isCancelled = true;
+        if (mayInterruptIfRunning && request != null && !request.isAborted()) {
+            request.abort();
+        }
+        return isCancelled();
+    }
 }
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
similarity index 62%
rename from library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 3937e1cc..985c5267 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -32,8 +32,6 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.lang.ref.WeakReference;
 import java.net.URI;
 
 /**
@@ -41,7 +39,7 @@
  * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
  * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
  * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
- * #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
+ * #onFinish()}, {@link #onRetry(int)} and {@link #onProgress(int, int)} methods as required.
  * <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
@@ -57,7 +55,8 @@
  *     }
  *
  *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error)
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
  * {
  *         // Response failed :(
  *     }
@@ -79,7 +78,7 @@
  * });
  * </pre>
  */
-public class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
     private static final String LOG_TAG = "AsyncHttpResponseHandler";
 
     protected static final int SUCCESS_MESSAGE = 0;
@@ -88,10 +87,11 @@
     protected static final int FINISH_MESSAGE = 3;
     protected static final int PROGRESS_MESSAGE = 4;
     protected static final int RETRY_MESSAGE = 5;
+    protected static final int CANCEL_MESSAGE = 6;
 
     protected static final int BUFFER_SIZE = 4096;
 
-    private Handler handler;
+    private final Handler handler;
     public static final String DEFAULT_CHARSET = "UTF-8";
     private String responseCharset = DEFAULT_CHARSET;
     private Boolean useSynchronousMode = false;
@@ -119,26 +119,25 @@ public void setRequestHeaders(Header[] requestHeaders) {
         this.requestHeaders = requestHeaders;
     }
 
-    // avoid leaks by using a non-anonymous handler class
-    // with a weak reference
-    static class ResponderHandler extends Handler {
-        private final WeakReference<AsyncHttpResponseHandler> mResponder;
+    /**
+     * Avoid leaks by using a non-anonymous handler class.
+     */
+    private static class ResponderHandler extends Handler {
+        private final AsyncHttpResponseHandler mResponder;
 
-        ResponderHandler(AsyncHttpResponseHandler service) {
-            mResponder = new WeakReference<AsyncHttpResponseHandler>(service);
+        ResponderHandler(AsyncHttpResponseHandler mResponder) {
+            this.mResponder = mResponder;
         }
 
         @Override
         public void handleMessage(Message msg) {
-            AsyncHttpResponseHandler service = mResponder.get();
-            if (service != null) {
-                service.handleMessage(msg);
-            }
+            mResponder.handleMessage(msg);
         }
     }
 
+    @Override
     public boolean getUseSynchronousMode() {
-        return (useSynchronousMode);
+        return useSynchronousMode;
     }
 
     @Override
@@ -164,16 +163,12 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if (Looper.myLooper() != null) {
-            handler = new ResponderHandler(this);
-        }
-    }
-
+        // There is always a handler ready for delivering messages.
+        handler = new ResponderHandler(this);
 
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
+        // Init Looper by calling postRunnable without an argument.
+        postRunnable(null);
+    }
 
     /**
      * Fired when the request progress, override to handle in your own code
@@ -182,6 +177,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
+        Log.v(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
     }
 
     /**
@@ -197,41 +193,6 @@ public void onStart() {
     public void onFinish() {
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param content the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(String content) {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, Header[] headers, String content) {
-        onSuccess(statusCode, content);
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
-    }
-
     /**
      * Fired when a request returns successfully, override to handle in your own code
      *
@@ -239,67 +200,7 @@ public void onSuccess(int statusCode, String content) {
      * @param headers      return headers, if any
      * @param responseBody the body of the HTTP response from the server
      */
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
-        }
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error) {
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error   the underlying cause of the failure
-     * @param content the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Throwable error, String content) {
-        // By default, call the chain method onFailure(Throwable,String)
-        onFailure(error, content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param headers    return headers, if any
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // By default, call the chain method onFailure(int,Throwable,String)
-        onFailure(statusCode, error, content);
-    }
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] responseBody);
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
@@ -309,37 +210,31 @@ public void onFailure(int statusCode, Header[] headers, Throwable error, String
      * @param responseBody the response body, if any
      * @param error        the underlying cause of the failure
      */
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, error, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
-        }
-    }
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
 
     /**
      * Fired when a retry occurs, override to handle in your own code
+     *
+     * @param retryNo number of retry
      */
-    public void onRetry() {
+    public void onRetry(int retryNo) {
+        Log.d(LOG_TAG, String.format("Request retry no. %d", retryNo));
     }
 
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
+    public void onCancel() {
+        Log.d(LOG_TAG, "Request got cancelled");
+    }
 
     final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
-    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
+    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
     }
 
-    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
+    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
     }
 
     final public void sendStartMessage() {
@@ -350,17 +245,21 @@ final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-    final public void sendRetryMessage() {
-        sendMessage(obtainMessage(RETRY_MESSAGE, null));
+    final public void sendRetryMessage(int retryNo) {
+        sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
+    }
+
+    final public void sendCancelMessage() {
+        sendMessage(obtainMessage(CANCEL_MESSAGE, null));
     }
 
     // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
+    protected void handleMessage(Message message) {
         Object[] response;
 
-        switch (msg.what) {
+        switch (message.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 3) {
                     onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
                 } else {
@@ -368,7 +267,7 @@ protected void handleMessage(Message msg) {
                 }
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 4) {
                     onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
                 } else {
@@ -382,7 +281,7 @@ protected void handleMessage(Message msg) {
                 onFinish();
                 break;
             case PROGRESS_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 2) {
                     try {
                         onProgress((Integer) response[0], (Integer) response[1]);
@@ -394,37 +293,53 @@ protected void handleMessage(Message msg) {
                 }
                 break;
             case RETRY_MESSAGE:
-                onRetry();
+                response = (Object[]) message.obj;
+                if (response != null && response.length == 1)
+                    onRetry((Integer) response[0]);
+                else
+                    Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
+                break;
+            case CANCEL_MESSAGE:
+                onCancel();
                 break;
         }
     }
 
     protected void sendMessage(Message msg) {
-        if (getUseSynchronousMode() || handler == null) {
+        if (getUseSynchronousMode()) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
             handler.sendMessage(msg);
         }
     }
 
-    protected void postRunnable(Runnable r) {
-        if (r != null) {
-            handler.post(r);
+    /**
+     * Helper method to send runnable into local handler loop
+     *
+     * @param runnable runnable instance, can be null
+     */
+    protected void postRunnable(Runnable runnable) {
+        boolean missingLooper = null == Looper.myLooper();
+        if (missingLooper) {
+            Looper.prepare();
+        }
+        if (null != runnable) {
+            handler.post(runnable);
+        }
+        if (missingLooper) {
+            Looper.loop();
         }
     }
 
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg;
-        if (handler != null) {
-            msg = handler.obtainMessage(responseMessage, response);
-        } else {
-            msg = Message.obtain();
-            if (msg != null) {
-                msg.what = responseMessage;
-                msg.obj = response;
-            }
-        }
-        return msg;
+    /**
+     * Helper method to create Message instance from handler
+     *
+     * @param responseMessageId   constant to identify Handler message
+     * @param responseMessageData object to be passed to message receiver
+     * @return Message instance, should not be null
+     */
+    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
+        return handler.obtainMessage(responseMessageId, responseMessageData);
     }
 
     @Override
@@ -445,6 +360,13 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
         }
     }
 
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
     byte[] getResponseData(HttpEntity entity) throws IOException {
         byte[] responseBody = null;
         if (entity != null) {
@@ -454,11 +376,9 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                if (contentLength < 0) {
-                    contentLength = BUFFER_SIZE;
-                }
+                int buffersize = (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
                     try {
                         byte[] tmp = new byte[BUFFER_SIZE];
                         int l, count = 0;
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
new file mode 100644
index 00000000..e9bc1809
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of
+ * binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
+ * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end
+     * of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output
+     * will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a
+     * CRLF pair instead of just an LF.  Has no effect if {@code
+     * NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and
+     * filename safe" variant of Base64 (see RFC 3548 section 4) where
+     * {@code -} and {@code _} are used in place of {@code +} and
+     * {@code /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link Base64OutputStream} to indicate that it
+     * should not close the output stream it is wrapping when it
+     * itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is
+         * provided by the caller, and must be big enough to hold all
+         * the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for
+         *        this object.  Will finalize the coder state and
+         *        include any final bytes in the output.
+         *
+         * @return true if the input so far is good; false if some
+         *         error has been detected in the input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process()
+         * could produce for the given number of input bytes.  This may
+         * be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param str    the input String to decode, which is converted to
+     *               bytes using the default charset
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the
+         * Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548
+         * sec. 4) where - and _ replace + and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /** Non-data values in the DECODE arrays. */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple.
+         * State 4 is having read one '=' and expecting exactly
+         * one more.
+         * State 5 is expecting no more data or padding characters
+         * in the input.
+         * State 6 is the error state; an error has been detected
+         * in the input and no future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3/4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if
+         *         bad base-64 data has been detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p+4 <= len &&
+                           (value = ((alphabet[input[p] & 0xff] << 18) |
+                                     (alphabet[input[p+1] & 0xff] << 12) |
+                                     (alphabet[input[p+2] & 0xff] << 6) |
+                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                case 0:
+                    if (d >= 0) {
+                        value = d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 1:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 2:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect exactly one more padding character.
+                        output[op++] = (byte) (value >> 4);
+                        state = 4;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 3:
+                    if (d >= 0) {
+                        // Emit the output triple and return to state 0.
+                        value = (value << 6) | d;
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        state = 0;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect no further data or padding characters.
+                        output[op+1] = (byte) (value >> 2);
+                        output[op] = (byte) (value >> 10);
+                        op += 2;
+                        state = 5;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 4:
+                    if (d == EQUALS) {
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 5:
+                    if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+            case 0:
+                // Output length is a multiple of three.  Fine.
+                break;
+            case 1:
+                // Read one extra input byte, which isn't enough to
+                // make another output byte.  Illegal.
+                this.state = 6;
+                return false;
+            case 2:
+                // Read two extra input bytes, enough to emit 1 more
+                // output byte.  Fine.
+                output[op++] = (byte) (value >> 4);
+                break;
+            case 3:
+                // Read three extra input bytes, enough to emit 2 more
+                // output bytes.  Fine.
+                output[op++] = (byte) (value >> 10);
+                output[op++] = (byte) (value >> 2);
+                break;
+            case 4:
+                // Read one padding '=' when we expected 2.  Illegal.
+                this.state = 6;
+                return false;
+            case 5:
+                // Read all the padding '='s we expected and no more.
+                // Fine.
+                break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0: break;
+                case 1: output_len += 2; break;
+                case 2: output_len += 3; break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        assert encoder.op == output_len;
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to
+         * a 76-character line length (the maximum allowable according to
+         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8/5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p+2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((input[p++] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+
+                case 2:
+                    if (p+1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((tail[1] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p+3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                    ((input[p+1] & 0xff) << 8) |
+                    (input[p+2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op+1] = alphabet[(v >> 12) & 0x3f];
+                output[op+2] = alphabet[(v >> 6) & 0x3f];
+                output[op+3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p-tailLen == len-1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p-tailLen == len-2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                assert tailLen == 0;
+                assert p == len;
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len-1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len-2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p+1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() { }   // don't instantiate
+}
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
new file mode 100644
index 00000000..ead54c56
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -0,0 +1,9 @@
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+public class Base64DataException extends IOException {
+    public Base64DataException(String detailMessage) {
+        super(detailMessage);
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
new file mode 100644
index 00000000..61afb931
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -0,0 +1,130 @@
+package com.loopj.android.http;
+
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class Base64OutputStream extends FilterOutputStream {
+    private final Base64.Coder coder;
+    private final int flags;
+
+    private byte[] buffer = null;
+    private int bpos = 0;
+
+    private static byte[] EMPTY = new byte[0];
+
+    /**
+     * Performs Base64 encoding on the data written to the stream, writing the encoded data to
+     * another OutputStream.
+     *
+     * @param out   the OutputStream to write the encoded data to
+     * @param flags bit flags for controlling the encoder; see the constants in {@link Base64}
+     */
+    public Base64OutputStream(OutputStream out, int flags) {
+        this(out, flags, true);
+    }
+
+    /**
+     * Performs Base64 encoding or decoding on the data written to the stream, writing the
+     * encoded/decoded data to another OutputStream.
+     *
+     * @param out    the OutputStream to write the encoded data to
+     * @param flags  bit flags for controlling the encoder; see the constants in {@link Base64}
+     * @param encode true to encode, false to decode
+     */
+    public Base64OutputStream(OutputStream out, int flags, boolean encode) {
+        super(out);
+        this.flags = flags;
+        if (encode) {
+            coder = new Base64.Encoder(flags, null);
+        } else {
+            coder = new Base64.Decoder(flags, null);
+        }
+    }
+
+    public void write(int b) throws IOException {
+        // To avoid invoking the encoder/decoder routines for single
+        // bytes, we buffer up calls to write(int) in an internal
+        // byte array to transform them into writes of decently-sized
+        // arrays.
+
+        if (buffer == null) {
+            buffer = new byte[1024];
+        }
+        if (bpos >= buffer.length) {
+            // internal buffer full; write it out.
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+        buffer[bpos++] = (byte) b;
+    }
+
+    /**
+     * Flush any buffered data from calls to write(int).  Needed before doing a write(byte[], int,
+     * int) or a close().
+     */
+    private void flushBuffer() throws IOException {
+        if (bpos > 0) {
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+    }
+
+    public void write(byte[] b, int off, int len) throws IOException {
+        if (len <= 0) return;
+        flushBuffer();
+        internalWrite(b, off, len, false);
+    }
+
+    public void close() throws IOException {
+        IOException thrown = null;
+        try {
+            flushBuffer();
+            internalWrite(EMPTY, 0, 0, true);
+        } catch (IOException e) {
+            thrown = e;
+        }
+
+        try {
+            if ((flags & Base64.NO_CLOSE) == 0) {
+                out.close();
+            } else {
+                out.flush();
+            }
+        } catch (IOException e) {
+            if (thrown != null) {
+                thrown = e;
+            }
+        }
+
+        if (thrown != null) {
+            throw thrown;
+        }
+    }
+
+    /**
+     * Write the given bytes to the encoder/decoder.
+     *
+     * @param finish true if this is the last batch of input, to cause encoder/decoder state to be
+     *               finalized.
+     */
+    private void internalWrite(byte[] b, int off, int len, boolean finish) throws IOException {
+        coder.output = embiggen(coder.output, coder.maxOutputSize(len));
+        if (!coder.process(b, off, len, finish)) {
+            throw new Base64DataException("bad base-64");
+        }
+        out.write(coder.output, 0, coder.op);
+    }
+
+    /**
+     * If b.length is at least len, return b.  Otherwise return a new byte array of length len.
+     */
+    private byte[] embiggen(byte[] b, int len) {
+        if (b == null || b.length < len) {
+            return new byte[len];
+        } else {
+            return b;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
similarity index 52%
rename from library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index c9a89091..03f98345 100644
--- a/library/src/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -23,91 +23,65 @@
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
 
+/**
+ * Class meant to be used with custom JSON parser (such as GSON or Jackson JSON) <p>&nbsp;</p>
+ * {@link #parseResponse(String, boolean)} should be overriden and must return type of generic param
+ * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
+ * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
+ * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates a new JsonHttpResponseHandler with default charset "UTF-8"
      */
-
     public BaseJsonHttpResponseHandler() {
-        super(DEFAULT_CHARSET);
+        this(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates a new JsonHttpResponseHandler with given string encoding
+     *
+     * @param encoding result string encoding, see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
     public BaseJsonHttpResponseHandler(String encoding) {
         super(encoding);
     }
 
-    @Override
-    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        // Disabling this method
-        super.onSuccess(statusCode, headers, responseBody);
-    }
-
-    @Override
-    public final void onSuccess(String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(content);
-    }
-
-    @Override
-    public final void onSuccess(int statusCode, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(statusCode, content);
-    }
-
-    @Override
-    public final void onFailure(String responseBody, Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        //Disabling this method
-        super.onFailure(statusCode, headers, responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, headers, error, content);
-    }
-
-    public abstract void onSuccess(int statusCode, Header[] headers, String rawResponse, JSON_TYPE response);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode      HTTP status line
+     * @param headers         response headers
+     * @param rawJsonResponse string of response, can be null
+     * @param response        response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, JSON_TYPE response);
 
-    public abstract void onFailure(int statusCode, Header[] headers, Throwable e, String rawData, JSON_TYPE errorResponse);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode    HTTP status line
+     * @param headers       response headers
+     * @param throwable     error thrown while processing request
+     * @param rawJsonData   raw string data returned if any
+     * @param errorResponse response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, JSON_TYPE errorResponse);
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, false);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onSuccess(statusCode, headers, responseBody, jsonResponse);
+                                onSuccess(statusCode, headers, responseString, jsonResponse);
                             }
                         });
                     } catch (final Throwable t) {
@@ -115,7 +89,7 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, t, responseBody, null);
+                                onFailure(statusCode, headers, t, responseString, null);
                             }
                         });
                     }
@@ -127,17 +101,17 @@ public void run() {
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
+    public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
+        if (responseString != null) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, true);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, jsonResponse);
+                                onFailure(statusCode, headers, throwable, responseString, jsonResponse);
                             }
                         });
                     } catch (Throwable t) {
@@ -145,16 +119,25 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, null);
+                                onFailure(statusCode, headers, throwable, responseString, null);
                             }
                         });
                     }
                 }
             }).start();
         } else {
-            onFailure(statusCode, headers, e, null, null);
+            onFailure(statusCode, headers, throwable, null, null);
         }
     }
 
-    protected abstract JSON_TYPE parseResponse(String responseBody) throws Throwable;
+    /**
+     * Should return deserialized instance of generic type, may return object for more vague
+     * handling
+     *
+     * @param rawJsonData response string, may be null
+     * @param isFailure   indicating if this method is called from onFailure or not
+     * @return object of generic type or possibly null if you choose so
+     * @throws Throwable allows you to throw anything from within deserializing JSON response
+     */
+    protected abstract JSON_TYPE parseResponse(String rawJsonData, boolean isFailure) throws Throwable;
 }
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
similarity index 69%
rename from library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index 58055ac3..1959ec6d 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -49,7 +49,9 @@
  * });
  * </pre>
  */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+public abstract class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private static final String LOG_TAG = "BinaryHttpResponseHandler";
 
     private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
@@ -80,65 +82,19 @@ public BinaryHttpResponseHandler() {
      * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
+        super();
+        if (allowedContentTypes != null)
+            mAllowedContentTypes = allowedContentTypes;
+        else
+            Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     */
-
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-        onSuccess(statusCode, binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     * @param error      the underlying cause of the failure
-     */
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] binaryData);
 
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error) {
-        onFailure(statusCode, error, null);
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error);
 
-    // Interface to AsyncHttpRequest
     @Override
     public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..dc35b42d
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -0,0 +1,149 @@
+package com.loopj.android.http;
+
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+import android.os.Message;
+import android.util.Log;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.util.ByteArrayBuffer;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "DataAsyncHttpResponseHandler";
+
+    protected static final int PROGRESS_DATA_MESSAGE = 6;
+
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public DataAsyncHttpResponseHandler() {
+        super();
+    }
+
+    /**
+     * Fired when the request progress, override to handle in your own code
+     */
+    public void onProgressData(byte[] responseBody) {
+    }
+
+
+    final public void sendProgressDataMessage(byte[] responseBytes) {
+        sendMessage(obtainMessage(PROGRESS_DATA_MESSAGE, new Object[]{responseBytes}));
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    @Override
+    protected void handleMessage(Message message) {
+        super.handleMessage(message);
+        Object[] response;
+
+        switch (message.what) {
+            case PROGRESS_DATA_MESSAGE:
+                response = (Object[]) message.obj;
+                if (response != null && response.length >= 1) {
+                    try {
+                        onProgressData((byte[]) response[0]);
+                    } catch (Throwable t) {
+                        Log.e(LOG_TAG, "custom onProgressData contains an error", t);
+                    }
+                } else {
+                    Log.e(LOG_TAG, "PROGRESS_DATA_MESSAGE didn't got enough params");
+                }
+                break;
+        }
+    }
+
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
+    @Override
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            buffer.append(tmp, 0, l);
+                            sendProgressDataMessage(copyOfRange(tmp, 0, l));
+                        }
+                    } finally {
+                        instream.close();
+                    }
+                    responseBody = buffer.toByteArray();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
+        }
+        return responseBody;
+    }
+
+    /**
+     * Copies elements from {@code original} into a new array, from indexes start (inclusive) to end
+     * (exclusive). The original order of elements is preserved. If {@code end} is greater than
+     * {@code original.length}, the result is padded with the value {@code (byte) 0}.
+     *
+     * @param original the original array
+     * @param start    the start index, inclusive
+     * @param end      the end index, exclusive
+     * @return the new array
+     * @throws ArrayIndexOutOfBoundsException if {@code start < 0 || start > original.length}
+     * @throws IllegalArgumentException       if {@code start > end}
+     * @throws NullPointerException           if {@code original == null}
+     * @see java.util.Arrays
+     * @since 1.6
+     */
+    public static byte[] copyOfRange(byte[] original, int start, int end) throws ArrayIndexOutOfBoundsException, IllegalArgumentException, NullPointerException {
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        int originalLength = original.length;
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        int resultLength = end - start;
+        int copyLength = Math.min(resultLength, originalLength - start);
+        byte[] result = new byte[resultLength];
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+}
+
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..6223890e
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,132 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private File mFile;
+    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
+
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        assert (file != null);
+        this.mFile = file;
+    }
+
+    /**
+     * Obtains new FileAsyncHttpResponseHandler against context with target being temporary file
+     *
+     * @param context Context, must not be null
+     */
+    public FileAsyncHttpResponseHandler(Context context) {
+        super();
+        this.mFile = getTemporaryFile(context);
+    }
+
+    /**
+     * Attempts to delete file with stored response
+     *
+     * @return false if the file does not exist or is null, true if it was successfully deleted
+     */
+    public boolean deleteTargetFile() {
+        return getTargetFile() != null && getTargetFile().delete();
+    }
+
+    /**
+     * Used when there is no file to be used when calling constructor
+     *
+     * @param context Context, must not be null
+     * @return temporary file or null if creating file failed
+     */
+    protected File getTemporaryFile(Context context) {
+        assert (context != null);
+        try {
+            return File.createTempFile("temp_", "_handled", context.getCacheDir());
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "Cannot create temporary file", t);
+        }
+        return null;
+    }
+
+    /**
+     * Retrieves File object in which the response is stored
+     *
+     * @return File file in which the response is stored
+     */
+    protected File getTargetFile() {
+        assert (mFile != null);
+        return mFile;
+    }
+
+    @Override
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, throwable, getTargetFile());
+    }
+
+    /**
+     * Method to be overriden, receives as much of file as possible Called when the file is
+     * considered failure or if there is error when retrieving file
+     *
+     * @param statusCode http file status line
+     * @param headers    file http headers if any
+     * @param throwable  returned throwable
+     * @param file       file in which the file is stored
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, File file);
+
+    @Override
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getTargetFile());
+    }
+
+    /**
+     * Method to be overriden, receives as much of response as possible
+     *
+     * @param statusCode http response status line
+     * @param headers    response http headers if any
+     * @param file       file in which the response is stored
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, File file);
+
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength();
+            FileOutputStream buffer = new FileOutputStream(getTargetFile());
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l, count = 0;
+                    // do not send messages if request has been cancelled
+                    while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        count += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage(count, (int) contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
+
+}
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
similarity index 54%
rename from library/src/com/loopj/android/http/JsonHttpResponseHandler.java
rename to library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 6778596c..0b26fb1b 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -30,126 +30,94 @@
 /**
  * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
  * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
- * designed to be passed to get, post, put and delete requests with the {@link
- * #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)} methods anonymously overridden.
- * <p>&nbsp;</p> Additionally, you can override the other event methods from the parent class.
+ * designed to be passed to get, post, put and delete requests with the {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONArray)} or {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONObject)} methods anonymously overridden. <p>&nbsp;</p>
+ * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends TextHttpResponseHandler {
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
      */
-
     public JsonHttpResponseHandler() {
         super(DEFAULT_CHARSET);
     }
 
-    public JsonHttpResponseHandler(String encoding) {
-        super(encoding);
-    }
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
-     *
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {
-    }
-
-
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Creates new JsonHttpRespnseHandler with given Json String encoding
      *
-     * @param response the parsed json array found in the server response (if any)
+     * @param encoding String encoding to be used when parsing JSON
      */
-    public void onSuccess(JSONArray response) {
+    public JsonHttpResponseHandler(String encoding) {
+        super(encoding);
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-        onSuccess(statusCode, response);
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
+    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-        onSuccess(statusCode, response);
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, JSONArray response) {
-        onSuccess(response);
-    }
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
 
-    public void onFailure(Throwable e, JSONObject errorResponse) {
-        onFailure(e);
     }
 
-    public void onFailure(int statusCode, Throwable e, JSONObject errorResponse) {
-        onFailure(e, errorResponse);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONObject errorResponse) {
-        onFailure(statusCode, e, errorResponse);
-    }
+    @Override
+    public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
 
-    public void onFailure(Throwable e, JSONArray errorResponse) {
-        onFailure(e);
     }
 
-    public void onFailure(int statusCode, Throwable e, JSONArray errorResponse) {
-        onFailure(e, errorResponse);
-    }
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseString) {
 
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray errorResponse) {
-        onFailure(statusCode, e, errorResponse);
     }
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -157,10 +125,8 @@ public void run() {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
-                                } else if (jsonResponse instanceof String) {
-                                    onSuccess(statusCode, headers, (String) jsonResponse);
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
 
                             }
@@ -169,7 +135,7 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(ex, (JSONObject) null);
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
                             }
                         });
                     }
@@ -181,24 +147,24 @@ public void run() {
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
+    public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
+        if (responseBytes != null) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 if (jsonResponse instanceof JSONObject) {
-                                    onFailure(statusCode, headers, e, (JSONObject) jsonResponse);
+                                    onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
-                                    onFailure(statusCode, headers, e, (JSONArray) jsonResponse);
+                                    onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
                                 } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, e, (String) jsonResponse);
+                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
                             }
                         });
@@ -216,18 +182,29 @@ public void run() {
             }).start();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
-            onFailure(statusCode, headers, e, (JSONObject) null);
+            onFailure(statusCode, headers, throwable, (JSONObject) null);
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
+    /**
+     * Returns Object of type {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
+     * Double or {@link JSONObject#NULL}, see {@link org.json.JSONTokener#nextValue()}
+     *
+     * @param responseBody response bytes to be assembled in String and parsed as JSON
+     * @return Object parsedResponse
+     * @throws org.json.JSONException exception if thrown while parsing JSON
+     */
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
         //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        String jsonString = responseBody.trim();
-        if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-            result = new JSONTokener(jsonString).nextValue();
+        String jsonString = getResponseString(responseBody, getCharset());
+        if (jsonString != null) {
+            jsonString = jsonString.trim();
+            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                result = new JSONTokener(jsonString).nextValue();
+            }
         }
         if (result == null) {
             result = jsonString;
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
new file mode 100644
index 00000000..49375061
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -0,0 +1,320 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * HTTP entity to upload JSON data using streams.
+ * This has very low memory footprint; suitable for uploading large
+ * files using base64 encoding.
+ */
+class JsonStreamerEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "JsonStreamerEntity";
+
+    private static final UnsupportedOperationException ERR_UNSUPPORTED =
+        new UnsupportedOperationException("Unsupported operation in this implementation.");
+
+    // Size of the byte-array buffer used to read from streams.
+    private static final int BUFFER_SIZE = 2048;
+
+    // Reusable StringBuilder used by escape() method.
+    // Base64, at worst, will make a binary stream grow in size by approximately
+    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
+    // large 'n'.
+    private static final StringBuilder BUILDER =
+        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+
+    private static final byte[] JSON_TRUE = "true".getBytes();
+    private static final byte[] JSON_FALSE = "false".getBytes();
+    private static final byte[] JSON_NULL = "null".getBytes();
+    private static final byte[] STREAM_NAME = escape("name");
+    private static final byte[] STREAM_TYPE = escape("type");
+    private static final byte[] STREAM_CONTENTS = escape("contents");
+    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
+
+    private static final Header HEADER_JSON_CONTENT =
+        new BasicHeader("Content-Type", "application/json");
+    private static final Header HEADER_GZIP_ENCODING =
+        new BasicHeader("Content-Encoding", "gzip");
+    private static final String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
+    // K/V objects to be uploaded.
+    private final Map<String, Object> kvParams =
+        new HashMap<String, Object>();
+
+    // Streams and their associated meta-data to be uploaded.
+    private final Map<String, RequestParams.StreamWrapper> streamParams =
+        new HashMap<String, RequestParams.StreamWrapper>();
+
+    // Whether to use gzip compression while uploading
+    private final Header contentEncoding;
+
+    public JsonStreamerEntity(boolean contentEncoding) {
+        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
+    }
+
+    public void addPart(String key, Object value) {
+        kvParams.put(key, value);
+    }
+
+    public void addPart(String key, InputStream inputStream, String name, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return contentEncoding;
+    }
+
+    @Override
+    public Header getContentType() {
+        return HEADER_JSON_CONTENT;
+    }
+
+    @Override
+    public void consumeContent() throws IOException, UnsupportedOperationException {
+    }
+
+    @Override
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw ERR_UNSUPPORTED;
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        if (outstream == null) {
+            throw new IllegalStateException("Output stream cannot be null.");
+        }
+
+        // Record the time when uploading started.
+        long now = System.currentTimeMillis();
+
+        // Keys used by the HashMaps.
+        Set<String> keys;
+
+        // Use GZIP compression when sending streams, otherwise just use
+        // a buffered output stream to speed things up a bit.
+        OutputStream upload;
+        if (null != contentEncoding) {
+            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
+        } else {
+            upload = new BufferedOutputStream(outstream);
+        }
+
+        // Always send a JSON object.
+        upload.write('{');
+
+        // Send the K/V values.
+        keys = kvParams.keySet();
+        for (String key : keys) {
+            // Write the JSON object's key.
+            upload.write(escape(key));
+            upload.write(':');
+
+            // Evaluate the value (which cannot be null).
+            Object value = kvParams.get(key);
+
+            if (value instanceof Boolean) {
+                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            } else if (value instanceof Long) {
+                upload.write((((Number)value).longValue() + "").getBytes());
+            } else if (value instanceof Double) {
+                upload.write((((Number)value).doubleValue() + "").getBytes());
+            } else if (value instanceof Float) {
+                upload.write((((Number)value).floatValue() + "").getBytes());
+            } else if (value instanceof Integer) {
+                upload.write((((Number)value).intValue() + "").getBytes());
+            } else {
+                upload.write(value.toString().getBytes());
+            }
+
+            upload.write(',');
+        }
+
+        // Buffer used for reading from input streams.
+        byte[] buffer = new byte[BUFFER_SIZE];
+
+        // Send the stream params.
+        keys = streamParams.keySet();
+        for (String key : keys) {
+            RequestParams.StreamWrapper entry = streamParams.get(key);
+
+            // Write the JSON object's key.
+            upload.write(escape(key));
+
+            // All uploads are sent as an object containing the file's details.
+            upload.write(':');
+            upload.write('{');
+
+            // Send the streams's name.
+            upload.write(STREAM_NAME);
+            upload.write(':');
+            upload.write(escape(entry.name));
+            upload.write(',');
+
+            // Send the streams's content type.
+            upload.write(STREAM_TYPE);
+            upload.write(':');
+            upload.write(escape(entry.contentType));
+            upload.write(',');
+
+            // Prepare the file content's key.
+            upload.write(STREAM_CONTENTS);
+            upload.write(':');
+            upload.write('"');
+
+            // Upload the file's contents in Base64.
+            Base64OutputStream outputStream =
+                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+            // Read from input stream until no more data's left to read.
+            int bytesRead;
+            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+                outputStream.write(buffer, 0, bytesRead);
+            }
+
+            // Close the Base64 output stream.
+            outputStream.close();
+
+            // End the file's object and prepare for next one.
+            upload.write('"');
+            upload.write('}');
+            upload.write(',');
+        }
+
+        // Include the elapsed time taken to upload everything.
+        // This might be useful for somebody, but it serves us well since
+        // there will almost always be a ',' as the last sent character.
+        upload.write(STREAM_ELAPSED);
+        upload.write(':');
+        long elapsedTime = System.currentTimeMillis() - now;
+        upload.write((elapsedTime + "}").getBytes());
+
+        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+
+        // Flush the contents up the stream.
+        upload.flush();
+        upload.close();
+    }
+
+    // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
+    // Changed a bit to suit our needs in this class.
+    static byte[] escape(String string) {
+        // If it's null, just return prematurely.
+        if (string == null) {
+          return JSON_NULL;
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        int length = string.length(), pos = -1;
+        while (++pos < length) {
+            char ch = string.charAt(pos);
+            switch (ch) {
+                case '"':
+                    BUILDER.append("\\\"");
+                    break;
+                case '\\':
+                    BUILDER.append("\\\\");
+                    break;
+                case '\b':
+                    BUILDER.append("\\b");
+                    break;
+                case '\f':
+                    BUILDER.append("\\f");
+                    break;
+                case '\n':
+                    BUILDER.append("\\n");
+                    break;
+                case '\r':
+                    BUILDER.append("\\r");
+                    break;
+                case '\t':
+                    BUILDER.append("\\t");
+                    break;
+                default:
+                    // Reference: http://www.unicode.org/versions/Unicode5.1.0/
+                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                        String intString = Integer.toHexString(ch);
+                        BUILDER.append("\\u");
+                        int intLength = 4 - intString.length();
+                        for (int zero = 0; zero < intLength; zero++) {
+                            BUILDER.append('0');
+                        }
+                        BUILDER.append(intString.toUpperCase(Locale.US));
+                    } else {
+                        BUILDER.append(ch);
+                    }
+                    break;
+            }
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        try {
+          return BUILDER.toString().getBytes();
+        } finally {
+          // Empty the String buffer.
+          // This is 20-30% faster than instantiating a new object.
+          BUILDER.setLength(0);
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
new file mode 100644
index 00000000..4ea14152
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -0,0 +1,185 @@
+package com.loopj.android.http;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+ 
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+ 
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
+
+/**
+ * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
+ * http://code.google.com/p/android/issues/detail?id=13117#c14 <p>&nbsp;</p> Warning! This omits SSL
+ * certificate validation on every device, use with caution
+ */
+public class MySSLSocketFactory extends SSLSocketFactory {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+
+    /**
+     * Creates a new SSL Socket Factory with the given KeyStore.
+     * 
+     * @param truststore A KeyStore to create the SSL Socket Factory in context of
+     * @throws NoSuchAlgorithmException
+     * @throws KeyManagementException
+     * @throws KeyStoreException
+     * @throws UnrecoverableKeyException
+     */
+    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
+        super(truststore);
+ 
+        X509TrustManager tm = new X509TrustManager() {
+            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            }
+ 
+            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            }
+ 
+            public X509Certificate[] getAcceptedIssuers() {
+                return null;
+            }
+        };
+ 
+        sslContext.init(null, new TrustManager[] { tm }, null);
+    }
+    
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+ 
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslContext.getSocketFactory().createSocket();
+    }	
+    
+    /**
+     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
+     */
+    public void fixHttpsURLConnection() {
+    	HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+    }
+    
+    /**
+     * Gets a KeyStore containing the Certificate
+     * 
+     * @param cert InputStream of the Certificate
+     * @return KeyStore
+     */
+	public static KeyStore getKeystoreOfCA(InputStream cert) {
+		
+		// Load CAs from an InputStream
+		InputStream caInput = null;
+		Certificate ca = null;
+		try {
+			CertificateFactory cf = CertificateFactory.getInstance("X.509");
+			caInput = new BufferedInputStream(cert);
+			ca = (Certificate) cf.generateCertificate(caInput);
+		} catch (CertificateException e1) {
+			e1.printStackTrace();
+		} finally {
+			try {
+				caInput.close();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+ 
+		// Create a KeyStore containing our trusted CAs
+		String keyStoreType = KeyStore.getDefaultType();
+		KeyStore keyStore = null;
+		try {
+			keyStore = KeyStore.getInstance(keyStoreType);
+			keyStore.load(null, null);
+			keyStore.setCertificateEntry("ca",
+					(java.security.cert.Certificate) ca);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		return keyStore;
+	}
+	
+	/**
+	 * Gets a Default KeyStore
+	 * 
+	 * @return KeyStore
+	 */
+	public static KeyStore getKeystore() {
+        KeyStore trustStore = null;
+        try {
+            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            trustStore.load(null, null);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+        return trustStore;
+    }
+ 
+	/**
+	 * Returns a SSlSocketFactory which trusts all certificates
+	 * 
+	 * @return
+	 */
+    public static SSLSocketFactory getFixedSocketFactory() {
+        SSLSocketFactory socketFactory;
+        try {
+            socketFactory = new MySSLSocketFactory(getKeystore());
+            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+        } catch (Throwable t) {
+            t.printStackTrace();
+            socketFactory = SSLSocketFactory.getSocketFactory();
+        }
+        return socketFactory;
+    }
+    
+    /**
+     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
+     * 
+     * @param keyStore
+     * @return
+     */
+	public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+		
+	    try {
+		    SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+		    SchemeRegistry registry = new SchemeRegistry();
+		    registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+		    registry.register(new Scheme("https", sf, 443));
+ 
+	        HttpParams params = new BasicHttpParams();
+	        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+	        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+ 
+	        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+ 
+	        return new DefaultHttpClient(ccm, params);
+	    } catch (Exception e) {
+	        return new DefaultHttpClient();
+	    }
+	}
+
+}
diff --git a/library/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
similarity index 75%
rename from library/src/com/loopj/android/http/PersistentCookieStore.java
rename to library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 96316991..ee87bd23 100644
--- a/library/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -21,6 +21,7 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.text.TextUtils;
+import android.util.Log;
 
 import org.apache.http.client.CookieStore;
 import org.apache.http.cookie.Cookie;
@@ -32,6 +33,7 @@
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -42,6 +44,7 @@
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
+    private static final String LOG_TAG = "PersistentCookieStore";
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
@@ -143,12 +146,15 @@ public boolean clearExpired(Date date) {
         return new ArrayList<Cookie>(cookies.values());
     }
 
-
-    //
-    // Cookie serialization/deserialization
-    //
-
+    /**
+     * Serializes Cookie object into String
+     *
+     * @param cookie cookie to be encoded, can be null
+     * @return cookie encoded as String
+     */
     protected String encodeCookie(SerializableCookie cookie) {
+        if (cookie == null)
+            return null;
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
@@ -160,39 +166,56 @@ protected String encodeCookie(SerializableCookie cookie) {
         return byteArrayToHexString(os.toByteArray());
     }
 
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+    /**
+     * Returns cookie decoded from cookie string
+     *
+     * @param cookieString string of cookie as returned from http request
+     * @return decoded cookie or null if exception occured
+     */
+    protected Cookie decodeCookie(String cookieString) {
+        byte[] bytes = hexStringToByteArray(cookieString);
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-            ObjectInputStream ois = new ObjectInputStream(is);
-            cookie = ((SerializableCookie) ois.readObject()).getCookie();
-        } catch (Exception e) {
-            e.printStackTrace();
+            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
+            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
+        } catch (Exception exception) {
+            Log.d(LOG_TAG, "decodeCookie failed", exception);
         }
 
         return cookie;
     }
 
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuilder sb = new StringBuilder(b.length * 2);
-        for (byte element : b) {
+    /**
+     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any
+     * large Base64 libraries. Can be overridden if you like!
+     *
+     * @param bytes byte array to be converted
+     * @return string containing hex values
+     */
+    protected String byteArrayToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        for (byte element : bytes) {
             int v = element & 0xff;
             if (v < 16) {
                 sb.append('0');
             }
             sb.append(Integer.toHexString(v));
         }
-        return sb.toString().toUpperCase();
+        return sb.toString().toUpperCase(Locale.US);
     }
 
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
+    /**
+     * Converts hex values from strings to byte arra
+     *
+     * @param hexString string of hex-encoded values
+     * @return decoded byte array
+     */
+    protected byte[] hexStringToByteArray(String hexString) {
+        int len = hexString.length();
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
+            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/library/src/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
similarity index 70%
rename from library/src/com/loopj/android/http/RequestHandle.java
rename to library/src/main/java/com/loopj/android/http/RequestHandle.java
index 08cb7824..1d56fb42 100644
--- a/library/src/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -1,15 +1,15 @@
 package com.loopj.android.http;
 
-import java.util.concurrent.Future;
+import java.lang.ref.WeakReference;
 
 /**
  * A Handle to an AsyncRequest which can be used to cancel a running request.
  */
-public class RequestHandle {
-    private final Future<?> request;
+class RequestHandle {
+    private final WeakReference<AsyncHttpRequest> request;
 
-    public RequestHandle(Future<?> request) {
-        this.request = request;
+    public RequestHandle(AsyncHttpRequest request) {
+        this.request = new WeakReference(request);
     }
 
     /**
@@ -28,7 +28,8 @@ public RequestHandle(Future<?> request) {
      * completed normally; true otherwise
      */
     public boolean cancel(boolean mayInterruptIfRunning) {
-        return this.request != null && request.cancel(mayInterruptIfRunning);
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.cancel(mayInterruptIfRunning);
     }
 
     /**
@@ -38,7 +39,8 @@ public boolean cancel(boolean mayInterruptIfRunning) {
      * @return true if this task completed
      */
     public boolean isFinished() {
-        return this.request == null || request.isDone();
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isDone();
     }
 
     /**
@@ -47,6 +49,14 @@ public boolean isFinished() {
      * @return true if this task was cancelled before it completed
      */
     public boolean isCancelled() {
-        return this.request != null && request.isCancelled();
+        AsyncHttpRequest _request = request.get();
+        return _request == null || _request.isCancelled();
+    }
+
+    public boolean shouldBeGarbageCollected() {
+        boolean should = isCancelled() || isFinished();
+        if (should)
+            request.clear();
+        return should;
     }
 }
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
similarity index 84%
rename from library/src/com/loopj/android/http/RequestParams.java
rename to library/src/main/java/com/loopj/android/http/RequestParams.java
index c7eedce6..42ba1706 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -18,6 +18,8 @@
 
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.client.entity.UrlEncodedFormEntity;
 import org.apache.http.client.utils.URLEncodedUtils;
@@ -25,6 +27,7 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -69,7 +72,8 @@
  * String[] colors = { "blue", "yellow" }; // Ordered collection
  * params.put("colors", colors); // url params: "colors[]=blue&amp;colors[]=yellow"
  *
- * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
+ * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String,
+ * String&gt;&gt;();
  * Map&lt;String, String&gt; user1 = new HashMap&lt;String, String&gt;();
  * user1.put("age", "30");
  * user1.put("gender", "male");
@@ -86,11 +90,27 @@
  */
 public class RequestParams {
 
-    protected boolean isRepeatable = false;
+    protected final static String LOG_TAG = "RequestParams";
+    protected boolean isRepeatable;
+    protected boolean useJsonStreamer;
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
     protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
+    protected String contentEncoding = HTTP.UTF_8;
+
+    /**
+     * Sets content encoding for return value of {@link #getParamString()} and {@link
+     * #createFormEntity()} <p>&nbsp;</p> Default encoding is "UTF-8"
+     *
+     * @param encoding String constant from {@link org.apache.http.protocol.HTTP}
+     */
+    public void setContentEncoding(final String encoding) {
+        if (encoding != null)
+            this.contentEncoding = encoding;
+        else
+            Log.d(LOG_TAG, "setContentEncoding called with null attribute");
+    }
 
     /**
      * Constructs a new empty {@code RequestParams} instance.
@@ -179,7 +199,10 @@ public void put(String key, File file) throws FileNotFoundException {
      * @throws java.io.FileNotFoundException throws if wrong File argument was passed
      */
     public void put(String key, File file, String contentType) throws FileNotFoundException {
-        if (key != null && file != null) {
+        if (file == null || !file.exists()) {
+            throw new FileNotFoundException();
+        }
+        if (key != null) {
             fileParams.put(key, new FileWrapper(file, contentType));
         }
     }
@@ -312,6 +335,10 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
         this.isRepeatable = isRepeatable;
     }
 
+    public void setUseJsonStreamer(boolean useJsonStreamer) {
+        this.useJsonStreamer = useJsonStreamer;
+    }
+
     /**
      * Returns an HttpEntity containing all request parameters
      *
@@ -321,18 +348,57 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
      * @throws IOException if one of the streams cannot be read
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+        if (useJsonStreamer) {
+            return createJsonStreamerEntity();
+        } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
             return createMultipartEntity(progressHandler);
         }
     }
 
+    private HttpEntity createJsonStreamerEntity() throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add non-string params
+        for (ConcurrentHashMap.Entry<String, Object> entry : urlParamsWithObjects.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(),
+                    new FileInputStream(fileWrapper.file),
+                    fileWrapper.file.getName(),
+                    fileWrapper.contentType);
+        }
+
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(),
+                        stream.inputStream,
+                        stream.name,
+                        stream.contentType);
+            }
+        }
+
+        return entity;
+    }
+
     private HttpEntity createFormEntity() {
         try {
-            return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
+            return new UrlEncodedFormEntity(getParamsList(), contentEncoding);
         } catch (UnsupportedEncodingException e) {
-            return null; // Actually cannot happen when using utf-8
+            Log.e(LOG_TAG, "createFormEntity failed", e);
+            return null; // Can happen, if the 'contentEncoding' won't be HTTP.UTF_8
         }
     }
 
@@ -424,10 +490,10 @@ private void init() {
     }
 
     protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
+        return URLEncodedUtils.format(getParamsList(), contentEncoding);
     }
 
-    private static class FileWrapper {
+    public static class FileWrapper {
         public File file;
         public String contentType;
 
@@ -437,7 +503,7 @@ public FileWrapper(File file, String contentType) {
         }
     }
 
-    private static class StreamWrapper {
+    public static class StreamWrapper {
         public InputStream inputStream;
         public String name;
         public String contentType;
diff --git a/library/src/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
similarity index 86%
rename from library/src/com/loopj/android/http/ResponseHandlerInterface.java
rename to library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index 06b2145b..4641a868 100644
--- a/library/src/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -37,6 +37,11 @@
      */
     void sendProgressMessage(int bytesWritten, int bytesTotal);
 
+    /**
+     * Notifies callback, that request was cancelled
+     */
+    void sendCancelMessage();
+
     /**
      * Notifies callback, that request was handled successfully
      *
@@ -58,8 +63,10 @@
 
     /**
      * Notifies callback of retrying request
+     *
+     * @param retryNo number of retry within one request
      */
-    void sendRetryMessage();
+    void sendRetryMessage(int retryNo);
 
     /**
      * Returns URI which was used to request
@@ -95,4 +102,11 @@
      * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
      */
     void setUseSynchronousMode(boolean useSynchronousMode);
+
+    /**
+     * Can set, whether the handler should be asynchronous or synchronous
+     *
+     * @return boolean if the ResponseHandler is running in synchronous mode
+     */
+    boolean getUseSynchronousMode();
 }
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
similarity index 95%
rename from library/src/com/loopj/android/http/RetryHandler.java
rename to library/src/main/java/com/loopj/android/http/RetryHandler.java
index e8ea7cca..d8dffa1d 100644
--- a/library/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -75,12 +75,12 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         if (executionCount > maxRetries) {
             // Do not retry if over max retry count
             retry = false;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
         } else if (isInList(exceptionWhitelist, exception)) {
             // immediately retry if error is whitelisted
             retry = true;
+        } else if (isInList(exceptionBlacklist, exception)) {
+            // immediately cancel retry if the error is blacklisted
+            retry = false;
         } else if (!sent) {
             // for most other errors, retry only if request hasn't been fully sent yet
             retry = true;
@@ -92,8 +92,6 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             if (currentReq == null) {
                 return false;
             }
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
         }
 
         if (retry) {
@@ -105,6 +103,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         return retry;
     }
 
+    static void addClassToWhitelist(Class<?> cls) {
+        exceptionWhitelist.add(cls);
+    }
+
+    static void addClassToBlacklist(Class<?> cls) {
+        exceptionBlacklist.add(cls);
+    }
+
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
         for (Class<?> aList : list) {
             if (aList.isInstance(error)) {
@@ -113,4 +119,4 @@ protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
         }
         return false;
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
similarity index 100%
rename from library/src/com/loopj/android/http/SerializableCookie.java
rename to library/src/main/java/com/loopj/android/http/SerializableCookie.java
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
similarity index 98%
rename from library/src/com/loopj/android/http/SimpleMultipartEntity.java
rename to library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index d4135139..7d134599 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -93,7 +93,7 @@ public void addPart(final String key, final String value, final String contentTy
             out.write(value.getBytes());
             out.write(CR_LF);
         } catch (final IOException e) {
-            // Can't happen on ByteArrayOutputStream
+            // Shall not happen on ByteArrayOutputStream
             Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
         }
     }
@@ -190,7 +190,7 @@ public FilePart(String key, File file, String type) {
         }
 
         public long getTotalLength() {
-            long streamLength = file.length();
+            long streamLength = file.length() + CR_LF.length;
             return header.length + streamLength;
         }
 
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
similarity index 93%
rename from library/src/com/loopj/android/http/SyncHttpClient.java
rename to library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index 22466edd..ac5ca66d 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -7,6 +7,12 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
 
+/**
+ * Processes http requests in synchronous mode, so your caller thread will be blocked on each
+ * request
+ *
+ * @see com.loopj.android.http.AsyncHttpClient
+ */
 public class SyncHttpClient extends AsyncHttpClient {
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
new file mode 100644
index 00000000..b96a263a
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -0,0 +1,105 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
+ * {@link #onSuccess(int, org.apache.http.Header[], String)} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], String, Throwable)}, {@link #onStart()}, and
+ * {@link #onFinish()} methods as required. <p>&nbsp;</p> For example: <p>&nbsp;</p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new TextHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String responseBody) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(String responseBody, Throwable e) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "TextHttpResponseHandler";
+
+    /**
+     * Creates new instance with default UTF-8 encoding
+     */
+    public TextHttpResponseHandler() {
+        this(DEFAULT_CHARSET);
+    }
+
+    /**
+     * Creates new instance with given string encoding
+     *
+     * @param encoding String encoding, see {@link #setCharset(String)}
+     */
+    public TextHttpResponseHandler(String encoding) {
+        super();
+        setCharset(encoding);
+    }
+
+    /**
+     * Called when request fails
+     *
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     * @param throwable      throwable returned when processing request
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable);
+
+    /**
+     * Called when request succeeds
+     *
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String responseString);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getResponseString(responseBytes, getCharset()));
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, getResponseString(responseBytes, getCharset()), throwable);
+    }
+
+    /**
+     * Attempts to encode response bytes as string of set encoding
+     *
+     * @param charset     charset to create string with
+     * @param stringBytes response bytes
+     * @return String of set encoding or null
+     */
+    public static String getResponseString(byte[] stringBytes, String charset) {
+        try {
+            return stringBytes == null ? null : new String(stringBytes, charset);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, "Encoding response into string failed", e);
+            return null;
+        }
+    }
+
+}
diff --git a/maven_push.gradle b/maven_push.gradle
index 6fc6fb30..7131da65 100644
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -15,7 +15,7 @@ if (isReleaseBuild()) {
     println 'DEBUG BUILD'
     sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
 }
-
+if(isReleaseBuild()){
 if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
     if (System.console())
         ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
@@ -98,3 +98,4 @@ afterEvaluate { project ->
         archives androidJavadocsJar
     }
 }
+}
diff --git a/sample/build.gradle b/sample/build.gradle
index d388761d..af693013 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.6.+'
+        classpath 'com.android.tools.build:gradle:0.7.+'
     }
 }
 apply plugin: 'android'
@@ -16,12 +16,22 @@ repositories {
 }
 
 android {
-    compileSdkVersion 18
-    buildToolsVersion "18.0.1"
+    compileSdkVersion 19
+    buildToolsVersion '19.0.1'
 
     defaultConfig {
         minSdkVersion 3
-        targetSdkVersion 18
+        targetSdkVersion 19
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    packagingOptions {
+        exclude 'META-INF/DEPENDENCIES'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/NOTICE'
     }
 }
 
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 3e0a2fa8..a7d337e9 100644
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -6,10 +6,6 @@
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
-    <uses-sdk
-        android:minSdkVersion="3"
-        android:targetSdkVersion="18" />
-
     <application
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
@@ -27,6 +23,7 @@
         <activity android:name=".JsonSample" />
         <activity android:name=".FileSample" />
         <activity android:name=".BinarySample" />
+        <activity android:name=".ThreadingTimeoutSample" />
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
index 46912aaa..68c3620b 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -44,18 +44,18 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, File file) {
+            public void onSuccess(int statusCode, Header[] headers, File response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugFile(getTargetFile());
+                debugFile(response);
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                debugFile(getTargetFile());
+                debugThrowable(LOG_TAG, throwable);
+                debugFile(file);
             }
 
             private void debugFile(File file) {
@@ -68,7 +68,7 @@ private void debugFile(File file) {
                 } catch (Throwable t) {
                     Log.e(LOG_TAG, "Cannot debug file contents", t);
                 }
-                if (!file.delete()) {
+                if (!deleteTargetFile()) {
                     Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
                 }
             }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
index 154804f8..ae701c91 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -49,28 +49,29 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, String rawResponse, SampleJSON response) {
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 if (response != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonResponse);
                 }
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable e, String rawResponse, SampleJSON errorResponse) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
+                debugThrowable(LOG_TAG, throwable);
                 if (errorResponse != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonData);
                 }
             }
 
             @Override
-            protected SampleJSON parseResponse(String responseBody) throws Throwable {
-                return new ObjectMapper().readValues(new JsonFactory().createParser(responseBody), SampleJSON.class).next();
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
             }
+
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index eae9011b..182425d2 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -24,6 +24,7 @@
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 
 public abstract class SampleParentActivity extends Activity {
 
@@ -46,6 +47,7 @@ protected void onCreate(Bundle savedInstanceState) {
         headersEditText = (EditText) findViewById(R.id.edit_headers);
         bodyEditText = (EditText) findViewById(R.id.edit_body);
         Button runButton = (Button) findViewById(R.id.button_run);
+        Button cancelButton = (Button) findViewById(R.id.button_cancel);
         LinearLayout headersLayout = (LinearLayout) findViewById(R.id.layout_headers);
         LinearLayout bodyLayout = (LinearLayout) findViewById(R.id.layout_body);
         responseLayout = (LinearLayout) findViewById(R.id.layout_response);
@@ -56,6 +58,10 @@ protected void onCreate(Bundle savedInstanceState) {
         headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
 
         runButton.setOnClickListener(onClickListener);
+        if (isCancelButtonAllowed() && cancelButton != null) {
+            cancelButton.setVisibility(View.VISIBLE);
+            cancelButton.setOnClickListener(onClickListener);
+        }
     }
 
     private View.OnClickListener onClickListener = new View.OnClickListener() {
@@ -69,6 +75,9 @@ public void onClick(View v) {
                             getRequestEntity(),
                             getResponseHandler());
                     break;
+                case R.id.button_cancel:
+                    asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+                    break;
             }
         }
     };
@@ -109,7 +118,7 @@ protected final void debugHeaders(String TAG, Header[] headers) {
             Log.d(TAG, "Return Headers:");
             StringBuilder builder = new StringBuilder();
             for (Header h : headers) {
-                String _h = String.format("%s : %s", h.getName(), h.getValue());
+                String _h = String.format(Locale.US, "%s : %s", h.getName(), h.getValue());
                 Log.d(TAG, _h);
                 builder.append(_h);
                 builder.append("\n");
@@ -143,7 +152,7 @@ protected final void debugResponse(String TAG, String response) {
     }
 
     protected final void debugStatusCode(String TAG, int statusCode) {
-        String msg = String.format("Return Status Code: %d", statusCode);
+        String msg = String.format(Locale.US, "Return Status Code: %d", statusCode);
         Log.d(TAG, msg);
         addView(getColoredView(LIGHTBLUE, msg));
     }
@@ -171,6 +180,10 @@ protected final void clearOutputs() {
         responseLayout.removeAllViews();
     }
 
+    protected boolean isCancelButtonAllowed() {
+        return false;
+    }
+
     protected abstract int getSampleTitle();
 
     protected abstract boolean isRequestBodyAllowed();
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
new file mode 100644
index 00000000..568537fe
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -0,0 +1,88 @@
+package com.loopj.android.http.sample;
+
+import android.util.SparseArray;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class ThreadingTimeoutSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+    private SparseArray<String> states = new SparseArray<String>();
+    private int counter = 0;
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.app_name;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isCancelButtonAllowed() {
+        return true;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/delay/6";
+    }
+
+    private synchronized void setStatus(int id, String status) {
+        String current = states.get(id, null);
+        states.put(id, current == null ? status : current + "," + status);
+        clearOutputs();
+        for (int i = 0; i < states.size(); i++) {
+            debugResponse(LOG_TAG, states.keyAt(i) + ": " + states.get(states.keyAt(i)));
+        }
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            private int id = counter++;
+
+            @Override
+            public void onStart() {
+                setStatus(id, "START");
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                setStatus(id, "SUCCESS");
+            }
+
+            @Override
+            public void onFinish() {
+                setStatus(id, "FINISH");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                setStatus(id, "FAILURE");
+            }
+
+            @Override
+            public void onCancel() {
+                setStatus(id, "CANCEL");
+            }
+        };
+    }
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 736c5424..857a0ffb 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -9,7 +9,7 @@
 
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY"};
+    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY", "THREADING TIMEOUTS"};
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -43,6 +43,9 @@ protected void onListItemClick(ListView l, View v, int position, long id) {
             case 6:
                 targetClass = BinarySample.class;
                 break;
+            case 7:
+                targetClass = ThreadingTimeoutSample.class;
+                break;
         }
         if (targetClass != null)
             startActivity(new Intent(this, targetClass));
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
index a7ad216e..b32b7b74 100644
--- a/sample/src/main/res/layout/parent_layout.xml
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -30,7 +30,14 @@
                 android:id="@+id/button_run"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="Run" />
+                android:text="@string/button_run" />
+
+            <Button
+                android:id="@+id/button_cancel"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:visibility="gone"
+                android:text="@string/button_cancel" />
         </LinearLayout>
 
         <LinearLayout
@@ -42,7 +49,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="Headers (key=val, one per line)" />
+                android:text="@string/label_headers" />
 
             <EditText
                 android:id="@+id/edit_headers"
@@ -63,7 +70,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="Request body" />
+                android:text="@string/label_req_body" />
 
             <EditText
                 android:id="@+id/edit_body"
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index b8d68899..9e6bae35 100644
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -9,4 +9,8 @@
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
+    <string name="button_run">Run</string>
+    <string name="label_headers">Headers (key=val, one per line)</string>
+    <string name="label_req_body">Request body</string>
+    <string name="button_cancel">Cancel</string>
 </resources>
