diff --git a/.gitignore b/.gitignore
index 8842bb26..4cc83d59 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,7 @@ gen/
 _layouts
 .DS_Store
 gh-pages
+out/
+.idea/
+target/
+*.iml
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 00000000..ee0feb41
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.loopj.android.http</groupId>
+    <artifactId>android-async-http</artifactId>
+    <version>1.4.4-SNAPSHOT</version>
+
+    <distributionManagement>
+        <repository>
+            <id>meituan-nexus-snapshots</id>
+            <name>Meituan Nexus Repository</name>
+            <url>http://nexus:8081/nexus/content/repositories/snapshots</url>
+        </repository>
+    </distributionManagement>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <version>4.1.1.4</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <sourceDirectory>src</sourceDirectory>
+    </build>
+</project>
\ No newline at end of file
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 5f0750d7..2ad98395 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -236,7 +236,7 @@ public void setTimeout(int timeout){
     public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
         this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
     }
-    
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
      * @param header the name of the header
@@ -256,7 +256,7 @@ public void setBasicAuth(String user, String pass){
         AuthScope scope = AuthScope.ANY;
         setBasicAuth(user, pass, scope);
     }
-    
+
    /**
      * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
      * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
@@ -339,11 +339,11 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP GET request and track the Android Context which initiated
      * the request with customized headers
-     * 
+     *
      * @param url the URL to send the request to.
      * @param headers set headers only for this request
      * @param params additional GET parameters to send with the request.
@@ -389,7 +389,7 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
+        post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -407,7 +407,7 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     /**
      * Perform a HTTP POST request and track the Android Context which initiated
      * the request. Set headers only for this request
-     * 
+     *
      * @param context the Android Context which initiated the request.
      * @param url the URL to send the request to.
      * @param headers set headers only for this request
@@ -418,9 +418,9 @@ public void post(Context context, String url, HttpEntity entity, String contentT
      *        the response.
      */
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
+        if(params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if(headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
@@ -442,7 +442,7 @@ public void post(Context context, String url, Header[] headers, RequestParams pa
      *        the response.
      */
     public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
         if(headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
@@ -479,7 +479,7 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
+        put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -494,7 +494,7 @@ public void put(Context context, String url, RequestParams params, AsyncHttpResp
     public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
      * And set one-time headers for the request
@@ -534,7 +534,7 @@ public void delete(Context context, String url, AsyncHttpResponseHandler respons
         final HttpDelete delete = new HttpDelete(url);
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP DELETE request.
      * @param context the Android Context which initiated the request.
@@ -584,11 +584,11 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
-    private HttpEntity paramsToEntity(RequestParams params) {
+    private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpEntity entity = null;
 
         if(params != null) {
-            entity = params.getEntity();
+            entity = params.getEntity(responseHandler);
         }
 
         return entity;
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 2030265f..9fa6c465 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,14 +21,16 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import org.apache.commons.io.IOUtils;
 import org.apache.http.Header;
+
 import java.io.IOException;
+import java.io.InputStream;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
 
 import android.os.Handler;
 import android.os.Looper;
@@ -36,7 +38,7 @@
 
 /**
  * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
  * designed to be anonymously overridden with your own response handling code.
  * <p>
  * Additionally, you can override the {@link #onFailure(Throwable, String)},
@@ -56,7 +58,7 @@
  *     public void onSuccess(String response) {
  *         // Successfully got a response
  *     }
- * 
+ *
  *     &#064;Override
  *     public void onFailure(Throwable e, String response) {
  *         // Response failed :(
@@ -74,8 +76,10 @@
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
 
     private Handler handler;
+    protected String url;
 
     /**
      * Creates a new AsyncHttpResponseHandler
@@ -151,6 +155,10 @@ public void onFailure(Throwable error, String content) {
         onFailure(error);
     }
 
+    /**
+     * Fired when the request progress, override to handle in your own code
+     */
+    public void onProgress(long position, long length) {}
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
@@ -163,7 +171,7 @@ protected void sendSuccessMessage(int statusCode, Header[] headers, String respo
     protected void sendFailureMessage(Throwable e, String responseBody) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
     }
-    
+
     protected void sendFailureMessage(Throwable e, byte[] responseBody) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
     }
@@ -176,6 +184,9 @@ protected void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
+    protected void sendProgressMessage(long position, long length) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{position, length}));
+    }
 
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
@@ -202,7 +213,7 @@ protected void handleMessage(Message msg) {
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
+                handleFailureMessage((Throwable)response[0], (String) response[1]);
                 break;
             case START_MESSAGE:
                 onStart();
@@ -210,6 +221,10 @@ protected void handleMessage(Message msg) {
             case FINISH_MESSAGE:
                 onFinish();
                 break;
+            case PROGRESS_MESSAGE:
+                response = (Object[])msg.obj;
+                onProgress(((Long)response[0]).longValue(), ((Long)response[1]).longValue());
+                break;
         }
     }
 
@@ -237,15 +252,23 @@ protected Message obtainMessage(int responseMessage, Object response) {
     void sendResponseMessage(HttpResponse response) {
         StatusLine status = response.getStatusLine();
         String responseBody = null;
+        InputStream inputStream = null;
         try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
+            final HttpEntity temp = response.getEntity();
             if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
+                inputStream = new CountingInputStream(temp.getContent(), new CountingInputStream.CountingListener() {
+                    @Override
+                    public void onReadCount(long count) {
+                        sendProgressMessage(count, temp.getContentLength());
+                    }
+                });
+
+                responseBody = IOUtils.toString(inputStream);
             }
         } catch(IOException e) {
             sendFailureMessage(e, (String) null);
+        } finally {
+            IOUtils.closeQuietly(inputStream);
         }
 
         if(status.getStatusCode() >= 300) {
@@ -254,4 +277,9 @@ void sendResponseMessage(HttpResponse response) {
             sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
         }
     }
+
+    public AsyncHttpResponseHandler with(String url) {
+        this.url = url;
+        return this;
+    }
 }
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 7d675a59..901a4155 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -19,22 +19,22 @@
 package com.loopj.android.http;
 
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.regex.Pattern;
 
+import org.apache.commons.io.IOUtils;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
 
 import android.os.Message;
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * {@link AsyncHttpClient}. Receives response body as byte array with a
+ * content-type whitelist. (e.g. checks Content-Type against allowed list,
  * Content-length).
  * <p>
  * For example:
@@ -119,11 +119,6 @@ protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
     }
 
-    @Override
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
@@ -143,11 +138,11 @@ protected void handleMessage(Message msg) {
         switch(msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
+                handleSuccessMessage(((Integer) response[0]).intValue(), (byte[]) response[1]);
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], response[1].toString());
+                handleFailureMessage((Throwable)response[0], response[1] == null ? "" : response[1].toString());
                 break;
             default:
                 super.handleMessage(msg);
@@ -178,15 +173,23 @@ void sendResponseMessage(HttpResponse response) {
             sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
             return;
         }
+        InputStream inputStream = null;
         try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
+            final HttpEntity temp = response.getEntity();
             if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
+                inputStream = new CountingInputStream(temp.getContent(), new CountingInputStream.CountingListener() {
+                    @Override
+                    public void onReadCount(long count) {
+                        sendProgressMessage(count, temp.getContentLength());
+                    }
+                });
+
+                responseBody = IOUtils.toByteArray(inputStream);
             }
-            responseBody = EntityUtils.toByteArray(entity);
         } catch(IOException e) {
             sendFailureMessage(e, (byte[]) null);
+        } finally {
+            IOUtils.closeQuietly(inputStream);
         }
 
         if(status.getStatusCode() >= 300) {
diff --git a/src/com/loopj/android/http/CountingInputStream.java b/src/com/loopj/android/http/CountingInputStream.java
new file mode 100644
index 00000000..88ace9c2
--- /dev/null
+++ b/src/com/loopj/android/http/CountingInputStream.java
@@ -0,0 +1,87 @@
+package com.loopj.android.http;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: wangkang
+ * Date: 13-6-18
+ * Time: 下午8:16
+ * To change this template use File | Settings | File Templates.
+ */
+public final class CountingInputStream extends FilterInputStream {
+
+    private CountingListener countingListener;
+    private long count;
+    private long mark = -1;
+
+    /**
+     * Wraps another input stream, counting the number of bytes read.
+     *
+     * @param in the input stream to be wrapped
+     */
+    public CountingInputStream(java.io.InputStream in) {
+        super(in);
+    }
+
+    public CountingInputStream(java.io.InputStream in, CountingListener countingListener) {
+        super(in);
+        this.countingListener = countingListener;
+    }
+
+    /** Returns the number of bytes read. */
+    public long getCount() {
+        return count;
+    }
+
+    @Override public int read() throws IOException {
+        int result = in.read();
+        if (result != -1) {
+            count++;
+            if (countingListener != null) {
+                countingListener.onReadCount(count);
+            }
+        }
+        return result;
+    }
+
+    @Override public int read(byte[] b, int off, int len) throws IOException {
+        int result = in.read(b, off, len);
+        if (result != -1) {
+            count += result;
+            if (countingListener != null) {
+                countingListener.onReadCount(count);
+            }
+        }
+        return result;
+    }
+
+    @Override public long skip(long n) throws IOException {
+        long result = in.skip(n);
+        count += result;
+        return result;
+    }
+
+    @Override public synchronized void mark(int readlimit) {
+        in.mark(readlimit);
+        mark = count;
+        // it's okay to mark even if mark isn't supported, as reset won't work
+    }
+
+    @Override public synchronized void reset() throws IOException {
+        if (!in.markSupported()) {
+            throw new IOException("Mark not supported");
+        }
+        if (mark == -1) {
+            throw new IOException("Mark not set");
+        }
+
+        in.reset();
+        count = mark;
+    }
+
+    public interface CountingListener {
+        void onReadCount(long count);
+    }
+}
diff --git a/src/com/loopj/android/http/CountingOutputStream.java b/src/com/loopj/android/http/CountingOutputStream.java
new file mode 100644
index 00000000..254f05a1
--- /dev/null
+++ b/src/com/loopj/android/http/CountingOutputStream.java
@@ -0,0 +1,74 @@
+package com.loopj.android.http;
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: wangkang
+ * Date: 13-6-18
+ * Time: 上午12:22
+ * To change this template use File | Settings | File Templates.
+ */
+public final class CountingOutputStream extends FilterOutputStream {
+
+    private CountingListener countingListener;
+    private long count;
+
+    /**
+     * Wraps another output stream, counting the number of bytes written.
+     *
+     * @param out the output stream to be wrapped
+     */
+    public CountingOutputStream(OutputStream out) {
+        super(out);
+    }
+
+    public CountingOutputStream(OutputStream out, CountingListener countingListener) {
+        super(out);
+        this.countingListener = countingListener;
+    }
+
+    /**
+     * Returns the number of bytes written.
+     */
+    public long getCount() {
+        return count;
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        out.write(b, off, len);
+        count += len;
+        if (countingListener != null) {
+            countingListener.onWriteCount(count);
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        out.write(b);
+        count++;
+        if (countingListener != null) {
+            countingListener.onWriteCount(count);
+        }
+    }
+
+    @Override
+    public void write(byte[] buffer) throws IOException {
+        super.write(buffer);
+        if (countingListener != null) {
+            countingListener.onWriteCount(count);
+        }
+    }
+
+    public OutputStream getOutputStream() {
+        return out;
+    }
+
+    public interface CountingListener {
+        void onWriteCount(long count);
+    }
+}
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index cbb0c288..c4def9ac 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -100,15 +100,15 @@ public RequestParams(String key, String value) {
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
+        init();
+        int len = keysAndValues.length;
+        if (len % 2 != 0)
+            throw new IllegalArgumentException("Supplied arguments must be even");
+        for (int i = 0; i < len; i += 2) {
+            String key = String.valueOf(keysAndValues[i]);
+            String val = String.valueOf(keysAndValues[i + 1]);
+            put(key, val);
+        }
     }
 
     /**
@@ -224,12 +224,13 @@ public String toString() {
 
    /**
      * Returns an HttpEntity containing all request parameters
+     * @param progressHandler
      */
-    public HttpEntity getEntity() {
+    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) {
         HttpEntity entity = null;
 
         if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity(progressHandler);
 
             // Add string params
             for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -318,4 +319,4 @@ public String getFileName() {
             }
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index 3221ec1e..6d4b2462 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -33,6 +33,7 @@
 import java.io.OutputStream;
 import java.util.Random;
 
+import org.apache.commons.io.IOUtils;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
@@ -42,18 +43,20 @@
 
     private String boundary = null;
 
+    private AsyncHttpResponseHandler progressHandler;
+
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     boolean isSetLast = false;
     boolean isSetFirst = false;
 
-    public SimpleMultipartEntity() {
+    public SimpleMultipartEntity(AsyncHttpResponseHandler progressHandler) {
         final StringBuffer buf = new StringBuffer();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
         }
         this.boundary = buf.toString();
-
+        this.progressHandler = progressHandler;
     }
 
     public void writeFirstBoundaryIfNeeds(){
@@ -83,7 +86,7 @@ public void writeLastBoundaryIfNeeds() {
         } catch (final IOException e) {
             e.printStackTrace();
         }
-        
+
         isSetLast = true;
     }
 
@@ -121,7 +124,7 @@ public void addPart(final String key, final String fileName, final InputStream f
                 out.write(tmp, 0, l);
             }
             out.write(("\r\n").getBytes());
-            
+
         } catch (final IOException e) {
             e.printStackTrace();
         } finally {
@@ -170,7 +173,13 @@ public boolean isStreaming() {
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
         writeLastBoundaryIfNeeds();
-        outstream.write(out.toByteArray());
+        // outstream.write(out.toByteArray());
+        IOUtils.write(out.toByteArray(), new CountingOutputStream(outstream, new CountingOutputStream.CountingListener() {
+            @Override
+            public void onWriteCount(long count) {
+                progressHandler.onProgress(count, getContentLength());
+            }
+        }));
     }
 
     @Override
@@ -180,17 +189,17 @@ public Header getContentEncoding() {
 
     @Override
     public void consumeContent() throws IOException,
-    UnsupportedOperationException {
+            UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
+                    "Streaming entity does not implement #consumeContent()");
         }
     }
 
     @Override
     public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-    	writeLastBoundaryIfNeeds();
+            UnsupportedOperationException {
+        writeLastBoundaryIfNeeds();
         return new ByteArrayInputStream(out.toByteArray());
     }
 }
\ No newline at end of file
