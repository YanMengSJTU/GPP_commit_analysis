diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 8361ade8..0f14c9de 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -32,6 +32,7 @@
         <activity android:name=".IntentServiceSample"/>
         <activity android:name=".SaxSample"/>
         <activity android:name=".FilesSample"/>
+        <activity android:name=".CustomCASample"/>
 
         <service android:name=".services.ExampleIntentService"/>
     </application>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
new file mode 100644
index 00000000..4ed75c4a
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
@@ -0,0 +1,193 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SecureSocketFactory;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+
+/**
+ * This sample demonstrates the implementation of self-signed CA's and connection to servers with
+ * such certificates. Be sure to read 'res/raw/custom_ca.txt' for how-to instructions on how to
+ * generate a BKS file necessary for this sample.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class CustomCASample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "CustomCASample";
+
+    private static final String SERVER_TEST_URL = "https://httpbin.org/get";
+    private static final String STORE_ALIAS = "TheAlias";
+    private static final String STORE_PASS = "ThePass";
+
+    // Instruct the library to retry connection when this exception is raised.
+    static {
+        AsyncHttpClient.allowRetryExceptionClass(javax.net.ssl.SSLException.class);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        try {
+            InputStream is = null;
+            try {
+                // Configure the library to use a custom 'bks' file to perform
+                // SSL negotiation.
+                KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());
+                is = getResources().openRawResource(R.raw.store);
+                store.load(is, STORE_PASS.toCharArray());
+                getAsyncHttpClient().setSSLSocketFactory(new SecureSocketFactory(store, STORE_ALIAS));
+            } catch (IOException e) {
+                throw new KeyStoreException(e);
+            } catch (CertificateException e) {
+                throw new KeyStoreException(e);
+            } catch (NoSuchAlgorithmException e) {
+                throw new KeyStoreException(e);
+            } catch (KeyManagementException e) {
+                throw new KeyStoreException(e);
+            } catch (UnrecoverableKeyException e) {
+                throw new KeyStoreException(e);
+            } finally {
+                AsyncHttpClient.silentCloseInputStream(is);
+            }
+        } catch (KeyStoreException e) {
+            Log.e(LOG_TAG, "Unable to initialize key store", e);
+            Toast.makeText(
+                    this,
+                    "Please read res/raw/custom_ca.txt\nto learn how to create your own\nkey store containing a custom CA",
+                    Toast.LENGTH_LONG).show();
+            showCustomCAHelp();
+        }
+    }
+
+    /**
+     * Returns contents of `custom_ca.txt` as CharSequence
+     *
+     * @return contents of custom_ca.txt from Assets
+     */
+    private CharSequence getReadmeText() {
+        String rtn = "";
+        try {
+            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
+            java.util.Scanner s = new java.util.Scanner(stream)
+                    .useDelimiter("\\A");
+            rtn = s.hasNext() ? s.next() : "";
+        } catch (Exception | Error e) {
+            Log.e(LOG_TAG, "License couldn't be retrieved", e);
+        }
+        return rtn;
+    }
+
+    /**
+     * Will display AlertDialog reading `custom_ca.txt` from Assets, to avoid strict Lint issue
+     */
+    private void showCustomCAHelp() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.title_custom_ca);
+        builder.setMessage(getReadmeText());
+        builder.setNeutralButton(android.R.string.cancel,
+                new DialogInterface.OnClickListener() {
+
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        dialog.dismiss();
+                    }
+                }
+        );
+        builder.show();
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_custom_ca;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return true;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return SERVER_TEST_URL;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BinaryHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public String[] getAllowedContentTypes() {
+                // Allowing all data for debug purposes
+                return new String[]{".*"};
+            }
+
+            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
+                debugStatusCode(LOG_TAG, statusCode);
+                debugHeaders(LOG_TAG, headers);
+                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
+                }
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
new file mode 100644
index 00000000..46133fd2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
@@ -0,0 +1,121 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.PersistentCookieStore;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.CookieStore;
+
+public class PersistentCookiesSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PersistentCookiesSample";
+
+    private CookieStore cookieStore;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        // Use the application's context so that memory leakage doesn't occur.
+        cookieStore = new PersistentCookieStore(getApplicationContext());
+
+        // Set the new cookie store.
+        getAsyncHttpClient().setCookieStore(cookieStore);
+
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_persistent_cookies;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        // The base URL for testing cookies.
+        String url = "http://httpbin.org/cookies";
+
+        // If the cookie store is empty, suggest a cookie.
+        if(cookieStore.getCookies().isEmpty()) {
+            url += "/set?time=" + System.currentTimeMillis();
+        }
+
+        return url;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index d559b8d5..80296dfc 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -125,7 +125,7 @@ public void onClick(View v) {
         }
     };
 
-    public Header[] getRequestHeaders() {
+    public List<Header> getRequestHeadersList() {
         List<Header> headers = new ArrayList<Header>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
@@ -133,15 +133,25 @@ public void onClick(View v) {
             String[] lines = headersRaw.split("\\r?\\n");
             for (String line : lines) {
                 try {
-                    String[] kv = line.split("=");
-                    if (kv.length != 2)
+                    int equalSignPos = line.indexOf('=');
+                    if (1 > equalSignPos) {
                         throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
-                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                    }
+
+                    String headerName = line.substring(0, equalSignPos).trim();
+                    String headerValue = line.substring(1 + equalSignPos).trim();
+
+                    headers.add(new BasicHeader(headerName, headerValue));
                 } catch (Throwable t) {
                     Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
                 }
             }
         }
+        return headers;
+    }
+
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
         return headers.toArray(new Header[headers.size()]);
     }
 
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 2d8a42c3..6854a945 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -46,7 +46,9 @@
         new SampleConfig(R.string.title_cancel_handle, CancelRequestHandleSample.class),
         new SampleConfig(R.string.title_synchronous, SynchronousClientSample.class),
         new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
-        new SampleConfig(R.string.title_post_files, FilesSample.class)
+        new SampleConfig(R.string.title_post_files, FilesSample.class),
+        new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class),
+        new SampleConfig(R.string.title_custom_ca, CustomCASample.class)
     };
 
     @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
new file mode 100644
index 00000000..02d5569d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
@@ -0,0 +1,195 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
+
+import android.annotation.TargetApi;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.InvalidKeyException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.security.SignatureException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * A class to authenticate a secured connection against a custom CA using a BKS store.
+ *
+ * @author Noor Dawod <github@fineswap.com>
+ */
+public class SecureSocketFactory extends SSLSocketFactory {
+
+    private static final String LOG_TAG = "SecureSocketFactory";
+
+    private final SSLContext sslCtx;
+    private final X509Certificate[] acceptedIssuers;
+
+    /**
+     * Instantiate a new secured factory pertaining to the passed store. Be sure to initialize the
+     * store with the password using {@link java.security.KeyStore#load(java.io.InputStream,
+     * char[])} method.
+     *
+     * @param store The key store holding the certificate details
+     * @param alias The alias of the certificate to use
+     */
+    public SecureSocketFactory(KeyStore store, String alias)
+            throws
+            CertificateException,
+            NoSuchAlgorithmException,
+            KeyManagementException,
+            KeyStoreException,
+            UnrecoverableKeyException {
+
+        super(store);
+
+        // Loading the CA certificate from store.
+        final Certificate rootca = store.getCertificate(alias);
+
+        // Turn it to X509 format.
+        InputStream is = new ByteArrayInputStream(rootca.getEncoded());
+        X509Certificate x509ca = (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(is);
+        AsyncHttpClient.silentCloseInputStream(is);
+
+        if (null == x509ca) {
+            throw new CertificateException("Embedded SSL certificate has expired.");
+        }
+
+        // Check the CA's validity.
+        x509ca.checkValidity();
+
+        // Accepted CA is only the one installed in the store.
+        acceptedIssuers = new X509Certificate[]{x509ca};
+
+        sslCtx = SSLContext.getInstance("TLS");
+        sslCtx.init(
+                null,
+                new TrustManager[]{
+                        new X509TrustManager() {
+                            @Override
+                            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                            }
+
+                            @Override
+                            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                                Exception error = null;
+
+                                if (null == chain || 0 == chain.length) {
+                                    error = new CertificateException("Certificate chain is invalid.");
+                                } else if (null == authType || 0 == authType.length()) {
+                                    error = new CertificateException("Authentication type is invalid.");
+                                } else {
+                                    Log.i(LOG_TAG, "Chain includes " + chain.length + " certificates.");
+                                    try {
+                                        for (X509Certificate cert : chain) {
+                                            Log.i(LOG_TAG, "Server Certificate Details:");
+                                            Log.i(LOG_TAG, "---------------------------");
+                                            Log.i(LOG_TAG, "IssuerDN: " + cert.getIssuerDN().toString());
+                                            Log.i(LOG_TAG, "SubjectDN: " + cert.getSubjectDN().toString());
+                                            Log.i(LOG_TAG, "Serial Number: " + cert.getSerialNumber());
+                                            Log.i(LOG_TAG, "Version: " + cert.getVersion());
+                                            Log.i(LOG_TAG, "Not before: " + cert.getNotBefore().toString());
+                                            Log.i(LOG_TAG, "Not after: " + cert.getNotAfter().toString());
+                                            Log.i(LOG_TAG, "---------------------------");
+
+                                            // Make sure that it hasn't expired.
+                                            cert.checkValidity();
+
+                                            // Verify the certificate's public key chain.
+                                            cert.verify(rootca.getPublicKey());
+                                        }
+                                    } catch (InvalidKeyException e) {
+                                        error = e;
+                                    } catch (NoSuchAlgorithmException e) {
+                                        error = e;
+                                    } catch (NoSuchProviderException e) {
+                                        error = e;
+                                    } catch (SignatureException e) {
+                                        error = e;
+                                    }
+                                }
+                                if (null != error) {
+                                    Log.e(LOG_TAG, "Certificate error", error);
+                                    throw new CertificateException(error);
+                                }
+                            }
+
+                            @Override
+                            public X509Certificate[] getAcceptedIssuers() {
+                                return acceptedIssuers;
+                            }
+                        }
+                },
+                null
+        );
+
+        setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+            throws IOException {
+
+        injectHostname(socket, host);
+        return sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslCtx.getSocketFactory().createSocket();
+    }
+
+    /**
+     * Pre-ICS Android had a bug resolving HTTPS addresses. This workaround fixes that bug.
+     *
+     * @param socket The socket to alter
+     * @param host   Hostname to connect to
+     * @see <a href="https://code.google.com/p/android/issues/detail?id=13117#c14">https://code.google.com/p/android/issues/detail?id=13117#c14</a>
+     */
+    @TargetApi(4)
+    private void injectHostname(Socket socket, String host) {
+        try {
+            if (android.os.Build.VERSION.SDK_INT < 14) {
+                Field field = InetAddress.class.getDeclaredField("hostName");
+                field.setAccessible(true);
+                field.set(socket.getInetAddress(), host);
+            }
+        } catch (Exception ignored) {
+        }
+    }
+}
diff --git a/sample/src/main/res/raw/custom_ca.txt b/sample/src/main/res/raw/custom_ca.txt
new file mode 100644
index 00000000..a601671d
--- /dev/null
+++ b/sample/src/main/res/raw/custom_ca.txt
@@ -0,0 +1,55 @@
+This is a short HOW-TO documenting the steps necessary to create a key store
+file that Android could use to connect to servers with a custom CA.
+
+Prerequisities:
+---------------
+
+1) Access to a computer with 'openssl' command;
+2) The 'keytool' command available in Java SE 6 and above;
+3) BouncyCastle jar version 1.46 (http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)
+
+Important:
+----------
+
+If you use the wrong BouncyCastle jar (for example, a newer version), older
+Android handsets might fail with the error "Wrong version of key store". So we
+advise to use an older BouncyCastle jar to cover older handsets.
+
+Let's see the fun part:
+-----------------------
+
+1) Create a self-signed CA using the openssl tool. You may bypass this step if
+   you already have a self-signed CA from before:
+
+   openssl req -newkey rsa:4096 -days 3650 -x509 -nodes -out ca.pem
+
+   You will be asked to provide details of the CA. When you're finished, a file
+   called 'ca.pem' will exist in current directory.
+
+2) Android has built-in support for the Bouncy Castle key store format (BKS).
+   You should have downloaded BouncyCastle's jar; we assume the path to that jar
+   is 'path/to/jar/bcprov.jar'. Now create a key store file containing your
+   self-signed CA:
+
+   keytool \
+      -import \
+      -v \
+      -trustcacerts \
+      -file ca.pem \
+      -keystore store.bks \
+      -storetype BKS \
+      -provider org.bouncycastle.jce.provider.BouncyCastleProvider \
+      -providerpath path/to/jar/bcprov.jar \
+      -alias TheAlias \
+      -storepass ThePass
+
+   keytool will ask to verify the certificate, naturally you should do so by
+   typing "yes" (without parentheses) and hitting Enter.
+
+   Note the alias and the password at the last two lines; you will need to enter
+   both in CustomCASample.java before running the sample app.
+
+3) If all went smoothly, you should have a file named store.bks which contains
+   the self-signed CA that we prepared in step 1. Move the resulting file to the
+   'res/raw/' directory, adjust the alias and password in CustomCASample.java
+   file, rebuild the app and run it.
diff --git a/sample/src/main/res/raw/store.bks b/sample/src/main/res/raw/store.bks
new file mode 100644
index 00000000..e69de29b
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 48c71f14..4b4b9d9f 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -15,7 +15,7 @@
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
-    <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_cancel_all">Cancel all requests</string>
     <string name="title_sax_example">SAX Example</string>
     <string name="title_cancel_handle">Cancel request handle</string>
     <string name="title_synchronous">Synchronous GET request</string>
@@ -24,4 +24,6 @@
     <string name="title_intent_service_sample">IntentService Synchronised Request</string>
     <string name="title_post_files">Post Multipart-encoded files</string>
     <string name="title_redirect_302">302 Redirect handling</string>
+    <string name="title_persistent_cookies">Handling persistent cookies</string>
+    <string name="title_custom_ca">Custom CA Example</string>
 </resources>
