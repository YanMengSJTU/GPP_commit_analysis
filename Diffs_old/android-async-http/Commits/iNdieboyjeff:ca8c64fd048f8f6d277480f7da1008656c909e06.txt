diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 3d312e26..b16e4213 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -179,7 +179,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
-        Log.d(LOG_TAG, String.format("Progress %d from %d (%d)", bytesWritten, totalSize, bytesWritten / (totalSize / 100)));
+        Log.d(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
     }
 
     /**
@@ -370,11 +370,9 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                if (contentLength < 0) {
-                    contentLength = BUFFER_SIZE;
-                }
+                int buffersize =  (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) buffersize);
                     try {
                         byte[] tmp = new byte[BUFFER_SIZE];
                         int l, count = 0;
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index c17b15b4..181019e7 100644
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -18,8 +18,6 @@
 
 package com.loopj.android.http;
 
-import android.util.Base64;
-import android.util.Base64OutputStream;
 import android.util.Log;
 
 import org.apache.http.Header;
@@ -27,8 +25,6 @@
 import org.apache.http.message.BasicHeader;
 
 import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -49,44 +45,50 @@
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
         new UnsupportedOperationException("Unsupported operation in this implementation.");
 
+    // Size of the byte-array buffer used to read from streams.
+    private static final int BUFFER_SIZE = 2048;
+
+    // Reusable StringBuilder used by escape() method.
+    // Base64, at worst, will make a binary stream grow in size by approximately
+    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
+    // large 'n'.
+    private static final StringBuilder BUILDER =
+        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
-    private static final byte[] STREAM_NAME = escape("name", true).getBytes();
-    private static final byte[] STREAM_TYPE = escape("type", true).getBytes();
-    private static final byte[] STREAM_CONTENTS = escape("contents", true).getBytes();
-    private static final byte[] STREAM_ELAPSED = escape("_elapsed", true).getBytes();
+    private static final byte[] JSON_NULL = "null".getBytes();
+    private static final byte[] STREAM_NAME = escape("name");
+    private static final byte[] STREAM_TYPE = escape("type");
+    private static final byte[] STREAM_CONTENTS = escape("contents");
+    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
-    private static final Header HEADER_JSON =
+    private static final Header HEADER_JSON_CONTENT =
         new BasicHeader("Content-Type", "application/json");
+    private static final Header HEADER_GZIP_ENCODING =
+        new BasicHeader("Content-Encoding", "gzip");
     private static final String APPLICATION_OCTET_STREAM =
         "application/octet-stream";
 
-    // Size of the byte-array buffer used to read from files.
-    private static final int BUFFER_SIZE = 2048;
-
     // K/V objects to be uploaded.
-    private final Map<String, Object> kvParams = new HashMap<String, Object>();
+    private final Map<String, Object> kvParams =
+        new HashMap<String, Object>();
 
     // Streams and their associated meta-data to be uploaded.
-    private final Map<String, RequestParams.StreamWrapper> streamParams = new HashMap<String, RequestParams.StreamWrapper>();
+    private final Map<String, RequestParams.StreamWrapper> streamParams =
+        new HashMap<String, RequestParams.StreamWrapper>();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
     public JsonStreamerEntity(boolean contentEncoding) {
-        this.contentEncoding = contentEncoding
-            ? new BasicHeader("Content-Encoding", "gzip")
-            : null;
+        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
     }
 
     public void addPart(String key, Object value) {
         kvParams.put(key, value);
     }
 
-    public void addPart(String key, File file, String type) throws IOException {
-        addPart(key, new FileInputStream(file), file.getName(), type);
-    }
-
     public void addPart(String key, InputStream inputStream, String name, String type) {
         if (type == null) {
             type = APPLICATION_OCTET_STREAM;
@@ -121,7 +123,7 @@ public Header getContentEncoding() {
 
     @Override
     public Header getContentType() {
-        return HEADER_JSON;
+        return HEADER_JSON_CONTENT;
     }
 
     @Override
@@ -139,13 +141,16 @@ public void writeTo(final OutputStream outstream) throws IOException {
             throw new IllegalStateException("Output stream cannot be null.");
         }
 
+        // Record the time when uploading started.
         long now = System.currentTimeMillis();
-        Log.i(LOG_TAG, "Started dumping at: " + now);
 
-        OutputStream upload;
+        // Keys used by the HashMaps.
+        Set<String> keys;
 
-        // GZIPOutputStream is available only from API level 8 and onward.
-        if(null != contentEncoding) {
+        // Use GZIP compression when sending streams, otherwise just use
+        // a buffered output stream to speed things up a bit.
+        OutputStream upload;
+        if (null != contentEncoding) {
             upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
         } else {
             upload = new BufferedOutputStream(outstream);
@@ -154,21 +159,18 @@ public void writeTo(final OutputStream outstream) throws IOException {
         // Always send a JSON object.
         upload.write('{');
 
-        // Keys used by the HashMaps.
-        Set<String> keys;
-
         // Send the K/V values.
         keys = kvParams.keySet();
         for (String key : keys) {
             // Write the JSON object's key.
-            upload.write(escape(key, true).getBytes());
+            upload.write(escape(key));
             upload.write(':');
 
             // Evaluate the value (which cannot be null).
             Object value = kvParams.get(key);
 
             if (value instanceof Boolean) {
-                upload.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
+                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
                 upload.write((((Number)value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
@@ -189,113 +191,129 @@ public void writeTo(final OutputStream outstream) throws IOException {
 
         // Send the stream params.
         keys = streamParams.keySet();
-        for(String key : keys) {
+        for (String key : keys) {
             RequestParams.StreamWrapper entry = streamParams.get(key);
 
             // Write the JSON object's key.
-            upload.write(escape(key, true).getBytes());
+            upload.write(escape(key));
 
             // All uploads are sent as an object containing the file's details.
-            upload.write(":{".getBytes());
+            upload.write(':');
+            upload.write('{');
 
             // Send the streams's name.
             upload.write(STREAM_NAME);
             upload.write(':');
-            upload.write(escape(entry.name, true).getBytes());
+            upload.write(escape(entry.name));
+            upload.write(',');
 
             // Send the streams's content type.
             upload.write(STREAM_TYPE);
             upload.write(':');
-            upload.write(escape(entry.contentType, true).getBytes());
+            upload.write(escape(entry.contentType));
+            upload.write(',');
 
             // Prepare the file content's key.
             upload.write(STREAM_CONTENTS);
             upload.write(':');
             upload.write('"');
 
-            // Write the file's contents in Base64.
-            Base64OutputStream outputStream = new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
+            // Upload the file's contents in Base64.
+            Base64OutputStream outputStream =
+                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+            // Read from input stream until no more data's left to read.
             int bytesRead;
-            while(-1 != (bytesRead = entry.inputStream.read(buffer))) {
+            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
                 outputStream.write(buffer, 0, bytesRead);
             }
 
-            // Close the output stream.
+            // Close the Base64 output stream.
             outputStream.close();
 
-            // Close the file's object.
+            // End the file's object and prepare for next one.
             upload.write('"');
             upload.write('}');
             upload.write(',');
         }
 
         // Include the elapsed time taken to upload everything.
+        // This might be useful for somebody, but it serves us well since
+        // there will almost always be a ',' as the last sent character.
         upload.write(STREAM_ELAPSED);
         upload.write(':');
         long elapsedTime = System.currentTimeMillis() - now;
         upload.write((elapsedTime + "}").getBytes());
 
-        Log.i(LOG_TAG, "JSON was uploaded in " + Math.floor(elapsedTime / 1000) + " seconds");
+        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
 
         // Flush the contents up the stream.
         upload.flush();
         upload.close();
     }
 
-    // Curtosy of Simple-JSON:
-    // http://goo.gl/XoW8RF
-    private static String escape(String string, boolean quotes) {
-        StringBuilder sb = new StringBuilder();
-        int length = string.length(), pos = -1;
-        if (quotes) {
-          sb.append('"');
+    // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
+    // Changed a bit to suit our needs in this class.
+    static byte[] escape(String string) {
+        // If it's null, just return prematurely.
+        if (string == null) {
+          return JSON_NULL;
         }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        int length = string.length(), pos = -1;
         while (++pos < length) {
             char ch = string.charAt(pos);
             switch (ch) {
                 case '"':
-                    sb.append("\\\"");
+                    BUILDER.append("\\\"");
                     break;
                 case '\\':
-                    sb.append("\\\\");
+                    BUILDER.append("\\\\");
                     break;
                 case '\b':
-                    sb.append("\\b");
+                    BUILDER.append("\\b");
                     break;
                 case '\f':
-                    sb.append("\\f");
+                    BUILDER.append("\\f");
                     break;
                 case '\n':
-                    sb.append("\\n");
+                    BUILDER.append("\\n");
                     break;
                 case '\r':
-                    sb.append("\\r");
+                    BUILDER.append("\\r");
                     break;
                 case '\t':
-                    sb.append("\\t");
-                    break;
-                case '/':
-                    sb.append("\\/");
+                    BUILDER.append("\\t");
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
                     if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
-                        sb.append("\\u");
+                        BUILDER.append("\\u");
                         int intLength = 4 - intString.length();
                         for (int zero = 0; zero < intLength; zero++) {
-                            sb.append('0');
+                            BUILDER.append('0');
                         }
-                        sb.append(intString.toUpperCase());
+                        BUILDER.append(intString.toUpperCase());
                     } else {
-                        sb.append(ch);
+                        BUILDER.append(ch);
                     }
                     break;
             }
         }
-        if (quotes) {
-          sb.append('"');
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        try {
+          return BUILDER.toString().getBytes();
+        } finally {
+          // Empty the String buffer.
+          // This is 20-30% faster than instantiating a new object.
+          BUILDER.setLength(0);
         }
-        return sb.toString();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 0d7e92f7..825132fd 100644
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -25,6 +25,7 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -314,9 +315,6 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
     }
 
     public void setUseJsonStreamer(boolean useJsonStreamer) {
-        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.FROYO) {
-            throw new IllegalStateException("Use of JSON streamer is available for API level 8 and later.");
-        }
         this.useJsonStreamer = useJsonStreamer;
     }
 
@@ -354,14 +352,20 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
             FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+            entity.addPart(entry.getKey(),
+                           new FileInputStream(fileWrapper.file),
+                           fileWrapper.file.getName(),
+                           fileWrapper.contentType);
         }
 
         // Add stream params
         for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
-                entity.addPart(entry.getKey(), stream.inputStream, stream.name, stream.contentType);
+                entity.addPart(entry.getKey(),
+                               stream.inputStream,
+                               stream.name,
+                               stream.contentType);
             }
         }
 
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index 38f725cd..f777d1fe 100644
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -92,8 +92,6 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             if (currentReq == null) {
                 return false;
             }
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
         }
 
         if (retry) {
