diff --git a/.classpath b/.classpath
index 14fcf527..d385d6a4 100644
--- a/.classpath
+++ b/.classpath
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="examples"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="lib" path="libs/jcifs-1.3.17.jar"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/.metadata/.lock b/.metadata/.lock
new file mode 100644
index 00000000..e69de29b
diff --git a/.metadata/.log b/.metadata/.log
new file mode 100644
index 00000000..9c92472d
--- /dev/null
+++ b/.metadata/.log
@@ -0,0 +1,10 @@
+!SESSION 2012-12-11 10:49:05.431 -----------------------------------------------
+eclipse.buildId=M20120208-0800
+java.version=1.6.0_33
+java.vendor=Apple Inc.
+BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
+Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -keyring /Users/evert/.eclipse_keyring -showlocation
+Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -data /Users/evert/Documents/dev/forks/android-async-http -product org.eclipse.epp.package.java.product -keyring /Users/evert/.eclipse_keyring -showlocation
+
+!ENTRY org.eclipse.core.net 1 0 2012-12-11 10:49:22.126
+!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
diff --git a/.metadata/.mylyn/.taskListIndex/segments.gen b/.metadata/.mylyn/.taskListIndex/segments.gen
new file mode 100644
index 00000000..63a7ec9a
Binary files /dev/null and b/.metadata/.mylyn/.taskListIndex/segments.gen differ
diff --git a/.metadata/.mylyn/.taskListIndex/segments_1 b/.metadata/.mylyn/.taskListIndex/segments_1
new file mode 100644
index 00000000..8b02aa03
Binary files /dev/null and b/.metadata/.mylyn/.taskListIndex/segments_1 differ
diff --git a/.metadata/.plugins/org.eclipse.core.resources/.root/.indexes/properties.index b/.metadata/.plugins/org.eclipse.core.resources/.root/.indexes/properties.index
new file mode 100644
index 00000000..3fa93355
Binary files /dev/null and b/.metadata/.plugins/org.eclipse.core.resources/.root/.indexes/properties.index differ
diff --git a/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.epp.usagedata.recording.prefs b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.epp.usagedata.recording.prefs
new file mode 100644
index 00000000..88f87620
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.epp.usagedata.recording.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.epp.usagedata.recording.last-upload=1355219370854
diff --git a/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.ui.prefs b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.ui.prefs
new file mode 100644
index 00000000..c2dc69fe
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.ui.prefs
@@ -0,0 +1,12 @@
+content_assist_proposals_background=255,255,255
+content_assist_proposals_foreground=0,0,0
+eclipse.preferences.version=1
+fontPropagated=true
+org.eclipse.jdt.ui.editor.tab.width=
+org.eclipse.jdt.ui.formatterprofiles.version=12
+org.eclipse.jdt.ui.javadoclocations.migrated=true
+org.eclipse.jface.textfont=1|Monaco|11.0|0|COCOA|1|;
+spelling_locale_initialized=true
+tabWidthPropagated=true
+useAnnotationsPrefPage=true
+useQuickDiffPrefPage=true
diff --git a/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.context.core.prefs b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.context.core.prefs
new file mode 100644
index 00000000..43e97e40
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.context.core.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+mylyn.attention.migrated=true
diff --git a/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.monitor.ui.prefs b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.monitor.ui.prefs
new file mode 100644
index 00000000..8d462a6c
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.mylyn.monitor.ui.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.mylyn.monitor.activity.tracking.enabled.checked=true
diff --git a/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.ui.prefs b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.ui.prefs
new file mode 100644
index 00000000..08076f23
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.ui.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+showIntro=false
diff --git a/.metadata/.plugins/org.eclipse.epp.usagedata.recording/usagedata.csv b/.metadata/.plugins/org.eclipse.epp.usagedata.recording/usagedata.csv
new file mode 100644
index 00000000..042803ee
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.epp.usagedata.recording/usagedata.csv
@@ -0,0 +1,101 @@
+what,kind,bundleId,bundleVersion,description,time
+activated,perspective,org.eclipse.jdt.ui,,"org.eclipse.jdt.ui.JavaPerspective",1355219369581
+started,bundle,org.eclipse.osgi,3.7.2.v20120110-1415,"org.eclipse.osgi",1355219369582
+started,bundle,org.eclipse.core.contenttype,3.4.100.v20110423-0524,"org.eclipse.core.contenttype",1355219369583
+started,bundle,org.eclipse.core.databinding.observable,1.4.0.I20110222-0800,"org.eclipse.core.databinding.observable",1355219369584
+started,bundle,org.eclipse.core.expressions,3.4.300.v20110228,"org.eclipse.core.expressions",1355219369586
+started,bundle,org.eclipse.core.net,1.2.100.I20110511-0800,"org.eclipse.core.net",1355219369587
+started,bundle,org.eclipse.core.runtime,3.7.0.v20110110,"org.eclipse.core.runtime",1355219369588
+started,bundle,org.eclipse.core.runtime.compatibility,3.2.100.v20100505,"org.eclipse.core.runtime.compatibility",1355219369588
+started,bundle,org.eclipse.core.runtime.compatibility.auth,3.2.200.v20110110,"org.eclipse.core.runtime.compatibility.auth",1355219369601
+started,bundle,org.eclipse.epp.mpc.ui,1.1.1.I20110907-0947,"org.eclipse.epp.mpc.ui",1355219369601
+started,bundle,org.eclipse.epp.usagedata.gathering,1.3.1.R201106061540,"org.eclipse.epp.usagedata.gathering",1355219369602
+started,bundle,org.eclipse.epp.usagedata.recording,1.3.1.R201106061540,"org.eclipse.epp.usagedata.recording",1355219369603
+started,bundle,org.eclipse.equinox.app,1.3.100.v20110321,"org.eclipse.equinox.app",1355219369606
+started,bundle,org.eclipse.equinox.common,3.6.0.v20110523,"org.eclipse.equinox.common",1355219369607
+started,bundle,org.eclipse.equinox.ds,1.3.1.R37x_v20110701,"org.eclipse.equinox.ds",1355219369608
+started,bundle,org.eclipse.equinox.event,1.2.100.v20110502,"org.eclipse.equinox.event",1355219369614
+started,bundle,org.eclipse.equinox.registry,3.5.101.R37x_v20110810-1611,"org.eclipse.equinox.registry",1355219369615
+started,bundle,org.eclipse.equinox.security,1.1.1.R37x_v20110822-1018,"org.eclipse.equinox.security",1355219369618
+started,bundle,org.eclipse.equinox.util,1.0.300.v20110502,"org.eclipse.equinox.util",1355219369620
+started,bundle,org.eclipse.help,3.5.100.v20110426,"org.eclipse.help",1355219369621
+started,bundle,org.eclipse.jsch.core,1.1.300.I20110514-0800,"org.eclipse.jsch.core",1355219369622
+started,bundle,org.eclipse.team.core,3.6.0.I20110525-0800,"org.eclipse.team.core",1355219369623
+started,bundle,org.eclipse.team.cvs.core,3.3.400.I20110510-0800,"org.eclipse.team.cvs.core",1355219369623
+started,bundle,org.eclipse.ui.intro,3.4.100.v20110425,"org.eclipse.ui.intro",1355219369624
+started,bundle,org.eclipse.ui.intro.universal,3.2.500.v20110510,"org.eclipse.ui.intro.universal",1355219369624
+started,bundle,org.eclipse.update.configurator,3.3.100.v20100512,"org.eclipse.update.configurator",1355219369626
+started,bundle,org.eclipse.update.core,3.2.500.v20110330,"org.eclipse.update.core",1355219369663
+started,bundle,org.eclipse.update.scheduler,3.2.300.v20100512,"org.eclipse.update.scheduler",1355219369682
+started,bundle,org.eclipse.equinox.simpleconfigurator,1.0.200.v20110815-1438,"org.eclipse.equinox.simpleconfigurator",1355219369683
+started,bundle,com.ibm.icu,4.4.2.v20110823,"com.ibm.icu",1355219369687
+started,bundle,org.eclipse.core.filebuffers,3.5.200.v20110928-1504,"org.eclipse.core.filebuffers",1355219369687
+started,bundle,org.eclipse.core.jobs,3.5.101.v20120113-1953,"org.eclipse.core.jobs",1355219369688
+started,bundle,org.eclipse.core.resources,3.7.101.v20120125-1505,"org.eclipse.core.resources",1355219369689
+started,bundle,org.eclipse.equinox.p2.core,2.1.1.v20120113-1346,"org.eclipse.equinox.p2.core",1355219369691
+started,bundle,org.eclipse.equinox.p2.directorywatcher,1.0.300.v20110815-1419,"org.eclipse.equinox.p2.directorywatcher",1355219369692
+started,bundle,org.eclipse.equinox.p2.engine,2.1.1.R37x_v20111003,"org.eclipse.equinox.p2.engine",1355219369716
+started,bundle,org.eclipse.equinox.p2.metadata,2.1.0.v20110815-1419,"org.eclipse.equinox.p2.metadata",1355219369726
+started,bundle,org.eclipse.equinox.p2.metadata.repository,1.2.0.v20110815-1419,"org.eclipse.equinox.p2.metadata.repository",1355219369729
+started,bundle,org.eclipse.equinox.p2.operations,2.1.1.R37x_v20111111,"org.eclipse.equinox.p2.operations",1355219369734
+started,bundle,org.eclipse.equinox.p2.reconciler.dropins,1.1.100.v20110815-1419,"org.eclipse.equinox.p2.reconciler.dropins",1355219369736
+started,bundle,org.eclipse.equinox.p2.repository,2.1.1.v20120113-1346,"org.eclipse.equinox.p2.repository",1355219369739
+started,bundle,org.eclipse.equinox.p2.ui.sdk.scheduler,1.0.100.v20110815-1419,"org.eclipse.equinox.p2.ui.sdk.scheduler",1355219369740
+started,bundle,org.eclipse.equinox.p2.updatechecker,1.1.200.v20110815-1419,"org.eclipse.equinox.p2.updatechecker",1355219369741
+started,bundle,org.eclipse.equinox.preferences,3.4.2.v20120111-2020,"org.eclipse.equinox.preferences",1355219369741
+started,bundle,org.eclipse.jdt.core,3.7.3.v20120119-1537,"org.eclipse.jdt.core",1355219369742
+started,bundle,org.eclipse.jdt.core.manipulation,1.4.0.v20110928-1453,"org.eclipse.jdt.core.manipulation",1355219369743
+started,bundle,org.eclipse.jdt.ui,3.7.2.v20120109-1427,"org.eclipse.jdt.ui",1355219369745
+started,bundle,org.eclipse.jface,3.7.0.v20110928-1505,"org.eclipse.jface",1355219369746
+started,bundle,org.eclipse.m2e.discovery,1.0.200.20111228-1245,"org.eclipse.m2e.discovery",1355219369746
+started,bundle,org.eclipse.m2e.logback.configuration,1.0.200.20111228-1245,"org.eclipse.m2e.logback.configuration",1355219369746
+started,bundle,org.eclipse.mylyn.bugzilla.core,3.7.1.v20120425-0100,"org.eclipse.mylyn.bugzilla.core",1355219369747
+started,bundle,org.eclipse.mylyn.bugzilla.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.bugzilla.ui",1355219369748
+started,bundle,org.eclipse.mylyn.commons.core,3.7.1.v20120425-0100,"org.eclipse.mylyn.commons.core",1355219369748
+started,bundle,org.eclipse.mylyn.commons.net,3.7.1.v20120425-0100,"org.eclipse.mylyn.commons.net",1355219369748
+started,bundle,org.eclipse.mylyn.commons.notifications.core,0.9.1.v20120425-0100,"org.eclipse.mylyn.commons.notifications.core",1355219369749
+started,bundle,org.eclipse.mylyn.commons.notifications.feed,0.9.1.v20120425-0100,"org.eclipse.mylyn.commons.notifications.feed",1355219369750
+started,bundle,org.eclipse.mylyn.commons.notifications.ui,0.9.1.v20120425-0100,"org.eclipse.mylyn.commons.notifications.ui",1355219369750
+started,bundle,org.eclipse.mylyn.commons.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.commons.ui",1355219369751
+started,bundle,org.eclipse.mylyn.commons.workbench,3.7.1.v20120425-0100,"org.eclipse.mylyn.commons.workbench",1355219369752
+started,bundle,org.eclipse.mylyn.context.core,3.7.1.v20120425-0100,"org.eclipse.mylyn.context.core",1355219369753
+started,bundle,org.eclipse.mylyn.context.tasks.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.context.tasks.ui",1355219369761
+started,bundle,org.eclipse.mylyn.monitor.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.monitor.ui",1355219369782
+started,bundle,org.eclipse.mylyn.tasks.index.core,3.7.1.v20120425-0100,"org.eclipse.mylyn.tasks.index.core",1355219369782
+started,bundle,org.eclipse.mylyn.tasks.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.tasks.ui",1355219369783
+started,bundle,org.eclipse.mylyn.team.ui,3.7.1.v20120425-0100,"org.eclipse.mylyn.team.ui",1355219369785
+started,bundle,org.eclipse.search,3.7.0.v20110928-1504,"org.eclipse.search",1355219369787
+started,bundle,org.eclipse.team.cvs.ui,3.3.401.v20120126-1227,"org.eclipse.team.cvs.ui",1355219369827
+started,bundle,org.eclipse.team.ui,3.6.101.R37x_v20111109-0800,"org.eclipse.team.ui",1355219369827
+started,bundle,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui",1355219369828
+started,bundle,org.eclipse.ui.console,3.5.100.v20111007_r372,"org.eclipse.ui.console",1355219369829
+started,bundle,org.eclipse.ui.editors,3.7.0.v20110928-1504,"org.eclipse.ui.editors",1355219369833
+started,bundle,org.eclipse.ui.forms,3.5.101.v20111011-1919,"org.eclipse.ui.forms",1355219369834
+started,bundle,org.eclipse.ui.ide,3.7.0.v20110928-1505,"org.eclipse.ui.ide",1355219369838
+started,bundle,org.eclipse.ui.net,1.2.100.v20111208-1155,"org.eclipse.ui.net",1355219369840
+started,bundle,org.eclipse.ui.views,3.6.0.v20110928-1505,"org.eclipse.ui.views",1355219369841
+started,bundle,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"org.eclipse.ui.workbench",1355219369842
+started,bundle,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.workbench.texteditor",1355219369843
+started,bundle,org.eclipse.wb.discovery.core,1.3.0.r37x201202052340,"org.eclipse.wb.discovery.core",1355219369844
+os,sysinfo,,,"macosx",1355219369848
+arch,sysinfo,,,"x86_64",1355219369848
+ws,sysinfo,,,"cocoa",1355219369848
+locale,sysinfo,,,"en_US",1355219369848
+processors,sysinfo,,,"2",1355219369848
+java.runtime.name,sysinfo,,,"Java(TM) SE Runtime Environment",1355219369848
+java.runtime.version,sysinfo,,,"1.6.0_33-b03-424-11M3720",1355219369848
+java.specification.name,sysinfo,,,"Java Platform API Specification",1355219369848
+java.specification.vendor,sysinfo,,,"Sun Microsystems Inc.",1355219369848
+java.specification.version,sysinfo,,,"1.6",1355219369848
+java.vendor,sysinfo,,,"Apple Inc.",1355219369848
+java.version,sysinfo,,,"1.6.0_33",1355219369848
+java.vm.info,sysinfo,,,"mixed mode",1355219369848
+java.vm.name,sysinfo,,,"Java HotSpot(TM) 64-Bit Server VM",1355219369848
+java.vm.specification.name,sysinfo,,,"Java Virtual Machine Specification",1355219369848
+java.vm.specification.vendor,sysinfo,,,"Sun Microsystems Inc.",1355219369848
+java.vm.specification.version,sysinfo,,,"1.0",1355219369848
+java.vm.vendor,sysinfo,,,"Apple Inc.",1355219369848
+java.vm.version,sysinfo,,,"20.8-b03-424",1355219369848
+started,bundle,org.eclipse.m2e.usagedata,1.0.200.20111228-1245,"org.eclipse.m2e.usagedata",1355219369853
+activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1355219370148
+activated,view,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.internal.introview",1355219370157
diff --git a/.metadata/.plugins/org.eclipse.m2e.logback.configuration/0.log b/.metadata/.plugins/org.eclipse.m2e.logback.configuration/0.log
new file mode 100644
index 00000000..e69de29b
diff --git a/.metadata/.plugins/org.eclipse.m2e.logback.configuration/logback.1.0.200.20111228-1245.xml b/.metadata/.plugins/org.eclipse.m2e.logback.configuration/logback.1.0.200.20111228-1245.xml
new file mode 100644
index 00000000..e0de5155
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.m2e.logback.configuration/logback.1.0.200.20111228-1245.xml
@@ -0,0 +1,41 @@
+<configuration scan="true">
+  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
+      <pattern>%date [%thread] %-5level %logger{35} - %msg%n</pattern>
+    </encoder>
+    <filter class="org.eclipse.m2e.logback.appender.ConsoleAppenderFilter"/>
+  </appender>
+
+  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
+    <File>${org.eclipse.m2e.log.dir}/0.log</File>
+    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
+      <FileNamePattern>${org.eclipse.m2e.log.dir}/%i.log</FileNamePattern>
+      <MinIndex>1</MinIndex>
+      <MaxIndex>10</MaxIndex>
+    </rollingPolicy>
+    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
+      <MaxFileSize>100MB</MaxFileSize>
+    </triggeringPolicy>
+    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
+      <pattern>%date [%thread] %-5level %logger{35} - %msg%n</pattern>
+    </encoder>
+  </appender>
+
+  <appender name="EclipseLog" class="org.eclipse.m2e.logback.appender.EclipseLogAppender">
+    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
+      <level>WARN</level>
+    </filter>
+  </appender>
+
+  <appender name="MavenConsoleLog" class="org.eclipse.m2e.logback.appender.MavenConsoleAppender">
+  </appender>
+        
+  <root level="INFO">
+    <appender-ref ref="FILE" />
+    <appender-ref ref="STDOUT" />
+    <appender-ref ref="EclipseLog" />
+    <appender-ref ref="MavenConsoleLog" />
+  </root>
+
+  <logger name="com.ning.http.client" level="INFO" />
+</configuration>
diff --git a/.metadata/.plugins/org.eclipse.team.cvs.core/.running b/.metadata/.plugins/org.eclipse.team.cvs.core/.running
new file mode 100644
index 00000000..e69de29b
diff --git a/.metadata/.plugins/org.eclipse.ui.workbench/workingsets.xml b/.metadata/.plugins/org.eclipse.ui.workbench/workingsets.xml
new file mode 100644
index 00000000..0a564043
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.ui.workbench/workingsets.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<workingSetManager>
+<workingSet aggregate="true" factoryID="org.eclipse.ui.internal.WorkingSetFactory" id="1355219365622_0" label="Window Working Set" name="Aggregate for window 1355219365620"/>
+</workingSetManager>
\ No newline at end of file
diff --git a/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_gwt.png b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_gwt.png
new file mode 100644
index 00000000..8f33b6b4
Binary files /dev/null and b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_gwt.png differ
diff --git a/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swing.png b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swing.png
new file mode 100644
index 00000000..3272ee2f
Binary files /dev/null and b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swing.png differ
diff --git a/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swt.png b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swt.png
new file mode 100644
index 00000000..897496a5
Binary files /dev/null and b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_swt.png differ
diff --git a/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_xwt.png b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_xwt.png
new file mode 100644
index 00000000..dc1a68ce
Binary files /dev/null and b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkit_xwt.png differ
diff --git a/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkits.xml b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkits.xml
new file mode 100644
index 00000000..1727003c
--- /dev/null
+++ b/.metadata/.plugins/org.eclipse.wb.discovery.core/toolkits.xml
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<toolkits>
+	
+	<!-- SWT -->
+	<toolkit
+        name="SWT"
+		id="org.eclipse.swt"
+		icon="toolkit_swt.png"
+		providerName="Eclipse.org"
+		licenseDescription="EPL"
+		moreInfoURL="http://www.eclipse.org/swt/">
+		
+		<description>This WindowBuilder toolkit allows you to build user interfaces with the Standard Widget Toolkit (SWT) from Eclipse.</description>
+		
+		<updateSite 
+			version="[3.6,3.7)"
+			url="http://download.eclipse.org/windowbuilder/WB/integration/3.6"
+			auxurl="http://download.eclipse.org/releases/helios">
+            <feature id="org.eclipse.wb.rcp.feature"/>
+		</updateSite>
+		
+        <updateSite 
+            version="[3.7,5.0)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.7"
+            auxurl="http://download.eclipse.org/releases/indigo">
+            <feature id="org.eclipse.wb.rcp.feature"/>
+        </updateSite>
+	</toolkit>
+	
+	<!-- Swing -->
+	<toolkit
+        name="Swing"
+		id="org.eclipse.swing"
+		icon="toolkit_swing.png"
+		providerName="Eclipse.org"
+		licenseDescription="EPL">
+		
+		<description>This WindowBuilder toolkit allows you to build user interfaces with Java's Swing GUI framework.</description>
+
+        <updateSite 
+            version="[3.6,3.7)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.6">
+            <feature id="org.eclipse.wb.swing.feature"/>
+        </updateSite>
+        
+        <updateSite 
+            version="[3.7,5.0)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.7">
+            <feature id="org.eclipse.wb.swing.feature"/>
+        </updateSite>
+	</toolkit>
+	
+    <!-- eRCP -->
+    <toolkit
+        name="eRCP"
+        id="org.eclipse.ercp"
+        icon="toolkit_ercp.png"
+        providerName="Eclipse.org"
+        licenseDescription="EPL"
+        os="win32"
+        moreInfoURL="http://www.eclipse.org/ercp/">
+        
+        <description>This WindowBuilder toolkit allows you to build user interfaces with Eclipse's embedded Rich Client Platform (eRCP) framework. eRCP targets embedded devices.</description>
+
+        <updateSite 
+            version="[3.6,3.7)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.6"
+            auxurl="http://download.eclipse.org/releases/helios">
+            <feature id="org.eclipse.wb.ercp.feature"/>
+        </updateSite>
+        
+        <updateSite 
+            version="[3.7,5.0)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.7"
+            auxurl="http://download.eclipse.org/releases/indigo">
+            <feature id="org.eclipse.wb.ercp.feature"/>
+        </updateSite>
+    </toolkit>
+    
+    <!-- XWT -->
+    <toolkit
+        name="XWT"
+        id="org.eclipse.xwt"
+        icon="toolkit_xwt.png"
+        providerName="Eclipse.org"
+        licenseDescription="EPL"
+        moreInfoURL="http://wiki.eclipse.org/E4/XWT">
+        
+        <description>This WindowBuilder toolkit allows you to build user interfaces with the XML Windowing Toolkit (XWT) UI framework.</description>
+
+        <updateSite 
+            version="[3.6,3.7)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.6"
+            auxurl="http://download.eclipse.org/releases/helios">
+            <feature id="org.eclipse.wb.xwt.feature"/>
+        </updateSite>
+        
+        <updateSite 
+            version="[3.7,5.0)"
+            url="http://download.eclipse.org/windowbuilder/WB/integration/3.7"
+            auxurl="http://download.eclipse.org/releases/indigo">
+            <feature id="org.eclipse.wb.xwt.feature"/>
+        </updateSite>
+    </toolkit>
+    
+	<!-- GWT -->
+	<toolkit
+        name="GWT"
+        title="GWT / Google Plugin for Eclipse"
+		id="com.google.gwt"
+		icon="toolkit_gwt.png"
+		providerName="Google, Inc."
+		moreInfoURL="http://code.google.com/eclipse/index.html">
+		
+		<description>The Google Plugin for Eclipse provides support for building projects with the Google Web Toolkit and Google APIs, as well as integration with Google Project Hosting and App Engine.</description>
+    
+		<updateSite version="[3.6,3.7)" url="http://dl.google.com/eclipse/plugin/3.6"
+		    auxurl="http://download.eclipse.org/releases/helios">
+            <feature id="com.google.gdt.eclipse.suite.e36.feature"/>
+            <feature id="com.google.gwt.eclipse.sdkbundle.e36.feature" optional="true"/>
+            <feature id="com.google.appengine.eclipse.sdkbundle.e36.feature" optional="true"/>
+            <feature id="org.eclipse.wb.core.feature" optional="true"/>
+            <feature id="org.eclipse.wb.core.xml.feature" optional="true"/>
+            <feature id="org.eclipse.wb.css.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.hosted.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.editor.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.gpe.feature" optional="true"/>
+		</updateSite>
+		
+		<updateSite version="[3.7,3.8)" url="http://dl.google.com/eclipse/plugin/3.7"
+		    auxurl="http://download.eclipse.org/releases/indigo">
+            <feature id="com.google.gdt.eclipse.suite.e37.feature"/>
+            <feature id="com.google.gwt.eclipse.sdkbundle.e37.feature" optional="true"/>
+            <feature id="com.google.appengine.eclipse.sdkbundle.e37.feature" optional="true"/>
+            <feature id="org.eclipse.wb.core.feature" optional="true"/>
+            <feature id="org.eclipse.wb.core.xml.feature" optional="true"/>
+            <feature id="org.eclipse.wb.css.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.hosted.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.editor.feature" optional="true"/>
+            <feature id="com.google.gdt.eclipse.designer.gpe.feature" optional="true"/>
+		</updateSite>
+	</toolkit>
+
+</toolkits>
diff --git a/.metadata/version.ini b/.metadata/version.ini
new file mode 100644
index 00000000..c51ff745
--- /dev/null
+++ b/.metadata/version.ini
@@ -0,0 +1 @@
+org.eclipse.core.runtime=1
\ No newline at end of file
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 00000000..b080d2dd
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/android-async-http b/android-async-http
new file mode 160000
index 00000000..f854f626
--- /dev/null
+++ b/android-async-http
@@ -0,0 +1 @@
+Subproject commit f854f62633726ab38d2795d0c1e805212a4f0d76
diff --git a/project.properties b/project.properties
index 1880987e..0e58ae1c 100644
--- a/project.properties
+++ b/project.properties
@@ -9,4 +9,4 @@
 
 android.library=true
 # Project target.
-target=android-3
+target=android-17
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 188fe730..548e6f30 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -40,6 +40,7 @@
 import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.NTCredentials;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
 import org.apache.http.client.HttpClient;
@@ -60,8 +61,9 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
+import org.apache.http.params.CoreProtocolPNames;
 import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
 import org.apache.http.protocol.HttpContext;
@@ -69,546 +71,740 @@
 
 import android.content.Context;
 
-
 /**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
- * DELETE HTTP requests in your Android applications. Requests can be made
- * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and
+ * DELETE HTTP requests in your Android applications. Requests can be made with
+ * additional parameters by passing a {@link RequestParams} instance, and
+ * responses can be handled by passing an anonymously overridden
  * {@link AsyncHttpResponseHandler} instance.
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
- *     }
+ * client.get(&quot;http://www.google.com&quot;, new AsyncHttpResponseHandler() {
+ * 	&#064;Override
+ * 	public void onSuccess(String response) {
+ * 		System.out.println(response);
+ * 	}
  * });
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.1";
-
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-
-
-    /**
-     * Creates a new AsyncHttpClient.
-     */
-    public AsyncHttpClient() {
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            public void process(HttpRequest request, HttpContext context) {
-                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-                }
-                for (String header : clientHeaderMap.keySet()) {
-                    request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                if (entity == null) {
-                    return;
-                }
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Get the underlying HttpContext instance. This is useful for getting 
-     * and setting fine-grained settings for requests by accessing the
-     * context's attributes such as the CookieStore.
-     */
-    public HttpContext getHttpContext() {
-        return this.httpContext;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
-     */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-    /**
-     * Sets the connection time oout. By default, 10 seconds
-     * @param timeout the connect/socket timeout in milliseconds
-     */
-    public void setTimeout(int timeout){
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-    
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     * @param header the name of the header
-     * @param value the contents of the header
-     */
-    public void addHeader(String header, String value) {
-        clientHeaderMap.put(header, value);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
-     * @param username
-     * @param password
-     */
-    public void setBasicAuth(String user, String pass){
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
-    }
-    
-   /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
-     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     * @param username
-     * @param password
-     * @param scope - an AuthScope object
-     *
-     */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
-     *
-     * @param context the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
-     */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.remove(context);
-    }
-
-
-    //
-    // HTTP GET Requests
-    //
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-
-    //
-    // HTTP POST Requests
-    //
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP PUT Requests
-    //
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-
-    // Private stuff
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
-
-        if(context != null) {
-            // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
-            }
-
-            requestList.add(new WeakReference<Future<?>>(request));
-
-            // TODO: Remove dead weakrefs from requestLists?
-        }
-    }
-
-    public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
-            String paramString = params.getParamString();
-            url += "?" + paramString;
-        }
-
-        return url;
-    }
-
-    private HttpEntity paramsToEntity(RequestParams params) {
-        HttpEntity entity = null;
-
-        if(params != null) {
-            entity = params.getEntity();
-        }
-
-        return entity;
-    }
-
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    private static class InflatingEntity extends HttpEntityWrapper {
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
-        public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
-        }
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
+	private static final String VERSION = "1.4.1";
+
+	private static final int DEFAULT_MAX_CONNECTIONS = 10;
+	private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+	private static final int DEFAULT_MAX_RETRIES = 5;
+	private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+	private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+	private static final String ENCODING_GZIP = "gzip";
+
+	private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
+	private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+	private final DefaultHttpClient httpClient;
+	private final HttpContext httpContext;
+	private ThreadPoolExecutor threadPool;
+	private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+	private final Map<String, String> clientHeaderMap;
+
+	/**
+	 * Creates a new AsyncHttpClient.
+	 */
+	public AsyncHttpClient() {
+		BasicHttpParams httpParams = new BasicHttpParams();
+
+		ConnManagerParams.setTimeout(httpParams, socketTimeout);
+		ConnManagerParams.setMaxConnectionsPerRoute(httpParams,
+				new ConnPerRouteBean(maxConnections));
+		ConnManagerParams.setMaxTotalConnections(httpParams,
+				DEFAULT_MAX_CONNECTIONS);
+
+		HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setTcpNoDelay(httpParams, true);
+		HttpConnectionParams.setSocketBufferSize(httpParams,
+				DEFAULT_SOCKET_BUFFER_SIZE);
+
+		HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+		HttpProtocolParams.setUserAgent(httpParams, String.format(
+				"android-async-http/%s (http://loopj.com/android-async-http)",
+				VERSION));
+
+		SchemeRegistry schemeRegistry = new SchemeRegistry();
+		schemeRegistry.register(new Scheme("http", PlainSocketFactory
+				.getSocketFactory(), 80));
+		schemeRegistry.register(new Scheme("https", SSLSocketFactory
+				.getSocketFactory(), 443));
+		ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(
+				httpParams, schemeRegistry);
+
+		httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+		httpClient = new DefaultHttpClient(cm, httpParams);
+		httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+			public void process(HttpRequest request, HttpContext context) {
+				if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+					request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+				}
+				for (String header : clientHeaderMap.keySet()) {
+					request.addHeader(header, clientHeaderMap.get(header));
+				}
+			}
+		});
+
+		httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+			public void process(HttpResponse response, HttpContext context) {
+				final HttpEntity entity = response.getEntity();
+				if (entity == null) {
+					return;
+				}
+				final Header encoding = entity.getContentEncoding();
+				if (encoding != null) {
+					for (HeaderElement element : encoding.getElements()) {
+						if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+							response.setEntity(new InflatingEntity(response
+									.getEntity()));
+							break;
+						}
+					}
+				}
+			}
+		});
+
+		httpClient.setHttpRequestRetryHandler(new RetryHandler(
+				DEFAULT_MAX_RETRIES));
+
+		threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+
+		requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+		clientHeaderMap = new HashMap<String, String>();
+	}
+
+	/**
+	 * Get the underlying HttpClient instance. This is useful for setting
+	 * additional fine-grained settings for requests by accessing the client's
+	 * ConnectionManager, HttpParams and SchemeRegistry.
+	 */
+	public HttpClient getHttpClient() {
+		return this.httpClient;
+	}
+
+	/**
+	 * Get the underlying HttpContext instance. This is useful for getting and
+	 * setting fine-grained settings for requests by accessing the context's
+	 * attributes such as the CookieStore.
+	 */
+	public HttpContext getHttpContext() {
+		return this.httpContext;
+	}
+
+	/**
+	 * Sets an optional CookieStore to use when making requests
+	 * 
+	 * @param cookieStore
+	 *            The CookieStore implementation to use, usually an instance of
+	 *            {@link PersistentCookieStore}
+	 */
+	public void setCookieStore(CookieStore cookieStore) {
+		httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+	}
+
+	/**
+	 * Overrides the threadpool implementation used when queuing/pooling
+	 * requests. By default, Executors.newCachedThreadPool() is used.
+	 * 
+	 * @param threadPool
+	 *            an instance of {@link ThreadPoolExecutor} to use for
+	 *            queuing/pooling requests.
+	 */
+	public void setThreadPool(ThreadPoolExecutor threadPool) {
+		this.threadPool = threadPool;
+	}
+
+	/**
+	 * Sets the User-Agent header to be sent with each request. By default,
+	 * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)"
+	 * is used.
+	 * 
+	 * @param userAgent
+	 *            the string to use in the User-Agent header.
+	 */
+	public void setUserAgent(String userAgent) {
+		HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+	}
+
+	/**
+	 * Sets the connection time oout. By default, 10 seconds
+	 * 
+	 * @param timeout
+	 *            the connect/socket timeout in milliseconds
+	 */
+	public void setTimeout(int timeout) {
+		final HttpParams httpParams = this.httpClient.getParams();
+		ConnManagerParams.setTimeout(httpParams, timeout);
+		HttpConnectionParams.setSoTimeout(httpParams, timeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+	}
+
+	/**
+	 * Sets the SSLSocketFactory to user when making requests. By default, a
+	 * new, default SSLSocketFactory is used.
+	 * 
+	 * @param sslSocketFactory
+	 *            the socket factory to use for https requests.
+	 */
+	public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+		this.httpClient.getConnectionManager().getSchemeRegistry()
+				.register(new Scheme("https", sslSocketFactory, 443));
+	}
+
+	/**
+	 * Sets headers that will be added to all requests this client makes (before
+	 * sending).
+	 * 
+	 * @param header
+	 *            the name of the header
+	 * @param value
+	 *            the contents of the header
+	 */
+	public void addHeader(String header, String value) {
+		clientHeaderMap.put(header, value);
+	}
+
+	/**
+	 * Sets basic authentication for the request. Uses AuthScope.ANY. This is
+	 * the same as setBasicAuth('username','password',AuthScope.ANY)
+	 * 
+	 * @param username
+	 * @param password
+	 */
+	public void setBasicAuth(String user, String pass) {
+		AuthScope scope = AuthScope.ANY;
+		setBasicAuth(user, pass, scope);
+	}
+
+	/**
+	 * Sets basic authentication for the request. You should pass in your
+	 * AuthScope for security. It should be like this
+	 * setBasicAuth("username","password", new
+	 * AuthScope("host",port,AuthScope.ANY_REALM))
+	 * 
+	 * @param username
+	 * @param password
+	 * @param scope
+	 *            - an AuthScope object
+	 * 
+	 */
+	public void setBasicAuth(String user, String pass, AuthScope scope) {
+		UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(
+				user, pass);
+		this.httpClient.getCredentialsProvider().setCredentials(scope,
+				credentials);
+	}
+
+	public void setNTCredentials(String userName, String password,
+			String workstation, String domain) {
+		AuthScope scope = AuthScope.ANY;
+		setNTCredentials(userName, password, workstation, domain, scope);
+	}
+
+	public void setNTCredentials(String userName, String password,
+			String workstation, String domain, AuthScope scope) {
+		
+        this.httpClient.getAuthSchemes().register("ntlm", new NTLMSchemeFactory());
+        this.httpClient.getCredentialsProvider().setCredentials(
+        	    AuthScope.ANY, 
+        	    new NTCredentials(userName, password, "", ""));
+		
+		// NTCredentials credentials = new NTCredentials(userName, password,
+		// workstation, domain);
+		// this.httpClient.getCredentialsProvider().setCredentials(scope,
+		// credentials);
+	}
+
+	/**
+	 * Cancels any pending (or potentially active) requests associated with the
+	 * passed Context.
+	 * <p>
+	 * <b>Note:</b> This will only affect requests which were created with a
+	 * non-null android Context. This method is intended to be used in the
+	 * onDestroy method of your android activities to destroy all requests which
+	 * are no longer required.
+	 * 
+	 * @param context
+	 *            the android Context instance associated to the request.
+	 * @param mayInterruptIfRunning
+	 *            specifies if active requests should be cancelled along with
+	 *            pending requests.
+	 */
+	public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
+		List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+		if (requestList != null) {
+			for (WeakReference<Future<?>> requestRef : requestList) {
+				Future<?> request = requestRef.get();
+				if (request != null) {
+					request.cancel(mayInterruptIfRunning);
+				}
+			}
+		}
+		requestMap.remove(context);
+	}
+
+	//
+	// HTTP GET Requests
+	//
+
+	/**
+	 * Perform a HTTP GET request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, AsyncHttpResponseHandler responseHandler) {
+		get(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		get(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request without any parameters and track the Android
+	 * Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url,
+			AsyncHttpResponseHandler responseHandler) {
+		get(context, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated
+	 * the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext,
+				new HttpGet(getUrlWithQueryString(url, params)), null,
+				responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated
+	 * the request with customized headers
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, Header[] headers,
+			RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, null, responseHandler,
+				context);
+	}
+
+	//
+	// HTTP POST Requests
+	//
+
+	/**
+	 * Perform a HTTP POST request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, AsyncHttpResponseHandler responseHandler) {
+		post(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		post(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		post(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for
+	 *            example, use this to send string/json/xml payloads to a server
+	 *            by passing a {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example
+	 *            application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, HttpEntity entity,
+			String contentType, AsyncHttpResponseHandler responseHandler) {
+		HttpPost post = new HttpPost(url);
+		post.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false);
+		sendRequest(httpClient, httpContext,
+				addEntityToRequestBase(post, entity), contentType,
+				responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request. Set headers only for this request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param params
+	 *            additional POST parameters to send with the request.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example
+	 *            application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, Header[] headers,
+			RequestParams params, String contentType,
+			AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = new HttpPost(url);
+		if (params != null)
+			request.setEntity(paramsToEntity(params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType,
+				responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request. Set headers only for this request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for
+	 *            example, use this to send string/json/xml payloads to a server
+	 *            by passing a {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example
+	 *            application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, Header[] headers,
+			HttpEntity entity, String contentType,
+			AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = addEntityToRequestBase(
+				new HttpPost(url), entity);
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType,
+				responseHandler, context);
+	}
+
+	//
+	// HTTP PUT Requests
+	//
+
+	/**
+	 * Perform a HTTP PUT request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, AsyncHttpResponseHandler responseHandler) {
+		put(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		put(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated
+	 * the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, RequestParams params,
+			AsyncHttpResponseHandler responseHandler) {
+		put(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated
+	 * the request. And set one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for
+	 *            example, use this to send string/json/xml payloads to a server
+	 *            by passing a {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example
+	 *            application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, HttpEntity entity,
+			String contentType, AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext,
+				addEntityToRequestBase(new HttpPut(url), entity), contentType,
+				responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated
+	 * the request. And set one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for
+	 *            example, use this to send string/json/xml payloads to a server
+	 *            by passing a {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example
+	 *            application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, Header[] headers,
+			HttpEntity entity, String contentType,
+			AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = addEntityToRequestBase(
+				new HttpPut(url), entity);
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType,
+				responseHandler, context);
+	}
+
+	//
+	// HTTP DELETE Requests
+	//
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(String url, AsyncHttpResponseHandler responseHandler) {
+		delete(null, url, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url,
+			AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler,
+				context);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url, Header[] headers,
+			AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		if (headers != null)
+			delete.setHeaders(headers);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler,
+				context);
+	}
+
+	// Private stuff
+	protected void sendRequest(DefaultHttpClient client,
+			HttpContext httpContext, HttpUriRequest uriRequest,
+			String contentType, AsyncHttpResponseHandler responseHandler,
+			Context context) {
+		if (contentType != null) {
+			uriRequest.addHeader("Content-Type", contentType);
+		}
+
+		Future<?> request = threadPool.submit(new AsyncHttpRequest(client,
+				httpContext, uriRequest, responseHandler));
+
+		if (context != null) {
+			// Add request to request map
+			List<WeakReference<Future<?>>> requestList = requestMap
+					.get(context);
+			if (requestList == null) {
+				requestList = new LinkedList<WeakReference<Future<?>>>();
+				requestMap.put(context, requestList);
+			}
+
+			requestList.add(new WeakReference<Future<?>>(request));
+
+			// TODO: Remove dead weakrefs from requestLists?
+		}
+	}
+
+	public static String getUrlWithQueryString(String url, RequestParams params) {
+		if (params != null) {
+			String paramString = params.getParamString();
+			url += "?" + paramString;
+		}
+
+		return url;
+	}
+
+	private HttpEntity paramsToEntity(RequestParams params) {
+		HttpEntity entity = null;
+
+		if (params != null) {
+			entity = params.getEntity();
+		}
+
+		return entity;
+	}
+
+	private HttpEntityEnclosingRequestBase addEntityToRequestBase(
+			HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
+		if (entity != null) {
+			requestBase.setEntity(entity);
+		}
+
+		return requestBase;
+	}
+
+	private static class InflatingEntity extends HttpEntityWrapper {
+		public InflatingEntity(HttpEntity wrapped) {
+			super(wrapped);
+		}
+
+		@Override
+		public InputStream getContent() throws IOException {
+			return new GZIPInputStream(wrappedEntity.getContent());
+		}
+
+		@Override
+		public long getContentLength() {
+			return -1;
+		}
+	}
 }
diff --git a/src/com/loopj/android/http/JCIFSEngine.java b/src/com/loopj/android/http/JCIFSEngine.java
new file mode 100644
index 00000000..2131b9e5
--- /dev/null
+++ b/src/com/loopj/android/http/JCIFSEngine.java
@@ -0,0 +1,47 @@
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+import jcifs.ntlmssp.NtlmFlags;
+import jcifs.ntlmssp.Type1Message;
+import jcifs.ntlmssp.Type2Message;
+import jcifs.ntlmssp.Type3Message;
+import jcifs.util.Base64;
+
+import org.apache.http.impl.auth.NTLMEngine;
+import org.apache.http.impl.auth.NTLMEngineException;
+
+public final class JCIFSEngine implements NTLMEngine {
+
+    private static final int TYPE_1_FLAGS = 
+            NtlmFlags.NTLMSSP_NEGOTIATE_56 | 
+            NtlmFlags.NTLMSSP_NEGOTIATE_128 | 
+            NtlmFlags.NTLMSSP_NEGOTIATE_NTLM2 | 
+            NtlmFlags.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | 
+            NtlmFlags.NTLMSSP_REQUEST_TARGET;
+
+    public String generateType1Msg(final String domain, final String workstation)
+            throws NTLMEngineException {
+        final Type1Message type1Message = new Type1Message(TYPE_1_FLAGS, domain, workstation);
+        return Base64.encode(type1Message.toByteArray());
+    }
+
+    public String generateType3Msg(final String username, final String password,
+            final String domain, final String workstation, final String challenge)
+            throws NTLMEngineException {
+        Type2Message type2Message;
+        try {
+            type2Message = new Type2Message(Base64.decode(challenge));
+        } catch (final IOException exception) {
+            throw new NTLMEngineException("Invalid NTLM type 2 message", exception);
+        }
+        final int type2Flags = type2Message.getFlags();
+        final int type3Flags = type2Flags
+                & (0xffffffff ^ (NtlmFlags.NTLMSSP_TARGET_TYPE_DOMAIN | NtlmFlags.NTLMSSP_TARGET_TYPE_SERVER));
+        final Type3Message type3Message = new Type3Message(type2Message, password, domain,
+                username, workstation, type3Flags);
+
+        return Base64.encode(type3Message.toByteArray());
+    }
+
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/NTLMSchemeFactory.java b/src/com/loopj/android/http/NTLMSchemeFactory.java
new file mode 100644
index 00000000..a8683db8
--- /dev/null
+++ b/src/com/loopj/android/http/NTLMSchemeFactory.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http;
+
+import org.apache.http.auth.AuthScheme;
+import org.apache.http.auth.AuthSchemeFactory;
+import org.apache.http.impl.auth.NTLMScheme;
+import org.apache.http.params.HttpParams;
+
+public class NTLMSchemeFactory implements AuthSchemeFactory {
+
+    public AuthScheme newInstance(final HttpParams params) {
+        return new NTLMScheme(new JCIFSEngine());
+    }
+
+}
\ No newline at end of file
