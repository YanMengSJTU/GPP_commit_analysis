diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
index cad95e1a..c102b2fb 100644
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -1,16 +1,17 @@
 import com.loopj.http.AsyncHttpClient;
-import com.loopj.http.AsyncHttpResponseHandler;
-import com.loopj.http.android.*;
+import com.loopj.http.android.AndroidResponseHandler;
 
 public class ExampleUsage {
     public static void makeRequest() {
         AsyncHttpClient client = new AsyncHttpClient();
 
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+//      client.get("http://www.google.com", new AndroidResponseHandler() {
+        client.new Transaction().get("http://www.google.com", new AndroidResponseHandler() {
             @Override
             public void onSuccess(String response) {
                 System.out.println(response);
             }
         });
+
     }
 }
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
index ea15432e..b204cbc2 100644
--- a/examples/TwitterRestClient.java
+++ b/examples/TwitterRestClient.java
@@ -11,11 +11,14 @@
     private static AsyncHttpClient client = new AsyncHttpClient();
 
     public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
+//        client.get(getAbsoluteUrl(url), params, responseHandler);
+        client.new Transaction().get(url, responseHandler);
     }
 
     public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
+//        client.get(getAbsoluteUrl(url), params, responseHandler);
+        client.new Transaction().setParams(params).get(url, responseHandler);
+
     }
 
     private static String getAbsoluteUrl(String relativeUrl) {
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
index 5271fa8f..cc21c404 100644
--- a/examples/TwitterRestClientUsage.java
+++ b/examples/TwitterRestClientUsage.java
@@ -1,10 +1,12 @@
-import org.json.*;
-import com.loopj.http.JsonHttpResponseHandler;
-import com.loopj.http.android.*;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import com.loopj.http.android.AndroidJsonResponseHandler;
 
 class TwitterRestClientUsage {
     public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
+        TwitterRestClient.get("statuses/public_timeline.json", null, new AndroidJsonResponseHandler() {
             @Override
             public void onSuccess(JSONArray timeline) {
                 try {
diff --git a/src/com/loopj/http/AsyncHttpClient.java b/src/com/loopj/http/AsyncHttpClient.java
index aabca9d3..ac97099b 100644
--- a/src/com/loopj/http/AsyncHttpClient.java
+++ b/src/com/loopj/http/AsyncHttpClient.java
@@ -310,7 +310,7 @@ public void cancelRequests(Object cancelKey, boolean mayInterruptIfRunning) {
      * to support the various permutations of possible parameters to get() calls. This
      * class fixes that.
      */
-    class Transaction {
+    public class Transaction {
     	private RequestParams params = null;
     	public Transaction setParams(RequestParams params){this.params=params;return this;}
 
diff --git a/src/com/loopj/http/AsyncHttpRequest.java b/src/com/loopj/http/AsyncHttpRequest.java
index 3dc195a2..6f417e99 100644
--- a/src/com/loopj/http/AsyncHttpRequest.java
+++ b/src/com/loopj/http/AsyncHttpRequest.java
@@ -34,17 +34,23 @@
     private final HttpContext context;
     private final HttpUriRequest request;
     private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
+    private boolean isBinaryRequest = false;
     private int executionCount;
+    
+    public boolean isBinaryRequest() {
+		return isBinaryRequest;
+	}
 
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
+	public AsyncHttpRequest setBinaryRequest(boolean isBinaryRequest) {
+		this.isBinaryRequest = isBinaryRequest;
+		return this;
+	}
+
+	public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
         this.client = client;
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
     }
 
     public void run() {
diff --git a/src/com/loopj/http/AsyncHttpResponseHandler.java b/src/com/loopj/http/AsyncHttpResponseHandler.java
index 4c117f96..7f1e3464 100644
--- a/src/com/loopj/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/http/AsyncHttpResponseHandler.java
@@ -1,241 +1,11 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
 package com.loopj.http;
 
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-
-import java.io.IOException;
-
-/**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
- * designed to be anonymously overridden with your own response handling code.
- * <p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p>
- * For example:
- * <p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         // Successfully got a response
- *     }
- * 
- *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public class AsyncHttpResponseHandler {
-    protected static final int SUCCESS_MESSAGE = 0;
-    protected static final int FAILURE_MESSAGE = 1;
-    protected static final int START_MESSAGE = 2;
-    protected static final int FINISH_MESSAGE = 3;
-
-    private Handler handler;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {}
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
-     */
-    public void onFinish() {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(String content) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    public void onFailure(Throwable error) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
-     */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
-    }
-
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-    
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    protected void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    protected void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, String responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
-    }
-
-
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
-        }
-    }
-
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = new Message();
-            msg.what = responseMessage;
-            msg.obj = response;
-        }
-        return msg;
-    }
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
-            }
-        } catch(IOException e) {
-            sendFailureMessage(e, (String) null);
-        }
 
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
-}
\ No newline at end of file
+public interface AsyncHttpResponseHandler {
+	public void sendStartMessage();
+	public void sendFinishMessage();
+	public void sendFailureMessage(Throwable e, String responseBody);
+	public void sendFailureMessage(Throwable e, byte[] responseBody);
+	public void sendResponseMessage(HttpResponse response);
+}
diff --git a/src/com/loopj/http/android/AndroidBinaryResponseHandler.java b/src/com/loopj/http/android/AndroidBinaryResponseHandler.java
new file mode 100644
index 00000000..ec1869b5
--- /dev/null
+++ b/src/com/loopj/http/android/AndroidBinaryResponseHandler.java
@@ -0,0 +1,192 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.http.android;
+
+import android.os.Message;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.entity.BufferedHttpEntity;
+import org.apache.http.util.EntityUtils;
+
+
+import java.io.IOException;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. Receives response body as byte array with a 
+ * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * Content-length).
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * String[] allowedTypes = new String[] { "image/png" };
+ * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
+ *     &#064;Override
+ *     public void onSuccess(byte[] imageData) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(Throwable e, byte[] imageData) {
+ *         // Response failed :(
+ *     }
+ * });
+ * </pre>
+ */
+public class AndroidBinaryResponseHandler extends AndroidResponseHandler {
+    // Allow images by default
+    private static String[] mAllowedContentTypes = new String[] {
+        "image/jpeg",
+        "image/png"
+    };
+
+    /**
+     * Creates a new BinaryHttpResponseHandler
+     */
+    public AndroidBinaryResponseHandler() {
+        super();
+    }
+
+    /**
+     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
+     * content types with passed String array (hopefully) of content types.
+     */
+    public AndroidBinaryResponseHandler(String[] allowedContentTypes) {
+        this();
+        mAllowedContentTypes = allowedContentTypes;
+    }
+
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param binaryData the body of the HTTP response from the server
+     */
+    public void onSuccess(byte[] binaryData) {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param statusCode the status code of the response
+     * @param binaryData the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, byte[] binaryData) {
+        onSuccess(binaryData);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @param binaryData the response body, if any
+     */
+    public void onFailure(Throwable error, byte[] binaryData) {
+        // By default, call the deprecated onFailure(Throwable) for compatibility
+        onFailure(error);
+    }
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
+    }
+
+    public void sendFailureMessage(Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
+        onFailure(e, responseBody);
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+        switch(msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[])msg.obj;
+                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[])msg.obj;
+                handleFailureMessage((Throwable)response[0], (byte[])response[1]);
+                break;
+            default:
+                super.handleMessage(msg);
+                break;
+        }
+    }
+
+    // Interface to AsyncHttpRequest
+    public void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+        byte[] responseBody = null;
+        if(contentTypeHeaders.length != 1) {
+            //malformed/ambiguous HTTP Header, ABORT!
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+            return;
+        }
+        Header contentTypeHeader = contentTypeHeaders[0];
+        boolean foundAllowedContentType = false;
+        for(String anAllowedContentType : mAllowedContentTypes) {
+            if(anAllowedContentType.equals(contentTypeHeader.getValue())) {
+                foundAllowedContentType = true;
+            }
+        }
+        if(!foundAllowedContentType) {
+            //Content-Type not in allowed list, ABORT!
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+            return;
+        }
+        try {
+            HttpEntity entity = null;
+            HttpEntity temp = response.getEntity();
+            if(temp != null) {
+                entity = new BufferedHttpEntity(temp);
+            }
+            responseBody = EntityUtils.toByteArray(entity);
+        } catch(IOException e) {
+            sendFailureMessage(e, (byte[]) null);
+        }
+
+        if(status.getStatusCode() >= 300) {
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), responseBody);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/http/android/AndroidJsonResponseHandler.java b/src/com/loopj/http/android/AndroidJsonResponseHandler.java
new file mode 100644
index 00000000..605a96c0
--- /dev/null
+++ b/src/com/loopj/http/android/AndroidJsonResponseHandler.java
@@ -0,0 +1,165 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.http.android;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+
+import android.os.Message;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
+ * or {@link JSONArray}.
+ * <p>
+ * This class is designed to be passed to get, post, put and delete requests
+ * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
+ * methods anonymously overridden.
+ * <p>
+ * Additionally, you can override the other event methods from the
+ * parent class.
+ */
+public class AndroidJsonResponseHandler extends AndroidResponseHandler {
+    protected static final int SUCCESS_JSON_MESSAGE = 100;
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param response the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(JSONObject response) {}
+
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param response the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(JSONArray response) {}
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param statusCode the status code of the response
+     * @param response the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONObject response) {
+        onSuccess(response);
+    }
+
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * @param statusCode the status code of the response
+     * @param response the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONArray response) {
+        onSuccess(response);
+    }
+
+    public void onFailure(Throwable e, JSONObject errorResponse) {}
+    public void onFailure(Throwable e, JSONArray errorResponse) {}
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    @Override
+    protected void sendSuccessMessage(int statusCode, String responseBody) {
+        try {
+            Object jsonResponse = parseResponse(responseBody);
+            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, jsonResponse}));
+        } catch(JSONException e) {
+            sendFailureMessage(e, responseBody);
+        }
+    }
+
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    @Override
+    protected void handleMessage(Message msg) {
+        switch(msg.what){
+            case SUCCESS_JSON_MESSAGE:
+                Object[] response = (Object[]) msg.obj;
+                handleSuccessJsonMessage(((Integer) response[0]).intValue(), response[1]);
+                break;
+            default:
+                super.handleMessage(msg);
+        }
+    }
+
+    protected void handleSuccessJsonMessage(int statusCode, Object jsonResponse) {
+        if(jsonResponse instanceof JSONObject) {
+            onSuccess(statusCode, (JSONObject)jsonResponse);
+        } else if(jsonResponse instanceof JSONArray) {
+            onSuccess(statusCode, (JSONArray)jsonResponse);
+        } else {
+            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()));
+        }
+    }
+
+    protected Object parseResponse(String responseBody) throws JSONException {
+        Object result = null;
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+		responseBody = responseBody.trim();
+		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
+			result = new JSONTokener(responseBody).nextValue();
+		}
+		if (result == null) {
+			result = responseBody;
+		}
+		return result;
+    }
+
+    @Override
+    protected void handleFailureMessage(Throwable e, String responseBody) {
+        try {
+            if (responseBody != null) {
+                Object jsonResponse = parseResponse(responseBody);
+                if(jsonResponse instanceof JSONObject) {
+                    onFailure(e, (JSONObject)jsonResponse);
+                } else if(jsonResponse instanceof JSONArray) {
+                    onFailure(e, (JSONArray)jsonResponse);
+                } else {
+                    onFailure(e, responseBody);
+                }
+            }else {
+                onFailure(e, "");
+            }
+        }catch(JSONException ex) {
+            onFailure(e, responseBody);
+        }
+    }
+}
diff --git a/src/com/loopj/http/android/AndroidResponseHandler.java b/src/com/loopj/http/android/AndroidResponseHandler.java
new file mode 100644
index 00000000..47e9f1a8
--- /dev/null
+++ b/src/com/loopj/http/android/AndroidResponseHandler.java
@@ -0,0 +1,244 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.http.android;
+
+import java.io.IOException;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.entity.BufferedHttpEntity;
+import org.apache.http.util.EntityUtils;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import com.loopj.http.AsyncHttpClient;
+import com.loopj.http.AsyncHttpResponseHandler;
+
+/**
+ * Used to intercept and handle the responses from requests made using 
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * designed to be anonymously overridden with your own response handling code.
+ * <p>
+ * Additionally, you can override the {@link #onFailure(Throwable, String)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String response) {
+ *         // Successfully got a response
+ *     }
+ * 
+ *     &#064;Override
+ *     public void onFailure(Throwable e, String response) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public class AndroidResponseHandler implements AsyncHttpResponseHandler {
+    protected static final int SUCCESS_MESSAGE = 0;
+    protected static final int FAILURE_MESSAGE = 1;
+    protected static final int START_MESSAGE = 2;
+    protected static final int FINISH_MESSAGE = 3;
+
+    private Handler handler;
+
+    /**
+     * Creates a new AndroidResponseHandler
+     */
+    public AndroidResponseHandler() {
+        // Set up a handler to post events back to the correct thread if possible
+        if(Looper.myLooper() != null) {
+            handler = new Handler(){
+                public void handleMessage(Message msg){
+                    AndroidResponseHandler.this.handleMessage(msg);
+                }
+            };
+        }
+    }
+
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when the request is started, override to handle in your own code
+     */
+    public void onStart() {}
+
+    /**
+     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
+     */
+    public void onFinish() {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param content the body of the HTTP response from the server
+     */
+    public void onSuccess(String content) {}
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     * @param statusCode the status code of the response
+     * @param content the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, String content) {
+        onSuccess(content);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @deprecated use {@link #onFailure(Throwable, String)}
+     */
+    public void onFailure(Throwable error) {}
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     * @param error the underlying cause of the failure
+     * @param content the response body, if any
+     */
+    public void onFailure(Throwable error, String content) {
+        // By default, call the deprecated onFailure(Throwable) for compatibility
+        onFailure(error);
+    }
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    protected void sendSuccessMessage(int statusCode, String responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
+    }
+
+    public void sendFailureMessage(Throwable e, String responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+    
+    public void sendFailureMessage(Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    }
+
+    public void sendStartMessage() {
+        sendMessage(obtainMessage(START_MESSAGE, null));
+    }
+
+    public void sendFinishMessage() {
+        sendMessage(obtainMessage(FINISH_MESSAGE, null));
+    }
+
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    protected void handleSuccessMessage(int statusCode, String responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(Throwable e, String responseBody) {
+        onFailure(e, responseBody);
+    }
+
+
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+
+        switch(msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[])msg.obj;
+                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[])msg.obj;
+                handleFailureMessage((Throwable)response[0], (String)response[1]);
+                break;
+            case START_MESSAGE:
+                onStart();
+                break;
+            case FINISH_MESSAGE:
+                onFinish();
+                break;
+        }
+    }
+
+    protected void sendMessage(Message msg) {
+        if(handler != null){
+            handler.sendMessage(msg);
+        } else {
+            handleMessage(msg);
+        }
+    }
+
+    protected Message obtainMessage(int responseMessage, Object response) {
+        Message msg = null;
+        if(handler != null){
+            msg = this.handler.obtainMessage(responseMessage, response);
+        }else{
+            msg = new Message();
+            msg.what = responseMessage;
+            msg.obj = response;
+        }
+        return msg;
+    }
+
+    // Interface to AsyncHttpRequest
+    public void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+        String responseBody = null;
+        try {
+            HttpEntity entity = null;
+            HttpEntity temp = response.getEntity();
+            if(temp != null) {
+                entity = new BufferedHttpEntity(temp);
+                responseBody = EntityUtils.toString(entity, "UTF-8");
+            }
+        } catch(IOException e) {
+            sendFailureMessage(e, (String) null);
+        }
+
+        if(status.getStatusCode() >= 300) {
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), responseBody);
+        }
+    }
+}
\ No newline at end of file
