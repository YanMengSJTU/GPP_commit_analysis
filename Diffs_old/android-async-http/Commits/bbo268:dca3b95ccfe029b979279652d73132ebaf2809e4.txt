diff --git a/.gitignore b/.gitignore
deleted file mode 100755
index d3b22564..00000000
--- a/.gitignore
+++ /dev/null
@@ -1,40 +0,0 @@
-# Custom
-_site
-
-# Ant
-MANIFEST.MF
-./*.jar
-build.num
-build
-
-# ADT
-.classpath
-.project
-.settings
-local.properties
-bin
-gen
-_layouts
-proguard.cfg
-
-# OSX
-.DS_Store
-
-# Github
-gh-pages
-
-# Gradle
-.gradle
-build
-
-# IDEA
-*.iml
-*.ipr
-*.iws
-out
-.idea
-
-# Maven
-target
-release.properties
-pom.xml.*
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100755
index 201b1af9..00000000
--- a/.travis.yml
+++ /dev/null
@@ -1,35 +0,0 @@
-language:
-  - java
-jdk:
-  - openjdk7
-before_install:
-  # environment info
-  - mvn -version
-  - gradle -v
-  - uname -a
-  # required libs for android build tools
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  # for gradle output style
-  - export TERM=dumb
-  # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.12-bin.zip
-  - unzip -qq gradle-1.12-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.12
-  - export PATH=$GRADLE_HOME/bin:$PATH
-  # just to test gradle version, against our provided one
-  - gradle -v
-  # newest android SDK 22.6.2
-  - wget http://dl.google.com/android/android-sdk_r22.6.2-linux.tgz
-  - tar -zxf android-sdk_r22.6.2-linux.tgz
-  - export ANDROID_HOME=`pwd`/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  # manually set sdk.dir variable, according to local paths
-  - echo "sdk.dir=$ANDROID_HOME" > local.properties
-  # list packages for debug purpose
-  - android list sdk -a -e -u
-  - echo yes | android update sdk -t 1,2,3,tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.1.0 --force --no-ui
-  # Sonatype bypass
-  - echo "nexusUsername=dummy" >> library/gradle.properties
-  - echo "nexusPassword=dummy" >> library/gradle.properties
-
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
deleted file mode 100644
index 9ef10325..00000000
--- a/CONTRIBUTING.md
+++ /dev/null
@@ -1,44 +0,0 @@
-CONTRIBUTING
-============
-AsyncHttpClient is an open-source project made by developers for developers!
-
-If you would like to contribute to the project, it's really great. You can contribute in a variety of ways:
-
-  * Help us with test cases and examples for the Wiki (and kindly follow our [Coding Standards](#coding-standards))
-  * If you have a good idea/patch for the project, create a [pull request](#pull-requests)
-  * Found a bug? You're more than welcome to [submit an issue](#issues)
-  * Help other fellow developers solve their problems, you're welcome to do so in issues
-
-We do require certain guidelines to be followed so that the quality of the project remains top-notch:
-
-PULL requests
--------------
-When you submit a patch or a new functionality for the project, you must open a pull request. We will get to the pull request as soon as possible, investigate what functionality or bug fixes have been added and decide whether to include it in the library or not -- for the benefit of everyone.
-
-**You agree that all contributions that you make to the library will be distributed further under the same license as the library itself (Apache V2).**
-
-Don't be discouraged if your pull request is rejected. This is not a deadline and sometimes with a proper explanation on your side, we are persuaded to merge in the request. Just remember that this is a library for everyone and as such must meet certain, generic rules that we would like to believe are following.  
-
-ISSUES
----------
-The issues system is the place to report bugs and not for submitting patches or new functionality. As helpful as we would like to be, we cannot replace the developer and we certainly do not see what you're seeing. So when you come to report an issue, follow these simple rules:  
-
-  * Report bugs in the English language only
-  * Use Markdown to format your issue in a fashionable way (easier to read): [Familiarize yourself](https://help.github.com/articles/github-flavored-markdown)
-  * If the issue is due to a crash, include the stack trace -- `throwable.printStackTrace()` -- and any other detail that will shed light on the problem
-  * We need to see the source code (minus certain details that you think are confidential) that caused the problem in the first place, so include it too
-
-Opening issues without providing us with the information necessary to debug and fix it is useless; so we will close such issues within 7 days period  
-
-CODING STANDARDS
-----------------
-We need you to follow certain rules when sending source code contributions. These are the basic principles that we ourselves abide to and we require that you do so as well:
-
-  * Do not use the Tab character (it's in first place for a reason)
-  * Indentation is 4 spaces
-  * Include the copyright info (as in other files) at the top of the class file
-  * You must provide proper Javadoc, including description, in English for both public and protected methods, classes and properties
-  * Group packages that belong to the same top-level package together, followed by an empty line
-  * Add an empty line after and before class/interface declarations, methods and constructors
-  * Add an empty line before and after a group of properties
-  * Do not catch generic Exception/Throwable errors, but always catch the most specific type of the exception/error
diff --git a/README.md b/README.md
deleted file mode 100755
index 182a9605..00000000
--- a/README.md
+++ /dev/null
@@ -1,54 +0,0 @@
-Asynchronous Http Client for Android
-====================================
-[![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
-
-An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
-
-
-Features
---------
-- Make **asynchronous** HTTP requests, handle responses in **anonymous callbacks**
-- HTTP requests happen **outside the UI thread**
-- Requests use a **threadpool** to cap concurrent resource usage
-- GET/POST **params builder** (RequestParams)
-- **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **60kb** for everything
-- Automatic smart **request retries** optimized for spotty mobile connections
-- Automatic **gzip** response decoding support for super-fast requests
-- Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
-- Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
-
-Maven
------
-You can now integrate this library in your project via Maven. There are available two kind of builds.
-
-**development snapshots**
-https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
-```
-Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
-GroupId: com.loopj.android
-ArtifactId: android-async-http
-Version: 1.4.5-SNAPSHOT
-Packaging: JAR or AAR
-```
-
-**releases, maven central**
-
-http://central.maven.org/maven2/com/loopj/android/android-async-http/
-```
-Maven URL: http://repo1.maven.org/maven2/
-GroupId: com.loopj.android
-ArtifactId: android-async-http
-Version: 1.4.4
-Packaging: JAR or AAR
-```
-
-Documentation, Features and Examples
-------------------------------------
-Full details and documentation can be found on the project page here:
-
-http://loopj.com/android-async-http/
-
-
-[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/loopj/android-async-http/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
-
diff --git a/build.gradle b/build.gradle
deleted file mode 100755
index 21db9553..00000000
--- a/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-
-    dependencies {
-        classpath 'com.android.tools.build:gradle:+'
-    }
-}
-
-def isReleaseBuild() {
-    return version.contains("SNAPSHOT") == false
-}
-
-allprojects {
-    group = 'com.loopj.android'
-    version = '1.4.5-SNAPSHOT'
-
-    repositories {
-        mavenCentral()
-    }
-
-    tasks.withType(JavaCompile) {
-        options.encoding = "UTF-8"
-        options.compilerArgs << "-Xlint:unchecked"
-    }
-}
-
-apply plugin: 'android-reporting'
diff --git a/gradle.properties b/gradle.properties
deleted file mode 100755
index 01f4bd2c..00000000
--- a/gradle.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-VERSION_NAME=1.4.5-SNAPSHOT
-VERSION_CODE=145
-GROUP=com.loopj.android
-
-POM_DESCRIPTION=An Asynchronous HTTP Library for Android
-POM_URL=loopj.com/android-async-http/
-POM_SCM_URL=https://github.com/loopj/android-async-http
-POM_SCM_CONNECTION=scm:git@github.com:loopj/android-async-http.git
-POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
-POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
-POM_LICENCE_DIST=repo
-
-POM_DEVELOPER_ID=jamessmith
-POM_DEVELOPER_NAME=James Smith
-
diff --git a/library/build.gradle b/library/build.gradle
deleted file mode 100755
index f10d39ab..00000000
--- a/library/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-apply plugin: 'android-library'
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1'
-
-    defaultConfig {
-        minSdkVersion 3
-        targetSdkVersion 19
-    }
-
-    lintOptions {
-        xmlReport false
-        warningsAsErrors true
-        quiet false
-        showAll true
-    }
-
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_6
-        targetCompatibility JavaVersion.VERSION_1_6
-    }
-}
-
-android.libraryVariants.all { variant ->
-    def name = variant.buildType.name
-    def task = project.tasks.create "jar${name.capitalize()}", Jar
-    task.dependsOn variant.javaCompile
-    task.from variant.javaCompile.destinationDir
-    artifacts.add('archives', task);
-}
-
-apply from: '../maven_push.gradle'
diff --git a/library/gradle.properties b/library/gradle.properties
deleted file mode 100755
index 96e35d66..00000000
--- a/library/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_NAME=android-async-http Library
-POM_ARTIFACT_ID=android-async-http
-POM_PACKAGING=aar
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
deleted file mode 100755
index d7a1fcad..00000000
--- a/library/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.loopj.android.http"
-          android:versionName="1.4.5-SNAPSHOT"
-          android:versionCode="145">
-
-    <uses-permission android:name="android.permission.INTERNET"/>
-
-    <application/>
-
-</manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
deleted file mode 100755
index fe014e71..00000000
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ /dev/null
@@ -1,1282 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.content.Context;
-import android.os.Looper;
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HeaderElement;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpException;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpResponseInterceptor;
-import org.apache.http.HttpVersion;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.AuthState;
-import org.apache.http.auth.Credentials;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.CredentialsProvider;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.RedirectHandler;
-import org.apache.http.client.methods.HttpDelete;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpHead;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.client.params.ClientPNames;
-import org.apache.http.client.protocol.ClientContext;
-import org.apache.http.conn.params.ConnManagerParams;
-import org.apache.http.conn.params.ConnPerRouteBean;
-import org.apache.http.conn.params.ConnRoutePNames;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.entity.HttpEntityWrapper;
-import org.apache.http.impl.auth.BasicScheme;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.BasicHttpContext;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.protocol.SyncBasicHttpContext;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PushbackInputStream;
-import java.net.URI;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.zip.GZIPInputStream;
-
-
-/**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
- * your Android applications. Requests can be made with additional parameters by passing a {@link
- * RequestParams} instance, and responses can be handled by passing an anonymously overridden {@link
- * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
- *          System.out.println(response);
- *     }
- *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
- * error)
- * {
- *          error.printStackTrace(System.out);
- *     }
- * });
- * </pre>
- *
- * @see com.loopj.android.http.AsyncHttpResponseHandler
- * @see com.loopj.android.http.ResponseHandlerInterface
- * @see com.loopj.android.http.RequestParams
- */
-public class AsyncHttpClient {
-
-    public static final int DEFAULT_MAX_CONNECTIONS = 10;
-    public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    public static final int DEFAULT_MAX_RETRIES = 5;
-    public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
-    public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    public static final String ENCODING_GZIP = "gzip";
-    public static final String LOG_TAG = "AsyncHttpClient";
-
-    private int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private int timeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ExecutorService threadPool;
-    private final Map<Context, List<RequestHandle>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-    private boolean isUrlEncodingEnabled = true;
-
-    /**
-     * Creates a new AsyncHttpClient with default constructor arguments values
-     */
-    public AsyncHttpClient() {
-        this(false, 80, 443);
-    }
-
-    /**
-     * Creates a new AsyncHttpClient.
-     *
-     * @param httpPort non-standard HTTP-only port
-     */
-    public AsyncHttpClient(int httpPort) {
-        this(false, httpPort, 443);
-    }
-
-    /**
-     * Creates a new AsyncHttpClient.
-     *
-     * @param httpPort  non-standard HTTP-only port
-     * @param httpsPort non-standard HTTPS-only port
-     */
-    public AsyncHttpClient(int httpPort, int httpsPort) {
-        this(false, httpPort, httpsPort);
-    }
-
-    /**
-     * Creates new AsyncHttpClient using given params
-     *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
-     * @param httpPort                   HTTP port to be used, must be greater than 0
-     * @param httpsPort                  HTTPS port to be used, must be greater than 0
-     */
-    public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
-        this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));
-    }
-
-    /**
-     * Returns default instance of SchemeRegistry
-     *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
-     * @param httpPort                   HTTP port to be used, must be greater than 0
-     * @param httpsPort                  HTTPS port to be used, must be greater than 0
-     */
-    private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
-        if (fixNoHttpResponseException) {
-            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
-        }
-
-        if (httpPort < 1) {
-            httpPort = 80;
-            Log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
-        }
-
-        if (httpsPort < 1) {
-            httpsPort = 443;
-            Log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
-        }
-
-        // Fix to SSL flaw in API < ICS
-        // See https://code.google.com/p/android/issues/detail?id=13117
-        SSLSocketFactory sslSocketFactory;
-        if (fixNoHttpResponseException)
-            sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
-        else
-            sslSocketFactory = SSLSocketFactory.getSocketFactory();
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
-        schemeRegistry.register(new Scheme("https", sslSocketFactory, httpsPort));
-
-        return schemeRegistry;
-    }
-
-    /**
-     * Creates a new AsyncHttpClient.
-     *
-     * @param schemeRegistry SchemeRegistry to be used
-     */
-    public AsyncHttpClient(SchemeRegistry schemeRegistry) {
-
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        threadPool = getDefaultThreadPool();
-        requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
-        clientHeaderMap = new HashMap<String, String>();
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            @Override
-            public void process(HttpRequest request, HttpContext context) {
-                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-                }
-                for (String header : clientHeaderMap.keySet()) {
-                    if (request.containsHeader(header)) {
-                        Header overwritten = request.getFirstHeader(header);
-                        Log.d(LOG_TAG,
-                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
-                                        header, clientHeaderMap.get(header),
-                                        overwritten.getName(), overwritten.getValue())
-                        );
-                    }
-                    request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            @Override
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                if (entity == null) {
-                    return;
-                }
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(entity));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            @Override
-            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
-                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
-                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
-                        ClientContext.CREDS_PROVIDER);
-                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
-
-                if (authState.getAuthScheme() == null) {
-                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
-                    Credentials creds = credsProvider.getCredentials(authScope);
-                    if (creds != null) {
-                        authState.setAuthScheme(new BasicScheme());
-                        authState.setCredentials(creds);
-                    }
-                }
-            }
-        }, 0);
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
-    }
-
-    public static void allowRetryExceptionClass(Class<?> cls) {
-        if (cls != null) {
-            RetryHandler.addClassToWhitelist(cls);
-        }
-    }
-
-    public static void blockRetryExceptionClass(Class<?> cls) {
-        if (cls != null) {
-            RetryHandler.addClassToBlacklist(cls);
-        }
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
-     * settings for requests by accessing the client's ConnectionManager, HttpParams and
-     * SchemeRegistry.
-     *
-     * @return underlying HttpClient instance
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Get the underlying HttpContext instance. This is useful for getting and setting fine-grained
-     * settings for requests by accessing the context's attributes such as the CookieStore.
-     *
-     * @return underlying HttpContext instance
-     */
-    public HttpContext getHttpContext() {
-        return this.httpContext;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     *
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link
-     *                    PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling requests. By default,
-     * Executors.newCachedThreadPool() is used.
-     *
-     * @param threadPool an instance of {@link ExecutorService} to use for queuing/pooling
-     *                   requests.
-     */
-    public void setThreadPool(ExecutorService threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Returns the current executor service used. By default, Executors.newCachedThreadPool() is
-     * used.
-     *
-     * @return current executor service used
-     */
-    public ExecutorService getThreadPool() {
-        return threadPool;
-    }
-
-    /**
-     * Get the default threading pool to be used for this HTTP client.
-     *
-     * @return The default threading pool to be used
-     */
-    protected ExecutorService getDefaultThreadPool() {
-        return Executors.newCachedThreadPool();
-    }
-
-    /**
-     * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
-     * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
-     * setting is to disallow redirects.
-     *
-     * @param enableRedirects         boolean
-     * @param enableRelativeRedirects boolean
-     * @param enableCircularRedirects boolean
-     */
-    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
-        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
-        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
-        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
-    }
-
-    /**
-     * Circular redirects are enabled by default
-     *
-     * @param enableRedirects         boolean
-     * @param enableRelativeRedirects boolean
-     * @see #setEnableRedirects(boolean, boolean, boolean)
-     */
-    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
-        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
-    }
-
-    /**
-     * @param enableRedirects boolean
-     * @see #setEnableRedirects(boolean, boolean, boolean)
-     */
-    public void setEnableRedirects(final boolean enableRedirects) {
-        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
-    }
-
-    /**
-     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
-     * your needs
-     *
-     * @param customRedirectHandler RedirectHandler instance
-     * @see com.loopj.android.http.MyRedirectHandler
-     */
-    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
-        httpClient.setRedirectHandler(customRedirectHandler);
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default, "Android Asynchronous
-     * Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     *
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-
-    /**
-     * Returns current limit of parallel connections
-     *
-     * @return maximum limit of parallel connections, default is 10
-     */
-    public int getMaxConnections() {
-        return maxConnections;
-    }
-
-    /**
-     * Sets maximum limit of parallel connections
-     *
-     * @param maxConnections maximum parallel connections, must be at least 1
-     */
-    public void setMaxConnections(int maxConnections) {
-        if (maxConnections < 1)
-            maxConnections = DEFAULT_MAX_CONNECTIONS;
-        this.maxConnections = maxConnections;
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(this.maxConnections));
-    }
-
-    /**
-     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
-     *
-     * @return Socket Timeout limit in milliseconds
-     */
-    public int getTimeout() {
-        return timeout;
-    }
-
-    /**
-     * Set the connection and socket timeout. By default, 10 seconds.
-     *
-     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
-     */
-    public void setTimeout(int timeout) {
-        if (timeout < 1000)
-            timeout = DEFAULT_SOCKET_TIMEOUT;
-        this.timeout = timeout;
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
-    }
-
-    /**
-     * Sets the Proxy by it's hostname and port
-     *
-     * @param hostname the hostname (IP or DNS name)
-     * @param port     the port number. -1 indicates the scheme default port.
-     */
-    public void setProxy(String hostname, int port) {
-        final HttpHost proxy = new HttpHost(hostname, port);
-        final HttpParams httpParams = this.httpClient.getParams();
-        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
-    }
-
-    /**
-     * Sets the Proxy by it's hostname,port,username and password
-     *
-     * @param hostname the hostname (IP or DNS name)
-     * @param port     the port number. -1 indicates the scheme default port.
-     * @param username the username
-     * @param password the password
-     */
-    public void setProxy(String hostname, int port, String username, String password) {
-        httpClient.getCredentialsProvider().setCredentials(
-                new AuthScope(hostname, port),
-                new UsernamePasswordCredentials(username, password));
-        final HttpHost proxy = new HttpHost(hostname, port);
-        final HttpParams httpParams = this.httpClient.getParams();
-        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default, a new, default
-     * SSLSocketFactory is used.
-     *
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-
-    /**
-     * Sets the maximum number of retries and timeout for a particular Request.
-     *
-     * @param retries maximum number of retries per request
-     * @param timeout sleep between retries in milliseconds
-     */
-    public void setMaxRetriesAndTimeout(int retries, int timeout) {
-        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
-    }
-
-    /**
-     * Will, before sending, remove all headers currently present in AsyncHttpClient instance, which
-     * applies on all requests this client makes
-     */
-    public void removeAllHeaders() {
-        clientHeaderMap.clear();
-    }
-
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     *
-     * @param header the name of the header
-     * @param value  the contents of the header
-     */
-    public void addHeader(String header, String value) {
-        clientHeaderMap.put(header, value);
-    }
-
-    /**
-     * Remove header from all requests this client makes (before sending).
-     *
-     * @param header the name of the header
-     */
-    public void removeHeader(String header) {
-        clientHeaderMap.remove(header);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY)
-     *
-     * @param username Basic Auth username
-     * @param password Basic Auth password
-     */
-    public void setBasicAuth(String username, String password) {
-        setBasicAuth(username, password, false);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY)
-     *
-     * @param username  Basic Auth username
-     * @param password  Basic Auth password
-     * @param preemtive sets authorization in preemtive manner
-     */
-    public void setBasicAuth(String username, String password, boolean preemtive) {
-        setBasicAuth(username, password, null, preemtive);
-    }
-
-    /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
-     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     *
-     * @param username Basic Auth username
-     * @param password Basic Auth password
-     * @param scope    - an AuthScope object
-     */
-    public void setBasicAuth(String username, String password, AuthScope scope) {
-        setBasicAuth(username, password, scope, false);
-    }
-
-    /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
-     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     *
-     * @param username  Basic Auth username
-     * @param password  Basic Auth password
-     * @param scope     an AuthScope object
-     * @param preemtive sets authorization in preemtive manner
-     */
-    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemtive) {
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
-        this.httpClient.getCredentialsProvider().setCredentials(scope == null ? AuthScope.ANY : scope, credentials);
-        setAuthenticationPreemptive(preemtive);
-    }
-
-    /**
-     * Sets HttpRequestInterceptor which handles authorization in preemtive way, as workaround you
-     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
-     *
-     * @param isPreemtive whether the authorization is processed in preemtive way
-     */
-    public void setAuthenticationPreemptive(boolean isPreemtive) {
-        if (isPreemtive) {
-            httpClient.addRequestInterceptor(new PreemtiveAuthorizationHttpRequestInterceptor(), 0);
-        } else {
-            httpClient.removeRequestInterceptorByClass(PreemtiveAuthorizationHttpRequestInterceptor.class);
-        }
-    }
-
-    /**
-     * Removes previously set basic auth credentials
-     */
-    public void clearBasicAuth() {
-        this.httpClient.getCredentialsProvider().clear();
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the passed Context.
-     * <p>&nbsp;</p> <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy method of your android
-     * activities to destroy all requests which are no longer required.
-     *
-     * @param context               the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
-     *                              pending requests.
-     */
-    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
-        if (context == null) {
-            Log.e(LOG_TAG, "Passed null Context to cancelRequests");
-            return;
-        }
-        Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                List<RequestHandle> requestList = requestMap.get(context);
-                if (requestList != null) {
-                    for (RequestHandle requestHandle : requestList) {
-                        requestHandle.cancel(mayInterruptIfRunning);
-                    }
-                    requestMap.remove(context);
-                }
-            }
-        };
-        if (Looper.myLooper() == Looper.getMainLooper()) {
-            new Thread(r).start();
-        } else {
-            r.run();
-        }
-    }
-
-    /**
-     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
-     * only affect requests which were created with a non-null android Context. This method is
-     * intended to be used in the onDestroy method of your android activities to destroy all
-     * requests which are no longer required.
-     *
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
-     *                              pending requests.
-     */
-    public void cancelAllRequests(boolean mayInterruptIfRunning) {
-        for (List<RequestHandle> requestList : requestMap.values()) {
-            if (requestList != null) {
-                for (RequestHandle requestHandle : requestList) {
-                    requestHandle.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.clear();
-    }
-
-    // [+] HTTP HEAD
-
-    /**
-     * Perform a HTTP HEAD request, without any parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle head(String url, ResponseHandlerInterface responseHandler) {
-        return head(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP HEAD request with parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param params          additional HEAD parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle head(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return head(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP HEAD request without any parameters and track the Android Context which
-     * initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle head(Context context, String url, ResponseHandlerInterface responseHandler) {
-        return head(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP HEAD request and track the Android Context which initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param params          additional HEAD parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle head(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP HEAD request and track the Android Context which initiated the request with
-     * customized headers
-     *
-     * @param context         Context to execute request against
-     * @param url             the URL to send the request to.
-     * @param headers         set headers only for this request
-     * @param params          additional HEAD parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle head(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
-        HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-    // [-] HTTP HEAD
-    // [+] HTTP GET
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle get(String url, ResponseHandlerInterface responseHandler) {
-        return get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param params          additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle get(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which
-     * initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle get(Context context, String url, ResponseHandlerInterface responseHandler) {
-        return get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param params          additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle get(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request with
-     * customized headers
-     *
-     * @param context         Context to execute request against
-     * @param url             the URL to send the request to.
-     * @param headers         set headers only for this request
-     * @param params          additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-    // [-] HTTP GET
-    // [+] HTTP POST
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(String url, ResponseHandlerInterface responseHandler) {
-        return post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param params          additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param params          additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
-     *                        example, use this to send string/json/xml payloads to a server by
-     *                        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example
-     *                        application/json if sending a json payload.
-     * @param responseHandler the response ha   ndler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
-     * headers only for this request
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param headers         set headers only for this request
-     * @param params          additional POST parameters to send with the request.
-     * @param contentType     the content type of the payload you are sending, for example
-     *                        application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-                              ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
-        if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request. Set
-     * headers only for this request
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param headers         set headers only for this request
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
-     *                        this to send string/json/xml payloads to a server by passing a {@link
-     *                        org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example
-     *                        application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-                              ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    // [-] HTTP POST
-    // [+] HTTP PUT
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle put(String url, ResponseHandlerInterface responseHandler) {
-        return put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     *
-     * @param url             the URL to send the request to.
-     * @param params          additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle put(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param params          additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle put(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
-        return put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
-     * one-time headers for the request
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
-     *                        this to send string/json/xml payloads to a server by passing a {@link
-     *                        org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example
-     *                        application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request. And set
-     * one-time headers for the request
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param headers         set one-time headers for this request
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
-     *                        this to send string/json/xml payloads to a server by passing a {@link
-     *                        org.apache.http.entity.StringEntity}.
-     * @param contentType     the content type of the payload you are sending, for example
-     *                        application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
-        if (headers != null) request.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    // [-] HTTP PUT
-    // [+] HTTP DELETE
-
-    /**
-     * Perform a HTTP DELETE request.
-     *
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle delete(String url, ResponseHandlerInterface responseHandler) {
-        return delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
-        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param headers         set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
-        if (headers != null) delete.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     *
-     * @param context         the Android Context which initiated the request.
-     * @param url             the URL to send the request to.
-     * @param headers         set one-time headers for this request
-     * @param params          additional DELETE parameters or files to send along with request
-     * @param responseHandler the response handler instance that should handle the response.
-     * @return RequestHandle of future request process
-     */
-    public RequestHandle delete(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) {
-        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
-        if (headers != null) httpDelete.setHeaders(headers);
-        return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
-    }
-
-    // [-] HTTP DELETE
-
-    /**
-     * Instantiate a new asynchronous HTTP request for the passed parameters.
-     *
-     * @param client          HttpClient to be used for request, can differ in single requests
-     * @param contentType     MIME body type, for POST and PUT requests, may be null
-     * @param context         Context of Android application, to hold the reference of request
-     * @param httpContext     HttpContext in which the request will be executed
-     * @param responseHandler ResponseHandler or its subclass to put the response into
-     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
-     *                        HttpPost, HttpGet, HttpPut, etc.
-     * @return AsyncHttpRequest ready to be dispatched
-     */
-    protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
-        return new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
-    }
-
-    /**
-     * Puts a new request in queue as a new thread in pool to be executed
-     *
-     * @param client          HttpClient to be used for request, can differ in single requests
-     * @param contentType     MIME body type, for POST and PUT requests, may be null
-     * @param context         Context of Android application, to hold the reference of request
-     * @param httpContext     HttpContext in which the request will be executed
-     * @param responseHandler ResponseHandler or its subclass to put the response into
-     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
-     *                        HttpPost, HttpGet, HttpPut, etc.
-     * @return RequestHandle of future request process
-     */
-    protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
-        if (uriRequest == null) {
-            throw new IllegalArgumentException("HttpUriRequest must not be null");
-        }
-
-        if (responseHandler == null) {
-            throw new IllegalArgumentException("ResponseHandler must not be null");
-        }
-
-        if (responseHandler.getUseSynchronousMode()) {
-            throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
-        }
-
-        if (contentType != null) {
-            uriRequest.setHeader("Content-Type", contentType);
-        }
-
-        responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
-        responseHandler.setRequestURI(uriRequest.getURI());
-
-        AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
-        threadPool.submit(request);
-        RequestHandle requestHandle = new RequestHandle(request);
-
-        if (context != null) {
-            // Add request to request map
-            List<RequestHandle> requestList = requestMap.get(context);
-            if (requestList == null) {
-                requestList = new LinkedList<RequestHandle>();
-                requestMap.put(context, requestList);
-            }
-
-            if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
-                ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(uriRequest);
-
-            requestList.add(requestHandle);
-
-            Iterator<RequestHandle> iterator = requestList.iterator();
-            while (iterator.hasNext()) {
-                if (iterator.next().shouldBeGarbageCollected()) {
-                    iterator.remove();
-                }
-            }
-        }
-
-        return requestHandle;
-    }
-
-    /**
-     * Sets state of URL encoding feature, see bug #227, this method allows you to turn off and on
-     * this auto-magic feature on-demand.
-     *
-     * @param enabled desired state of feature
-     */
-    public void setURLEncodingEnabled(boolean enabled) {
-        this.isUrlEncodingEnabled = enabled;
-    }
-
-    /**
-     * Will encode url, if not disabled, and adds params on the end of it
-     *
-     * @param url             String with URL, should be valid URL without params
-     * @param params          RequestParams to be appended on the end of URL
-     * @param shouldEncodeUrl whether url should be encoded (replaces spaces with %20)
-     * @return encoded url if requested with params appended if any available
-     */
-    public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
-        if (url == null)
-            return null;
-
-        if (shouldEncodeUrl)
-            url = url.replace(" ", "%20");
-
-        if (params != null) {
-            // Construct the query string and trim it, in case it
-            // includes any excessive white spaces.
-            String paramString = params.getParamString().trim();
-
-            // Only add the query string if it isn't empty and it
-            // isn't equal to '?'.
-            if (!paramString.equals("") && !paramString.equals("?")) {
-                url += url.contains("?") ? "&" : "?";
-                url += paramString;
-            }
-        }
-
-        return url;
-    }
-
-    /**
-     * Checks the InputStream if it contains  GZIP compressed data
-     *
-     * @param inputStream InputStream to be checked
-     * @return true or false if the stream contains GZIP compressed data
-     * @throws java.io.IOException
-     */
-    public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {
-        if (inputStream == null)
-            return false;
-
-        byte[] signature = new byte[2];
-        int readStatus = inputStream.read(signature);
-        inputStream.unread(signature);
-        int streamHeader = ((int) signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);
-        return readStatus == 2 && GZIPInputStream.GZIP_MAGIC == streamHeader;
-    }
-
-    /**
-     * A utility function to close an input stream without raising an exception.
-     *
-     * @param is input stream to close safely
-     */
-    public static void silentCloseInputStream(InputStream is) {
-        try {
-            if (is != null) {
-                is.close();
-            }
-        } catch (IOException e) {
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
-    }
-
-    /**
-     * A utility function to close an output stream without raising an exception.
-     *
-     * @param os output stream to close safely
-     */
-    public static void silentCloseOutputStream(OutputStream os) {
-        try {
-            if (os != null) {
-                os.close();
-            }
-        } catch (IOException e) {
-            Log.w(LOG_TAG, "Cannot close output stream", e);
-        }
-    }
-
-    /**
-     * Returns HttpEntity containing data from RequestParams included with request declaration.
-     * Allows also passing progress from upload via provided ResponseHandler
-     *
-     * @param params          additional request params
-     * @param responseHandler ResponseHandlerInterface or its subclass to be notified on progress
-     */
-    private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface responseHandler) {
-        HttpEntity entity = null;
-
-        try {
-            if (params != null) {
-                entity = params.getEntity(responseHandler);
-            }
-        } catch (IOException e) {
-            if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, null, e);
-            else
-                e.printStackTrace();
-        }
-
-        return entity;
-    }
-
-    public boolean isUrlEncodingEnabled() {
-        return isUrlEncodingEnabled;
-    }
-
-    /**
-     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for
-     * example not DELETE
-     *
-     * @param entity      entity to be included within the request
-     * @param requestBase HttpRequest instance, must not be null
-     */
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if (entity != null) {
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    /**
-     * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
-     */
-    private static class InflatingEntity extends HttpEntityWrapper {
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
-        public InputStream getContent() throws IOException {
-            PushbackInputStream content = new PushbackInputStream(wrappedEntity.getContent(), 2);
-            if (isInputStreamGZIPCompressed(content)) {
-                return new GZIPInputStream(content);
-            } else {
-                return content;
-            }
-        }
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
deleted file mode 100755
index 81786ceb..00000000
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.UnknownHostException;
-
-/**
- * Internal class, representing the HttpRequest, done in asynchronous manner
- */
-public class AsyncHttpRequest implements Runnable {
-    private final AbstractHttpClient client;
-    private final HttpContext context;
-    private final HttpUriRequest request;
-    private final ResponseHandlerInterface responseHandler;
-    private int executionCount;
-    private boolean isCancelled = false;
-    private boolean cancelIsNotified = false;
-    private boolean isFinished = false;
-
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
-    }
-
-    @Override
-    public void run() {
-        if (isCancelled()) {
-            return;
-        }
-
-        if (responseHandler != null) {
-            responseHandler.sendStartMessage();
-        }
-
-        if (isCancelled()) {
-            return;
-        }
-
-        try {
-            makeRequestWithRetries();
-        } catch (IOException e) {
-            if (!isCancelled() && responseHandler != null) {
-                responseHandler.sendFailureMessage(0, null, null, e);
-            } else {
-                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
-            }
-        }
-
-        if (isCancelled()) {
-            return;
-        }
-
-        if (responseHandler != null) {
-            responseHandler.sendFinishMessage();
-        }
-
-        isFinished = true;
-    }
-
-    private void makeRequest() throws IOException {
-        if (isCancelled()) {
-            return;
-        }
-        // Fixes #115
-        if (request.getURI().getScheme() == null) {
-            // subclass of IOException so processed in the caller
-            throw new MalformedURLException("No valid URI scheme was provided");
-        }
-
-        HttpResponse response = client.execute(request, context);
-
-        if (!isCancelled() && responseHandler != null) {
-            responseHandler.sendResponseMessage(response);
-        }
-    }
-
-    private void makeRequestWithRetries() throws IOException {
-        boolean retry = true;
-        IOException cause = null;
-        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        try {
-            while (retry) {
-                try {
-                    makeRequest();
-                    return;
-                } catch (UnknownHostException e) {
-                    // switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException
-                    // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
-                    // (to assist in genuine cases of unknown host) which seems better than outright failure
-                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
-                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
-                } catch (NullPointerException e) {
-                    // there's a bug in HttpClient 4.0.x that on some occasions causes
-                    // DefaultRequestExecutor to throw an NPE, see
-                    // http://code.google.com/p/android/issues/detail?id=5255
-                    cause = new IOException("NPE in HttpClient: " + e.getMessage());
-                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
-                } catch (IOException e) {
-                    if (isCancelled()) {
-                        // Eating exception, as the request was cancelled
-                        return;
-                    }
-                    cause = e;
-                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
-                }
-                if (retry && (responseHandler != null)) {
-                    responseHandler.sendRetryMessage(executionCount);
-                }
-            }
-        } catch (Exception e) {
-            // catch anything else to ensure failure message is propagated
-            Log.e("AsyncHttpRequest", "Unhandled exception origin cause", e);
-            cause = new IOException("Unhandled exception: " + e.getMessage());
-        }
-
-        // cleaned up to throw IOException
-        throw (cause);
-    }
-
-    public boolean isCancelled() {
-        if (isCancelled) {
-            sendCancelNotification();
-        }
-        return isCancelled;
-    }
-
-    private synchronized void sendCancelNotification() {
-        if (!isFinished && isCancelled && !cancelIsNotified) {
-            cancelIsNotified = true;
-            if (responseHandler != null)
-                responseHandler.sendCancelMessage();
-        }
-    }
-
-    public boolean isDone() {
-        return isCancelled() || isFinished;
-    }
-
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        isCancelled = true;
-        request.abort();
-        return isCancelled();
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
deleted file mode 100755
index 256ab9c9..00000000
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.util.ByteArrayBuffer;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URI;
-
-/**
- * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
- * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
- * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
- * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
- * #onFinish()}, {@link #onRetry(int)} and {@link #onProgress(int, int)} methods as required.
- * <p>&nbsp;</p> For example: <p>&nbsp;</p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
- * error)
- * {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onRetry(int retryNo) {
- *         // Request was retried
- *     }
- *
- *     &#064;Override
- *     public void onProgress(int bytesWritten, int totalSize) {
- *         // Progress notification
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
-    private static final String LOG_TAG = "AsyncHttpResponseHandler";
-
-    protected static final int SUCCESS_MESSAGE = 0;
-    protected static final int FAILURE_MESSAGE = 1;
-    protected static final int START_MESSAGE = 2;
-    protected static final int FINISH_MESSAGE = 3;
-    protected static final int PROGRESS_MESSAGE = 4;
-    protected static final int RETRY_MESSAGE = 5;
-    protected static final int CANCEL_MESSAGE = 6;
-
-    protected static final int BUFFER_SIZE = 4096;
-
-    public static final String DEFAULT_CHARSET = "UTF-8";
-    private String responseCharset = DEFAULT_CHARSET;
-    private Handler handler;
-    private boolean useSynchronousMode;
-
-    private URI requestURI = null;
-    private Header[] requestHeaders = null;
-
-    @Override
-    public URI getRequestURI() {
-        return this.requestURI;
-    }
-
-    @Override
-    public Header[] getRequestHeaders() {
-        return this.requestHeaders;
-    }
-
-    @Override
-    public void setRequestURI(URI requestURI) {
-        this.requestURI = requestURI;
-    }
-
-    @Override
-    public void setRequestHeaders(Header[] requestHeaders) {
-        this.requestHeaders = requestHeaders;
-    }
-
-    /**
-     * Avoid leaks by using a non-anonymous handler class.
-     */
-    private static class ResponderHandler extends Handler {
-        private final AsyncHttpResponseHandler mResponder;
-
-        ResponderHandler(AsyncHttpResponseHandler mResponder) {
-            this.mResponder = mResponder;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            mResponder.handleMessage(msg);
-        }
-    }
-
-    @Override
-    public boolean getUseSynchronousMode() {
-        return useSynchronousMode;
-    }
-
-    @Override
-    public void setUseSynchronousMode(boolean value) {
-        // A looper must be prepared before setting asynchronous mode.
-        if (!value && Looper.myLooper() == null) {
-            value = true;
-            Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
-        }
-
-        // If using synchronous mode.
-        if (!value && handler == null) {
-            // Create a handler on current thread to submit tasks
-            handler = new ResponderHandler(this);
-        } else if (value && handler != null) {
-            // TODO: Consider adding a flag to remove all queued messages.
-            handler = null;
-        }
-
-        useSynchronousMode = value;
-    }
-
-    /**
-     * Sets the charset for the response string. If not set, the default is UTF-8.
-     *
-     * @param charset to be used for the response string.
-     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
-     */
-    public void setCharset(final String charset) {
-        this.responseCharset = charset;
-    }
-
-    public String getCharset() {
-        return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
-    }
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Use asynchronous mode by default.
-        setUseSynchronousMode(false);
-    }
-
-    /**
-     * Fired when the request progress, override to handle in your own code
-     *
-     * @param bytesWritten offset from start of file
-     * @param totalSize    total size of file
-     */
-    public void onProgress(int bytesWritten, int totalSize) {
-        Log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
-    }
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {
-    }
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to
-     * handle in your own code
-     */
-    public void onFinish() {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode   the status code of the response
-     * @param headers      return headers, if any
-     * @param responseBody the body of the HTTP response from the server
-     */
-    public abstract void onSuccess(int statusCode, Header[] headers, byte[] responseBody);
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode   return HTTP status code
-     * @param headers      return headers, if any
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
-     */
-    public abstract void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
-
-    /**
-     * Fired when a retry occurs, override to handle in your own code
-     *
-     * @param retryNo number of retry
-     */
-    public void onRetry(int retryNo) {
-        Log.d(LOG_TAG, String.format("Request retry no. %d", retryNo));
-    }
-
-    public void onCancel() {
-        Log.d(LOG_TAG, "Request got cancelled");
-    }
-
-    final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
-        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
-    }
-
-    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
-    }
-
-    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
-    }
-
-    final public void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    final public void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-    final public void sendRetryMessage(int retryNo) {
-        sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
-    }
-
-    final public void sendCancelMessage() {
-        sendMessage(obtainMessage(CANCEL_MESSAGE, null));
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message message) {
-        Object[] response;
-
-        switch (message.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 3) {
-                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
-                } else {
-                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 4) {
-                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
-                } else {
-                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
-                }
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-            case PROGRESS_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 2) {
-                    try {
-                        onProgress((Integer) response[0], (Integer) response[1]);
-                    } catch (Throwable t) {
-                        Log.e(LOG_TAG, "custom onProgress contains an error", t);
-                    }
-                } else {
-                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
-                }
-                break;
-            case RETRY_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length == 1)
-                    onRetry((Integer) response[0]);
-                else
-                    Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
-                break;
-            case CANCEL_MESSAGE:
-                onCancel();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if (getUseSynchronousMode() || handler == null) {
-            handleMessage(msg);
-        } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
-            handler.sendMessage(msg);
-        }
-    }
-
-    /**
-     * Helper method to send runnable into local handler loop
-     *
-     * @param runnable runnable instance, can be null
-     */
-    protected void postRunnable(Runnable runnable) {
-        if (runnable != null) {
-            if (getUseSynchronousMode() || handler == null) {
-                // This response handler is synchronous, run on current thread
-                runnable.run();
-            } else {
-                // Otherwise, run on provided handler
-                handler.post(runnable);
-            }
-        }
-    }
-
-    /**
-     * Helper method to create Message instance from handler
-     *
-     * @param responseMessageId   constant to identify Handler message
-     * @param responseMessageData object to be passed to message receiver
-     * @return Message instance, should not be null
-     */
-    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
-        Message msg;
-        if (handler == null) {
-            msg = Message.obtain();
-            if (msg != null) {
-                msg.what = responseMessageId;
-                msg.obj = responseMessageData;
-            }
-        } else {
-            msg = Message.obtain(handler, responseMessageId, responseMessageData);
-        }
-        return msg;
-    }
-
-    @Override
-    public void sendResponseMessage(HttpResponse response) throws IOException {
-        // do not process if request has been cancelled
-        if (!Thread.currentThread().isInterrupted()) {
-            StatusLine status = response.getStatusLine();
-            byte[] responseBody;
-            responseBody = getResponseData(response.getEntity());
-            // additional cancellation check as getResponseData() can take non-zero time to process
-            if (!Thread.currentThread().isInterrupted()) {
-                if (status.getStatusCode() >= 300) {
-                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
-                } else {
-                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
-                }
-            }
-        }
-    }
-
-    /**
-     * Returns byte array of response HttpEntity contents
-     *
-     * @param entity can be null
-     * @return response entity body or null
-     * @throws java.io.IOException if reading entity or creating byte array failed
-     */
-    byte[] getResponseData(HttpEntity entity) throws IOException {
-        byte[] responseBody = null;
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            if (instream != null) {
-                long contentLength = entity.getContentLength();
-                if (contentLength > Integer.MAX_VALUE) {
-                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
-                }
-                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
-                try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
-                    try {
-                        byte[] tmp = new byte[BUFFER_SIZE];
-                        int l, count = 0;
-                        // do not send messages if request has been cancelled
-                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                            count += l;
-                            buffer.append(tmp, 0, l);
-                            sendProgressMessage(count, (int) (contentLength <= 0 ? 1 : contentLength));
-                        }
-                    } finally {
-                        AsyncHttpClient.silentCloseInputStream(instream);
-                    }
-                    responseBody = buffer.toByteArray();
-                } catch (OutOfMemoryError e) {
-                    System.gc();
-                    throw new IOException("File too large to fit into available memory");
-                }
-            }
-        }
-        return responseBody;
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
deleted file mode 100755
index cc26d439..00000000
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ /dev/null
@@ -1,718 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.loopj.android.http;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
- */
-public class Base64 {
-    /**
-     * Default values for encoder/decoder flags.
-     */
-    public static final int DEFAULT = 0;
-
-    /**
-     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
-     */
-    public static final int NO_PADDING = 1;
-
-    /**
-     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
-     */
-    public static final int NO_WRAP = 2;
-
-    /**
-     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
-     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
-     */
-    public static final int CRLF = 4;
-
-    /**
-     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
-     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
-     * /}.
-     */
-    public static final int URL_SAFE = 8;
-
-    /**
-     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
-     * stream it is wrapping when it itself is closed.
-     */
-    public static final int NO_CLOSE = 16;
-
-    //  --------------------------------------------------------
-    //  shared code
-    //  --------------------------------------------------------
-
-    /* package */ static abstract class Coder {
-        public byte[] output;
-        public int op;
-
-        /**
-         * Encode/decode another block of input data.  this.output is provided by the caller, and
-         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
-         * of the coded data.
-         *
-         * @param finish true if this is the final call to process for this object.  Will finalize
-         *               the coder state and include any final bytes in the output.
-         * @return true if the input so far is good; false if some error has been detected in the
-         * input stream..
-         */
-        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
-
-        /**
-         * @return the maximum number of bytes a call to process() could produce for the given
-         * number of input bytes.  This may be an overestimate.
-         */
-        public abstract int maxOutputSize(int len);
-    }
-
-    //  --------------------------------------------------------
-    //  decoding
-    //  --------------------------------------------------------
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
-     * are present, there must be the correct number of them.
-     *
-     * @param str   the input String to decode, which is converted to bytes using the default
-     *              charset
-     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
-     *              standard Base64.
-     * @return decoded bytes
-     * @throws IllegalArgumentException if the input contains incorrect padding
-     */
-    public static byte[] decode(String str, int flags) {
-        return decode(str.getBytes(), flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
-     * are present, there must be the correct number of them.
-     *
-     * @param input the input array to decode
-     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
-     *              standard Base64.
-     * @return decoded bytes
-     * @throws IllegalArgumentException if the input contains incorrect padding
-     */
-    public static byte[] decode(byte[] input, int flags) {
-        return decode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
-     * are present, there must be the correct number of them.
-     *
-     * @param input  the data to decode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
-     *               standard Base64.
-     * @return decoded bytes for given offset and length
-     * @throws IllegalArgumentException if the input contains incorrect padding
-     */
-    public static byte[] decode(byte[] input, int offset, int len, int flags) {
-        // Allocate space for the most data the input could represent.
-        // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
-
-        if (!decoder.process(input, offset, len, true)) {
-            throw new IllegalArgumentException("bad base-64");
-        }
-
-        // Maybe we got lucky and allocated exactly enough output space.
-        if (decoder.op == decoder.output.length) {
-            return decoder.output;
-        }
-
-        // Need to shorten the array, so allocate a new one of the
-        // right size and copy.
-        byte[] temp = new byte[decoder.op];
-        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
-        return temp;
-    }
-
-    /* package */ static class Decoder extends Coder {
-        /**
-         * Lookup table for turning bytes into their position in the Base64 alphabet.
-         */
-        private static final int DECODE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /**
-         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
-         * and /.
-         */
-        private static final int DECODE_WEBSAFE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /**
-         * Non-data values in the DECODE arrays.
-         */
-        private static final int SKIP = -1;
-        private static final int EQUALS = -2;
-
-        /**
-         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
-         * expecting exactly one more. State 5 is expecting no more data or padding characters in
-         * the input. State 6 is the error state; an error has been detected in the input and no
-         * future input can "fix" it.
-         */
-        private int state;   // state number (0 to 6)
-        private int value;
-
-        final private int[] alphabet;
-
-        public Decoder(int flags, byte[] output) {
-            this.output = output;
-
-            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
-            state = 0;
-            value = 0;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 3 / 4 + 10;
-        }
-
-        /**
-         * Decode another block of input data.
-         *
-         * @return true if the state machine is still healthy.  false if bad base-64 data has been
-         * detected in the input stream.
-         */
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            if (this.state == 6) return false;
-
-            int p = offset;
-            len += offset;
-
-            // Using local variables makes the decoder about 12%
-            // faster than if we manipulate the member variables in
-            // the loop.  (Even alphabet makes a measurable
-            // difference, which is somewhat surprising to me since
-            // the member variable is final.)
-            int state = this.state;
-            int value = this.value;
-            int op = 0;
-            final byte[] output = this.output;
-            final int[] alphabet = this.alphabet;
-
-            while (p < len) {
-                // Try the fast path:  we're starting a new tuple and the
-                // next four bytes of the input stream are all data
-                // bytes.  This corresponds to going through states
-                // 0-1-2-3-0.  We expect to use this method for most of
-                // the data.
-                //
-                // If any of the next four bytes of input are non-data
-                // (whitespace, etc.), value will end up negative.  (All
-                // the non-data values in decode are small negative
-                // numbers, so shifting any of them up and or'ing them
-                // together will result in a value with its top bit set.)
-                //
-                // You can remove this whole block and the output should
-                // be the same, just slower.
-                if (state == 0) {
-                    while (p + 4 <= len &&
-                            (value = ((alphabet[input[p] & 0xff] << 18) |
-                                    (alphabet[input[p + 1] & 0xff] << 12) |
-                                    (alphabet[input[p + 2] & 0xff] << 6) |
-                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
-                        output[op + 2] = (byte) value;
-                        output[op + 1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        p += 4;
-                    }
-                    if (p >= len) break;
-                }
-
-                // The fast path isn't available -- either we've read a
-                // partial tuple, or the next four input bytes aren't all
-                // data, or whatever.  Fall back to the slower state
-                // machine implementation.
-
-                int d = alphabet[input[p++] & 0xff];
-
-                switch (state) {
-                    case 0:
-                        if (d >= 0) {
-                            value = d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 1:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 2:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect exactly one more padding character.
-                            output[op++] = (byte) (value >> 4);
-                            state = 4;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 3:
-                        if (d >= 0) {
-                            // Emit the output triple and return to state 0.
-                            value = (value << 6) | d;
-                            output[op + 2] = (byte) value;
-                            output[op + 1] = (byte) (value >> 8);
-                            output[op] = (byte) (value >> 16);
-                            op += 3;
-                            state = 0;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect no further data or padding characters.
-                            output[op + 1] = (byte) (value >> 2);
-                            output[op] = (byte) (value >> 10);
-                            op += 2;
-                            state = 5;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 4:
-                        if (d == EQUALS) {
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 5:
-                        if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-                }
-            }
-
-            if (!finish) {
-                // We're out of input, but a future call could provide
-                // more.
-                this.state = state;
-                this.value = value;
-                this.op = op;
-                return true;
-            }
-
-            // Done reading input.  Now figure out where we are left in
-            // the state machine and finish up.
-
-            switch (state) {
-                case 0:
-                    // Output length is a multiple of three.  Fine.
-                    break;
-                case 1:
-                    // Read one extra input byte, which isn't enough to
-                    // make another output byte.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 2:
-                    // Read two extra input bytes, enough to emit 1 more
-                    // output byte.  Fine.
-                    output[op++] = (byte) (value >> 4);
-                    break;
-                case 3:
-                    // Read three extra input bytes, enough to emit 2 more
-                    // output bytes.  Fine.
-                    output[op++] = (byte) (value >> 10);
-                    output[op++] = (byte) (value >> 2);
-                    break;
-                case 4:
-                    // Read one padding '=' when we expected 2.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 5:
-                    // Read all the padding '='s we expected and no more.
-                    // Fine.
-                    break;
-            }
-
-            this.state = state;
-            this.op = op;
-            return true;
-        }
-    }
-
-    //  --------------------------------------------------------
-    //  encoding
-    //  --------------------------------------------------------
-
-    /**
-     * Base64-encode the given data and return a newly allocated String with the result.
-     *
-     * @param input the data to encode
-     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
-     *              in output that adheres to RFC 2045.
-     * @return base64 string containing encoded input
-     */
-    public static String encodeToString(byte[] input, int flags) {
-        try {
-            return new String(encode(input, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated String with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
-     *               results in output that adheres to RFC 2045.
-     * @return base64 string containing encoded range of input
-     */
-    public static String encodeToString(byte[] input, int offset, int len, int flags) {
-        try {
-            return new String(encode(input, offset, len, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated byte[] with the result.
-     *
-     * @param input the data to encode
-     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
-     *              in output that adheres to RFC 2045.
-     * @return base64 encoded input as bytes
-     */
-    public static byte[] encode(byte[] input, int flags) {
-        return encode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
-     *               results in output that adheres to RFC 2045.
-     * @return base64 encoded input as bytes
-     */
-    public static byte[] encode(byte[] input, int offset, int len, int flags) {
-        Encoder encoder = new Encoder(flags, null);
-
-        // Compute the exact length of the array we will produce.
-        int output_len = len / 3 * 4;
-
-        // Account for the tail of the data and the padding bytes, if any.
-        if (encoder.do_padding) {
-            if (len % 3 > 0) {
-                output_len += 4;
-            }
-        } else {
-            switch (len % 3) {
-                case 0:
-                    break;
-                case 1:
-                    output_len += 2;
-                    break;
-                case 2:
-                    output_len += 3;
-                    break;
-            }
-        }
-
-        // Account for the newlines, if any.
-        if (encoder.do_newline && len > 0) {
-            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                    (encoder.do_cr ? 2 : 1);
-        }
-
-        encoder.output = new byte[output_len];
-        encoder.process(input, offset, len, true);
-
-        if (BuildConfig.DEBUG && encoder.op != output_len) {
-            throw new AssertionError();
-        }
-
-        return encoder.output;
-    }
-
-    /* package */ static class Encoder extends Coder {
-        /**
-         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
-         * (the maximum allowable according to <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC
-         * 2045</a>).
-         */
-        public static final int LINE_GROUPS = 19;
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
-         */
-        private static final byte ENCODE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
-        };
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
-         */
-        private static final byte ENCODE_WEBSAFE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
-        };
-
-        final private byte[] tail;
-        /* package */ int tailLen;
-        private int count;
-
-        final public boolean do_padding;
-        final public boolean do_newline;
-        final public boolean do_cr;
-        final private byte[] alphabet;
-
-        public Encoder(int flags, byte[] output) {
-            this.output = output;
-
-            do_padding = (flags & NO_PADDING) == 0;
-            do_newline = (flags & NO_WRAP) == 0;
-            do_cr = (flags & CRLF) != 0;
-            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
-
-            tail = new byte[2];
-            tailLen = 0;
-
-            count = do_newline ? LINE_GROUPS : -1;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 8 / 5 + 10;
-        }
-
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            // Using local variables makes the encoder about 9% faster.
-            final byte[] alphabet = this.alphabet;
-            final byte[] output = this.output;
-            int op = 0;
-            int count = this.count;
-
-            int p = offset;
-            len += offset;
-            int v = -1;
-
-            // First we need to concatenate the tail of the previous call
-            // with any input bytes available now and see if we can empty
-            // the tail.
-
-            switch (tailLen) {
-                case 0:
-                    // There was no tail.
-                    break;
-
-                case 1:
-                    if (p + 2 <= len) {
-                        // A 1-byte tail with at least 2 bytes of
-                        // input available now.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((input[p++] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    }
-                    break;
-
-                case 2:
-                    if (p + 1 <= len) {
-                        // A 2-byte tail with at least 1 byte of input.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((tail[1] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    }
-                    break;
-            }
-
-            if (v != -1) {
-                output[op++] = alphabet[(v >> 18) & 0x3f];
-                output[op++] = alphabet[(v >> 12) & 0x3f];
-                output[op++] = alphabet[(v >> 6) & 0x3f];
-                output[op++] = alphabet[v & 0x3f];
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            // At this point either there is no tail, or there are fewer
-            // than 3 bytes of input available.
-
-            // The main loop, turning 3 input bytes into 4 output bytes on
-            // each iteration.
-            while (p + 3 <= len) {
-                v = ((input[p] & 0xff) << 16) |
-                        ((input[p + 1] & 0xff) << 8) |
-                        (input[p + 2] & 0xff);
-                output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op + 1] = alphabet[(v >> 12) & 0x3f];
-                output[op + 2] = alphabet[(v >> 6) & 0x3f];
-                output[op + 3] = alphabet[v & 0x3f];
-                p += 3;
-                op += 4;
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            if (finish) {
-                // Finish up the tail of the input.  Note that we need to
-                // consume any bytes in tail before any bytes
-                // remaining in input; there should be at most two bytes
-                // total.
-
-                if (p - tailLen == len - 1) {
-                    int t = 0;
-                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (p - tailLen == len - 2) {
-                    int t = 0;
-                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 12) & 0x3f];
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                }
-
-                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
-                    throw new AssertionError();
-                }
-            } else {
-                // Save the leftovers in tail to be consumed on the next
-                // call to encodeInternal.
-
-                if (p == len - 1) {
-                    tail[tailLen++] = input[p];
-                } else if (p == len - 2) {
-                    tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p + 1];
-                }
-            }
-
-            this.op = op;
-            this.count = count;
-
-            return true;
-        }
-    }
-
-    private Base64() {
-    }   // don't instantiate
-}
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
deleted file mode 100755
index ea2af542..00000000
--- a/library/src/main/java/com/loopj/android/http/Base64DataException.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.loopj.android.http;
-
-import java.io.IOException;
-
-public class Base64DataException extends IOException {
-    public Base64DataException(String detailMessage) {
-        super(detailMessage);
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
deleted file mode 100755
index 036d4a28..00000000
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.loopj.android.http;
-
-import java.io.FilterOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-public class Base64OutputStream extends FilterOutputStream {
-    private final Base64.Coder coder;
-    private final int flags;
-
-    private byte[] buffer = null;
-    private int bpos = 0;
-
-    private static byte[] EMPTY = new byte[0];
-
-    /**
-     * Performs Base64 encoding on the data written to the stream, writing the encoded data to
-     * another OutputStream.
-     *
-     * @param out   the OutputStream to write the encoded data to
-     * @param flags bit flags for controlling the encoder; see the constants in {@link Base64}
-     */
-    public Base64OutputStream(OutputStream out, int flags) {
-        this(out, flags, true);
-    }
-
-    /**
-     * Performs Base64 encoding or decoding on the data written to the stream, writing the
-     * encoded/decoded data to another OutputStream.
-     *
-     * @param out    the OutputStream to write the encoded data to
-     * @param flags  bit flags for controlling the encoder; see the constants in {@link Base64}
-     * @param encode true to encode, false to decode
-     */
-    public Base64OutputStream(OutputStream out, int flags, boolean encode) {
-        super(out);
-        this.flags = flags;
-        if (encode) {
-            coder = new Base64.Encoder(flags, null);
-        } else {
-            coder = new Base64.Decoder(flags, null);
-        }
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        // To avoid invoking the encoder/decoder routines for single
-        // bytes, we buffer up calls to write(int) in an internal
-        // byte array to transform them into writes of decently-sized
-        // arrays.
-
-        if (buffer == null) {
-            buffer = new byte[1024];
-        }
-        if (bpos >= buffer.length) {
-            // internal buffer full; write it out.
-            internalWrite(buffer, 0, bpos, false);
-            bpos = 0;
-        }
-        buffer[bpos++] = (byte) b;
-    }
-
-    /**
-     * Flush any buffered data from calls to write(int).  Needed before doing a write(byte[], int,
-     * int) or a close().
-     */
-    private void flushBuffer() throws IOException {
-        if (bpos > 0) {
-            internalWrite(buffer, 0, bpos, false);
-            bpos = 0;
-        }
-    }
-
-    @Override
-    public void write(byte[] b, int off, int len) throws IOException {
-        if (len <= 0) return;
-        flushBuffer();
-        internalWrite(b, off, len, false);
-    }
-
-    @Override
-    public void close() throws IOException {
-        IOException thrown = null;
-        try {
-            flushBuffer();
-            internalWrite(EMPTY, 0, 0, true);
-        } catch (IOException e) {
-            thrown = e;
-        }
-
-        try {
-            if ((flags & Base64.NO_CLOSE) == 0) {
-                out.close();
-            } else {
-                out.flush();
-            }
-        } catch (IOException e) {
-            if (thrown != null) {
-                thrown = e;
-            }
-        }
-
-        if (thrown != null) {
-            throw thrown;
-        }
-    }
-
-    /**
-     * Write the given bytes to the encoder/decoder.
-     *
-     * @param finish true if this is the last batch of input, to cause encoder/decoder state to be
-     *               finalized.
-     */
-    private void internalWrite(byte[] b, int off, int len, boolean finish) throws IOException {
-        coder.output = embiggen(coder.output, coder.maxOutputSize(len));
-        if (!coder.process(b, off, len, finish)) {
-            throw new Base64DataException("bad base-64");
-        }
-        out.write(coder.output, 0, coder.op);
-    }
-
-    /**
-     * If b.length is at least len, return b.  Otherwise return a new byte array of length len.
-     */
-    private byte[] embiggen(byte[] b, int len) {
-        if (b == null || b.length < len) {
-            return new byte[len];
-        } else {
-            return b;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
deleted file mode 100755
index 0fe6ec16..00000000
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpStatus;
-
-/**
- * Class meant to be used with custom JSON parser (such as GSON or Jackson JSON) <p>&nbsp;</p>
- * {@link #parseResponse(String, boolean)} should be overriden and must return type of generic param
- * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
- * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
- * Throwable, String, Object)}, depending of response HTTP status line (result http code)
- *
- * @param <JSON_TYPE> Generic type meant to be returned in callback
- */
-public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
-    private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
-
-    /**
-     * Creates a new JsonHttpResponseHandler with default charset "UTF-8"
-     */
-    public BaseJsonHttpResponseHandler() {
-        this(DEFAULT_CHARSET);
-    }
-
-    /**
-     * Creates a new JsonHttpResponseHandler with given string encoding
-     *
-     * @param encoding result string encoding, see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
-     */
-    public BaseJsonHttpResponseHandler(String encoding) {
-        super(encoding);
-    }
-
-    /**
-     * Base abstract method, handling defined generic type
-     *
-     * @param statusCode      HTTP status line
-     * @param headers         response headers
-     * @param rawJsonResponse string of response, can be null
-     * @param response        response returned by {@link #parseResponse(String, boolean)}
-     */
-    public abstract void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, JSON_TYPE response);
-
-    /**
-     * Base abstract method, handling defined generic type
-     *
-     * @param statusCode    HTTP status line
-     * @param headers       response headers
-     * @param throwable     error thrown while processing request
-     * @param rawJsonData   raw string data returned if any
-     * @param errorResponse response returned by {@link #parseResponse(String, boolean)}
-     */
-    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, JSON_TYPE errorResponse);
-
-    @Override
-    public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
-        if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            Runnable parser = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseString, false);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onSuccess(statusCode, headers, responseString, jsonResponse);
-                            }
-                        });
-                    } catch (final Throwable t) {
-                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onFailure(statusCode, headers, t, responseString, null);
-                            }
-                        });
-                    }
-                }
-            };
-            if (!getUseSynchronousMode())
-                new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
-                parser.run();
-        } else {
-            onSuccess(statusCode, headers, null, null);
-        }
-    }
-
-    @Override
-    public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
-        if (responseString != null) {
-            Runnable parser = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseString, true);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onFailure(statusCode, headers, throwable, responseString, jsonResponse);
-                            }
-                        });
-                    } catch (Throwable t) {
-                        Log.d(LOG_TAG, "parseResponse thrown an problem", t);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onFailure(statusCode, headers, throwable, responseString, null);
-                            }
-                        });
-                    }
-                }
-            };
-            if (!getUseSynchronousMode())
-                new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
-                parser.run();
-        } else {
-            onFailure(statusCode, headers, throwable, null, null);
-        }
-    }
-
-    /**
-     * Should return deserialized instance of generic type, may return object for more vague
-     * handling
-     *
-     * @param rawJsonData response string, may be null
-     * @param isFailure   indicating if this method is called from onFailure or not
-     * @return object of generic type or possibly null if you choose so
-     * @throws Throwable allows you to throw anything from within deserializing JSON response
-     */
-    protected abstract JSON_TYPE parseResponse(String rawJsonData, boolean isFailure) throws Throwable;
-}
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
deleted file mode 100755
index f4355caa..00000000
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-
-import java.io.IOException;
-import java.util.regex.Pattern;
-import java.util.regex.PatternSyntaxException;
-
-/**
- * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}.
- * Receives response body as byte array with a content-type whitelist. (e.g. checks Content-Type
- * against allowed list, Content-length). <p>&nbsp;</p> For example: <p>&nbsp;</p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * String[] allowedTypes = new String[] { "image/png" };
- * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
- *     &#064;Override
- *     public void onSuccess(byte[] imageData) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(Throwable e, byte[] imageData) {
- *         // Response failed :(
- *     }
- * });
- * </pre>
- */
-public abstract class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
-
-    private static final String LOG_TAG = "BinaryHttpResponseHandler";
-
-    private String[] mAllowedContentTypes = new String[]{
-            "image/jpeg",
-            "image/png",
-            "image/gif",
-            "application/octet-stream"
-    };
-
-    /**
-     * Method can be overriden to return allowed content types, can be sometimes better than passing
-     * data in constructor
-     *
-     * @return array of content-types or Pattern string templates (eg. '.*' to match every response)
-     */
-    public String[] getAllowedContentTypes() {
-        return mAllowedContentTypes;
-    }
-
-    /**
-     * Creates a new BinaryHttpResponseHandler
-     */
-    public BinaryHttpResponseHandler() {
-        super();
-    }
-
-    /**
-     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed content types with
-     * passed String array (hopefully) of content types.
-     *
-     * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
-     */
-    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        super();
-        if (allowedContentTypes != null)
-            mAllowedContentTypes = allowedContentTypes;
-        else
-            Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
-    }
-
-    @Override
-    public abstract void onSuccess(int statusCode, Header[] headers, byte[] binaryData);
-
-    @Override
-    public abstract void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error);
-
-    @Override
-    public final void sendResponseMessage(HttpResponse response) throws IOException {
-        StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        if (contentTypeHeaders.length != 1) {
-            //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
-            return;
-        }
-        Header contentTypeHeader = contentTypeHeaders[0];
-        boolean foundAllowedContentType = false;
-        for (String anAllowedContentType : getAllowedContentTypes()) {
-            try {
-                if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
-                    foundAllowedContentType = true;
-                }
-            } catch (PatternSyntaxException e) {
-                Log.e("BinaryHttpResponseHandler", "Given pattern is not valid: " + anAllowedContentType, e);
-            }
-        }
-        if (!foundAllowedContentType) {
-            //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
-            return;
-        }
-        super.sendResponseMessage(response);
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
deleted file mode 100755
index 72c9404c..00000000
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.os.Message;
-import android.util.Log;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.util.ByteArrayBuffer;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
-    private static final String LOG_TAG = "DataAsyncHttpResponseHandler";
-
-    protected static final int PROGRESS_DATA_MESSAGE = 6;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public DataAsyncHttpResponseHandler() {
-        super();
-    }
-
-    /**
-     * Fired when the request progress, override to handle in your own code
-     *
-     * @param responseBody response body received so far
-     */
-    public void onProgressData(byte[] responseBody) {
-    }
-
-
-    final public void sendProgressDataMessage(byte[] responseBytes) {
-        sendMessage(obtainMessage(PROGRESS_DATA_MESSAGE, new Object[]{responseBytes}));
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    @Override
-    protected void handleMessage(Message message) {
-        super.handleMessage(message);
-        Object[] response;
-
-        switch (message.what) {
-            case PROGRESS_DATA_MESSAGE:
-                response = (Object[]) message.obj;
-                if (response != null && response.length >= 1) {
-                    try {
-                        onProgressData((byte[]) response[0]);
-                    } catch (Throwable t) {
-                        Log.e(LOG_TAG, "custom onProgressData contains an error", t);
-                    }
-                } else {
-                    Log.e(LOG_TAG, "PROGRESS_DATA_MESSAGE didn't got enough params");
-                }
-                break;
-        }
-    }
-
-    /**
-     * Returns byte array of response HttpEntity contents
-     *
-     * @param entity can be null
-     * @return response entity body or null
-     * @throws java.io.IOException if reading entity or creating byte array failed
-     */
-    @Override
-    byte[] getResponseData(HttpEntity entity) throws IOException {
-
-        byte[] responseBody = null;
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            if (instream != null) {
-                long contentLength = entity.getContentLength();
-                if (contentLength > Integer.MAX_VALUE) {
-                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
-                }
-                if (contentLength < 0) {
-                    contentLength = BUFFER_SIZE;
-                }
-                try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
-                    try {
-                        byte[] tmp = new byte[BUFFER_SIZE];
-                        int l;
-                        // do not send messages if request has been cancelled
-                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                            buffer.append(tmp, 0, l);
-                            sendProgressDataMessage(copyOfRange(tmp, 0, l));
-                        }
-                    } finally {
-                        AsyncHttpClient.silentCloseInputStream(instream);
-                    }
-                    responseBody = buffer.toByteArray();
-                } catch (OutOfMemoryError e) {
-                    System.gc();
-                    throw new IOException("File too large to fit into available memory");
-                }
-            }
-        }
-        return responseBody;
-    }
-
-    /**
-     * Copies elements from {@code original} into a new array, from indexes start (inclusive) to end
-     * (exclusive). The original order of elements is preserved. If {@code end} is greater than
-     * {@code original.length}, the result is padded with the value {@code (byte) 0}.
-     *
-     * @param original the original array
-     * @param start    the start index, inclusive
-     * @param end      the end index, exclusive
-     * @return the new array
-     * @throws ArrayIndexOutOfBoundsException if {@code start < 0 || start > original.length}
-     * @throws IllegalArgumentException       if {@code start > end}
-     * @throws NullPointerException           if {@code original == null}
-     * @see java.util.Arrays
-     * @since 1.6
-     */
-    public static byte[] copyOfRange(byte[] original, int start, int end) throws ArrayIndexOutOfBoundsException, IllegalArgumentException, NullPointerException {
-        if (start > end) {
-            throw new IllegalArgumentException();
-        }
-        int originalLength = original.length;
-        if (start < 0 || start > originalLength) {
-            throw new ArrayIndexOutOfBoundsException();
-        }
-        int resultLength = end - start;
-        int copyLength = Math.min(resultLength, originalLength - start);
-        byte[] result = new byte[resultLength];
-        System.arraycopy(original, start, result, 0, copyLength);
-        return result;
-    }
-}
-
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
deleted file mode 100755
index 5a005d6a..00000000
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.content.Context;
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
-
-    protected final File mFile;
-    private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
-
-    /**
-     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
-     *
-     * @param file File to store response within, must not be null
-     */
-    public FileAsyncHttpResponseHandler(File file) {
-        super();
-        assert (file != null);
-        this.mFile = file;
-    }
-
-    /**
-     * Obtains new FileAsyncHttpResponseHandler against context with target being temporary file
-     *
-     * @param context Context, must not be null
-     */
-    public FileAsyncHttpResponseHandler(Context context) {
-        super();
-        this.mFile = getTemporaryFile(context);
-    }
-
-    /**
-     * Attempts to delete file with stored response
-     *
-     * @return false if the file does not exist or is null, true if it was successfully deleted
-     */
-    public boolean deleteTargetFile() {
-        return getTargetFile() != null && getTargetFile().delete();
-    }
-
-    /**
-     * Used when there is no file to be used when calling constructor
-     *
-     * @param context Context, must not be null
-     * @return temporary file or null if creating file failed
-     */
-    protected File getTemporaryFile(Context context) {
-        assert (context != null);
-        try {
-            return File.createTempFile("temp_", "_handled", context.getCacheDir());
-        } catch (IOException e) {
-            Log.e(LOG_TAG, "Cannot create temporary file", e);
-        }
-        return null;
-    }
-
-    /**
-     * Retrieves File object in which the response is stored
-     *
-     * @return File file in which the response is stored
-     */
-    protected File getTargetFile() {
-        assert (mFile != null);
-        return mFile;
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
-        onFailure(statusCode, headers, throwable, getTargetFile());
-    }
-
-    /**
-     * Method to be overriden, receives as much of file as possible Called when the file is
-     * considered failure or if there is error when retrieving file
-     *
-     * @param statusCode http file status line
-     * @param headers    file http headers if any
-     * @param throwable  returned throwable
-     * @param file       file in which the file is stored
-     */
-    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, File file);
-
-    @Override
-    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
-        onSuccess(statusCode, headers, getTargetFile());
-    }
-
-    /**
-     * Method to be overriden, receives as much of response as possible
-     *
-     * @param statusCode http response status line
-     * @param headers    response http headers if any
-     * @param file       file in which the response is stored
-     */
-    public abstract void onSuccess(int statusCode, Header[] headers, File file);
-
-    @Override
-    protected byte[] getResponseData(HttpEntity entity) throws IOException {
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            long contentLength = entity.getContentLength();
-            FileOutputStream buffer = new FileOutputStream(getTargetFile());
-            if (instream != null) {
-                try {
-                    byte[] tmp = new byte[BUFFER_SIZE];
-                    int l, count = 0;
-                    // do not send messages if request has been cancelled
-                    while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                        count += l;
-                        buffer.write(tmp, 0, l);
-                        sendProgressMessage(count, (int) contentLength);
-                    }
-                } finally {
-                    AsyncHttpClient.silentCloseInputStream(instream);
-                    buffer.flush();
-                    AsyncHttpClient.silentCloseOutputStream(buffer);
-                }
-            }
-        }
-        return null;
-    }
-
-}
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
deleted file mode 100755
index ab10821d..00000000
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpStatus;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-/**
- * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
- * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
- * designed to be passed to get, post, put and delete requests with the {@link #onSuccess(int,
- * org.apache.http.Header[], org.json.JSONArray)} or {@link #onSuccess(int,
- * org.apache.http.Header[], org.json.JSONObject)} methods anonymously overridden. <p>&nbsp;</p>
- * Additionally, you can override the other event methods from the parent class.
- */
-public class JsonHttpResponseHandler extends TextHttpResponseHandler {
-    private static final String LOG_TAG = "JsonHttpResponseHandler";
-
-    /**
-     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
-     */
-    public JsonHttpResponseHandler() {
-        super(DEFAULT_CHARSET);
-    }
-
-    /**
-     * Creates new JsonHttpRespnseHandler with given Json String encoding
-     *
-     * @param encoding String encoding to be used when parsing JSON
-     */
-    public JsonHttpResponseHandler(String encoding) {
-        super(encoding);
-    }
-
-    /**
-     * Returns when request succeeds
-     *
-     * @param statusCode http response status line
-     * @param headers    response headers if any
-     * @param response   parsed response if any
-     */
-    public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-
-    }
-
-    /**
-     * Returns when request succeeds
-     *
-     * @param statusCode http response status line
-     * @param headers    response headers if any
-     * @param response   parsed response if any
-     */
-    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-
-    }
-
-    /**
-     * Returns when request failed
-     *
-     * @param statusCode    http response status line
-     * @param headers       response headers if any
-     * @param throwable     throwable describing the way request failed
-     * @param errorResponse parsed response if any
-     */
-    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
-
-    }
-
-    /**
-     * Returns when request failed
-     *
-     * @param statusCode    http response status line
-     * @param headers       response headers if any
-     * @param throwable     throwable describing the way request failed
-     * @param errorResponse parsed response if any
-     */
-    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
-
-    }
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
-
-    }
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, String responseString) {
-
-    }
-
-    @Override
-    public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
-        if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            Runnable parser = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        final Object jsonResponse = parseResponse(responseBytes);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                if (jsonResponse instanceof JSONObject) {
-                                    onSuccess(statusCode, headers, (JSONObject) jsonResponse);
-                                } else if (jsonResponse instanceof JSONArray) {
-                                    onSuccess(statusCode, headers, (JSONArray) jsonResponse);
-                                } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
-                                } else {
-                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
-                                }
-
-                            }
-                        });
-                    } catch (final JSONException ex) {
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onFailure(statusCode, headers, ex, (JSONObject) null);
-                            }
-                        });
-                    }
-                }
-            };
-            if (!getUseSynchronousMode())
-                new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
-                parser.run();
-        } else {
-            onSuccess(statusCode, headers, new JSONObject());
-        }
-    }
-
-    @Override
-    public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
-        if (responseBytes != null) {
-            Runnable parser = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        final Object jsonResponse = parseResponse(responseBytes);
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                if (jsonResponse instanceof JSONObject) {
-                                    onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
-                                } else if (jsonResponse instanceof JSONArray) {
-                                    onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
-                                } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
-                                } else {
-                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
-                                }
-                            }
-                        });
-
-                    } catch (final JSONException ex) {
-                        postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                onFailure(statusCode, headers, ex, (JSONObject) null);
-                            }
-                        });
-
-                    }
-                }
-            };
-            if (!getUseSynchronousMode())
-                new Thread(parser).start();
-            else // In synchronous mode everything should be run on one thread
-                parser.run();
-        } else {
-            Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
-            onFailure(statusCode, headers, throwable, (JSONObject) null);
-        }
-    }
-
-    /**
-     * Returns Object of type {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
-     * Double or {@link JSONObject#NULL}, see {@link org.json.JSONTokener#nextValue()}
-     *
-     * @param responseBody response bytes to be assembled in String and parsed as JSON
-     * @return Object parsedResponse
-     * @throws org.json.JSONException exception if thrown while parsing JSON
-     */
-    protected Object parseResponse(byte[] responseBody) throws JSONException {
-        if (null == responseBody)
-            return null;
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        String jsonString = getResponseString(responseBody, getCharset());
-        if (jsonString != null) {
-            jsonString = jsonString.trim();
-            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-                result = new JSONTokener(jsonString).nextValue();
-            }
-        }
-        if (result == null) {
-            result = jsonString;
-        }
-        return result;
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
deleted file mode 100755
index f033d4c0..00000000
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.zip.GZIPOutputStream;
-
-/**
- * HTTP entity to upload JSON data using streams. This has very low memory footprint; suitable for
- * uploading large files using base64 encoding.
- */
-public class JsonStreamerEntity implements HttpEntity {
-
-    private static final String LOG_TAG = "JsonStreamerEntity";
-
-    private static final UnsupportedOperationException ERR_UNSUPPORTED =
-            new UnsupportedOperationException("Unsupported operation in this implementation.");
-
-    // Size of the byte-array buffer used in I/O streams.
-    private static final int BUFFER_SIZE = 4096;
-
-    // Buffer used for reading from input streams.
-    private final byte[] buffer = new byte[BUFFER_SIZE];
-
-    // Reusable StringBuilder used by escape() method.
-    // Its size is just initial, if more space is needed, the system will
-    // automatically enlarge the buffer.
-    private static final StringBuilder BUILDER = new StringBuilder(128);
-
-    private static final byte[] JSON_TRUE = "true".getBytes();
-    private static final byte[] JSON_FALSE = "false".getBytes();
-    private static final byte[] JSON_NULL = "null".getBytes();
-    private static final byte[] STREAM_NAME = escape("name");
-    private static final byte[] STREAM_TYPE = escape("type");
-    private static final byte[] STREAM_CONTENTS = escape("contents");
-    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
-
-    private static final Header HEADER_JSON_CONTENT =
-            new BasicHeader("Content-Type", "application/json");
-    private static final Header HEADER_GZIP_ENCODING =
-            new BasicHeader("Content-Encoding", "gzip");
-
-    // JSON data and associated meta-data to be uploaded.
-    private final Map<String, Object> jsonParams = new HashMap<String, Object>();
-
-    // Whether to use gzip compression while uploading
-    private final Header contentEncoding;
-
-    private final ResponseHandlerInterface progressHandler;
-
-    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
-        this.progressHandler = progressHandler;
-        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
-    }
-
-    /**
-     * Add content parameter, identified by the given key, to the request.
-     *
-     * @param key   entity's name
-     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
-     */
-    public void addPart(String key, Object value) {
-        jsonParams.put(key, value);
-    }
-
-    @Override
-    public boolean isRepeatable() {
-        return false;
-    }
-
-    @Override
-    public boolean isChunked() {
-        return false;
-    }
-
-    @Override
-    public boolean isStreaming() {
-        return false;
-    }
-
-    @Override
-    public long getContentLength() {
-        return -1;
-    }
-
-    @Override
-    public Header getContentEncoding() {
-        return contentEncoding;
-    }
-
-    @Override
-    public Header getContentType() {
-        return HEADER_JSON_CONTENT;
-    }
-
-    @Override
-    public void consumeContent() throws IOException, UnsupportedOperationException {
-    }
-
-    @Override
-    public InputStream getContent() throws IOException, UnsupportedOperationException {
-        throw ERR_UNSUPPORTED;
-    }
-
-    @Override
-    public void writeTo(final OutputStream out) throws IOException {
-        if (out == null) {
-            throw new IllegalStateException("Output stream cannot be null.");
-        }
-
-        // Record the time when uploading started.
-        long now = System.currentTimeMillis();
-
-        // Use GZIP compression when sending streams, otherwise just use
-        // a buffered output stream to speed things up a bit.
-        OutputStream os = null != contentEncoding
-                ? new GZIPOutputStream(out, BUFFER_SIZE)
-                : out;
-
-        // Always send a JSON object.
-        os.write('{');
-
-        // Keys used by the HashMaps.
-        Set<String> keys = jsonParams.keySet();
-
-        boolean isFileWrapper;
-
-        // Go over all keys and handle each's value.
-        for (String key : keys) {
-            // Evaluate the value (which cannot be null).
-            Object value = jsonParams.get(key);
-
-            // Bail out prematurely if value's null.
-            if (value == null) {
-                continue;
-            }
-
-            // Write the JSON object's key.
-            os.write(escape(key));
-            os.write(':');
-
-            // Check if this is a FileWrapper.
-            isFileWrapper = value instanceof RequestParams.FileWrapper;
-
-            // If a file should be uploaded.
-            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
-                // All uploads are sent as an object containing the file's details.
-                os.write('{');
-
-                // Determine how to handle this entry.
-                if (isFileWrapper) {
-                    writeToFromFile(os, (RequestParams.FileWrapper) value);
-                } else {
-                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
-                }
-
-                // End the file's object and prepare for next one.
-                os.write('}');
-            } else if (value instanceof Boolean) {
-                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
-            } else if (value instanceof Long) {
-                os.write((((Number) value).longValue() + "").getBytes());
-            } else if (value instanceof Double) {
-                os.write((((Number) value).doubleValue() + "").getBytes());
-            } else if (value instanceof Float) {
-                os.write((((Number) value).floatValue() + "").getBytes());
-            } else if (value instanceof Integer) {
-                os.write((((Number) value).intValue() + "").getBytes());
-            } else {
-                os.write(value.toString().getBytes());
-            }
-
-            os.write(',');
-        }
-
-        // Include the elapsed time taken to upload everything.
-        // This might be useful for somebody, but it serves us well since
-        // there will almost always be a ',' as the last sent character.
-        os.write(STREAM_ELAPSED);
-        os.write(':');
-        long elapsedTime = System.currentTimeMillis() - now;
-        os.write((elapsedTime + "}").getBytes());
-
-        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
-
-        // Flush the contents up the stream.
-        os.flush();
-        AsyncHttpClient.silentCloseOutputStream(os);
-    }
-
-    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
-            throws IOException {
-
-        // Send the meta data.
-        writeMetaData(os, entry.name, entry.contentType);
-
-        int bytesRead;
-
-        // Upload the file's contents in Base64.
-        Base64OutputStream bos =
-                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-        // Read from input stream until no more data's left to read.
-        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
-            bos.write(buffer, 0, bytesRead);
-        }
-
-        // Close the Base64 output stream.
-        AsyncHttpClient.silentCloseOutputStream(bos);
-
-        // End the meta data.
-        endMetaData(os);
-
-        // Close input stream.
-        if (entry.autoClose) {
-            // Safely close the input stream.
-            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
-        }
-    }
-
-    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
-            throws IOException {
-
-        // Send the meta data.
-        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
-
-        int bytesRead, bytesWritten = 0, totalSize = (int) wrapper.file.length();
-
-        // Open the file for reading.
-        FileInputStream in = new FileInputStream(wrapper.file);
-
-        // Upload the file's contents in Base64.
-        Base64OutputStream bos =
-                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-        // Read from file until no more data's left to read.
-        while ((bytesRead = in.read(buffer)) != -1) {
-            bos.write(buffer, 0, bytesRead);
-            bytesWritten += bytesRead;
-            progressHandler.sendProgressMessage(bytesWritten, totalSize);
-        }
-
-        // Close the Base64 output stream.
-        AsyncHttpClient.silentCloseOutputStream(bos);
-
-        // End the meta data.
-        endMetaData(os);
-
-        // Safely close the input stream.
-        AsyncHttpClient.silentCloseInputStream(in);
-    }
-
-    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
-        // Send the streams's name.
-        os.write(STREAM_NAME);
-        os.write(':');
-        os.write(escape(name));
-        os.write(',');
-
-        // Send the streams's content type.
-        os.write(STREAM_TYPE);
-        os.write(':');
-        os.write(escape(contentType));
-        os.write(',');
-
-        // Prepare the file content's key.
-        os.write(STREAM_CONTENTS);
-        os.write(':');
-        os.write('"');
-    }
-
-    private void endMetaData(OutputStream os) throws IOException {
-        os.write('"');
-    }
-
-    // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
-    // Changed a bit to suit our needs in this class.
-    static byte[] escape(String string) {
-        // If it's null, just return prematurely.
-        if (string == null) {
-            return JSON_NULL;
-        }
-
-        // Surround with quotations.
-        BUILDER.append('"');
-
-        int length = string.length(), pos = -1;
-        while (++pos < length) {
-            char ch = string.charAt(pos);
-            switch (ch) {
-                case '"':
-                    BUILDER.append("\\\"");
-                    break;
-                case '\\':
-                    BUILDER.append("\\\\");
-                    break;
-                case '\b':
-                    BUILDER.append("\\b");
-                    break;
-                case '\f':
-                    BUILDER.append("\\f");
-                    break;
-                case '\n':
-                    BUILDER.append("\\n");
-                    break;
-                case '\r':
-                    BUILDER.append("\\r");
-                    break;
-                case '\t':
-                    BUILDER.append("\\t");
-                    break;
-                default:
-                    // Reference: http://www.unicode.org/versions/Unicode5.1.0/
-                    if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
-                        String intString = Integer.toHexString(ch);
-                        BUILDER.append("\\u");
-                        int intLength = 4 - intString.length();
-                        for (int zero = 0; zero < intLength; zero++) {
-                            BUILDER.append('0');
-                        }
-                        BUILDER.append(intString.toUpperCase(Locale.US));
-                    } else {
-                        BUILDER.append(ch);
-                    }
-                    break;
-            }
-        }
-
-        // Surround with quotations.
-        BUILDER.append('"');
-
-        try {
-            return BUILDER.toString().getBytes();
-        } finally {
-            // Empty the String buffer.
-            // This is 20-30% faster than instantiating a new object.
-            BUILDER.setLength(0);
-        }
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
deleted file mode 100644
index dfc45ec0..00000000
--- a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Aymon Fournier <aymon.fournier@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.Header;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.ProtocolException;
-import org.apache.http.client.CircularRedirectException;
-import org.apache.http.client.params.ClientPNames;
-import org.apache.http.client.utils.URIUtils;
-import org.apache.http.impl.client.DefaultRedirectHandler;
-import org.apache.http.impl.client.RedirectLocations;
-import org.apache.http.params.HttpParams;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-/**
- * Taken from StackOverflow
- *
- * @author Aymon Fournier, aymon.fournier@gmail.com
- * @see <a href="https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception">https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception</a>
- */
-class MyRedirectHandler extends DefaultRedirectHandler {
-
-    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
-    private final boolean enableRedirects;
-
-    public MyRedirectHandler(final boolean allowRedirects) {
-        super();
-        this.enableRedirects = allowRedirects;
-    }
-
-    @Override
-    public boolean isRedirectRequested(
-            final HttpResponse response,
-            final HttpContext context) {
-        if (!enableRedirects) {
-            return false;
-        }
-        if (response == null) {
-            throw new IllegalArgumentException("HTTP response may not be null");
-        }
-        int statusCode = response.getStatusLine().getStatusCode();
-        switch (statusCode) {
-            case HttpStatus.SC_MOVED_TEMPORARILY:
-            case HttpStatus.SC_MOVED_PERMANENTLY:
-            case HttpStatus.SC_SEE_OTHER:
-            case HttpStatus.SC_TEMPORARY_REDIRECT:
-                return true;
-            default:
-                return false;
-        } //end of switch
-    }
-
-    @Override
-    public URI getLocationURI(
-            final HttpResponse response,
-            final HttpContext context) throws ProtocolException {
-        if (response == null) {
-            throw new IllegalArgumentException("HTTP response may not be null");
-        }
-        //get the location header to find out where to redirect to
-        Header locationHeader = response.getFirstHeader("location");
-        if (locationHeader == null) {
-            // got a redirect response, but no location header
-            throw new ProtocolException(
-                    "Received redirect response " + response.getStatusLine()
-                            + " but no location header"
-            );
-        }
-        //HERE IS THE MODIFIED LINE OF CODE
-        String location = locationHeader.getValue().replaceAll(" ", "%20");
-
-        URI uri;
-        try {
-            uri = new URI(location);
-        } catch (URISyntaxException ex) {
-            throw new ProtocolException("Invalid redirect URI: " + location, ex);
-        }
-
-        HttpParams params = response.getParams();
-        // rfc2616 demands the location value be a complete URI
-        // Location       = "Location" ":" absoluteURI
-        if (!uri.isAbsolute()) {
-            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
-                throw new ProtocolException("Relative redirect location '"
-                        + uri + "' not allowed");
-            }
-            // Adjust location URI
-            HttpHost target = (HttpHost) context.getAttribute(
-                    ExecutionContext.HTTP_TARGET_HOST);
-            if (target == null) {
-                throw new IllegalStateException("Target host not available " +
-                        "in the HTTP context");
-            }
-
-            HttpRequest request = (HttpRequest) context.getAttribute(
-                    ExecutionContext.HTTP_REQUEST);
-
-            try {
-                URI requestURI = new URI(request.getRequestLine().getUri());
-                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
-                uri = URIUtils.resolve(absoluteRequestURI, uri);
-            } catch (URISyntaxException ex) {
-                throw new ProtocolException(ex.getMessage(), ex);
-            }
-        }
-
-        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
-
-            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
-                    REDIRECT_LOCATIONS);
-
-            if (redirectLocations == null) {
-                redirectLocations = new RedirectLocations();
-                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
-            }
-
-            URI redirectURI;
-            if (uri.getFragment() != null) {
-                try {
-                    HttpHost target = new HttpHost(
-                            uri.getHost(),
-                            uri.getPort(),
-                            uri.getScheme());
-                    redirectURI = URIUtils.rewriteURI(uri, target, true);
-                } catch (URISyntaxException ex) {
-                    throw new ProtocolException(ex.getMessage(), ex);
-                }
-            } else {
-                redirectURI = uri;
-            }
-
-            if (redirectLocations.contains(redirectURI)) {
-                throw new CircularRedirectException("Circular redirect to '" +
-                        redirectURI + "'");
-            } else {
-                redirectLocations.add(redirectURI);
-            }
-        }
-
-        return uri;
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
deleted file mode 100755
index 4808bcbf..00000000
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.HttpVersion;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.HTTP;
-
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Socket;
-import java.security.KeyManagementException;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.UnrecoverableKeyException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
- * http://code.google.com/p/android/issues/detail?id=13117#c14 <p>&nbsp;</p> Warning! This omits SSL
- * certificate validation on every device, use with caution
- */
-public class MySSLSocketFactory extends SSLSocketFactory {
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-
-    /**
-     * Creates a new SSL Socket Factory with the given KeyStore.
-     *
-     * @param truststore A KeyStore to create the SSL Socket Factory in context of
-     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
-     * @throws KeyManagementException    KeyManagementException
-     * @throws KeyStoreException         KeyStoreException
-     * @throws UnrecoverableKeyException UnrecoverableKeyException
-     */
-    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
-        super(truststore);
-
-        X509TrustManager tm = new X509TrustManager() {
-            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            }
-
-            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            }
-
-            public X509Certificate[] getAcceptedIssuers() {
-                return null;
-            }
-        };
-
-        sslContext.init(null, new TrustManager[]{tm}, null);
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
-        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return sslContext.getSocketFactory().createSocket();
-    }
-
-    /**
-     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
-     */
-    public void fixHttpsURLConnection() {
-        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
-    }
-
-    /**
-     * Gets a KeyStore containing the Certificate
-     *
-     * @param cert InputStream of the Certificate
-     * @return KeyStore
-     */
-    public static KeyStore getKeystoreOfCA(InputStream cert) {
-
-        // Load CAs from an InputStream
-        InputStream caInput = null;
-        Certificate ca = null;
-        try {
-            CertificateFactory cf = CertificateFactory.getInstance("X.509");
-            caInput = new BufferedInputStream(cert);
-            ca = cf.generateCertificate(caInput);
-        } catch (CertificateException e1) {
-            e1.printStackTrace();
-        } finally {
-            try {
-                if (caInput != null) {
-                    caInput.close();
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        // Create a KeyStore containing our trusted CAs
-        String keyStoreType = KeyStore.getDefaultType();
-        KeyStore keyStore = null;
-        try {
-            keyStore = KeyStore.getInstance(keyStoreType);
-            keyStore.load(null, null);
-            keyStore.setCertificateEntry("ca", ca);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        return keyStore;
-    }
-
-    /**
-     * Gets a Default KeyStore
-     *
-     * @return KeyStore
-     */
-    public static KeyStore getKeystore() {
-        KeyStore trustStore = null;
-        try {
-            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
-            trustStore.load(null, null);
-        } catch (Throwable t) {
-            t.printStackTrace();
-        }
-        return trustStore;
-    }
-
-    /**
-     * Returns a SSlSocketFactory which trusts all certificates
-     *
-     * @return SSLSocketFactory
-     */
-    public static SSLSocketFactory getFixedSocketFactory() {
-        SSLSocketFactory socketFactory;
-        try {
-            socketFactory = new MySSLSocketFactory(getKeystore());
-            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
-        } catch (Throwable t) {
-            t.printStackTrace();
-            socketFactory = SSLSocketFactory.getSocketFactory();
-        }
-        return socketFactory;
-    }
-
-    /**
-     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
-     *
-     * @param keyStore custom provided KeyStore instance
-     * @return DefaultHttpClient
-     */
-    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
-
-        try {
-            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
-            SchemeRegistry registry = new SchemeRegistry();
-            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-            registry.register(new Scheme("https", sf, 443));
-
-            HttpParams params = new BasicHttpParams();
-            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
-            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
-
-            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
-
-            return new DefaultHttpClient(ccm, params);
-        } catch (Exception e) {
-            return new DefaultHttpClient();
-        }
-    }
-
-}
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
deleted file mode 100755
index 0fefaf72..00000000
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.text.TextUtils;
-import android.util.Log;
-
-import org.apache.http.client.CookieStore;
-import org.apache.http.cookie.Cookie;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-
-import java.io.IOException;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * A persistent cookie store which implements the Apache HttpClient {@link CookieStore} interface.
- * Cookies are stored and will persist on the user's device between application sessions since they
- * are serialized and stored in {@link SharedPreferences}. <p>&nbsp;</p> Instances of this class are
- * designed to be used with {@link AsyncHttpClient#setCookieStore}, but can also be used with a
- * regular old apache HttpClient/HttpContext if you prefer.
- */
-public class PersistentCookieStore implements CookieStore {
-    private static final String LOG_TAG = "PersistentCookieStore";
-    private static final String COOKIE_PREFS = "CookiePrefsFile";
-    private static final String COOKIE_NAME_STORE = "names";
-    private static final String COOKIE_NAME_PREFIX = "cookie_";
-    private boolean omitNonPersistentCookies = false;
-
-    private final ConcurrentHashMap<String, Cookie> cookies;
-    private final SharedPreferences cookiePrefs;
-
-    /**
-     * Construct a persistent cookie store.
-     *
-     * @param context Context to attach cookie store to
-     */
-    public PersistentCookieStore(Context context) {
-        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
-
-        // Load any previously stored cookies into the store
-        String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if (storedCookieNames != null) {
-            String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for (String name : cookieNames) {
-                String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if (encodedCookie != null) {
-                    Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if (decodedCookie != null) {
-                        cookies.put(name, decodedCookie);
-                    }
-                }
-            }
-
-            // Clear out expired cookies
-            clearExpired(new Date());
-        }
-    }
-
-    @Override
-    public void addCookie(Cookie cookie) {
-        if (omitNonPersistentCookies && !cookie.isPersistent())
-            return;
-        String name = cookie.getName() + cookie.getDomain();
-
-        // Save cookie into local store, or remove if expired
-        if (!cookie.isExpired(new Date())) {
-            cookies.put(name, cookie);
-        } else {
-            cookies.remove(name);
-        }
-
-        // Save cookie into persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));
-        prefsWriter.commit();
-    }
-
-    @Override
-    public void clear() {
-        // Clear cookies from persistent store
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for (String name : cookies.keySet()) {
-            prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-        }
-        prefsWriter.remove(COOKIE_NAME_STORE);
-        prefsWriter.commit();
-
-        // Clear cookies from local store
-        cookies.clear();
-    }
-
-    @Override
-    public boolean clearExpired(Date date) {
-        boolean clearedAny = false;
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-
-        for (ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
-            String name = entry.getKey();
-            Cookie cookie = entry.getValue();
-            if (cookie.isExpired(date)) {
-                // Clear cookies from local store
-                cookies.remove(name);
-
-                // Clear cookies from persistent store
-                prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-
-                // We've cleared at least one
-                clearedAny = true;
-            }
-        }
-
-        // Update names in persistent store
-        if (clearedAny) {
-            prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
-        }
-        prefsWriter.commit();
-
-        return clearedAny;
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
-    }
-
-    /**
-     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
-     * signature (`Cookie.isPersistent`)
-     *
-     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
-     */
-    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
-        this.omitNonPersistentCookies = omitNonPersistentCookies;
-    }
-
-    /**
-     * Non-standard helper method, to delete cookie
-     *
-     * @param cookie cookie to be removed
-     */
-    public void deleteCookie(Cookie cookie) {
-        String name = cookie.getName() + cookie.getDomain();
-        cookies.remove(name);
-        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
-        prefsWriter.commit();
-    }
-
-    /**
-     * Serializes Cookie object into String
-     *
-     * @param cookie cookie to be encoded, can be null
-     * @return cookie encoded as String
-     */
-    protected String encodeCookie(SerializableCookie cookie) {
-        if (cookie == null)
-            return null;
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        try {
-            ObjectOutputStream outputStream = new ObjectOutputStream(os);
-            outputStream.writeObject(cookie);
-        } catch (IOException e) {
-            Log.d(LOG_TAG, "IOException in encodeCookie", e);
-            return null;
-        }
-
-        return byteArrayToHexString(os.toByteArray());
-    }
-
-    /**
-     * Returns cookie decoded from cookie string
-     *
-     * @param cookieString string of cookie as returned from http request
-     * @return decoded cookie or null if exception occured
-     */
-    protected Cookie decodeCookie(String cookieString) {
-        byte[] bytes = hexStringToByteArray(cookieString);
-        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
-        Cookie cookie = null;
-        try {
-            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
-            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
-        } catch (IOException e) {
-            Log.d(LOG_TAG, "IOException in decodeCookie", e);
-        } catch (ClassNotFoundException e) {
-            Log.d(LOG_TAG, "ClassNotFoundException in decodeCookie", e);
-        }
-
-        return cookie;
-    }
-
-    /**
-     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any
-     * large Base64 libraries. Can be overridden if you like!
-     *
-     * @param bytes byte array to be converted
-     * @return string containing hex values
-     */
-    protected String byteArrayToHexString(byte[] bytes) {
-        StringBuilder sb = new StringBuilder(bytes.length * 2);
-        for (byte element : bytes) {
-            int v = element & 0xff;
-            if (v < 16) {
-                sb.append('0');
-            }
-            sb.append(Integer.toHexString(v));
-        }
-        return sb.toString().toUpperCase(Locale.US);
-    }
-
-    /**
-     * Converts hex values from strings to byte arra
-     *
-     * @param hexString string of hex-encoded values
-     * @return decoded byte array
-     */
-    protected byte[] hexStringToByteArray(String hexString) {
-        int len = hexString.length();
-        byte[] data = new byte[len / 2];
-        for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
-        }
-        return data;
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
deleted file mode 100755
index 3f52da79..00000000
--- a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.HttpException;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.AuthState;
-import org.apache.http.auth.Credentials;
-import org.apache.http.client.CredentialsProvider;
-import org.apache.http.client.protocol.ClientContext;
-import org.apache.http.impl.auth.BasicScheme;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-
-import java.io.IOException;
-
-public class PreemtiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
-
-    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
-        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
-        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
-                ClientContext.CREDS_PROVIDER);
-        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
-
-        if (authState.getAuthScheme() == null) {
-            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
-            Credentials creds = credsProvider.getCredentials(authScope);
-            if (creds != null) {
-                authState.setAuthScheme(new BasicScheme());
-                authState.setCredentials(creds);
-            }
-        }
-    }
-
-}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
deleted file mode 100755
index f5e21fc8..00000000
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
-import org.apache.http.client.methods.HttpUriRequest;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-
-public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
-    private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
-
-    private long current = 0;
-    private boolean append = false;
-
-    /**
-     * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
-     *
-     * @param file File to store response within, must not be null
-     */
-    public RangeFileAsyncHttpResponseHandler(File file) {
-        super(file);
-    }
-
-    @Override
-    public void sendResponseMessage(HttpResponse response) throws IOException {
-        if (!Thread.currentThread().isInterrupted()) {
-            StatusLine status = response.getStatusLine();
-            if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
-                //already finished
-                if (!Thread.currentThread().isInterrupted())
-                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
-            } else if (status.getStatusCode() >= 300) {
-                if (!Thread.currentThread().isInterrupted())
-                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
-            } else {
-                if (!Thread.currentThread().isInterrupted()) {
-                    Header header = response.getFirstHeader("Content-Range");
-                    if (header == null) {
-                        append = false;
-                        current = 0;
-                    } else
-                        Log.v(LOG_TAG, "Content-Range: " + header.getValue());
-                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
-                }
-            }
-        }
-    }
-
-    @Override
-    protected byte[] getResponseData(HttpEntity entity) throws IOException {
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            long contentLength = entity.getContentLength() + current;
-            FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
-            if (instream != null) {
-                try {
-                    byte[] tmp = new byte[BUFFER_SIZE];
-                    int l;
-                    while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
-                        current += l;
-                        buffer.write(tmp, 0, l);
-                        sendProgressMessage((int) current, (int) contentLength);
-                    }
-                } finally {
-                    instream.close();
-                    buffer.flush();
-                    buffer.close();
-                }
-            }
-        }
-        return null;
-    }
-
-    public void updateRequestHeaders(HttpUriRequest uriRequest) {
-        if (mFile.exists() && mFile.canWrite())
-            current = mFile.length();
-        if (current > 0) {
-            append = true;
-            uriRequest.setHeader("Range", "bytes=" + current + "-");
-        }
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
deleted file mode 100755
index 290422a9..00000000
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2013 Jason Choy <jjwchoy@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import java.lang.ref.WeakReference;
-
-/**
- * A Handle to an AsyncRequest which can be used to cancel a running request.
- */
-public class RequestHandle {
-    private final WeakReference<AsyncHttpRequest> request;
-
-    public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference<AsyncHttpRequest>(request);
-    }
-
-    /**
-     * Attempts to cancel this request. This attempt will fail if the request has already completed,
-     * has already been cancelled, or could not be cancelled for some other reason. If successful,
-     * and this request has not started when cancel is called, this request should never run. If the
-     * request has already started, then the mayInterruptIfRunning parameter determines whether the
-     * thread executing this request should be interrupted in an attempt to stop the request.
-     * <p>&nbsp;</p> After this method returns, subsequent calls to isDone() will always return
-     * true. Subsequent calls to isCancelled() will always return true if this method returned
-     * true.
-     *
-     * @param mayInterruptIfRunning true if the thread executing this request should be interrupted;
-     *                              otherwise, in-progress requests are allowed to complete
-     * @return false if the request could not be cancelled, typically because it has already
-     * completed normally; true otherwise
-     */
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        AsyncHttpRequest _request = request.get();
-        return _request == null || _request.cancel(mayInterruptIfRunning);
-    }
-
-    /**
-     * Returns true if this task completed. Completion may be due to normal termination, an
-     * exception, or cancellation -- in all of these cases, this method will return true.
-     *
-     * @return true if this task completed
-     */
-    public boolean isFinished() {
-        AsyncHttpRequest _request = request.get();
-        return _request == null || _request.isDone();
-    }
-
-    /**
-     * Returns true if this task was cancelled before it completed normally.
-     *
-     * @return true if this task was cancelled before it completed
-     */
-    public boolean isCancelled() {
-        AsyncHttpRequest _request = request.get();
-        return _request == null || _request.isCancelled();
-    }
-
-    public boolean shouldBeGarbageCollected() {
-        boolean should = isCancelled() || isFinished();
-        if (should)
-            request.clear();
-        return should;
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
deleted file mode 100755
index b115bdc3..00000000
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ /dev/null
@@ -1,587 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-import org.apache.http.protocol.HTTP;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * A collection of string request parameters or files to send along with requests made from an
- * {@link AsyncHttpClient} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
- * <pre>
- * RequestParams params = new RequestParams();
- * params.put("username", "james");
- * params.put("password", "123456");
- * params.put("email", "my&#064;email.com");
- * params.put("profile_picture", new File("pic.jpg")); // Upload a File
- * params.put("profile_picture2", someInputStream); // Upload an InputStream
- * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- *
- * Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
- * map.put("first_name", "James");
- * map.put("last_name", "Smith");
- * params.put("user", map); // url params: "user[first_name]=James&amp;user[last_name]=Smith"
- *
- * Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // unordered collection
- * set.add("music");
- * set.add("art");
- * params.put("like", set); // url params: "like=music&amp;like=art"
- *
- * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
- * list.add("Java");
- * list.add("C");
- * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
- *
- * String[] colors = { "blue", "yellow" }; // Ordered collection
- * params.put("colors", colors); // url params: "colors[]=blue&amp;colors[]=yellow"
- *
- * List&lt;Map&lt;String, String&gt;&gt; listOfMaps = new ArrayList&lt;Map&lt;String,
- * String&gt;&gt;();
- * Map&lt;String, String&gt; user1 = new HashMap&lt;String, String&gt;();
- * user1.put("age", "30");
- * user1.put("gender", "male");
- * Map&lt;String, String&gt; user2 = new HashMap&lt;String, String&gt;();
- * user2.put("age", "25");
- * user2.put("gender", "female");
- * listOfMaps.add(user1);
- * listOfMaps.add(user2);
- * params.put("users", listOfMaps); // url params: "users[][age]=30&amp;users[][gender]=male&amp;users[][age]=25&amp;users[][gender]=female"
- *
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.post("http://myendpoint.com", params, responseHandler);
- * </pre>
- */
-public class RequestParams {
-
-    public final static String APPLICATION_OCTET_STREAM =
-            "application/octet-stream";
-
-    protected final static String LOG_TAG = "RequestParams";
-    protected boolean isRepeatable;
-    protected boolean useJsonStreamer;
-    protected boolean autoCloseInputStreams;
-    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
-    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
-    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
-    protected String contentEncoding = HTTP.UTF_8;
-
-    /**
-     * Sets content encoding for return value of {@link #getParamString()} and {@link
-     * #createFormEntity()} <p>&nbsp;</p> Default encoding is "UTF-8"
-     *
-     * @param encoding String constant from {@link org.apache.http.protocol.HTTP}
-     */
-    public void setContentEncoding(final String encoding) {
-        if (encoding != null)
-            this.contentEncoding = encoding;
-        else
-            Log.d(LOG_TAG, "setContentEncoding called with null attribute");
-    }
-
-    /**
-     * Constructs a new empty {@code RequestParams} instance.
-     */
-    public RequestParams() {
-        this((Map<String, String>) null);
-    }
-
-    /**
-     * Constructs a new RequestParams instance containing the key/value string params from the
-     * specified map.
-     *
-     * @param source the source key/value string map to add.
-     */
-    public RequestParams(Map<String, String> source) {
-        if (source != null) {
-            for (Map.Entry<String, String> entry : source.entrySet()) {
-                put(entry.getKey(), entry.getValue());
-            }
-        }
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with a single initial key/value
-     * string param.
-     *
-     * @param key   the key name for the intial param.
-     * @param value the value string for the initial param.
-     */
-    public RequestParams(final String key, final String value) {
-        this(new HashMap<String, String>() {{
-            put(key, value);
-        }});
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with multiple initial key/value
-     * string param.
-     *
-     * @param keysAndValues a sequence of keys and values. Objects are automatically converted to
-     *                      Strings (including the value {@code null}).
-     * @throws IllegalArgumentException if the number of arguments isn't even.
-     */
-    public RequestParams(Object... keysAndValues) {
-        int len = keysAndValues.length;
-        if (len % 2 != 0)
-            throw new IllegalArgumentException("Supplied arguments must be even");
-        for (int i = 0; i < len; i += 2) {
-            String key = String.valueOf(keysAndValues[i]);
-            String val = String.valueOf(keysAndValues[i + 1]);
-            put(key, val);
-        }
-    }
-
-    /**
-     * Adds a key/value string pair to the request.
-     *
-     * @param key   the key name for the new param.
-     * @param value the value string for the new param.
-     */
-    public void put(String key, String value) {
-        if (key != null && value != null) {
-            urlParams.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a file to the request.
-     *
-     * @param key  the key name for the new param.
-     * @param file the file to add.
-     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
-     */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, file, null);
-    }
-
-    /**
-     * Adds a file to the request.
-     *
-     * @param key         the key name for the new param.
-     * @param file        the file to add.
-     * @param contentType the content type of the file, eg. application/json
-     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
-     */
-    public void put(String key, File file, String contentType) throws FileNotFoundException {
-        if (file == null || !file.exists()) {
-            throw new FileNotFoundException();
-        }
-        if (key != null) {
-            fileParams.put(key, new FileWrapper(file, contentType));
-        }
-    }
-
-    /**
-     * Adds an input stream to the request.
-     *
-     * @param key    the key name for the new param.
-     * @param stream the input stream to add.
-     */
-    public void put(String key, InputStream stream) {
-        put(key, stream, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     *
-     * @param key    the key name for the new param.
-     * @param stream the input stream to add.
-     * @param name   the name of the stream.
-     */
-    public void put(String key, InputStream stream, String name) {
-        put(key, stream, name, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     *
-     * @param key         the key name for the new param.
-     * @param stream      the input stream to add.
-     * @param name        the name of the stream.
-     * @param contentType the content type of the file, eg. application/json
-     */
-    public void put(String key, InputStream stream, String name, String contentType) {
-        put(key, stream, name, contentType, autoCloseInputStreams);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     *
-     * @param key         the key name for the new param.
-     * @param stream      the input stream to add.
-     * @param name        the name of the stream.
-     * @param contentType the content type of the file, eg. application/json
-     * @param autoClose   close input stream automatically on successful upload
-     */
-    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
-        if (key != null && stream != null) {
-            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
-        }
-    }
-
-    /**
-     * Adds param with non-string value (e.g. Map, List, Set).
-     *
-     * @param key   the key name for the new param.
-     * @param value the non-string value object for the new param.
-     */
-    public void put(String key, Object value) {
-        if (key != null && value != null) {
-            urlParamsWithObjects.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a int value to the request.
-     *
-     * @param key   the key name for the new param.
-     * @param value the value int for the new param.
-     */
-    public void put(String key, int value) {
-        if (key != null) {
-            urlParams.put(key, String.valueOf(value));
-        }
-    }
-
-    /**
-     * Adds a long value to the request.
-     *
-     * @param key   the key name for the new param.
-     * @param value the value long for the new param.
-     */
-    public void put(String key, long value) {
-        if (key != null) {
-            urlParams.put(key, String.valueOf(value));
-        }
-    }
-
-    /**
-     * Adds string value to param which can have more than one value.
-     *
-     * @param key   the key name for the param, either existing or new.
-     * @param value the value string for the new param.
-     */
-    public void add(String key, String value) {
-        if (key != null && value != null) {
-            Object params = urlParamsWithObjects.get(key);
-            if (params == null) {
-                // Backward compatible, which will result in "k=v1&k=v2&k=v3"
-                params = new HashSet<String>();
-                this.put(key, params);
-            }
-            if (params instanceof List) {
-                ((List<Object>) params).add(value);
-            } else if (params instanceof Set) {
-                ((Set<Object>) params).add(value);
-            }
-        }
-    }
-
-    /**
-     * Removes a parameter from the request.
-     *
-     * @param key the key name for the parameter to remove.
-     */
-    public void remove(String key) {
-        urlParams.remove(key);
-        streamParams.remove(key);
-        fileParams.remove(key);
-        urlParamsWithObjects.remove(key);
-    }
-
-    /**
-     * Check if a parameter is defined.
-     *
-     * @param key the key name for the parameter to check existence.
-     * @return Boolean
-     */
-    public boolean has(String key) {
-        return urlParams.get(key) != null ||
-                streamParams.get(key) != null ||
-                fileParams.get(key) != null ||
-                urlParamsWithObjects.get(key) != null;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if (result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append(entry.getValue());
-        }
-
-        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
-            if (result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("STREAM");
-        }
-
-        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if (result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("FILE");
-        }
-
-        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
-        for (BasicNameValuePair kv : params) {
-            if (result.length() > 0)
-                result.append("&");
-
-            result.append(kv.getName());
-            result.append("=");
-            result.append(kv.getValue());
-        }
-
-        return result.toString();
-    }
-
-    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
-        this.isRepeatable = isRepeatable;
-    }
-
-    public void setUseJsonStreamer(boolean useJsonStreamer) {
-        this.useJsonStreamer = useJsonStreamer;
-    }
-
-    /**
-     * Set global flag which determines whether to automatically close input streams on successful
-     * upload.
-     *
-     * @param flag boolean whether to automatically close input streams
-     */
-    public void setAutoCloseInputStreams(boolean flag) {
-        autoCloseInputStreams = flag;
-    }
-
-    /**
-     * Returns an HttpEntity containing all request parameters.
-     *
-     * @param progressHandler HttpResponseHandler for reporting progress on entity submit
-     * @return HttpEntity resulting HttpEntity to be included along with {@link
-     * org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
-     * @throws IOException if one of the streams cannot be read
-     */
-    public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        if (useJsonStreamer) {
-            return createJsonStreamerEntity(progressHandler);
-        } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
-            return createFormEntity();
-        } else {
-            return createMultipartEntity(progressHandler);
-        }
-    }
-
-    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
-                !fileParams.isEmpty() || !streamParams.isEmpty());
-
-        // Add string params
-        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
-        }
-
-        // Add non-string params
-        for (ConcurrentHashMap.Entry<String, Object> entry : urlParamsWithObjects.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
-        }
-
-        // Add file params
-        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
-        }
-
-        // Add stream params
-        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
-            StreamWrapper stream = entry.getValue();
-            if (stream.inputStream != null) {
-                entity.addPart(entry.getKey(),
-                        StreamWrapper.newInstance(
-                                stream.inputStream,
-                                stream.name,
-                                stream.contentType,
-                                stream.autoClose)
-                );
-            }
-        }
-
-        return entity;
-    }
-
-    private HttpEntity createFormEntity() {
-        try {
-            return new UrlEncodedFormEntity(getParamsList(), contentEncoding);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, "createFormEntity failed", e);
-            return null; // Can happen, if the 'contentEncoding' won't be HTTP.UTF_8
-        }
-    }
-
-    private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
-        entity.setIsRepeatable(isRepeatable);
-
-        // Add string params
-        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            entity.addPartWithCharset(entry.getKey(), entry.getValue(), contentEncoding);
-        }
-
-        // Add non-string params
-        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
-        for (BasicNameValuePair kv : params) {
-            entity.addPartWithCharset(kv.getName(), kv.getValue(), contentEncoding);
-        }
-
-        // Add stream params
-        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
-            StreamWrapper stream = entry.getValue();
-            if (stream.inputStream != null) {
-                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
-                        stream.contentType);
-            }
-        }
-
-        // Add file params
-        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
-        }
-
-        return entity;
-    }
-
-    protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
-
-        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        lparams.addAll(getParamsList(null, urlParamsWithObjects));
-
-        return lparams;
-    }
-
-    private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
-        if (value instanceof Map) {
-            Map map = (Map) value;
-            List list = new ArrayList<Object>(map.keySet());
-            // Ensure consistent ordering in query string
-            if (list.size() > 0 && list.get(0) instanceof Comparable) {
-                Collections.sort(list);
-            }
-            for (Object nestedKey : list) {
-                if (nestedKey instanceof String) {
-                    Object nestedValue = map.get(nestedKey);
-                    if (nestedValue != null) {
-                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
-                                nestedValue));
-                    }
-                }
-            }
-        } else if (value instanceof List) {
-            List list = (List) value;
-            int listSize = list.size();
-            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
-                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
-            }
-        } else if (value instanceof Object[]) {
-            Object[] array = (Object[]) value;
-            int arrayLength = array.length;
-            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
-                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
-            }
-        } else if (value instanceof Set) {
-            Set set = (Set) value;
-            for (Object nestedValue : set) {
-                params.addAll(getParamsList(key, nestedValue));
-            }
-        } else {
-            params.add(new BasicNameValuePair(key, value.toString()));
-        }
-        return params;
-    }
-
-    protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), contentEncoding);
-    }
-
-    public static class FileWrapper {
-        public final File file;
-        public final String contentType;
-
-        public FileWrapper(File file, String contentType) {
-            this.file = file;
-            this.contentType = contentType;
-        }
-    }
-
-    public static class StreamWrapper {
-        public final InputStream inputStream;
-        public final String name;
-        public final String contentType;
-        public final boolean autoClose;
-
-        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
-            this.inputStream = inputStream;
-            this.name = name;
-            this.contentType = contentType;
-            this.autoClose = autoClose;
-        }
-
-        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
-            return new StreamWrapper(
-                    inputStream,
-                    name,
-                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
-                    autoClose);
-        }
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
deleted file mode 100755
index 23a185d0..00000000
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2013 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-
-import java.io.IOException;
-import java.net.URI;
-
-/**
- * Interface to standardize implementations
- */
-public interface ResponseHandlerInterface {
-
-    /**
-     * Returns data whether request completed successfully
-     *
-     * @param response HttpResponse object with data
-     * @throws java.io.IOException if retrieving data from response fails
-     */
-    void sendResponseMessage(HttpResponse response) throws IOException;
-
-    /**
-     * Notifies callback, that request started execution
-     */
-    void sendStartMessage();
-
-    /**
-     * Notifies callback, that request was completed and is being removed from thread pool
-     */
-    void sendFinishMessage();
-
-    /**
-     * Notifies callback, that request (mainly uploading) has progressed
-     *
-     * @param bytesWritten number of written bytes
-     * @param bytesTotal   number of total bytes to be written
-     */
-    void sendProgressMessage(int bytesWritten, int bytesTotal);
-
-    /**
-     * Notifies callback, that request was cancelled
-     */
-    void sendCancelMessage();
-
-    /**
-     * Notifies callback, that request was handled successfully
-     *
-     * @param statusCode   HTTP status code
-     * @param headers      returned headers
-     * @param responseBody returned data
-     */
-    void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody);
-
-    /**
-     * Returns if request was completed with error code or failure of implementation
-     *
-     * @param statusCode   returned HTTP status code
-     * @param headers      returned headers
-     * @param responseBody returned data
-     * @param error        cause of request failure
-     */
-    void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
-
-    /**
-     * Notifies callback of retrying request
-     *
-     * @param retryNo number of retry within one request
-     */
-    void sendRetryMessage(int retryNo);
-
-    /**
-     * Returns URI which was used to request
-     *
-     * @return uri of origin request
-     */
-    public URI getRequestURI();
-
-    /**
-     * Returns Header[] which were used to request
-     *
-     * @return headers from origin request
-     */
-    public Header[] getRequestHeaders();
-
-    /**
-     * Helper for handlers to receive Request URI info
-     *
-     * @param requestURI claimed request URI
-     */
-    public void setRequestURI(URI requestURI);
-
-    /**
-     * Helper for handlers to receive Request Header[] info
-     *
-     * @param requestHeaders Headers, claimed to be from original request
-     */
-    public void setRequestHeaders(Header[] requestHeaders);
-
-    /**
-     * Can set, whether the handler should be asynchronous or synchronous
-     *
-     * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
-     */
-    void setUseSynchronousMode(boolean useSynchronousMode);
-
-    /**
-     * Returns whether the handler is asynchronous or synchronous
-     *
-     * @return boolean if the ResponseHandler is running in synchronous mode
-     */
-    boolean getUseSynchronousMode();
-}
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
deleted file mode 100755
index 3b6ad196..00000000
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-/*
-    Some of the retry logic in this class is heavily borrowed from the
-    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
-*/
-
-package com.loopj.android.http;
-
-import android.os.SystemClock;
-
-import org.apache.http.NoHttpResponseException;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.util.HashSet;
-
-import javax.net.ssl.SSLException;
-
-class RetryHandler implements HttpRequestRetryHandler {
-    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
-
-    static {
-        // Retry if the server dropped connection on us
-        exceptionWhitelist.add(NoHttpResponseException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(UnknownHostException.class);
-        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
-        exceptionWhitelist.add(SocketException.class);
-
-        // never retry timeouts
-        exceptionBlacklist.add(InterruptedIOException.class);
-        // never retry SSL handshake failures
-        exceptionBlacklist.add(SSLException.class);
-    }
-
-    private final int maxRetries;
-    private final int retrySleepTimeMS;
-
-    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
-        this.maxRetries = maxRetries;
-        this.retrySleepTimeMS = retrySleepTimeMS;
-    }
-
-    @Override
-    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-        boolean retry = true;
-
-        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b);
-
-        if (executionCount > maxRetries) {
-            // Do not retry if over max retry count
-            retry = false;
-        } else if (isInList(exceptionWhitelist, exception)) {
-            // immediately retry if error is whitelisted
-            retry = true;
-        } else if (isInList(exceptionBlacklist, exception)) {
-            // immediately cancel retry if the error is blacklisted
-            retry = false;
-        } else if (!sent) {
-            // for most other errors, retry only if request hasn't been fully sent yet
-            retry = true;
-        }
-
-        if (retry) {
-            // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
-            if (currentReq == null) {
-                return false;
-            }
-        }
-
-        if (retry) {
-            SystemClock.sleep(retrySleepTimeMS);
-        } else {
-            exception.printStackTrace();
-        }
-
-        return retry;
-    }
-
-    static void addClassToWhitelist(Class<?> cls) {
-        exceptionWhitelist.add(cls);
-    }
-
-    static void addClassToBlacklist(Class<?> cls) {
-        exceptionBlacklist.add(cls);
-    }
-
-    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-        for (Class<?> aList : list) {
-            if (aList.isInstance(error)) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
deleted file mode 100644
index f4663b7b..00000000
--- a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.DefaultHandler;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-
-/**
- * Provides interface to deserialize SAX responses, using AsyncHttpResponseHandler. Can be used like
- * this
- *
- * <pre>
- *     AsyncHttpClient ahc = new AsyncHttpClient();
- *     FontHandler handlerInstance = ... ; // init handler instance
- *     ahc.post("https://server.tld/api/call", new SaxAsyncHttpResponseHandler<FontHandler>(handlerInstance){
- *         &#064;Override
- *         public void onSuccess(int statusCode, Header[] headers, FontHandler t) {
- *              // Request got HTTP success statusCode
- *         }
- *         &#064;Override
- *         public void onFailure(int statusCode, Header[] headers, FontHandler t){
- *              // Request got HTTP fail statusCode
- *         }
- *     });
- * <pre/>
- *
- * @param <T> Handler extending {@link org.xml.sax.helpers.DefaultHandler}
- * @see org.xml.sax.helpers.DefaultHandler
- * @see com.loopj.android.http.AsyncHttpResponseHandler
- */
-public abstract class SaxAsyncHttpResponseHandler<T extends DefaultHandler> extends AsyncHttpResponseHandler {
-
-    /**
-     * Generic Type of handler
-     */
-    private T handler = null;
-    private final static String LOG_TAG = "SaxAsyncHttpResponseHandler";
-
-    /**
-     * Constructs new SaxAsyncHttpResponseHandler with given handler instance
-     *
-     * @param t instance of Handler extending DefaultHandler
-     * @see org.xml.sax.helpers.DefaultHandler
-     */
-    public SaxAsyncHttpResponseHandler(T t) {
-        super();
-        if (t == null) {
-            throw new Error("null instance of <T extends DefaultHandler> passed to constructor");
-        }
-        this.handler = t;
-    }
-
-    /**
-     * Deconstructs response into given content handler
-     *
-     * @param entity returned HttpEntity
-     * @return deconstructed response
-     * @throws java.io.IOException
-     * @see org.apache.http.HttpEntity
-     */
-    @Override
-    protected byte[] getResponseData(HttpEntity entity) throws IOException {
-        if (entity != null) {
-            InputStream instream = entity.getContent();
-            InputStreamReader inputStreamReader = null;
-            if (instream != null) {
-                try {
-                    SAXParserFactory sfactory = SAXParserFactory.newInstance();
-                    SAXParser sparser = sfactory.newSAXParser();
-                    XMLReader rssReader = sparser.getXMLReader();
-                    rssReader.setContentHandler(handler);
-                    inputStreamReader = new InputStreamReader(instream, DEFAULT_CHARSET);
-                    rssReader.parse(new InputSource(inputStreamReader));
-                } catch (SAXException e) {
-                    Log.e(LOG_TAG, "getResponseData exception", e);
-                } catch (ParserConfigurationException e) {
-                    Log.e(LOG_TAG, "getResponseData exception", e);
-                } finally {
-                    AsyncHttpClient.silentCloseInputStream(instream);
-                    if (inputStreamReader != null) {
-                        try {
-                            inputStreamReader.close();
-                        } catch (IOException e) { /*ignore*/ }
-                    }
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Default onSuccess method for this AsyncHttpResponseHandler to override
-     *
-     * @param statusCode returned HTTP status code
-     * @param headers    returned HTTP headers
-     * @param t          instance of Handler extending DefaultHandler
-     */
-    public abstract void onSuccess(int statusCode, Header[] headers, T t);
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        onSuccess(statusCode, headers, handler);
-    }
-
-    /**
-     * Default onFailure method for this AsyncHttpResponseHandler to override
-     *
-     * @param statusCode returned HTTP status code
-     * @param headers    returned HTTP headers
-     * @param t          instance of Handler extending DefaultHandler
-     */
-    public abstract void onFailure(int statusCode, Header[] headers, T t);
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers,
-                          byte[] responseBody, Throwable error) {
-        onSuccess(statusCode, headers, handler);
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
deleted file mode 100755
index 855105b1..00000000
--- a/library/src/main/java/com/loopj/android/http/SerializableCookie.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.apache.http.cookie.Cookie;
-import org.apache.http.impl.cookie.BasicClientCookie;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.Date;
-
-/**
- * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie} designed for use in {@link
- * PersistentCookieStore}.
- */
-public class SerializableCookie implements Serializable {
-    private static final long serialVersionUID = 6374381828722046732L;
-
-    private transient final Cookie cookie;
-    private transient BasicClientCookie clientCookie;
-
-    public SerializableCookie(Cookie cookie) {
-        this.cookie = cookie;
-    }
-
-    public Cookie getCookie() {
-        Cookie bestCookie = cookie;
-        if (clientCookie != null) {
-            bestCookie = clientCookie;
-        }
-        return bestCookie;
-    }
-
-    private void writeObject(ObjectOutputStream out) throws IOException {
-        out.writeObject(cookie.getName());
-        out.writeObject(cookie.getValue());
-        out.writeObject(cookie.getComment());
-        out.writeObject(cookie.getDomain());
-        out.writeObject(cookie.getExpiryDate());
-        out.writeObject(cookie.getPath());
-        out.writeInt(cookie.getVersion());
-        out.writeBoolean(cookie.isSecure());
-    }
-
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String) in.readObject();
-        String value = (String) in.readObject();
-        clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String) in.readObject());
-        clientCookie.setDomain((String) in.readObject());
-        clientCookie.setExpiryDate((Date) in.readObject());
-        clientCookie.setPath((String) in.readObject());
-        clientCookie.setVersion(in.readInt());
-        clientCookie.setSecure(in.readBoolean());
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
deleted file mode 100755
index baca2281..00000000
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-/*
-    This code is taken from Rafael Sanches' blog.
-    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-import org.apache.http.protocol.HTTP;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-
-/**
- * Simplified multipart entity mainly used for sending one or more files.
- */
-class SimpleMultipartEntity implements HttpEntity {
-
-    private static final String LOG_TAG = "SimpleMultipartEntity";
-
-    private static final String STR_CR_LF = "\r\n";
-    private static final byte[] CR_LF = STR_CR_LF.getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY =
-            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
-
-    private final static char[] MULTIPART_CHARS =
-            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
-
-    private final String boundary;
-    private final byte[] boundaryLine;
-    private final byte[] boundaryEnd;
-    private boolean isRepeatable;
-
-    private final List<FilePart> fileParts = new ArrayList<FilePart>();
-
-    // The buffer we use for building the message excluding files and the last
-    // boundary
-    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    private final ResponseHandlerInterface progressHandler;
-
-    private int bytesWritten;
-
-    private int totalSize;
-
-    public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
-        final StringBuilder buf = new StringBuilder();
-        final Random rand = new Random();
-        for (int i = 0; i < 30; i++) {
-            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
-        }
-
-        boundary = buf.toString();
-        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
-        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
-
-        this.progressHandler = progressHandler;
-    }
-
-    public void addPart(String key, String value, String contentType) {
-        try {
-            out.write(boundaryLine);
-            out.write(createContentDisposition(key));
-            out.write(createContentType(contentType));
-            out.write(CR_LF);
-            out.write(value.getBytes());
-            out.write(CR_LF);
-        } catch (final IOException e) {
-            // Shall not happen on ByteArrayOutputStream
-            Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
-        }
-    }
-
-    public void addPartWithCharset(String key, String value, String charset) {
-        if (charset == null) charset = HTTP.UTF_8;
-        addPart(key, value, "text/plain; charset=" + charset);
-    }
-
-    public void addPart(String key, String value) {
-        addPartWithCharset(key, value, null);
-    }
-
-    public void addPart(String key, File file) {
-        addPart(key, file, null);
-    }
-
-    public void addPart(String key, File file, String type) {
-        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
-    }
-
-    public void addPart(String key, String streamName, InputStream inputStream, String type)
-            throws IOException {
-
-        out.write(boundaryLine);
-
-        // Headers
-        out.write(createContentDisposition(key, streamName));
-        out.write(createContentType(type));
-        out.write(TRANSFER_ENCODING_BINARY);
-        out.write(CR_LF);
-
-        // Stream (file)
-        final byte[] tmp = new byte[4096];
-        int l;
-        while ((l = inputStream.read(tmp)) != -1) {
-            out.write(tmp, 0, l);
-        }
-
-        out.write(CR_LF);
-        out.flush();
-
-        AsyncHttpClient.silentCloseOutputStream(out);
-    }
-
-    private String normalizeContentType(String type) {
-        return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
-    }
-
-    private byte[] createContentType(String type) {
-        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
-        return result.getBytes();
-    }
-
-    private byte[] createContentDisposition(String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
-                .getBytes();
-    }
-
-    private byte[] createContentDisposition(String key, String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
-                .getBytes();
-    }
-
-    private void updateProgress(int count) {
-        bytesWritten += count;
-        progressHandler.sendProgressMessage(bytesWritten, totalSize);
-    }
-
-    private class FilePart {
-        public File file;
-        public byte[] header;
-
-        public FilePart(String key, File file, String type) {
-            header = createHeader(key, file.getName(), type);
-            this.file = file;
-        }
-
-        private byte[] createHeader(String key, String filename, String type) {
-            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
-            try {
-                headerStream.write(boundaryLine);
-
-                // Headers
-                headerStream.write(createContentDisposition(key, filename));
-                headerStream.write(createContentType(type));
-                headerStream.write(TRANSFER_ENCODING_BINARY);
-                headerStream.write(CR_LF);
-            } catch (IOException e) {
-                // Can't happen on ByteArrayOutputStream
-                Log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
-            }
-            return headerStream.toByteArray();
-        }
-
-        public long getTotalLength() {
-            long streamLength = file.length() + CR_LF.length;
-            return header.length + streamLength;
-        }
-
-        public void writeTo(OutputStream out) throws IOException {
-            out.write(header);
-            updateProgress(header.length);
-
-            FileInputStream inputStream = new FileInputStream(file);
-            final byte[] tmp = new byte[4096];
-            int bytesRead;
-            while ((bytesRead = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, bytesRead);
-                updateProgress(bytesRead);
-            }
-            out.write(CR_LF);
-            updateProgress(CR_LF.length);
-            out.flush();
-            AsyncHttpClient.silentCloseInputStream(inputStream);
-        }
-    }
-
-    // The following methods are from the HttpEntity interface
-
-    @Override
-    public long getContentLength() {
-        long contentLen = out.size();
-        for (FilePart filePart : fileParts) {
-            long len = filePart.getTotalLength();
-            if (len < 0) {
-                return -1; // Should normally not happen
-            }
-            contentLen += len;
-        }
-        contentLen += boundaryEnd.length;
-        return contentLen;
-    }
-
-    @Override
-    public Header getContentType() {
-        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
-    }
-
-    @Override
-    public boolean isChunked() {
-        return false;
-    }
-
-    public void setIsRepeatable(boolean isRepeatable) {
-        this.isRepeatable = isRepeatable;
-    }
-
-    @Override
-    public boolean isRepeatable() {
-        return isRepeatable;
-    }
-
-    @Override
-    public boolean isStreaming() {
-        return false;
-    }
-
-    @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        bytesWritten = 0;
-        totalSize = (int) getContentLength();
-        out.writeTo(outstream);
-        updateProgress(out.size());
-
-        for (FilePart filePart : fileParts) {
-            filePart.writeTo(outstream);
-        }
-        outstream.write(boundaryEnd);
-        updateProgress(boundaryEnd.length);
-    }
-
-    @Override
-    public Header getContentEncoding() {
-        return null;
-    }
-
-    @Override
-    public void consumeContent() throws IOException, UnsupportedOperationException {
-        if (isStreaming()) {
-            throw new UnsupportedOperationException(
-                    "Streaming entity does not implement #consumeContent()");
-        }
-    }
-
-    @Override
-    public InputStream getContent() throws IOException, UnsupportedOperationException {
-        throw new UnsupportedOperationException(
-                "getContent() is not supported. Use writeTo() instead.");
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
deleted file mode 100755
index 89591461..00000000
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-package com.loopj.android.http;
-
-import android.content.Context;
-
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-/**
- * Processes http requests in synchronous mode, so your caller thread will be blocked on each
- * request
- *
- * @see com.loopj.android.http.AsyncHttpClient
- */
-public class SyncHttpClient extends AsyncHttpClient {
-
-    /**
-     * Creates a new SyncHttpClient with default constructor arguments values
-     */
-    public SyncHttpClient() {
-        super(false, 80, 443);
-    }
-
-    /**
-     * Creates a new SyncHttpClient.
-     *
-     * @param httpPort non-standard HTTP-only port
-     */
-    public SyncHttpClient(int httpPort) {
-        super(false, httpPort, 443);
-    }
-
-    /**
-     * Creates a new SyncHttpClient.
-     *
-     * @param httpPort  non-standard HTTP-only port
-     * @param httpsPort non-standard HTTPS-only port
-     */
-    public SyncHttpClient(int httpPort, int httpsPort) {
-        super(false, httpPort, httpsPort);
-    }
-
-    /**
-     * Creates new SyncHttpClient using given params
-     *
-     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
-     * @param httpPort                   HTTP port to be used, must be greater than 0
-     * @param httpsPort                  HTTPS port to be used, must be greater than 0
-     */
-    public SyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
-        super(fixNoHttpResponseException, httpPort, httpsPort);
-    }
-
-    /**
-     * Creates a new SyncHttpClient.
-     *
-     * @param schemeRegistry SchemeRegistry to be used
-     */
-    public SyncHttpClient(SchemeRegistry schemeRegistry) {
-        super(schemeRegistry);
-    }
-
-    @Override
-    protected RequestHandle sendRequest(DefaultHttpClient client,
-                                        HttpContext httpContext, HttpUriRequest uriRequest,
-                                        String contentType, ResponseHandlerInterface responseHandler,
-                                        Context context) {
-        if (contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        responseHandler.setUseSynchronousMode(true);
-
-		/*
-         * will execute the request directly
-		*/
-        newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context).run();
-
-        // Return a Request Handle that cannot be used to cancel the request
-        // because it is already complete by the time this returns
-        return new RequestHandle(null);
-    }
-}
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
deleted file mode 100755
index 1c354a6c..00000000
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import android.util.Log;
-
-import org.apache.http.Header;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
- * {@link #onSuccess(int, org.apache.http.Header[], String)} method is designed to be anonymously
- * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
- * {@link #onFailure(int, org.apache.http.Header[], String, Throwable)}, {@link #onStart()}, and
- * {@link #onFinish()} methods as required. <p>&nbsp;</p> For example: <p>&nbsp;</p>
- * <pre>
- * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new TextHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String responseBody) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(String responseBody, Throwable e) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
- * });
- * </pre>
- */
-public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
-    private static final String LOG_TAG = "TextHttpResponseHandler";
-
-    /**
-     * Creates new instance with default UTF-8 encoding
-     */
-    public TextHttpResponseHandler() {
-        this(DEFAULT_CHARSET);
-    }
-
-    /**
-     * Creates new instance with given string encoding
-     *
-     * @param encoding String encoding, see {@link #setCharset(String)}
-     */
-    public TextHttpResponseHandler(String encoding) {
-        super();
-        setCharset(encoding);
-    }
-
-    /**
-     * Called when request fails
-     *
-     * @param statusCode     http response status line
-     * @param headers        response headers if any
-     * @param responseString string response of given charset
-     * @param throwable      throwable returned when processing request
-     */
-    public abstract void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable);
-
-    /**
-     * Called when request succeeds
-     *
-     * @param statusCode     http response status line
-     * @param headers        response headers if any
-     * @param responseString string response of given charset
-     */
-    public abstract void onSuccess(int statusCode, Header[] headers, String responseString);
-
-    @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
-        onSuccess(statusCode, headers, getResponseString(responseBytes, getCharset()));
-    }
-
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
-        onFailure(statusCode, headers, getResponseString(responseBytes, getCharset()), throwable);
-    }
-
-    /**
-     * Attempts to encode response bytes as string of set encoding
-     *
-     * @param charset     charset to create string with
-     * @param stringBytes response bytes
-     * @return String of set encoding or null
-     */
-    public static String getResponseString(byte[] stringBytes, String charset) {
-        try {
-            return stringBytes == null ? null : new String(stringBytes, charset);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, "Encoding response into string failed", e);
-            return null;
-        }
-    }
-
-}
diff --git a/library/src/main/java/com/loopj/android/http/package-info.java b/library/src/main/java/com/loopj/android/http/package-info.java
deleted file mode 100644
index 40174b19..00000000
--- a/library/src/main/java/com/loopj/android/http/package-info.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
\ No newline at end of file
diff --git a/maven_push.gradle b/maven_push.gradle
deleted file mode 100755
index 27fff0d8..00000000
--- a/maven_push.gradle
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright 2013 Chris Banes
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'maven'
-apply plugin: 'signing'
-
-def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
-}
-
-def getReleaseRepositoryUrl() {
-    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-}
-
-def getSnapshotRepositoryUrl() {
-    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-            : "https://oss.sonatype.org/content/repositories/snapshots/"
-}
-
-def getRepositoryUsername() {
-    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
-}
-
-def getRepositoryPassword() {
-    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
-}
-
-afterEvaluate { project ->
-    uploadArchives {
-        repositories {
-            mavenDeployer {
-                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
-
-                pom.groupId = GROUP
-                pom.artifactId = POM_ARTIFACT_ID
-                pom.version = VERSION_NAME
-
-                repository(url: getReleaseRepositoryUrl()) {
-                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
-                }
-                snapshotRepository(url: getSnapshotRepositoryUrl()) {
-                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
-                }
-
-                pom.project {
-                    name POM_NAME
-                    packaging POM_PACKAGING
-                    description POM_DESCRIPTION
-                    url POM_URL
-
-                    scm {
-                        url POM_SCM_URL
-                        connection POM_SCM_CONNECTION
-                        developerConnection POM_SCM_DEV_CONNECTION
-                    }
-
-                    licenses {
-                        license {
-                            name POM_LICENCE_NAME
-                            url POM_LICENCE_URL
-                            distribution POM_LICENCE_DIST
-                        }
-                    }
-
-                    developers {
-                        developer {
-                            id POM_DEVELOPER_ID
-                            name POM_DEVELOPER_NAME
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
-        sign configurations.archives
-    }
-
-    task androidJavadocs(type: Javadoc) {
-        source = android.sourceSets.main.java.srcDirs
-        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
-    }
-
-    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
-        classifier = 'javadoc'
-        from androidJavadocs.destinationDir
-    }
-
-    task androidSourcesJar(type: Jar) {
-        classifier = 'sources'
-        from android.sourceSets.main.java.srcDirs
-    }
-
-    artifacts {
-        archives androidSourcesJar
-        archives androidJavadocsJar
-    }
-}
diff --git a/releases/android-async-http-1.2.0.jar b/releases/android-async-http-1.2.0.jar
deleted file mode 100755
index 3fd4789b..00000000
Binary files a/releases/android-async-http-1.2.0.jar and /dev/null differ
diff --git a/releases/android-async-http-1.2.1.jar b/releases/android-async-http-1.2.1.jar
deleted file mode 100755
index 4db7cf11..00000000
Binary files a/releases/android-async-http-1.2.1.jar and /dev/null differ
diff --git a/releases/android-async-http-1.3.0.jar b/releases/android-async-http-1.3.0.jar
deleted file mode 100755
index faebdf0f..00000000
Binary files a/releases/android-async-http-1.3.0.jar and /dev/null differ
diff --git a/releases/android-async-http-1.3.1.jar b/releases/android-async-http-1.3.1.jar
deleted file mode 100755
index 107b032d..00000000
Binary files a/releases/android-async-http-1.3.1.jar and /dev/null differ
diff --git a/releases/android-async-http-1.3.2.jar b/releases/android-async-http-1.3.2.jar
deleted file mode 100755
index 0af40632..00000000
Binary files a/releases/android-async-http-1.3.2.jar and /dev/null differ
diff --git a/releases/android-async-http-1.4.0.jar b/releases/android-async-http-1.4.0.jar
deleted file mode 100755
index 2109150d..00000000
Binary files a/releases/android-async-http-1.4.0.jar and /dev/null differ
diff --git a/releases/android-async-http-1.4.1.jar b/releases/android-async-http-1.4.1.jar
deleted file mode 100755
index 551f5fbf..00000000
Binary files a/releases/android-async-http-1.4.1.jar and /dev/null differ
diff --git a/releases/android-async-http-1.4.2.jar b/releases/android-async-http-1.4.2.jar
deleted file mode 100755
index 1c568cb9..00000000
Binary files a/releases/android-async-http-1.4.2.jar and /dev/null differ
diff --git a/releases/android-async-http-1.4.3.jar b/releases/android-async-http-1.4.3.jar
deleted file mode 100755
index 3a749a59..00000000
Binary files a/releases/android-async-http-1.4.3.jar and /dev/null differ
diff --git a/releases/android-async-http-1.4.4.jar b/releases/android-async-http-1.4.4.jar
deleted file mode 100755
index 75af7015..00000000
Binary files a/releases/android-async-http-1.4.4.jar and /dev/null differ
diff --git a/sample/.gitignore b/sample/.gitignore
deleted file mode 100755
index 796b96d1..00000000
--- a/sample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/sample/build.gradle b/sample/build.gradle
deleted file mode 100755
index f6541400..00000000
--- a/sample/build.gradle
+++ /dev/null
@@ -1,49 +0,0 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:0.+'
-    }
-}
-apply plugin: 'android'
-
-repositories {
-    mavenCentral()
-    maven {
-        url "https://oss.sonatype.org/content/repositories/snapshots/"
-    }
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1'
-
-    defaultConfig {
-        minSdkVersion 3
-        targetSdkVersion 19
-    }
-
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_7
-        targetCompatibility JavaVersion.VERSION_1_7
-    }
-
-    lintOptions {
-        xmlReport false
-        warningsAsErrors true
-        quiet false
-        showAll true
-    }
-
-    packagingOptions {
-        exclude 'META-INF/DEPENDENCIES'
-        exclude 'META-INF/LICENSE'
-        exclude 'META-INF/NOTICE'
-    }
-}
-
-dependencies {
-    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
-    compile project(':library')
-}
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
deleted file mode 100755
index 0f14c9de..00000000
--- a/sample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.loopj.android.http.sample"
-          android:versionCode="1"
-          android:versionName="1.0">
-
-    <uses-permission android:name="android.permission.INTERNET"/>
-
-    <application
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name"
-        android:theme="@style/AppTheme">
-        <activity android:name=".WaypointsActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
-            </intent-filter>
-        </activity>
-        <activity android:name=".GetSample"/>
-        <activity android:name=".PostSample"/>
-        <activity android:name=".DeleteSample"/>
-        <activity android:name=".PutSample"/>
-        <activity android:name=".JsonSample"/>
-        <activity android:name=".FileSample"/>
-        <activity android:name=".BinarySample"/>
-        <activity android:name=".GzipSample"/>
-        <activity android:name=".Redirect302Sample"/>
-        <activity android:name=".ThreadingTimeoutSample"/>
-        <activity android:name=".CancelAllRequestsSample"/>
-        <activity android:name=".CancelRequestHandleSample"/>
-        <activity android:name=".SynchronousClientSample"/>
-        <activity android:name=".IntentServiceSample"/>
-        <activity android:name=".SaxSample"/>
-        <activity android:name=".FilesSample"/>
-        <activity android:name=".CustomCASample"/>
-
-        <service android:name=".services.ExampleIntentService"/>
-    </application>
-
-</manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
deleted file mode 100755
index 94417798..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.BinaryHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class BinarySample extends SampleParentActivity {
-    private static final String LOG_TAG = "BinarySample";
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_binary_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/gzip";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new BinaryHttpResponseHandler() {
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public String[] getAllowedContentTypes() {
-                // Allowing all data for debug purposes
-                return new String[]{".*"};
-            }
-
-            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-                debugStatusCode(LOG_TAG, statusCode);
-                debugHeaders(LOG_TAG, headers);
-                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
-                }
-            }
-        };
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
deleted file mode 100644
index 84d23b5f..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-public class CancelAllRequestsSample extends ThreadingTimeoutSample {
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_cancel_all;
-    }
-
-    @Override
-    public void onCancelButtonPressed() {
-        getAsyncHttpClient().cancelAllRequests(true);
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
deleted file mode 100644
index 7db7ba72..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.util.Log;
-
-import com.loopj.android.http.RequestHandle;
-
-public class CancelRequestHandleSample extends ThreadingTimeoutSample {
-
-    private static final String LOG_TAG = "ThreadingTimeoutSample";
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_cancel_handle;
-    }
-
-    @Override
-    public void onCancelButtonPressed() {
-        Log.d(LOG_TAG, String.format("Number of handles found: %d", getRequestHandles().size()));
-        int counter = 0;
-        for (RequestHandle handle : getRequestHandles()) {
-            if (!handle.isCancelled() && !handle.isFinished()) {
-                Log.d(LOG_TAG, String.format("Cancelling handle %d", counter));
-                Log.d(LOG_TAG, String.format("Handle %d cancel", counter) + (handle.cancel(true) ? " succeeded" : " failed"));
-            } else {
-                Log.d(LOG_TAG, String.format("Handle %d already non-cancellable", counter));
-            }
-            counter++;
-        }
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java b/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
deleted file mode 100644
index 4ed75c4a..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/CustomCASample.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.BinaryHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.sample.util.SecureSocketFactory;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.KeyManagementException;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.UnrecoverableKeyException;
-import java.security.cert.CertificateException;
-
-/**
- * This sample demonstrates the implementation of self-signed CA's and connection to servers with
- * such certificates. Be sure to read 'res/raw/custom_ca.txt' for how-to instructions on how to
- * generate a BKS file necessary for this sample.
- *
- * @author Noor Dawod <github@fineswap.com>
- */
-public class CustomCASample extends SampleParentActivity {
-
-    private static final String LOG_TAG = "CustomCASample";
-
-    private static final String SERVER_TEST_URL = "https://httpbin.org/get";
-    private static final String STORE_ALIAS = "TheAlias";
-    private static final String STORE_PASS = "ThePass";
-
-    // Instruct the library to retry connection when this exception is raised.
-    static {
-        AsyncHttpClient.allowRetryExceptionClass(javax.net.ssl.SSLException.class);
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        try {
-            InputStream is = null;
-            try {
-                // Configure the library to use a custom 'bks' file to perform
-                // SSL negotiation.
-                KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());
-                is = getResources().openRawResource(R.raw.store);
-                store.load(is, STORE_PASS.toCharArray());
-                getAsyncHttpClient().setSSLSocketFactory(new SecureSocketFactory(store, STORE_ALIAS));
-            } catch (IOException e) {
-                throw new KeyStoreException(e);
-            } catch (CertificateException e) {
-                throw new KeyStoreException(e);
-            } catch (NoSuchAlgorithmException e) {
-                throw new KeyStoreException(e);
-            } catch (KeyManagementException e) {
-                throw new KeyStoreException(e);
-            } catch (UnrecoverableKeyException e) {
-                throw new KeyStoreException(e);
-            } finally {
-                AsyncHttpClient.silentCloseInputStream(is);
-            }
-        } catch (KeyStoreException e) {
-            Log.e(LOG_TAG, "Unable to initialize key store", e);
-            Toast.makeText(
-                    this,
-                    "Please read res/raw/custom_ca.txt\nto learn how to create your own\nkey store containing a custom CA",
-                    Toast.LENGTH_LONG).show();
-            showCustomCAHelp();
-        }
-    }
-
-    /**
-     * Returns contents of `custom_ca.txt` as CharSequence
-     *
-     * @return contents of custom_ca.txt from Assets
-     */
-    private CharSequence getReadmeText() {
-        String rtn = "";
-        try {
-            InputStream stream = getResources().openRawResource(R.raw.custom_ca);
-            java.util.Scanner s = new java.util.Scanner(stream)
-                    .useDelimiter("\\A");
-            rtn = s.hasNext() ? s.next() : "";
-        } catch (Exception | Error e) {
-            Log.e(LOG_TAG, "License couldn't be retrieved", e);
-        }
-        return rtn;
-    }
-
-    /**
-     * Will display AlertDialog reading `custom_ca.txt` from Assets, to avoid strict Lint issue
-     */
-    private void showCustomCAHelp() {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle(R.string.title_custom_ca);
-        builder.setMessage(getReadmeText());
-        builder.setNeutralButton(android.R.string.cancel,
-                new DialogInterface.OnClickListener() {
-
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        dialog.dismiss();
-                    }
-                }
-        );
-        builder.show();
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_custom_ca;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return true;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return false;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return SERVER_TEST_URL;
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new BinaryHttpResponseHandler() {
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public String[] getAllowedContentTypes() {
-                // Allowing all data for debug purposes
-                return new String[]{".*"};
-            }
-
-            public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-                debugStatusCode(LOG_TAG, statusCode);
-                debugHeaders(LOG_TAG, headers);
-                debugResponse(LOG_TAG, "Received response is " + binaryData.length + " bytes");
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, "Received response is " + errorResponse.length + " bytes");
-                }
-            }
-        };
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
deleted file mode 100755
index 0eea3740..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class DeleteSample extends SampleParentActivity {
-    private static final String LOG_TAG = "DeleteSample";
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.delete(this, URL, headers, null, responseHandler);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_delete_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/delete";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugResponse(LOG_TAG, new String(response));
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, new String(errorResponse));
-                }
-            }
-        };
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
deleted file mode 100755
index 4d774e60..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.util.Log;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.FileAsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.sample.util.FileUtil;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.File;
-
-public class FileSample extends SampleParentActivity {
-    private static final String LOG_TAG = "FileSample";
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_file_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "https://httpbin.org/robots.txt";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new FileAsyncHttpResponseHandler(this) {
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, File response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugFile(response);
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, throwable);
-                debugFile(file);
-            }
-
-            private void debugFile(File file) {
-                if (file == null || !file.exists()) {
-                    debugResponse(LOG_TAG, "Response is null");
-                    return;
-                }
-                try {
-                    debugResponse(LOG_TAG, file.getAbsolutePath() + "\r\n\r\n" + FileUtil.getStringFromFile(file));
-                } catch (Throwable t) {
-                    Log.e(LOG_TAG, "Cannot debug file contents", t);
-                }
-                if (!deleteTargetFile()) {
-                    Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
-                }
-            }
-        };
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
deleted file mode 100644
index 491c2b36..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package com.loopj.android.http.sample;
-
-import android.util.Log;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.RequestParams;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.util.Random;
-
-public class FilesSample extends PostSample {
-
-    public static final String LOG_TAG = "PostFilesSample";
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_post_files;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        try {
-            RequestParams params = new RequestParams();
-            final String contentType = "application/octet-stream";
-            params.put("fileOne", createTempFile("fileOne", 1020), contentType);
-            params.put("fileTwo", createTempFile("fileTwo", 1030), contentType);
-            params.put("fileThree", createTempFile("fileThree", 1040), contentType);
-            params.put("fileFour", createTempFile("fileFour", 1050), contentType);
-            params.put("fileFive", createTempFile("fileFive", 1060), contentType);
-            return client.post(this, URL, params, responseHandler);
-        } catch (FileNotFoundException fnfException) {
-            Log.e(LOG_TAG, "executeSample failed with FileNotFoundException", fnfException);
-        }
-        return null;
-    }
-
-    public File createTempFile(String namePart, int byteSize) {
-        try {
-            File f = File.createTempFile(namePart, "_handled", getCacheDir());
-            FileOutputStream fos = new FileOutputStream(f);
-            Random r = new Random();
-            byte[] buffer = new byte[byteSize];
-            r.nextBytes(buffer);
-            fos.write(buffer);
-            fos.flush();
-            fos.close();
-            return f;
-        } catch (Throwable t) {
-            Log.e(LOG_TAG, "createTempFile failed", t);
-        }
-        return null;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
deleted file mode 100755
index ac11151a..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.widget.Toast;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class GetSample extends SampleParentActivity {
-    private static final String LOG_TAG = "GetSample";
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_get_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "https://httpbin.org/get";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugResponse(LOG_TAG, new String(response));
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, new String(errorResponse));
-                }
-            }
-
-            @Override
-            public void onRetry(int retryNo) {
-                Toast.makeText(GetSample.this,
-                        String.format("Request is retried, retry no. %d", retryNo),
-                        Toast.LENGTH_SHORT)
-                        .show();
-            }
-        };
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
deleted file mode 100644
index 2664b6f0..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-public class GzipSample extends JsonSample {
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_gzip_sample;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/gzip";
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
deleted file mode 100644
index 7b7dde62..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package com.loopj.android.http.sample;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.sample.services.ExampleIntentService;
-import com.loopj.android.http.sample.util.IntentUtil;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class IntentServiceSample extends SampleParentActivity {
-
-    public static final String LOG_TAG = "IntentServiceSample";
-    public static final String ACTION_START = "SYNC_START";
-    public static final String ACTION_RETRY = "SYNC_RETRY";
-    public static final String ACTION_CANCEL = "SYNC_CANCEL";
-    public static final String ACTION_SUCCESS = "SYNC_SUCCESS";
-    public static final String ACTION_FAILURE = "SYNC_FAILURE";
-    public static final String ACTION_FINISH = "SYNC_FINISH";
-    public static final String[] ALLOWED_ACTIONS = {ACTION_START,
-            ACTION_RETRY, ACTION_CANCEL, ACTION_SUCCESS, ACTION_FAILURE, ACTION_FINISH};
-    private final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-
-            // switch() doesn't support strings in older JDK.
-            if(ACTION_START.equals(action)) {
-                clearOutputs();
-                addView(getColoredView(LIGHTBLUE, "Request started"));
-            } else if(ACTION_FINISH.equals(action)) {
-                addView(getColoredView(LIGHTBLUE, "Request finished"));
-            } else if(ACTION_CANCEL.equals(action)) {
-                addView(getColoredView(LIGHTBLUE, "Request cancelled"));
-            } else if(ACTION_RETRY.equals(action)) {
-                addView(getColoredView(LIGHTBLUE, "Request retried"));
-            } else if(ACTION_FAILURE.equals(action) || ACTION_SUCCESS.equals(action)) {
-                debugThrowable(LOG_TAG, (Throwable) intent.getSerializableExtra(ExampleIntentService.INTENT_THROWABLE));
-                if(ACTION_SUCCESS.equals(action)) {
-                    debugStatusCode(LOG_TAG, intent.getIntExtra(ExampleIntentService.INTENT_STATUS_CODE, 0));
-                    debugHeaders(LOG_TAG, IntentUtil.deserializeHeaders(intent.getStringArrayExtra(ExampleIntentService.INTENT_HEADERS)));
-                    byte[] returnedBytes = intent.getByteArrayExtra(ExampleIntentService.INTENT_DATA);
-                    if (returnedBytes != null) {
-                        debugResponse(LOG_TAG, new String(returnedBytes));
-                    }
-                }
-            }
-        }
-    };
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        IntentFilter iFilter = new IntentFilter();
-        for (String action : ALLOWED_ACTIONS) {
-            iFilter.addAction(action);
-        }
-        registerReceiver(broadcastReceiver, iFilter);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        unregisterReceiver(broadcastReceiver);
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        // no response handler on activity
-        return null;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "https://httpbin.org/get";
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_intent_service_sample;
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        Intent serviceCall = new Intent(this, ExampleIntentService.class);
-        serviceCall.putExtra(ExampleIntentService.INTENT_URL, URL);
-        startService(serviceCall);
-        return null;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
deleted file mode 100755
index 4fcc07e0..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.fasterxml.jackson.core.JsonFactory;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.BaseJsonHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.sample.util.SampleJSON;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class JsonSample extends SampleParentActivity {
-
-    private static final String LOG_TAG = "JsonSample";
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_json_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return false;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/headers";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new BaseJsonHttpResponseHandler<SampleJSON>() {
-
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                if (response != null) {
-                    debugResponse(LOG_TAG, rawJsonResponse);
-                }
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, throwable);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, rawJsonData);
-                }
-            }
-
-            @Override
-            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
-                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
-            }
-
-        };
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
deleted file mode 100644
index 46133fd2..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.os.Bundle;
-
-import com.fasterxml.jackson.core.JsonFactory;
-import com.fasterxml.jackson.databind.ObjectMapper;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.BaseJsonHttpResponseHandler;
-import com.loopj.android.http.PersistentCookieStore;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.sample.util.SampleJSON;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.client.CookieStore;
-
-public class PersistentCookiesSample extends SampleParentActivity {
-
-    private static final String LOG_TAG = "PersistentCookiesSample";
-
-    private CookieStore cookieStore;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        // Use the application's context so that memory leakage doesn't occur.
-        cookieStore = new PersistentCookieStore(getApplicationContext());
-
-        // Set the new cookie store.
-        getAsyncHttpClient().setCookieStore(cookieStore);
-
-        super.onCreate(savedInstanceState);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_persistent_cookies;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        // The base URL for testing cookies.
-        String url = "http://httpbin.org/cookies";
-
-        // If the cookie store is empty, suggest a cookie.
-        if(cookieStore.getCookies().isEmpty()) {
-            url += "/set?time=" + System.currentTimeMillis();
-        }
-
-        return url;
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new BaseJsonHttpResponseHandler<SampleJSON>() {
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                if (response != null) {
-                    debugResponse(LOG_TAG, rawJsonResponse);
-                }
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, throwable);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, rawJsonData);
-                }
-            }
-
-            @Override
-            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
-                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
-            }
-        };
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
deleted file mode 100755
index 311b4216..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class PostSample extends SampleParentActivity {
-    private static final String LOG_TAG = "PostSample";
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.post(this, URL, headers, entity, null, responseHandler);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_post_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return true;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/post";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugResponse(LOG_TAG, new String(response));
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, new String(errorResponse));
-                }
-            }
-        };
-    }
-}
-
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
deleted file mode 100755
index 56260150..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class PutSample extends SampleParentActivity {
-    private static final String LOG_TAG = "PutSample";
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.put(this, URL, headers, entity, null, responseHandler);
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_put_sample;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return true;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/put";
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onStart() {
-                clearOutputs();
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugResponse(LOG_TAG, new String(response));
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
-                debugHeaders(LOG_TAG, headers);
-                debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                if (errorResponse != null) {
-                    debugResponse(LOG_TAG, new String(errorResponse));
-                }
-            }
-        };
-    }
-
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
deleted file mode 100644
index 766bc0f8..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.view.Menu;
-import android.view.MenuItem;
-import android.widget.Toast;
-
-import com.loopj.android.http.AsyncHttpClient;
-
-import org.apache.http.client.HttpClient;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-public class Redirect302Sample extends GetSample {
-
-    private boolean enableRedirects = true;
-    private boolean enableRelativeRedirects = true;
-    private boolean enableCircularRedirects = true;
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        menu.add(Menu.NONE, 0, Menu.NONE, "Enable redirects").setCheckable(true);
-        menu.add(Menu.NONE, 1, Menu.NONE, "Enable relative redirects").setCheckable(true);
-        menu.add(Menu.NONE, 2, Menu.NONE, "Enable circular redirects").setCheckable(true);
-        return super.onCreateOptionsMenu(menu);
-    }
-
-    @Override
-    public boolean onPrepareOptionsMenu(Menu menu) {
-        MenuItem menuItemEnableRedirects = menu.findItem(0);
-        if (menuItemEnableRedirects != null)
-            menuItemEnableRedirects.setChecked(enableRedirects);
-        MenuItem menuItemEnableRelativeRedirects = menu.findItem(1);
-        if (menuItemEnableRelativeRedirects != null)
-            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
-        MenuItem menuItemEnableCircularRedirects = menu.findItem(2);
-        if (menuItemEnableCircularRedirects != null)
-            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
-        return super.onPrepareOptionsMenu(menu);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        if (item.isCheckable()) {
-            item.setChecked(!item.isChecked());
-            if (item.getItemId() == 0) {
-                enableRedirects = item.isChecked();
-            } else if (item.getItemId() == 1) {
-                enableRelativeRedirects = item.isChecked();
-            } else if (item.getItemId() == 2) {
-                enableCircularRedirects = item.isChecked();
-            }
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/redirect/6";
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_redirect_302;
-    }
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient() {
-        AsyncHttpClient ahc = super.getAsyncHttpClient();
-        HttpClient client = ahc.getHttpClient();
-        if (client instanceof DefaultHttpClient) {
-            Toast.makeText(this,
-                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
-                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
-                    Toast.LENGTH_SHORT
-            ).show();
-            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
-        }
-        return ahc;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
deleted file mode 100644
index 6c7fe6b5..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-import java.util.List;
-
-public interface SampleInterface {
-
-    List<RequestHandle> getRequestHandles();
-
-    void addRequestHandle(RequestHandle handle);
-
-    void onRunButtonPressed();
-
-    void onCancelButtonPressed();
-
-    Header[] getRequestHeaders();
-
-    HttpEntity getRequestEntity();
-
-    AsyncHttpClient getAsyncHttpClient();
-
-    void setAsyncHttpClient(AsyncHttpClient client);
-
-    ResponseHandlerInterface getResponseHandler();
-
-    String getDefaultURL();
-
-    boolean isRequestHeadersAllowed();
-
-    boolean isRequestBodyAllowed();
-
-    int getSampleTitle();
-
-    boolean isCancelButtonAllowed();
-
-    RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler);
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
deleted file mode 100755
index 80296dfc..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.app.Activity;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.RequestHandle;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.message.BasicHeader;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Locale;
-
-public abstract class SampleParentActivity extends Activity implements SampleInterface {
-
-    private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-    private EditText urlEditText, headersEditText, bodyEditText;
-    private LinearLayout responseLayout;
-    private final List<RequestHandle> requestHandles = new LinkedList<RequestHandle>();
-
-    protected static final int LIGHTGREEN = Color.parseColor("#00FF66");
-    protected static final int LIGHTRED = Color.parseColor("#FF3300");
-    protected static final int YELLOW = Color.parseColor("#FFFF00");
-    protected static final int LIGHTBLUE = Color.parseColor("#99CCFF");
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.parent_layout);
-        setTitle(getSampleTitle());
-
-        urlEditText = (EditText) findViewById(R.id.edit_url);
-        headersEditText = (EditText) findViewById(R.id.edit_headers);
-        bodyEditText = (EditText) findViewById(R.id.edit_body);
-        Button runButton = (Button) findViewById(R.id.button_run);
-        Button cancelButton = (Button) findViewById(R.id.button_cancel);
-        LinearLayout headersLayout = (LinearLayout) findViewById(R.id.layout_headers);
-        LinearLayout bodyLayout = (LinearLayout) findViewById(R.id.layout_body);
-        responseLayout = (LinearLayout) findViewById(R.id.layout_response);
-
-        urlEditText.setText(getDefaultURL());
-
-        bodyLayout.setVisibility(isRequestBodyAllowed() ? View.VISIBLE : View.GONE);
-        headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
-
-        runButton.setOnClickListener(onClickListener);
-        if (cancelButton != null) {
-            if (isCancelButtonAllowed()) {
-                cancelButton.setVisibility(View.VISIBLE);
-                cancelButton.setOnClickListener(onClickListener);
-            } else {
-                cancelButton.setEnabled(false);
-            }
-        }
-    }
-
-    public List<RequestHandle> getRequestHandles() {
-        return requestHandles;
-    }
-
-    @Override
-    public void addRequestHandle(RequestHandle handle) {
-        if (null != handle) {
-            requestHandles.add(handle);
-        }
-    }
-
-    public void onRunButtonPressed() {
-        addRequestHandle(executeSample(getAsyncHttpClient(),
-                (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
-                getRequestHeaders(),
-                getRequestEntity(),
-                getResponseHandler()));
-    }
-
-    public void onCancelButtonPressed() {
-        asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
-    }
-
-    protected View.OnClickListener onClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View v) {
-            switch (v.getId()) {
-                case R.id.button_run:
-                    onRunButtonPressed();
-                    break;
-                case R.id.button_cancel:
-                    onCancelButtonPressed();
-                    break;
-            }
-        }
-    };
-
-    public List<Header> getRequestHeadersList() {
-        List<Header> headers = new ArrayList<Header>();
-        String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
-
-        if (headersRaw != null && headersRaw.length() > 3) {
-            String[] lines = headersRaw.split("\\r?\\n");
-            for (String line : lines) {
-                try {
-                    int equalSignPos = line.indexOf('=');
-                    if (1 > equalSignPos) {
-                        throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
-                    }
-
-                    String headerName = line.substring(0, equalSignPos).trim();
-                    String headerValue = line.substring(1 + equalSignPos).trim();
-
-                    headers.add(new BasicHeader(headerName, headerValue));
-                } catch (Throwable t) {
-                    Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
-                }
-            }
-        }
-        return headers;
-    }
-
-    public Header[] getRequestHeaders() {
-        List<Header> headers = getRequestHeadersList();
-        return headers.toArray(new Header[headers.size()]);
-    }
-
-    public HttpEntity getRequestEntity() {
-        if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
-            try {
-                return new StringEntity(bodyEditText.getText().toString());
-            } catch (UnsupportedEncodingException e) {
-                Log.e("SampleParentActivity", "cannot create String entity", e);
-            }
-        }
-        return null;
-    }
-
-    protected final void debugHeaders(String TAG, Header[] headers) {
-        if (headers != null) {
-            Log.d(TAG, "Return Headers:");
-            StringBuilder builder = new StringBuilder();
-            for (Header h : headers) {
-                String _h = String.format(Locale.US, "%s : %s", h.getName(), h.getValue());
-                Log.d(TAG, _h);
-                builder.append(_h);
-                builder.append("\n");
-            }
-            addView(getColoredView(YELLOW, builder.toString()));
-        }
-    }
-
-    protected static String throwableToString(Throwable t) {
-        if (t == null)
-            return null;
-
-        StringWriter sw = new StringWriter();
-        t.printStackTrace(new PrintWriter(sw));
-        return sw.toString();
-    }
-
-    protected final void debugThrowable(String TAG, Throwable t) {
-        if (t != null) {
-            Log.e(TAG, "AsyncHttpClient returned error", t);
-            addView(getColoredView(LIGHTRED, throwableToString(t)));
-        }
-    }
-
-    protected final void debugResponse(String TAG, String response) {
-        if (response != null) {
-            Log.d(TAG, "Response data:");
-            Log.d(TAG, response);
-            addView(getColoredView(LIGHTGREEN, response));
-        }
-    }
-
-    protected final void debugStatusCode(String TAG, int statusCode) {
-        String msg = String.format(Locale.US, "Return Status Code: %d", statusCode);
-        Log.d(TAG, msg);
-        addView(getColoredView(LIGHTBLUE, msg));
-    }
-
-    public static int getContrastColor(int color) {
-        double y = (299 * Color.red(color) + 587 * Color.green(color) + 114 * Color.blue(color)) / 1000;
-        return y >= 128 ? Color.BLACK : Color.WHITE;
-    }
-
-    protected View getColoredView(int bgColor, String msg) {
-        TextView tv = new TextView(this);
-        tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
-        tv.setText(msg);
-        tv.setBackgroundColor(bgColor);
-        tv.setPadding(10, 10, 10, 10);
-        tv.setTextColor(getContrastColor(bgColor));
-        return tv;
-    }
-
-    protected final void addView(View v) {
-        responseLayout.addView(v);
-    }
-
-    protected final void clearOutputs() {
-        responseLayout.removeAllViews();
-    }
-
-    public boolean isCancelButtonAllowed() {
-        return false;
-    }
-
-    public AsyncHttpClient getAsyncHttpClient() {
-        return this.asyncHttpClient;
-    }
-
-    @Override
-    public void setAsyncHttpClient(AsyncHttpClient client) {
-        this.asyncHttpClient = client;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
deleted file mode 100644
index ca85eb8d..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.SaxAsyncHttpResponseHandler;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.xml.sax.Attributes;
-import org.xml.sax.helpers.DefaultHandler;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class SaxSample extends SampleParentActivity {
-
-    private static final String LOG_TAG = "SaxSample";
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return saxAsyncHttpResponseHandler;
-    }
-
-    private SaxAsyncHttpResponseHandler saxAsyncHttpResponseHandler = new SaxAsyncHttpResponseHandler<SAXTreeStructure>(new SAXTreeStructure()) {
-        @Override
-        public void onStart() {
-            clearOutputs();
-        }
-
-        @Override
-        public void onSuccess(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
-            debugStatusCode(LOG_TAG, statusCode);
-            debugHeaders(LOG_TAG, headers);
-            debugHandler(saxTreeStructure);
-        }
-
-        @Override
-        public void onFailure(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
-            debugStatusCode(LOG_TAG, statusCode);
-            debugHeaders(LOG_TAG, headers);
-            debugHandler(saxTreeStructure);
-        }
-
-        private void debugHandler(SAXTreeStructure handler) {
-            for (Tuple t : handler.responseViews) {
-                addView(getColoredView(t.color, t.text));
-            }
-        }
-    };
-
-    @Override
-    public String getDefaultURL() {
-        return "http://bin-iin.com/sitemap.xml";
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_sax_example;
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-
-    private class Tuple {
-        public Integer color;
-        public String text;
-
-        public Tuple(int _color, String _text) {
-            this.color = _color;
-            this.text = _text;
-        }
-    }
-
-    private class SAXTreeStructure extends DefaultHandler {
-
-        public List<Tuple> responseViews = new ArrayList<Tuple>();
-
-        public void startElement(String namespaceURI, String localName,
-                                 String rawName, Attributes atts) {
-            responseViews.add(new Tuple(LIGHTBLUE, "Start Element: " + rawName));
-        }
-
-        public void endElement(String namespaceURI, String localName,
-                               String rawName) {
-            responseViews.add(new Tuple(LIGHTBLUE, "End Element  : " + rawName));
-        }
-
-        public void characters(char[] data, int off, int length) {
-            if (length > 0 && data[0] != '\n') {
-                responseViews.add(new Tuple(LIGHTGREEN, "Characters  :  " + new String(data,
-                        off, length)));
-            }
-        }
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
deleted file mode 100644
index bb92f02c..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.os.Bundle;
-import android.util.Log;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-import com.loopj.android.http.SyncHttpClient;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class SynchronousClientSample extends GetSample {
-    private static final String LOG_TAG = "SyncSample";
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setAsyncHttpClient(new SyncHttpClient());
-    }
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_synchronous;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "https://httpbin.org/delay/6";
-    }
-
-    @Override
-    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
-        if (client instanceof SyncHttpClient) {
-            new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    Log.d(LOG_TAG, "Before Request");
-                    client.get(SynchronousClientSample.this, URL, headers, null, responseHandler);
-                    Log.d(LOG_TAG, "After Request");
-                }
-            }).start();
-        } else {
-            Log.e(LOG_TAG, "Error, not using SyncHttpClient");
-        }
-        /**
-         * SyncHttpClient does not return RequestHandle,
-         * it executes each request directly,
-         * therefore those requests are not in cancelable threads
-         * */
-        return null;
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            @Override
-            public void onStart() {
-                runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        clearOutputs();
-                    }
-                });
-            }
-
-            @Override
-            public void onSuccess(final int statusCode, final Header[] headers, final byte[] response) {
-                runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        debugHeaders(LOG_TAG, headers);
-                        debugStatusCode(LOG_TAG, statusCode);
-                        debugResponse(LOG_TAG, new String(response));
-                    }
-                });
-            }
-
-            @Override
-            public void onFailure(final int statusCode, final Header[] headers, final byte[] errorResponse, final Throwable e) {
-                runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        debugHeaders(LOG_TAG, headers);
-                        debugStatusCode(LOG_TAG, statusCode);
-                        debugThrowable(LOG_TAG, e);
-                        if (errorResponse != null) {
-                            debugResponse(LOG_TAG, new String(errorResponse));
-                        }
-                    }
-                });
-            }
-        };
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
deleted file mode 100755
index 752559e7..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.util.SparseArray;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestHandle;
-import com.loopj.android.http.ResponseHandlerInterface;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-
-public class ThreadingTimeoutSample extends SampleParentActivity {
-
-    private static final String LOG_TAG = "ThreadingTimeoutSample";
-    private final SparseArray<String> states = new SparseArray<String>();
-    private int counter = 0;
-
-    @Override
-    public int getSampleTitle() {
-        return R.string.title_threading_timeout;
-    }
-
-    @Override
-    public boolean isRequestBodyAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isRequestHeadersAllowed() {
-        return false;
-    }
-
-    @Override
-    public boolean isCancelButtonAllowed() {
-        return true;
-    }
-
-    @Override
-    public String getDefaultURL() {
-        return "http://httpbin.org/delay/6";
-    }
-
-    private synchronized void setStatus(int id, String status) {
-        String current = states.get(id, null);
-        states.put(id, current == null ? status : current + "," + status);
-        clearOutputs();
-        for (int i = 0; i < states.size(); i++) {
-            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
-        }
-    }
-
-    @Override
-    public ResponseHandlerInterface getResponseHandler() {
-        return new AsyncHttpResponseHandler() {
-
-            private final int id = counter++;
-
-            @Override
-            public void onStart() {
-                setStatus(id, "START");
-            }
-
-            @Override
-            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-                setStatus(id, "SUCCESS");
-            }
-
-            @Override
-            public void onFinish() {
-                setStatus(id, "FINISH");
-            }
-
-            @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-                setStatus(id, "FAILURE");
-            }
-
-            @Override
-            public void onCancel() {
-                setStatus(id, "CANCEL");
-            }
-        };
-    }
-
-    public int getCounter() {
-        return counter;
-    }
-
-    @Override
-    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
-        return client.get(this, URL, headers, null, responseHandler);
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
deleted file mode 100755
index 6854a945..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
-
-import android.app.ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class WaypointsActivity extends ListActivity {
-
-    private static final SampleConfig[] samplesConfig = new SampleConfig[] {
-        new SampleConfig(R.string.title_get_sample, GetSample.class),
-        new SampleConfig(R.string.title_post_sample, PostSample.class),
-        new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
-        new SampleConfig(R.string.title_put_sample, PutSample.class),
-        new SampleConfig(R.string.title_json_sample, JsonSample.class),
-        new SampleConfig(R.string.title_sax_example, SaxSample.class),
-        new SampleConfig(R.string.title_file_sample, FileSample.class),
-        new SampleConfig(R.string.title_binary_sample, BinarySample.class),
-        new SampleConfig(R.string.title_gzip_sample, GzipSample.class),
-        new SampleConfig(R.string.title_redirect_302, Redirect302Sample.class),
-        new SampleConfig(R.string.title_threading_timeout, ThreadingTimeoutSample.class),
-        new SampleConfig(R.string.title_cancel_all, CancelAllRequestsSample.class),
-        new SampleConfig(R.string.title_cancel_handle, CancelRequestHandleSample.class),
-        new SampleConfig(R.string.title_synchronous, SynchronousClientSample.class),
-        new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
-        new SampleConfig(R.string.title_post_files, FilesSample.class),
-        new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class),
-        new SampleConfig(R.string.title_custom_ca, CustomCASample.class)
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, getTitlesList()));
-    }
-
-    private List<String> getTitlesList() {
-        List<String> titles = new ArrayList<String>();
-        for (SampleConfig config : samplesConfig) {
-            titles.add(getString(config.titleId));
-        }
-        return titles;
-    }
-
-    @Override
-    protected void onListItemClick(ListView l, View v, int position, long id) {
-        if (position >= 0 && position < samplesConfig.length)
-            startActivity(new Intent(this, samplesConfig[position].targetClass));
-    }
-
-    private static class SampleConfig {
-
-        final int titleId;
-        final Class targetClass;
-
-        SampleConfig(int titleId, Class targetClass) {
-          this.titleId = titleId;
-          this.targetClass = targetClass;
-        }
-
-    }
-
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
deleted file mode 100644
index d2d743a5..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/package-info.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
deleted file mode 100644
index 7fe49c71..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.loopj.android.http.sample.services;
-
-import android.app.IntentService;
-import android.content.Intent;
-import android.util.Log;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.SyncHttpClient;
-import com.loopj.android.http.sample.IntentServiceSample;
-import com.loopj.android.http.sample.util.IntentUtil;
-
-import org.apache.http.Header;
-
-public class ExampleIntentService extends IntentService {
-
-    public static final String LOG_TAG = "ExampleIntentService:IntentServiceSample";
-    public static final String INTENT_URL = "INTENT_URL";
-    public static final String INTENT_STATUS_CODE = "INTENT_STATUS_CODE";
-    public static final String INTENT_HEADERS = "INTENT_HEADERS";
-    public static final String INTENT_DATA = "INTENT_DATA";
-    public static final String INTENT_THROWABLE = "INTENT_THROWABLE";
-
-    private AsyncHttpClient aClient = new SyncHttpClient();
-
-    public ExampleIntentService() {
-        super("ExampleIntentService");
-    }
-
-    @Override
-    public void onStart(Intent intent, int startId) {
-        Log.d(LOG_TAG, "onStart()");
-        super.onStart(intent, startId);
-    }
-
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        if (intent != null && intent.hasExtra(INTENT_URL)) {
-            aClient.get(this, intent.getStringExtra(INTENT_URL), new AsyncHttpResponseHandler() {
-                @Override
-                public void onStart() {
-                    sendBroadcast(new Intent(IntentServiceSample.ACTION_START));
-                    Log.d(LOG_TAG, "onStart");
-                }
-
-                @Override
-                public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-                    Intent broadcast = new Intent(IntentServiceSample.ACTION_SUCCESS);
-                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
-                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
-                    broadcast.putExtra(INTENT_DATA, responseBody);
-                    sendBroadcast(broadcast);
-                    Log.d(LOG_TAG, "onSuccess");
-                }
-
-                @Override
-                public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-                    Intent broadcast = new Intent(IntentServiceSample.ACTION_FAILURE);
-                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
-                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
-                    broadcast.putExtra(INTENT_DATA, responseBody);
-                    broadcast.putExtra(INTENT_THROWABLE, error);
-                    sendBroadcast(broadcast);
-                    Log.d(LOG_TAG, "onFailure");
-                }
-
-                @Override
-                public void onCancel() {
-                    sendBroadcast(new Intent(IntentServiceSample.ACTION_CANCEL));
-                    Log.d(LOG_TAG, "onCancel");
-                }
-
-                @Override
-                public void onRetry(int retryNo) {
-                    sendBroadcast(new Intent(IntentServiceSample.ACTION_RETRY));
-                    Log.d(LOG_TAG, String.format("onRetry: %d", retryNo));
-                }
-
-                @Override
-                public void onFinish() {
-                    sendBroadcast(new Intent(IntentServiceSample.ACTION_FINISH));
-                    Log.d(LOG_TAG, "onFinish");
-                }
-            });
-        }
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
deleted file mode 100644
index df4ac428..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample.services;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
deleted file mode 100755
index 6838d595..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample.util;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-
-// Source: http://stackoverflow.com/questions/12910503/android-read-file-as-string
-public class FileUtil {
-
-    public static String convertStreamToString(InputStream is) throws Exception {
-        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-        StringBuilder sb = new StringBuilder();
-        String line;
-        while ((line = reader.readLine()) != null) {
-            sb.append(line).append("\n");
-        }
-        return sb.toString();
-    }
-
-    public static String getStringFromFile(File file) throws Exception {
-        FileInputStream fin = new FileInputStream(file);
-        String ret = convertStreamToString(fin);
-        //Make sure you close all streams.
-        fin.close();
-        return ret;
-    }
-
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
deleted file mode 100644
index a0ccb54b..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.loopj.android.http.sample.util;
-
-import org.apache.http.Header;
-import org.apache.http.message.BasicHeader;
-
-public class IntentUtil {
-
-    public static String[] serializeHeaders(Header[] headers) {
-        if (headers == null) {
-            return new String[0];
-        }
-        String[] rtn = new String[headers.length * 2];
-        int index = -1;
-        for (Header h : headers) {
-            rtn[++index] = h.getName();
-            rtn[++index] = h.getValue();
-        }
-        return rtn;
-    }
-
-    public static Header[] deserializeHeaders(String[] serialized) {
-        if (serialized == null || serialized.length % 2 != 0) {
-            return new Header[0];
-        }
-        Header[] headers = new Header[serialized.length / 2];
-        for (int i = 0, h = 0; h < headers.length; i++, h++) {
-            headers[h] = new BasicHeader(serialized[i], serialized[++i]);
-        }
-        return headers;
-    }
-
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
deleted file mode 100755
index 8e6c4a91..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample.util;
-
-import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
-import com.fasterxml.jackson.annotation.JsonProperty;
-
-@JsonIgnoreProperties(ignoreUnknown = true)
-public class SampleJSON {
-
-    private String Accept;
-    private String Referer;
-    private String AcceptLanguage;
-    private String Connection;
-    private String UserAgent;
-
-    public String getAccept() {
-        return Accept;
-    }
-
-    @JsonProperty("Accept")
-    public void setAccept(String accept) {
-        Accept = accept;
-    }
-
-    public String getReferer() {
-        return Referer;
-    }
-
-    @JsonProperty("Referer")
-    public void setReferer(String referer) {
-        Referer = referer;
-    }
-
-    public String getAcceptLanguage() {
-        return AcceptLanguage;
-    }
-
-    @JsonProperty("Accept-Language")
-    public void setAcceptLanguage(String acceptLanguage) {
-        AcceptLanguage = acceptLanguage;
-    }
-
-    public String getConnection() {
-        return Connection;
-    }
-
-    @JsonProperty("Connection")
-    public void setConnection(String connection) {
-        Connection = connection;
-    }
-
-    public String getUserAgent() {
-        return UserAgent;
-    }
-
-    @JsonProperty("User-Agent")
-    public void setUserAgent(String userAgent) {
-        UserAgent = userAgent;
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java b/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
deleted file mode 100644
index 02d5569d..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SecureSocketFactory.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
-    Android Asynchronous Http Client Sample
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample.util;
-
-import android.annotation.TargetApi;
-import android.util.Log;
-
-import com.loopj.android.http.AsyncHttpClient;
-
-import org.apache.http.conn.ssl.SSLSocketFactory;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Field;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.security.InvalidKeyException;
-import java.security.KeyManagementException;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.NoSuchProviderException;
-import java.security.SignatureException;
-import java.security.UnrecoverableKeyException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * A class to authenticate a secured connection against a custom CA using a BKS store.
- *
- * @author Noor Dawod <github@fineswap.com>
- */
-public class SecureSocketFactory extends SSLSocketFactory {
-
-    private static final String LOG_TAG = "SecureSocketFactory";
-
-    private final SSLContext sslCtx;
-    private final X509Certificate[] acceptedIssuers;
-
-    /**
-     * Instantiate a new secured factory pertaining to the passed store. Be sure to initialize the
-     * store with the password using {@link java.security.KeyStore#load(java.io.InputStream,
-     * char[])} method.
-     *
-     * @param store The key store holding the certificate details
-     * @param alias The alias of the certificate to use
-     */
-    public SecureSocketFactory(KeyStore store, String alias)
-            throws
-            CertificateException,
-            NoSuchAlgorithmException,
-            KeyManagementException,
-            KeyStoreException,
-            UnrecoverableKeyException {
-
-        super(store);
-
-        // Loading the CA certificate from store.
-        final Certificate rootca = store.getCertificate(alias);
-
-        // Turn it to X509 format.
-        InputStream is = new ByteArrayInputStream(rootca.getEncoded());
-        X509Certificate x509ca = (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(is);
-        AsyncHttpClient.silentCloseInputStream(is);
-
-        if (null == x509ca) {
-            throw new CertificateException("Embedded SSL certificate has expired.");
-        }
-
-        // Check the CA's validity.
-        x509ca.checkValidity();
-
-        // Accepted CA is only the one installed in the store.
-        acceptedIssuers = new X509Certificate[]{x509ca};
-
-        sslCtx = SSLContext.getInstance("TLS");
-        sslCtx.init(
-                null,
-                new TrustManager[]{
-                        new X509TrustManager() {
-                            @Override
-                            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-                            }
-
-                            @Override
-                            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-                                Exception error = null;
-
-                                if (null == chain || 0 == chain.length) {
-                                    error = new CertificateException("Certificate chain is invalid.");
-                                } else if (null == authType || 0 == authType.length()) {
-                                    error = new CertificateException("Authentication type is invalid.");
-                                } else {
-                                    Log.i(LOG_TAG, "Chain includes " + chain.length + " certificates.");
-                                    try {
-                                        for (X509Certificate cert : chain) {
-                                            Log.i(LOG_TAG, "Server Certificate Details:");
-                                            Log.i(LOG_TAG, "---------------------------");
-                                            Log.i(LOG_TAG, "IssuerDN: " + cert.getIssuerDN().toString());
-                                            Log.i(LOG_TAG, "SubjectDN: " + cert.getSubjectDN().toString());
-                                            Log.i(LOG_TAG, "Serial Number: " + cert.getSerialNumber());
-                                            Log.i(LOG_TAG, "Version: " + cert.getVersion());
-                                            Log.i(LOG_TAG, "Not before: " + cert.getNotBefore().toString());
-                                            Log.i(LOG_TAG, "Not after: " + cert.getNotAfter().toString());
-                                            Log.i(LOG_TAG, "---------------------------");
-
-                                            // Make sure that it hasn't expired.
-                                            cert.checkValidity();
-
-                                            // Verify the certificate's public key chain.
-                                            cert.verify(rootca.getPublicKey());
-                                        }
-                                    } catch (InvalidKeyException e) {
-                                        error = e;
-                                    } catch (NoSuchAlgorithmException e) {
-                                        error = e;
-                                    } catch (NoSuchProviderException e) {
-                                        error = e;
-                                    } catch (SignatureException e) {
-                                        error = e;
-                                    }
-                                }
-                                if (null != error) {
-                                    Log.e(LOG_TAG, "Certificate error", error);
-                                    throw new CertificateException(error);
-                                }
-                            }
-
-                            @Override
-                            public X509Certificate[] getAcceptedIssuers() {
-                                return acceptedIssuers;
-                            }
-                        }
-                },
-                null
-        );
-
-        setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
-            throws IOException {
-
-        injectHostname(socket, host);
-        return sslCtx.getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return sslCtx.getSocketFactory().createSocket();
-    }
-
-    /**
-     * Pre-ICS Android had a bug resolving HTTPS addresses. This workaround fixes that bug.
-     *
-     * @param socket The socket to alter
-     * @param host   Hostname to connect to
-     * @see <a href="https://code.google.com/p/android/issues/detail?id=13117#c14">https://code.google.com/p/android/issues/detail?id=13117#c14</a>
-     */
-    @TargetApi(4)
-    private void injectHostname(Socket socket, String host) {
-        try {
-            if (android.os.Build.VERSION.SDK_INT < 14) {
-                Field field = InetAddress.class.getDeclaredField("hostName");
-                field.setAccessible(true);
-                field.set(socket.getInetAddress(), host);
-            }
-        } catch (Exception ignored) {
-        }
-    }
-}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
deleted file mode 100644
index 4937f7f5..00000000
--- a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http.sample.util;
\ No newline at end of file
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100755
index 96a442e5..00000000
Binary files a/sample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100755
index 359047df..00000000
Binary files a/sample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100755
index 71c6d760..00000000
Binary files a/sample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
deleted file mode 100755
index 97ba749b..00000000
--- a/sample/src/main/res/layout-v14/parent_layout.xml
+++ /dev/null
@@ -1,94 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            android:fillViewport="true">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:focusable="true"
-        android:focusableInTouchMode="true"
-        android:orientation="vertical">
-
-        <requestFocus/>
-
-        <EditText
-            android:id="@+id/edit_url"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:inputType="textUri"/>
-
-        <LinearLayout
-            android:id="@+id/layout_url"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal">
-
-            <Button
-                android:id="@+id/button_cancel"
-                style="?android:attr/buttonBarButtonStyle"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:text="@string/button_cancel"/>
-
-            <Button
-                android:id="@+id/button_run"
-                style="?android:attr/buttonBarButtonStyle"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:text="@string/button_run"/>
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_headers"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical">
-
-            <TextView
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="@string/label_headers"/>
-
-            <EditText
-                android:id="@+id/edit_headers"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:inputType="textMultiLine"
-                android:minLines="3"
-                android:singleLine="false"/>
-
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_body"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical">
-
-            <TextView
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="@string/label_req_body"/>
-
-            <EditText
-                android:id="@+id/edit_body"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:inputType="textMultiLine"
-                android:minLines="3"
-                android:singleLine="false"/>
-
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_response"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"/>
-
-    </LinearLayout>
-</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
deleted file mode 100755
index d2c7dad6..00000000
--- a/sample/src/main/res/layout/parent_layout.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            android:fillViewport="true">
-
-    <LinearLayout
-        android:focusable="true"
-        android:focusableInTouchMode="true"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-
-        <requestFocus/>
-
-        <LinearLayout
-            android:id="@+id/layout_url"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal">
-
-            <EditText
-                android:id="@+id/edit_url"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:inputType="textUri"/>
-
-            <Button
-                android:id="@+id/button_run"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="@string/button_run"/>
-
-            <Button
-                android:id="@+id/button_cancel"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:visibility="gone"
-                android:text="@string/button_cancel"/>
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_headers"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical">
-
-            <TextView
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="@string/label_headers"/>
-
-            <EditText
-                android:id="@+id/edit_headers"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:inputType="textMultiLine"
-                android:minLines="3"
-                android:singleLine="false"/>
-
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_body"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical">
-
-            <TextView
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="@string/label_req_body"/>
-
-            <EditText
-                android:id="@+id/edit_body"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:inputType="textMultiLine"
-                android:minLines="3"
-                android:singleLine="false"/>
-
-        </LinearLayout>
-
-        <LinearLayout
-            android:id="@+id/layout_response"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"/>
-
-    </LinearLayout>
-</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/raw/custom_ca.txt b/sample/src/main/res/raw/custom_ca.txt
deleted file mode 100644
index a601671d..00000000
--- a/sample/src/main/res/raw/custom_ca.txt
+++ /dev/null
@@ -1,55 +0,0 @@
-This is a short HOW-TO documenting the steps necessary to create a key store
-file that Android could use to connect to servers with a custom CA.
-
-Prerequisities:
----------------
-
-1) Access to a computer with 'openssl' command;
-2) The 'keytool' command available in Java SE 6 and above;
-3) BouncyCastle jar version 1.46 (http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)
-
-Important:
-----------
-
-If you use the wrong BouncyCastle jar (for example, a newer version), older
-Android handsets might fail with the error "Wrong version of key store". So we
-advise to use an older BouncyCastle jar to cover older handsets.
-
-Let's see the fun part:
------------------------
-
-1) Create a self-signed CA using the openssl tool. You may bypass this step if
-   you already have a self-signed CA from before:
-
-   openssl req -newkey rsa:4096 -days 3650 -x509 -nodes -out ca.pem
-
-   You will be asked to provide details of the CA. When you're finished, a file
-   called 'ca.pem' will exist in current directory.
-
-2) Android has built-in support for the Bouncy Castle key store format (BKS).
-   You should have downloaded BouncyCastle's jar; we assume the path to that jar
-   is 'path/to/jar/bcprov.jar'. Now create a key store file containing your
-   self-signed CA:
-
-   keytool \
-      -import \
-      -v \
-      -trustcacerts \
-      -file ca.pem \
-      -keystore store.bks \
-      -storetype BKS \
-      -provider org.bouncycastle.jce.provider.BouncyCastleProvider \
-      -providerpath path/to/jar/bcprov.jar \
-      -alias TheAlias \
-      -storepass ThePass
-
-   keytool will ask to verify the certificate, naturally you should do so by
-   typing "yes" (without parentheses) and hitting Enter.
-
-   Note the alias and the password at the last two lines; you will need to enter
-   both in CustomCASample.java before running the sample app.
-
-3) If all went smoothly, you should have a file named store.bks which contains
-   the self-signed CA that we prepared in step 1. Move the resulting file to the
-   'res/raw/' directory, adjust the alias and password in CustomCASample.java
-   file, rebuild the app and run it.
diff --git a/sample/src/main/res/raw/store.bks b/sample/src/main/res/raw/store.bks
deleted file mode 100644
index e69de29b..00000000
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
deleted file mode 100755
index 3c02242a..00000000
--- a/sample/src/main/res/values-v11/styles.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<resources>
-
-    <!--
-        Base application theme for API 11+. This theme completely replaces
-        AppBaseTheme from res/values/styles.xml on API 11+ devices.
-    -->
-    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
-        <!-- API 11 theme customizations can go here. -->
-    </style>
-
-</resources>
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
deleted file mode 100755
index a91fd037..00000000
--- a/sample/src/main/res/values-v14/styles.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<resources>
-
-    <!--
-        Base application theme for API 14+. This theme completely replaces
-        AppBaseTheme from BOTH res/values/styles.xml and
-        res/values-v11/styles.xml on API 14+ devices.
-    -->
-    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
-        <!-- API 14 theme customizations can go here. -->
-    </style>
-
-</resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
deleted file mode 100755
index 4b4b9d9f..00000000
--- a/sample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<resources>
-    <string name="app_name">Android Async Http Samples</string>
-
-    <string name="button_run">Run</string>
-    <string name="label_headers">Headers (key=val, one per line)</string>
-    <string name="label_req_body">Request body</string>
-    <string name="button_cancel">Cancel</string>
-
-    <string name="title_get_sample">GET</string>
-    <string name="title_json_sample">GET JSON and parse it</string>
-    <string name="title_post_sample">POST</string>
-    <string name="title_put_sample">PUT</string>
-    <string name="title_delete_sample">DELETE</string>
-    <string name="title_file_sample">GET to File</string>
-    <string name="title_binary_sample">GET binary data</string>
-    <string name="title_cancel_all">Cancel all requests</string>
-    <string name="title_sax_example">SAX Example</string>
-    <string name="title_cancel_handle">Cancel request handle</string>
-    <string name="title_synchronous">Synchronous GET request</string>
-    <string name="title_threading_timeout">Threading timeouts</string>
-    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
-    <string name="title_intent_service_sample">IntentService Synchronised Request</string>
-    <string name="title_post_files">Post Multipart-encoded files</string>
-    <string name="title_redirect_302">302 Redirect handling</string>
-    <string name="title_persistent_cookies">Handling persistent cookies</string>
-    <string name="title_custom_ca">Custom CA Example</string>
-</resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
deleted file mode 100755
index 6ce89c7b..00000000
--- a/sample/src/main/res/values/styles.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<resources>
-
-    <!--
-        Base application theme, dependent on API level. This theme is replaced
-        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
-    -->
-    <style name="AppBaseTheme" parent="android:Theme.Light">
-        <!--
-            Theme customizations available in newer API levels can go in
-            res/values-vXX/styles.xml, while customizations related to
-            backward-compatibility can go here.
-        -->
-    </style>
-
-    <!-- Application theme. -->
-    <style name="AppTheme" parent="AppBaseTheme">
-        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
-    </style>
-
-</resources>
diff --git a/settings.gradle b/settings.gradle
deleted file mode 100755
index 612d9e44..00000000
--- a/settings.gradle
+++ /dev/null
@@ -1,2 +0,0 @@
-include ':library'
-include ':sample'
