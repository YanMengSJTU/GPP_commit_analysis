diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..832e19de
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,38 @@
+CONTRIBUTING
+------------
+AsyncHttpClient is an open-source project made by developers for developers!  
+If you would like to contribute to the project, that's really great. You can contribute in a variety of ways:  
+
+1) Help us with test cases and examples for the Wiki  
+2) If you have a good idea/patch for the project, create a pull request (see PULL)  
+3) Found a bug? You're more than welcome to submit an issue (see ISSUES)  
+4) Help other fellow developers solve their problems, you're welcome to do so in issues
+
+We do require certain guidelines to be followed so that the quality of the project remains top-notch:
+
+1. PULL requests
+----------------
+When you submit a patch or a new functionality for the project, you must open a pull request. We will get to the pull request as soon as possible, investigate what functionality or bug fixes have been added and decide whether to include it in the library or not -- for the benefit of everyone.  
+You further agree that any contribution that you make to the library will be distributed further under the same license as the library itself (Apache v2.0).  
+Don't be discouraged if your pull request is rejected. This is not a deadline and sometimes with a proper explanation on your side, we are persuaded to merge in the request. Just remember that this is a library for everyone and as such must meet certain, generic rules that we would like to believe are following.  
+
+2. ISSUES
+---------
+The issues system is the place to report bugs. Please do not use it to submit patches or new functionality. As helpful as we would like to be, we cannot replace the developer and we certainly do not see what you're seeing. So when you come to report an issue, please follow these simple rules:  
+
+1) Reporting bugs in English language only  
+2) If the issue is due to a crash, we need the stack trace -- throwable.printStackTrace() -- and any other detail that will shed light on the problem  
+3) We need to see the source code (minus certain details that you think are confidential) that caused the problem in the first place  
+4) Opening issues without providing us with the information necessary to debug and fix it is useless; so we will close such issues within 7 days period  
+
+3. CODING STANDARDS
+-------------------
+We need you to follow certain rules when sending source code contributions. These are the basic principles that we ourselves abide to and we require that you do so too:  
+
+1) Do not use the Tab character (it's in first place for a reason)  
+2) Indentation is 4 spaces  
+3) You must provide proper Javadoc, including description, in English for both public and protected methods, classes and properties  
+4) Group packages that belong to the same top-level package together, followed by an empty line  
+5) Add an empty line after and before class/interface declarations, methods and constructors  
+6) Add an empty line before and after a group of properties  
+7) Do not catch generic Exception/Throwable errors, but always catch the most specific type of the exception/error  
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
deleted file mode 100755
index 998daa1f..00000000
--- a/examples/CookieVideoView.java
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.media.MediaPlayer.OnInfoListener;
-import android.net.Uri;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.widget.MediaController;
-import android.widget.MediaController.MediaPlayerControl;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.http.cookie.Cookie;
-
-/**
- * Displays a video file.  The VideoView class
- * can load images from various sources (such as resources or content
- * providers), takes care of computing its measurement from the video so that
- * it can be used in any layout manager, and provides various display options
- * such as scaling and tinting.
- *
- * @author Jungho Bang <me@bangtoven.com>
- */
-public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
-    private String TAG = "CookieVideoView";
-    // settable by the client
-    private Uri         mUri;
-    private Map<String, String> mHeaders;
-
-    // all possible internal states
-    private static final int STATE_ERROR              = -1;
-    private static final int STATE_IDLE               = 0;
-    private static final int STATE_PREPARING          = 1;
-    private static final int STATE_PREPARED           = 2;
-    private static final int STATE_PLAYING            = 3;
-    private static final int STATE_PAUSED             = 4;
-    private static final int STATE_PLAYBACK_COMPLETED = 5;
-
-    // mCurrentState is a VideoView object's current state.
-    // mTargetState is the state that a method caller intends to reach.
-    // For instance, regardless the VideoView object's current state,
-    // calling pause() intends to bring the object to a target state
-    // of STATE_PAUSED.
-    private int mCurrentState = STATE_IDLE;
-    private int mTargetState  = STATE_IDLE;
-
-    // All the stuff we need for playing and showing a video
-    private SurfaceHolder mSurfaceHolder = null;
-    private MediaPlayer mMediaPlayer = null;
-    private int         mVideoWidth;
-    private int         mVideoHeight;
-    private int         mSurfaceWidth;
-    private int         mSurfaceHeight;
-    private MediaController mMediaController;
-    private OnCompletionListener mOnCompletionListener;
-    private MediaPlayer.OnPreparedListener mOnPreparedListener;
-    private int         mCurrentBufferPercentage;
-    private OnErrorListener mOnErrorListener;
-    private OnInfoListener  mOnInfoListener;
-    private int         mSeekWhenPrepared;  // recording the seek position while preparing
-    private boolean     mCanPause;
-    private boolean     mCanSeekBack;
-    private boolean     mCanSeekForward;
-	private Context 	mContext;
-
-    public CookieVideoView(Context context) {
-        super(context);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initVideoView(context);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        //Log.i("@@@@", "onMeasure");
-        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
-        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
-        if (mVideoWidth > 0 && mVideoHeight > 0) {
-            if ( mVideoWidth * height  > width * mVideoHeight ) {
-                //Log.i("@@@", "image too tall, correcting");
-                height = width * mVideoHeight / mVideoWidth;
-            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
-                //Log.i("@@@", "image too wide, correcting");
-                width = height * mVideoWidth / mVideoHeight;
-            } else {
-                //Log.i("@@@", "aspect ratio is correct: " +
-                        //width+"/"+height+"="+
-                        //mVideoWidth+"/"+mVideoHeight);
-            }
-        }
-        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
-        setMeasuredDimension(width, height);
-    }
-
-    @SuppressLint("NewApi")
-	@Override
-    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-        super.onInitializeAccessibilityEvent(event);
-        event.setClassName(CookieVideoView.class.getName());
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-	@Override
-    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
-        super.onInitializeAccessibilityNodeInfo(info);
-        info.setClassName(CookieVideoView.class.getName());
-    }
-
-    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
-        int result = desiredSize;
-        int specMode = MeasureSpec.getMode(measureSpec);
-        int specSize =  MeasureSpec.getSize(measureSpec);
-
-        switch (specMode) {
-            case MeasureSpec.UNSPECIFIED:
-                /* Parent says we can be as big as we want. Just don't be larger
-                 * than max size imposed on ourselves.
-                 */
-                result = desiredSize;
-                break;
-
-            case MeasureSpec.AT_MOST:
-                /* Parent says we can be as big as we want, up to specSize.
-                 * Don't be larger than specSize, and don't be larger than
-                 * the max size imposed on ourselves.
-                 */
-                result = Math.min(desiredSize, specSize);
-                break;
-
-            case MeasureSpec.EXACTLY:
-                // No choice. Do what we are told.
-                result = specSize;
-                break;
-        }
-        return result;
-}
-
-    private void initVideoView(Context context) {
-        mVideoWidth = 0;
-        mVideoHeight = 0;
-        getHolder().addCallback(mSHCallback);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-        setFocusable(true);
-        setFocusableInTouchMode(true);
-        requestFocus();
-        mCurrentState = STATE_IDLE;
-        mTargetState  = STATE_IDLE;
-        mContext = context;
-    }
-
-    public void setVideoPath(String path) {
-        setVideoURI(Uri.parse(path));
-    }
-
-    public void setVideoURI(Uri uri) {
-    	mUri = uri;
-        mHeaders = getCookieHeader();
-    	mSeekWhenPrepared = 0;
-        openVideo();
-        requestLayout();
-        invalidate();
-    }
-    
-    private Map<String,String> getCookieHeader() {
-    	String hostDomain = mUri.getHost();
-    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
-    	for(Cookie cookie : cookieList) {
-    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
-    			Map<String,String> header = new HashMap<String, String>();
-    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
-    	    	Log.d(TAG,"Cookie: "+header.toString());
-    	        return header;
-    	    }
-    	}
-    	return null;
-    }
-    
-    public void stopPlayback() {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.stop();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            mTargetState  = STATE_IDLE;
-        }
-    }
-
-    private void openVideo() {
-        if (mUri == null || mSurfaceHolder == null) {
-            // not ready for playback just yet, will try again later
-            return;
-        }
-        // Tell the music playback service to pause
-        // TODO: these constants need to be published somewhere in the framework.
-        Intent i = new Intent("com.android.music.musicservicecommand");
-        i.putExtra("command", "pause");
-        mContext.sendBroadcast(i);
-
-        // we shouldn't clear the target state, because somebody might have
-        // called start() previously
-        release(false);
-        try {
-            mMediaPlayer = new MediaPlayer();
-            mMediaPlayer.setOnPreparedListener(mPreparedListener);
-            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
-            mMediaPlayer.setOnCompletionListener(mCompletionListener);
-            mMediaPlayer.setOnErrorListener(mErrorListener);
-            mMediaPlayer.setOnInfoListener(mOnInfoListener);
-            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
-            mCurrentBufferPercentage = 0;
-            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
-            mMediaPlayer.setDisplay(mSurfaceHolder);
-            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mMediaPlayer.setScreenOnWhilePlaying(true);
-            mMediaPlayer.prepareAsync();
-            // we don't set the target state here either, but preserve the
-            // target state that was there before.
-            mCurrentState = STATE_PREPARING;
-            attachMediaController();
-        } catch (IOException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        } catch (IllegalArgumentException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        }
-    }
-
-    public void setMediaController(MediaController controller) {
-        if (mMediaController != null) {
-            mMediaController.hide();
-        }
-        mMediaController = controller;
-        attachMediaController();
-    }
-
-    private void attachMediaController() {
-        if (mMediaPlayer != null && mMediaController != null) {
-            mMediaController.setMediaPlayer(this);
-            View anchorView = this.getParent() instanceof View ?
-                    (View)this.getParent() : this;
-            mMediaController.setAnchorView(anchorView);
-            mMediaController.setEnabled(isInPlaybackState());
-        }
-    }
-
-    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
-        new MediaPlayer.OnVideoSizeChangedListener() {
-            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-                mVideoWidth = mp.getVideoWidth();
-                mVideoHeight = mp.getVideoHeight();
-                if (mVideoWidth != 0 && mVideoHeight != 0) {
-                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                    requestLayout();
-                }
-            }
-    };
-
-    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
-        public void onPrepared(MediaPlayer mp) {
-            mCurrentState = STATE_PREPARED;
-
-            // Get the capabilities of the player for this stream
-//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
-//                                      MediaPlayer.BYPASS_METADATA_FILTER);
-//            
-//          if (data != null) {
-//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
-//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
-//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
-//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
-//            } else {
-                mCanPause = mCanSeekBack = mCanSeekForward = true;
-//            }
-
-            if (mOnPreparedListener != null) {
-                mOnPreparedListener.onPrepared(mMediaPlayer);
-            }
-            if (mMediaController != null) {
-                mMediaController.setEnabled(true);
-            }
-            mVideoWidth = mp.getVideoWidth();
-            mVideoHeight = mp.getVideoHeight();
-
-            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
-            if (seekToPosition != 0) {
-                seekTo(seekToPosition);
-            }
-            if (mVideoWidth != 0 && mVideoHeight != 0) {
-                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
-                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
-                    // We didn't actually change the size (it was already at the size
-                    // we need), so we won't get a "surface changed" callback, so
-                    // start the video here instead of in the callback.
-                    if (mTargetState == STATE_PLAYING) {
-                        start();
-                        if (mMediaController != null) {
-                            mMediaController.show();
-                        }
-                    } else if (!isPlaying() &&
-                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
-                       if (mMediaController != null) {
-                           // Show the media controls when we're paused into a video and make 'em stick.
-                           mMediaController.show(0);
-                       }
-                   }
-                }
-            } else {
-                // We don't know the video size yet, but should start anyway.
-                // The video size might be reported to us later.
-                if (mTargetState == STATE_PLAYING) {
-                    start();
-                }
-            }
-        }
-    };
-
-    private MediaPlayer.OnCompletionListener mCompletionListener =
-        new MediaPlayer.OnCompletionListener() {
-        public void onCompletion(MediaPlayer mp) {
-            mCurrentState = STATE_PLAYBACK_COMPLETED;
-            mTargetState = STATE_PLAYBACK_COMPLETED;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-            if (mOnCompletionListener != null) {
-                mOnCompletionListener.onCompletion(mMediaPlayer);
-            }
-        }
-    };
-
-    private MediaPlayer.OnErrorListener mErrorListener =
-        new MediaPlayer.OnErrorListener() {
-        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
-            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-
-            /* If an error handler has been supplied, use it and finish. */
-            if (mOnErrorListener != null) {
-                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
-                    return true;
-                }
-            }
-
-            /* Otherwise, pop up an error dialog so the user knows that
-             * something bad has happened. Only try and pop up the dialog
-             * if we're attached to a window. When we're going away and no
-             * longer have a window, don't bother showing the user an error.
-             */
-            if (getWindowToken() != null) {
-//                Resources r = mContext.getResources();
-                int messageId;
-
-                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
-                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
-                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
-                } else {
-                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
-                    messageId = R.string.VideoView_error_text_unknown;
-                }
-
-                new AlertDialog.Builder(mContext)
-                        .setMessage(messageId)
-                        //eg. <string name="VideoView_error_button">OK</string>
-                        .setPositiveButton(R.string.VideoView_error_button,
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int whichButton) {
-                                        /* If we get here, there is no onError listener, so
-                                         * at least inform them that the video is over.
-                                         */
-                                        if (mOnCompletionListener != null) {
-                                            mOnCompletionListener.onCompletion(mMediaPlayer);
-                                        }
-                                    }
-                                })
-                        .setCancelable(false)
-                        .show();
-            }
-            return true;
-        }
-    };
-
-    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
-        new MediaPlayer.OnBufferingUpdateListener() {
-        public void onBufferingUpdate(MediaPlayer mp, int percent) {
-            mCurrentBufferPercentage = percent;
-        }
-    };
-
-    /**
-     * Register a callback to be invoked when the media file
-     * is loaded and ready to go.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
-    {
-        mOnPreparedListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when the end of a media file
-     * has been reached during playback.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnCompletionListener(OnCompletionListener l)
-    {
-        mOnCompletionListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an error occurs
-     * during playback or setup.  If no listener is specified,
-     * or if the listener returned false, VideoView will inform
-     * the user of any errors.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnErrorListener(OnErrorListener l)
-    {
-        mOnErrorListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an informational event
-     * occurs during playback or setup.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnInfoListener(OnInfoListener l) {
-        mOnInfoListener = l;
-    }
-
-    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
-    {
-        public void surfaceChanged(SurfaceHolder holder, int format,
-                                    int w, int h)
-        {
-            mSurfaceWidth = w;
-            mSurfaceHeight = h;
-            boolean isValidState =  (mTargetState == STATE_PLAYING);
-            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
-            if (mMediaPlayer != null && isValidState && hasValidSize) {
-                if (mSeekWhenPrepared != 0) {
-                    seekTo(mSeekWhenPrepared);
-                }
-                start();
-            }
-        }
-
-        public void surfaceCreated(SurfaceHolder holder)
-        {
-            mSurfaceHolder = holder;
-            openVideo();
-        }
-
-        public void surfaceDestroyed(SurfaceHolder holder)
-        {
-            // after we return from this we can't use the surface any more
-            mSurfaceHolder = null;
-            if (mMediaController != null) mMediaController.hide();
-            release(true);
-        }
-    };
-
-    /*
-     * release the media player in any state
-     */
-    private void release(boolean cleartargetstate) {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.reset();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            if (cleartargetstate) {
-                mTargetState  = STATE_IDLE;
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onTrackballEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
-                                     keyCode != KeyEvent.KEYCODE_MENU &&
-                                     keyCode != KeyEvent.KEYCODE_CALL &&
-                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
-        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
-            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
-                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                } else {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
-                if (!mMediaPlayer.isPlaying()) {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
-                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                }
-                return true;
-            } else {
-                toggleMediaControlsVisiblity();
-            }
-        }
-
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void toggleMediaControlsVisiblity() {
-        if (mMediaController.isShowing()) {
-            mMediaController.hide();
-        } else {
-            mMediaController.show();
-        }
-    }
-
-    public void start() {
-        if (isInPlaybackState()) {
-            mMediaPlayer.start();
-            mCurrentState = STATE_PLAYING;
-        }
-        mTargetState = STATE_PLAYING;
-    }
-
-    public void pause() {
-        if (isInPlaybackState()) {
-            if (mMediaPlayer.isPlaying()) {
-                mMediaPlayer.pause();
-                mCurrentState = STATE_PAUSED;
-            }
-        }
-        mTargetState = STATE_PAUSED;
-    }
-
-    public void suspend() {
-        release(false);
-    }
-
-    public void resume() {
-        openVideo();
-    }
-
-    public int getDuration() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getDuration();
-        }
-
-        return -1;
-    }
-
-    public int getCurrentPosition() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getCurrentPosition();
-        }
-        return 0;
-    }
-
-    public void seekTo(int msec) {
-        if (isInPlaybackState()) {
-            mMediaPlayer.seekTo(msec);
-            mSeekWhenPrepared = 0;
-        } else {
-            mSeekWhenPrepared = msec;
-        }
-    }
-
-    public boolean isPlaying() {
-        return isInPlaybackState() && mMediaPlayer.isPlaying();
-    }
-
-    public int getBufferPercentage() {
-        if (mMediaPlayer != null) {
-            return mCurrentBufferPercentage;
-        }
-        return 0;
-    }
-
-    private boolean isInPlaybackState() {
-        return (mMediaPlayer != null &&
-                mCurrentState != STATE_ERROR &&
-                mCurrentState != STATE_IDLE &&
-                mCurrentState != STATE_PREPARING);
-    }
-
-    public boolean canPause() {
-        return mCanPause;
-    }
-
-    public boolean canSeekBackward() {
-        return mCanSeekBack;
-    }
-
-    public boolean canSeekForward() {
-        return mCanSeekForward;
-    }
-}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
deleted file mode 100755
index b5c4fc6f..00000000
--- a/examples/ExampleUsage.java
+++ /dev/null
@@ -1,12 +0,0 @@
-public class ExampleUsage {
-    public static void makeRequest() {
-        AsyncHttpClient client = new AsyncHttpClient();
-
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
-            @Override
-            public void onSuccess(String response) {
-                System.out.println(response);
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
deleted file mode 100755
index ce949817..00000000
--- a/examples/TestCaseExampleUsage.java
+++ /dev/null
@@ -1,63 +0,0 @@
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
-import android.test.InstrumentationTestCase;
-import android.util.Log;
-
-// Credits to Wuyexiong <forever_crying@qq.com>
-// See: https://github.com/loopj/android-async-http/pull/236
-public class TestCaseExampleUsage extends InstrumentationTestCase
-{
-	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
-
-	public void testAsync() throws Throwable
-	{
-		final CountDownLatch signal = new CountDownLatch(1);
-		runTestOnUiThread(new Runnable()
-		{
-			@Override
-			public void run()
-			{
-				AsyncHttpClient client = new AsyncHttpClient();
-
-				client.get("http://www.google.com", new AsyncHttpResponseHandler()
-				{
-					@Override
-					public void onStart()
-					{
-						Log.v(TAG , "onStart");
-					}
-
-					@Override
-					public void onSuccess(String response)
-					{
-						Log.v(TAG , "onSuccess");
-						System.out.println(response);
-					}
-
-					@Override
-					public void onFailure(Throwable error, String content)
-					{
-						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
-					}
-
-					@Override
-					public void onFinish()
-					{
-						Log.v(TAG , "onFinish");
-						signal.countDown();
-					}
-				});
-
-				try {
-					signal.await(30, TimeUnit.SECONDS);
-				} catch (InterruptedException e) {
-				}
-				Log.v(TAG , "TestCaseExampleUsage Over");
-			}
-		});
-	}
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
deleted file mode 100755
index 395273df..00000000
--- a/examples/TwitterRestClient.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// Static wrapper library around AsyncHttpClient
-
-public class TwitterRestClient {
-    private static final String BASE_URL = "http://api.twitter.com/1/";
-
-    private static AsyncHttpClient client = new AsyncHttpClient();
-
-    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.post(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    private static String getAbsoluteUrl(String relativeUrl) {
-        return BASE_URL + relativeUrl;
-    }
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
deleted file mode 100755
index 297bfecc..00000000
--- a/examples/TwitterRestClientUsage.java
+++ /dev/null
@@ -1,18 +0,0 @@
-class TwitterRestClientUsage {
-    public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
-            @Override
-            public void onSuccess(JSONArray timeline) {
-                try {
-                    JSONObject firstEvent = (JSONObject) timeline.get(0);
-                    String tweetText = firstEvent.getString("text");
-
-                    // Do something with the response
-                    System.out.println(tweetText);
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
index b6c39ab0..537f1abd 100755
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,3 @@
-import com.android.builder.BuilderConstants
-
 apply plugin: 'android-library'
 
 android {
@@ -10,7 +8,7 @@ android {
         minSdkVersion 3
         targetSdkVersion 19
     }
-    
+
     lintOptions {
         abortOnError false
     }
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index f45dcd47..d7a1fcad 100755
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http"
-    android:versionName="1.4.5-SNAPSHOT"
-    android:versionCode="145">
+          package="com.loopj.android.http"
+          android:versionName="1.4.5-SNAPSHOT"
+          android:versionCode="145">
 
-    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
-    <application />
+    <application/>
 
 </manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 0cf493b9..12362f5a 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -92,13 +92,23 @@
  * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new ResponseHandlerInterface() {
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
  *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+ *          System.out.println(response);
+ *     }
+ *     &#064;Override
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
+ * {
+ *          error.printStackTrace(System.out);
  *     }
  * });
  * </pre>
+ *
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ * @see com.loopj.android.http.ResponseHandlerInterface
+ * @see com.loopj.android.http.RequestParams
  */
 public class AsyncHttpClient {
 
@@ -509,8 +519,8 @@ public void setMaxRetriesAndTimeout(int retries, int timeout) {
     }
 
     /**
-     * Will, before sending, remove all headers currently present in AsyncHttpClient instance,
-     * which applies on all requests this client makes
+     * Will, before sending, remove all headers currently present in AsyncHttpClient instance, which
+     * applies on all requests this client makes
      */
     public void removeAllHeaders() {
         clientHeaderMap.clear();
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index b345d872..256ab9c9 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -62,7 +62,7 @@
  *     }
  *
  *     &#064;Override
- *     public void onRetry() {
+ *     public void onRetry(int retryNo) {
  *         // Request was retried
  *     }
  *
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
index 8da2be16..cc26d439 100755
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -90,16 +90,15 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param str   the input String to decode, which is converted to bytes using the default
      *              charset
      * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *              standard Base64.
-     * @throws IllegalArgumentException if the input contains incorrect padding
      * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(String str, int flags) {
         return decode(str.getBytes(), flags);
@@ -107,15 +106,14 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input the input array to decode
      * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *              standard Base64.
-     * @throws IllegalArgumentException if the input contains incorrect padding
      * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int flags) {
         return decode(input, 0, input.length, flags);
@@ -123,17 +121,16 @@
 
     /**
      * Decode the Base64-encoded data in input and return the data in a new byte array.
-     * <p>&nbsp;</p>
-     * <p>The padding '=' characters at the end are considered optional, but if any are present,
-     * there must be the correct number of them.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input  the data to decode
      * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to decode
      * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
      *               standard Base64.
-     * @throws IllegalArgumentException if the input contains incorrect padding
      * @return decoded bytes for given offset and length
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int offset, int len, int flags) {
         // Allocate space for the most data the input could represent.
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
index ead54c56..ea2af542 100755
--- a/library/src/main/java/com/loopj/android/http/Base64DataException.java
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.loopj.android.http;
 
 import java.io.IOException;
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
index 231d4036..036d4a28 100755
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -1,5 +1,20 @@
-package com.loopj.android.http;
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
+package com.loopj.android.http;
 
 import java.io.FilterOutputStream;
 import java.io.IOException;
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index f643bf3f..0fe6ec16 100755
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -29,6 +29,7 @@
  * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
  * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
  * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ *
  * @param <JSON_TYPE> Generic type meant to be returned in callback
  */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
@@ -74,7 +75,7 @@ public BaseJsonHttpResponseHandler(String encoding) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -95,11 +96,11 @@ public void run() {
                         });
                     }
                 }
-	    };
+            };
             if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onSuccess(statusCode, headers, null, null);
         }
@@ -108,7 +109,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
         if (responseString != null) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -129,11 +130,11 @@ public void run() {
                         });
                     }
                 }
-	    };
+            };
             if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onFailure(statusCode, headers, throwable, null, null);
         }
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
index b121835d..72c9404c 100755
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -1,5 +1,3 @@
-package com.loopj.android.http;
-
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
@@ -18,6 +16,8 @@
     limitations under the License.
 */
 
+package com.loopj.android.http;
+
 import android.os.Message;
 import android.util.Log;
 
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index be48f62b..6e6f3275 100755
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -11,7 +29,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-
 public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
     protected final File mFile;
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index 63648a15..ab10821d 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -113,7 +113,7 @@ public void onSuccess(int statusCode, Header[] headers, String responseString) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -142,11 +142,11 @@ public void run() {
                         });
                     }
                 }
-	    };
-	    if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
@@ -155,7 +155,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
         if (responseBytes != null) {
-	    Runnable parser = new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -185,11 +185,11 @@ public void run() {
 
                     }
                 }
-	    };
-	    if (!getUseSynchronousMode())
-		new Thread(parser).start();
-	    else // In synchronous mode everything should be run on one thread
-		parser.run();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
             onFailure(statusCode, headers, throwable, (JSONObject) null);
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 6db13641..f033d4c0 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -35,16 +35,15 @@
 import java.util.zip.GZIPOutputStream;
 
 /**
- * HTTP entity to upload JSON data using streams.
- * This has very low memory footprint; suitable for uploading large
- * files using base64 encoding.
+ * HTTP entity to upload JSON data using streams. This has very low memory footprint; suitable for
+ * uploading large files using base64 encoding.
  */
-class JsonStreamerEntity implements HttpEntity {
+public class JsonStreamerEntity implements HttpEntity {
 
     private static final String LOG_TAG = "JsonStreamerEntity";
 
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
-        new UnsupportedOperationException("Unsupported operation in this implementation.");
+            new UnsupportedOperationException("Unsupported operation in this implementation.");
 
     // Size of the byte-array buffer used in I/O streams.
     private static final int BUFFER_SIZE = 4096;
@@ -66,12 +65,12 @@
     private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
-        new BasicHeader("Content-Type", "application/json");
+            new BasicHeader("Content-Type", "application/json");
     private static final Header HEADER_GZIP_ENCODING =
-        new BasicHeader("Content-Encoding", "gzip");
+            new BasicHeader("Content-Encoding", "gzip");
 
     // JSON data and associated meta-data to be uploaded.
-    private final Map<String, Object> jsonParams = new HashMap();
+    private final Map<String, Object> jsonParams = new HashMap<String, Object>();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
@@ -86,7 +85,7 @@ public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useG
     /**
      * Add content parameter, identified by the given key, to the request.
      *
-     * @param key entity's name
+     * @param key   entity's name
      * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
      */
     public void addPart(String key, Object value) {
@@ -144,8 +143,8 @@ public void writeTo(final OutputStream out) throws IOException {
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
         OutputStream os = null != contentEncoding
-          ? new GZIPOutputStream(out, BUFFER_SIZE)
-          : out;
+                ? new GZIPOutputStream(out, BUFFER_SIZE)
+                : out;
 
         // Always send a JSON object.
         os.write('{');
@@ -179,23 +178,23 @@ public void writeTo(final OutputStream out) throws IOException {
 
                 // Determine how to handle this entry.
                 if (isFileWrapper) {
-                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                    writeToFromFile(os, (RequestParams.FileWrapper) value);
                 } else {
-                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
                 }
 
                 // End the file's object and prepare for next one.
                 os.write('}');
             } else if (value instanceof Boolean) {
-                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                os.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number) value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                os.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number) value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                os.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number) value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                os.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number) value).intValue() + "").getBytes());
             } else {
                 os.write(value.toString().getBytes());
             }
@@ -228,7 +227,7 @@ private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entr
 
         // Upload the file's contents in Base64.
         Base64OutputStream bos =
-            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from input stream until no more data's left to read.
         while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
@@ -254,14 +253,14 @@ private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
         // Send the meta data.
         writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
 
-        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+        int bytesRead, bytesWritten = 0, totalSize = (int) wrapper.file.length();
 
         // Open the file for reading.
         FileInputStream in = new FileInputStream(wrapper.file);
 
         // Upload the file's contents in Base64.
         Base64OutputStream bos =
-            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
 
         // Read from file until no more data's left to read.
         while ((bytesRead = in.read(buffer)) != -1) {
@@ -301,14 +300,14 @@ private void writeMetaData(OutputStream os, String name, String contentType) thr
 
     private void endMetaData(OutputStream os) throws IOException {
         os.write('"');
-      }
+    }
 
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
     // Changed a bit to suit our needs in this class.
     static byte[] escape(String string) {
         // If it's null, just return prematurely.
         if (string == null) {
-          return JSON_NULL;
+            return JSON_NULL;
         }
 
         // Surround with quotations.
@@ -341,7 +340,7 @@ private void endMetaData(OutputStream os) throws IOException {
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
-                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                    if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
                         BUILDER.append("\\u");
                         int intLength = 4 - intString.length();
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
index 5ad3402b..f67579ea 100644
--- a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Aymon Fournier <aymon.fournier@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
@@ -18,7 +36,12 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
-// taken from: https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception
+/**
+ * Taken from StackOverflow
+ *
+ * @author Aymon Fournier, aymon.fournier@gmail.com
+ * @see <a href="https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception">https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception</a>
+ */
 class MyRedirectHandler extends DefaultRedirectHandler {
 
     private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
@@ -65,7 +88,7 @@ public URI getLocationURI(
                             + " but no location header"
             );
         }
-//HERE IS THE MODIFIED LINE OF CODE
+        //HERE IS THE MODIFIED LINE OF CODE
         String location = locationHeader.getValue().replaceAll(" ", "%20");
 
         URI uri;
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
index 2753801a..4808bcbf 100755
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.HttpVersion;
@@ -44,9 +62,9 @@
      * Creates a new SSL Socket Factory with the given KeyStore.
      *
      * @param truststore A KeyStore to create the SSL Socket Factory in context of
-     * @throws NoSuchAlgorithmException NoSuchAlgorithmException
-     * @throws KeyManagementException KeyManagementException
-     * @throws KeyStoreException KeyStoreException
+     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
+     * @throws KeyManagementException    KeyManagementException
+     * @throws KeyStoreException         KeyStoreException
      * @throws UnrecoverableKeyException UnrecoverableKeyException
      */
     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 2e0fdb8d..ca328e6b 100755
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -60,7 +60,7 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap();
+        cookies = new ConcurrentHashMap<String, Cookie>();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -146,7 +146,7 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList(cookies.values());
+        return new ArrayList<Cookie>(cookies.values());
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
index 6f3756cf..3f52da79 100755
--- a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.HttpException;
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
index f6348da4..2209fb78 100755
--- a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -1,11 +1,30 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
 import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
 import org.apache.http.client.methods.HttpUriRequest;
 
@@ -16,80 +35,76 @@
 
 
 public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
-	private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+    private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
 
-	private long current = 0;
-	private boolean append = false;
+    private long current = 0;
+    private boolean append = false;
 
-	/**
-	 * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
-	 * 
-	 * @param file File to store response within, must not be null
-	 */
-	public RangeFileAsyncHttpResponseHandler(File file) {
-		super(file);
-	}
+    /**
+     * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public RangeFileAsyncHttpResponseHandler(File file) {
+        super(file);
+    }
 
-	@Override
-	public void sendResponseMessage(HttpResponse response) throws IOException {
-		if (!Thread.currentThread().isInterrupted()) {
-			StatusLine status = response.getStatusLine();
-			if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE){
-				//already finished
-				if (!Thread.currentThread().isInterrupted())
-					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
-			}
-			else if (status.getStatusCode() >= 300) {
-				if (!Thread.currentThread().isInterrupted())
-					sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
-			}
-			else {
-				if (!Thread.currentThread().isInterrupted()) {
-					Header header = response.getFirstHeader("Content-Range");
-					if (header == null) {
-						append = false;
-						current = 0;
-					}
-					else
-						Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
-					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
-				}
-			}
-		}
-	}
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
+                //already finished
+                if (!Thread.currentThread().isInterrupted())
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+            } else if (status.getStatusCode() >= 300) {
+                if (!Thread.currentThread().isInterrupted())
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+            } else {
+                if (!Thread.currentThread().isInterrupted()) {
+                    Header header = response.getFirstHeader("Content-Range");
+                    if (header == null) {
+                        append = false;
+                        current = 0;
+                    } else
+                        Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+                }
+            }
+        }
+    }
 
-	@Override
-	protected byte[] getResponseData(HttpEntity entity) throws IOException {
-		if (entity != null) {
-			InputStream instream = entity.getContent();
-			long contentLength = entity.getContentLength() + current;
-			FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
-			if (instream != null) {
-				try {
-					byte[] tmp = new byte[BUFFER_SIZE];
-					int l;
-					while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted())
-					{
-						current += l;
-						buffer.write(tmp, 0, l);
-						sendProgressMessage((int)current, (int)contentLength);
-					}
-				} finally {
-					instream.close();
-					buffer.flush();
-					buffer.close();
-				}
-			}
-		}
-		return null;
-	}
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength() + current;
+            FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l;
+                    while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        current += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage((int) current, (int) contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
 
-	public void updateRequestHeaders(HttpUriRequest uriRequest) {
-		if (mFile.exists() && mFile.canWrite())
-			current = mFile.length();
-		if (current > 0) {
-			append = true;
-			uriRequest.setHeader("Range", "bytes=" + current + "-");
-		}
-	}
+    public void updateRequestHeaders(HttpUriRequest uriRequest) {
+        if (mFile.exists() && mFile.canWrite())
+            current = mFile.length();
+        if (current > 0) {
+            append = true;
+            uriRequest.setHeader("Range", "bytes=" + current + "-");
+        }
+    }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index a35aa634..290422a9 100755
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Jason Choy <jjwchoy@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import java.lang.ref.WeakReference;
@@ -9,7 +27,7 @@
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference(request);
+        this.request = new WeakReference<AsyncHttpRequest>(request);
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 8a1cb5ce..68488f8f 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -90,16 +90,16 @@
 public class RequestParams {
 
     public final static String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
+            "application/octet-stream";
 
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
     protected boolean autoCloseInputStreams;
-    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
-    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -307,9 +307,9 @@ public void add(String key, String value) {
                 this.put(key, params);
             }
             if (params instanceof List) {
-                ((List) params).add(value);
+                ((List<Object>) params).add(value);
             } else if (params instanceof Set) {
-                ((Set) params).add(value);
+                ((Set<Object>) params).add(value);
             }
         }
     }
@@ -334,9 +334,9 @@ public void remove(String key) {
      */
     public boolean has(String key) {
         return urlParams.get(key) != null ||
-        streamParams.get(key) != null ||
-        fileParams.get(key) != null ||
-        urlParamsWithObjects.get(key) != null;
+                streamParams.get(key) != null ||
+                fileParams.get(key) != null ||
+                urlParamsWithObjects.get(key) != null;
     }
 
     @Override
@@ -391,8 +391,8 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Set global flag which determines whether to automatically close input
-     * streams on successful upload.
+     * Set global flag which determines whether to automatically close input streams on successful
+     * upload.
      *
      * @param flag boolean whether to automatically close input streams
      */
@@ -420,7 +420,7 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
 
     private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
         JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
-            !fileParams.isEmpty() || !streamParams.isEmpty());
+                !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -442,11 +442,12 @@ private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHan
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
-                    StreamWrapper.newInstance(
-                        stream.inputStream,
-                        stream.name,
-                        stream.contentType,
-                        stream.autoClose));
+                        StreamWrapper.newInstance(
+                                stream.inputStream,
+                                stream.name,
+                                stream.contentType,
+                                stream.autoClose)
+                );
             }
         }
 
@@ -496,7 +497,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList();
+        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -508,12 +509,14 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList();
+        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
         if (value instanceof Map) {
             Map map = (Map) value;
             List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
-            Collections.sort(list);
+            if (list.size() > 0 && list.get(0) instanceof Comparable) {
+                Collections.sort(list);
+            }
             for (Object nestedKey : list) {
                 if (nestedKey instanceof String) {
                     Object nestedValue = map.get(nestedKey);
@@ -575,10 +578,10 @@ public StreamWrapper(InputStream inputStream, String name, String contentType, b
 
         static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
             return new StreamWrapper(
-                inputStream,
-                name,
-                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
-                autoClose);
+                    inputStream,
+                    name,
+                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                    autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index fe5eacc0..23a185d0 100755
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index a6968667..3b6ad196 100755
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
-    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..db4a3325
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
@@ -0,0 +1,145 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+/**
+ * Provides interface to deserialize SAX responses, using AsyncHttpResponseHandler. Can be used like
+ * this
+ *
+ * <pre>
+ *     AsyncHttpClient ahc = new AsyncHttpClient();
+ *     FontHandler handlerInstance = ... ; // init handler instance
+ *     ahc.post("https://server.tld/api/call", new SaxAsyncHttpResponseHandler<FontHandler>(handlerInstance){
+ *         &#064;Override
+ *         public void onSuccess(int statusCode, Header[] headers, FontHandler t) {
+ *              // Request got HTTP success statusCode
+ *         }
+ *         &#064;Override
+ *         public void onFailure(int statusCode, Header[] headers, T t){
+ *              // Request got HTTP fail statusCode
+ *         }
+ *     });
+ * <pre/>
+ *
+ * @see org.xml.sax.helpers.DefaultHandler
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ */
+public abstract class SaxAsyncHttpResponseHandler<T extends DefaultHandler> extends AsyncHttpResponseHandler {
+
+    /**
+     * Generic Type of handler
+     */
+    private T handler = null;
+    private final static String LOG_TAG = "SaxAsyncHttpResponseHandler";
+
+    /**
+     * Constructs new SaxAsyncHttpResponseHandler with given handler instance
+     *
+     * @param t instance of Handler extending DefaultHandler
+     * @see org.xml.sax.helpers.DefaultHandler
+     */
+    public SaxAsyncHttpResponseHandler(T t) {
+        super();
+        if (t == null) {
+            throw new Error("null instance of <T extends DefaultHandler> passed to constructor");
+        }
+        this.handler = t;
+    }
+
+    /**
+     * Deconstructs response into given content handler
+     *
+     * @param entity returned HttpEntity
+     * @see org.apache.http.HttpEntity
+     */
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            InputStreamReader inputStreamReader = null;
+            if (instream != null) {
+                try {
+                    SAXParserFactory sfactory = SAXParserFactory.newInstance();
+                    SAXParser sparser = sfactory.newSAXParser();
+                    XMLReader rssReader = sparser.getXMLReader();
+                    rssReader.setContentHandler(handler);
+                    inputStreamReader = new InputStreamReader(instream, DEFAULT_CHARSET);
+                    rssReader.parse(new InputSource(inputStreamReader));
+                } catch (SAXException | ParserConfigurationException e) {
+                    Log.e(LOG_TAG, "getResponseData exception", e);
+                } finally {
+                    AsyncHttpClient.silentCloseInputStream(instream);
+                    if (inputStreamReader != null) {
+                        try {
+                            inputStreamReader.close();
+                        } catch (IOException e) { /*ignore*/ }
+                    }
+
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Default onSuccess method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, headers, handler);
+    }
+
+    /**
+     * Default onFailure method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers,
+                          byte[] responseBody, Throwable error) {
+        onSuccess(statusCode, headers, handler);
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index bffdf740..423ab478 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -49,17 +49,17 @@
     private static final String STR_CR_LF = "\r\n";
     private static final byte[] CR_LF = STR_CR_LF.getBytes();
     private static final byte[] TRANSFER_ENCODING_BINARY =
-        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
+            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
     private final static char[] MULTIPART_CHARS =
-        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
     private final String boundary;
     private final byte[] boundaryLine;
     private final byte[] boundaryEnd;
     private boolean isRepeatable;
 
-    private final List<FilePart> fileParts = new ArrayList();
+    private final List<FilePart> fileParts = new ArrayList<FilePart>();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
@@ -136,7 +136,7 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
     }
 
     private String normalizeContentType(String type) {
-       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
+        return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
@@ -146,12 +146,12 @@ private String normalizeContentType(String type) {
 
     private byte[] createContentDisposition(String key) {
         return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
-            .getBytes();
+                .getBytes();
     }
 
     private byte[] createContentDisposition(String key, String fileName) {
         return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
-            .getBytes();
+                .getBytes();
     }
 
     private void updateProgress(int count) {
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index dd57d5a5..89591461 100755
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -1,3 +1,20 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
 package com.loopj.android.http;
 
 import android.content.Context;
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
index b96a263a..1c354a6c 100755
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.util.Log;
diff --git a/library/src/main/java/com/loopj/android/http/package-info.java b/library/src/main/java/com/loopj/android/http/package-info.java
new file mode 100644
index 00000000..40174b19
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
\ No newline at end of file
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index b1cac259..31876077 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -29,6 +29,7 @@
         <activity android:name=".CancelAllRequestsSample"/>
         <activity android:name=".CancelRequestHandleSample"/>
         <activity android:name=".SynchronousClientSample"/>
+        <activity android:name=".SaxSample"/>
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
index a01942fd..94417798 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
index fa8df74b..84d23b5f 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 public class CancelAllRequestsSample extends ThreadingTimeoutSample {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
index fd66c3a0..7db7ba72 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
index bea35ca4..0eea3740 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
index c554cc4d..4d774e60 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
index 5464cc6c..ac11151a 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.widget.Toast;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
index ba242939..2664b6f0 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 public class GzipSample extends JsonSample {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
index cde4e06f..4fcc07e0 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.fasterxml.jackson.core.JsonFactory;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
index 2e183d9b..311b4216 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
index d32b5767..56260150 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
index 1a10a1a3..766bc0f8 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.view.Menu;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
index 751823e9..6c7fe6b5 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
index 3b26362c..6f097724 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.Activity;
@@ -34,10 +52,10 @@
     private LinearLayout responseLayout;
     private final List<RequestHandle> requestHandles = new LinkedList<>();
 
-    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
-    private static final int LIGHTRED = Color.parseColor("#FF3300");
-    private static final int YELLOW = Color.parseColor("#FFFF00");
-    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+    protected static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    protected static final int LIGHTRED = Color.parseColor("#FF3300");
+    protected static final int YELLOW = Color.parseColor("#FFFF00");
+    protected static final int LIGHTBLUE = Color.parseColor("#99CCFF");
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
new file mode 100644
index 00000000..ca85eb8d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SaxAsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class SaxSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "SaxSample";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return saxAsyncHttpResponseHandler;
+    }
+
+    private SaxAsyncHttpResponseHandler saxAsyncHttpResponseHandler = new SaxAsyncHttpResponseHandler<SAXTreeStructure>(new SAXTreeStructure()) {
+        @Override
+        public void onStart() {
+            clearOutputs();
+        }
+
+        @Override
+        public void onSuccess(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        @Override
+        public void onFailure(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        private void debugHandler(SAXTreeStructure handler) {
+            for (Tuple t : handler.responseViews) {
+                addView(getColoredView(t.color, t.text));
+            }
+        }
+    };
+
+    @Override
+    public String getDefaultURL() {
+        return "http://bin-iin.com/sitemap.xml";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_sax_example;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    private class Tuple {
+        public Integer color;
+        public String text;
+
+        public Tuple(int _color, String _text) {
+            this.color = _color;
+            this.text = _text;
+        }
+    }
+
+    private class SAXTreeStructure extends DefaultHandler {
+
+        public List<Tuple> responseViews = new ArrayList<Tuple>();
+
+        public void startElement(String namespaceURI, String localName,
+                                 String rawName, Attributes atts) {
+            responseViews.add(new Tuple(LIGHTBLUE, "Start Element: " + rawName));
+        }
+
+        public void endElement(String namespaceURI, String localName,
+                               String rawName) {
+            responseViews.add(new Tuple(LIGHTBLUE, "End Element  : " + rawName));
+        }
+
+        public void characters(char[] data, int off, int length) {
+            if (length > 0 && data[0] != '\n') {
+                responseViews.add(new Tuple(LIGHTGREEN, "Characters  :  " + new String(data,
+                        off, length)));
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
index d0756ad0..bb92f02c 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.os.Bundle;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
index 059adeac..5222355b 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.SparseArray;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index dad700c2..3f0c1a45 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.ListActivity;
@@ -7,22 +25,26 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{
-            "GET",
-            "POST",
-            "DELETE",
-            "PUT",
-            "JSON",
-            "FILE",
-            "BINARY",
-            "GZIP",
-            "302 REDIRECT",
-            "THREADING TIMEOUTS",
-            "CANCEL ALL REQUESTS",
-            "CANCEL REQUEST HANDLE",
-            "SYNCHRONOUS CLIENT"
+    private static final int[] samples = new int[]{
+            R.string.title_get_sample,
+            R.string.title_post_sample,
+            R.string.title_delete_sample,
+            R.string.title_put_sample,
+            R.string.title_json_sample,
+            R.string.title_sax_example,
+            R.string.title_file_sample,
+            R.string.title_binary_sample,
+            R.string.title_gzip_sample,
+            R.string.title_redirect_302,
+            R.string.title_threading_timeout,
+            R.string.title_cancel_all,
+            R.string.title_cancel_handle,
+            R.string.title_synchronous
     };
     private static final Class[] targets = {
             GetSample.class,
@@ -30,6 +52,7 @@
             DeleteSample.class,
             PutSample.class,
             JsonSample.class,
+            SaxSample.class,
             FileSample.class,
             BinarySample.class,
             GzipSample.class,
@@ -43,7 +66,15 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, getTitlesList()));
+    }
+
+    private List<String> getTitlesList() {
+        List<String> titles = new ArrayList<String>();
+        for (int title : samples) {
+            titles.add(getString(title));
+        }
+        return titles;
     }
 
     @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
new file mode 100644
index 00000000..d2d743a5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
index 1398d9d9..6838d595 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import java.io.BufferedReader;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
index e12c30fc..8e6c4a91 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
new file mode 100644
index 00000000..4937f7f5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
\ No newline at end of file
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 3507db19..f71393e5 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -10,6 +10,7 @@
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
     <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_sax_example">SAX Example</string>
     <string name="title_cancel_handle">Cancel request handle</string>
     <string name="title_synchronous">Synchronous GET request</string>
     <string name="title_threading_timeout">Threading timeouts</string>
