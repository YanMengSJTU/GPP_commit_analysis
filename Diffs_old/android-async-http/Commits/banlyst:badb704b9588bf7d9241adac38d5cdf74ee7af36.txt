diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 5f0750d7..1ddc9d5f 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -1,20 +1,20 @@
 /*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
+ * Android Asynchronous Http Client
+ * Copyright (c) 2011 James Smith <james@loopj.com>
+ * http://loopj.com
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package com.loopj.android.http;
 
@@ -69,552 +69,700 @@
 
 import android.content.Context;
 
-
 /**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and
  * DELETE HTTP requests in your Android applications. Requests can be made
  * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
- * {@link AsyncHttpResponseHandler} instance.
+ * and responses can be handled by passing an anonymously overridden {@link AsyncHttpResponseHandler}
+ * instance.
  * <p>
  * For example:
  * <p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
- *     }
+ * &#064;Override
+ * public void onSuccess(String response) {
+ * System.out.println(response);
+ * }
  * });
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.3";
-
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
-
-    private final DefaultHttpClient httpClient;
-    private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
-    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
-    private final Map<String, String> clientHeaderMap;
-
-
-    /**
-     * Creates a new AsyncHttpClient.
-     */
-    public AsyncHttpClient() {
-        BasicHttpParams httpParams = new BasicHttpParams();
-
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
-
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
-
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
-
-        SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
-
-        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
-        httpClient = new DefaultHttpClient(cm, httpParams);
-        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
-            @Override
-            public void process(HttpRequest request, HttpContext context) {
-                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
-                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
-                }
-                for (String header : clientHeaderMap.keySet()) {
-                    request.addHeader(header, clientHeaderMap.get(header));
-                }
-            }
-        });
-
-        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
-            @Override
-            public void process(HttpResponse response, HttpContext context) {
-                final HttpEntity entity = response.getEntity();
-                if (entity == null) {
-                    return;
-                }
-                final Header encoding = entity.getContentEncoding();
-                if (encoding != null) {
-                    for (HeaderElement element : encoding.getElements()) {
-                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Get the underlying HttpClient instance. This is useful for setting
-     * additional fine-grained settings for requests by accessing the
-     * client's ConnectionManager, HttpParams and SchemeRegistry.
-     */
-    public HttpClient getHttpClient() {
-        return this.httpClient;
-    }
-
-    /**
-     * Get the underlying HttpContext instance. This is useful for getting 
-     * and setting fine-grained settings for requests by accessing the
-     * context's attributes such as the CookieStore.
-     */
-    public HttpContext getHttpContext() {
-        return this.httpContext;
-    }
-
-    /**
-     * Sets an optional CookieStore to use when making requests
-     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
-     */
-    public void setCookieStore(CookieStore cookieStore) {
-        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
-    }
-
-    /**
-     * Overrides the threadpool implementation used when queuing/pooling
-     * requests. By default, Executors.newCachedThreadPool() is used.
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
-     */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
-        this.threadPool = threadPool;
-    }
-
-    /**
-     * Sets the User-Agent header to be sent with each request. By default,
-     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
-     * @param userAgent the string to use in the User-Agent header.
-     */
-    public void setUserAgent(String userAgent) {
-        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
-    }
-
-    /**
-     * Sets the connection time oout. By default, 10 seconds
-     * @param timeout the connect/socket timeout in milliseconds
-     */
-    public void setTimeout(int timeout){
-        final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
-    }
-
-    /**
-     * Sets the SSLSocketFactory to user when making requests. By default,
-     * a new, default SSLSocketFactory is used.
-     * @param sslSocketFactory the socket factory to use for https requests.
-     */
-    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
-    }
-    
-    /**
-     * Sets headers that will be added to all requests this client makes (before sending).
-     * @param header the name of the header
-     * @param value the contents of the header
-     */
-    public void addHeader(String header, String value) {
-        clientHeaderMap.put(header, value);
-    }
-
-    /**
-     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
-     * @param username
-     * @param password
-     */
-    public void setBasicAuth(String user, String pass){
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
-    }
-    
-   /**
-     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
-     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     * @param username
-     * @param password
-     * @param scope - an AuthScope object
-     *
-     */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
-    }
-
-    /**
-     * Cancels any pending (or potentially active) requests associated with the
-     * passed Context.
-     * <p>
-     * <b>Note:</b> This will only affect requests which were created with a non-null
-     * android Context. This method is intended to be used in the onDestroy
-     * method of your android activities to destroy all requests which are no
-     * longer required.
-     *
-     * @param context the android Context instance associated to the request.
-     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
-     */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
-                Future<?> request = requestRef.get();
-                if(request != null) {
-                    request.cancel(mayInterruptIfRunning);
-                }
-            }
-        }
-        requestMap.remove(context);
-    }
-
-
-    //
-    // HTTP GET Requests
-    //
-
-    /**
-     * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        get(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        get(context, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP GET request and track the Android Context which initiated
-     * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, null, responseHandler,
-                context);
-    }
-
-
-    //
-    // HTTP POST Requests
-    //
-
-    /**
-     * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType,
-                responseHandler, context);
-    }
-
-    /**
-     * Perform a HTTP POST request and track the Android Context which initiated
-     * the request. Set headers only for this request
-     *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle
-     *        the response.
-     */
-    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP PUT Requests
-    //
-
-    /**
-     * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
-        delete(null, url, responseHandler);
-    }
-
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-    
-    /**
-     * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param responseHandler the response handler instance that should handle the response.
-     */
-    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
-        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
-    }
-
-
-    // Private stuff
-    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
-            uriRequest.addHeader("Content-Type", contentType);
-        }
-
-        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
-
-        if(context != null) {
-            // Add request to request map
-            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
-                requestList = new LinkedList<WeakReference<Future<?>>>();
-                requestMap.put(context, requestList);
-            }
-
-            requestList.add(new WeakReference<Future<?>>(request));
-
-            // TODO: Remove dead weakrefs from requestLists?
-        }
-    }
-
-    public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
-            String paramString = params.getParamString();
-            if (url.indexOf("?") == -1) {
-                url += "?" + paramString;
-            } else {
-                url += "&" + paramString;
-            }
-        }
-
-        return url;
-    }
-
-    private HttpEntity paramsToEntity(RequestParams params) {
-        HttpEntity entity = null;
-
-        if(params != null) {
-            entity = params.getEntity();
-        }
-
-        return entity;
-    }
-
-    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
-            requestBase.setEntity(entity);
-        }
-
-        return requestBase;
-    }
-
-    private static class InflatingEntity extends HttpEntityWrapper {
-        public InflatingEntity(HttpEntity wrapped) {
-            super(wrapped);
-        }
-
-        @Override
-        public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
-        }
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-    }
+	private static final String VERSION = "1.4.3";
+
+	private static final int DEFAULT_MAX_CONNECTIONS = 10;
+	private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+	private static final int DEFAULT_MAX_RETRIES = 5;
+	private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+	private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+	private static final String ENCODING_GZIP = "gzip";
+	private static final String DEFAULT_CHARSET = "UTF-8";
+
+	private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
+	private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+	private final DefaultHttpClient httpClient;
+	private final HttpContext httpContext;
+	private ThreadPoolExecutor threadPool;
+	private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+	private final Map<String, String> clientHeaderMap;
+
+	/**
+	 * Creates a new AsyncHttpClient.
+	 */
+	public AsyncHttpClient() {
+		this(null, null);
+	}
+
+	/**
+	 * Creates a new AsyncHttpClient.
+	 */
+	public AsyncHttpClient(String charset, String userAgent) {
+
+		BasicHttpParams httpParams = new BasicHttpParams();
+
+		ConnManagerParams.setTimeout(httpParams, socketTimeout);
+		ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
+		ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+		HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+		HttpConnectionParams.setTcpNoDelay(httpParams, true);
+		HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+		HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+		// HttpProtocolParams.setUserAgent(httpParams,
+		// String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+		HttpProtocolParams.setUserAgent(httpParams,
+		        userAgent != null && !"".equals(userAgent) ? userAgent :
+		                String.format("android-async-http/%s (http://loopj.com/android-async-http)",
+		                        VERSION));
+
+		HttpProtocolParams.setContentCharset(httpParams, charset != null && !"".equals(charset) ? charset
+		        : DEFAULT_CHARSET);
+
+		SchemeRegistry schemeRegistry = new SchemeRegistry();
+		schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+		schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+		ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+
+		httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+		httpClient = new DefaultHttpClient(cm, httpParams);
+		httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+			@Override
+			public void process(HttpRequest request, HttpContext context) {
+				if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+					request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+				}
+				for (String header : clientHeaderMap.keySet()) {
+					request.addHeader(header, clientHeaderMap.get(header));
+				}
+			}
+		});
+
+		httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+			@Override
+			public void process(HttpResponse response, HttpContext context) {
+				final HttpEntity entity = response.getEntity();
+				if (entity == null) {
+					return;
+				}
+				final Header encoding = entity.getContentEncoding();
+				if (encoding != null) {
+					for (HeaderElement element : encoding.getElements()) {
+						if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+							response.setEntity(new InflatingEntity(response.getEntity()));
+							break;
+						}
+					}
+				}
+			}
+		});
+
+		httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+
+		threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+
+		requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+		clientHeaderMap = new HashMap<String, String>();
+	}
+
+	/**
+	 * Get the underlying HttpClient instance. This is useful for setting
+	 * additional fine-grained settings for requests by accessing the
+	 * client's ConnectionManager, HttpParams and SchemeRegistry.
+	 */
+	public HttpClient getHttpClient() {
+		return this.httpClient;
+	}
+
+	/**
+	 * Get the underlying HttpContext instance. This is useful for getting
+	 * and setting fine-grained settings for requests by accessing the
+	 * context's attributes such as the CookieStore.
+	 */
+	public HttpContext getHttpContext() {
+		return this.httpContext;
+	}
+
+	/**
+	 * Sets an optional CookieStore to use when making requests
+	 * 
+	 * @param cookieStore
+	 *            The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
+	 */
+	public void setCookieStore(CookieStore cookieStore) {
+		httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+	}
+
+	/**
+	 * Overrides the threadpool implementation used when queuing/pooling
+	 * requests. By default, Executors.newCachedThreadPool() is used.
+	 * 
+	 * @param threadPool
+	 *            an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
+	 */
+	public void setThreadPool(ThreadPoolExecutor threadPool) {
+		this.threadPool = threadPool;
+	}
+
+	/**
+	 * Sets the User-Agent header to be sent with each request. By default,
+	 * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+	 * 
+	 * @param userAgent
+	 *            the string to use in the User-Agent header.
+	 */
+	public void setUserAgent(String userAgent) {
+		HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+	}
+
+	/**
+	 * Sets the connection time oout. By default, 10 seconds
+	 * 
+	 * @param timeout
+	 *            the connect/socket timeout in milliseconds
+	 */
+	public void setTimeout(int timeout) {
+		final HttpParams httpParams = this.httpClient.getParams();
+		ConnManagerParams.setTimeout(httpParams, timeout);
+		HttpConnectionParams.setSoTimeout(httpParams, timeout);
+		HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+	}
+
+	/**
+	 * Sets the SSLSocketFactory to user when making requests. By default,
+	 * a new, default SSLSocketFactory is used.
+	 * 
+	 * @param sslSocketFactory
+	 *            the socket factory to use for https requests.
+	 */
+	public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+		this.httpClient.getConnectionManager().getSchemeRegistry()
+		        .register(new Scheme("https", sslSocketFactory, 443));
+	}
+
+	/**
+	 * Sets headers that will be added to all requests this client makes (before sending).
+	 * 
+	 * @param header
+	 *            the name of the header
+	 * @param value
+	 *            the contents of the header
+	 */
+	public void addHeader(String header, String value) {
+		clientHeaderMap.put(header, value);
+	}
+
+	/**
+	 * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+	 * setBasicAuth('username','password',AuthScope.ANY)
+	 * 
+	 * @param username
+	 * @param password
+	 */
+	public void setBasicAuth(String user, String pass) {
+		AuthScope scope = AuthScope.ANY;
+		setBasicAuth(user, pass, scope);
+	}
+
+	/**
+	 * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be
+	 * like this
+	 * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+	 * 
+	 * @param username
+	 * @param password
+	 * @param scope
+	 *            - an AuthScope object
+	 * 
+	 */
+	public void setBasicAuth(String user, String pass, AuthScope scope) {
+		UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user, pass);
+		this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+	}
+
+	/**
+	 * Cancels any pending (or potentially active) requests associated with the
+	 * passed Context.
+	 * <p>
+	 * <b>Note:</b> This will only affect requests which were created with a non-null
+	 * android Context. This method is intended to be used in the onDestroy
+	 * method of your android activities to destroy all requests which are no
+	 * longer required.
+	 * 
+	 * @param context
+	 *            the android Context instance associated to the request.
+	 * @param mayInterruptIfRunning
+	 *            specifies if active requests should be cancelled along with pending requests.
+	 */
+	public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
+		List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+		if (requestList != null) {
+			for (WeakReference<Future<?>> requestRef : requestList) {
+				Future<?> request = requestRef.get();
+				if (request != null) {
+					request.cancel(mayInterruptIfRunning);
+				}
+			}
+		}
+		requestMap.remove(context);
+	}
+
+	//
+	// HTTP GET Requests
+	//
+
+	/**
+	 * Perform a HTTP GET request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, AsyncHttpResponseHandler responseHandler) {
+		get(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		get(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request without any parameters and track the Android Context which initiated the
+	 * request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+		get(context, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void get(Context context, String url, RequestParams params,
+	        AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null,
+		        responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP GET request and track the Android Context which initiated
+	 * the request with customized headers
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param params
+	 *            additional GET parameters to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle
+	 *            the response.
+	 */
+	public void get(Context context, String url, Header[] headers, RequestParams params,
+	        AsyncHttpResponseHandler responseHandler) {
+		HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, null, responseHandler,
+		        context);
+	}
+
+	//
+	// HTTP POST Requests
+	//
+
+	/**
+	 * Perform a HTTP POST request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, AsyncHttpResponseHandler responseHandler) {
+		post(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		post(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional POST parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, RequestParams params,
+	        AsyncHttpResponseHandler responseHandler) {
+		post(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if sending a
+	 *            json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void post(Context context, String url, HttpEntity entity, String contentType,
+	        AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType,
+		        responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request. Set headers only for this request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param params
+	 *            additional POST parameters to send with the request.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for
+	 *            example application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle
+	 *            the response.
+	 */
+	public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+	        AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = new HttpPost(url);
+		if (params != null)
+			request.setEntity(paramsToEntity(params));
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType,
+		        responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP POST request and track the Android Context which initiated
+	 * the request. Set headers only for this request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set headers only for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for
+	 *            example, use this to send string/json/xml payloads to a server by
+	 *            passing a {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for
+	 *            example application/json if sending a json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle
+	 *            the response.
+	 */
+	public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+	        AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+	}
+
+	//
+	// HTTP PUT Requests
+	//
+
+	/**
+	 * Perform a HTTP PUT request, without any parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, AsyncHttpResponseHandler responseHandler) {
+		put(null, url, null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request with parameters.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+		put(null, url, params, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param params
+	 *            additional PUT parameters or files to send with the request.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, RequestParams params,
+	        AsyncHttpResponseHandler responseHandler) {
+		put(context, url, paramsToEntity(params), null, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request.
+	 * And set one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if sending a
+	 *            json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, HttpEntity entity, String contentType,
+	        AsyncHttpResponseHandler responseHandler) {
+		sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType,
+		        responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP PUT request and track the Android Context which initiated the request.
+	 * And set one-time headers for the request
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param entity
+	 *            a raw {@link HttpEntity} to send with the request, for example, use this to send
+	 *            string/json/xml payloads to a server by passing a
+	 *            {@link org.apache.http.entity.StringEntity}.
+	 * @param contentType
+	 *            the content type of the payload you are sending, for example application/json if sending a
+	 *            json payload.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void put(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+	        AsyncHttpResponseHandler responseHandler) {
+		HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+		if (headers != null)
+			request.setHeaders(headers);
+		sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+	}
+
+	//
+	// HTTP DELETE Requests
+	//
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(String url, AsyncHttpResponseHandler responseHandler) {
+		delete(null, url, responseHandler);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+	}
+
+	/**
+	 * Perform a HTTP DELETE request.
+	 * 
+	 * @param context
+	 *            the Android Context which initiated the request.
+	 * @param url
+	 *            the URL to send the request to.
+	 * @param headers
+	 *            set one-time headers for this request
+	 * @param responseHandler
+	 *            the response handler instance that should handle the response.
+	 */
+	public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
+		final HttpDelete delete = new HttpDelete(url);
+		if (headers != null)
+			delete.setHeaders(headers);
+		sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+	}
+
+	// Private stuff
+	protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest,
+	        String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
+		if (contentType != null) {
+			uriRequest.addHeader("Content-Type", contentType);
+		}
+
+		Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest,
+		        responseHandler));
+
+		if (context != null) {
+			// Add request to request map
+			List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+			if (requestList == null) {
+				requestList = new LinkedList<WeakReference<Future<?>>>();
+				requestMap.put(context, requestList);
+			}
+
+			requestList.add(new WeakReference<Future<?>>(request));
+
+			// TODO: Remove dead weakrefs from requestLists?
+		}
+	}
+
+	public static String getUrlWithQueryString(String url, RequestParams params) {
+		if (params != null) {
+			String paramString = params.getParamString();
+			if (url.indexOf("?") == -1) {
+				url += "?" + paramString;
+			} else {
+				url += "&" + paramString;
+			}
+		}
+
+		return url;
+	}
+
+	private HttpEntity paramsToEntity(RequestParams params) {
+		HttpEntity entity = null;
+
+		if (params != null) {
+			entity = params.getEntity();
+		}
+
+		return entity;
+	}
+
+	private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase,
+	        HttpEntity entity) {
+		if (entity != null) {
+			requestBase.setEntity(entity);
+		}
+
+		return requestBase;
+	}
+
+	private static class InflatingEntity extends HttpEntityWrapper {
+		public InflatingEntity(HttpEntity wrapped) {
+			super(wrapped);
+		}
+
+		@Override
+		public InputStream getContent() throws IOException {
+			return new GZIPInputStream(wrappedEntity.getContent());
+		}
+
+		@Override
+		public long getContentLength() {
+			return -1;
+		}
+	}
 }
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index cbb0c288..9bcc11e8 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -1,27 +1,27 @@
 /*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
+ * Android Asynchronous Http Client
+ * Copyright (c) 2011 James Smith <james@loopj.com>
+ * http://loopj.com
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package com.loopj.android.http;
 
-import java.io.InputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -48,274 +48,317 @@
  * params.put("profile_picture", new File("pic.jpg")); // Upload a File
  * params.put("profile_picture2", someInputStream); // Upload an InputStream
  * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
- *
+ * 
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.post("http://myendpoint.com", params, responseHandler);
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
-
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
-
-    /**
-     * Constructs a new empty <code>RequestParams</code> instance.
-     */
-    public RequestParams() {
-        init();
-    }
-
-    /**
-     * Constructs a new RequestParams instance containing the key/value
-     * string params from the specified map.
-     * @param source the source key/value string map to add.
-     */
-    public RequestParams(Map<String, String> source) {
-        init();
-
-        for(Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with a single
-     * initial key/value string param.
-     * @param key the key name for the intial param.
-     * @param value the value string for the initial param.
-     */
-    public RequestParams(String key, String value) {
-        init();
-
-        put(key, value);
-    }
-
-    /**
-     * Constructs a new RequestParams instance and populate it with multiple
-     * initial key/value string param.
-     * @param keysAndValues a sequence of keys and values. Objects are
-     * automatically converted to Strings (including the value {@code null}).
-     * @throws IllegalArgumentException if the number of arguments isn't even.
-     */
-    public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
-    }
-
-    /**
-     * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
-     * @param value the value string for the new param.
-     */
-    public void put(String key, String value){
-        if(key != null && value != null) {
-            urlParams.put(key, value);
-        }
-    }
-
-    /**
-     * Adds a file to the request.
-     * @param key the key name for the new param.
-     * @param file the file to add.
-     */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
-    }
-
-    /**
-     * Adds param with more than one value.
-     * @param key the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values)  {
-        if(key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     */
-    public void put(String key, InputStream stream) {
-        put(key, stream, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
-    }
-
-    /**
-     * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
-     * @param contentType the content type of the file, eg. application/json
-     */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
-        }
-    }
-
-    /**
-     * Removes a parameter from the request.
-     * @param key the key name for the parameter to remove.
-     */
-    public void remove(String key){
-        urlParams.remove(key);
-        fileParams.remove(key);
-        urlParamsWithArray.remove(key);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append(entry.getValue());
-        }
-
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            result.append(entry.getKey());
-            result.append("=");
-            result.append("FILE");
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (int i = 0; i < values.size(); i++) {
-                if (i != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(values.get(i));
-            }
-        }
-
-        return result.toString();
-    }
-
-   /**
-     * Returns an HttpEntity containing all request parameters
-     */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
-
-        if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
-
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
-
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
-
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
-            }
-
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            }
-        }
-
-        return entity;
-    }
-
-    private void init(){
-        urlParams = new ConcurrentHashMap<String, String>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
-    }
-
-    protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
-
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
-        }
-
-        return lparams;
-    }
-
-    protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
-    }
-
-    private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
-        public String contentType;
-
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
-            this.contentType = contentType;
-        }
-
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
-        }
-    }
+	private static String ENCODING = "UTF-8";
+
+	protected ConcurrentHashMap<String, String> urlParams;
+	protected ConcurrentHashMap<String, FileWrapper> fileParams;
+	protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
+
+	protected String encoding;
+
+	/**
+	 * Constructs a new empty <code>RequestParams</code> instance.
+	 */
+	public RequestParams() {
+		this.encoding = ENCODING;
+		init();
+	}
+
+	/**
+	 * Constructs a new empty <code>RequestParams</code> instance with your URL-encoding strategy.
+	 */
+	public RequestParams(String encoding) {
+		this.encoding = encoding == null || "".equals(encoding) ? ENCODING : encoding;
+		init();
+	}
+
+	/**
+	 * Constructs a new RequestParams instance containing the key/value
+	 * string params from the specified map.
+	 * 
+	 * @param source
+	 *            the source key/value string map to add.
+	 */
+	public RequestParams(Map<String, String> source) {
+		init();
+
+		for (Map.Entry<String, String> entry : source.entrySet()) {
+			put(entry.getKey(), entry.getValue());
+		}
+	}
+
+	/**
+	 * Constructs a new RequestParams instance and populate it with a single
+	 * initial key/value string param.
+	 * 
+	 * @param key
+	 *            the key name for the intial param.
+	 * @param value
+	 *            the value string for the initial param.
+	 */
+	public RequestParams(String key, String value) {
+		init();
+
+		put(key, value);
+	}
+
+	/**
+	 * Constructs a new RequestParams instance and populate it with multiple
+	 * initial key/value string param.
+	 * 
+	 * @param keysAndValues
+	 *            a sequence of keys and values. Objects are
+	 *            automatically converted to Strings (including the value {@code null}).
+	 * @throws IllegalArgumentException
+	 *             if the number of arguments isn't even.
+	 */
+	public RequestParams(Object... keysAndValues) {
+		init();
+		int len = keysAndValues.length;
+		if (len % 2 != 0)
+			throw new IllegalArgumentException("Supplied arguments must be even");
+		for (int i = 0; i < len; i += 2) {
+			String key = String.valueOf(keysAndValues[i]);
+			String val = String.valueOf(keysAndValues[i + 1]);
+			put(key, val);
+		}
+	}
+
+	/**
+	 * Adds a key/value string pair to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param value
+	 *            the value string for the new param.
+	 */
+	public void put(String key, String value) {
+		if (key != null && value != null) {
+			urlParams.put(key, value);
+		}
+	}
+
+	/**
+	 * Adds a file to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param file
+	 *            the file to add.
+	 */
+	public void put(String key, File file) throws FileNotFoundException {
+		put(key, new FileInputStream(file), file.getName());
+	}
+
+	/**
+	 * Adds param with more than one value.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param values
+	 *            is the ArrayList with values for the param.
+	 */
+	public void put(String key, ArrayList<String> values) {
+		if (key != null && values != null) {
+			urlParamsWithArray.put(key, values);
+		}
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 */
+	public void put(String key, InputStream stream) {
+		put(key, stream, null);
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 * @param fileName
+	 *            the name of the file.
+	 */
+	public void put(String key, InputStream stream, String fileName) {
+		put(key, stream, fileName, null);
+	}
+
+	/**
+	 * Adds an input stream to the request.
+	 * 
+	 * @param key
+	 *            the key name for the new param.
+	 * @param stream
+	 *            the input stream to add.
+	 * @param fileName
+	 *            the name of the file.
+	 * @param contentType
+	 *            the content type of the file, eg. application/json
+	 */
+	public void put(String key, InputStream stream, String fileName, String contentType) {
+		if (key != null && stream != null) {
+			fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+		}
+	}
+
+	/**
+	 * Removes a parameter from the request.
+	 * 
+	 * @param key
+	 *            the key name for the parameter to remove.
+	 */
+	public void remove(String key) {
+		urlParams.remove(key);
+		fileParams.remove(key);
+		urlParamsWithArray.remove(key);
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder result = new StringBuilder();
+		for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+			if (result.length() > 0)
+				result.append("&");
+
+			result.append(entry.getKey());
+			result.append("=");
+			result.append(entry.getValue());
+		}
+
+		for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+			if (result.length() > 0)
+				result.append("&");
+
+			result.append(entry.getKey());
+			result.append("=");
+			result.append("FILE");
+		}
+
+		for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+			if (result.length() > 0)
+				result.append("&");
+
+			ArrayList<String> values = entry.getValue();
+			for (int i = 0; i < values.size(); i++) {
+				if (i != 0)
+					result.append("&");
+				result.append(entry.getKey());
+				result.append("=");
+				result.append(values.get(i));
+			}
+		}
+
+		return result.toString();
+	}
+
+	/**
+	 * Returns an HttpEntity containing all request parameters
+	 */
+	public HttpEntity getEntity() {
+		HttpEntity entity = null;
+
+		if (!fileParams.isEmpty()) {
+			SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+
+			// Add string params
+			for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+				multipartEntity.addPart(entry.getKey(), entry.getValue());
+			}
+
+			// Add dupe params
+			for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+				ArrayList<String> values = entry.getValue();
+				for (String value : values) {
+					multipartEntity.addPart(entry.getKey(), value);
+				}
+			}
+
+			// Add file params
+			int currentIndex = 0;
+			int lastIndex = fileParams.entrySet().size() - 1;
+			for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+				FileWrapper file = entry.getValue();
+				if (file.inputStream != null) {
+					boolean isLast = currentIndex == lastIndex;
+					if (file.contentType != null) {
+						multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream,
+						        file.contentType, isLast);
+					} else {
+						multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
+					}
+				}
+				currentIndex++;
+			}
+
+			entity = multipartEntity;
+		} else {
+			try {
+				entity = new UrlEncodedFormEntity(getParamsList(), this.encoding);
+			} catch (UnsupportedEncodingException e) {
+				e.printStackTrace();
+			}
+		}
+
+		return entity;
+	}
+
+	private void init() {
+		urlParams = new ConcurrentHashMap<String, String>();
+		fileParams = new ConcurrentHashMap<String, FileWrapper>();
+		urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
+	}
+
+	protected List<BasicNameValuePair> getParamsList() {
+		List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+
+		for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+			lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
+		}
+
+		for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+			ArrayList<String> values = entry.getValue();
+			for (String value : values) {
+				lparams.add(new BasicNameValuePair(entry.getKey(), value));
+			}
+		}
+
+		return lparams;
+	}
+
+	protected String getParamString() {
+		return URLEncodedUtils.format(getParamsList(), this.encoding);
+	}
+
+	private static class FileWrapper {
+		public InputStream inputStream;
+		public String fileName;
+		public String contentType;
+
+		public FileWrapper(InputStream inputStream, String fileName, String contentType) {
+			this.inputStream = inputStream;
+			this.fileName = fileName;
+			this.contentType = contentType;
+		}
+
+		public String getFileName() {
+			if (fileName != null) {
+				return fileName;
+			} else {
+				return "nofilename";
+			}
+		}
+	}
 }
