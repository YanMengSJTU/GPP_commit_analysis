diff --git a/.travis.yml b/.travis.yml
index 6f48cc94..95e9236b 100755
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,10 +2,10 @@ language: android
 jdk: openjdk7
 android:
   components:
-    - build-tools-19.1.0
+    - build-tools-21.1.2
     - extra-android-support
     - extra-android-m2repository
-    - android-19
+    - android-21
   licenses:
     - '.+'
 script:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0566956b..948f7b1f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,12 @@
 ## 1.4.7 (future version)
 
   - Fixed crash when canceling through RequestHandle from UI Thread (NetworkOnMainThreadException)
+  - Fixed URL encoding feature, that was breaking whole URL, not just path and query parts
+  - FileAsyncHttpResponseHandler now checks that target file path is available or can be created
+  - DataAsyncHttpResponseHandler was sending cancel notification instead of progress notification, fixed
+  - Added support for HTTP PATCH requests
+  - Fixed Assert exception when mkdirs in FileAsyncHttpResponseHandler tries to create dirs that already exists
+  - Provided option to easily override ClientConnectionManager provision in AsyncHttpClient
 
 ## 1.4.6 (released 7. 9. 2014)
 
diff --git a/NOTICE.txt b/NOTICE.txt
new file mode 100644
index 00000000..283826a1
--- /dev/null
+++ b/NOTICE.txt
@@ -0,0 +1,6 @@
+Android Async Http Client library
+Copyright (c) 2011-2014 James Smith <james@loopj.com>
+http://loopj.com
+
+This product includes software developed by
+The Apache Software Foundation (http://www.apache.org/).
diff --git a/build.gradle b/build.gradle
index 6dcaf5c1..35c9970e 100755
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.12.2'
+        classpath 'com.android.tools.build:gradle:1.0.0'
     }
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 796a5111..27a8a50e 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip
diff --git a/library/build.gradle b/library/build.gradle
index f68a9d92..47d51479 100755
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,12 +1,12 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1'
+    compileSdkVersion 21
+    buildToolsVersion '21.1.2'
 
     defaultConfig {
         minSdkVersion 3
-        targetSdkVersion 19
+        targetSdkVersion 21
     }
 
     lintOptions {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index dbfa5c79..ca7955b9 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -40,15 +40,14 @@
 import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.RedirectHandler;
-import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpHead;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
 import org.apache.http.conn.params.ConnRoutePNames;
@@ -73,10 +72,10 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PushbackInputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Field;
 import java.net.URI;
-import java.net.URLEncoder;
+import java.net.URL;
+import java.net.URLDecoder;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -237,7 +236,8 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
 
-        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+        ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);
+        Utils.asserts(cm != null, "Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null");
 
         threadPool = getDefaultThreadPool();
         requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
@@ -382,6 +382,17 @@ protected ExecutorService getDefaultThreadPool() {
         return Executors.newCachedThreadPool();
     }
 
+    /**
+     * Provided so it is easier for developers to provide custom ThreadSafeClientConnManager implementation
+     *
+     * @param schemeRegistry SchemeRegistry, usually provided by {@link #getDefaultSchemeRegistry(boolean, int, int)}
+     * @param httpParams     BasicHttpParams
+     * @return ClientConnectionManager instance
+     */
+    protected ClientConnectionManager createConnectionManager(SchemeRegistry schemeRegistry, BasicHttpParams httpParams) {
+        return new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
      * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
@@ -888,6 +899,23 @@ public RequestHandle get(Context context, String url, Header[] headers, RequestP
                 context);
     }
 
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
     // [-] HTTP GET
     // [+] HTTP POST
 
@@ -941,7 +969,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -959,7 +987,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
+        HttpEntityEnclosingRequestBase request = new HttpPost(getURI(url));
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -983,7 +1011,7 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -1042,7 +1070,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -1061,7 +1089,76 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(getURI(url)), entity);
+        if (headers != null) request.setHeaders(headers);
+        return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP PATCH request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) {
+        return patch(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPatch(getURI(url)), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP PATCH request and track the Android Context which initiated the request. And set
+     * one-time headers for the request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use
+     *                        this to send string/json/xml payloads to a server by passing a {@link
+     *                        org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle patch(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -1089,7 +1186,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        final HttpDelete delete = new HttpDelete(getURI(url));
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -1103,11 +1200,23 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        final HttpDelete delete = new HttpDelete(getURI(url));
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional DELETE parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, null);
+    }
+
     /**
      * Perform a HTTP DELETE request.
      *
@@ -1124,6 +1233,23 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpDelete(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
     // [-] HTTP DELETE
 
     /**
@@ -1163,7 +1289,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
             throw new IllegalArgumentException("ResponseHandler must not be null");
         }
 
-        if (responseHandler.getUseSynchronousMode()) {
+        if (responseHandler.getUseSynchronousMode() && !responseHandler.getUsePoolThread()) {
             throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
         }
 
@@ -1205,6 +1331,16 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
         return requestHandle;
     }
 
+    /**
+     * Returns a {@link URI} instance for the specified, absolute URL string.
+     *
+     * @param url absolute URL string, containing scheme, host and path
+     * @return URI instance for the URL string
+     */
+    protected URI getURI(String url) {
+        return URI.create(url).normalize();
+    }
+
     /**
      * Sets state of URL encoding feature, see bug #227, this method allows you to turn off and on
      * this auto-magic feature on-demand.
@@ -1229,10 +1365,13 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
 
         if (shouldEncodeUrl) {
             try {
-                url = URLEncoder.encode(url, "UTF-8");
-            } catch (UnsupportedEncodingException e) {
+                String decodedURL = URLDecoder.decode(url, "UTF-8");
+                URL _url = new URL(decodedURL);
+                URI _uri = new URI(_url.getProtocol(), _url.getUserInfo(), _url.getHost(), _url.getPort(), _url.getPath(), _url.getQuery(), _url.getRef());
+                url = _uri.toASCIIString();
+            } catch (Exception ex) {
                 // Should not really happen, added just for sake of validity
-                Log.e(LOG_TAG, "getUrlWithQueryString encoding URL", e);
+                Log.e(LOG_TAG, "getUrlWithQueryString encoding URL", ex);
             }
         }
 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 682a4f7b..6ae195e2 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Internal class, representing the HttpRequest, done in asynchronous manner
@@ -39,16 +40,16 @@
     private final HttpUriRequest request;
     private final ResponseHandlerInterface responseHandler;
     private int executionCount;
-    private boolean isCancelled;
+    private final AtomicBoolean isCancelled = new AtomicBoolean();
     private boolean cancelIsNotified;
-    private boolean isFinished;
+    private volatile boolean isFinished;
     private boolean isRequestPreProcessed;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
+        this.client = Utils.notNull(client, "client");
+        this.context = Utils.notNull(context, "context");
+        this.request = Utils.notNull(request, "request");
+        this.responseHandler = Utils.notNull(responseHandler, "responseHandler");
     }
 
     /**
@@ -97,9 +98,7 @@ public void run() {
             return;
         }
 
-        if (responseHandler != null) {
-            responseHandler.sendStartMessage();
-        }
+        responseHandler.sendStartMessage();
 
         if (isCancelled()) {
             return;
@@ -108,10 +107,10 @@ public void run() {
         try {
             makeRequestWithRetries();
         } catch (IOException e) {
-            if (!isCancelled() && responseHandler != null) {
+            if (!isCancelled()) {
                 responseHandler.sendFailureMessage(0, null, null, e);
             } else {
-                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
+                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error", e);
             }
         }
 
@@ -119,9 +118,7 @@ public void run() {
             return;
         }
 
-        if (responseHandler != null) {
-            responseHandler.sendFinishMessage();
-        }
+        responseHandler.sendFinishMessage();
 
         if (isCancelled()) {
             return;
@@ -150,7 +147,7 @@ private void makeRequest() throws IOException {
 
         HttpResponse response = client.execute(request, context);
 
-        if (isCancelled() || responseHandler == null) {
+        if (isCancelled()) {
             return;
         }
 
@@ -201,7 +198,7 @@ private void makeRequestWithRetries() throws IOException {
                     cause = e;
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                if (retry && (responseHandler != null)) {
+                if (retry) {
                     responseHandler.sendRetryMessage(executionCount);
                 }
             }
@@ -216,17 +213,17 @@ private void makeRequestWithRetries() throws IOException {
     }
 
     public boolean isCancelled() {
-        if (isCancelled) {
+        boolean cancelled = isCancelled.get();
+        if (cancelled) {
             sendCancelNotification();
         }
-        return isCancelled;
+        return cancelled;
     }
 
     private synchronized void sendCancelNotification() {
-        if (!isFinished && isCancelled && !cancelIsNotified) {
+        if (!isFinished && isCancelled.get() && !cancelIsNotified) {
             cancelIsNotified = true;
-            if (responseHandler != null)
-                responseHandler.sendCancelMessage();
+            responseHandler.sendCancelMessage();
         }
     }
 
@@ -235,7 +232,7 @@ public boolean isDone() {
     }
 
     public boolean cancel(boolean mayInterruptIfRunning) {
-        isCancelled = true;
+        isCancelled.set(true);
         request.abort();
         return isCancelled();
     }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 6943584a..a61d456e 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -97,11 +97,56 @@
     private String responseCharset = DEFAULT_CHARSET;
     private Handler handler;
     private boolean useSynchronousMode;
+    private boolean usePoolThread;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
     private Looper looper = null;
 
+    /**
+     * Creates a new AsyncHttpResponseHandler
+     */
+    public AsyncHttpResponseHandler() {
+        this(null);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If
+     * the passed looper is null, the looper attached to the current thread will
+     * be used.
+     *
+     * @param looper The looper to work with
+     */
+    public AsyncHttpResponseHandler(Looper looper) {
+        this.looper = looper == null ? Looper.myLooper() : looper;
+
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
+
+        // Do not use the pool's thread to fire callbacks by default.
+        setUsePoolThread(false);
+    }
+
+    /**
+     * Creates a new AsyncHttpResponseHandler and decide whether the callbacks
+     * will be fired on current thread's looper or the pool thread's.
+     *
+     * @param usePoolThread Whether to use the pool's thread to fire callbacks
+     */
+    public AsyncHttpResponseHandler(boolean usePoolThread) {
+        // Whether to use the pool's thread to fire callbacks.
+        setUsePoolThread(usePoolThread);
+
+        // When using the pool's thread, there's no sense in having a looper.
+        if (!getUsePoolThread()) {
+            // Use the current thread's looper.
+            this.looper = Looper.myLooper();
+
+            // Use asynchronous mode by default.
+            setUseSynchronousMode(false);
+        }
+    }
+
     @Override
     public URI getRequestURI() {
         return this.requestURI;
@@ -164,6 +209,23 @@ public void setUseSynchronousMode(boolean sync) {
         useSynchronousMode = sync;
     }
 
+    @Override
+    public boolean getUsePoolThread() {
+        return usePoolThread;
+    }
+
+    @Override
+    public void setUsePoolThread(boolean pool) {
+        // If pool thread is to be used, there's no point in keeping a reference
+        // to the looper and no need for a handler.
+        if (pool) {
+            looper = null;
+            handler = null;
+        }
+
+        usePoolThread = pool;
+    }
+
     /**
      * Sets the charset for the response string. If not set, the default is UTF-8.
      *
@@ -178,26 +240,6 @@ public String getCharset() {
         return this.responseCharset == null ? DEFAULT_CHARSET : this.responseCharset;
     }
 
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        this(null);
-    }
-
-    /**
-     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If
-     * the passed looper is null, the looper attached to the current thread will
-     * be used.
-     *
-     * @param looper The looper to work with
-     */
-    public AsyncHttpResponseHandler(Looper looper) {
-        this.looper = looper == null ? Looper.myLooper() : looper;
-        // Use asynchronous mode by default.
-        setUseSynchronousMode(false);
-    }
-
     /**
      * Fired when the request progress, override to handle in your own code
      *
@@ -357,7 +399,7 @@ protected void sendMessage(Message msg) {
         if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
-            AssertUtils.asserts(handler != null, "handler should not be null!");
+            Utils.asserts(handler != null, "handler should not be null!");
             handler.sendMessage(msg);
         }
     }
@@ -374,7 +416,7 @@ protected void postRunnable(Runnable runnable) {
                 runnable.run();
             } else {
                 // Otherwise, run on provided handler
-                AssertUtils.asserts(handler != null, "handler should not be null!");
+                Utils.asserts(handler != null, "handler should not be null!");
                 handler.post(runnable);
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index dae49c59..bbec9695 100755
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -97,7 +97,7 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode()) {
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
                 new Thread(parser).start();
             } else {
                 // In synchronous mode everything should be run on one thread
@@ -133,7 +133,7 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode()) {
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
                 new Thread(parser).start();
             } else {
                 // In synchronous mode everything should be run on one thread
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index 3b844dfc..539a263f 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -105,13 +105,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
             sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
                     status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "None, or more than one, Content-Type Header found!"
-                    )
+                    "None, or more than one, Content-Type Header found!"
+                )
             );
             return;
         }
@@ -129,13 +129,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
             sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
                     status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "Content-Type not allowed!"
-                    )
+                    "Content-Type (" + contentTypeHeader.getValue() + ") not allowed!"
+                )
             );
             return;
         }
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
index bea9a929..d801c9fa 100755
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -30,7 +30,7 @@
 public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
     private static final String LOG_TAG = "DataAsyncHttpResponseHandler";
 
-    protected static final int PROGRESS_DATA_MESSAGE = 6;
+    protected static final int PROGRESS_DATA_MESSAGE = 7;
 
     /**
      * Creates a new AsyncHttpResponseHandler
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 13de7fe2..1a11a1a0 100755
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -52,7 +52,11 @@ public FileAsyncHttpResponseHandler(File file) {
      */
     public FileAsyncHttpResponseHandler(File file, boolean append) {
         super();
-        AssertUtils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
+        Utils.asserts(file != null, "File passed into FileAsyncHttpResponseHandler constructor must not be null");
+        Utils.asserts(!file.isDirectory(), "File passed into FileAsyncHttpResponseHandler constructor must not point to directory");
+        if (!file.getParentFile().isDirectory()) {
+            Utils.asserts(file.getParentFile().mkdirs(), "Cannot create parent directories for requested File location");
+        }
         this.mFile = file;
         this.append = append;
     }
@@ -84,7 +88,7 @@ public boolean deleteTargetFile() {
      * @return temporary file or null if creating file failed
      */
     protected File getTemporaryFile(Context context) {
-        AssertUtils.asserts(context != null, "Tried creating temporary file without having Context");
+        Utils.asserts(context != null, "Tried creating temporary file without having Context");
         try {
             // not effective in release mode
             assert context != null;
diff --git a/library/src/main/java/com/loopj/android/http/HttpDelete.java b/library/src/main/java/com/loopj/android/http/HttpDelete.java
new file mode 100644
index 00000000..7bd0d10b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpDelete.java
@@ -0,0 +1,55 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP DELETE method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpDelete extends HttpEntityEnclosingRequestBase {
+    public final static String METHOD_NAME = "DELETE";
+
+    public HttpDelete() {
+        super();
+    }
+
+    public HttpDelete(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpDelete(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/HttpGet.java b/library/src/main/java/com/loopj/android/http/HttpGet.java
new file mode 100644
index 00000000..880f3c76
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpGet.java
@@ -0,0 +1,56 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP GET method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpGet extends HttpEntityEnclosingRequestBase {
+
+    public final static String METHOD_NAME = "GET";
+
+    public HttpGet() {
+        super();
+    }
+
+    public HttpGet(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpGet(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/HttpPatch.java b/library/src/main/java/com/loopj/android/http/HttpPatch.java
new file mode 100644
index 00000000..a81cc2c5
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpPatch.java
@@ -0,0 +1,54 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.net.URI;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * the HTTP PATCH method. Until the Android version is updated this can serve in it's stead. 
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpPatch extends HttpEntityEnclosingRequestBase {
+	
+    public final static String METHOD_NAME = "PATCH";
+
+    public HttpPatch() {
+        super();
+    }
+
+    public HttpPatch(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpPatch(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index b12afce6..52663a07 100755
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -144,7 +144,7 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode()) {
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
                 new Thread(parser).start();
             } else {
                 // In synchronous mode everything should be run on one thread
@@ -189,7 +189,7 @@ public void run() {
                     }
                 }
             };
-            if (!getUseSynchronousMode()) {
+            if (!getUseSynchronousMode() && !getUsePoolThread()) {
                 new Thread(parser).start();
             } else {
                 // In synchronous mode everything should be run on one thread
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 0df47d47..aea2d1d1 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -18,6 +18,7 @@
 
 package com.loopj.android.http;
 
+import android.text.TextUtils;
 import android.util.Log;
 
 import org.apache.http.Header;
@@ -51,18 +52,12 @@
     // Buffer used for reading from input streams.
     private final byte[] buffer = new byte[BUFFER_SIZE];
 
-    // Reusable StringBuilder used by escape() method.
-    // Its size is just initial, if more space is needed, the system will
-    // automatically enlarge the buffer.
-    private static final StringBuilder BUILDER = new StringBuilder(128);
-
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
     private static final byte[] JSON_NULL = "null".getBytes();
     private static final byte[] STREAM_NAME = escape("name");
     private static final byte[] STREAM_TYPE = escape("type");
     private static final byte[] STREAM_CONTENTS = escape("contents");
-    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
             new BasicHeader(
@@ -80,11 +75,16 @@
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
+    private final byte[] elapsedField;
+
     private final ResponseHandlerInterface progressHandler;
 
-    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression, String elapsedField) {
         this.progressHandler = progressHandler;
         this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
+        this.elapsedField = TextUtils.isEmpty(elapsedField)
+          ? null
+          : escape(elapsedField);
     }
 
     /**
@@ -147,7 +147,7 @@ public void writeTo(final OutputStream out) throws IOException {
 
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream os = null != contentEncoding
+        OutputStream os = contentEncoding != null
                 ? new GZIPOutputStream(out, BUFFER_SIZE)
                 : out;
 
@@ -157,71 +157,90 @@ public void writeTo(final OutputStream out) throws IOException {
         // Keys used by the HashMaps.
         Set<String> keys = jsonParams.keySet();
 
-        boolean isFileWrapper;
-
-        // Go over all keys and handle each's value.
-        for (String key : keys) {
-            // Evaluate the value (which cannot be null).
-            Object value = jsonParams.get(key);
-
-            // Bail out prematurely if value's null.
-            if (value == null) {
-                continue;
-            }
+        int keysCount = keys.size();
+        if (0 < keysCount) {
+            int keysProcessed = 0;
+            boolean isFileWrapper;
 
-            // Write the JSON object's key.
-            os.write(escape(key));
-            os.write(':');
+            // Go over all keys and handle each's value.
+            for (String key : keys) {
+                // Indicate that this key has been processed.
+                keysProcessed++;
 
-            // Check if this is a FileWrapper.
-            isFileWrapper = value instanceof RequestParams.FileWrapper;
+                try {
+                    // Evaluate the value (which cannot be null).
+                    Object value = jsonParams.get(key);
 
-            // If a file should be uploaded.
-            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
-                // All uploads are sent as an object containing the file's details.
-                os.write('{');
+                    // Write the JSON object's key.
+                    os.write(escape(key));
+                    os.write(':');
 
-                // Determine how to handle this entry.
-                if (isFileWrapper) {
-                    writeToFromFile(os, (RequestParams.FileWrapper) value);
-                } else {
-                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                    // Bail out prematurely if value's null.
+                    if (value == null) {
+                        os.write(JSON_NULL);
+                    } else {
+                        // Check if this is a FileWrapper.
+                        isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+                        // If a file should be uploaded.
+                        if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                            // All uploads are sent as an object containing the file's details.
+                            os.write('{');
+
+                            // Determine how to handle this entry.
+                            if (isFileWrapper) {
+                                writeToFromFile(os, (RequestParams.FileWrapper) value);
+                            } else {
+                                writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                            }
+
+                            // End the file's object and prepare for next one.
+                            os.write('}');
+                        } else if (value instanceof JsonValueInterface) {
+                            os.write(((JsonValueInterface) value).getEscapedJsonValue());
+                        } else if (value instanceof org.json.JSONObject) {
+                            os.write(((org.json.JSONObject) value).toString().getBytes());
+                        } else if (value instanceof org.json.JSONArray) {
+                            os.write(((org.json.JSONArray) value).toString().getBytes());
+                        } else if (value instanceof Boolean) {
+                            os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
+                        } else if (value instanceof Long) {
+                            os.write((((Number) value).longValue() + "").getBytes());
+                        } else if (value instanceof Double) {
+                            os.write((((Number) value).doubleValue() + "").getBytes());
+                        } else if (value instanceof Float) {
+                            os.write((((Number) value).floatValue() + "").getBytes());
+                        } else if (value instanceof Integer) {
+                            os.write((((Number) value).intValue() + "").getBytes());
+                        } else {
+                            os.write(escape(value.toString()));
+                        }
+                    }
+                } finally {
+                    // Separate each K:V with a comma, except the last one.
+                    if (elapsedField != null || keysProcessed < keysCount) {
+                        os.write(',');
+                    }
                 }
+            }
 
-                // End the file's object and prepare for next one.
-                os.write('}');
-            } else if (value instanceof JsonValueInterface) {
-                os.write(((JsonValueInterface) value).getEscapedJsonValue());
-            } else if (value instanceof org.json.JSONObject) {
-                os.write(((org.json.JSONObject) value).toString().getBytes());
-            } else if (value instanceof org.json.JSONArray) {
-                os.write(((org.json.JSONArray) value).toString().getBytes());
-            } else if (value instanceof Boolean) {
-                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
-            } else if (value instanceof Long) {
-                os.write((((Number) value).longValue() + "").getBytes());
-            } else if (value instanceof Double) {
-                os.write((((Number) value).doubleValue() + "").getBytes());
-            } else if (value instanceof Float) {
-                os.write((((Number) value).floatValue() + "").getBytes());
-            } else if (value instanceof Integer) {
-                os.write((((Number) value).intValue() + "").getBytes());
-            } else {
-                os.write(escape(value.toString()));
+            // Calculate how many milliseconds it took to upload the contents.
+            long elapsedTime = System.currentTimeMillis() - now;
+
+            // Include the elapsed time taken to upload everything.
+            // This might be useful for somebody, but it serves us well since
+            // there will almost always be a ',' as the last sent character.
+            if (elapsedField != null) {
+                os.write(elapsedField);
+                os.write(':');
+                os.write((elapsedTime + "").getBytes());
             }
 
-            os.write(',');
+            Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
         }
 
-        // Include the elapsed time taken to upload everything.
-        // This might be useful for somebody, but it serves us well since
-        // there will almost always be a ',' as the last sent character.
-        os.write(STREAM_ELAPSED);
-        os.write(':');
-        long elapsedTime = System.currentTimeMillis() - now;
-        os.write((elapsedTime + "}").getBytes());
-
-        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+        // Close the JSON object.
+        os.write('}');
 
         // Flush the contents up the stream.
         os.flush();
@@ -321,60 +340,57 @@ private void endMetaData(OutputStream os) throws IOException {
             return JSON_NULL;
         }
 
+        // Create a string builder to generate the escaped string.
+        StringBuilder sb = new StringBuilder(128);
+
         // Surround with quotations.
-        BUILDER.append('"');
+        sb.append('"');
 
         int length = string.length(), pos = -1;
         while (++pos < length) {
             char ch = string.charAt(pos);
             switch (ch) {
                 case '"':
-                    BUILDER.append("\\\"");
+                    sb.append("\\\"");
                     break;
                 case '\\':
-                    BUILDER.append("\\\\");
+                    sb.append("\\\\");
                     break;
                 case '\b':
-                    BUILDER.append("\\b");
+                    sb.append("\\b");
                     break;
                 case '\f':
-                    BUILDER.append("\\f");
+                    sb.append("\\f");
                     break;
                 case '\n':
-                    BUILDER.append("\\n");
+                    sb.append("\\n");
                     break;
                 case '\r':
-                    BUILDER.append("\\r");
+                    sb.append("\\r");
                     break;
                 case '\t':
-                    BUILDER.append("\\t");
+                    sb.append("\\t");
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
                     if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
-                        BUILDER.append("\\u");
+                        sb.append("\\u");
                         int intLength = 4 - intString.length();
                         for (int zero = 0; zero < intLength; zero++) {
-                            BUILDER.append('0');
+                            sb.append('0');
                         }
-                        BUILDER.append(intString.toUpperCase(Locale.US));
+                        sb.append(intString.toUpperCase(Locale.US));
                     } else {
-                        BUILDER.append(ch);
+                        sb.append(ch);
                     }
                     break;
             }
         }
 
         // Surround with quotations.
-        BUILDER.append('"');
-
-        try {
-            return BUILDER.toString().getBytes();
-        } finally {
-            // Empty the String buffer.
-            // This is 20-30% faster than instantiating a new object.
-            BUILDER.setLength(0);
-        }
+        sb.append('"');
+
+        return sb.toString().getBytes();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 28a7a93a..4c4ce49e 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -99,6 +99,7 @@
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
+    protected String elapsedFieldInJsonStreamer = "_elapsed";
     protected boolean autoCloseInputStreams;
     protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
     protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
@@ -412,12 +413,25 @@ public String toString() {
         return result.toString();
     }
 
-    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
-        this.isRepeatable = isRepeatable;
+    public void setHttpEntityIsRepeatable(boolean flag) {
+        this.isRepeatable = flag;
     }
 
-    public void setUseJsonStreamer(boolean useJsonStreamer) {
-        this.useJsonStreamer = useJsonStreamer;
+    public void setUseJsonStreamer(boolean flag) {
+        this.useJsonStreamer = flag;
+    }
+
+    /**
+     * Sets an additional field when upload a JSON object through the streamer
+     * to hold the time, in milliseconds, it took to upload the payload. By
+     * default, this field is set to "_elapsed".
+     *
+     * To disable this feature, call this method with null as the field value.
+     *
+     * @param value field name to add elapsed time, or null to disable
+     */
+    public void setElapsedFieldInJsonStreamer(String value) {
+        this.elapsedFieldInJsonStreamer = value;
     }
 
     /**
@@ -449,8 +463,10 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
     }
 
     private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
-                !fileParams.isEmpty() || !streamParams.isEmpty());
+        JsonStreamerEntity entity = new JsonStreamerEntity(
+            progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty(),
+            elapsedFieldInJsonStreamer);
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index 193f44fe..6660683c 100755
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -128,6 +128,22 @@
      */
     boolean getUseSynchronousMode();
 
+    /**
+     * Sets whether the handler should be executed on the pool's thread or the
+     * UI thread
+     *
+     * @param usePoolThread if the ResponseHandler should run on pool's thread
+     */
+    void setUsePoolThread(boolean usePoolThread);
+
+    /**
+     * Returns whether the handler should be executed on the pool's thread
+     * or the UI thread
+     *
+     * @return boolean if the ResponseHandler should run on pool's thread
+     */
+    boolean getUsePoolThread();
+
     /**
      * This method is called once by the system when the response is about to be
      * processed by the system. The library makes sure that a single response
diff --git a/library/src/main/java/com/loopj/android/http/AssertUtils.java b/library/src/main/java/com/loopj/android/http/Utils.java
similarity index 50%
rename from library/src/main/java/com/loopj/android/http/AssertUtils.java
rename to library/src/main/java/com/loopj/android/http/Utils.java
index ddd7c6e4..196d5a46 100644
--- a/library/src/main/java/com/loopj/android/http/AssertUtils.java
+++ b/library/src/main/java/com/loopj/android/http/Utils.java
@@ -19,16 +19,38 @@
 package com.loopj.android.http;
 
 /**
- * Internal class, used to make some asserts, throw AssertError if asserts fail.
+ * Provides general assert utils, which are stripped by Android SDK on
+ * compile/runtime, to work on release builds
  */
-class AssertUtils {
+class Utils {
 
-    private AssertUtils() {
+    private Utils() {
     }
 
+    /**
+     * Will throw AssertionError, if expression is not true
+     *
+     * @param expression    result of your asserted condition
+     * @param failedMessage message to be included in error log
+     * @throws java.lang.AssertionError
+     */
     public static void asserts(final boolean expression, final String failedMessage) {
         if (!expression) {
             throw new AssertionError(failedMessage);
         }
     }
+
+    /**
+     * Will throw IllegalArgumentException if provided object is null on runtime
+     *
+     * @param argument object that should be asserted as not null
+     * @param name     name of the object asserted
+     * @throws java.lang.IllegalArgumentException
+     */
+    public static <T> T notNull(final T argument, final String name) {
+        if (argument == null) {
+            throw new IllegalArgumentException(name + " should not be null!");
+        }
+        return argument;
+    }
 }
diff --git a/sample/build.gradle b/sample/build.gradle
index 3f4166a7..0d326e09 100755
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -1,11 +1,3 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:0.12.2'
-    }
-}
 apply plugin: 'com.android.application'
 
 repositories {
@@ -16,12 +8,12 @@ repositories {
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1'
+    compileSdkVersion 21
+    buildToolsVersion '21.1.2'
 
     defaultConfig {
         minSdkVersion 3
-        targetSdkVersion 19
+        targetSdkVersion 21
     }
 
     compileOptions {
@@ -45,6 +37,6 @@ android {
 }
 
 dependencies {
-    compile 'com.fasterxml.jackson.core:jackson-databind:2.2.3'
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.4.3'
     compile project(':library')
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index c3ebb2f1..1d180c46 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -11,16 +11,19 @@
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
+
         <activity android:name=".WaypointsActivity">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN"/>
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
+
         <activity android:name=".GetSample"/>
         <activity android:name=".PostSample"/>
         <activity android:name=".DeleteSample"/>
         <activity android:name=".PutSample"/>
+        <activity android:name=".PatchSample"/>
         <activity android:name=".JsonSample"/>
         <activity android:name=".JsonStreamerSample"/>
         <activity android:name=".FileSample"/>
@@ -32,6 +35,7 @@
         <activity android:name=".CancelRequestHandleSample"/>
         <activity android:name=".SynchronousClientSample"/>
         <activity android:name=".IntentServiceSample"/>
+
         <activity android:name=".SaxSample"/>
         <activity android:name=".FilesSample"/>
         <activity android:name=".PersistentCookiesSample"/>
@@ -44,8 +48,10 @@
         <activity android:name=".ResumeDownloadSample"/>
         <activity android:name=".PrePostProcessingSample"/>
         <activity android:name=".DigestAuthSample"/>
+        <activity android:name=".UsePoolThreadSample"/>
 
         <service android:name=".services.ExampleIntentService"/>
+
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
new file mode 100644
index 00000000..8bd8ab1e
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PatchSample.java
@@ -0,0 +1,68 @@
+package com.loopj.android.http.sample;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+public class PatchSample extends SampleParentActivity {
+
+	private static final String LOG_TAG = "PatchSample";
+	 
+	@Override
+	public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+		return client.patch(this, URL, entity, null, responseHandler);
+	}
+
+	@Override
+	public int getSampleTitle() {
+		return R.string.title_patch_sample;
+	}
+
+	@Override
+	public boolean isRequestBodyAllowed() {
+		return false;
+	}
+
+	@Override
+	public boolean isRequestHeadersAllowed() {
+		return false;
+	}
+
+	@Override
+	public String getDefaultURL() {
+		return PROTOCOL + "httpbin.org/patch";
+	}
+	
+	@Override
+	public ResponseHandlerInterface getResponseHandler() {
+		return new AsyncHttpResponseHandler() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugResponse(LOG_TAG, new String(response));
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, e);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, new String(errorResponse));
+                }
+            }
+        };
+	}
+
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
index 3daf055c..274b5e2b 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/RangeResponseSample.java
@@ -21,16 +21,19 @@
 import android.os.Bundle;
 import android.util.Log;
 import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.RangeFileAsyncHttpResponseHandler;
 import com.loopj.android.http.RequestHandle;
 import com.loopj.android.http.ResponseHandlerInterface;
-import java.io.File;
-import java.io.IOException;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.client.methods.HttpUriRequest;
 
+import java.io.File;
+import java.io.IOException;
+
 /**
  * This sample demonstrates use of {@link RangeFileAsyncHttpResponseHandler} to
  * download a remote file in multiple requests. While this response handler
@@ -71,7 +74,9 @@ protected void onDestroy() {
 
         // Remove temporary file.
         if (file != null) {
-            file.delete();
+            if (!file.delete()) {
+                Log.e(LOG_TAG, String.format("Couldn't remove temporary file in path: %s", file.getAbsolutePath()));
+            }
             file = null;
         }
     }
@@ -133,9 +138,9 @@ public void onSuccess(int statusCode, Header[] headers, File file) {
                     // Is the content length known?
                     if (!supportsRange || fileSize < 1) {
                         Toast.makeText(
-                            RangeResponseSample.this,
-                            "Unable to determine remote file's size, or\nremote server doesn't support ranges",
-                            Toast.LENGTH_LONG
+                                RangeResponseSample.this,
+                                "Unable to determine remote file's size, or\nremote server doesn't support ranges",
+                                Toast.LENGTH_LONG
                         ).show();
                     }
                 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java b/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java
new file mode 100644
index 00000000..45dd61fd
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/UsePoolThreadSample.java
@@ -0,0 +1,114 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+
+import java.io.File;
+
+public class UsePoolThreadSample extends GetSample {
+
+    private static final String LOG_TAG = "UsePoolThreadSample";
+
+    @Override
+    public String getDefaultURL() {
+        return PROTOCOL + "httpbin.org/bytes/1024000";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_use_pool_thread;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new UsePoolThreadResponseHandler();
+    }
+
+    private class UsePoolThreadResponseHandler extends AsyncHttpResponseHandler {
+
+        private final File destFile;
+
+        public UsePoolThreadResponseHandler() {
+            super();
+
+            // Destination file to save the downloaded bytes to.
+            destFile = getRandomCacheFile();
+            Log.d(LOG_TAG, "Bytes will be saved in file: " + destFile.getAbsolutePath());
+
+            // We wish to use the same pool thread to run the response.
+            setUsePoolThread(true);
+        }
+
+        @Override
+        public void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBody) {
+            // Response body includes 1MB of data, and it might take few
+            // milliseconds, maybe a second or two on old devices, to save it in
+            // the filesystem. However, since this callback method is running
+            // within the pool thread's execution scope, the UI thread will be
+            // relaxed to continue its work of updating the UI while this
+            // handler saves the bytes on disk.
+
+            // Save the response body's bytes on disk.
+            saveBytesOnDisk(destFile, responseBody);
+
+            // This callback is now running within the pool thread execution
+            // scope and not within Android's UI thread, so if we must update
+            // the UI, we'll have to dispatch a runnable to the UI thread.
+            runOnUiThread(new Runnable() {
+
+                @Override
+                public void run() {
+                    debugStatusCode(LOG_TAG, statusCode);
+                    debugHeaders(LOG_TAG, headers);
+                    if (responseBody != null) {
+                        addView(getColoredView(LIGHTGREEN, "Request succeeded (" + statusCode + "): (bytes=" + destFile.length() + "), path: " + destFile.getAbsolutePath()));
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void onFailure(final int statusCode, final Header[] headers, final byte[] responseBody, final Throwable error) {
+            // This callback is now running within the pool thread execution
+            // scope and not within Android's UI thread, so if we must update
+            // the UI, we'll have to dispatch a runnable to the UI thread.
+            runOnUiThread(new Runnable() {
+
+                @Override
+                public void run() {
+                    debugStatusCode(LOG_TAG, statusCode);
+                    debugHeaders(LOG_TAG, headers);
+                    debugThrowable(LOG_TAG, error);
+                    if (responseBody != null) {
+                        addView(getColoredView(LIGHTGREEN, "Download interrupted (" + statusCode + "): (bytes=" + responseBody.length + "), path: " + destFile.getAbsolutePath()));
+                    }
+                }
+            });
+        }
+
+        private File getRandomCacheFile() {
+            File dir = getCacheDir();
+            if (dir == null) {
+                dir = getFilesDir();
+            }
+
+            return new File(dir, "sample-" + System.currentTimeMillis() + ".bin");
+        }
+
+        private void saveBytesOnDisk(File destination, byte[] bytes) {
+            // TODO: Spin your own implementation to save the bytes on disk/SD card.
+            if (bytes != null && destination != null) {
+                Log.d(LOG_TAG, "Saved " + bytes.length + " bytes into file: " + destination.getAbsolutePath());
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 099dc134..23ad8764 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -35,6 +35,7 @@
             new SampleConfig(R.string.title_post_sample, PostSample.class),
             new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
             new SampleConfig(R.string.title_put_sample, PutSample.class),
+            new SampleConfig(R.string.title_patch_sample, PatchSample.class),
             new SampleConfig(R.string.title_json_sample, JsonSample.class),
             new SampleConfig(R.string.title_json_streamer_sample, JsonStreamerSample.class),
             new SampleConfig(R.string.title_sax_example, SaxSample.class),
@@ -56,7 +57,8 @@
             new SampleConfig(R.string.title_pre_post_processing, PrePostProcessingSample.class),
             new SampleConfig(R.string.title_content_type_http_entity, ContentTypeForHttpEntitySample.class),
             new SampleConfig(R.string.title_resume_download, ResumeDownloadSample.class),
-            new SampleConfig(R.string.title_digest_auth, DigestAuthSample.class)
+            new SampleConfig(R.string.title_digest_auth, DigestAuthSample.class),
+            new SampleConfig(R.string.title_use_pool_thread, UsePoolThreadSample.class)
     };
 
     @Override
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
old mode 100755
new mode 100644
index 96a442e5..d95d16f9
Binary files a/sample/src/main/res/drawable-hdpi/ic_launcher.png and b/sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
old mode 100755
new mode 100644
index 359047df..75b78337
Binary files a/sample/src/main/res/drawable-mdpi/ic_launcher.png and b/sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
old mode 100755
new mode 100644
index 71c6d760..52a6abdd
Binary files a/sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..d75067ca
Binary files /dev/null and b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
new file mode 100644
index 00000000..927c4a26
Binary files /dev/null and b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index f8465168..83bb24e4 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -21,6 +21,7 @@
     <string name="title_json_streamer_sample">POST JSON using streamer</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
+    <string name="title_patch_sample">PATCH</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
@@ -43,4 +44,5 @@
     <string name="title_content_type_http_entity">Content-Type with HttpEntity</string>
     <string name="title_resume_download">Resuming Download</string>
     <string name="title_digest_auth">Digest Authentication</string>
+    <string name="title_use_pool_thread">Use Pool Thread in Response</string>
 </resources>
