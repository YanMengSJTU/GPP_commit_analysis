diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index abaf6ee5..eeb9485d 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -19,8 +19,8 @@
 package com.loopj.android.http;
 
 import android.content.Context;
-import com.loopj.android.http.methods.HttpPatch;
 import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
@@ -69,6 +69,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -76,16 +77,6 @@
 
 
 /**
- * The ouwjngaiosjaeos0~gaeopw~sn+~opgawnp+oiajn~+hips~+hrop+fdsgdsgfddfggfdgfddfgdfgfdfggdfdgfdgfdfgdfgdfgdgfdfgdgfdfg
- * dfg
- * AsyncHttpClient can be used to make asynchronous GET, POST, PUT and
- * DELETE HTTP requests in your Android applications. Requests can be made
- * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden
- * {@link AsyncHttpResponseHandler} instance.
- * <p>&nbsp;</p>
- * For example:
- * <p>&nbsp;</p>
  * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and DELETE HTTP requests in
  * your Android applications. Requests can be made with additional parameters by passing a {@link
  * RequestParams} instance, and responses can be handled by passing an anonymously overridden {@link
@@ -101,23 +92,23 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.5";
 
-    private static final int DEFAULT_MAX_CONNECTIONS = 10;
-    private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
-    private static final int DEFAULT_MAX_RETRIES = 5;
-    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
-    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
-    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
-    private static final String ENCODING_GZIP = "gzip";
-    private static final String LOG_TAG = "AsyncHttpClient";
+    public static final String VERSION = "1.4.5";
+    public static final int DEFAULT_MAX_CONNECTIONS = 10;
+    public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
+    public static final int DEFAULT_MAX_RETRIES = 5;
+    public static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
+    public static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+    public static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    public static final String ENCODING_GZIP = "gzip";
+    public static final String LOG_TAG = "AsyncHttpClient";
 
     private int maxConnections = DEFAULT_MAX_CONNECTIONS;
     private int timeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
-    private ThreadPoolExecutor threadPool;
+    private ExecutorService threadPool;
     private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
     private final Map<String, String> clientHeaderMap;
     private boolean isUrlEncodingEnabled = true;
@@ -219,7 +210,7 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(DEFAULT_MAX_CONNECTIONS);
+        threadPool = Executors.newCachedThreadPool();
         requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
         clientHeaderMap = new HashMap<String, String>();
 
@@ -259,6 +250,18 @@ public void process(HttpResponse response, HttpContext context) {
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
+    public static void allowRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToWhitelist(cls);
+        }
+    }
+
+    public static void blockRetryExceptionClass(Class<?> cls) {
+        if (cls != null) {
+            RetryHandler.addClassToBlacklist(cls);
+        }
+    }
+
     /**
      * Get the underlying HttpClient instance. This is useful for setting additional fine-grained
      * settings for requests by accessing the client's ConnectionManager, HttpParams and
@@ -497,9 +500,7 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         requestMap.remove(context);
     }
 
-    //
-    // HTTP HEAD Requests
-    //
+    // [+] HTTP HEAD
 
     /**
      * Perform a HTTP HEAD request, without any parameters.
@@ -568,10 +569,8 @@ public RequestHandle head(Context context, String url, Header[] headers, Request
                 context);
     }
 
-
-    //
-    // HTTP GET Requests
-    //
+    // [-] HTTP HEAD
+    // [+] HTTP GET
 
     /**
      * Perform a HTTP GET request, without any parameters.
@@ -640,10 +639,8 @@ public RequestHandle get(Context context, String url, Header[] headers, RequestP
                 context);
     }
 
-
-    //
-    // HTTP POST Requests
-    //
+    // [-] HTTP GET
+    // [+] HTTP POST
 
     /**
      * Perform a HTTP POST request, without any parameters.
@@ -742,9 +739,8 @@ public RequestHandle post(Context context, String url, Header[] headers, HttpEnt
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP PUT Requests
-    //
+    // [-] HTTP POST
+    // [+] HTTP PUT
 
     /**
      * Perform a HTTP PUT request, without any parameters.
@@ -821,32 +817,8 @@ public RequestHandle put(Context context, String url, Header[] headers, HttpEnti
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
-    //
-    // HTTP PATCH Requests
-    //
-
-    public void patch(String url, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, null, responseHandler);
-    }
-
-    public void patch(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(null, url, params, responseHandler);
-    }
-
-    public void patch(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
-    }
-
-    public void patch( Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler )
-    {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase( new HttpPatch(url), entity);
-        if(headers != null) request.setHeaders(headers);
-        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
-    }
-
-    //
-    // HTTP DELETE Requests
-    //
+    // [-] HTTP PUT
+    // [+] HTTP DELETE
 
     /**
      * Perform a HTTP DELETE request.
@@ -903,6 +875,8 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
+    // [-] HTTP DELETE
+
     /**
      * Puts a new request in queue as a new thread in pool to be executed
      *
@@ -1036,4 +1010,4 @@ public long getContentLength() {
             return -1;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index d6c36f2a..55791f18 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -30,6 +30,9 @@
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
 
+/**
+ * Internal class, representing the HttpRequest, done in asynchronous manner
+ */
 class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
@@ -55,6 +58,8 @@ public void run() {
         } catch (IOException e) {
             if (responseHandler != null) {
                 responseHandler.sendFailureMessage(0, null, null, e);
+            } else {
+                Log.e("AsyncHttpRequest", "makeRequestWithRetries returned error, but handler is null", e);
             }
         }
 
@@ -107,7 +112,7 @@ private void makeRequestWithRetries() throws IOException {
                     retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
                 if (retry && (responseHandler != null)) {
-                    responseHandler.sendRetryMessage();
+                    responseHandler.sendRetryMessage(executionCount);
                 }
             }
         } catch (Exception e) {
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 58371eca..b16e4213 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -32,7 +32,6 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.ref.WeakReference;
 import java.net.URI;
 
@@ -41,7 +40,7 @@
  * {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is designed to be anonymously
  * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
  * {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)}, {@link #onStart()}, {@link
- * #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
+ * #onFinish()}, {@link #onRetry(int)} and {@link #onProgress(int, int)} methods as required.
  * <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
@@ -57,7 +56,8 @@
  *     }
  *
  *     &#064;Override
- *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error)
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
  * {
  *         // Response failed :(
  *     }
@@ -79,7 +79,7 @@
  * });
  * </pre>
  */
-public class AsyncHttpResponseHandler implements ResponseHandlerInterface {
+public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface {
     private static final String LOG_TAG = "AsyncHttpResponseHandler";
 
     protected static final int SUCCESS_MESSAGE = 0;
@@ -119,8 +119,9 @@ public void setRequestHeaders(Header[] requestHeaders) {
         this.requestHeaders = requestHeaders;
     }
 
-    // avoid leaks by using a non-anonymous handler class
-    // with a weak reference
+    /**
+     * Avoid leaks by using a non-anonymous handler class with a weak reference
+     */
     static class ResponderHandler extends Handler {
         private final WeakReference<AsyncHttpResponseHandler> mResponder;
 
@@ -137,8 +138,9 @@ public void handleMessage(Message msg) {
         }
     }
 
+    @Override
     public boolean getUseSynchronousMode() {
-        return (useSynchronousMode);
+        return useSynchronousMode;
     }
 
     @Override
@@ -170,11 +172,6 @@ public AsyncHttpResponseHandler() {
         }
     }
 
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
     /**
      * Fired when the request progress, override to handle in your own code
      *
@@ -182,6 +179,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
+        Log.d(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
     }
 
     /**
@@ -197,41 +195,6 @@ public void onStart() {
     public void onFinish() {
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param content the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(String content) {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, Header[] headers, String content) {
-        onSuccess(statusCode, content);
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param content    the body of the HTTP response from the server
-     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
-     */
-    @Deprecated
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
-    }
-
     /**
      * Fired when a request returns successfully, override to handle in your own code
      *
@@ -239,67 +202,7 @@ public void onSuccess(int statusCode, String content) {
      * @param headers      return headers, if any
      * @param responseBody the body of the HTTP response from the server
      */
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, e, null);
-        }
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error) {
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param error   the underlying cause of the failure
-     * @param content the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Throwable error, String content) {
-        // By default, call the chain method onFailure(Throwable,String)
-        onFailure(error, content);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode return HTTP status code
-     * @param headers    return headers, if any
-     * @param error      the underlying cause of the failure
-     * @param content    the response body, if any
-     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
-     */
-    @Deprecated
-    public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // By default, call the chain method onFailure(int,Throwable,String)
-        onFailure(statusCode, error, content);
-    }
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] responseBody);
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
@@ -309,37 +212,27 @@ public void onFailure(int statusCode, Header[] headers, Throwable error, String
      * @param responseBody the response body, if any
      * @param error        the underlying cause of the failure
      */
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, error, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, e.toString());
-            onFailure(statusCode, headers, error, null);
-        }
-    }
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error);
 
     /**
      * Fired when a retry occurs, override to handle in your own code
+     *
+     * @param retryNo number of retry
      */
-    public void onRetry() {
+    public void onRetry(int retryNo) {
+        Log.d(LOG_TAG, String.format("Request retry no. %d", retryNo));
     }
 
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
     final public void sendProgressMessage(int bytesWritten, int bytesTotal) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, bytesTotal}));
     }
 
-    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
+    final public void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBytes) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBytes}));
     }
 
-    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
+    final public void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));
     }
 
     final public void sendStartMessage() {
@@ -350,17 +243,17 @@ final public void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-    final public void sendRetryMessage() {
-        sendMessage(obtainMessage(RETRY_MESSAGE, null));
+    final public void sendRetryMessage(int retryNo) {
+        sendMessage(obtainMessage(RETRY_MESSAGE, new Object[]{retryNo}));
     }
 
     // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
+    protected void handleMessage(Message message) {
         Object[] response;
 
-        switch (msg.what) {
+        switch (message.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 3) {
                     onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
                 } else {
@@ -368,7 +261,7 @@ protected void handleMessage(Message msg) {
                 }
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 4) {
                     onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
                 } else {
@@ -382,7 +275,7 @@ protected void handleMessage(Message msg) {
                 onFinish();
                 break;
             case PROGRESS_MESSAGE:
-                response = (Object[]) msg.obj;
+                response = (Object[]) message.obj;
                 if (response != null && response.length >= 2) {
                     try {
                         onProgress((Integer) response[0], (Integer) response[1]);
@@ -394,7 +287,11 @@ protected void handleMessage(Message msg) {
                 }
                 break;
             case RETRY_MESSAGE:
-                onRetry();
+                response = (Object[]) message.obj;
+                if (response != null && response.length == 1)
+                    onRetry((Integer) response[0]);
+                else
+                    Log.e(LOG_TAG, "RETRY_MESSAGE didn't get enough params");
                 break;
         }
     }
@@ -407,21 +304,33 @@ protected void sendMessage(Message msg) {
         }
     }
 
-    protected void postRunnable(Runnable r) {
-        if (r != null) {
-            handler.post(r);
+    /**
+     * Helper method to send runnable into local handler loop
+     *
+     * @param runnable runnable instance, can be null
+     */
+    protected void postRunnable(Runnable runnable) {
+        if (runnable != null) {
+            handler.post(runnable);
         }
     }
 
-    protected Message obtainMessage(int responseMessage, Object response) {
+    /**
+     * Helper method to create Message instance from handler
+     *
+     * @param responseMessageId   constant to identify Handler message
+     * @param responseMessageData object to be passed to message receiver
+     * @return Message instance, should not be null
+     */
+    protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
         Message msg;
         if (handler != null) {
-            msg = handler.obtainMessage(responseMessage, response);
+            msg = handler.obtainMessage(responseMessageId, responseMessageData);
         } else {
             msg = Message.obtain();
             if (msg != null) {
-                msg.what = responseMessage;
-                msg.obj = response;
+                msg.what = responseMessageId;
+                msg.obj = responseMessageData;
             }
         }
         return msg;
@@ -445,6 +354,13 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
         }
     }
 
+    /**
+     * Returns byte array of response HttpEntity contents
+     *
+     * @param entity can be null
+     * @return response entity body or null
+     * @throws java.io.IOException if reading entity or creating byte array failed
+     */
     byte[] getResponseData(HttpEntity entity) throws IOException {
         byte[] responseBody = null;
         if (entity != null) {
@@ -454,11 +370,9 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                if (contentLength < 0) {
-                    contentLength = BUFFER_SIZE;
-                }
+                int buffersize =  (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
-                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) buffersize);
                     try {
                         byte[] tmp = new byte[BUFFER_SIZE];
                         int l, count = 0;
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
new file mode 100644
index 00000000..e9bc1809
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of
+ * binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
+ * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end
+     * of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output
+     * will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a
+     * CRLF pair instead of just an LF.  Has no effect if {@code
+     * NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and
+     * filename safe" variant of Base64 (see RFC 3548 section 4) where
+     * {@code -} and {@code _} are used in place of {@code +} and
+     * {@code /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link Base64OutputStream} to indicate that it
+     * should not close the output stream it is wrapping when it
+     * itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is
+         * provided by the caller, and must be big enough to hold all
+         * the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for
+         *        this object.  Will finalize the coder state and
+         *        include any final bytes in the output.
+         *
+         * @return true if the input so far is good; false if some
+         *         error has been detected in the input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process()
+         * could produce for the given number of input bytes.  This may
+         * be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param str    the input String to decode, which is converted to
+     *               bytes using the default charset
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the
+         * Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548
+         * sec. 4) where - and _ replace + and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /** Non-data values in the DECODE arrays. */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple.
+         * State 4 is having read one '=' and expecting exactly
+         * one more.
+         * State 5 is expecting no more data or padding characters
+         * in the input.
+         * State 6 is the error state; an error has been detected
+         * in the input and no future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3/4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if
+         *         bad base-64 data has been detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p+4 <= len &&
+                           (value = ((alphabet[input[p] & 0xff] << 18) |
+                                     (alphabet[input[p+1] & 0xff] << 12) |
+                                     (alphabet[input[p+2] & 0xff] << 6) |
+                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                case 0:
+                    if (d >= 0) {
+                        value = d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 1:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 2:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect exactly one more padding character.
+                        output[op++] = (byte) (value >> 4);
+                        state = 4;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 3:
+                    if (d >= 0) {
+                        // Emit the output triple and return to state 0.
+                        value = (value << 6) | d;
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        state = 0;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect no further data or padding characters.
+                        output[op+1] = (byte) (value >> 2);
+                        output[op] = (byte) (value >> 10);
+                        op += 2;
+                        state = 5;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 4:
+                    if (d == EQUALS) {
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 5:
+                    if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+            case 0:
+                // Output length is a multiple of three.  Fine.
+                break;
+            case 1:
+                // Read one extra input byte, which isn't enough to
+                // make another output byte.  Illegal.
+                this.state = 6;
+                return false;
+            case 2:
+                // Read two extra input bytes, enough to emit 1 more
+                // output byte.  Fine.
+                output[op++] = (byte) (value >> 4);
+                break;
+            case 3:
+                // Read three extra input bytes, enough to emit 2 more
+                // output bytes.  Fine.
+                output[op++] = (byte) (value >> 10);
+                output[op++] = (byte) (value >> 2);
+                break;
+            case 4:
+                // Read one padding '=' when we expected 2.  Illegal.
+                this.state = 6;
+                return false;
+            case 5:
+                // Read all the padding '='s we expected and no more.
+                // Fine.
+                break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0: break;
+                case 1: output_len += 2; break;
+                case 2: output_len += 3; break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        assert encoder.op == output_len;
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to
+         * a 76-character line length (the maximum allowable according to
+         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8/5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p+2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((input[p++] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+
+                case 2:
+                    if (p+1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((tail[1] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p+3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                    ((input[p+1] & 0xff) << 8) |
+                    (input[p+2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op+1] = alphabet[(v >> 12) & 0x3f];
+                output[op+2] = alphabet[(v >> 6) & 0x3f];
+                output[op+3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p-tailLen == len-1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p-tailLen == len-2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                assert tailLen == 0;
+                assert p == len;
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len-1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len-2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p+1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() { }   // don't instantiate
+}
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
new file mode 100644
index 00000000..ead54c56
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -0,0 +1,9 @@
+package com.loopj.android.http;
+
+import java.io.IOException;
+
+public class Base64DataException extends IOException {
+    public Base64DataException(String detailMessage) {
+        super(detailMessage);
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
new file mode 100644
index 00000000..61afb931
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -0,0 +1,130 @@
+package com.loopj.android.http;
+
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class Base64OutputStream extends FilterOutputStream {
+    private final Base64.Coder coder;
+    private final int flags;
+
+    private byte[] buffer = null;
+    private int bpos = 0;
+
+    private static byte[] EMPTY = new byte[0];
+
+    /**
+     * Performs Base64 encoding on the data written to the stream, writing the encoded data to
+     * another OutputStream.
+     *
+     * @param out   the OutputStream to write the encoded data to
+     * @param flags bit flags for controlling the encoder; see the constants in {@link Base64}
+     */
+    public Base64OutputStream(OutputStream out, int flags) {
+        this(out, flags, true);
+    }
+
+    /**
+     * Performs Base64 encoding or decoding on the data written to the stream, writing the
+     * encoded/decoded data to another OutputStream.
+     *
+     * @param out    the OutputStream to write the encoded data to
+     * @param flags  bit flags for controlling the encoder; see the constants in {@link Base64}
+     * @param encode true to encode, false to decode
+     */
+    public Base64OutputStream(OutputStream out, int flags, boolean encode) {
+        super(out);
+        this.flags = flags;
+        if (encode) {
+            coder = new Base64.Encoder(flags, null);
+        } else {
+            coder = new Base64.Decoder(flags, null);
+        }
+    }
+
+    public void write(int b) throws IOException {
+        // To avoid invoking the encoder/decoder routines for single
+        // bytes, we buffer up calls to write(int) in an internal
+        // byte array to transform them into writes of decently-sized
+        // arrays.
+
+        if (buffer == null) {
+            buffer = new byte[1024];
+        }
+        if (bpos >= buffer.length) {
+            // internal buffer full; write it out.
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+        buffer[bpos++] = (byte) b;
+    }
+
+    /**
+     * Flush any buffered data from calls to write(int).  Needed before doing a write(byte[], int,
+     * int) or a close().
+     */
+    private void flushBuffer() throws IOException {
+        if (bpos > 0) {
+            internalWrite(buffer, 0, bpos, false);
+            bpos = 0;
+        }
+    }
+
+    public void write(byte[] b, int off, int len) throws IOException {
+        if (len <= 0) return;
+        flushBuffer();
+        internalWrite(b, off, len, false);
+    }
+
+    public void close() throws IOException {
+        IOException thrown = null;
+        try {
+            flushBuffer();
+            internalWrite(EMPTY, 0, 0, true);
+        } catch (IOException e) {
+            thrown = e;
+        }
+
+        try {
+            if ((flags & Base64.NO_CLOSE) == 0) {
+                out.close();
+            } else {
+                out.flush();
+            }
+        } catch (IOException e) {
+            if (thrown != null) {
+                thrown = e;
+            }
+        }
+
+        if (thrown != null) {
+            throw thrown;
+        }
+    }
+
+    /**
+     * Write the given bytes to the encoder/decoder.
+     *
+     * @param finish true if this is the last batch of input, to cause encoder/decoder state to be
+     *               finalized.
+     */
+    private void internalWrite(byte[] b, int off, int len, boolean finish) throws IOException {
+        coder.output = embiggen(coder.output, coder.maxOutputSize(len));
+        if (!coder.process(b, off, len, finish)) {
+            throw new Base64DataException("bad base-64");
+        }
+        out.write(coder.output, 0, coder.op);
+    }
+
+    /**
+     * If b.length is at least len, return b.  Otherwise return a new byte array of length len.
+     */
+    private byte[] embiggen(byte[] b, int len) {
+        if (b == null || b.length < len) {
+            return new byte[len];
+        } else {
+            return b;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
index c9a89091..03f98345 100644
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -23,91 +23,65 @@
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
 
+/**
+ * Class meant to be used with custom JSON parser (such as GSON or Jackson JSON) <p>&nbsp;</p>
+ * {@link #parseResponse(String, boolean)} should be overriden and must return type of generic param
+ * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
+ * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
+ * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates a new JsonHttpResponseHandler with default charset "UTF-8"
      */
-
     public BaseJsonHttpResponseHandler() {
-        super(DEFAULT_CHARSET);
+        this(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates a new JsonHttpResponseHandler with given string encoding
+     *
+     * @param encoding result string encoding, see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
     public BaseJsonHttpResponseHandler(String encoding) {
         super(encoding);
     }
 
-    @Override
-    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        // Disabling this method
-        super.onSuccess(statusCode, headers, responseBody);
-    }
-
-    @Override
-    public final void onSuccess(String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(content);
-    }
-
-    @Override
-    public final void onSuccess(int statusCode, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onSuccess(statusCode, content);
-    }
-
-    @Override
-    public final void onFailure(String responseBody, Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        //Disabling this method
-        super.onFailure(statusCode, headers, responseBody, error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error);
-    }
-
-    @Override
-    public final void onFailure(Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, error, content);
-    }
-
-    @Override
-    public final void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
-        // Disabling usage of this method, until removed from parent
-        super.onFailure(statusCode, headers, error, content);
-    }
-
-    public abstract void onSuccess(int statusCode, Header[] headers, String rawResponse, JSON_TYPE response);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode      HTTP status line
+     * @param headers         response headers
+     * @param rawJsonResponse string of response, can be null
+     * @param response        response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, JSON_TYPE response);
 
-    public abstract void onFailure(int statusCode, Header[] headers, Throwable e, String rawData, JSON_TYPE errorResponse);
+    /**
+     * Base abstract method, handling defined generic type
+     *
+     * @param statusCode    HTTP status line
+     * @param headers       response headers
+     * @param throwable     error thrown while processing request
+     * @param rawJsonData   raw string data returned if any
+     * @param errorResponse response returned by {@link #parseResponse(String, boolean)}
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, JSON_TYPE errorResponse);
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, false);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onSuccess(statusCode, headers, responseBody, jsonResponse);
+                                onSuccess(statusCode, headers, responseString, jsonResponse);
                             }
                         });
                     } catch (final Throwable t) {
@@ -115,7 +89,7 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, t, responseBody, null);
+                                onFailure(statusCode, headers, t, responseString, null);
                             }
                         });
                     }
@@ -127,17 +101,17 @@ public void run() {
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
+    public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
+        if (responseString != null) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final JSON_TYPE jsonResponse = parseResponse(responseBody);
+                        final JSON_TYPE jsonResponse = parseResponse(responseString, true);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, jsonResponse);
+                                onFailure(statusCode, headers, throwable, responseString, jsonResponse);
                             }
                         });
                     } catch (Throwable t) {
@@ -145,16 +119,25 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody, null);
+                                onFailure(statusCode, headers, throwable, responseString, null);
                             }
                         });
                     }
                 }
             }).start();
         } else {
-            onFailure(statusCode, headers, e, null, null);
+            onFailure(statusCode, headers, throwable, null, null);
         }
     }
 
-    protected abstract JSON_TYPE parseResponse(String responseBody) throws Throwable;
+    /**
+     * Should return deserialized instance of generic type, may return object for more vague
+     * handling
+     *
+     * @param rawJsonData response string, may be null
+     * @param isFailure   indicating if this method is called from onFailure or not
+     * @return object of generic type or possibly null if you choose so
+     * @throws Throwable allows you to throw anything from within deserializing JSON response
+     */
+    protected abstract JSON_TYPE parseResponse(String rawJsonData, boolean isFailure) throws Throwable;
 }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index ce475850..d8bd16cc 100644
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -50,7 +50,9 @@
  * });
  * </pre>
  */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+public abstract class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private static final String LOG_TAG = "BinaryHttpResponseHandler";
 
     private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
@@ -81,65 +83,19 @@ public BinaryHttpResponseHandler() {
      * @param allowedContentTypes content types array, eg. 'image/jpeg' or pattern '.*'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {
-    }
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
+        super();
+        if (allowedContentTypes != null)
+            mAllowedContentTypes = allowedContentTypes;
+        else
+            Log.e(LOG_TAG, "Constructor passed allowedContentTypes was null !");
     }
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     */
-
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] binaryData) {
-        onSuccess(statusCode, binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param binaryData the response body, if any
-     * @param error      the underlying cause of the failure
-     */
+    public abstract void onSuccess(int statusCode, Header[] headers, byte[] binaryData);
 
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error) {
-        onFailure(statusCode, error, null);
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
+    public abstract void onFailure(int statusCode, Header[] headers, byte[] binaryData, Throwable error);
 
-    // Interface to AsyncHttpRequest
     @Override
     public final void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 51177c93..6223890e 100644
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -12,75 +12,99 @@
 import java.io.InputStream;
 
 
-public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
     private File mFile;
     private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
 
+    /**
+     * Obtains new FileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
     public FileAsyncHttpResponseHandler(File file) {
         super();
         assert (file != null);
         this.mFile = file;
     }
 
-    public FileAsyncHttpResponseHandler(Context c) {
+    /**
+     * Obtains new FileAsyncHttpResponseHandler against context with target being temporary file
+     *
+     * @param context Context, must not be null
+     */
+    public FileAsyncHttpResponseHandler(Context context) {
         super();
-        assert (c != null);
-        this.mFile = getTemporaryFile(c);
+        this.mFile = getTemporaryFile(context);
     }
 
-    protected File getTemporaryFile(Context c) {
+    /**
+     * Attempts to delete file with stored response
+     *
+     * @return false if the file does not exist or is null, true if it was successfully deleted
+     */
+    public boolean deleteTargetFile() {
+        return getTargetFile() != null && getTargetFile().delete();
+    }
+
+    /**
+     * Used when there is no file to be used when calling constructor
+     *
+     * @param context Context, must not be null
+     * @return temporary file or null if creating file failed
+     */
+    protected File getTemporaryFile(Context context) {
+        assert (context != null);
         try {
-            return File.createTempFile("temp_", "_handled", c.getCacheDir());
+            return File.createTempFile("temp_", "_handled", context.getCacheDir());
         } catch (Throwable t) {
             Log.e(LOG_TAG, "Cannot create temporary file", t);
         }
         return null;
     }
 
+    /**
+     * Retrieves File object in which the response is stored
+     *
+     * @return File file in which the response is stored
+     */
     protected File getTargetFile() {
         assert (mFile != null);
         return mFile;
     }
 
-    public void onSuccess(File file) {
-    }
-
-    public void onSuccess(int statusCode, File file) {
-        onSuccess(file);
-    }
-
-    public void onSuccess(int statusCode, Header[] headers, File file) {
-        onSuccess(statusCode, file);
-    }
-
-    public void onFailure(Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e);
-    }
-
-    public void onFailure(int statusCode, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(e, response);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
-        // By default call lower chain method
-        onFailure(statusCode, e, response);
-    }
-
     @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
-        onFailure(statusCode, headers, error, getTargetFile());
+    public final void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, throwable, getTargetFile());
     }
 
+    /**
+     * Method to be overriden, receives as much of file as possible Called when the file is
+     * considered failure or if there is error when retrieving file
+     *
+     * @param statusCode http file status line
+     * @param headers    file http headers if any
+     * @param throwable  returned throwable
+     * @param file       file in which the file is stored
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, Throwable throwable, File file);
+
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+    public final void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
         onSuccess(statusCode, headers, getTargetFile());
     }
 
+    /**
+     * Method to be overriden, receives as much of response as possible
+     *
+     * @param statusCode http response status line
+     * @param headers    response http headers if any
+     * @param file       file in which the response is stored
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, File file);
+
     @Override
-    byte[] getResponseData(HttpEntity entity) throws IOException {
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
         if (entity != null) {
             InputStream instream = entity.getContent();
             long contentLength = entity.getContentLength();
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
index d48ded5d..4ef8c9f9 100644
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -30,126 +30,94 @@
 /**
  * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}, with
  * automatic parsing into a {@link JSONObject} or {@link JSONArray}. <p>&nbsp;</p> This class is
- * designed to be passed to get, post, put and delete requests with the {@link
- * #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)} methods anonymously overridden.
- * <p>&nbsp;</p> Additionally, you can override the other event methods from the parent class.
+ * designed to be passed to get, post, put and delete requests with the {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONArray)} or {@link #onSuccess(int,
+ * org.apache.http.Header[], org.json.JSONObject)} methods anonymously overridden. <p>&nbsp;</p>
+ * Additionally, you can override the other event methods from the parent class.
  */
 public class JsonHttpResponseHandler extends TextHttpResponseHandler {
     private static final String LOG_TAG = "JsonHttpResponseHandler";
 
     /**
-     * Creates a new JsonHttpResponseHandler
+     * Creates new JsonHttpResponseHandler, with Json String encoding UTF-8
      */
-
     public JsonHttpResponseHandler() {
         super(DEFAULT_CHARSET);
     }
 
-    public JsonHttpResponseHandler(String encoding) {
-        super(encoding);
-    }
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
-     *
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {
-    }
-
-
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Creates new JsonHttpRespnseHandler with given Json String encoding
      *
-     * @param response the parsed json array found in the server response (if any)
+     * @param encoding String encoding to be used when parsing JSON
      */
-    public void onSuccess(JSONArray response) {
+    public JsonHttpResponseHandler(String encoding) {
+        super(encoding);
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
-        onSuccess(statusCode, response);
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json object at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request succeeds
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json object found in the server response (if any)
+     * @param statusCode http response status line
+     * @param headers    response headers if any
+     * @param response   parsed response if any
      */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
+    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param headers    the headers of the HTTP response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
-        onSuccess(statusCode, response);
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
+
     }
 
     /**
-     * Fired when a request returns successfully and contains a json array at the base of the
-     * response string. Override to handle in your own code.
+     * Returns when request failed
      *
-     * @param statusCode the status code of the response
-     * @param response   the parsed json array found in the server response (if any)
+     * @param statusCode    http response status line
+     * @param headers       response headers if any
+     * @param throwable     throwable describing the way request failed
+     * @param errorResponse parsed response if any
      */
-    public void onSuccess(int statusCode, JSONArray response) {
-        onSuccess(response);
-    }
+    public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
 
-    public void onFailure(Throwable e, JSONObject errorResponse) {
-        onFailure(e);
     }
 
-    public void onFailure(int statusCode, Throwable e, JSONObject errorResponse) {
-        onFailure(e, errorResponse);
-    }
-
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONObject errorResponse) {
-        onFailure(statusCode, e, errorResponse);
-    }
+    @Override
+    public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
 
-    public void onFailure(Throwable e, JSONArray errorResponse) {
-        onFailure(e);
     }
 
-    public void onFailure(int statusCode, Throwable e, JSONArray errorResponse) {
-        onFailure(e, errorResponse);
-    }
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseString) {
 
-    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray errorResponse) {
-        onFailure(statusCode, e, errorResponse);
     }
 
     @Override
-    public void onSuccess(final int statusCode, final Header[] headers, final String responseBody) {
+    public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -157,10 +125,8 @@ public void run() {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
-                                } else if (jsonResponse instanceof String) {
-                                    onSuccess(statusCode, headers, (String) jsonResponse);
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
 
                             }
@@ -169,7 +135,7 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(ex, (JSONObject) null);
+                                onFailure(statusCode, headers, ex, (JSONObject) null);
                             }
                         });
                     }
@@ -181,24 +147,24 @@ public void run() {
     }
 
     @Override
-    public void onFailure(final int statusCode, final Header[] headers, final String responseBody, final Throwable e) {
-        if (responseBody != null) {
+    public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
+        if (responseBytes != null) {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        final Object jsonResponse = parseResponse(responseBody);
+                        final Object jsonResponse = parseResponse(responseBytes);
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 if (jsonResponse instanceof JSONObject) {
-                                    onFailure(statusCode, headers, e, (JSONObject) jsonResponse);
+                                    onFailure(statusCode, headers, throwable, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
-                                    onFailure(statusCode, headers, e, (JSONArray) jsonResponse);
+                                    onFailure(statusCode, headers, throwable, (JSONArray) jsonResponse);
                                 } else if (jsonResponse instanceof String) {
-                                    onFailure(statusCode, headers, e, (String) jsonResponse);
+                                    onFailure(statusCode, headers, (String) jsonResponse, throwable);
                                 } else {
-                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                    onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
                             }
                         });
@@ -216,18 +182,29 @@ public void run() {
             }).start();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
-            onFailure(statusCode, headers, e, (JSONObject) null);
+            onFailure(statusCode, headers, throwable, (JSONObject) null);
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
+    /**
+     * Returns Object of type {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
+     * Double or {@link JSONObject#NULL}, see {@link org.json.JSONTokener#nextValue()}
+     *
+     * @param responseBody response bytes to be assembled in String and parsed as JSON
+     * @return Object parsedResponse
+     * @throws org.json.JSONException exception if thrown while parsing JSON
+     */
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
         if (null == responseBody)
             return null;
         Object result = null;
         //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        String jsonString = responseBody.trim();
-        if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
-            result = new JSONTokener(jsonString).nextValue();
+        String jsonString = getResponseString(responseBody, getCharset());
+        if (jsonString != null) {
+            jsonString = jsonString.trim();
+            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                result = new JSONTokener(jsonString).nextValue();
+            }
         }
         if (result == null) {
             result = jsonString;
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
new file mode 100644
index 00000000..181019e7
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -0,0 +1,319 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * HTTP entity to upload JSON data using streams.
+ * This has very low memory footprint; suitable for uploading large
+ * files using base64 encoding.
+ */
+class JsonStreamerEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "JsonStreamerEntity";
+
+    private static final UnsupportedOperationException ERR_UNSUPPORTED =
+        new UnsupportedOperationException("Unsupported operation in this implementation.");
+
+    // Size of the byte-array buffer used to read from streams.
+    private static final int BUFFER_SIZE = 2048;
+
+    // Reusable StringBuilder used by escape() method.
+    // Base64, at worst, will make a binary stream grow in size by approximately
+    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
+    // large 'n'.
+    private static final StringBuilder BUILDER =
+        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+
+    private static final byte[] JSON_TRUE = "true".getBytes();
+    private static final byte[] JSON_FALSE = "false".getBytes();
+    private static final byte[] JSON_NULL = "null".getBytes();
+    private static final byte[] STREAM_NAME = escape("name");
+    private static final byte[] STREAM_TYPE = escape("type");
+    private static final byte[] STREAM_CONTENTS = escape("contents");
+    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
+
+    private static final Header HEADER_JSON_CONTENT =
+        new BasicHeader("Content-Type", "application/json");
+    private static final Header HEADER_GZIP_ENCODING =
+        new BasicHeader("Content-Encoding", "gzip");
+    private static final String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
+    // K/V objects to be uploaded.
+    private final Map<String, Object> kvParams =
+        new HashMap<String, Object>();
+
+    // Streams and their associated meta-data to be uploaded.
+    private final Map<String, RequestParams.StreamWrapper> streamParams =
+        new HashMap<String, RequestParams.StreamWrapper>();
+
+    // Whether to use gzip compression while uploading
+    private final Header contentEncoding;
+
+    public JsonStreamerEntity(boolean contentEncoding) {
+        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
+    }
+
+    public void addPart(String key, Object value) {
+        kvParams.put(key, value);
+    }
+
+    public void addPart(String key, InputStream inputStream, String name, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return contentEncoding;
+    }
+
+    @Override
+    public Header getContentType() {
+        return HEADER_JSON_CONTENT;
+    }
+
+    @Override
+    public void consumeContent() throws IOException, UnsupportedOperationException {
+    }
+
+    @Override
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw ERR_UNSUPPORTED;
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        if (outstream == null) {
+            throw new IllegalStateException("Output stream cannot be null.");
+        }
+
+        // Record the time when uploading started.
+        long now = System.currentTimeMillis();
+
+        // Keys used by the HashMaps.
+        Set<String> keys;
+
+        // Use GZIP compression when sending streams, otherwise just use
+        // a buffered output stream to speed things up a bit.
+        OutputStream upload;
+        if (null != contentEncoding) {
+            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
+        } else {
+            upload = new BufferedOutputStream(outstream);
+        }
+
+        // Always send a JSON object.
+        upload.write('{');
+
+        // Send the K/V values.
+        keys = kvParams.keySet();
+        for (String key : keys) {
+            // Write the JSON object's key.
+            upload.write(escape(key));
+            upload.write(':');
+
+            // Evaluate the value (which cannot be null).
+            Object value = kvParams.get(key);
+
+            if (value instanceof Boolean) {
+                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            } else if (value instanceof Long) {
+                upload.write((((Number)value).longValue() + "").getBytes());
+            } else if (value instanceof Double) {
+                upload.write((((Number)value).doubleValue() + "").getBytes());
+            } else if (value instanceof Float) {
+                upload.write((((Number)value).floatValue() + "").getBytes());
+            } else if (value instanceof Integer) {
+                upload.write((((Number)value).intValue() + "").getBytes());
+            } else {
+                upload.write(value.toString().getBytes());
+            }
+
+            upload.write(',');
+        }
+
+        // Buffer used for reading from input streams.
+        byte[] buffer = new byte[BUFFER_SIZE];
+
+        // Send the stream params.
+        keys = streamParams.keySet();
+        for (String key : keys) {
+            RequestParams.StreamWrapper entry = streamParams.get(key);
+
+            // Write the JSON object's key.
+            upload.write(escape(key));
+
+            // All uploads are sent as an object containing the file's details.
+            upload.write(':');
+            upload.write('{');
+
+            // Send the streams's name.
+            upload.write(STREAM_NAME);
+            upload.write(':');
+            upload.write(escape(entry.name));
+            upload.write(',');
+
+            // Send the streams's content type.
+            upload.write(STREAM_TYPE);
+            upload.write(':');
+            upload.write(escape(entry.contentType));
+            upload.write(',');
+
+            // Prepare the file content's key.
+            upload.write(STREAM_CONTENTS);
+            upload.write(':');
+            upload.write('"');
+
+            // Upload the file's contents in Base64.
+            Base64OutputStream outputStream =
+                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+            // Read from input stream until no more data's left to read.
+            int bytesRead;
+            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+                outputStream.write(buffer, 0, bytesRead);
+            }
+
+            // Close the Base64 output stream.
+            outputStream.close();
+
+            // End the file's object and prepare for next one.
+            upload.write('"');
+            upload.write('}');
+            upload.write(',');
+        }
+
+        // Include the elapsed time taken to upload everything.
+        // This might be useful for somebody, but it serves us well since
+        // there will almost always be a ',' as the last sent character.
+        upload.write(STREAM_ELAPSED);
+        upload.write(':');
+        long elapsedTime = System.currentTimeMillis() - now;
+        upload.write((elapsedTime + "}").getBytes());
+
+        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+
+        // Flush the contents up the stream.
+        upload.flush();
+        upload.close();
+    }
+
+    // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
+    // Changed a bit to suit our needs in this class.
+    static byte[] escape(String string) {
+        // If it's null, just return prematurely.
+        if (string == null) {
+          return JSON_NULL;
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        int length = string.length(), pos = -1;
+        while (++pos < length) {
+            char ch = string.charAt(pos);
+            switch (ch) {
+                case '"':
+                    BUILDER.append("\\\"");
+                    break;
+                case '\\':
+                    BUILDER.append("\\\\");
+                    break;
+                case '\b':
+                    BUILDER.append("\\b");
+                    break;
+                case '\f':
+                    BUILDER.append("\\f");
+                    break;
+                case '\n':
+                    BUILDER.append("\\n");
+                    break;
+                case '\r':
+                    BUILDER.append("\\r");
+                    break;
+                case '\t':
+                    BUILDER.append("\\t");
+                    break;
+                default:
+                    // Reference: http://www.unicode.org/versions/Unicode5.1.0/
+                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                        String intString = Integer.toHexString(ch);
+                        BUILDER.append("\\u");
+                        int intLength = 4 - intString.length();
+                        for (int zero = 0; zero < intLength; zero++) {
+                            BUILDER.append('0');
+                        }
+                        BUILDER.append(intString.toUpperCase());
+                    } else {
+                        BUILDER.append(ch);
+                    }
+                    break;
+            }
+        }
+
+        // Surround with quotations.
+        BUILDER.append('"');
+
+        try {
+          return BUILDER.toString().getBytes();
+        } finally {
+          // Empty the String buffer.
+          // This is 20-30% faster than instantiating a new object.
+          BUILDER.setLength(0);
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
index eb4aa97e..03115afc 100644
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -16,7 +16,8 @@
 
 /**
  * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
- * http://code.google.com/p/android/issues/detail?id=13117#c14
+ * http://code.google.com/p/android/issues/detail?id=13117#c14 <p>&nbsp;</p> Warning! This omits SSL
+ * certificate validation on every device, use with caution
  */
 public class MySSLSocketFactory extends SSLSocketFactory {
     SSLContext sslContext = SSLContext.getInstance("TLS");
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index e28ec19f..bca196d6 100644
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -21,6 +21,8 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.text.TextUtils;
+import android.util.Log;
+
 import org.apache.http.client.CookieStore;
 import org.apache.http.cookie.Cookie;
 
@@ -41,6 +43,7 @@
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
+    private static final String LOG_TAG = "PersistentCookieStore";
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
@@ -142,12 +145,15 @@ public boolean clearExpired(Date date) {
         return new ArrayList<Cookie>(cookies.values());
     }
 
-
-    //
-    // Cookie serialization/deserialization
-    //
-
+    /**
+     * Serializes Cookie object into String
+     *
+     * @param cookie cookie to be encoded, can be null
+     * @return cookie encoded as String
+     */
     protected String encodeCookie(SerializableCookie cookie) {
+        if (cookie == null)
+            return null;
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
@@ -159,25 +165,36 @@ protected String encodeCookie(SerializableCookie cookie) {
         return byteArrayToHexString(os.toByteArray());
     }
 
-    protected Cookie decodeCookie(String cookieStr) {
-        byte[] bytes = hexStringToByteArray(cookieStr);
-        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+    /**
+     * Returns cookie decoded from cookie string
+     *
+     * @param cookieString string of cookie as returned from http request
+     * @return decoded cookie or null if exception occured
+     */
+    protected Cookie decodeCookie(String cookieString) {
+        byte[] bytes = hexStringToByteArray(cookieString);
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-            ObjectInputStream ois = new ObjectInputStream(is);
-            cookie = ((SerializableCookie) ois.readObject()).getCookie();
-        } catch (Exception e) {
-            e.printStackTrace();
+            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
+            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
+        } catch (Exception exception) {
+            Log.d(LOG_TAG, "decodeCookie failed", exception);
         }
 
         return cookie;
     }
 
-    // Using some super basic byte array <-> hex conversions so we don't have
-    // to rely on any large Base64 libraries. Can be overridden if you like!
-    protected String byteArrayToHexString(byte[] b) {
-        StringBuilder sb = new StringBuilder(b.length * 2);
-        for (byte element : b) {
+    /**
+     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any
+     * large Base64 libraries. Can be overridden if you like!
+     *
+     * @param bytes byte array to be converted
+     * @return string containing hex values
+     */
+    protected String byteArrayToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        for (byte element : bytes) {
             int v = element & 0xff;
             if (v < 16) {
                 sb.append('0');
@@ -187,11 +204,17 @@ protected String byteArrayToHexString(byte[] b) {
         return sb.toString().toUpperCase();
     }
 
-    protected byte[] hexStringToByteArray(String s) {
-        int len = s.length();
+    /**
+     * Converts hex values from strings to byte arra
+     *
+     * @param hexString string of hex-encoded values
+     * @return decoded byte array
+     */
+    protected byte[] hexStringToByteArray(String hexString) {
+        int len = hexString.length();
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
+            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 229a9da4..ccff7222 100644
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -24,6 +24,7 @@
 import org.apache.http.message.BasicNameValuePair;
 import org.apache.http.protocol.HTTP;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -85,7 +86,8 @@
  */
 public class RequestParams {
 
-    protected boolean isRepeatable = false;
+    protected boolean isRepeatable;
+    protected boolean useJsonStreamer;
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
@@ -311,6 +313,10 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
         this.isRepeatable = isRepeatable;
     }
 
+    public void setUseJsonStreamer(boolean useJsonStreamer) {
+        this.useJsonStreamer = useJsonStreamer;
+    }
+
     /**
      * Returns an HttpEntity containing all request parameters
      *
@@ -320,13 +326,51 @@ public void setHttpEntityIsRepeatable(boolean isRepeatable) {
      * @throws IOException if one of the streams cannot be read
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+        if (useJsonStreamer) {
+            return createJsonStreamerEntity();
+        } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
             return createMultipartEntity(progressHandler);
         }
     }
 
+    private HttpEntity createJsonStreamerEntity() throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add non-string params
+        for (ConcurrentHashMap.Entry<String, Object> entry : urlParamsWithObjects.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(),
+                           new FileInputStream(fileWrapper.file),
+                           fileWrapper.file.getName(),
+                           fileWrapper.contentType);
+        }
+
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(),
+                               stream.inputStream,
+                               stream.name,
+                               stream.contentType);
+            }
+        }
+
+        return entity;
+    }
+
     private HttpEntity createFormEntity() {
         try {
             return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
@@ -426,7 +470,7 @@ protected String getParamString() {
         return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
 
-    private static class FileWrapper {
+    public static class FileWrapper {
         public File file;
         public String contentType;
 
@@ -436,7 +480,7 @@ public FileWrapper(File file, String contentType) {
         }
     }
 
-    private static class StreamWrapper {
+    public static class StreamWrapper {
         public InputStream inputStream;
         public String name;
         public String contentType;
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index 06b2145b..d563a20c 100644
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -58,8 +58,10 @@
 
     /**
      * Notifies callback of retrying request
+     *
+     * @param retryNo number of retry within one request
      */
-    void sendRetryMessage();
+    void sendRetryMessage(int retryNo);
 
     /**
      * Returns URI which was used to request
@@ -95,4 +97,11 @@
      * @param useSynchronousMode whether data should be handled on background Thread on UI Thread
      */
     void setUseSynchronousMode(boolean useSynchronousMode);
+
+    /**
+     * Can set, whether the handler should be asynchronous or synchronous
+     *
+     * @return boolean if the ResponseHandler is running in synchronous mode
+     */
+    boolean getUseSynchronousMode();
 }
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index 967ac11b..22dede64 100644
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -91,8 +91,6 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             if (currentReq == null) {
                 return false;
             }
-            String requestType = currentReq.getMethod();
-            retry = !requestType.equals("POST");
         }
 
         if (retry) {
@@ -104,6 +102,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         return retry;
     }
 
+    static void addClassToWhitelist(Class<?> cls) {
+        exceptionWhitelist.add(cls);
+    }
+
+    static void addClassToBlacklist(Class<?> cls) {
+        exceptionBlacklist.add(cls);
+    }
+
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
         for (Class<?> aList : list) {
             if (aList.isInstance(error)) {
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index fcaf4d21..be6388f0 100644
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -93,7 +93,7 @@ public void addPart(final String key, final String value, final String contentTy
             out.write(value.getBytes());
             out.write(CR_LF);
         } catch (final IOException e) {
-            // Can't happen on ByteArrayOutputStream
+            // Shall not happen on ByteArrayOutputStream
             Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
         }
     }
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
index 22466edd..ac5ca66d 100644
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -7,6 +7,12 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
 
+/**
+ * Processes http requests in synchronous mode, so your caller thread will be blocked on each
+ * request
+ *
+ * @see com.loopj.android.http.AsyncHttpClient
+ */
 public class SyncHttpClient extends AsyncHttpClient {
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
index c476814d..b96a263a 100644
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -8,10 +8,10 @@
 
 /**
  * Used to intercept and handle the responses from requests made using {@link AsyncHttpClient}. The
- * {@link #onSuccess(String)} method is designed to be anonymously overridden with your own response
- * handling code. <p>&nbsp;</p> Additionally, you can override the {@link #onFailure(String,
- * Throwable)}, {@link #onStart()}, and {@link #onFinish()} methods as required. <p>&nbsp;</p> For
- * example: <p>&nbsp;</p>
+ * {@link #onSuccess(int, org.apache.http.Header[], String)} method is designed to be anonymously
+ * overridden with your own response handling code. <p>&nbsp;</p> Additionally, you can override the
+ * {@link #onFailure(int, org.apache.http.Header[], String, Throwable)}, {@link #onStart()}, and
+ * {@link #onFinish()} methods as required. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new TextHttpResponseHandler() {
@@ -37,78 +37,68 @@
  * });
  * </pre>
  */
-public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandler {
     private static final String LOG_TAG = "TextHttpResponseHandler";
 
     /**
-     * Creates a new TextHttpResponseHandler
+     * Creates new instance with default UTF-8 encoding
      */
-
     public TextHttpResponseHandler() {
         this(DEFAULT_CHARSET);
     }
 
+    /**
+     * Creates new instance with given string encoding
+     *
+     * @param encoding String encoding, see {@link #setCharset(String)}
+     */
     public TextHttpResponseHandler(String encoding) {
         super();
         setCharset(encoding);
     }
 
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Called when request fails
      *
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
+     * @param throwable      throwable returned when processing request
      */
-    public void onFailure(String responseBody, Throwable error) {
-    }
+    public abstract void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable);
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Called when request succeeds
      *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the response body, if any
-     * @param error        the underlying cause of the failure
+     * @param statusCode     http response status line
+     * @param headers        response headers if any
+     * @param responseString string response of given charset
      */
-    public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
-        onFailure(responseBody, error);
-    }
+    public abstract void onSuccess(int statusCode, Header[] headers, String responseString);
 
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     *
-     * @param statusCode   the status code of the response
-     * @param headers      HTTP response headers
-     * @param responseBody the body of the HTTP response from the server
-     */
     @Override
-    public void onSuccess(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, responseBody);
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBytes) {
+        onSuccess(statusCode, headers, getResponseString(responseBytes, getCharset()));
     }
 
     @Override
-    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
-        try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onSuccess(statusCode, headers, response);
-        } catch (UnsupportedEncodingException e) {
-            Log.v(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)");
-            onFailure(0, headers, (String) null, e);
-        }
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBytes, Throwable throwable) {
+        onFailure(statusCode, headers, getResponseString(responseBytes, getCharset()), throwable);
     }
 
-    @Override
-    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+    /**
+     * Attempts to encode response bytes as string of set encoding
+     *
+     * @param charset     charset to create string with
+     * @param stringBytes response bytes
+     * @return String of set encoding or null
+     */
+    public static String getResponseString(byte[] stringBytes, String charset) {
         try {
-            String response = responseBody == null ? null : new String(responseBody, getCharset());
-            onFailure(statusCode, headers, response, error);
+            return stringBytes == null ? null : new String(stringBytes, charset);
         } catch (UnsupportedEncodingException e) {
-            Log.e(LOG_TAG, "String encoding failed, calling onFailure(int, Header[], String, Throwable)", e);
-            onFailure(0, headers, (String) null, error);
+            Log.e(LOG_TAG, "Encoding response into string failed", e);
+            return null;
         }
     }
 
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 3e0a2fa8..23b6ee77 100644
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -27,6 +27,7 @@
         <activity android:name=".JsonSample" />
         <activity android:name=".FileSample" />
         <activity android:name=".BinarySample" />
+        <activity android:name=".ThreadingTimeoutSample" />
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
index 46912aaa..68c3620b 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -44,18 +44,18 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, File file) {
+            public void onSuccess(int statusCode, Header[] headers, File response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugFile(getTargetFile());
+                debugFile(response);
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, File file) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
-                debugFile(getTargetFile());
+                debugThrowable(LOG_TAG, throwable);
+                debugFile(file);
             }
 
             private void debugFile(File file) {
@@ -68,7 +68,7 @@ private void debugFile(File file) {
                 } catch (Throwable t) {
                     Log.e(LOG_TAG, "Cannot debug file contents", t);
                 }
-                if (!file.delete()) {
+                if (!deleteTargetFile()) {
                     Log.d(LOG_TAG, "Could not delete response file " + file.getAbsolutePath());
                 }
             }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
index 154804f8..ae701c91 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -49,28 +49,29 @@ public void onStart() {
             }
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, String rawResponse, SampleJSON response) {
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 if (response != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonResponse);
                 }
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable e, String rawResponse, SampleJSON errorResponse) {
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
-                debugThrowable(LOG_TAG, e);
+                debugThrowable(LOG_TAG, throwable);
                 if (errorResponse != null) {
-                    debugResponse(LOG_TAG, rawResponse);
+                    debugResponse(LOG_TAG, rawJsonData);
                 }
             }
 
             @Override
-            protected SampleJSON parseResponse(String responseBody) throws Throwable {
-                return new ObjectMapper().readValues(new JsonFactory().createParser(responseBody), SampleJSON.class).next();
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
             }
+
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
index 8ecad2b0..202fd480 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -5,14 +5,12 @@
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
 
 public class PostSample extends SampleParentActivity {
     private static final String LOG_TAG = "PostSample";
 
     @Override
     protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        headers = new Header[]{ new BasicHeader("Content-Type", "ee") };
         client.post(this, URL, headers, entity, null, responseHandler);
     }
 
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
new file mode 100644
index 00000000..aeb131a5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -0,0 +1,79 @@
+package com.loopj.android.http.sample;
+
+import android.util.SparseArray;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.Random;
+
+public class ThreadingTimeoutSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+    private SparseArray<String> states = new SparseArray<String>();
+
+    @Override
+    protected int getSampleTitle() {
+        return R.string.app_name;
+    }
+
+    @Override
+    protected boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    protected boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    protected String getDefaultURL() {
+        return "http://httpbin.org/delay/6";
+    }
+
+    private synchronized void setStatus(int id, String status) {
+        String current = states.get(id, null);
+        states.put(id, current == null ? status : current + "," + status);
+        clearOutputs();
+        for (int i = 0; i < states.size(); i++) {
+            debugResponse(LOG_TAG, states.keyAt(i) + ": " + states.get(states.keyAt(i)));
+        }
+    }
+
+    @Override
+    protected AsyncHttpResponseHandler getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            private int id = new Random().nextInt(1000);
+
+            @Override
+            public void onStart() {
+                setStatus(id, "START");
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                setStatus(id, "SUCCESS");
+            }
+
+            @Override
+            public void onFinish() {
+                setStatus(id, "FINISH");
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                setStatus(id, "FAILURE");
+            }
+        };
+    }
+
+    @Override
+    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
+        client.get(this, URL, headers, null, responseHandler);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 736c5424..857a0ffb 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -9,7 +9,7 @@
 
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY"};
+    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY", "THREADING TIMEOUTS"};
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -43,6 +43,9 @@ protected void onListItemClick(ListView l, View v, int position, long id) {
             case 6:
                 targetClass = BinarySample.class;
                 break;
+            case 7:
+                targetClass = ThreadingTimeoutSample.class;
+                break;
         }
         if (targetClass != null)
             startActivity(new Intent(this, targetClass));
