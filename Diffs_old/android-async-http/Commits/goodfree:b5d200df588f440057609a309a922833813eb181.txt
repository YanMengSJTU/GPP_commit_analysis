diff --git a/android-app-http/src/com/app/library/http/RequestManager.java b/android-app-http/src/com/app/library/http/RequestManager.java
index e039ea77..e77b2061 100644
--- a/android-app-http/src/com/app/library/http/RequestManager.java
+++ b/android-app-http/src/com/app/library/http/RequestManager.java
@@ -155,7 +155,7 @@ public void post(Context context, String url, Header[] headers, String params, R
 	public void get(Context context, String url, RequestListener requestListener, int actionId) {
 		get(context, url, null, requestListener, false, actionId);
 	}
-	
+
 	/**
 	 * get数据
 	 * 
@@ -165,7 +165,8 @@ public void get(Context context, String url, RequestListener requestListener, in
 	 * @param cache
 	 * @param actionId
 	 */
-	public void get(Context context, String url, RequestParams params, RequestListener requestListener, boolean cache, int actionId) {
+	public void get(Context context, String url, RequestParams params, RequestListener requestListener, boolean cache,
+			int actionId) {
 		final String encodeUrl = urlEncode(url);
 		if (!cache) {
 			asyncHttpClient.get(context, url, params, new HttpRequestListener(requestListener, actionId));
@@ -392,20 +393,14 @@ public void onStart() {
 		}
 
 		@Override
-		public void onFinish() {
-			super.onFinish();
+		protected void onSuccess(int intValue, Header[] headers, byte[] response) {
+			super.onSuccess(intValue, headers, response);
+			requestListener.onCompleted(response, RequestListener.OK, "server response ok", actionId);
 		}
 
 		@Override
-		public void onSuccess(int statusCode, byte[] binaryData) {
-			super.onSuccess(statusCode, binaryData);
-			requestListener.onCompleted(binaryData, RequestListener.OK, "server response ok", actionId);
-		}
-
-		@Override
-		public void onFailure(Throwable error, String content) {
-			super.onFailure(error, content);
-			requestListener.onCompleted(null, RequestListener.ERR, content, actionId);
+		protected void onFailure(Throwable throwable, String response) {
+			requestListener.onCompleted(null, RequestListener.ERR, response, actionId);
 		}
 	}
 
@@ -424,7 +419,6 @@ public static boolean hasNetwork(Context context) {
 		return false;
 	}
 
-
 	/**
 	 * 对字符串进行MD5加密。
 	 */
@@ -472,5 +466,5 @@ public static String urlEncode(String str) {
 		}
 		return buf.toString();
 	}
-	
+
 }
diff --git a/android-app-http/src/com/loopj/android/http/AsyncHttpClient.java b/android-app-http/src/com/loopj/android/http/AsyncHttpClient.java
index 1059c904..23e685c9 100644
--- a/android-app-http/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/android-app-http/src/com/loopj/android/http/AsyncHttpClient.java
@@ -60,8 +60,8 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
 import org.apache.http.protocol.HttpContext;
@@ -90,9 +90,9 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.1";
+    private static final String VERSION = "1.4.3";
 
-    private static final int DEFAULT_MAX_CONNECTIONS = 30;
+    private static final int DEFAULT_MAX_CONNECTIONS = 15;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     private static final int DEFAULT_MAX_RETRIES = 3;
     private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
@@ -135,6 +135,7 @@ public AsyncHttpClient() {
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
         httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
             public void process(HttpRequest request, HttpContext context) {
                 if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
@@ -146,6 +147,7 @@ public void process(HttpRequest request, HttpContext context) {
         });
 
         httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+            @Override
             public void process(HttpResponse response, HttpContext context) {
                 final HttpEntity entity = response.getEntity();
                 if (entity == null) {
diff --git a/android-app-http/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/android-app-http/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 9ea90c3f..b81f99ac 100644
--- a/android-app-http/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/android-app-http/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -14,13 +14,13 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
+import java.io.IOException;
+
+import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -28,189 +28,175 @@
 import org.apache.http.entity.BufferedHttpEntity;
 import org.apache.http.util.EntityUtils;
 
-import java.io.IOException;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
 
 /**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
- * designed to be anonymously overridden with your own response handling code.
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is designed to
+ * be anonymously overridden with your own response handling code.
  * <p>
  * Additionally, you can override the {@link #onFailure(Throwable, String)},
  * {@link #onStart()}, and {@link #onFinish()} methods as required.
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
- *     &#064;Override
- *     public void onStart() {
- *         // Initiated the request
- *     }
- *
- *     &#064;Override
- *     public void onSuccess(String response) {
- *         // Successfully got a response
- *     }
+ * client.get(&quot;http://www.google.com&quot;, new AsyncHttpResponseHandler() {
+ * 	&#064;Override
+ * 	public void onStart() {
+ * 		// Initiated the request
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onSuccess(String response) {
+ * 		// Successfully got a response
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onFailure(Throwable e, String response) {
+ * 		// Response failed :(
+ * 	}
  * 
- *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
- *         // Response failed :(
- *     }
- *
- *     &#064;Override
- *     public void onFinish() {
- *         // Completed the request (either success or failure)
- *     }
+ * 	&#064;Override
+ * 	public void onFinish() {
+ * 		// Completed the request (either success or failure)
+ * 	}
  * });
  * </pre>
  */
 public class AsyncHttpResponseHandler {
-    protected static final int SUCCESS_MESSAGE = 0;
-    protected static final int FAILURE_MESSAGE = 1;
-    protected static final int START_MESSAGE = 2;
-    protected static final int FINISH_MESSAGE = 3;
-
-    private Handler handler;
-
-    /**
-     * Creates a new AsyncHttpResponseHandler
-     */
-    public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
-        }
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when the request is started, override to handle in your own code
-     */
-    public void onStart() {}
-
-    /**
-     * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
-     */
-    public void onFinish() {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] byteData) {}
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
-     */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-    }
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, byte[] byteData) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{Integer.valueOf(statusCode), byteData}));
-    }
-
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    protected void sendStartMessage() {
-        sendMessage(obtainMessage(START_MESSAGE, null));
-    }
-
-    protected void sendFinishMessage() {
-        sendMessage(obtainMessage(FINISH_MESSAGE, null));
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, byte[] byteData) {
-        onSuccess(statusCode, byteData);
-    }
-
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
-        }
-    }
-
-    protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
-        }
-    }
-
-    protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = Message.obtain();
-            msg.what = responseMessage;
-            msg.obj = response;
-        }
-        return msg;
-    }
-
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        byte[] responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toByteArray(entity);
-            }
-        } catch(IOException e) {
-            sendFailureMessage(e, null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), "server response error");
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
-}
\ No newline at end of file
+	protected static final int SUCCESS_MESSAGE = 0;
+	protected static final int FAILURE_MESSAGE = 1;
+	protected static final int START_MESSAGE = 2;
+	protected static final int FINISH_MESSAGE = 3;
+
+	private Handler handler;
+
+	/**
+	 * Creates a new AsyncHttpResponseHandler
+	 */
+	public AsyncHttpResponseHandler() {
+		// Set up a handler to post events back to the correct thread if
+		// possible
+		if (Looper.myLooper() != null) {
+			handler = new Handler() {
+				@Override
+				public void handleMessage(Message msg) {
+					AsyncHttpResponseHandler.this.handleMessage(msg);
+				}
+			};
+		}
+	}
+
+	//
+	// Callbacks to be overridden, typically anonymously
+	//
+
+	/**
+	 * Fired when the request is started, override to handle in your own code
+	 */
+	public void onStart() {
+	}
+
+	/**
+	 * Fired in all cases when the request is finished, after both success and
+	 * failure, override to handle in your own code
+	 */
+	public void onFinish() {
+	}
+
+	//
+	// Pre-processing of messages (executes in background threadpool thread)
+	//
+	protected void sendStartMessage() {
+		sendMessage(obtainMessage(START_MESSAGE, null));
+	}
+
+	protected void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
+		sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[] { new Integer(statusCode), headers, responseBody }));
+	}
+
+	protected void sendFailureMessage(Throwable e, String responseBody) {
+		sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] { e, responseBody }));
+	}
+
+	// Methods which emulate android's Handler and Message methods
+	protected void handleMessage(Message msg) {
+		Object[] response;
+		switch (msg.what) {
+		case START_MESSAGE:
+			onStart();
+			break;
+		case SUCCESS_MESSAGE:
+			response = (Object[]) msg.obj;
+			onSuccess(((Integer) response[0]).intValue(), (Header[]) response[1], (byte[]) response[2]);
+			break;
+		case FAILURE_MESSAGE:
+			response = (Object[]) msg.obj;
+			onFailure((Throwable) response[0], (String) response[1]);
+			break;
+		}
+	}
+
+	protected void onSuccess(int intValue, Header[] headers, byte[] response) {
+
+	}
+
+	protected void onFailure(Throwable throwable, String errorMsg) {
+
+	}
+
+	protected void sendMessage(Message msg) {
+		if (handler != null) {
+			handler.sendMessage(msg);
+		} else {
+			handleMessage(msg);
+		}
+	}
+
+	protected Message obtainMessage(int responseMessage, Object response) {
+		Message msg = null;
+		if (handler != null) {
+			msg = this.handler.obtainMessage(responseMessage, response);
+		} else {
+			msg = Message.obtain();
+			msg.what = responseMessage;
+			msg.obj = response;
+		}
+		return msg;
+	}
+
+	// Interface to AsyncHttpRequest
+	void sendResponseMessage(HttpResponse response) {
+		StatusLine status = response.getStatusLine();
+		byte[] responseBody = null;
+		try {
+			HttpEntity entity = null;
+			HttpEntity temp = response.getEntity();
+			if (temp != null) {
+				entity = new BufferedHttpEntity(temp);
+				responseBody = EntityUtils.toByteArray(entity);
+			}
+		} catch (IOException e) {
+			sendFailureMessage(e, null);
+		}
+
+		if (status.getStatusCode() >= 300) {
+			sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()),
+					getFailureMsg(responseBody));
+		} else {
+			sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+		}
+	}
+
+	private String getFailureMsg(byte[] msg) {
+		if (msg != null) {
+			return new String("UTF-8");
+		}
+		return null;
+	}
+}
diff --git a/android-app-http/src/com/loopj/android/http/PersistentCookieStore.java b/android-app-http/src/com/loopj/android/http/PersistentCookieStore.java
index 94076682..11b2a2bf 100644
--- a/android-app-http/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/android-app-http/src/com/loopj/android/http/PersistentCookieStore.java
@@ -80,7 +80,7 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
-        String name = cookie.getName();
+        String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
         if(!cookie.isExpired(new Date())) {
@@ -98,9 +98,6 @@ public void addCookie(Cookie cookie) {
 
     @Override
     public void clear() {
-        // Clear cookies from local store
-        cookies.clear();
-
         // Clear cookies from persistent store
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
         for(String name : cookies.keySet()) {
@@ -108,6 +105,9 @@ public void clear() {
         }
         prefsWriter.remove(COOKIE_NAME_STORE);
         prefsWriter.commit();
+
+        // Clear cookies from local store
+        cookies.clear();
     }
 
     @Override
diff --git a/android-app-http/src/com/loopj/android/http/RequestParams.java b/android-app-http/src/com/loopj/android/http/RequestParams.java
index cca963a1..cbb0c288 100644
--- a/android-app-http/src/com/loopj/android/http/RequestParams.java
+++ b/android-app-http/src/com/loopj/android/http/RequestParams.java
@@ -210,12 +210,12 @@ public String toString() {
                 result.append("&");
 
             ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                if (values.indexOf(value) != 0)
+            for (int i = 0; i < values.size(); i++) {
+                if (i != 0)
                     result.append("&");
                 result.append(entry.getKey());
                 result.append("=");
-                result.append(value);
+                result.append(values.get(i));
             }
         }
 
@@ -236,6 +236,14 @@ public HttpEntity getEntity() {
                 multipartEntity.addPart(entry.getKey(), entry.getValue());
             }
 
+            // Add dupe params
+            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+                ArrayList<String> values = entry.getValue();
+                for (String value : values) {
+                    multipartEntity.addPart(entry.getKey(), value);
+                }
+            }
+
             // Add file params
             int currentIndex = 0;
             int lastIndex = fileParams.entrySet().size() - 1;
@@ -252,14 +260,6 @@ public HttpEntity getEntity() {
                 currentIndex++;
             }
 
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
-
             entity = multipartEntity;
         } else {
             try {
@@ -318,4 +318,4 @@ public String getFileName() {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/android-app-http/src/com/loopj/android/http/RetryHandler.java b/android-app-http/src/com/loopj/android/http/RetryHandler.java
index 715456fb..5256aad2 100644
--- a/android-app-http/src/com/loopj/android/http/RetryHandler.java
+++ b/android-app-http/src/com/loopj/android/http/RetryHandler.java
@@ -65,6 +65,7 @@ public RetryHandler(int maxRetries) {
         this.maxRetries = maxRetries;
     }
 
+    @Override
     public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
         boolean retry = true;
 
diff --git a/android-app-http/src/com/loopj/android/http/SimpleMultipartEntity.java b/android-app-http/src/com/loopj/android/http/SimpleMultipartEntity.java
index bff0efcc..3221ec1e 100644
--- a/android-app-http/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/android-app-http/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -58,47 +58,57 @@ public SimpleMultipartEntity() {
 
     public void writeFirstBoundaryIfNeeds(){
         if(!isSetFirst){
-            try {
-                out.write(("--" + boundary + "\r\n").getBytes());
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
+            writeBoundary();
         }
 
         isSetFirst = true;
     }
 
+    public void writeBoundary() {
+        try {
+            out.write(("--" + boundary + "\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
     public void writeLastBoundaryIfNeeds() {
         if(isSetLast){
             return;
         }
 
         try {
-            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
+            out.write(("--" + boundary + "--\r\n").getBytes());
+            out.flush();
         } catch (final IOException e) {
             e.printStackTrace();
         }
-
+        
         isSetLast = true;
     }
 
-    public void addPart(final String key, final String value) {
-        writeFirstBoundaryIfNeeds();
+    public void addPart(final String key, final String value, final String contentType) {
+        writeBoundary();
         try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
+            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n").getBytes());
+            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
             out.write(value.getBytes());
-            out.write(("\r\n--" + boundary + "\r\n").getBytes());
+            out.write(("\r\n").getBytes());
         } catch (final IOException e) {
             e.printStackTrace();
         }
     }
 
+    public void addPart(final String key, final String value) {
+        addPart(key,value,"text/plain; charset=UTF-8");
+    }
+
     public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
         addPart(key, fileName, fin, "application/octet-stream", isLast);
     }
 
     public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeFirstBoundaryIfNeeds();
+        writeBoundary();
         try {
             type = "Content-Type: "+type+"\r\n";
             out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
@@ -110,9 +120,8 @@ public void addPart(final String key, final String fileName, final InputStream f
             while ((l = fin.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
             }
-            if(!isLast)
-                out.write(("\r\n--" + boundary + "\r\n").getBytes());
-            out.flush();
+            out.write(("\r\n").getBytes());
+            
         } catch (final IOException e) {
             e.printStackTrace();
         } finally {
@@ -160,6 +169,7 @@ public boolean isStreaming() {
 
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
+        writeLastBoundaryIfNeeds();
         outstream.write(out.toByteArray());
     }
 
@@ -180,6 +190,7 @@ public void consumeContent() throws IOException,
     @Override
     public InputStream getContent() throws IOException,
     UnsupportedOperationException {
+    	writeLastBoundaryIfNeeds();
         return new ByteArrayInputStream(out.toByteArray());
     }
 }
\ No newline at end of file
