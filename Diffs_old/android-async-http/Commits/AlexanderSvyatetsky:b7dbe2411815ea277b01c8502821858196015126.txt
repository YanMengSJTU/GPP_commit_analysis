diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index cf5d1dc4..02bcf8a7 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -18,10 +18,16 @@
 
 package com.loopj.android.http;
 
-import java.io.InputStream;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.protocol.HTTP;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -29,11 +35,6 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-
 /**
  * A collection of string request parameters or files to send along with
  * requests made from an {@link AsyncHttpClient} instance.
@@ -54,7 +55,6 @@
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
 
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
@@ -226,46 +226,49 @@ public String toString() {
      * Returns an HttpEntity containing all request parameters
      */
     public HttpEntity getEntity() {
-        HttpEntity entity = null;
-
         if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+            return createMultipartEntity();
+        } else {
+            return createFormEntity();
+        }
+    }
 
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
+    private HttpEntity createFormEntity() {
+        try {
+            return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
+        } catch (UnsupportedEncodingException e) {
+            return null; // Actually cannot happen when using utf-8
+        }
+    }
 
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
+    private HttpEntity createMultipartEntity() {
+        SimpleMultipartEntity entity = new SimpleMultipartEntity();
 
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
+
+        // Add dupe params
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray
+                .entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                entity.addPart(entry.getKey(), value);
             }
+        }
 
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper file = entry.getValue();
+            if (file.inputStream != null) {
+                if (file.contentType != null) {
+                    entity.addPart(entry.getKey(), file.getFileName(),
+                            file.inputStream, file.contentType);
+                } else {
+                    entity.addPart(entry.getKey(), file.getFileName(),
+                            file.inputStream);
+                }
             }
         }
 
@@ -296,7 +299,7 @@ private void init(){
     }
 
     protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
+        return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
 
     private static class FileWrapper {
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index edfd013b..a9917807 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -36,6 +36,9 @@
 import java.io.OutputStream;
 import java.util.Random;
 
+/**
+ * Simplified multipart entity mainly used for sending one or more files.
+ */
 class SimpleMultipartEntity implements HttpEntity {
 
     private static final byte[] CR_LF = ("\r\n").getBytes();
@@ -68,16 +71,17 @@ public void addPart(final String key, final String value) {
             out.write(createContentDisposition(key));
             out.write(CR_LF);
             out.write(value.getBytes());
+            out.write(CR_LF);
         } catch (final IOException e) {
             // Can't happen on ByteArrayOutputStream
         }
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    public void addPart(final String key, final String fileName, final InputStream fin) {
+        addPart(key, fileName, fin, "application/octet-stream");
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
+    public void addPart(final String key, final String fileName, final InputStream fin, String type) {
         try {
             out.write(boundaryLine);
 
@@ -104,9 +108,9 @@ public void addPart(final String key, final String fileName, final InputStream f
         }
     }
 
-    public void addPart(final String key, final File value, final boolean isLast)
+    public void addPart(final String key, final File value)
             throws FileNotFoundException {
-        addPart(key, value.getName(), new FileInputStream(value), isLast);
+        addPart(key, value.getName(), new FileInputStream(value));
     }
 
     private byte[] createContentType(String type) {
@@ -132,6 +136,8 @@ public void addPart(final String key, final File value, final boolean isLast)
         return builder.toString().getBytes();
     }
 
+    // The following methods are from the HttpEntity interface
+
     @Override
     public long getContentLength() {
         return out.size() + boundaryEnd.length;
@@ -180,6 +186,6 @@ public void consumeContent() throws IOException,
     @Override
     public InputStream getContent() throws IOException, UnsupportedOperationException {
         throw new UnsupportedOperationException(
-                "getContent() not supported. Use writeTo() instead.");
+                "getContent() is not supported. Use writeTo() instead.");
     }
 }
\ No newline at end of file
