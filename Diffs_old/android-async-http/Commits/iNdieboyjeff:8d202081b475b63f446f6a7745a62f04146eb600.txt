diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index 758ad956..c6df930c 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -102,6 +102,7 @@
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     private static final int DEFAULT_MAX_RETRIES = 5;
+    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
     private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
     private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
     private static final String ENCODING_GZIP = "gzip";
@@ -115,6 +116,7 @@
     private ThreadPoolExecutor threadPool;
     private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
     private final Map<String, String> clientHeaderMap;
+    private boolean isUrlEncodingEnabled = true;
 
 
     /**
@@ -144,28 +146,37 @@ public AsyncHttpClient(int httpPort, int httpsPort) {
     }
 
     /**
-     * Creates a new AsyncHttpClient.
+     * Creates new AsyncHttpClient using given params
      *
-     * @param fixNoHttpResponseException See issue https://github.com/loopj/android-async-http/issues/143
-     * @param httpPort                   non-standard HTTP-only port
-     * @param httpsPort                  non-standard HTTPS-only port
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
     public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
-        if (fixNoHttpResponseException)
-            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
-        BasicHttpParams httpParams = new BasicHttpParams();
+        this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));
+    }
 
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
-        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
-        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+    /**
+     * Returns default instance of SchemeRegistry
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
+     */
+    private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        if (fixNoHttpResponseException) {
+            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
+        }
 
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setTcpNoDelay(httpParams, true);
-        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+        if (httpPort < 1) {
+            httpPort = 80;
+            Log.d(LOG_TAG, "Invalid HTTP port number specified, defaulting to 80");
+        }
 
-        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+        if (httpsPort < 1) {
+            httpsPort = 443;
+            Log.d(LOG_TAG, "Invalid HTTPS port number specified, defaulting to 443");
+        }
 
         // Fix to SSL flaw in API < ICS
         // See https://code.google.com/p/android/issues/detail?id=13117
@@ -179,6 +190,30 @@ public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int htt
         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
         schemeRegistry.register(new Scheme("https", sslSocketFactory, httpsPort));
 
+        return schemeRegistry;
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
+     */
+    public AsyncHttpClient(SchemeRegistry schemeRegistry) {
+
+        BasicHttpParams httpParams = new BasicHttpParams();
+
+        ConnManagerParams.setTimeout(httpParams, socketTimeout);
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
+        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setTcpNoDelay(httpParams, true);
+        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
@@ -218,7 +253,7 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
     /**
@@ -310,6 +345,7 @@ public void setProxy(String hostname, int port) {
         final HttpParams httpParams = this.httpClient.getParams();
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
+
     /**
      * Sets the Proxy by it's hostname,port,username and password
      *
@@ -318,14 +354,14 @@ public void setProxy(String hostname, int port) {
      * @param username the username
      * @param password the password
      */
-     public void setProxy(String hostname,int port,String username,String password){
-         httpClient.getCredentialsProvider().setCredentials(
-    		    new AuthScope(hostname, port),
-    		    new UsernamePasswordCredentials(username, password));
+    public void setProxy(String hostname, int port, String username, String password) {
+        httpClient.getCredentialsProvider().setCredentials(
+                new AuthScope(hostname, port),
+                new UsernamePasswordCredentials(username, password));
         final HttpHost proxy = new HttpHost(hostname, port);
         final HttpParams httpParams = this.httpClient.getParams();
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
-     }
+    }
 
 
     /**
@@ -339,12 +375,12 @@ public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
     }
 
     /**
-     * Sets the maximum number of retries for a particular Request.
+     * Sets the maximum number of retries and timeout for a particular Request.
      *
      * @param retries maximum number of retries per request
      */
-    public void setMaxRetries(int retries) {
-        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries));
+    public void setMaxRetriesAndTimeout(int retries, int timeout) {
+        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
     }
 
     /**
@@ -468,7 +504,7 @@ public void head(Context context, String url, AsyncHttpResponseHandler responseH
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(url, params)), null, responseHandler, context);
+        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -483,7 +519,7 @@ public void head(Context context, String url, RequestParams params, AsyncHttpRes
      *                        the response.
      */
     public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpHead(getUrlWithQueryString(url, params));
+        HttpUriRequest request = new HttpHead(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
@@ -535,7 +571,7 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
+        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);
     }
 
     /**
@@ -550,7 +586,7 @@ public void get(Context context, String url, RequestParams params, AsyncHttpResp
      *                        the response.
      */
     public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+        HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
@@ -769,13 +805,21 @@ public void delete(Context context, String url, Header[] headers, AsyncHttpRespo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(url, params));
+        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(isUrlEncodingEnabled, url, params));
         if (headers != null) httpDelete.setHeaders(headers);
         sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
-
-    // Private stuff
+    /**
+     * Puts a new request in queue as a new thread in pool to be executed
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete, HttpPost, HttpGet, HttpPut, etc.
+     */
     protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
         if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
@@ -797,7 +841,26 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
         }
     }
 
-    public static String getUrlWithQueryString(String url, RequestParams params) {
+    /**
+     * Sets state of URL encoding feature, see bug #227, this method
+     * allows you to turn off and on this auto-magic feature on-demand.
+     *
+     * @param enabled desired state of feature
+     */
+    public void setURLEncodingEnabled(boolean enabled) {
+        this.isUrlEncodingEnabled = enabled;
+    }
+
+    /**
+     * Will encode url, if not disabled, and adds params on the end of it
+     *
+     * @param url    String with URL, should be valid URL without params
+     * @param params RequestParams to be appended on the end of URL
+     */
+    public static String getUrlWithQueryString(boolean isUrlEncodingEnabled, String url, RequestParams params) {
+        if (isUrlEncodingEnabled)
+            url = url.replace(" ", "%20");
+
         if (params != null) {
             String paramString = params.getParamString();
             if (!url.contains("?")) {
@@ -810,6 +873,13 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
+    /**
+     * Returns HttpEntity containing data from RequestParams included with request declaration.
+     * Allows also passing progress from upload via provided ResponseHandler
+     *
+     * @param params          additional request params
+     * @param responseHandler AsyncHttpResponseHandler or its subclass to be notified on progress
+     */
     private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpEntity entity = null;
 
@@ -827,6 +897,16 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
         return entity;
     }
 
+    public boolean isUrlEncodingEnabled(){
+        return isUrlEncodingEnabled;
+    }
+
+    /**
+     * Applicable only to HttpRequest methods extending HttpEntityEnclosingRequestBase, which is for example not DELETE
+     *
+     * @param entity      entity to be included within the request
+     * @param requestBase HttpRequest instance, must not be null
+     */
     private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
         if (entity != null) {
             requestBase.setEntity(entity);
@@ -835,6 +915,9 @@ private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosin
         return requestBase;
     }
 
+    /**
+     * Enclosing entity to hold stream of gzip decoded data for accessing HttpEntity contents
+     */
     private static class InflatingEntity extends HttpEntityWrapper {
         public InflatingEntity(HttpEntity wrapped) {
             super(wrapped);
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
index 8eefde0d..d235663b 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -28,6 +28,7 @@
 
 import java.io.IOException;
 import java.net.ConnectException;
+import java.net.MalformedURLException;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -74,16 +75,19 @@ public void run() {
         }
     }
 
-    private void makeRequest() throws IOException {
+    private void makeRequest() throws IOException, InterruptedException {
         if (!Thread.currentThread().isInterrupted()) {
             try {
+                // Fixes #115
+                if (request.getURI().getScheme() == null)
+                    throw new MalformedURLException("No valid URI scheme was provided");
                 HttpResponse response = client.execute(request, context);
                 if (!Thread.currentThread().isInterrupted()) {
                     if (responseHandler != null) {
                         responseHandler.sendResponseMessage(response);
                     }
                 } else {
-                    //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
+                    throw new InterruptedException("makeRequest was interrupted");
                 }
             } catch (IOException e) {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -104,7 +108,7 @@ private void makeRequestWithRetries() throws ConnectException {
                 makeRequest();
                 return;
             } catch (ClientProtocolException e) {
-                if(responseHandler != null) {
+                if (responseHandler != null) {
                     responseHandler.sendFailureMessage(e, "cannot repeat the request");
                 }
                 return;
@@ -137,6 +141,9 @@ private void makeRequestWithRetries() throws ConnectException {
                 // http://code.google.com/p/android/issues/detail?id=5255
                 cause = new IOException("NPE in HttpClient " + e.getMessage());
                 retry = retryHandler.retryRequest(cause, ++executionCount, context);
+            } catch (InterruptedException e) {
+                cause = new IOException("Request was interrupted while executing");
+                retry = retryHandler.retryRequest(cause, ++executionCount, context);
             }
         }
 
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
index 18e2b106..40951b3f 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -30,9 +30,12 @@
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -49,6 +52,35 @@
  * params.put("profile_picture", new File("pic.jpg")); // Upload a File
  * params.put("profile_picture2", someInputStream); // Upload an InputStream
  * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
+ * 
+ * Map<String, String> map = new HashMap<String, String>();
+ * map.put("first_name", "James");
+ * map.put("last_name", "Smith");
+ * params.put("user", map); // url params: "user[first_name]=James&user[last_name]=Smith"
+ *
+ * Set<String> set = new HashSet<String>(); // unordered collection
+ * set.add("music");
+ * set.add("art");
+ * params.put("like", set); // url params: "like=music&like=art"
+ * 
+ * List<String> list = new ArrayList<String>(); // Ordered collection
+ * list.add("Java");
+ * list.add("C");
+ * params.put("languages", list); // url params: "languages[]=Java&languages[]=C"
+ * 
+ * String[] colors = { "blue", "yellow" }; // Ordered collection
+ * params.put("colors", colors); // url params: "colors[]=blue&colors[]=yellow"
+ * 
+ * List<Map<String, String>> listOfMaps = new ArrayList<Map<String, String>>();
+ * Map<String, String> user1 = new HashMap<String, String>();
+ * user1.put("age", "30");
+ * user1.put("gender", "male");
+ * Map<String, String> user2 = new HashMap<String, String>();
+ * user2.put("age", "25");
+ * user2.put("gender", "female");
+ * listOfMaps.add(user1);
+ * listOfMaps.add(user2);
+ * params.put("users", listOfMaps); // url params: "users[][age]=30&users[][gender]=male&users[][age]=25&users[][gender]=female"
  *
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.post("http://myendpoint.com", params, responseHandler);
@@ -61,7 +93,7 @@
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
+    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
 
     /**
      * Constructs a new empty <code>RequestParams</code> instance.
@@ -154,18 +186,6 @@ public void put(String key, File file, String contentType) throws FileNotFoundEx
         }
     }
 
-    /**
-     * Adds param with more than one value.
-     *
-     * @param key    the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values) {
-        if (key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
-    }
-
     /**
      * Adds an input stream to the request.
      *
@@ -201,6 +221,38 @@ public void put(String key, InputStream stream, String name, String contentType)
         }
     }
 
+    /**
+     * Adds param with non-string value (e.g. Map, List, Set).
+     * @param key   the key name for the new param.
+     * @param value the non-string value object for the new param.
+     */
+    public void put(String key, Object value)  {
+        if (key != null && value != null) {
+            urlParamsWithObjects.put(key, value);
+        }
+    }
+            
+    /**
+     * Adds string value to param which can have more than one value.
+     * @param key   the key name for the param, either existing or new.
+     * @param value the value string for the new param.
+     */
+    public void add(String key, String value) {
+        if (key != null && value != null) {
+            Object params = urlParamsWithObjects.get(key);
+            if (params == null) {
+                // Backward compatible, which will result in "k=v1&k=v2&k=v3"
+                params = new HashSet<String>();
+                this.put(key, params);
+            }
+            if (params instanceof List) {
+                ((List<Object>) params).add(value);
+            } else if (params instanceof Set) {
+                ((Set<Object>) params).add(value);
+            }
+        }
+    }
+    
     /**
      * Removes a parameter from the request.
      *
@@ -210,7 +262,7 @@ public void remove(String key) {
         urlParams.remove(key);
         streamParams.remove(key);
         fileParams.remove(key);
-        urlParamsWithArray.remove(key);
+        urlParamsWithObjects.remove(key);
     }
 
     @Override
@@ -243,18 +295,14 @@ public String toString() {
             result.append("FILE");
         }
 
-        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
             if (result.length() > 0)
                 result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (int i = 0; i < values.size(); i++) {
-                if (i != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(values.get(i));
-            }
+            
+            result.append(kv.getName());
+            result.append("=");
+            result.append(kv.getValue());
         }
 
         return result.toString();
@@ -291,13 +339,10 @@ private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandle
             entity.addPart(entry.getKey(), entry.getValue());
         }
 
-        // Add dupe params
-        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray
-                .entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                entity.addPart(entry.getKey(), value);
-            }
+        // Add non-string params
+        List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
+        for (BasicNameValuePair kv : params) {
+        	entity.addPart(kv.getName(), kv.getValue());
         }
 
         // Add stream params
@@ -322,7 +367,7 @@ private void init() {
         urlParams = new ConcurrentHashMap<String, String>();
         streamParams = new ConcurrentHashMap<String, StreamWrapper>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
+        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
     }
 
     protected List<BasicNameValuePair> getParamsList() {
@@ -332,16 +377,46 @@ private void init() {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
         }
 
-        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
-        }
+        lparams.addAll(getParamsList(null, urlParamsWithObjects));
 
         return lparams;
     }
 
+    private List<BasicNameValuePair> getParamsList(String key, Object value) {
+        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
+        if (value instanceof Map) {
+            Map<String, Object> map = (Map<String, Object>) value;
+            List<String> list = new ArrayList<String>(map.keySet());
+            // Ensure consistent ordering in query string
+            Collections.sort(list);
+            for (String nestedKey : list) {
+                Object nestedValue = map.get(nestedKey);
+                if (nestedValue != null) {
+                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
+                            nestedValue));
+                }
+            }
+        } else if (value instanceof List) {
+            List<Object> list = (List<Object>) value;
+            for (Object nestedValue : list) {
+                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            }
+        } else if (value instanceof Object[]) {
+            Object[] array = (Object[]) value;
+            for (Object nestedValue : array) {
+                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            }
+        } else if (value instanceof Set) {
+            Set<Object> set = (Set<Object>) value;
+            for (Object nestedValue : set) {
+                params.addAll(getParamsList(key, nestedValue));
+            }
+        } else if (value instanceof String) {
+            params.add(new BasicNameValuePair(key, (String) value));
+        }
+        return params;
+    }
+    
     protected String getParamString() {
         return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
@@ -367,4 +442,4 @@ public StreamWrapper(InputStream inputStream, String name, String contentType) {
             this.contentType = contentType;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
index ccb01aa1..e8ea7cca 100644
--- a/library/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -40,7 +40,6 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
     private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
     private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
@@ -59,9 +58,11 @@
     }
 
     private final int maxRetries;
+    private final int retrySleepTimeMS;
 
-    public RetryHandler(int maxRetries) {
+    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
         this.maxRetries = maxRetries;
+        this.retrySleepTimeMS = retrySleepTimeMS;
     }
 
     @Override
@@ -96,7 +97,7 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         }
 
         if (retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+            SystemClock.sleep(retrySleepTimeMS);
         } else {
             exception.printStackTrace();
         }
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
index 8e73471a..879abb1f 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -4,6 +4,7 @@
 import android.os.Message;
 
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
@@ -19,7 +20,7 @@
     protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
 
         @Override
-        protected void sendResponseMessage(org.apache.http.HttpResponse response) {
+        protected void sendResponseMessage(HttpResponse response) {
             responseCode = response.getStatusLine().getStatusCode();
             super.sendResponseMessage(response);
         }
@@ -27,7 +28,7 @@ protected void sendResponseMessage(org.apache.http.HttpResponse response) {
         @Override
         protected void sendMessage(Message msg) {
             /*
-			 * Dont use the handler and send it directly to the analysis
+             * Dont use the handler and send it directly to the analysis
 			 * (because its all the same thread)
 			 */
             handleMessage(msg);
@@ -63,7 +64,7 @@ protected void sendRequest(DefaultHttpClient client,
         }
 
 		/*
-		 * will execute the request directly
+         * will execute the request directly
 		 */
         new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
                 .run();
@@ -73,13 +74,12 @@ protected void sendRequest(DefaultHttpClient client,
 
     public void delete(String url, RequestParams queryParams,
                        AsyncHttpResponseHandler responseHandler) {
-        // TODO what about query params??
-        delete(url, responseHandler);
+        delete(getUrlWithQueryString(isUrlEncodingEnabled(), url, queryParams), responseHandler);
     }
 
     public String get(String url, RequestParams params) {
         this.get(url, params, responseHandler);
-		/*
+        /*
 		 * the response handler will have set the result when this line is
 		 * reached
 		 */
@@ -101,7 +101,7 @@ public String put(String url) {
         return result;
     }
 
-    public String post(String url, HttpEntity entity){
+    public String post(String url, HttpEntity entity) {
         this.post(null, url, entity, null, responseHandler);
         return result;
     }
