diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/.travis.yml b/.travis.yml
old mode 100644
new mode 100755
index 69ae732e..201b1af9
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,10 +1,7 @@
-branches:
-  only:
-    - master
 language:
   - java
 jdk:
-  - openjdk6
+  - openjdk7
 before_install:
   # environment info
   - mvn -version
@@ -16,22 +13,22 @@ before_install:
   # for gradle output style
   - export TERM=dumb
   # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.10-bin.zip
-  - unzip -qq gradle-1.10-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.10
+  - wget http://services.gradle.org/distributions/gradle-1.12-bin.zip
+  - unzip -qq gradle-1.12-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.12
   - export PATH=$GRADLE_HOME/bin:$PATH
   # just to test gradle version, against our provided one
   - gradle -v
-  # newest android SDK 22.3
-  - wget http://dl.google.com/android/android-sdk_r22.3-linux.tgz
-  - tar -zxf android-sdk_r22.3-linux.tgz
+  # newest android SDK 22.6.2
+  - wget http://dl.google.com/android/android-sdk_r22.6.2-linux.tgz
+  - tar -zxf android-sdk_r22.6.2-linux.tgz
   - export ANDROID_HOME=`pwd`/android-sdk-linux
   - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
   # manually set sdk.dir variable, according to local paths
   - echo "sdk.dir=$ANDROID_HOME" > local.properties
   # list packages for debug purpose
   - android list sdk -a -e -u
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.1 --force --no-ui
+  - echo yes | android update sdk -t 1,2,3,tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.1.0 --force --no-ui
   # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..9ef10325
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,44 @@
+CONTRIBUTING
+============
+AsyncHttpClient is an open-source project made by developers for developers!
+
+If you would like to contribute to the project, it's really great. You can contribute in a variety of ways:
+
+  * Help us with test cases and examples for the Wiki (and kindly follow our [Coding Standards](#coding-standards))
+  * If you have a good idea/patch for the project, create a [pull request](#pull-requests)
+  * Found a bug? You're more than welcome to [submit an issue](#issues)
+  * Help other fellow developers solve their problems, you're welcome to do so in issues
+
+We do require certain guidelines to be followed so that the quality of the project remains top-notch:
+
+PULL requests
+-------------
+When you submit a patch or a new functionality for the project, you must open a pull request. We will get to the pull request as soon as possible, investigate what functionality or bug fixes have been added and decide whether to include it in the library or not -- for the benefit of everyone.
+
+**You agree that all contributions that you make to the library will be distributed further under the same license as the library itself (Apache V2).**
+
+Don't be discouraged if your pull request is rejected. This is not a deadline and sometimes with a proper explanation on your side, we are persuaded to merge in the request. Just remember that this is a library for everyone and as such must meet certain, generic rules that we would like to believe are following.  
+
+ISSUES
+---------
+The issues system is the place to report bugs and not for submitting patches or new functionality. As helpful as we would like to be, we cannot replace the developer and we certainly do not see what you're seeing. So when you come to report an issue, follow these simple rules:  
+
+  * Report bugs in the English language only
+  * Use Markdown to format your issue in a fashionable way (easier to read): [Familiarize yourself](https://help.github.com/articles/github-flavored-markdown)
+  * If the issue is due to a crash, include the stack trace -- `throwable.printStackTrace()` -- and any other detail that will shed light on the problem
+  * We need to see the source code (minus certain details that you think are confidential) that caused the problem in the first place, so include it too
+
+Opening issues without providing us with the information necessary to debug and fix it is useless; so we will close such issues within 7 days period  
+
+CODING STANDARDS
+----------------
+We need you to follow certain rules when sending source code contributions. These are the basic principles that we ourselves abide to and we require that you do so as well:
+
+  * Do not use the Tab character (it's in first place for a reason)
+  * Indentation is 4 spaces
+  * Include the copyright info (as in other files) at the top of the class file
+  * You must provide proper Javadoc, including description, in English for both public and protected methods, classes and properties
+  * Group packages that belong to the same top-level package together, followed by an empty line
+  * Add an empty line after and before class/interface declarations, methods and constructors
+  * Add an empty line before and after a group of properties
+  * Do not catch generic Exception/Throwable errors, but always catch the most specific type of the exception/error
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index fe5fed6b..182a9605
--- a/README.md
+++ b/README.md
@@ -1,7 +1,6 @@
 Asynchronous Http Client for Android
 ====================================
-
-Travis CI state : [![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
+[![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
 
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
@@ -13,7 +12,7 @@ Features
 - Requests use a **threadpool** to cap concurrent resource usage
 - GET/POST **params builder** (RequestParams)
 - **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **19kb** for everything
+- Tiny size overhead to your application, only **60kb** for everything
 - Automatic smart **request retries** optimized for spotty mobile connections
 - Automatic **gzip** response decoding support for super-fast requests
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
@@ -28,7 +27,7 @@ https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/androi
 ```
 Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
+ArtifactId: android-async-http
 Version: 1.4.5-SNAPSHOT
 Packaging: JAR or AAR
 ```
diff --git a/build.gradle b/build.gradle
old mode 100644
new mode 100755
index 37955d18..dbd2f8ed
--- a/build.gradle
+++ b/build.gradle
@@ -21,6 +21,7 @@ allprojects {
 
     tasks.withType(JavaCompile) {
         options.encoding = "UTF-8"
+        options.compilerArgs << "-Xlint:unchecked"
     }
 }
 
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
deleted file mode 100644
index 998daa1f..00000000
--- a/examples/CookieVideoView.java
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.media.MediaPlayer.OnInfoListener;
-import android.net.Uri;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.widget.MediaController;
-import android.widget.MediaController.MediaPlayerControl;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.http.cookie.Cookie;
-
-/**
- * Displays a video file.  The VideoView class
- * can load images from various sources (such as resources or content
- * providers), takes care of computing its measurement from the video so that
- * it can be used in any layout manager, and provides various display options
- * such as scaling and tinting.
- *
- * @author Jungho Bang <me@bangtoven.com>
- */
-public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
-    private String TAG = "CookieVideoView";
-    // settable by the client
-    private Uri         mUri;
-    private Map<String, String> mHeaders;
-
-    // all possible internal states
-    private static final int STATE_ERROR              = -1;
-    private static final int STATE_IDLE               = 0;
-    private static final int STATE_PREPARING          = 1;
-    private static final int STATE_PREPARED           = 2;
-    private static final int STATE_PLAYING            = 3;
-    private static final int STATE_PAUSED             = 4;
-    private static final int STATE_PLAYBACK_COMPLETED = 5;
-
-    // mCurrentState is a VideoView object's current state.
-    // mTargetState is the state that a method caller intends to reach.
-    // For instance, regardless the VideoView object's current state,
-    // calling pause() intends to bring the object to a target state
-    // of STATE_PAUSED.
-    private int mCurrentState = STATE_IDLE;
-    private int mTargetState  = STATE_IDLE;
-
-    // All the stuff we need for playing and showing a video
-    private SurfaceHolder mSurfaceHolder = null;
-    private MediaPlayer mMediaPlayer = null;
-    private int         mVideoWidth;
-    private int         mVideoHeight;
-    private int         mSurfaceWidth;
-    private int         mSurfaceHeight;
-    private MediaController mMediaController;
-    private OnCompletionListener mOnCompletionListener;
-    private MediaPlayer.OnPreparedListener mOnPreparedListener;
-    private int         mCurrentBufferPercentage;
-    private OnErrorListener mOnErrorListener;
-    private OnInfoListener  mOnInfoListener;
-    private int         mSeekWhenPrepared;  // recording the seek position while preparing
-    private boolean     mCanPause;
-    private boolean     mCanSeekBack;
-    private boolean     mCanSeekForward;
-	private Context 	mContext;
-
-    public CookieVideoView(Context context) {
-        super(context);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-        initVideoView(context);
-    }
-
-    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initVideoView(context);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        //Log.i("@@@@", "onMeasure");
-        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
-        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
-        if (mVideoWidth > 0 && mVideoHeight > 0) {
-            if ( mVideoWidth * height  > width * mVideoHeight ) {
-                //Log.i("@@@", "image too tall, correcting");
-                height = width * mVideoHeight / mVideoWidth;
-            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
-                //Log.i("@@@", "image too wide, correcting");
-                width = height * mVideoWidth / mVideoHeight;
-            } else {
-                //Log.i("@@@", "aspect ratio is correct: " +
-                        //width+"/"+height+"="+
-                        //mVideoWidth+"/"+mVideoHeight);
-            }
-        }
-        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
-        setMeasuredDimension(width, height);
-    }
-
-    @SuppressLint("NewApi")
-	@Override
-    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-        super.onInitializeAccessibilityEvent(event);
-        event.setClassName(CookieVideoView.class.getName());
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-	@Override
-    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
-        super.onInitializeAccessibilityNodeInfo(info);
-        info.setClassName(CookieVideoView.class.getName());
-    }
-
-    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
-        int result = desiredSize;
-        int specMode = MeasureSpec.getMode(measureSpec);
-        int specSize =  MeasureSpec.getSize(measureSpec);
-
-        switch (specMode) {
-            case MeasureSpec.UNSPECIFIED:
-                /* Parent says we can be as big as we want. Just don't be larger
-                 * than max size imposed on ourselves.
-                 */
-                result = desiredSize;
-                break;
-
-            case MeasureSpec.AT_MOST:
-                /* Parent says we can be as big as we want, up to specSize.
-                 * Don't be larger than specSize, and don't be larger than
-                 * the max size imposed on ourselves.
-                 */
-                result = Math.min(desiredSize, specSize);
-                break;
-
-            case MeasureSpec.EXACTLY:
-                // No choice. Do what we are told.
-                result = specSize;
-                break;
-        }
-        return result;
-}
-
-    private void initVideoView(Context context) {
-        mVideoWidth = 0;
-        mVideoHeight = 0;
-        getHolder().addCallback(mSHCallback);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-        setFocusable(true);
-        setFocusableInTouchMode(true);
-        requestFocus();
-        mCurrentState = STATE_IDLE;
-        mTargetState  = STATE_IDLE;
-        mContext = context;
-    }
-
-    public void setVideoPath(String path) {
-        setVideoURI(Uri.parse(path));
-    }
-
-    public void setVideoURI(Uri uri) {
-    	mUri = uri;
-        mHeaders = getCookieHeader();
-    	mSeekWhenPrepared = 0;
-        openVideo();
-        requestLayout();
-        invalidate();
-    }
-    
-    private Map<String,String> getCookieHeader() {
-    	String hostDomain = mUri.getHost();
-    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
-    	for(Cookie cookie : cookieList) {
-    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
-    			Map<String,String> header = new HashMap<String, String>();
-    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
-    	    	Log.d(TAG,"Cookie: "+header.toString());
-    	        return header;
-    	    }
-    	}
-    	return null;
-    }
-    
-    public void stopPlayback() {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.stop();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            mTargetState  = STATE_IDLE;
-        }
-    }
-
-    private void openVideo() {
-        if (mUri == null || mSurfaceHolder == null) {
-            // not ready for playback just yet, will try again later
-            return;
-        }
-        // Tell the music playback service to pause
-        // TODO: these constants need to be published somewhere in the framework.
-        Intent i = new Intent("com.android.music.musicservicecommand");
-        i.putExtra("command", "pause");
-        mContext.sendBroadcast(i);
-
-        // we shouldn't clear the target state, because somebody might have
-        // called start() previously
-        release(false);
-        try {
-            mMediaPlayer = new MediaPlayer();
-            mMediaPlayer.setOnPreparedListener(mPreparedListener);
-            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
-            mMediaPlayer.setOnCompletionListener(mCompletionListener);
-            mMediaPlayer.setOnErrorListener(mErrorListener);
-            mMediaPlayer.setOnInfoListener(mOnInfoListener);
-            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
-            mCurrentBufferPercentage = 0;
-            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
-            mMediaPlayer.setDisplay(mSurfaceHolder);
-            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mMediaPlayer.setScreenOnWhilePlaying(true);
-            mMediaPlayer.prepareAsync();
-            // we don't set the target state here either, but preserve the
-            // target state that was there before.
-            mCurrentState = STATE_PREPARING;
-            attachMediaController();
-        } catch (IOException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        } catch (IllegalArgumentException ex) {
-            Log.w(TAG, "Unable to open content: " + mUri, ex);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
-            return;
-        }
-    }
-
-    public void setMediaController(MediaController controller) {
-        if (mMediaController != null) {
-            mMediaController.hide();
-        }
-        mMediaController = controller;
-        attachMediaController();
-    }
-
-    private void attachMediaController() {
-        if (mMediaPlayer != null && mMediaController != null) {
-            mMediaController.setMediaPlayer(this);
-            View anchorView = this.getParent() instanceof View ?
-                    (View)this.getParent() : this;
-            mMediaController.setAnchorView(anchorView);
-            mMediaController.setEnabled(isInPlaybackState());
-        }
-    }
-
-    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
-        new MediaPlayer.OnVideoSizeChangedListener() {
-            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-                mVideoWidth = mp.getVideoWidth();
-                mVideoHeight = mp.getVideoHeight();
-                if (mVideoWidth != 0 && mVideoHeight != 0) {
-                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                    requestLayout();
-                }
-            }
-    };
-
-    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
-        public void onPrepared(MediaPlayer mp) {
-            mCurrentState = STATE_PREPARED;
-
-            // Get the capabilities of the player for this stream
-//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
-//                                      MediaPlayer.BYPASS_METADATA_FILTER);
-//            
-//          if (data != null) {
-//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
-//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
-//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
-//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
-//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
-//            } else {
-                mCanPause = mCanSeekBack = mCanSeekForward = true;
-//            }
-
-            if (mOnPreparedListener != null) {
-                mOnPreparedListener.onPrepared(mMediaPlayer);
-            }
-            if (mMediaController != null) {
-                mMediaController.setEnabled(true);
-            }
-            mVideoWidth = mp.getVideoWidth();
-            mVideoHeight = mp.getVideoHeight();
-
-            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
-            if (seekToPosition != 0) {
-                seekTo(seekToPosition);
-            }
-            if (mVideoWidth != 0 && mVideoHeight != 0) {
-                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
-                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
-                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
-                    // We didn't actually change the size (it was already at the size
-                    // we need), so we won't get a "surface changed" callback, so
-                    // start the video here instead of in the callback.
-                    if (mTargetState == STATE_PLAYING) {
-                        start();
-                        if (mMediaController != null) {
-                            mMediaController.show();
-                        }
-                    } else if (!isPlaying() &&
-                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
-                       if (mMediaController != null) {
-                           // Show the media controls when we're paused into a video and make 'em stick.
-                           mMediaController.show(0);
-                       }
-                   }
-                }
-            } else {
-                // We don't know the video size yet, but should start anyway.
-                // The video size might be reported to us later.
-                if (mTargetState == STATE_PLAYING) {
-                    start();
-                }
-            }
-        }
-    };
-
-    private MediaPlayer.OnCompletionListener mCompletionListener =
-        new MediaPlayer.OnCompletionListener() {
-        public void onCompletion(MediaPlayer mp) {
-            mCurrentState = STATE_PLAYBACK_COMPLETED;
-            mTargetState = STATE_PLAYBACK_COMPLETED;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-            if (mOnCompletionListener != null) {
-                mOnCompletionListener.onCompletion(mMediaPlayer);
-            }
-        }
-    };
-
-    private MediaPlayer.OnErrorListener mErrorListener =
-        new MediaPlayer.OnErrorListener() {
-        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
-            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
-            mCurrentState = STATE_ERROR;
-            mTargetState = STATE_ERROR;
-            if (mMediaController != null) {
-                mMediaController.hide();
-            }
-
-            /* If an error handler has been supplied, use it and finish. */
-            if (mOnErrorListener != null) {
-                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
-                    return true;
-                }
-            }
-
-            /* Otherwise, pop up an error dialog so the user knows that
-             * something bad has happened. Only try and pop up the dialog
-             * if we're attached to a window. When we're going away and no
-             * longer have a window, don't bother showing the user an error.
-             */
-            if (getWindowToken() != null) {
-//                Resources r = mContext.getResources();
-                int messageId;
-
-                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
-                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
-                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
-                } else {
-                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
-                    messageId = R.string.VideoView_error_text_unknown;
-                }
-
-                new AlertDialog.Builder(mContext)
-                        .setMessage(messageId)
-                        //eg. <string name="VideoView_error_button">OK</string>
-                        .setPositiveButton(R.string.VideoView_error_button,
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int whichButton) {
-                                        /* If we get here, there is no onError listener, so
-                                         * at least inform them that the video is over.
-                                         */
-                                        if (mOnCompletionListener != null) {
-                                            mOnCompletionListener.onCompletion(mMediaPlayer);
-                                        }
-                                    }
-                                })
-                        .setCancelable(false)
-                        .show();
-            }
-            return true;
-        }
-    };
-
-    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
-        new MediaPlayer.OnBufferingUpdateListener() {
-        public void onBufferingUpdate(MediaPlayer mp, int percent) {
-            mCurrentBufferPercentage = percent;
-        }
-    };
-
-    /**
-     * Register a callback to be invoked when the media file
-     * is loaded and ready to go.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
-    {
-        mOnPreparedListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when the end of a media file
-     * has been reached during playback.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnCompletionListener(OnCompletionListener l)
-    {
-        mOnCompletionListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an error occurs
-     * during playback or setup.  If no listener is specified,
-     * or if the listener returned false, VideoView will inform
-     * the user of any errors.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnErrorListener(OnErrorListener l)
-    {
-        mOnErrorListener = l;
-    }
-
-    /**
-     * Register a callback to be invoked when an informational event
-     * occurs during playback or setup.
-     *
-     * @param l The callback that will be run
-     */
-    public void setOnInfoListener(OnInfoListener l) {
-        mOnInfoListener = l;
-    }
-
-    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
-    {
-        public void surfaceChanged(SurfaceHolder holder, int format,
-                                    int w, int h)
-        {
-            mSurfaceWidth = w;
-            mSurfaceHeight = h;
-            boolean isValidState =  (mTargetState == STATE_PLAYING);
-            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
-            if (mMediaPlayer != null && isValidState && hasValidSize) {
-                if (mSeekWhenPrepared != 0) {
-                    seekTo(mSeekWhenPrepared);
-                }
-                start();
-            }
-        }
-
-        public void surfaceCreated(SurfaceHolder holder)
-        {
-            mSurfaceHolder = holder;
-            openVideo();
-        }
-
-        public void surfaceDestroyed(SurfaceHolder holder)
-        {
-            // after we return from this we can't use the surface any more
-            mSurfaceHolder = null;
-            if (mMediaController != null) mMediaController.hide();
-            release(true);
-        }
-    };
-
-    /*
-     * release the media player in any state
-     */
-    private void release(boolean cleartargetstate) {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.reset();
-            mMediaPlayer.release();
-            mMediaPlayer = null;
-            mCurrentState = STATE_IDLE;
-            if (cleartargetstate) {
-                mTargetState  = STATE_IDLE;
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onTrackballEvent(MotionEvent ev) {
-        if (isInPlaybackState() && mMediaController != null) {
-            toggleMediaControlsVisiblity();
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
-                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
-                                     keyCode != KeyEvent.KEYCODE_MENU &&
-                                     keyCode != KeyEvent.KEYCODE_CALL &&
-                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
-        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
-            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
-                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                } else {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
-                if (!mMediaPlayer.isPlaying()) {
-                    start();
-                    mMediaController.hide();
-                }
-                return true;
-            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
-                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
-                if (mMediaPlayer.isPlaying()) {
-                    pause();
-                    mMediaController.show();
-                }
-                return true;
-            } else {
-                toggleMediaControlsVisiblity();
-            }
-        }
-
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void toggleMediaControlsVisiblity() {
-        if (mMediaController.isShowing()) {
-            mMediaController.hide();
-        } else {
-            mMediaController.show();
-        }
-    }
-
-    public void start() {
-        if (isInPlaybackState()) {
-            mMediaPlayer.start();
-            mCurrentState = STATE_PLAYING;
-        }
-        mTargetState = STATE_PLAYING;
-    }
-
-    public void pause() {
-        if (isInPlaybackState()) {
-            if (mMediaPlayer.isPlaying()) {
-                mMediaPlayer.pause();
-                mCurrentState = STATE_PAUSED;
-            }
-        }
-        mTargetState = STATE_PAUSED;
-    }
-
-    public void suspend() {
-        release(false);
-    }
-
-    public void resume() {
-        openVideo();
-    }
-
-    public int getDuration() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getDuration();
-        }
-
-        return -1;
-    }
-
-    public int getCurrentPosition() {
-        if (isInPlaybackState()) {
-            return mMediaPlayer.getCurrentPosition();
-        }
-        return 0;
-    }
-
-    public void seekTo(int msec) {
-        if (isInPlaybackState()) {
-            mMediaPlayer.seekTo(msec);
-            mSeekWhenPrepared = 0;
-        } else {
-            mSeekWhenPrepared = msec;
-        }
-    }
-
-    public boolean isPlaying() {
-        return isInPlaybackState() && mMediaPlayer.isPlaying();
-    }
-
-    public int getBufferPercentage() {
-        if (mMediaPlayer != null) {
-            return mCurrentBufferPercentage;
-        }
-        return 0;
-    }
-
-    private boolean isInPlaybackState() {
-        return (mMediaPlayer != null &&
-                mCurrentState != STATE_ERROR &&
-                mCurrentState != STATE_IDLE &&
-                mCurrentState != STATE_PREPARING);
-    }
-
-    public boolean canPause() {
-        return mCanPause;
-    }
-
-    public boolean canSeekBackward() {
-        return mCanSeekBack;
-    }
-
-    public boolean canSeekForward() {
-        return mCanSeekForward;
-    }
-}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
deleted file mode 100644
index b5c4fc6f..00000000
--- a/examples/ExampleUsage.java
+++ /dev/null
@@ -1,12 +0,0 @@
-public class ExampleUsage {
-    public static void makeRequest() {
-        AsyncHttpClient client = new AsyncHttpClient();
-
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
-            @Override
-            public void onSuccess(String response) {
-                System.out.println(response);
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
deleted file mode 100644
index ce949817..00000000
--- a/examples/TestCaseExampleUsage.java
+++ /dev/null
@@ -1,63 +0,0 @@
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
-import android.test.InstrumentationTestCase;
-import android.util.Log;
-
-// Credits to Wuyexiong <forever_crying@qq.com>
-// See: https://github.com/loopj/android-async-http/pull/236
-public class TestCaseExampleUsage extends InstrumentationTestCase
-{
-	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
-
-	public void testAsync() throws Throwable
-	{
-		final CountDownLatch signal = new CountDownLatch(1);
-		runTestOnUiThread(new Runnable()
-		{
-			@Override
-			public void run()
-			{
-				AsyncHttpClient client = new AsyncHttpClient();
-
-				client.get("http://www.google.com", new AsyncHttpResponseHandler()
-				{
-					@Override
-					public void onStart()
-					{
-						Log.v(TAG , "onStart");
-					}
-
-					@Override
-					public void onSuccess(String response)
-					{
-						Log.v(TAG , "onSuccess");
-						System.out.println(response);
-					}
-
-					@Override
-					public void onFailure(Throwable error, String content)
-					{
-						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
-					}
-
-					@Override
-					public void onFinish()
-					{
-						Log.v(TAG , "onFinish");
-						signal.countDown();
-					}
-				});
-
-				try {
-					signal.await(30, TimeUnit.SECONDS);
-				} catch (InterruptedException e) {
-				}
-				Log.v(TAG , "TestCaseExampleUsage Over");
-			}
-		});
-	}
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
deleted file mode 100644
index 395273df..00000000
--- a/examples/TwitterRestClient.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// Static wrapper library around AsyncHttpClient
-
-public class TwitterRestClient {
-    private static final String BASE_URL = "http://api.twitter.com/1/";
-
-    private static AsyncHttpClient client = new AsyncHttpClient();
-
-    public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.get(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        client.post(getAbsoluteUrl(url), params, responseHandler);
-    }
-
-    private static String getAbsoluteUrl(String relativeUrl) {
-        return BASE_URL + relativeUrl;
-    }
-}
\ No newline at end of file
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
deleted file mode 100644
index 297bfecc..00000000
--- a/examples/TwitterRestClientUsage.java
+++ /dev/null
@@ -1,18 +0,0 @@
-class TwitterRestClientUsage {
-    public void getPublicTimeline() {
-        TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
-            @Override
-            public void onSuccess(JSONArray timeline) {
-                try {
-                    JSONObject firstEvent = (JSONObject) timeline.get(0);
-                    String tweetText = firstEvent.getString("text");
-
-                    // Do something with the response
-                    System.out.println(tweetText);
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
old mode 100644
new mode 100755
index faf4d955..01f4bd2c
--- a/gradle.properties
+++ b/gradle.properties
@@ -10,3 +10,7 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=jamessmith
+POM_DEVELOPER_NAME=James Smith
+
diff --git a/library/build.gradle b/library/build.gradle
old mode 100644
new mode 100755
index 5f7d8954..691a1a44
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -2,37 +2,31 @@ apply plugin: 'android-library'
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.3'
+    buildToolsVersion '19.1'
 
     defaultConfig {
         minSdkVersion 3
         targetSdkVersion 19
     }
-    
+
     lintOptions {
-        abortOnError false
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
     }
-}
 
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "android${name.capitalize()}Jar", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
+    }
 }
 
 android.libraryVariants.all { variant ->
-
-    task("generate${variant.name}Javadoc", type: Javadoc) {
-        description "Generates Javadoc for $variant.name."
-        source = variant.javaCompile.source
-        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
-    }
-
+    def name = variant.buildType.name
+    def task = project.tasks.create "jar${name.capitalize()}", Jar
+    task.dependsOn variant.javaCompile
+    task.from variant.javaCompile.destinationDir
+    artifacts.add('archives', task);
 }
 
diff --git a/library/gradle.properties b/library/gradle.properties
old mode 100644
new mode 100755
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
index f45dcd47..d7a1fcad
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http"
-    android:versionName="1.4.5-SNAPSHOT"
-    android:versionCode="145">
+          package="com.loopj.android.http"
+          android:versionName="1.4.5-SNAPSHOT"
+          android:versionCode="145">
 
-    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
-    <application />
+    <application/>
 
 </manifest> 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
old mode 100644
new mode 100755
index 7e9867c9..7e49df73
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -19,11 +19,13 @@
 package com.loopj.android.http;
 
 import android.content.Context;
+import android.os.Looper;
 import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpException;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
@@ -31,9 +33,13 @@
 import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
+import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
+import org.apache.http.client.RedirectHandler;
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
@@ -41,6 +47,7 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
@@ -50,19 +57,24 @@
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.auth.BasicScheme;
 import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PushbackInputStream;
+import java.net.URI;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -71,7 +83,6 @@
 import java.util.WeakHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.zip.GZIPInputStream;
 
 
@@ -82,17 +93,26 @@
  * ResponseHandlerInterface} instance. <p>&nbsp;</p> For example: <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new ResponseHandlerInterface() {
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
  *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+ *          System.out.println(response);
+ *     }
+ *     &#064;Override
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable
+ * error)
+ * {
+ *          error.printStackTrace(System.out);
  *     }
  * });
  * </pre>
+ *
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ * @see com.loopj.android.http.ResponseHandlerInterface
+ * @see com.loopj.android.http.RequestParams
  */
 public class AsyncHttpClient {
 
-    public static final String VERSION = "1.4.5";
     public static final int DEFAULT_MAX_CONNECTIONS = 10;
     public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     public static final int DEFAULT_MAX_RETRIES = 5;
@@ -205,12 +225,11 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = Executors.newCachedThreadPool();
-        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
+        threadPool = getDefaultThreadPool();
+        requestMap = Collections.synchronizedMap(new WeakHashMap<Context, List<RequestHandle>>());
         clientHeaderMap = new HashMap<String, String>();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
@@ -222,6 +241,14 @@ public void process(HttpRequest request, HttpContext context) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
                 }
                 for (String header : clientHeaderMap.keySet()) {
+                    if (request.containsHeader(header)) {
+                        Header overwritten = request.getFirstHeader(header);
+                        Log.d(LOG_TAG,
+                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
+                                        header, clientHeaderMap.get(header),
+                                        overwritten.getName(), overwritten.getValue())
+                        );
+                    }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
             }
@@ -246,6 +273,25 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                        ClientContext.CREDS_PROVIDER);
+                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+                if (authState.getAuthScheme() == null) {
+                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+                    Credentials creds = credsProvider.getCredentials(authScope);
+                    if (creds != null) {
+                        authState.setAuthScheme(new BasicScheme());
+                        authState.setCredentials(creds);
+                    }
+                }
+            }
+        }, 0);
+
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
@@ -296,26 +342,75 @@ public void setCookieStore(CookieStore cookieStore) {
      * Overrides the threadpool implementation used when queuing/pooling requests. By default,
      * Executors.newFixedThreadPool() is used.
      *
-     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling
+     * @param threadPool an instance of {@link ExecutorService} to use for queuing/pooling
      *                   requests.
      */
-    public void setThreadPool(ThreadPoolExecutor threadPool) {
+    public void setThreadPool(ExecutorService threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * used.
+     *
+     * @return current executor service used
+     */
+    public ExecutorService getThreadPool() {
+        return threadPool;
+    }
+
+    /**
+     * Get the default threading pool to be used for this HTTP client.
+     *
+     * @return The default threading pool to be used
+     */
+    protected ExecutorService getDefaultThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
-     * on underlying HttpClient, effects of this method will be canceled.
+     * on underlying HttpClient, effects of this method will be canceled. <p>&nbsp;</p> Default
+     * setting is to disallow redirects.
      *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @param enableCircularRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
+        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
+        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
+        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
+    }
+
+    /**
+     * Circular redirects are enabled by default
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
+        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
+    }
+
+    /**
      * @param enableRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
      */
     public void setEnableRedirects(final boolean enableRedirects) {
-        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
-            @Override
-            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
-                return enableRedirects;
-            }
-        });
+        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
+    }
+
+    /**
+     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
+     * your needs
+     *
+     * @param customRedirectHandler RedirectHandler instance
+     * @see com.loopj.android.http.MyRedirectHandler
+     */
+    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
+        httpClient.setRedirectHandler(customRedirectHandler);
     }
 
     /**
@@ -404,7 +499,6 @@ public void setProxy(String hostname, int port, String username, String password
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
-
     /**
      * Sets the SSLSocketFactory to user when making requests. By default, a new, default
      * SSLSocketFactory is used.
@@ -425,6 +519,14 @@ public void setMaxRetriesAndTimeout(int retries, int timeout) {
         this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries, timeout));
     }
 
+    /**
+     * Will, before sending, remove all headers currently present in AsyncHttpClient instance, which
+     * applies on all requests this client makes
+     */
+    public void removeAllHeaders() {
+        clientHeaderMap.clear();
+    }
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
      *
@@ -452,8 +554,19 @@ public void removeHeader(String header) {
      * @param password Basic Auth password
      */
     public void setBasicAuth(String username, String password) {
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(username, password, scope);
+        setBasicAuth(username, password, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, boolean preemtive) {
+        setBasicAuth(username, password, null, preemtive);
     }
 
     /**
@@ -465,12 +578,40 @@ public void setBasicAuth(String username, String password) {
      * @param scope    - an AuthScope object
      */
     public void setBasicAuth(String username, String password, AuthScope scope) {
+        setBasicAuth(username, password, scope, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param scope     an AuthScope object
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemtive) {
         UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+        this.httpClient.getCredentialsProvider().setCredentials(scope == null ? AuthScope.ANY : scope, credentials);
+        setAuthenticationPreemptive(preemtive);
     }
 
     /**
-     * Removes set basic auth credentials
+     * Sets HttpRequestInterceptor which handles authorization in preemtive way, as workaround you
+     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
+     *
+     * @param isPreemtive whether the authorization is processed in preemtive way
+     */
+    public void setAuthenticationPreemptive(boolean isPreemtive) {
+        if (isPreemtive) {
+            httpClient.addRequestInterceptor(new PreemtiveAuthorizationHttpRequestInterceptor(), 0);
+        } else {
+            httpClient.removeRequestInterceptorByClass(PreemtiveAuthorizationHttpRequestInterceptor.class);
+        }
+    }
+
+    /**
+     * Removes previously set basic auth credentials
      */
     public void clearBasicAuth() {
         this.httpClient.getCredentialsProvider().clear();
@@ -486,16 +627,50 @@ public void clearBasicAuth() {
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
      *                              pending requests.
      */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<RequestHandle> requestList = requestMap.get(context);
-        if (requestList != null) {
-            for (RequestHandle requestHandle : requestList) {
-                requestHandle.cancel(mayInterruptIfRunning);
+    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
+        if (context == null) {
+            Log.e(LOG_TAG, "Passed null Context to cancelRequests");
+            return;
+        }
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                List<RequestHandle> requestList = requestMap.get(context);
+                if (requestList != null) {
+                    for (RequestHandle requestHandle : requestList) {
+                        requestHandle.cancel(mayInterruptIfRunning);
+                    }
+                    requestMap.remove(context);
+                }
             }
-            requestMap.remove(context);
+        };
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            new Thread(r).start();
+        } else {
+            r.run();
         }
     }
 
+    /**
+     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
+     * only affect requests which were created with a non-null android Context. This method is
+     * intended to be used in the onDestroy method of your android activities to destroy all
+     * requests which are no longer required.
+     *
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelAllRequests(boolean mayInterruptIfRunning) {
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    requestHandle.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.clear();
+    }
+
     // [+] HTTP HEAD
 
     /**
@@ -688,7 +863,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -706,7 +881,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -730,7 +905,7 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -789,7 +964,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -808,7 +983,7 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -836,7 +1011,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -850,7 +1025,7 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
@@ -873,6 +1048,22 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
 
     // [-] HTTP DELETE
 
+    /**
+     * Instantiate a new asynchronous HTTP request for the passed parameters.
+     *
+     * @param client          HttpClient to be used for request, can differ in single requests
+     * @param contentType     MIME body type, for POST and PUT requests, may be null
+     * @param context         Context of Android application, to hold the reference of request
+     * @param httpContext     HttpContext in which the request will be executed
+     * @param responseHandler ResponseHandler or its subclass to put the response into
+     * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,
+     *                        HttpPost, HttpGet, HttpPut, etc.
+     * @return AsyncHttpRequest ready to be dispatched
+     */
+    protected AsyncHttpRequest newAsyncHttpRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        return new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+    }
+
     /**
      * Puts a new request in queue as a new thread in pool to be executed
      *
@@ -886,6 +1077,18 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
      * @return RequestHandle of future request process
      */
     protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        if (uriRequest == null) {
+            throw new IllegalArgumentException("HttpUriRequest must not be null");
+        }
+
+        if (responseHandler == null) {
+            throw new IllegalArgumentException("ResponseHandler must not be null");
+        }
+
+        if (responseHandler.getUseSynchronousMode()) {
+            throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
+        }
+
         if (contentType != null) {
             uriRequest.setHeader("Content-Type", contentType);
         }
@@ -893,7 +1096,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
         responseHandler.setRequestHeaders(uriRequest.getAllHeaders());
         responseHandler.setRequestURI(uriRequest.getURI());
 
-        AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler);
+        AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);
         threadPool.submit(request);
         RequestHandle requestHandle = new RequestHandle(request);
 
@@ -905,6 +1108,9 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
                 requestMap.put(context, requestList);
             }
 
+            if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
+                ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(uriRequest);
+
             requestList.add(requestHandle);
 
             Iterator<RequestHandle> iterator = requestList.iterator();
@@ -937,6 +1143,9 @@ public void setURLEncodingEnabled(boolean enabled) {
      * @return encoded url if requested with params appended if any available
      */
     public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url, RequestParams params) {
+        if (url == null)
+            return null;
+
         if (shouldEncodeUrl)
             url = url.replace(" ", "%20");
 
@@ -956,6 +1165,54 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
         return url;
     }
 
+    /**
+     * Checks the InputStream if it contains  GZIP compressed data
+     *
+     * @param inputStream InputStream to be checked
+     * @return true or false if the stream contains GZIP compressed data
+     * @throws java.io.IOException
+     */
+    public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {
+        if (inputStream == null)
+            return false;
+
+        byte[] signature = new byte[2];
+        int readStatus = inputStream.read(signature);
+        inputStream.unread(signature);
+        int streamHeader = ((int) signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);
+        return readStatus == 2 && GZIPInputStream.GZIP_MAGIC == streamHeader;
+    }
+
+    /**
+     * A utility function to close an input stream without raising an exception.
+     *
+     * @param is input stream to close safely
+     */
+    public static void silentCloseInputStream(InputStream is) {
+        try {
+            if (is != null) {
+                is.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close input stream", e);
+        }
+    }
+
+    /**
+     * A utility function to close an output stream without raising an exception.
+     *
+     * @param os output stream to close safely
+     */
+    public static void silentCloseOutputStream(OutputStream os) {
+        try {
+            if (os != null) {
+                os.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close output stream", e);
+        }
+    }
+
     /**
      * Returns HttpEntity containing data from RequestParams included with request declaration.
      * Allows also passing progress from upload via provided ResponseHandler
@@ -970,11 +1227,11 @@ private HttpEntity paramsToEntity(RequestParams params, ResponseHandlerInterface
             if (params != null) {
                 entity = params.getEntity(responseHandler);
             }
-        } catch (Throwable t) {
+        } catch (IOException e) {
             if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, null, t);
+                responseHandler.sendFailureMessage(0, null, null, e);
             else
-                t.printStackTrace();
+                e.printStackTrace();
         }
 
         return entity;
@@ -1009,7 +1266,12 @@ public InflatingEntity(HttpEntity wrapped) {
 
         @Override
         public InputStream getContent() throws IOException {
-            return new GZIPInputStream(wrappedEntity.getContent());
+            PushbackInputStream content = new PushbackInputStream(wrappedEntity.getContent(), 2);
+            if (isInputStreamGZIPCompressed(content)) {
+                return new GZIPInputStream(content);
+            } else {
+                return content;
+            }
         }
 
         @Override
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
old mode 100644
new mode 100755
index b9dc45ca..81786ceb
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -33,7 +33,7 @@
 /**
  * Internal class, representing the HttpRequest, done in asynchronous manner
  */
-class AsyncHttpRequest implements Runnable {
+public class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
@@ -166,9 +166,7 @@ public boolean isDone() {
 
     public boolean cancel(boolean mayInterruptIfRunning) {
         isCancelled = true;
-        if (mayInterruptIfRunning && request != null && !request.isAborted()) {
-            request.abort();
-        }
+        request.abort();
         return isCancelled();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 985c5267..256ab9c9
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -62,7 +62,7 @@
  *     }
  *
  *     &#064;Override
- *     public void onRetry() {
+ *     public void onRetry(int retryNo) {
  *         // Request was retried
  *     }
  *
@@ -91,10 +91,10 @@
 
     protected static final int BUFFER_SIZE = 4096;
 
-    private final Handler handler;
     public static final String DEFAULT_CHARSET = "UTF-8";
     private String responseCharset = DEFAULT_CHARSET;
-    private Boolean useSynchronousMode = false;
+    private Handler handler;
+    private boolean useSynchronousMode;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
@@ -142,6 +142,21 @@ public boolean getUseSynchronousMode() {
 
     @Override
     public void setUseSynchronousMode(boolean value) {
+        // A looper must be prepared before setting asynchronous mode.
+        if (!value && Looper.myLooper() == null) {
+            value = true;
+            Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
+        }
+
+        // If using synchronous mode.
+        if (!value && handler == null) {
+            // Create a handler on current thread to submit tasks
+            handler = new ResponderHandler(this);
+        } else if (value && handler != null) {
+            // TODO: Consider adding a flag to remove all queued messages.
+            handler = null;
+        }
+
         useSynchronousMode = value;
     }
 
@@ -163,11 +178,8 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
-        // There is always a handler ready for delivering messages.
-        handler = new ResponderHandler(this);
-
-        // Init Looper by calling postRunnable without an argument.
-        postRunnable(null);
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
     }
 
     /**
@@ -177,7 +189,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
-        Log.v(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
+        Log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
     }
 
     /**
@@ -306,7 +318,7 @@ protected void handleMessage(Message message) {
     }
 
     protected void sendMessage(Message msg) {
-        if (getUseSynchronousMode()) {
+        if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
             handler.sendMessage(msg);
@@ -319,15 +331,14 @@ protected void sendMessage(Message msg) {
      * @param runnable runnable instance, can be null
      */
     protected void postRunnable(Runnable runnable) {
-        boolean missingLooper = null == Looper.myLooper();
-        if (missingLooper) {
-            Looper.prepare();
-        }
-        if (null != runnable) {
-            handler.post(runnable);
-        }
-        if (missingLooper) {
-            Looper.loop();
+        if (runnable != null) {
+            if (getUseSynchronousMode() || handler == null) {
+                // This response handler is synchronous, run on current thread
+                runnable.run();
+            } else {
+                // Otherwise, run on provided handler
+                handler.post(runnable);
+            }
         }
     }
 
@@ -339,7 +350,17 @@ protected void postRunnable(Runnable runnable) {
      * @return Message instance, should not be null
      */
     protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
-        return handler.obtainMessage(responseMessageId, responseMessageData);
+        Message msg;
+        if (handler == null) {
+            msg = Message.obtain();
+            if (msg != null) {
+                msg.what = responseMessageId;
+                msg.obj = responseMessageData;
+            }
+        } else {
+            msg = Message.obtain(handler, responseMessageId, responseMessageData);
+        }
+        return msg;
     }
 
     @Override
@@ -376,7 +397,7 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                int buffersize = (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
+                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
                     ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
                     try {
@@ -386,10 +407,10 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                         while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
                             count += l;
                             buffer.append(tmp, 0, l);
-                            sendProgressMessage(count, (int) contentLength);
+                            sendProgressMessage(count, (int) (contentLength <= 0 ? 1 : contentLength));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
old mode 100644
new mode 100755
index e9bc1809..cc26d439
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -19,10 +19,8 @@
 import java.io.UnsupportedEncodingException;
 
 /**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
  */
 public class Base64 {
     /**
@@ -31,36 +29,31 @@
     public static final int DEFAULT = 0;
 
     /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
+     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
      */
     public static final int NO_PADDING = 1;
 
     /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
+     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
      */
     public static final int NO_WRAP = 2;
 
     /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
+     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
+     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
      */
     public static final int CRLF = 4;
 
     /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
+     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
+     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
+     * /}.
      */
     public static final int URL_SAFE = 8;
 
     /**
-     * Flag to pass to {@link Base64OutputStream} to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
+     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
+     * stream it is wrapping when it itself is closed.
      */
     public static final int NO_CLOSE = 16;
 
@@ -73,24 +66,20 @@
         public int op;
 
         /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
+         * Encode/decode another block of input data.  this.output is provided by the caller, and
+         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
          * of the coded data.
          *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
+         * @param finish true if this is the final call to process for this object.  Will finalize
+         *               the coder state and include any final bytes in the output.
+         * @return true if the input so far is good; false if some error has been detected in the
+         * input stream..
          */
         public abstract boolean process(byte[] input, int offset, int len, boolean finish);
 
         /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
+         * @return the maximum number of bytes a call to process() could produce for the given
+         * number of input bytes.  This may be an overestimate.
          */
         public abstract int maxOutputSize(int len);
     }
@@ -100,62 +89,53 @@
     //  --------------------------------------------------------
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param str   the input String to decode, which is converted to bytes using the default
+     *              charset
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(String str, int flags) {
         return decode(str.getBytes(), flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @return decoded bytes
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int flags) {
         return decode(input, 0, input.length, flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p>&nbsp;</p> <p>The padding '=' characters at the end are considered optional, but if any
+     * are present, there must be the correct number of them.
      *
      * @param input  the data to decode
      * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *               standard Base64.
+     * @return decoded bytes for given offset and length
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int offset, int len, int flags) {
         // Allocate space for the most data the input could represent.
         // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
 
         if (!decoder.process(input, offset, len, true)) {
             throw new IllegalArgumentException("bad base-64");
@@ -175,63 +155,61 @@
 
     /* package */ static class Decoder extends Coder {
         /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
+         * Lookup table for turning bytes into their position in the Base64 alphabet.
          */
         private static final int DECODE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
         /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
+         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
+         * and /.
          */
         private static final int DECODE_WEBSAFE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
-        /** Non-data values in the DECODE arrays. */
+        /**
+         * Non-data values in the DECODE arrays.
+         */
         private static final int SKIP = -1;
         private static final int EQUALS = -2;
 
         /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
+         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
+         * expecting exactly one more. State 5 is expecting no more data or padding characters in
+         * the input. State 6 is the error state; an error has been detected in the input and no
+         * future input can "fix" it.
          */
         private int state;   // state number (0 to 6)
         private int value;
@@ -247,18 +225,17 @@ public Decoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
          */
         public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
+            return len * 3 / 4 + 10;
         }
 
         /**
          * Decode another block of input data.
          *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
+         * @return true if the state machine is still healthy.  false if bad base-64 data has been
+         * detected in the input stream.
          */
         public boolean process(byte[] input, int offset, int len, boolean finish) {
             if (this.state == 6) return false;
@@ -293,13 +270,13 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // You can remove this whole block and the output should
                 // be the same, just slower.
                 if (state == 0) {
-                    while (p+4 <= len &&
-                           (value = ((alphabet[input[p] & 0xff] << 18) |
-                                     (alphabet[input[p+1] & 0xff] << 12) |
-                                     (alphabet[input[p+2] & 0xff] << 6) |
-                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
+                    while (p + 4 <= len &&
+                            (value = ((alphabet[input[p] & 0xff] << 18) |
+                                    (alphabet[input[p + 1] & 0xff] << 12) |
+                                    (alphabet[input[p + 2] & 0xff] << 6) |
+                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                        output[op + 2] = (byte) value;
+                        output[op + 1] = (byte) (value >> 8);
                         output[op] = (byte) (value >> 16);
                         op += 3;
                         p += 4;
@@ -315,78 +292,78 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 int d = alphabet[input[p++] & 0xff];
 
                 switch (state) {
-                case 0:
-                    if (d >= 0) {
-                        value = d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 1:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 2:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect exactly one more padding character.
-                        output[op++] = (byte) (value >> 4);
-                        state = 4;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 3:
-                    if (d >= 0) {
-                        // Emit the output triple and return to state 0.
-                        value = (value << 6) | d;
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        state = 0;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect no further data or padding characters.
-                        output[op+1] = (byte) (value >> 2);
-                        output[op] = (byte) (value >> 10);
-                        op += 2;
-                        state = 5;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 4:
-                    if (d == EQUALS) {
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 5:
-                    if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
+                    case 0:
+                        if (d >= 0) {
+                            value = d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 1:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 2:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect exactly one more padding character.
+                            output[op++] = (byte) (value >> 4);
+                            state = 4;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 3:
+                        if (d >= 0) {
+                            // Emit the output triple and return to state 0.
+                            value = (value << 6) | d;
+                            output[op + 2] = (byte) value;
+                            output[op + 1] = (byte) (value >> 8);
+                            output[op] = (byte) (value >> 16);
+                            op += 3;
+                            state = 0;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect no further data or padding characters.
+                            output[op + 1] = (byte) (value >> 2);
+                            output[op] = (byte) (value >> 10);
+                            op += 2;
+                            state = 5;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 4:
+                        if (d == EQUALS) {
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 5:
+                        if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
                 }
             }
 
@@ -403,33 +380,33 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
             // the state machine and finish up.
 
             switch (state) {
-            case 0:
-                // Output length is a multiple of three.  Fine.
-                break;
-            case 1:
-                // Read one extra input byte, which isn't enough to
-                // make another output byte.  Illegal.
-                this.state = 6;
-                return false;
-            case 2:
-                // Read two extra input bytes, enough to emit 1 more
-                // output byte.  Fine.
-                output[op++] = (byte) (value >> 4);
-                break;
-            case 3:
-                // Read three extra input bytes, enough to emit 2 more
-                // output bytes.  Fine.
-                output[op++] = (byte) (value >> 10);
-                output[op++] = (byte) (value >> 2);
-                break;
-            case 4:
-                // Read one padding '=' when we expected 2.  Illegal.
-                this.state = 6;
-                return false;
-            case 5:
-                // Read all the padding '='s we expected and no more.
-                // Fine.
-                break;
+                case 0:
+                    // Output length is a multiple of three.  Fine.
+                    break;
+                case 1:
+                    // Read one extra input byte, which isn't enough to
+                    // make another output byte.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 2:
+                    // Read two extra input bytes, enough to emit 1 more
+                    // output byte.  Fine.
+                    output[op++] = (byte) (value >> 4);
+                    break;
+                case 3:
+                    // Read three extra input bytes, enough to emit 2 more
+                    // output bytes.  Fine.
+                    output[op++] = (byte) (value >> 10);
+                    output[op++] = (byte) (value >> 2);
+                    break;
+                case 4:
+                    // Read one padding '=' when we expected 2.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 5:
+                    // Read all the padding '='s we expected and no more.
+                    // Fine.
+                    break;
             }
 
             this.state = state;
@@ -443,13 +420,12 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
     //  --------------------------------------------------------
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     * @return base64 string containing encoded input
      */
     public static String encodeToString(byte[] input, int flags) {
         try {
@@ -461,16 +437,14 @@ public static String encodeToString(byte[] input, int flags) {
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     * @return base64 string containing encoded range of input
      */
     public static String encodeToString(byte[] input, int offset, int len, int flags) {
         try {
@@ -482,29 +456,26 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
      */
     public static byte[] encode(byte[] input, int flags) {
         return encode(input, 0, input.length, flags);
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
+     * @return base64 encoded input as bytes
      */
     public static byte[] encode(byte[] input, int offset, int len, int flags) {
         Encoder encoder = new Encoder(flags, null);
@@ -519,54 +490,59 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
             }
         } else {
             switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
+                case 0:
+                    break;
+                case 1:
+                    output_len += 2;
+                    break;
+                case 2:
+                    output_len += 3;
+                    break;
             }
         }
 
         // Account for the newlines, if any.
         if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                (encoder.do_cr ? 2 : 1);
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                    (encoder.do_cr ? 2 : 1);
         }
 
         encoder.output = new byte[output_len];
         encoder.process(input, offset, len, true);
 
-        assert encoder.op == output_len;
+        if (BuildConfig.DEBUG && encoder.op != output_len) {
+            throw new AssertionError();
+        }
 
         return encoder.output;
     }
 
     /* package */ static class Encoder extends Coder {
         /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
+         * (the maximum allowable according to <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC
+         * 2045</a>).
          */
         public static final int LINE_GROUPS = 19;
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
         };
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE_WEBSAFE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
         };
 
         final private byte[] tail;
@@ -593,11 +569,10 @@ public Encoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
          */
         public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
+            return len * 8 / 5 + 10;
         }
 
         public boolean process(byte[] input, int offset, int len, boolean finish) {
@@ -621,22 +596,22 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     break;
 
                 case 1:
-                    if (p+2 <= len) {
+                    if (p + 2 <= len) {
                         // A 1-byte tail with at least 2 bytes of
                         // input available now.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((input[p++] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((input[p++] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
 
                 case 2:
-                    if (p+1 <= len) {
+                    if (p + 1 <= len) {
                         // A 2-byte tail with at least 1 byte of input.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((tail[1] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((tail[1] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
@@ -659,14 +634,14 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
 
             // The main loop, turning 3 input bytes into 4 output bytes on
             // each iteration.
-            while (p+3 <= len) {
+            while (p + 3 <= len) {
                 v = ((input[p] & 0xff) << 16) |
-                    ((input[p+1] & 0xff) << 8) |
-                    (input[p+2] & 0xff);
+                        ((input[p + 1] & 0xff) << 8) |
+                        (input[p + 2] & 0xff);
                 output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
+                output[op + 1] = alphabet[(v >> 12) & 0x3f];
+                output[op + 2] = alphabet[(v >> 6) & 0x3f];
+                output[op + 3] = alphabet[v & 0x3f];
                 p += 3;
                 op += 4;
                 if (--count == 0) {
@@ -682,7 +657,7 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // remaining in input; there should be at most two bytes
                 // total.
 
-                if (p-tailLen == len-1) {
+                if (p - tailLen == len - 1) {
                     int t = 0;
                     v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                     tailLen -= t;
@@ -696,10 +671,10 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                         if (do_cr) output[op++] = '\r';
                         output[op++] = '\n';
                     }
-                } else if (p-tailLen == len-2) {
+                } else if (p - tailLen == len - 2) {
                     int t = 0;
                     v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                     tailLen -= t;
                     output[op++] = alphabet[(v >> 12) & 0x3f];
                     output[op++] = alphabet[(v >> 6) & 0x3f];
@@ -716,17 +691,18 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     output[op++] = '\n';
                 }
 
-                assert tailLen == 0;
-                assert p == len;
+                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
+                    throw new AssertionError();
+                }
             } else {
                 // Save the leftovers in tail to be consumed on the next
                 // call to encodeInternal.
 
-                if (p == len-1) {
+                if (p == len - 1) {
                     tail[tailLen++] = input[p];
-                } else if (p == len-2) {
+                } else if (p == len - 2) {
                     tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
+                    tail[tailLen++] = input[p + 1];
                 }
             }
 
@@ -737,5 +713,6 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
         }
     }
 
-    private Base64() { }   // don't instantiate
+    private Base64() {
+    }   // don't instantiate
 }
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
old mode 100644
new mode 100755
index ead54c56..ea2af542
--- a/library/src/main/java/com/loopj/android/http/Base64DataException.java
+++ b/library/src/main/java/com/loopj/android/http/Base64DataException.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.loopj.android.http;
 
 import java.io.IOException;
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
old mode 100644
new mode 100755
index 61afb931..036d4a28
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -1,5 +1,20 @@
-package com.loopj.android.http;
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
+package com.loopj.android.http;
 
 import java.io.FilterOutputStream;
 import java.io.IOException;
@@ -43,6 +58,7 @@ public Base64OutputStream(OutputStream out, int flags, boolean encode) {
         }
     }
 
+    @Override
     public void write(int b) throws IOException {
         // To avoid invoking the encoder/decoder routines for single
         // bytes, we buffer up calls to write(int) in an internal
@@ -71,12 +87,14 @@ private void flushBuffer() throws IOException {
         }
     }
 
+    @Override
     public void write(byte[] b, int off, int len) throws IOException {
         if (len <= 0) return;
         flushBuffer();
         internalWrite(b, off, len, false);
     }
 
+    @Override
     public void close() throws IOException {
         IOException thrown = null;
         try {
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
old mode 100644
new mode 100755
index 03f98345..0fe6ec16
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -29,6 +29,8 @@
  * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
  * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
  * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ *
+ * @param <JSON_TYPE> Generic type meant to be returned in callback
  */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
@@ -73,7 +75,7 @@ public BaseJsonHttpResponseHandler(String encoding) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -94,7 +96,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onSuccess(statusCode, headers, null, null);
         }
@@ -103,7 +109,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
         if (responseString != null) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -124,7 +130,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onFailure(statusCode, headers, throwable, null, null);
         }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
old mode 100644
new mode 100755
index 1959ec6d..f4355caa
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -55,7 +55,9 @@
 
     private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
-            "image/png"
+            "image/png",
+            "image/gif",
+            "application/octet-stream"
     };
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index dc35b42d..72c9404c
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -1,5 +1,3 @@
-package com.loopj.android.http;
-
 /*
     Android Asynchronous Http Client
     Copyright (c) 2011 James Smith <james@loopj.com>
@@ -18,6 +16,8 @@
     limitations under the License.
 */
 
+package com.loopj.android.http;
+
 import android.os.Message;
 import android.util.Log;
 
@@ -41,6 +41,8 @@ public DataAsyncHttpResponseHandler() {
 
     /**
      * Fired when the request progress, override to handle in your own code
+     *
+     * @param responseBody response body received so far
      */
     public void onProgressData(byte[] responseBody) {
     }
@@ -104,7 +106,7 @@ protected void handleMessage(Message message) {
                             sendProgressDataMessage(copyOfRange(tmp, 0, l));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 6223890e..5a005d6a
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -11,10 +29,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-
 public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
-    private File mFile;
+    protected final File mFile;
     private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
 
     /**
@@ -57,8 +74,8 @@ protected File getTemporaryFile(Context context) {
         assert (context != null);
         try {
             return File.createTempFile("temp_", "_handled", context.getCacheDir());
-        } catch (Throwable t) {
-            Log.e(LOG_TAG, "Cannot create temporary file", t);
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Cannot create temporary file", e);
         }
         return null;
     }
@@ -120,9 +137,9 @@ public final void onSuccess(int statusCode, Header[] headers, byte[] responseByt
                         sendProgressMessage(count, (int) contentLength);
                     }
                 } finally {
-                    instream.close();
+                    AsyncHttpClient.silentCloseInputStream(instream);
                     buffer.flush();
-                    buffer.close();
+                    AsyncHttpClient.silentCloseOutputStream(buffer);
                 }
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
old mode 100644
new mode 100755
index 0b26fb1b..ab10821d
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -113,7 +113,7 @@ public void onSuccess(int statusCode, Header[] headers, String responseString) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -125,6 +125,8 @@ public void run() {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
                                 } else {
                                     onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
@@ -140,7 +142,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
@@ -149,7 +155,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
         if (responseBytes != null) {
-            new Thread(new Runnable() {
+            Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -179,7 +185,11 @@ public void run() {
 
                     }
                 }
-            }).start();
+            };
+            if (!getUseSynchronousMode())
+                new Thread(parser).start();
+            else // In synchronous mode everything should be run on one thread
+                parser.run();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
             onFailure(statusCode, headers, throwable, (JSONObject) null);
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
old mode 100644
new mode 100755
index 49375061..f033d4c0
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -24,7 +24,7 @@
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
 
-import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -35,26 +35,26 @@
 import java.util.zip.GZIPOutputStream;
 
 /**
- * HTTP entity to upload JSON data using streams.
- * This has very low memory footprint; suitable for uploading large
- * files using base64 encoding.
+ * HTTP entity to upload JSON data using streams. This has very low memory footprint; suitable for
+ * uploading large files using base64 encoding.
  */
-class JsonStreamerEntity implements HttpEntity {
+public class JsonStreamerEntity implements HttpEntity {
 
     private static final String LOG_TAG = "JsonStreamerEntity";
 
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
-        new UnsupportedOperationException("Unsupported operation in this implementation.");
+            new UnsupportedOperationException("Unsupported operation in this implementation.");
 
-    // Size of the byte-array buffer used to read from streams.
-    private static final int BUFFER_SIZE = 2048;
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
 
     // Reusable StringBuilder used by escape() method.
-    // Base64, at worst, will make a binary stream grow in size by approximately
-    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
-    // large 'n'.
-    private static final StringBuilder BUILDER =
-        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+    // Its size is just initial, if more space is needed, the system will
+    // automatically enlarge the buffer.
+    private static final StringBuilder BUILDER = new StringBuilder(128);
 
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
@@ -65,36 +65,31 @@
     private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
-        new BasicHeader("Content-Type", "application/json");
+            new BasicHeader("Content-Type", "application/json");
     private static final Header HEADER_GZIP_ENCODING =
-        new BasicHeader("Content-Encoding", "gzip");
-    private static final String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
-
-    // K/V objects to be uploaded.
-    private final Map<String, Object> kvParams =
-        new HashMap<String, Object>();
+            new BasicHeader("Content-Encoding", "gzip");
 
-    // Streams and their associated meta-data to be uploaded.
-    private final Map<String, RequestParams.StreamWrapper> streamParams =
-        new HashMap<String, RequestParams.StreamWrapper>();
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap<String, Object>();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
-    public JsonStreamerEntity(boolean contentEncoding) {
-        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
-    }
+    private final ResponseHandlerInterface progressHandler;
 
-    public void addPart(String key, Object value) {
-        kvParams.put(key, value);
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
     }
 
-    public void addPart(String key, InputStream inputStream, String name, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key   entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
     }
 
     @Override
@@ -137,120 +132,174 @@ public InputStream getContent() throws IOException, UnsupportedOperationExceptio
     }
 
     @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        if (outstream == null) {
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
             throw new IllegalStateException("Output stream cannot be null.");
         }
 
         // Record the time when uploading started.
         long now = System.currentTimeMillis();
 
-        // Keys used by the HashMaps.
-        Set<String> keys;
-
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream upload;
-        if (null != contentEncoding) {
-            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
-        } else {
-            upload = new BufferedOutputStream(outstream);
-        }
+        OutputStream os = null != contentEncoding
+                ? new GZIPOutputStream(out, BUFFER_SIZE)
+                : out;
 
         // Always send a JSON object.
-        upload.write('{');
+        os.write('{');
 
-        // Send the K/V values.
-        keys = kvParams.keySet();
-        for (String key : keys) {
-            // Write the JSON object's key.
-            upload.write(escape(key));
-            upload.write(':');
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        boolean isFileWrapper;
 
+        // Go over all keys and handle each's value.
+        for (String key : keys) {
             // Evaluate the value (which cannot be null).
-            Object value = kvParams.get(key);
+            Object value = jsonParams.get(key);
+
+            // Bail out prematurely if value's null.
+            if (value == null) {
+                continue;
+            }
 
-            if (value instanceof Boolean) {
-                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            // Write the JSON object's key.
+            os.write(escape(key));
+            os.write(':');
+
+            // Check if this is a FileWrapper.
+            isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+            // If a file should be uploaded.
+            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                // All uploads are sent as an object containing the file's details.
+                os.write('{');
+
+                // Determine how to handle this entry.
+                if (isFileWrapper) {
+                    writeToFromFile(os, (RequestParams.FileWrapper) value);
+                } else {
+                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                }
+
+                // End the file's object and prepare for next one.
+                os.write('}');
+            } else if (value instanceof Boolean) {
+                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                upload.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number) value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                upload.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number) value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                upload.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number) value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                upload.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number) value).intValue() + "").getBytes());
             } else {
-                upload.write(value.toString().getBytes());
+                os.write(value.toString().getBytes());
             }
 
-            upload.write(',');
-        }
-
-        // Buffer used for reading from input streams.
-        byte[] buffer = new byte[BUFFER_SIZE];
-
-        // Send the stream params.
-        keys = streamParams.keySet();
-        for (String key : keys) {
-            RequestParams.StreamWrapper entry = streamParams.get(key);
-
-            // Write the JSON object's key.
-            upload.write(escape(key));
-
-            // All uploads are sent as an object containing the file's details.
-            upload.write(':');
-            upload.write('{');
-
-            // Send the streams's name.
-            upload.write(STREAM_NAME);
-            upload.write(':');
-            upload.write(escape(entry.name));
-            upload.write(',');
-
-            // Send the streams's content type.
-            upload.write(STREAM_TYPE);
-            upload.write(':');
-            upload.write(escape(entry.contentType));
-            upload.write(',');
-
-            // Prepare the file content's key.
-            upload.write(STREAM_CONTENTS);
-            upload.write(':');
-            upload.write('"');
-
-            // Upload the file's contents in Base64.
-            Base64OutputStream outputStream =
-                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-            // Read from input stream until no more data's left to read.
-            int bytesRead;
-            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
-                outputStream.write(buffer, 0, bytesRead);
-            }
-
-            // Close the Base64 output stream.
-            outputStream.close();
-
-            // End the file's object and prepare for next one.
-            upload.write('"');
-            upload.write('}');
-            upload.write(',');
+            os.write(',');
         }
 
         // Include the elapsed time taken to upload everything.
         // This might be useful for somebody, but it serves us well since
         // there will almost always be a ',' as the last sent character.
-        upload.write(STREAM_ELAPSED);
-        upload.write(':');
+        os.write(STREAM_ELAPSED);
+        os.write(':');
         long elapsedTime = System.currentTimeMillis() - now;
-        upload.write((elapsedTime + "}").getBytes());
+        os.write((elapsedTime + "}").getBytes());
 
         Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
 
         // Flush the contents up the stream.
-        upload.flush();
-        upload.close();
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
+    }
+
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead, bytesWritten = 0, totalSize = (int) wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+                new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
     }
 
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
@@ -258,7 +307,7 @@ public void writeTo(final OutputStream outstream) throws IOException {
     static byte[] escape(String string) {
         // If it's null, just return prematurely.
         if (string == null) {
-          return JSON_NULL;
+            return JSON_NULL;
         }
 
         // Surround with quotations.
@@ -291,7 +340,7 @@ public void writeTo(final OutputStream outstream) throws IOException {
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
-                    if((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
+                    if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
                         BUILDER.append("\\u");
                         int intLength = 4 - intString.length();
@@ -310,11 +359,11 @@ public void writeTo(final OutputStream outstream) throws IOException {
         BUILDER.append('"');
 
         try {
-          return BUILDER.toString().getBytes();
+            return BUILDER.toString().getBytes();
         } finally {
-          // Empty the String buffer.
-          // This is 20-30% faster than instantiating a new object.
-          BUILDER.setLength(0);
+            // Empty the String buffer.
+            // This is 20-30% faster than instantiating a new object.
+            BUILDER.setLength(0);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
new file mode 100644
index 00000000..dfc45ec0
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -0,0 +1,166 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Aymon Fournier <aymon.fournier@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.ProtocolException;
+import org.apache.http.client.CircularRedirectException;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.utils.URIUtils;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.client.RedirectLocations;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Taken from StackOverflow
+ *
+ * @author Aymon Fournier, aymon.fournier@gmail.com
+ * @see <a href="https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception">https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception</a>
+ */
+class MyRedirectHandler extends DefaultRedirectHandler {
+
+    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
+    private final boolean enableRedirects;
+
+    public MyRedirectHandler(final boolean allowRedirects) {
+        super();
+        this.enableRedirects = allowRedirects;
+    }
+
+    @Override
+    public boolean isRedirectRequested(
+            final HttpResponse response,
+            final HttpContext context) {
+        if (!enableRedirects) {
+            return false;
+        }
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        int statusCode = response.getStatusLine().getStatusCode();
+        switch (statusCode) {
+            case HttpStatus.SC_MOVED_TEMPORARILY:
+            case HttpStatus.SC_MOVED_PERMANENTLY:
+            case HttpStatus.SC_SEE_OTHER:
+            case HttpStatus.SC_TEMPORARY_REDIRECT:
+                return true;
+            default:
+                return false;
+        } //end of switch
+    }
+
+    @Override
+    public URI getLocationURI(
+            final HttpResponse response,
+            final HttpContext context) throws ProtocolException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        //get the location header to find out where to redirect to
+        Header locationHeader = response.getFirstHeader("location");
+        if (locationHeader == null) {
+            // got a redirect response, but no location header
+            throw new ProtocolException(
+                    "Received redirect response " + response.getStatusLine()
+                            + " but no location header"
+            );
+        }
+        //HERE IS THE MODIFIED LINE OF CODE
+        String location = locationHeader.getValue().replaceAll(" ", "%20");
+
+        URI uri;
+        try {
+            uri = new URI(location);
+        } catch (URISyntaxException ex) {
+            throw new ProtocolException("Invalid redirect URI: " + location, ex);
+        }
+
+        HttpParams params = response.getParams();
+        // rfc2616 demands the location value be a complete URI
+        // Location       = "Location" ":" absoluteURI
+        if (!uri.isAbsolute()) {
+            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
+                throw new ProtocolException("Relative redirect location '"
+                        + uri + "' not allowed");
+            }
+            // Adjust location URI
+            HttpHost target = (HttpHost) context.getAttribute(
+                    ExecutionContext.HTTP_TARGET_HOST);
+            if (target == null) {
+                throw new IllegalStateException("Target host not available " +
+                        "in the HTTP context");
+            }
+
+            HttpRequest request = (HttpRequest) context.getAttribute(
+                    ExecutionContext.HTTP_REQUEST);
+
+            try {
+                URI requestURI = new URI(request.getRequestLine().getUri());
+                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
+                uri = URIUtils.resolve(absoluteRequestURI, uri);
+            } catch (URISyntaxException ex) {
+                throw new ProtocolException(ex.getMessage(), ex);
+            }
+        }
+
+        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
+
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
+                    REDIRECT_LOCATIONS);
+
+            if (redirectLocations == null) {
+                redirectLocations = new RedirectLocations();
+                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
+            }
+
+            URI redirectURI;
+            if (uri.getFragment() != null) {
+                try {
+                    HttpHost target = new HttpHost(
+                            uri.getHost(),
+                            uri.getPort(),
+                            uri.getScheme());
+                    redirectURI = URIUtils.rewriteURI(uri, target, true);
+                } catch (URISyntaxException ex) {
+                    throw new ProtocolException(ex.getMessage(), ex);
+                }
+            } else {
+                redirectURI = uri;
+            }
+
+            if (redirectLocations.contains(redirectURI)) {
+                throw new CircularRedirectException("Circular redirect to '" +
+                        redirectURI + "'");
+            } else {
+                redirectLocations.add(redirectURI);
+            }
+        }
+
+        return uri;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
old mode 100644
new mode 100755
index 4ea14152..4808bcbf
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,10 +1,40 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
+
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
@@ -14,24 +44,11 @@
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
- 
+
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
- 
-import org.apache.http.HttpVersion;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.HTTP;
 
 /**
  * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
@@ -43,92 +60,94 @@
 
     /**
      * Creates a new SSL Socket Factory with the given KeyStore.
-     * 
+     *
      * @param truststore A KeyStore to create the SSL Socket Factory in context of
-     * @throws NoSuchAlgorithmException
-     * @throws KeyManagementException
-     * @throws KeyStoreException
-     * @throws UnrecoverableKeyException
+     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
+     * @throws KeyManagementException    KeyManagementException
+     * @throws KeyStoreException         KeyStoreException
+     * @throws UnrecoverableKeyException UnrecoverableKeyException
      */
     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);
- 
+
         X509TrustManager tm = new X509TrustManager() {
             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public X509Certificate[] getAcceptedIssuers() {
                 return null;
             }
         };
- 
-        sslContext.init(null, new TrustManager[] { tm }, null);
+
+        sslContext.init(null, new TrustManager[]{tm}, null);
     }
-    
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }
- 
+
     @Override
     public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
-    }	
-    
+    }
+
     /**
      * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
      */
     public void fixHttpsURLConnection() {
-    	HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
     }
-    
+
     /**
      * Gets a KeyStore containing the Certificate
-     * 
+     *
      * @param cert InputStream of the Certificate
      * @return KeyStore
      */
-	public static KeyStore getKeystoreOfCA(InputStream cert) {
-		
-		// Load CAs from an InputStream
-		InputStream caInput = null;
-		Certificate ca = null;
-		try {
-			CertificateFactory cf = CertificateFactory.getInstance("X.509");
-			caInput = new BufferedInputStream(cert);
-			ca = (Certificate) cf.generateCertificate(caInput);
-		} catch (CertificateException e1) {
-			e1.printStackTrace();
-		} finally {
-			try {
-				caInput.close();
-			} catch (IOException e) {
-				e.printStackTrace();
-			}
-		}
- 
-		// Create a KeyStore containing our trusted CAs
-		String keyStoreType = KeyStore.getDefaultType();
-		KeyStore keyStore = null;
-		try {
-			keyStore = KeyStore.getInstance(keyStoreType);
-			keyStore.load(null, null);
-			keyStore.setCertificateEntry("ca",
-					(java.security.cert.Certificate) ca);
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		return keyStore;
-	}
-	
-	/**
-	 * Gets a Default KeyStore
-	 * 
-	 * @return KeyStore
-	 */
-	public static KeyStore getKeystore() {
+    public static KeyStore getKeystoreOfCA(InputStream cert) {
+
+        // Load CAs from an InputStream
+        InputStream caInput = null;
+        Certificate ca = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            caInput = new BufferedInputStream(cert);
+            ca = cf.generateCertificate(caInput);
+        } catch (CertificateException e1) {
+            e1.printStackTrace();
+        } finally {
+            try {
+                if (caInput != null) {
+                    caInput.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Create a KeyStore containing our trusted CAs
+        String keyStoreType = KeyStore.getDefaultType();
+        KeyStore keyStore = null;
+        try {
+            keyStore = KeyStore.getInstance(keyStoreType);
+            keyStore.load(null, null);
+            keyStore.setCertificateEntry("ca", ca);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return keyStore;
+    }
+
+    /**
+     * Gets a Default KeyStore
+     *
+     * @return KeyStore
+     */
+    public static KeyStore getKeystore() {
         KeyStore trustStore = null;
         try {
             trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -138,12 +157,12 @@ public static KeyStore getKeystore() {
         }
         return trustStore;
     }
- 
-	/**
-	 * Returns a SSlSocketFactory which trusts all certificates
-	 * 
-	 * @return
-	 */
+
+    /**
+     * Returns a SSlSocketFactory which trusts all certificates
+     *
+     * @return SSLSocketFactory
+     */
     public static SSLSocketFactory getFixedSocketFactory() {
         SSLSocketFactory socketFactory;
         try {
@@ -155,31 +174,31 @@ public static SSLSocketFactory getFixedSocketFactory() {
         }
         return socketFactory;
     }
-    
+
     /**
      * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
-     * 
-     * @param keyStore
-     * @return
+     *
+     * @param keyStore custom provided KeyStore instance
+     * @return DefaultHttpClient
      */
-	public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
-		
-	    try {
-		    SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
-		    SchemeRegistry registry = new SchemeRegistry();
-		    registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-		    registry.register(new Scheme("https", sf, 443));
- 
-	        HttpParams params = new BasicHttpParams();
-	        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
-	        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
- 
-	        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
- 
-	        return new DefaultHttpClient(ccm, params);
-	    } catch (Exception e) {
-	        return new DefaultHttpClient();
-	    }
-	}
+    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+
+        try {
+            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+            registry.register(new Scheme("https", sf, 443));
+
+            HttpParams params = new BasicHttpParams();
+            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+
+            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+
+            return new DefaultHttpClient(ccm, params);
+        } catch (Exception e) {
+            return new DefaultHttpClient();
+        }
+    }
 
 }
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
old mode 100644
new mode 100755
index ee87bd23..0fefaf72
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -30,6 +30,9 @@
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+
+import java.io.IOException;
+
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
@@ -48,6 +51,7 @@
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
+    private boolean omitNonPersistentCookies = false;
 
     private final ConcurrentHashMap<String, Cookie> cookies;
     private final SharedPreferences cookiePrefs;
@@ -82,6 +86,8 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
+        if (omitNonPersistentCookies && !cookie.isPersistent())
+            return;
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
@@ -146,6 +152,29 @@ public boolean clearExpired(Date date) {
         return new ArrayList<Cookie>(cookies.values());
     }
 
+    /**
+     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
+     * signature (`Cookie.isPersistent`)
+     *
+     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
+     */
+    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
+        this.omitNonPersistentCookies = omitNonPersistentCookies;
+    }
+
+    /**
+     * Non-standard helper method, to delete cookie
+     *
+     * @param cookie cookie to be removed
+     */
+    public void deleteCookie(Cookie cookie) {
+        String name = cookie.getName() + cookie.getDomain();
+        cookies.remove(name);
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        prefsWriter.commit();
+    }
+
     /**
      * Serializes Cookie object into String
      *
@@ -159,7 +188,8 @@ protected String encodeCookie(SerializableCookie cookie) {
         try {
             ObjectOutputStream outputStream = new ObjectOutputStream(os);
             outputStream.writeObject(cookie);
-        } catch (Exception e) {
+        } catch (IOException e) {
+            Log.d(LOG_TAG, "IOException in encodeCookie", e);
             return null;
         }
 
@@ -179,8 +209,10 @@ protected Cookie decodeCookie(String cookieString) {
         try {
             ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
             cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
-        } catch (Exception exception) {
-            Log.d(LOG_TAG, "decodeCookie failed", exception);
+        } catch (IOException e) {
+            Log.d(LOG_TAG, "IOException in decodeCookie", e);
+        } catch (ClassNotFoundException e) {
+            Log.d(LOG_TAG, "ClassNotFoundException in decodeCookie", e);
         }
 
         return cookie;
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
new file mode 100755
index 00000000..3f52da79
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -0,0 +1,54 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+public class PreemtiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
+
+    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                ClientContext.CREDS_PROVIDER);
+        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+        if (authState.getAuthScheme() == null) {
+            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+            Credentials creds = credsProvider.getCredentials(authScope);
+            if (creds != null) {
+                authState.setAuthScheme(new BasicScheme());
+                authState.setCredentials(creds);
+            }
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..f5e21fc8
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -0,0 +1,110 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
+    private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+
+    private long current = 0;
+    private boolean append = false;
+
+    /**
+     * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+     *
+     * @param file File to store response within, must not be null
+     */
+    public RangeFileAsyncHttpResponseHandler(File file) {
+        super(file);
+    }
+
+    @Override
+    public void sendResponseMessage(HttpResponse response) throws IOException {
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
+                //already finished
+                if (!Thread.currentThread().isInterrupted())
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+            } else if (status.getStatusCode() >= 300) {
+                if (!Thread.currentThread().isInterrupted())
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+            } else {
+                if (!Thread.currentThread().isInterrupted()) {
+                    Header header = response.getFirstHeader("Content-Range");
+                    if (header == null) {
+                        append = false;
+                        current = 0;
+                    } else
+                        Log.v(LOG_TAG, "Content-Range: " + header.getValue());
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+                }
+            }
+        }
+    }
+
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            long contentLength = entity.getContentLength() + current;
+            FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+            if (instream != null) {
+                try {
+                    byte[] tmp = new byte[BUFFER_SIZE];
+                    int l;
+                    while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                        current += l;
+                        buffer.write(tmp, 0, l);
+                        sendProgressMessage((int) current, (int) contentLength);
+                    }
+                } finally {
+                    instream.close();
+                    buffer.flush();
+                    buffer.close();
+                }
+            }
+        }
+        return null;
+    }
+
+    public void updateRequestHeaders(HttpUriRequest uriRequest) {
+        if (mFile.exists() && mFile.canWrite())
+            current = mFile.length();
+        if (current > 0) {
+            append = true;
+            uriRequest.setHeader("Range", "bytes=" + current + "-");
+        }
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
old mode 100644
new mode 100755
index 1d56fb42..290422a9
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Jason Choy <jjwchoy@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import java.lang.ref.WeakReference;
@@ -5,11 +23,11 @@
 /**
  * A Handle to an AsyncRequest which can be used to cancel a running request.
  */
-class RequestHandle {
+public class RequestHandle {
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference(request);
+        this.request = new WeakReference<AsyncHttpRequest>(request);
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
old mode 100644
new mode 100755
index 42ba1706..b115bdc3
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -27,7 +27,6 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -90,13 +89,17 @@
  */
 public class RequestParams {
 
+    public final static String APPLICATION_OCTET_STREAM =
+            "application/octet-stream";
+
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -126,7 +129,6 @@ public RequestParams() {
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
-        init();
         if (source != null) {
             for (Map.Entry<String, String> entry : source.entrySet()) {
                 put(entry.getKey(), entry.getValue());
@@ -156,7 +158,6 @@ public RequestParams(final String key, final String value) {
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-        init();
         int len = keysAndValues.length;
         if (len % 2 != 0)
             throw new IllegalArgumentException("Supplied arguments must be even");
@@ -237,8 +238,21 @@ public void put(String key, InputStream stream, String name) {
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
         if (key != null && stream != null) {
-            streamParams.put(key, new StreamWrapper(stream, name, contentType));
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
         }
     }
 
@@ -254,6 +268,30 @@ public void put(String key, Object value) {
         }
     }
 
+    /**
+     * Adds a int value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value int for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds a long value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value long for the new param.
+     */
+    public void put(String key, long value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds string value to param which can have more than one value.
      *
@@ -288,6 +326,19 @@ public void remove(String key) {
         urlParamsWithObjects.remove(key);
     }
 
+    /**
+     * Check if a parameter is defined.
+     *
+     * @param key the key name for the parameter to check existence.
+     * @return Boolean
+     */
+    public boolean has(String key) {
+        return urlParams.get(key) != null ||
+                streamParams.get(key) != null ||
+                fileParams.get(key) != null ||
+                urlParamsWithObjects.get(key) != null;
+    }
+
     @Override
     public String toString() {
         StringBuilder result = new StringBuilder();
@@ -340,7 +391,17 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Returns an HttpEntity containing all request parameters
+     * Set global flag which determines whether to automatically close input streams on successful
+     * upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
      * @return HttpEntity resulting HttpEntity to be included along with {@link
@@ -349,7 +410,7 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
         if (useJsonStreamer) {
-            return createJsonStreamerEntity();
+            return createJsonStreamerEntity(progressHandler);
         } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
@@ -357,8 +418,9 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
         }
     }
 
-    private HttpEntity createJsonStreamerEntity() throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
+                !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -372,11 +434,7 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
 
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(),
-                    new FileInputStream(fileWrapper.file),
-                    fileWrapper.file.getName(),
-                    fileWrapper.contentType);
+            entity.addPart(entry.getKey(), entry.getValue());
         }
 
         // Add stream params
@@ -384,9 +442,12 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
-                        stream.inputStream,
-                        stream.name,
-                        stream.contentType);
+                        StreamWrapper.newInstance(
+                                stream.inputStream,
+                                stream.name,
+                                stream.contentType,
+                                stream.autoClose)
+                );
             }
         }
 
@@ -408,13 +469,13 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            entity.addPart(entry.getKey(), entry.getValue());
+            entity.addPartWithCharset(entry.getKey(), entry.getValue(), contentEncoding);
         }
 
         // Add non-string params
         List<BasicNameValuePair> params = getParamsList(null, urlParamsWithObjects);
         for (BasicNameValuePair kv : params) {
-            entity.addPart(kv.getName(), kv.getValue());
+            entity.addPartWithCharset(kv.getName(), kv.getValue(), contentEncoding);
         }
 
         // Add stream params
@@ -435,13 +496,6 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
         return entity;
     }
 
-    private void init() {
-        urlParams = new ConcurrentHashMap<String, String>();
-        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
-    }
-
     protected List<BasicNameValuePair> getParamsList() {
         List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
@@ -457,34 +511,40 @@ private void init() {
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
         List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
         if (value instanceof Map) {
-            Map<String, Object> map = (Map<String, Object>) value;
-            List<String> list = new ArrayList<String>(map.keySet());
+            Map map = (Map) value;
+            List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
-            Collections.sort(list);
-            for (String nestedKey : list) {
-                Object nestedValue = map.get(nestedKey);
-                if (nestedValue != null) {
-                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
-                            nestedValue));
+            if (list.size() > 0 && list.get(0) instanceof Comparable) {
+                Collections.sort(list);
+            }
+            for (Object nestedKey : list) {
+                if (nestedKey instanceof String) {
+                    Object nestedValue = map.get(nestedKey);
+                    if (nestedValue != null) {
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
+                                nestedValue));
+                    }
                 }
             }
         } else if (value instanceof List) {
-            List<Object> list = (List<Object>) value;
-            for (Object nestedValue : list) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            List list = (List) value;
+            int listSize = list.size();
+            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
             }
         } else if (value instanceof Object[]) {
             Object[] array = (Object[]) value;
-            for (Object nestedValue : array) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            int arrayLength = array.length;
+            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
             }
         } else if (value instanceof Set) {
-            Set<Object> set = (Set<Object>) value;
+            Set set = (Set) value;
             for (Object nestedValue : set) {
                 params.addAll(getParamsList(key, nestedValue));
             }
-        } else if (value instanceof String) {
-            params.add(new BasicNameValuePair(key, (String) value));
+        } else {
+            params.add(new BasicNameValuePair(key, value.toString()));
         }
         return params;
     }
@@ -494,8 +554,8 @@ protected String getParamString() {
     }
 
     public static class FileWrapper {
-        public File file;
-        public String contentType;
+        public final File file;
+        public final String contentType;
 
         public FileWrapper(File file, String contentType) {
             this.file = file;
@@ -504,14 +564,24 @@ public FileWrapper(File file, String contentType) {
     }
 
     public static class StreamWrapper {
-        public InputStream inputStream;
-        public String name;
-        public String contentType;
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
 
-        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
             this.inputStream = inputStream;
             this.name = name;
             this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                    inputStream,
+                    name,
+                    contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                    autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
old mode 100644
new mode 100755
index 4641a868..23a185d0
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2013 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import org.apache.http.Header;
@@ -104,7 +122,7 @@
     void setUseSynchronousMode(boolean useSynchronousMode);
 
     /**
-     * Can set, whether the handler should be asynchronous or synchronous
+     * Returns whether the handler is asynchronous or synchronous
      *
      * @return boolean if the ResponseHandler is running in synchronous mode
      */
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
old mode 100644
new mode 100755
index d8dffa1d..3b6ad196
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..f4663b7b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/SaxAsyncHttpResponseHandler.java
@@ -0,0 +1,149 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+/**
+ * Provides interface to deserialize SAX responses, using AsyncHttpResponseHandler. Can be used like
+ * this
+ *
+ * <pre>
+ *     AsyncHttpClient ahc = new AsyncHttpClient();
+ *     FontHandler handlerInstance = ... ; // init handler instance
+ *     ahc.post("https://server.tld/api/call", new SaxAsyncHttpResponseHandler<FontHandler>(handlerInstance){
+ *         &#064;Override
+ *         public void onSuccess(int statusCode, Header[] headers, FontHandler t) {
+ *              // Request got HTTP success statusCode
+ *         }
+ *         &#064;Override
+ *         public void onFailure(int statusCode, Header[] headers, FontHandler t){
+ *              // Request got HTTP fail statusCode
+ *         }
+ *     });
+ * <pre/>
+ *
+ * @param <T> Handler extending {@link org.xml.sax.helpers.DefaultHandler}
+ * @see org.xml.sax.helpers.DefaultHandler
+ * @see com.loopj.android.http.AsyncHttpResponseHandler
+ */
+public abstract class SaxAsyncHttpResponseHandler<T extends DefaultHandler> extends AsyncHttpResponseHandler {
+
+    /**
+     * Generic Type of handler
+     */
+    private T handler = null;
+    private final static String LOG_TAG = "SaxAsyncHttpResponseHandler";
+
+    /**
+     * Constructs new SaxAsyncHttpResponseHandler with given handler instance
+     *
+     * @param t instance of Handler extending DefaultHandler
+     * @see org.xml.sax.helpers.DefaultHandler
+     */
+    public SaxAsyncHttpResponseHandler(T t) {
+        super();
+        if (t == null) {
+            throw new Error("null instance of <T extends DefaultHandler> passed to constructor");
+        }
+        this.handler = t;
+    }
+
+    /**
+     * Deconstructs response into given content handler
+     *
+     * @param entity returned HttpEntity
+     * @return deconstructed response
+     * @throws java.io.IOException
+     * @see org.apache.http.HttpEntity
+     */
+    @Override
+    protected byte[] getResponseData(HttpEntity entity) throws IOException {
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            InputStreamReader inputStreamReader = null;
+            if (instream != null) {
+                try {
+                    SAXParserFactory sfactory = SAXParserFactory.newInstance();
+                    SAXParser sparser = sfactory.newSAXParser();
+                    XMLReader rssReader = sparser.getXMLReader();
+                    rssReader.setContentHandler(handler);
+                    inputStreamReader = new InputStreamReader(instream, DEFAULT_CHARSET);
+                    rssReader.parse(new InputSource(inputStreamReader));
+                } catch (SAXException e) {
+                    Log.e(LOG_TAG, "getResponseData exception", e);
+                } catch (ParserConfigurationException e) {
+                    Log.e(LOG_TAG, "getResponseData exception", e);
+                } finally {
+                    AsyncHttpClient.silentCloseInputStream(instream);
+                    if (inputStreamReader != null) {
+                        try {
+                            inputStreamReader.close();
+                        } catch (IOException e) { /*ignore*/ }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Default onSuccess method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onSuccess(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, headers, handler);
+    }
+
+    /**
+     * Default onFailure method for this AsyncHttpResponseHandler to override
+     *
+     * @param statusCode returned HTTP status code
+     * @param headers    returned HTTP headers
+     * @param t          instance of Handler extending DefaultHandler
+     */
+    public abstract void onFailure(int statusCode, Header[] headers, T t);
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers,
+                          byte[] responseBody, Throwable error) {
+        onSuccess(statusCode, headers, handler);
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
old mode 100644
new mode 100755
index 7d134599..baca2281
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -28,6 +28,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -46,25 +47,26 @@
 
     private static final String LOG_TAG = "SimpleMultipartEntity";
 
-    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
-    private static final byte[] CR_LF = ("\r\n").getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
-            .getBytes();
+    private static final String STR_CR_LF = "\r\n";
+    private static final byte[] CR_LF = STR_CR_LF.getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY =
+            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+    private final static char[] MULTIPART_CHARS =
+            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary;
-    private byte[] boundaryLine;
-    private byte[] boundaryEnd;
-    private boolean isRepeatable = false;
+    private final String boundary;
+    private final byte[] boundaryLine;
+    private final byte[] boundaryEnd;
+    private boolean isRepeatable;
 
-    private List<FilePart> fileParts = new ArrayList<FilePart>();
+    private final List<FilePart> fileParts = new ArrayList<FilePart>();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
-    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    private ResponseHandlerInterface progressHandler;
+    private final ResponseHandlerInterface progressHandler;
 
     private int bytesWritten;
 
@@ -78,13 +80,13 @@ public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         }
 
         boundary = buf.toString();
-        boundaryLine = ("--" + boundary + "\r\n").getBytes();
-        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
+        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
 
         this.progressHandler = progressHandler;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
+    public void addPart(String key, String value, String contentType) {
         try {
             out.write(boundaryLine);
             out.write(createContentDisposition(key));
@@ -98,26 +100,26 @@ public void addPart(final String key, final String value, final String contentTy
         }
     }
 
-    public void addPart(final String key, final String value) {
-        addPart(key, value, "text/plain; charset=UTF-8");
+    public void addPartWithCharset(String key, String value, String charset) {
+        if (charset == null) charset = HTTP.UTF_8;
+        addPart(key, value, "text/plain; charset=" + charset);
+    }
+
+    public void addPart(String key, String value) {
+        addPartWithCharset(key, value, null);
     }
 
     public void addPart(String key, File file) {
         addPart(key, file, null);
     }
 
-    public void addPart(final String key, File file, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        fileParts.add(new FilePart(key, file, type));
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
     }
 
     public void addPart(String key, String streamName, InputStream inputStream, String type)
             throws IOException {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
+
         out.write(boundaryLine);
 
         // Headers
@@ -135,26 +137,26 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
 
         out.write(CR_LF);
         out.flush();
-        try {
-            inputStream.close();
-        } catch (final IOException e) {
-            // Not important, just log it
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
+
+        AsyncHttpClient.silentCloseOutputStream(out);
+    }
+
+    private String normalizeContentType(String type) {
+        return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + type + "\r\n";
+        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
-    private byte[] createContentDisposition(final String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
+    private byte[] createContentDisposition(String key) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
                 .getBytes();
     }
 
-    private byte[] createContentDisposition(final String key, final String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
+    private byte[] createContentDisposition(String key, String fileName) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
                 .getBytes();
     }
 
@@ -200,20 +202,15 @@ public void writeTo(OutputStream out) throws IOException {
 
             FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
-            int l;
-            while ((l = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-                updateProgress(l);
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
             }
             out.write(CR_LF);
             updateProgress(CR_LF.length);
             out.flush();
-            try {
-                inputStream.close();
-            } catch (final IOException e) {
-                // Not important, just log it
-                Log.w(LOG_TAG, "Cannot close input stream", e);
-            }
+            AsyncHttpClient.silentCloseInputStream(inputStream);
         }
     }
 
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
old mode 100644
new mode 100755
index ac5ca66d..89591461
--- a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
@@ -1,3 +1,20 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
 package com.loopj.android.http;
 
 import android.content.Context;
@@ -75,7 +92,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client,
 		/*
          * will execute the request directly
 		*/
-        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
+        newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context).run();
 
         // Return a Request Handle that cannot be used to cancel the request
         // because it is already complete by the time this returns
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
old mode 100644
new mode 100755
index b96a263a..1c354a6c
--- a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http;
 
 import android.util.Log;
diff --git a/library/src/main/java/com/loopj/android/http/package-info.java b/library/src/main/java/com/loopj/android/http/package-info.java
new file mode 100644
index 00000000..40174b19
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
\ No newline at end of file
diff --git a/maven_push.gradle b/maven_push.gradle
old mode 100644
new mode 100755
index 7131da65..27fff0d8
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -1,33 +1,42 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 apply plugin: 'maven'
 apply plugin: 'signing'
 
-configurations {
-    archives {
-        extendsFrom configurations.default
-    }
+def isReleaseBuild() {
+    return VERSION_NAME.contains("SNAPSHOT") == false
+}
+
+def getReleaseRepositoryUrl() {
+    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
 }
 
-def sonatypeRepositoryUrl
-if (isReleaseBuild()) {
-    println 'RELEASE BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-} else {
-    println 'DEBUG BUILD'
-    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+def getSnapshotRepositoryUrl() {
+    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : "https://oss.sonatype.org/content/repositories/snapshots/"
 }
-if(isReleaseBuild()){
-if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
-    if (System.console())
-        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
-    else
-        ext.set('signing.password', 'dummy')
+
+def getRepositoryUsername() {
+    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
 }
 
-if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
-    if (System.console())
-        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
-    else
-    	ext.set('nexusPassword', 'dummy')
+def getRepositoryPassword() {
+    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -36,10 +45,15 @@ afterEvaluate { project ->
             mavenDeployer {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
+                pom.groupId = GROUP
                 pom.artifactId = POM_ARTIFACT_ID
+                pom.version = VERSION_NAME
 
-                repository(url: sonatypeRepositoryUrl) {
-                    authentication(userName: nexusUsername, password: nexusPassword)
+                repository(url: getReleaseRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+                snapshotRepository(url: getSnapshotRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
                 pom.project {
@@ -64,12 +78,8 @@ afterEvaluate { project ->
 
                     developers {
                         developer {
-                            id "loopj"
-                            name "James Smith"
-                        }
-                        developer {
-                            id "smarek"
-                            name "Marek Sebera"
+                            id POM_DEVELOPER_ID
+                            name POM_DEVELOPER_NAME
                         }
                     }
                 }
@@ -82,20 +92,23 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidJavadocsJar(type: Jar, dependsOn: generateReleaseJavadoc) {
+    task androidJavadocs(type: Javadoc) {
+        source = android.sourceSets.main.java.srcDirs
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
-        from generateReleaseJavadoc.destinationDir
+        from androidJavadocs.destinationDir
     }
 
     task androidSourcesJar(type: Jar) {
         classifier = 'sources'
-        from android.sourceSets.main.allSource
+        from android.sourceSets.main.java.srcDirs
     }
 
     artifacts {
-        archives androidReleaseJar
         archives androidSourcesJar
         archives androidJavadocsJar
     }
 }
-}
diff --git a/releases/android-async-http-1.2.0.jar b/releases/android-async-http-1.2.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.2.1.jar b/releases/android-async-http-1.2.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.0.jar b/releases/android-async-http-1.3.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.1.jar b/releases/android-async-http-1.3.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.2.jar b/releases/android-async-http-1.3.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.0.jar b/releases/android-async-http-1.4.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.1.jar b/releases/android-async-http-1.4.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.2.jar b/releases/android-async-http-1.4.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.3.jar b/releases/android-async-http-1.4.3.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.4.jar b/releases/android-async-http-1.4.4.jar
old mode 100644
new mode 100755
diff --git a/sample/.gitignore b/sample/.gitignore
old mode 100644
new mode 100755
diff --git a/sample/build.gradle b/sample/build.gradle
old mode 100644
new mode 100755
index af693013..f6541400
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.7.+'
+        classpath 'com.android.tools.build:gradle:0.+'
     }
 }
 apply plugin: 'android'
@@ -17,15 +17,23 @@ repositories {
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.1'
+    buildToolsVersion '19.1'
 
     defaultConfig {
         minSdkVersion 3
         targetSdkVersion 19
     }
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
     lintOptions {
-        abortOnError false
+        xmlReport false
+        warningsAsErrors true
+        quiet false
+        showAll true
     }
 
     packagingOptions {
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
index a7d337e9..8361ade8
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http.sample"
-    android:versionCode="1"
-    android:versionName="1.0">
+          package="com.loopj.android.http.sample"
+          android:versionCode="1"
+          android:versionName="1.0">
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
@@ -12,18 +12,28 @@
         android:theme="@style/AppTheme">
         <activity android:name=".WaypointsActivity">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name=".GetSample" />
-        <activity android:name=".PostSample" />
-        <activity android:name=".DeleteSample" />
-        <activity android:name=".PutSample" />
-        <activity android:name=".JsonSample" />
-        <activity android:name=".FileSample" />
-        <activity android:name=".BinarySample" />
-        <activity android:name=".ThreadingTimeoutSample" />
+        <activity android:name=".GetSample"/>
+        <activity android:name=".PostSample"/>
+        <activity android:name=".DeleteSample"/>
+        <activity android:name=".PutSample"/>
+        <activity android:name=".JsonSample"/>
+        <activity android:name=".FileSample"/>
+        <activity android:name=".BinarySample"/>
+        <activity android:name=".GzipSample"/>
+        <activity android:name=".Redirect302Sample"/>
+        <activity android:name=".ThreadingTimeoutSample"/>
+        <activity android:name=".CancelAllRequestsSample"/>
+        <activity android:name=".CancelRequestHandleSample"/>
+        <activity android:name=".SynchronousClientSample"/>
+        <activity android:name=".IntentServiceSample"/>
+        <activity android:name=".SaxSample"/>
+        <activity android:name=".FilesSample"/>
+
+        <service android:name=".services.ExampleIntentService"/>
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
old mode 100644
new mode 100755
index e134a1b6..94417798
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -1,8 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,27 +30,27 @@
     private static final String LOG_TAG = "BinarySample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_binary_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/gzip";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BinaryHttpResponseHandler() {
             @Override
             public void onStart() {
@@ -63,7 +82,7 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
new file mode 100644
index 00000000..84d23b5f
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -0,0 +1,32 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+public class CancelAllRequestsSample extends ThreadingTimeoutSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_all;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        getAsyncHttpClient().cancelAllRequests(true);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
new file mode 100644
index 00000000..7db7ba72
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -0,0 +1,48 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.RequestHandle;
+
+public class CancelRequestHandleSample extends ThreadingTimeoutSample {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_handle;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        Log.d(LOG_TAG, String.format("Number of handles found: %d", getRequestHandles().size()));
+        int counter = 0;
+        for (RequestHandle handle : getRequestHandles()) {
+            if (!handle.isCancelled() && !handle.isFinished()) {
+                Log.d(LOG_TAG, String.format("Cancelling handle %d", counter));
+                Log.d(LOG_TAG, String.format("Handle %d cancel", counter) + (handle.cancel(true) ? " succeeded" : " failed"));
+            } else {
+                Log.d(LOG_TAG, String.format("Handle %d already non-cancellable", counter));
+            }
+            counter++;
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
old mode 100644
new mode 100755
index 42104356..0eea3740
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,33 +30,33 @@
     private static final String LOG_TAG = "DeleteSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.delete(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.delete(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_delete_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/delete";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
old mode 100644
new mode 100755
index 68c3620b..4d774e60
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -1,10 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.Log;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.FileUtil;
 
 import org.apache.http.Header;
@@ -16,27 +35,27 @@
     private static final String LOG_TAG = "FileSample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_file_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/robots.txt";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new FileAsyncHttpResponseHandler(this) {
             @Override
             public void onStart() {
@@ -76,7 +95,7 @@ private void debugFile(File file) {
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
new file mode 100644
index 00000000..491c2b36
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/FilesSample.java
@@ -0,0 +1,65 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.RequestParams;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.util.Random;
+
+public class FilesSample extends PostSample {
+
+    public static final String LOG_TAG = "PostFilesSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_post_files;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        try {
+            RequestParams params = new RequestParams();
+            final String contentType = "application/octet-stream";
+            params.put("fileOne", createTempFile("fileOne", 1020), contentType);
+            params.put("fileTwo", createTempFile("fileTwo", 1030), contentType);
+            params.put("fileThree", createTempFile("fileThree", 1040), contentType);
+            params.put("fileFour", createTempFile("fileFour", 1050), contentType);
+            params.put("fileFive", createTempFile("fileFive", 1060), contentType);
+            return client.post(this, URL, params, responseHandler);
+        } catch (FileNotFoundException fnfException) {
+            Log.e(LOG_TAG, "executeSample failed with FileNotFoundException", fnfException);
+        }
+        return null;
+    }
+
+    public File createTempFile(String namePart, int byteSize) {
+        try {
+            File f = File.createTempFile(namePart, "_handled", getCacheDir());
+            FileOutputStream fos = new FileOutputStream(f);
+            Random r = new Random();
+            byte[] buffer = new byte[byteSize];
+            r.nextBytes(buffer);
+            fos.write(buffer);
+            fos.flush();
+            fos.close();
+            return f;
+        } catch (Throwable t) {
+            Log.e(LOG_TAG, "createTempFile failed", t);
+        }
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
old mode 100644
new mode 100755
index 96ab3e64..ac11151a
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,7 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
+import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +32,32 @@
     private static final String LOG_TAG = "GetSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_get_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/get";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -59,6 +81,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
                     debugResponse(LOG_TAG, new String(errorResponse));
                 }
             }
+
+            @Override
+            public void onRetry(int retryNo) {
+                Toast.makeText(GetSample.this,
+                        String.format("Request is retried, retry no. %d", retryNo),
+                        Toast.LENGTH_SHORT)
+                        .show();
+            }
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
new file mode 100644
index 00000000..2664b6f0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -0,0 +1,32 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+public class GzipSample extends JsonSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_gzip_sample;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
new file mode 100644
index 00000000..7b7dde62
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/IntentServiceSample.java
@@ -0,0 +1,106 @@
+package com.loopj.android.http.sample;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.services.ExampleIntentService;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class IntentServiceSample extends SampleParentActivity {
+
+    public static final String LOG_TAG = "IntentServiceSample";
+    public static final String ACTION_START = "SYNC_START";
+    public static final String ACTION_RETRY = "SYNC_RETRY";
+    public static final String ACTION_CANCEL = "SYNC_CANCEL";
+    public static final String ACTION_SUCCESS = "SYNC_SUCCESS";
+    public static final String ACTION_FAILURE = "SYNC_FAILURE";
+    public static final String ACTION_FINISH = "SYNC_FINISH";
+    public static final String[] ALLOWED_ACTIONS = {ACTION_START,
+            ACTION_RETRY, ACTION_CANCEL, ACTION_SUCCESS, ACTION_FAILURE, ACTION_FINISH};
+    private final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            // switch() doesn't support strings in older JDK.
+            if(ACTION_START.equals(action)) {
+                clearOutputs();
+                addView(getColoredView(LIGHTBLUE, "Request started"));
+            } else if(ACTION_FINISH.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request finished"));
+            } else if(ACTION_CANCEL.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request cancelled"));
+            } else if(ACTION_RETRY.equals(action)) {
+                addView(getColoredView(LIGHTBLUE, "Request retried"));
+            } else if(ACTION_FAILURE.equals(action) || ACTION_SUCCESS.equals(action)) {
+                debugThrowable(LOG_TAG, (Throwable) intent.getSerializableExtra(ExampleIntentService.INTENT_THROWABLE));
+                if(ACTION_SUCCESS.equals(action)) {
+                    debugStatusCode(LOG_TAG, intent.getIntExtra(ExampleIntentService.INTENT_STATUS_CODE, 0));
+                    debugHeaders(LOG_TAG, IntentUtil.deserializeHeaders(intent.getStringArrayExtra(ExampleIntentService.INTENT_HEADERS)));
+                    byte[] returnedBytes = intent.getByteArrayExtra(ExampleIntentService.INTENT_DATA);
+                    if (returnedBytes != null) {
+                        debugResponse(LOG_TAG, new String(returnedBytes));
+                    }
+                }
+            }
+        }
+    };
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        IntentFilter iFilter = new IntentFilter();
+        for (String action : ALLOWED_ACTIONS) {
+            iFilter.addAction(action);
+        }
+        registerReceiver(broadcastReceiver, iFilter);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        unregisterReceiver(broadcastReceiver);
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        // no response handler on activity
+        return null;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/get";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_intent_service_sample;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        Intent serviceCall = new Intent(this, ExampleIntentService.class);
+        serviceCall.putExtra(ExampleIntentService.INTENT_URL, URL);
+        startService(serviceCall);
+        return null;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
old mode 100644
new mode 100755
index ae701c91..4fcc07e0
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -1,10 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.SampleJSON;
 
 import org.apache.http.Header;
@@ -15,32 +34,32 @@
     private static final String LOG_TAG = "JsonSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_json_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return false;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/headers";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BaseJsonHttpResponseHandler<SampleJSON>() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
new file mode 100644
index 00000000..46133fd2
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/PersistentCookiesSample.java
@@ -0,0 +1,121 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.PersistentCookieStore;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.sample.util.SampleJSON;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.CookieStore;
+
+public class PersistentCookiesSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "PersistentCookiesSample";
+
+    private CookieStore cookieStore;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        // Use the application's context so that memory leakage doesn't occur.
+        cookieStore = new PersistentCookieStore(getApplicationContext());
+
+        // Set the new cookie store.
+        getAsyncHttpClient().setCookieStore(cookieStore);
+
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_persistent_cookies;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        // The base URL for testing cookies.
+        String url = "http://httpbin.org/cookies";
+
+        // If the cookie store is empty, suggest a cookie.
+        if(cookieStore.getCookies().isEmpty()) {
+            url += "/set?time=" + System.currentTimeMillis();
+        }
+
+        return url;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new BaseJsonHttpResponseHandler<SampleJSON>() {
+            @Override
+            public void onStart() {
+                clearOutputs();
+            }
+
+            @Override
+            public void onSuccess(int statusCode, Header[] headers, String rawJsonResponse, SampleJSON response) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                if (response != null) {
+                    debugResponse(LOG_TAG, rawJsonResponse);
+                }
+            }
+
+            @Override
+            public void onFailure(int statusCode, Header[] headers, Throwable throwable, String rawJsonData, SampleJSON errorResponse) {
+                debugHeaders(LOG_TAG, headers);
+                debugStatusCode(LOG_TAG, statusCode);
+                debugThrowable(LOG_TAG, throwable);
+                if (errorResponse != null) {
+                    debugResponse(LOG_TAG, rawJsonData);
+                }
+            }
+
+            @Override
+            protected SampleJSON parseResponse(String rawJsonData, boolean isFailure) throws Throwable {
+                return new ObjectMapper().readValues(new JsonFactory().createParser(rawJsonData), SampleJSON.class).next();
+            }
+        };
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
old mode 100644
new mode 100755
index 202fd480..311b4216
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +30,32 @@
     private static final String LOG_TAG = "PostSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.post(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_post_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/post";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -51,7 +71,7 @@ public void onSuccess(int statusCode, Header[] headers, byte[] response) {
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 debugThrowable(LOG_TAG, e);
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
old mode 100644
new mode 100755
index f9e6b5dc..56260150
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -1,7 +1,27 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +30,32 @@
     private static final String LOG_TAG = "PutSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.put(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.put(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_put_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/put";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
new file mode 100644
index 00000000..766bc0f8
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -0,0 +1,97 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class Redirect302Sample extends GetSample {
+
+    private boolean enableRedirects = true;
+    private boolean enableRelativeRedirects = true;
+    private boolean enableCircularRedirects = true;
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, 0, Menu.NONE, "Enable redirects").setCheckable(true);
+        menu.add(Menu.NONE, 1, Menu.NONE, "Enable relative redirects").setCheckable(true);
+        menu.add(Menu.NONE, 2, Menu.NONE, "Enable circular redirects").setCheckable(true);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem menuItemEnableRedirects = menu.findItem(0);
+        if (menuItemEnableRedirects != null)
+            menuItemEnableRedirects.setChecked(enableRedirects);
+        MenuItem menuItemEnableRelativeRedirects = menu.findItem(1);
+        if (menuItemEnableRelativeRedirects != null)
+            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
+        MenuItem menuItemEnableCircularRedirects = menu.findItem(2);
+        if (menuItemEnableCircularRedirects != null)
+            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
+        return super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.isCheckable()) {
+            item.setChecked(!item.isChecked());
+            if (item.getItemId() == 0) {
+                enableRedirects = item.isChecked();
+            } else if (item.getItemId() == 1) {
+                enableRelativeRedirects = item.isChecked();
+            } else if (item.getItemId() == 2) {
+                enableCircularRedirects = item.isChecked();
+            }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/redirect/6";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_redirect_302;
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient() {
+        AsyncHttpClient ahc = super.getAsyncHttpClient();
+        HttpClient client = ahc.getHttpClient();
+        if (client instanceof DefaultHttpClient) {
+            Toast.makeText(this,
+                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
+                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
+                    Toast.LENGTH_SHORT
+            ).show();
+            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
+        }
+        return ahc;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
new file mode 100644
index 00000000..6c7fe6b5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -0,0 +1,61 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.List;
+
+public interface SampleInterface {
+
+    List<RequestHandle> getRequestHandles();
+
+    void addRequestHandle(RequestHandle handle);
+
+    void onRunButtonPressed();
+
+    void onCancelButtonPressed();
+
+    Header[] getRequestHeaders();
+
+    HttpEntity getRequestEntity();
+
+    AsyncHttpClient getAsyncHttpClient();
+
+    void setAsyncHttpClient(AsyncHttpClient client);
+
+    ResponseHandlerInterface getResponseHandler();
+
+    String getDefaultURL();
+
+    boolean isRequestHeadersAllowed();
+
+    boolean isRequestBodyAllowed();
+
+    int getSampleTitle();
+
+    boolean isCancelButtonAllowed();
+
+    RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler);
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
old mode 100644
new mode 100755
index 182425d2..80296dfc
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.Activity;
@@ -12,7 +30,7 @@
 import android.widget.TextView;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -23,19 +41,21 @@
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 
-public abstract class SampleParentActivity extends Activity {
+public abstract class SampleParentActivity extends Activity implements SampleInterface {
 
     private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
     private EditText urlEditText, headersEditText, bodyEditText;
     private LinearLayout responseLayout;
+    private final List<RequestHandle> requestHandles = new LinkedList<RequestHandle>();
 
-    private static final int LIGHTGREEN = Color.parseColor("#00FF66");
-    private static final int LIGHTRED = Color.parseColor("#FF3300");
-    private static final int YELLOW = Color.parseColor("#FFFF00");
-    private static final int LIGHTBLUE = Color.parseColor("#99CCFF");
+    protected static final int LIGHTGREEN = Color.parseColor("#00FF66");
+    protected static final int LIGHTRED = Color.parseColor("#FF3300");
+    protected static final int YELLOW = Color.parseColor("#FFFF00");
+    protected static final int LIGHTBLUE = Color.parseColor("#99CCFF");
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -58,31 +78,54 @@ protected void onCreate(Bundle savedInstanceState) {
         headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
 
         runButton.setOnClickListener(onClickListener);
-        if (isCancelButtonAllowed() && cancelButton != null) {
-            cancelButton.setVisibility(View.VISIBLE);
-            cancelButton.setOnClickListener(onClickListener);
+        if (cancelButton != null) {
+            if (isCancelButtonAllowed()) {
+                cancelButton.setVisibility(View.VISIBLE);
+                cancelButton.setOnClickListener(onClickListener);
+            } else {
+                cancelButton.setEnabled(false);
+            }
         }
     }
 
-    private View.OnClickListener onClickListener = new View.OnClickListener() {
+    public List<RequestHandle> getRequestHandles() {
+        return requestHandles;
+    }
+
+    @Override
+    public void addRequestHandle(RequestHandle handle) {
+        if (null != handle) {
+            requestHandles.add(handle);
+        }
+    }
+
+    public void onRunButtonPressed() {
+        addRequestHandle(executeSample(getAsyncHttpClient(),
+                (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
+                getRequestHeaders(),
+                getRequestEntity(),
+                getResponseHandler()));
+    }
+
+    public void onCancelButtonPressed() {
+        asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+    }
+
+    protected View.OnClickListener onClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
             switch (v.getId()) {
                 case R.id.button_run:
-                    executeSample(getAsyncHttpClient(),
-                            (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
-                            getRequestHeaders(),
-                            getRequestEntity(),
-                            getResponseHandler());
+                    onRunButtonPressed();
                     break;
                 case R.id.button_cancel:
-                    asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+                    onCancelButtonPressed();
                     break;
             }
         }
     };
 
-    protected Header[] getRequestHeaders() {
+    public List<Header> getRequestHeadersList() {
         List<Header> headers = new ArrayList<Header>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
@@ -90,19 +133,29 @@ public void onClick(View v) {
             String[] lines = headersRaw.split("\\r?\\n");
             for (String line : lines) {
                 try {
-                    String[] kv = line.split("=");
-                    if (kv.length != 2)
+                    int equalSignPos = line.indexOf('=');
+                    if (1 > equalSignPos) {
                         throw new IllegalArgumentException("Wrong header format, may be 'Key=Value' only");
-                    headers.add(new BasicHeader(kv[0].trim(), kv[1].trim()));
+                    }
+
+                    String headerName = line.substring(0, equalSignPos).trim();
+                    String headerValue = line.substring(1 + equalSignPos).trim();
+
+                    headers.add(new BasicHeader(headerName, headerValue));
                 } catch (Throwable t) {
                     Log.e("SampleParentActivity", "Not a valid header line: " + line, t);
                 }
             }
         }
+        return headers;
+    }
+
+    public Header[] getRequestHeaders() {
+        List<Header> headers = getRequestHeadersList();
         return headers.toArray(new Header[headers.size()]);
     }
 
-    protected HttpEntity getRequestEntity() {
+    public HttpEntity getRequestEntity() {
         if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
             try {
                 return new StringEntity(bodyEditText.getText().toString());
@@ -162,7 +215,7 @@ public static int getContrastColor(int color) {
         return y >= 128 ? Color.BLACK : Color.WHITE;
     }
 
-    private View getColoredView(int bgColor, String msg) {
+    protected View getColoredView(int bgColor, String msg) {
         TextView tv = new TextView(this);
         tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
         tv.setText(msg);
@@ -180,23 +233,16 @@ protected final void clearOutputs() {
         responseLayout.removeAllViews();
     }
 
-    protected boolean isCancelButtonAllowed() {
+    public boolean isCancelButtonAllowed() {
         return false;
     }
 
-    protected abstract int getSampleTitle();
-
-    protected abstract boolean isRequestBodyAllowed();
-
-    protected abstract boolean isRequestHeadersAllowed();
-
-    protected abstract String getDefaultURL();
-
-    protected abstract AsyncHttpResponseHandler getResponseHandler();
-
-    protected AsyncHttpClient getAsyncHttpClient() {
+    public AsyncHttpClient getAsyncHttpClient() {
         return this.asyncHttpClient;
     }
 
-    protected abstract void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler);
+    @Override
+    public void setAsyncHttpClient(AsyncHttpClient client) {
+        this.asyncHttpClient = client;
+    }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
new file mode 100644
index 00000000..ca85eb8d
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SaxSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SaxAsyncHttpResponseHandler;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class SaxSample extends SampleParentActivity {
+
+    private static final String LOG_TAG = "SaxSample";
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return saxAsyncHttpResponseHandler;
+    }
+
+    private SaxAsyncHttpResponseHandler saxAsyncHttpResponseHandler = new SaxAsyncHttpResponseHandler<SAXTreeStructure>(new SAXTreeStructure()) {
+        @Override
+        public void onStart() {
+            clearOutputs();
+        }
+
+        @Override
+        public void onSuccess(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        @Override
+        public void onFailure(int statusCode, Header[] headers, SAXTreeStructure saxTreeStructure) {
+            debugStatusCode(LOG_TAG, statusCode);
+            debugHeaders(LOG_TAG, headers);
+            debugHandler(saxTreeStructure);
+        }
+
+        private void debugHandler(SAXTreeStructure handler) {
+            for (Tuple t : handler.responseViews) {
+                addView(getColoredView(t.color, t.text));
+            }
+        }
+    };
+
+    @Override
+    public String getDefaultURL() {
+        return "http://bin-iin.com/sitemap.xml";
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_sax_example;
+    }
+
+    @Override
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
+    }
+
+    private class Tuple {
+        public Integer color;
+        public String text;
+
+        public Tuple(int _color, String _text) {
+            this.color = _color;
+            this.text = _text;
+        }
+    }
+
+    private class SAXTreeStructure extends DefaultHandler {
+
+        public List<Tuple> responseViews = new ArrayList<Tuple>();
+
+        public void startElement(String namespaceURI, String localName,
+                                 String rawName, Attributes atts) {
+            responseViews.add(new Tuple(LIGHTBLUE, "Start Element: " + rawName));
+        }
+
+        public void endElement(String namespaceURI, String localName,
+                               String rawName) {
+            responseViews.add(new Tuple(LIGHTBLUE, "End Element  : " + rawName));
+        }
+
+        public void characters(char[] data, int off, int length) {
+            if (length > 0 && data[0] != '\n') {
+                responseViews.add(new Tuple(LIGHTGREEN, "Characters  :  " + new String(data,
+                        off, length)));
+            }
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
new file mode 100644
index 00000000..bb92f02c
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -0,0 +1,126 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SyncHttpClient;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class SynchronousClientSample extends GetSample {
+    private static final String LOG_TAG = "SyncSample";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setAsyncHttpClient(new SyncHttpClient());
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_synchronous;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/delay/6";
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+        if (client instanceof SyncHttpClient) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Log.d(LOG_TAG, "Before Request");
+                    client.get(SynchronousClientSample.this, URL, headers, null, responseHandler);
+                    Log.d(LOG_TAG, "After Request");
+                }
+            }).start();
+        } else {
+            Log.e(LOG_TAG, "Error, not using SyncHttpClient");
+        }
+        /**
+         * SyncHttpClient does not return RequestHandle,
+         * it executes each request directly,
+         * therefore those requests are not in cancelable threads
+         * */
+        return null;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        clearOutputs();
+                    }
+                });
+            }
+
+            @Override
+            public void onSuccess(final int statusCode, final Header[] headers, final byte[] response) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(final int statusCode, final Header[] headers, final byte[] errorResponse, final Throwable e) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+                });
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
old mode 100644
new mode 100755
index 568537fe..752559e7
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -1,9 +1,29 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.util.SparseArray;
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,31 +31,31 @@
 public class ThreadingTimeoutSample extends SampleParentActivity {
 
     private static final String LOG_TAG = "ThreadingTimeoutSample";
-    private SparseArray<String> states = new SparseArray<String>();
+    private final SparseArray<String> states = new SparseArray<String>();
     private int counter = 0;
 
     @Override
-    protected int getSampleTitle() {
-        return R.string.app_name;
+    public int getSampleTitle() {
+        return R.string.title_threading_timeout;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isCancelButtonAllowed() {
+    public boolean isCancelButtonAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/delay/6";
     }
 
@@ -44,15 +64,15 @@ private synchronized void setStatus(int id, String status) {
         states.put(id, current == null ? status : current + "," + status);
         clearOutputs();
         for (int i = 0; i < states.size(); i++) {
-            debugResponse(LOG_TAG, states.keyAt(i) + ": " + states.get(states.keyAt(i)));
+            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
         }
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
-            private int id = counter++;
+            private final int id = counter++;
 
             @Override
             public void onStart() {
@@ -81,8 +101,12 @@ public void onCancel() {
         };
     }
 
+    public int getCounter() {
+        return counter;
+    }
+
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
old mode 100644
new mode 100755
index 857a0ffb..0341e23b
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample;
 
 import android.app.ListActivity;
@@ -7,47 +25,61 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY", "THREADING TIMEOUTS"};
+    private static final SampleConfig[] samplesConfig = new SampleConfig[] {
+        new SampleConfig(R.string.title_get_sample, GetSample.class),
+        new SampleConfig(R.string.title_post_sample, PostSample.class),
+        new SampleConfig(R.string.title_delete_sample, DeleteSample.class),
+        new SampleConfig(R.string.title_put_sample, PutSample.class),
+        new SampleConfig(R.string.title_json_sample, JsonSample.class),
+        new SampleConfig(R.string.title_sax_example, SaxSample.class),
+        new SampleConfig(R.string.title_file_sample, FileSample.class),
+        new SampleConfig(R.string.title_binary_sample, BinarySample.class),
+        new SampleConfig(R.string.title_gzip_sample, GzipSample.class),
+        new SampleConfig(R.string.title_redirect_302, Redirect302Sample.class),
+        new SampleConfig(R.string.title_threading_timeout, ThreadingTimeoutSample.class),
+        new SampleConfig(R.string.title_cancel_all, CancelAllRequestsSample.class),
+        new SampleConfig(R.string.title_cancel_handle, CancelRequestHandleSample.class),
+        new SampleConfig(R.string.title_synchronous, SynchronousClientSample.class),
+        new SampleConfig(R.string.title_intent_service_sample, IntentServiceSample.class),
+        new SampleConfig(R.string.title_post_files, FilesSample.class),
+        new SampleConfig(R.string.title_persistent_cookies, PersistentCookiesSample.class)
+    };
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, getTitlesList()));
+    }
+
+    private List<String> getTitlesList() {
+        List<String> titles = new ArrayList<String>();
+        for (SampleConfig config : samplesConfig) {
+            titles.add(getString(config.titleId));
+        }
+        return titles;
     }
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        Class<?> targetClass;
-        switch (position) {
-            case 0:
-            default:
-                targetClass = GetSample.class;
-                break;
-            case 1:
-                targetClass = PostSample.class;
-                break;
-            case 2:
-                targetClass = DeleteSample.class;
-                break;
-            case 3:
-                targetClass = PutSample.class;
-                break;
-            case 4:
-                targetClass = JsonSample.class;
-                break;
-            case 5:
-                targetClass = FileSample.class;
-                break;
-            case 6:
-                targetClass = BinarySample.class;
-                break;
-            case 7:
-                targetClass = ThreadingTimeoutSample.class;
-                break;
+        if (position >= 0 && position < samplesConfig.length)
+            startActivity(new Intent(this, samplesConfig[position].targetClass));
+    }
+
+    private static class SampleConfig {
+
+        final int titleId;
+        final Class targetClass;
+
+        SampleConfig(int titleId, Class targetClass) {
+          this.titleId = titleId;
+          this.targetClass = targetClass;
         }
-        if (targetClass != null)
-            startActivity(new Intent(this, targetClass));
+
     }
+
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
new file mode 100644
index 00000000..d2d743a5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
new file mode 100644
index 00000000..7fe49c71
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/ExampleIntentService.java
@@ -0,0 +1,87 @@
+package com.loopj.android.http.sample.services;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.SyncHttpClient;
+import com.loopj.android.http.sample.IntentServiceSample;
+import com.loopj.android.http.sample.util.IntentUtil;
+
+import org.apache.http.Header;
+
+public class ExampleIntentService extends IntentService {
+
+    public static final String LOG_TAG = "ExampleIntentService:IntentServiceSample";
+    public static final String INTENT_URL = "INTENT_URL";
+    public static final String INTENT_STATUS_CODE = "INTENT_STATUS_CODE";
+    public static final String INTENT_HEADERS = "INTENT_HEADERS";
+    public static final String INTENT_DATA = "INTENT_DATA";
+    public static final String INTENT_THROWABLE = "INTENT_THROWABLE";
+
+    private AsyncHttpClient aClient = new SyncHttpClient();
+
+    public ExampleIntentService() {
+        super("ExampleIntentService");
+    }
+
+    @Override
+    public void onStart(Intent intent, int startId) {
+        Log.d(LOG_TAG, "onStart()");
+        super.onStart(intent, startId);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        if (intent != null && intent.hasExtra(INTENT_URL)) {
+            aClient.get(this, intent.getStringExtra(INTENT_URL), new AsyncHttpResponseHandler() {
+                @Override
+                public void onStart() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_START));
+                    Log.d(LOG_TAG, "onStart");
+                }
+
+                @Override
+                public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_SUCCESS);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onSuccess");
+                }
+
+                @Override
+                public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+                    Intent broadcast = new Intent(IntentServiceSample.ACTION_FAILURE);
+                    broadcast.putExtra(INTENT_STATUS_CODE, statusCode);
+                    broadcast.putExtra(INTENT_HEADERS, IntentUtil.serializeHeaders(headers));
+                    broadcast.putExtra(INTENT_DATA, responseBody);
+                    broadcast.putExtra(INTENT_THROWABLE, error);
+                    sendBroadcast(broadcast);
+                    Log.d(LOG_TAG, "onFailure");
+                }
+
+                @Override
+                public void onCancel() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_CANCEL));
+                    Log.d(LOG_TAG, "onCancel");
+                }
+
+                @Override
+                public void onRetry(int retryNo) {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_RETRY));
+                    Log.d(LOG_TAG, String.format("onRetry: %d", retryNo));
+                }
+
+                @Override
+                public void onFinish() {
+                    sendBroadcast(new Intent(IntentServiceSample.ACTION_FINISH));
+                    Log.d(LOG_TAG, "onFinish");
+                }
+            });
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
new file mode 100644
index 00000000..df4ac428
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/services/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.services;
\ No newline at end of file
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
old mode 100644
new mode 100755
index 2d9d5dda..6838d595
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import java.io.BufferedReader;
@@ -12,7 +30,7 @@
     public static String convertStreamToString(InputStream is) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(is));
         StringBuilder sb = new StringBuilder();
-        String line = null;
+        String line;
         while ((line = reader.readLine()) != null) {
             sb.append(line).append("\n");
         }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
new file mode 100644
index 00000000..a0ccb54b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/IntentUtil.java
@@ -0,0 +1,32 @@
+package com.loopj.android.http.sample.util;
+
+import org.apache.http.Header;
+import org.apache.http.message.BasicHeader;
+
+public class IntentUtil {
+
+    public static String[] serializeHeaders(Header[] headers) {
+        if (headers == null) {
+            return new String[0];
+        }
+        String[] rtn = new String[headers.length * 2];
+        int index = -1;
+        for (Header h : headers) {
+            rtn[++index] = h.getName();
+            rtn[++index] = h.getValue();
+        }
+        return rtn;
+    }
+
+    public static Header[] deserializeHeaders(String[] serialized) {
+        if (serialized == null || serialized.length % 2 != 0) {
+            return new Header[0];
+        }
+        Header[] headers = new Header[serialized.length / 2];
+        for (int i = 0, h = 0; h < headers.length; i++, h++) {
+            headers[h] = new BasicHeader(serialized[i], serialized[++i]);
+        }
+        return headers;
+    }
+
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
old mode 100644
new mode 100755
index e12c30fc..8e6c4a91
--- a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
@@ -1,3 +1,21 @@
+/*
+    Android Asynchronous Http Client Sample
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
 package com.loopj.android.http.sample.util;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
new file mode 100644
index 00000000..4937f7f5
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/package-info.java
@@ -0,0 +1,19 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2014 Marek Sebera <marek.sebera@gmail.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http.sample.util;
\ No newline at end of file
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
new file mode 100755
index 00000000..97ba749b
--- /dev/null
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <EditText
+            android:id="@+id/edit_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:inputType="textUri"/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/button_cancel"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_cancel"/>
+
+            <Button
+                android:id="@+id/button_run"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_run"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
old mode 100644
new mode 100755
index b32b7b74..d2c7dad6
--- a/sample/src/main/res/layout/parent_layout.xml
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:fillViewport="true">
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
 
     <LinearLayout
         android:focusable="true"
@@ -11,7 +11,7 @@
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
-        <requestFocus />
+        <requestFocus/>
 
         <LinearLayout
             android:id="@+id/layout_url"
@@ -24,20 +24,20 @@
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:layout_weight="1"
-                android:inputType="textUri" />
+                android:inputType="textUri"/>
 
             <Button
                 android:id="@+id/button_run"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="@string/button_run" />
+                android:text="@string/button_run"/>
 
             <Button
                 android:id="@+id/button_cancel"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:visibility="gone"
-                android:text="@string/button_cancel" />
+                android:text="@string/button_cancel"/>
         </LinearLayout>
 
         <LinearLayout
@@ -49,7 +49,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_headers" />
+                android:text="@string/label_headers"/>
 
             <EditText
                 android:id="@+id/edit_headers"
@@ -57,7 +57,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -70,7 +70,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_req_body" />
+                android:text="@string/label_req_body"/>
 
             <EditText
                 android:id="@+id/edit_body"
@@ -78,7 +78,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -86,7 +86,7 @@
             android:id="@+id/layout_response"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:orientation="vertical" />
+            android:orientation="vertical"/>
 
     </LinearLayout>
 </ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
old mode 100644
new mode 100755
index 9e6bae35..4d9d5805
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -1,16 +1,28 @@
 <?xml version="1.0" encoding="utf-8"?>
-<resources>
 
+<resources>
     <string name="app_name">Android Async Http Samples</string>
+
+    <string name="button_run">Run</string>
+    <string name="label_headers">Headers (key=val, one per line)</string>
+    <string name="label_req_body">Request body</string>
+    <string name="button_cancel">Cancel</string>
+
     <string name="title_get_sample">GET</string>
-    <string name="title_json_sample">GET and JSON parse</string>
+    <string name="title_json_sample">GET JSON and parse it</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
-    <string name="button_run">Run</string>
-    <string name="label_headers">Headers (key=val, one per line)</string>
-    <string name="label_req_body">Request body</string>
-    <string name="button_cancel">Cancel</string>
+    <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_sax_example">SAX Example</string>
+    <string name="title_cancel_handle">Cancel request handle</string>
+    <string name="title_synchronous">Synchronous GET request</string>
+    <string name="title_threading_timeout">Threading timeouts</string>
+    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
+    <string name="title_intent_service_sample">IntentService Synchronised Request</string>
+    <string name="title_post_files">Post Multipart-encoded files</string>
+    <string name="title_redirect_302">302 Redirect handling</string>
+    <string name="title_persistent_cookies">Handling persistent cookies</string>
 </resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
old mode 100644
new mode 100755
diff --git a/settings.gradle b/settings.gradle
old mode 100644
new mode 100755
