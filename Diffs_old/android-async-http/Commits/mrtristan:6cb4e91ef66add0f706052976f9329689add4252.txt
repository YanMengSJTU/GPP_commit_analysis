diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/.travis.yml b/.travis.yml
old mode 100644
new mode 100755
index 69ae732e..516e7ca9
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,7 +4,7 @@ branches:
 language:
   - java
 jdk:
-  - openjdk6
+  - openjdk7
 before_install:
   # environment info
   - mvn -version
@@ -16,22 +16,22 @@ before_install:
   # for gradle output style
   - export TERM=dumb
   # newer version of gradle
-  - wget http://services.gradle.org/distributions/gradle-1.10-bin.zip
-  - unzip -qq gradle-1.10-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.10
+  - wget http://services.gradle.org/distributions/gradle-1.11-bin.zip
+  - unzip -qq gradle-1.11-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.11
   - export PATH=$GRADLE_HOME/bin:$PATH
   # just to test gradle version, against our provided one
   - gradle -v
-  # newest android SDK 22.3
-  - wget http://dl.google.com/android/android-sdk_r22.3-linux.tgz
-  - tar -zxf android-sdk_r22.3-linux.tgz
+  # newest android SDK 22.6.1
+  - wget http://dl.google.com/android/android-sdk_r22.6.1-linux.tgz
+  - tar -zxf android-sdk_r22.6.1-linux.tgz
   - export ANDROID_HOME=`pwd`/android-sdk-linux
   - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
   # manually set sdk.dir variable, according to local paths
   - echo "sdk.dir=$ANDROID_HOME" > local.properties
   # list packages for debug purpose
   - android list sdk -a -e -u
-  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.1 --force --no-ui
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-19,build-tools-19.0.3 --force --no-ui
   # Sonatype bypass
   - echo "nexusUsername=dummy" >> library/gradle.properties
   - echo "nexusPassword=dummy" >> library/gradle.properties
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index fe5fed6b..182a9605
--- a/README.md
+++ b/README.md
@@ -1,7 +1,6 @@
 Asynchronous Http Client for Android
 ====================================
-
-Travis CI state : [![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
+[![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
 
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
@@ -13,7 +12,7 @@ Features
 - Requests use a **threadpool** to cap concurrent resource usage
 - GET/POST **params builder** (RequestParams)
 - **Multipart file uploads** with no additional third party libraries
-- Tiny size overhead to your application, only **19kb** for everything
+- Tiny size overhead to your application, only **60kb** for everything
 - Automatic smart **request retries** optimized for spotty mobile connections
 - Automatic **gzip** response decoding support for super-fast requests
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
@@ -28,7 +27,7 @@ https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/androi
 ```
 Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
+ArtifactId: android-async-http
 Version: 1.4.5-SNAPSHOT
 Packaging: JAR or AAR
 ```
diff --git a/build.gradle b/build.gradle
old mode 100644
new mode 100755
index ca484909..21db9553
--- a/build.gradle
+++ b/build.gradle
@@ -22,6 +22,7 @@ allprojects {
 
     tasks.withType(JavaCompile) {
         options.encoding = "UTF-8"
+        options.compilerArgs << "-Xlint:unchecked"
     }
 }
 
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
old mode 100644
new mode 100755
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
old mode 100644
new mode 100755
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
old mode 100644
new mode 100755
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
old mode 100644
new mode 100755
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
old mode 100644
new mode 100755
diff --git a/gradle.properties b/gradle.properties
old mode 100644
new mode 100755
diff --git a/library/build.gradle b/library/build.gradle
old mode 100644
new mode 100755
index e7b17970..3ac2b0a6
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,8 +1,10 @@
+import com.android.builder.BuilderConstants
+
 apply plugin: 'android-library'
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.1'
+    buildToolsVersion '19.0.3'
 
     defaultConfig {
         minSdkVersion 3
@@ -12,11 +14,16 @@ android {
     lintOptions {
         abortOnError false
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 android.libraryVariants.all { variant ->
   def name = variant.buildType.name
-  if (name.equals(com.android.builder.BuilderConstants.DEBUG)) {
+  if (name.equals(BuilderConstants.DEBUG)) {
     return; // Skip debug builds.
   }
   def task = project.tasks.create "android${name.capitalize()}Jar", Jar
@@ -27,7 +34,7 @@ android.libraryVariants.all { variant ->
 
 android.libraryVariants.all { variant ->
 
-    task("generate${variant.name}Javadoc", type: Javadoc) {
+    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
         description "Generates Javadoc for $variant.name."
         source = variant.javaCompile.source
         ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
diff --git a/library/gradle.properties b/library/gradle.properties
old mode 100644
new mode 100755
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
old mode 100644
new mode 100755
index 7e9867c9..2e2f68c9
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -19,11 +19,13 @@
 package com.loopj.android.http;
 
 import android.content.Context;
+import android.os.Looper;
 import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpException;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
@@ -31,9 +33,13 @@
 import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
+import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
+import org.apache.http.client.RedirectHandler;
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
@@ -41,6 +47,7 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
@@ -50,19 +57,22 @@
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.auth.BasicScheme;
 import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -92,7 +102,6 @@
  */
 public class AsyncHttpClient {
 
-    public static final String VERSION = "1.4.5";
     public static final int DEFAULT_MAX_CONNECTIONS = 10;
     public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     public static final int DEFAULT_MAX_RETRIES = 5;
@@ -205,11 +214,10 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = Executors.newCachedThreadPool();
+        threadPool = getDefaultThreadPool();
         requestMap = new WeakHashMap<Context, List<RequestHandle>>();
         clientHeaderMap = new HashMap<String, String>();
 
@@ -222,6 +230,14 @@ public void process(HttpRequest request, HttpContext context) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
                 }
                 for (String header : clientHeaderMap.keySet()) {
+                    if (request.containsHeader(header)) {
+                        Header overwritten = request.getFirstHeader(header);
+                        Log.d(LOG_TAG,
+                                String.format("Headers were overwritten! (%s | %s) overwrites (%s | %s)",
+                                        header, clientHeaderMap.get(header),
+                                        overwritten.getName(), overwritten.getValue())
+                        );
+                    }
                     request.addHeader(header, clientHeaderMap.get(header));
                 }
             }
@@ -246,6 +262,25 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+                AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+                CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                        ClientContext.CREDS_PROVIDER);
+                HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+                if (authState.getAuthScheme() == null) {
+                    AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+                    Credentials creds = credsProvider.getCredentials(authScope);
+                    if (creds != null) {
+                        authState.setAuthScheme(new BasicScheme());
+                        authState.setCredentials(creds);
+                    }
+                }
+            }
+        }, 0);
+
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));
     }
 
@@ -303,19 +338,69 @@ public void setThreadPool(ThreadPoolExecutor threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * used.
+     *
+     * @return current executor service used
+     */
+    public ExecutorService getThreadPool() {
+        return threadPool;
+    }
+
+    /**
+     * Get the default threading pool to be used for this HTTP client.
+     *
+     * @return The default threading pool to be used
+     */
+    protected ExecutorService getDefaultThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
      * on underlying HttpClient, effects of this method will be canceled.
+     * <p/>
+     * Default setting is to disallow redirects.
      *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @param enableCircularRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
+        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
+        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
+        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
+    }
+
+    /**
+     * Circular redirects are enabled by default
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
+        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
+    }
+
+    /**
      * @param enableRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
      */
     public void setEnableRedirects(final boolean enableRedirects) {
-        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
-            @Override
-            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
-                return enableRedirects;
-            }
-        });
+        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
+    }
+
+    /**
+     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
+     * your needs
+     *
+     * @param customRedirectHandler RedirectHandler instance
+     * @see com.loopj.android.http.MyRedirectHandler
+     */
+    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
+        httpClient.setRedirectHandler(customRedirectHandler);
     }
 
     /**
@@ -404,7 +489,6 @@ public void setProxy(String hostname, int port, String username, String password
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
-
     /**
      * Sets the SSLSocketFactory to user when making requests. By default, a new, default
      * SSLSocketFactory is used.
@@ -452,8 +536,19 @@ public void removeHeader(String header) {
      * @param password Basic Auth password
      */
     public void setBasicAuth(String username, String password) {
-        AuthScope scope = AuthScope.ANY;
-        setBasicAuth(username, password, scope);
+        setBasicAuth(username, password, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, boolean preemtive) {
+        setBasicAuth(username, password, null, preemtive);
     }
 
     /**
@@ -465,12 +560,40 @@ public void setBasicAuth(String username, String password) {
      * @param scope    - an AuthScope object
      */
     public void setBasicAuth(String username, String password, AuthScope scope) {
+        setBasicAuth(username, password, scope, false);
+    }
+
+    /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It
+     * should be like this setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
+     * @param username  Basic Auth username
+     * @param password  Basic Auth password
+     * @param scope     an AuthScope object
+     * @param preemtive sets authorization in preemtive manner
+     */
+    public void setBasicAuth(String username, String password, AuthScope scope, boolean preemtive) {
         UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
-        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+        this.httpClient.getCredentialsProvider().setCredentials(scope == null ? AuthScope.ANY : scope, credentials);
+        setAuthenticationPreemptive(preemtive);
+    }
+
+    /**
+     * Sets HttpRequestInterceptor which handles authorization in preemtive way, as workaround you
+     * can use call `AsyncHttpClient.addHeader("Authorization","Basic base64OfUsernameAndPassword==")`
+     *
+     * @param isPreemtive whether the authorization is processed in preemtive way
+     */
+    public void setAuthenticationPreemptive(boolean isPreemtive) {
+        if (isPreemtive) {
+            httpClient.addRequestInterceptor(new PreemtiveAuthorizationHttpRequestInterceptor(), 0);
+        } else {
+            httpClient.removeRequestInterceptorByClass(PreemtiveAuthorizationHttpRequestInterceptor.class);
+        }
     }
 
     /**
-     * Removes set basic auth credentials
+     * Removes previously set basic auth credentials
      */
     public void clearBasicAuth() {
         this.httpClient.getCredentialsProvider().clear();
@@ -486,14 +609,48 @@ public void clearBasicAuth() {
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
      *                              pending requests.
      */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<RequestHandle> requestList = requestMap.get(context);
-        if (requestList != null) {
-            for (RequestHandle requestHandle : requestList) {
-                requestHandle.cancel(mayInterruptIfRunning);
+    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
+        if (context == null) {
+            Log.e(LOG_TAG, "Passed null Context to cancelRequests");
+            return;
+        }
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                List<RequestHandle> requestList = requestMap.get(context);
+                if (requestList != null) {
+                    for (RequestHandle requestHandle : requestList) {
+                        requestHandle.cancel(mayInterruptIfRunning);
+                    }
+                    requestMap.remove(context);
+                }
+            }
+        };
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            new Thread(r).start();
+        } else {
+            r.run();
+        }
+    }
+
+    /**
+     * Cancels all pending (or potentially active) requests. <p>&nbsp;</p> <b>Note:</b> This will
+     * only affect requests which were created with a non-null android Context. This method is
+     * intended to be used in the onDestroy method of your android activities to destroy all
+     * requests which are no longer required.
+     *
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
+     *                              pending requests.
+     */
+    public void cancelAllRequests(boolean mayInterruptIfRunning) {
+        for (List<RequestHandle> requestList : requestMap.values()) {
+            if (requestList != null) {
+                for (RequestHandle requestHandle : requestList) {
+                    requestHandle.cancel(mayInterruptIfRunning);
+                }
             }
-            requestMap.remove(context);
         }
+        requestMap.clear();
     }
 
     // [+] HTTP HEAD
@@ -688,7 +845,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -706,7 +863,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -730,7 +887,7 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -789,7 +946,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -808,7 +965,7 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -836,7 +993,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -850,7 +1007,7 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(url);
+        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
@@ -886,6 +1043,18 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
      * @return RequestHandle of future request process
      */
     protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) {
+        if (uriRequest == null) {
+            throw new IllegalArgumentException("HttpUriRequest must not be null");
+        }
+
+        if (responseHandler == null) {
+            throw new IllegalArgumentException("ResponseHandler must not be null");
+        }
+
+        if (responseHandler.getUseSynchronousMode()) {
+            throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
+        }
+
         if (contentType != null) {
             uriRequest.setHeader("Content-Type", contentType);
         }
@@ -901,10 +1070,13 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
             // Add request to request map
             List<RequestHandle> requestList = requestMap.get(context);
             if (requestList == null) {
-                requestList = new LinkedList<RequestHandle>();
+                requestList = new LinkedList();
                 requestMap.put(context, requestList);
             }
 
+            if (responseHandler instanceof RangeFileAsyncHttpResponseHandler)
+                ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(uriRequest);
+
             requestList.add(requestHandle);
 
             Iterator<RequestHandle> iterator = requestList.iterator();
@@ -956,6 +1128,36 @@ public static String getUrlWithQueryString(boolean shouldEncodeUrl, String url,
         return url;
     }
 
+    /**
+     * A utility function to close an input stream without raising an exception.
+     *
+     * @param is input stream to close safely
+     */
+    public static void silentCloseInputStream(InputStream is) {
+        try {
+            if (is != null) {
+                is.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close input stream", e);
+        }
+    }
+
+    /**
+     * A utility function to close an output stream without raising an exception.
+     *
+     * @param os output stream to close safely
+     */
+    public static void silentCloseOutputStream(OutputStream os) {
+        try {
+            if (os != null) {
+                os.close();
+            }
+        } catch (IOException e) {
+            Log.w(LOG_TAG, "Cannot close output stream", e);
+        }
+    }
+
     /**
      * Returns HttpEntity containing data from RequestParams included with request declaration.
      * Allows also passing progress from upload via provided ResponseHandler
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
old mode 100644
new mode 100755
index b9dc45ca..81786ceb
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -33,7 +33,7 @@
 /**
  * Internal class, representing the HttpRequest, done in asynchronous manner
  */
-class AsyncHttpRequest implements Runnable {
+public class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
     private final HttpUriRequest request;
@@ -166,9 +166,7 @@ public boolean isDone() {
 
     public boolean cancel(boolean mayInterruptIfRunning) {
         isCancelled = true;
-        if (mayInterruptIfRunning && request != null && !request.isAborted()) {
-            request.abort();
-        }
+        request.abort();
         return isCancelled();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 985c5267..b345d872
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -91,10 +91,10 @@
 
     protected static final int BUFFER_SIZE = 4096;
 
-    private final Handler handler;
     public static final String DEFAULT_CHARSET = "UTF-8";
     private String responseCharset = DEFAULT_CHARSET;
-    private Boolean useSynchronousMode = false;
+    private Handler handler;
+    private boolean useSynchronousMode;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
@@ -142,6 +142,21 @@ public boolean getUseSynchronousMode() {
 
     @Override
     public void setUseSynchronousMode(boolean value) {
+        // A looper must be prepared before setting asynchronous mode.
+        if (!value && Looper.myLooper() == null) {
+            value = true;
+            Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
+        }
+
+        // If using synchronous mode.
+        if (!value && handler == null) {
+            // Create a handler on current thread to submit tasks
+            handler = new ResponderHandler(this);
+        } else if (value && handler != null) {
+            // TODO: Consider adding a flag to remove all queued messages.
+            handler = null;
+        }
+
         useSynchronousMode = value;
     }
 
@@ -163,11 +178,8 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
-        // There is always a handler ready for delivering messages.
-        handler = new ResponderHandler(this);
-
-        // Init Looper by calling postRunnable without an argument.
-        postRunnable(null);
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
     }
 
     /**
@@ -177,7 +189,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
-        Log.v(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
+        Log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
     }
 
     /**
@@ -306,7 +318,7 @@ protected void handleMessage(Message message) {
     }
 
     protected void sendMessage(Message msg) {
-        if (getUseSynchronousMode()) {
+        if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
             handler.sendMessage(msg);
@@ -319,15 +331,14 @@ protected void sendMessage(Message msg) {
      * @param runnable runnable instance, can be null
      */
     protected void postRunnable(Runnable runnable) {
-        boolean missingLooper = null == Looper.myLooper();
-        if (missingLooper) {
-            Looper.prepare();
-        }
-        if (null != runnable) {
-            handler.post(runnable);
-        }
-        if (missingLooper) {
-            Looper.loop();
+        if (runnable != null) {
+            if (getUseSynchronousMode() || handler == null) {
+                // This response handler is synchronous, run on current thread
+                runnable.run();
+            } else {
+                // Otherwise, run on provided handler
+                handler.post(runnable);
+            }
         }
     }
 
@@ -339,7 +350,17 @@ protected void postRunnable(Runnable runnable) {
      * @return Message instance, should not be null
      */
     protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
-        return handler.obtainMessage(responseMessageId, responseMessageData);
+        Message msg;
+        if (handler == null) {
+            msg = Message.obtain();
+            if (msg != null) {
+                msg.what = responseMessageId;
+                msg.obj = responseMessageData;
+            }
+        } else {
+            msg = Message.obtain(handler, responseMessageId, responseMessageData);
+        }
+        return msg;
     }
 
     @Override
@@ -376,7 +397,7 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                 if (contentLength > Integer.MAX_VALUE) {
                     throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
                 }
-                int buffersize = (contentLength < 0) ? BUFFER_SIZE : (int) contentLength;
+                int buffersize = (contentLength <= 0) ? BUFFER_SIZE : (int) contentLength;
                 try {
                     ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize);
                     try {
@@ -386,10 +407,10 @@ public void sendResponseMessage(HttpResponse response) throws IOException {
                         while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
                             count += l;
                             buffer.append(tmp, 0, l);
-                            sendProgressMessage(count, (int) contentLength);
+                            sendProgressMessage(count, (int) (contentLength <= 0 ? 1 : contentLength));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/Base64.java b/library/src/main/java/com/loopj/android/http/Base64.java
old mode 100644
new mode 100755
index e9bc1809..0fae7e9a
--- a/library/src/main/java/com/loopj/android/http/Base64.java
+++ b/library/src/main/java/com/loopj/android/http/Base64.java
@@ -19,10 +19,8 @@
 import java.io.UnsupportedEncodingException;
 
 /**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ * Utilities for encoding and decoding the Base64 representation of binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
  */
 public class Base64 {
     /**
@@ -31,36 +29,31 @@
     public static final int DEFAULT = 0;
 
     /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
+     * Encoder flag bit to omit the padding '=' characters at the end of the output (if any).
      */
     public static final int NO_PADDING = 1;
 
     /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
+     * Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).
      */
     public static final int NO_WRAP = 2;
 
     /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
+     * Encoder flag bit to indicate lines should be terminated with a CRLF pair instead of just an
+     * LF.  Has no effect if {@code NO_WRAP} is specified as well.
      */
     public static final int CRLF = 4;
 
     /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
+     * Encoder/decoder flag bit to indicate using the "URL and filename safe" variant of Base64 (see
+     * RFC 3548 section 4) where {@code -} and {@code _} are used in place of {@code +} and {@code
+     * /}.
      */
     public static final int URL_SAFE = 8;
 
     /**
-     * Flag to pass to {@link Base64OutputStream} to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
+     * Flag to pass to {@link Base64OutputStream} to indicate that it should not close the output
+     * stream it is wrapping when it itself is closed.
      */
     public static final int NO_CLOSE = 16;
 
@@ -73,24 +66,20 @@
         public int op;
 
         /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
+         * Encode/decode another block of input data.  this.output is provided by the caller, and
+         * must be big enough to hold all the coded data.  On exit, this.opwill be set to the length
          * of the coded data.
          *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
+         * @param finish true if this is the final call to process for this object.  Will finalize
+         *               the coder state and include any final bytes in the output.
+         * @return true if the input so far is good; false if some error has been detected in the
+         * input stream..
          */
         public abstract boolean process(byte[] input, int offset, int len, boolean finish);
 
         /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
+         * @return the maximum number of bytes a call to process() could produce for the given
+         * number of input bytes.  This may be an overestimate.
          */
         public abstract int maxOutputSize(int len);
     }
@@ -100,62 +89,53 @@
     //  --------------------------------------------------------
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param str   the input String to decode, which is converted to bytes using the default
+     *              charset
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(String str, int flags) {
         return decode(str.getBytes(), flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
      * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *              standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int flags) {
         return decode(input, 0, input.length, flags);
     }
 
     /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
+     * Decode the Base64-encoded data in input and return the data in a new byte array.
+     * <p/>
+     * <p>The padding '=' characters at the end are considered optional, but if any are present,
+     * there must be the correct number of them.
      *
      * @param input  the data to decode
      * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
+     * @param flags  controls certain features of the decoded output. Pass {@code DEFAULT} to decode
+     *               standard Base64.
+     * @throws IllegalArgumentException if the input contains incorrect padding
      */
     public static byte[] decode(byte[] input, int offset, int len, int flags) {
         // Allocate space for the most data the input could represent.
         // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
 
         if (!decoder.process(input, offset, len, true)) {
             throw new IllegalArgumentException("bad base-64");
@@ -175,63 +155,61 @@
 
     /* package */ static class Decoder extends Coder {
         /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
+         * Lookup table for turning bytes into their position in the Base64 alphabet.
          */
         private static final int DECODE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
         /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
+         * Decode lookup table for the "web safe" variant (RFC 3548 sec. 4) where - and _ replace +
+         * and /.
          */
         private static final int DECODE_WEBSAFE[] = {
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         };
 
-        /** Non-data values in the DECODE arrays. */
+        /**
+         * Non-data values in the DECODE arrays.
+         */
         private static final int SKIP = -1;
         private static final int EQUALS = -2;
 
         /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
+         * States 0-3 are reading through the next input tuple. State 4 is having read one '=' and
+         * expecting exactly one more. State 5 is expecting no more data or padding characters in
+         * the input. State 6 is the error state; an error has been detected in the input and no
+         * future input can "fix" it.
          */
         private int state;   // state number (0 to 6)
         private int value;
@@ -247,18 +225,17 @@ public Decoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could decode to.
          */
         public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
+            return len * 3 / 4 + 10;
         }
 
         /**
          * Decode another block of input data.
          *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
+         * @return true if the state machine is still healthy.  false if bad base-64 data has been
+         * detected in the input stream.
          */
         public boolean process(byte[] input, int offset, int len, boolean finish) {
             if (this.state == 6) return false;
@@ -293,13 +270,13 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // You can remove this whole block and the output should
                 // be the same, just slower.
                 if (state == 0) {
-                    while (p+4 <= len &&
-                           (value = ((alphabet[input[p] & 0xff] << 18) |
-                                     (alphabet[input[p+1] & 0xff] << 12) |
-                                     (alphabet[input[p+2] & 0xff] << 6) |
-                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
+                    while (p + 4 <= len &&
+                            (value = ((alphabet[input[p] & 0xff] << 18) |
+                                    (alphabet[input[p + 1] & 0xff] << 12) |
+                                    (alphabet[input[p + 2] & 0xff] << 6) |
+                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {
+                        output[op + 2] = (byte) value;
+                        output[op + 1] = (byte) (value >> 8);
                         output[op] = (byte) (value >> 16);
                         op += 3;
                         p += 4;
@@ -315,78 +292,78 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 int d = alphabet[input[p++] & 0xff];
 
                 switch (state) {
-                case 0:
-                    if (d >= 0) {
-                        value = d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 1:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 2:
-                    if (d >= 0) {
-                        value = (value << 6) | d;
-                        ++state;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect exactly one more padding character.
-                        output[op++] = (byte) (value >> 4);
-                        state = 4;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 3:
-                    if (d >= 0) {
-                        // Emit the output triple and return to state 0.
-                        value = (value << 6) | d;
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        state = 0;
-                    } else if (d == EQUALS) {
-                        // Emit the last (partial) output tuple;
-                        // expect no further data or padding characters.
-                        output[op+1] = (byte) (value >> 2);
-                        output[op] = (byte) (value >> 10);
-                        op += 2;
-                        state = 5;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 4:
-                    if (d == EQUALS) {
-                        ++state;
-                    } else if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
-
-                case 5:
-                    if (d != SKIP) {
-                        this.state = 6;
-                        return false;
-                    }
-                    break;
+                    case 0:
+                        if (d >= 0) {
+                            value = d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 1:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 2:
+                        if (d >= 0) {
+                            value = (value << 6) | d;
+                            ++state;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect exactly one more padding character.
+                            output[op++] = (byte) (value >> 4);
+                            state = 4;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 3:
+                        if (d >= 0) {
+                            // Emit the output triple and return to state 0.
+                            value = (value << 6) | d;
+                            output[op + 2] = (byte) value;
+                            output[op + 1] = (byte) (value >> 8);
+                            output[op] = (byte) (value >> 16);
+                            op += 3;
+                            state = 0;
+                        } else if (d == EQUALS) {
+                            // Emit the last (partial) output tuple;
+                            // expect no further data or padding characters.
+                            output[op + 1] = (byte) (value >> 2);
+                            output[op] = (byte) (value >> 10);
+                            op += 2;
+                            state = 5;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 4:
+                        if (d == EQUALS) {
+                            ++state;
+                        } else if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
+
+                    case 5:
+                        if (d != SKIP) {
+                            this.state = 6;
+                            return false;
+                        }
+                        break;
                 }
             }
 
@@ -403,33 +380,33 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
             // the state machine and finish up.
 
             switch (state) {
-            case 0:
-                // Output length is a multiple of three.  Fine.
-                break;
-            case 1:
-                // Read one extra input byte, which isn't enough to
-                // make another output byte.  Illegal.
-                this.state = 6;
-                return false;
-            case 2:
-                // Read two extra input bytes, enough to emit 1 more
-                // output byte.  Fine.
-                output[op++] = (byte) (value >> 4);
-                break;
-            case 3:
-                // Read three extra input bytes, enough to emit 2 more
-                // output bytes.  Fine.
-                output[op++] = (byte) (value >> 10);
-                output[op++] = (byte) (value >> 2);
-                break;
-            case 4:
-                // Read one padding '=' when we expected 2.  Illegal.
-                this.state = 6;
-                return false;
-            case 5:
-                // Read all the padding '='s we expected and no more.
-                // Fine.
-                break;
+                case 0:
+                    // Output length is a multiple of three.  Fine.
+                    break;
+                case 1:
+                    // Read one extra input byte, which isn't enough to
+                    // make another output byte.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 2:
+                    // Read two extra input bytes, enough to emit 1 more
+                    // output byte.  Fine.
+                    output[op++] = (byte) (value >> 4);
+                    break;
+                case 3:
+                    // Read three extra input bytes, enough to emit 2 more
+                    // output bytes.  Fine.
+                    output[op++] = (byte) (value >> 10);
+                    output[op++] = (byte) (value >> 2);
+                    break;
+                case 4:
+                    // Read one padding '=' when we expected 2.  Illegal.
+                    this.state = 6;
+                    return false;
+                case 5:
+                    // Read all the padding '='s we expected and no more.
+                    // Fine.
+                    break;
             }
 
             this.state = state;
@@ -443,13 +420,11 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
     //  --------------------------------------------------------
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
      */
     public static String encodeToString(byte[] input, int flags) {
         try {
@@ -461,16 +436,13 @@ public static String encodeToString(byte[] input, int flags) {
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
+     * Base64-encode the given data and return a newly allocated String with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
      */
     public static String encodeToString(byte[] input, int offset, int len, int flags) {
         try {
@@ -482,29 +454,24 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param input the data to encode
+     * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
+     *              in output that adheres to RFC 2045.
      */
     public static byte[] encode(byte[] input, int flags) {
         return encode(input, 0, input.length, flags);
     }
 
     /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
+     * Base64-encode the given data and return a newly allocated byte[] with the result.
      *
      * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
+     * @param offset the position within the input array at which to start
      * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
+     * @param flags  controls certain features of the encoded output. Passing {@code DEFAULT}
+     *               results in output that adheres to RFC 2045.
      */
     public static byte[] encode(byte[] input, int offset, int len, int flags) {
         Encoder encoder = new Encoder(flags, null);
@@ -519,54 +486,59 @@ public static String encodeToString(byte[] input, int offset, int len, int flags
             }
         } else {
             switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
+                case 0:
+                    break;
+                case 1:
+                    output_len += 2;
+                    break;
+                case 2:
+                    output_len += 3;
+                    break;
             }
         }
 
         // Account for the newlines, if any.
         if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                (encoder.do_cr ? 2 : 1);
+            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                    (encoder.do_cr ? 2 : 1);
         }
 
         encoder.output = new byte[output_len];
         encoder.process(input, offset, len, true);
 
-        assert encoder.op == output_len;
+        if (BuildConfig.DEBUG && encoder.op != output_len) {
+            throw new AssertionError();
+        }
 
         return encoder.output;
     }
 
     /* package */ static class Encoder extends Coder {
         /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         * Emit a new line every this many output tuples.  Corresponds to a 76-character line length
+         * (the maximum allowable according to <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC
+         * 2045</a>).
          */
         public static final int LINE_GROUPS = 19;
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
         };
 
         /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
+         * Lookup table for turning Base64 alphabet positions (6 bits) into output bytes.
          */
         private static final byte ENCODE_WEBSAFE[] = {
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
         };
 
         final private byte[] tail;
@@ -593,11 +565,10 @@ public Encoder(int flags, byte[] output) {
         }
 
         /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
+         * @return an overestimate for the number of bytes {@code len} bytes could encode to.
          */
         public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
+            return len * 8 / 5 + 10;
         }
 
         public boolean process(byte[] input, int offset, int len, boolean finish) {
@@ -621,22 +592,22 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     break;
 
                 case 1:
-                    if (p+2 <= len) {
+                    if (p + 2 <= len) {
                         // A 1-byte tail with at least 2 bytes of
                         // input available now.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((input[p++] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((input[p++] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
 
                 case 2:
-                    if (p+1 <= len) {
+                    if (p + 1 <= len) {
                         // A 2-byte tail with at least 1 byte of input.
                         v = ((tail[0] & 0xff) << 16) |
-                            ((tail[1] & 0xff) << 8) |
-                            (input[p++] & 0xff);
+                                ((tail[1] & 0xff) << 8) |
+                                (input[p++] & 0xff);
                         tailLen = 0;
                     }
                     break;
@@ -659,14 +630,14 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
 
             // The main loop, turning 3 input bytes into 4 output bytes on
             // each iteration.
-            while (p+3 <= len) {
+            while (p + 3 <= len) {
                 v = ((input[p] & 0xff) << 16) |
-                    ((input[p+1] & 0xff) << 8) |
-                    (input[p+2] & 0xff);
+                        ((input[p + 1] & 0xff) << 8) |
+                        (input[p + 2] & 0xff);
                 output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
+                output[op + 1] = alphabet[(v >> 12) & 0x3f];
+                output[op + 2] = alphabet[(v >> 6) & 0x3f];
+                output[op + 3] = alphabet[v & 0x3f];
                 p += 3;
                 op += 4;
                 if (--count == 0) {
@@ -682,7 +653,7 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                 // remaining in input; there should be at most two bytes
                 // total.
 
-                if (p-tailLen == len-1) {
+                if (p - tailLen == len - 1) {
                     int t = 0;
                     v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                     tailLen -= t;
@@ -696,10 +667,10 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                         if (do_cr) output[op++] = '\r';
                         output[op++] = '\n';
                     }
-                } else if (p-tailLen == len-2) {
+                } else if (p - tailLen == len - 2) {
                     int t = 0;
                     v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                     tailLen -= t;
                     output[op++] = alphabet[(v >> 12) & 0x3f];
                     output[op++] = alphabet[(v >> 6) & 0x3f];
@@ -716,17 +687,18 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
                     output[op++] = '\n';
                 }
 
-                assert tailLen == 0;
-                assert p == len;
+                if (BuildConfig.DEBUG && (tailLen != 0 || p != len)) {
+                    throw new AssertionError();
+                }
             } else {
                 // Save the leftovers in tail to be consumed on the next
                 // call to encodeInternal.
 
-                if (p == len-1) {
+                if (p == len - 1) {
                     tail[tailLen++] = input[p];
-                } else if (p == len-2) {
+                } else if (p == len - 2) {
                     tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
+                    tail[tailLen++] = input[p + 1];
                 }
             }
 
@@ -737,5 +709,6 @@ public boolean process(byte[] input, int offset, int len, boolean finish) {
         }
     }
 
-    private Base64() { }   // don't instantiate
+    private Base64() {
+    }   // don't instantiate
 }
diff --git a/library/src/main/java/com/loopj/android/http/Base64DataException.java b/library/src/main/java/com/loopj/android/http/Base64DataException.java
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
old mode 100644
new mode 100755
index 61afb931..231d4036
--- a/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
+++ b/library/src/main/java/com/loopj/android/http/Base64OutputStream.java
@@ -43,6 +43,7 @@ public Base64OutputStream(OutputStream out, int flags, boolean encode) {
         }
     }
 
+    @Override
     public void write(int b) throws IOException {
         // To avoid invoking the encoder/decoder routines for single
         // bytes, we buffer up calls to write(int) in an internal
@@ -71,12 +72,14 @@ private void flushBuffer() throws IOException {
         }
     }
 
+    @Override
     public void write(byte[] b, int off, int len) throws IOException {
         if (len <= 0) return;
         flushBuffer();
         internalWrite(b, off, len, false);
     }
 
+    @Override
     public void close() throws IOException {
         IOException thrown = null;
         try {
diff --git a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
old mode 100644
new mode 100755
index 03f98345..bc5deabd
--- a/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BaseJsonHttpResponseHandler.java
@@ -29,6 +29,7 @@
  * class, response will be then handled to implementation of abstract methods {@link #onSuccess(int,
  * org.apache.http.Header[], String, Object)} or {@link #onFailure(int, org.apache.http.Header[],
  * Throwable, String, Object)}, depending of response HTTP status line (result http code)
+ * @param <JSON_TYPE>
  */
 public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler {
     private static final String LOG_TAG = "BaseJsonHttpResponseHandler";
@@ -73,7 +74,7 @@ public BaseJsonHttpResponseHandler(String encoding) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final String responseString) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+	    Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -94,7 +95,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+	    };
+            if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
         } else {
             onSuccess(statusCode, headers, null, null);
         }
@@ -103,7 +108,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final String responseString, final Throwable throwable) {
         if (responseString != null) {
-            new Thread(new Runnable() {
+	    Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -124,7 +129,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+	    };
+            if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
         } else {
             onFailure(statusCode, headers, throwable, null, null);
         }
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index dc35b42d..b121835d
--- a/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/DataAsyncHttpResponseHandler.java
@@ -41,6 +41,8 @@ public DataAsyncHttpResponseHandler() {
 
     /**
      * Fired when the request progress, override to handle in your own code
+     *
+     * @param responseBody response body received so far
      */
     public void onProgressData(byte[] responseBody) {
     }
@@ -104,7 +106,7 @@ protected void handleMessage(Message message) {
                             sendProgressDataMessage(copyOfRange(tmp, 0, l));
                         }
                     } finally {
-                        instream.close();
+                        AsyncHttpClient.silentCloseInputStream(instream);
                     }
                     responseBody = buffer.toByteArray();
                 } catch (OutOfMemoryError e) {
diff --git a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
old mode 100644
new mode 100755
index 6223890e..be48f62b
--- a/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -14,7 +14,7 @@
 
 public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
 
-    private File mFile;
+    protected final File mFile;
     private static final String LOG_TAG = "FileAsyncHttpResponseHandler";
 
     /**
@@ -120,9 +120,9 @@ public final void onSuccess(int statusCode, Header[] headers, byte[] responseByt
                         sendProgressMessage(count, (int) contentLength);
                     }
                 } finally {
-                    instream.close();
+                    AsyncHttpClient.silentCloseInputStream(instream);
                     buffer.flush();
-                    buffer.close();
+                    AsyncHttpClient.silentCloseOutputStream(buffer);
                 }
             }
         }
diff --git a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
old mode 100644
new mode 100755
index 0b26fb1b..63648a15
--- a/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -113,7 +113,7 @@ public void onSuccess(int statusCode, Header[] headers, String responseString) {
     @Override
     public final void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBytes) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            new Thread(new Runnable() {
+	    Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -125,6 +125,8 @@ public void run() {
                                     onSuccess(statusCode, headers, (JSONObject) jsonResponse);
                                 } else if (jsonResponse instanceof JSONArray) {
                                     onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onFailure(statusCode, headers, (String) jsonResponse, new JSONException("Response cannot be parsed as JSON data"));
                                 } else {
                                     onFailure(statusCode, headers, new JSONException("Unexpected response type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
@@ -140,7 +142,11 @@ public void run() {
                         });
                     }
                 }
-            }).start();
+	    };
+	    if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
         } else {
             onSuccess(statusCode, headers, new JSONObject());
         }
@@ -149,7 +155,7 @@ public void run() {
     @Override
     public final void onFailure(final int statusCode, final Header[] headers, final byte[] responseBytes, final Throwable throwable) {
         if (responseBytes != null) {
-            new Thread(new Runnable() {
+	    Runnable parser = new Runnable() {
                 @Override
                 public void run() {
                     try {
@@ -179,7 +185,11 @@ public void run() {
 
                     }
                 }
-            }).start();
+	    };
+	    if (!getUseSynchronousMode())
+		new Thread(parser).start();
+	    else // In synchronous mode everything should be run on one thread
+		parser.run();
         } else {
             Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
             onFailure(statusCode, headers, throwable, (JSONObject) null);
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
old mode 100644
new mode 100755
index 49375061..6db13641
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -24,7 +24,7 @@
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
 
-import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -46,15 +46,16 @@
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
         new UnsupportedOperationException("Unsupported operation in this implementation.");
 
-    // Size of the byte-array buffer used to read from streams.
-    private static final int BUFFER_SIZE = 2048;
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
 
     // Reusable StringBuilder used by escape() method.
-    // Base64, at worst, will make a binary stream grow in size by approximately
-    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
-    // large 'n'.
-    private static final StringBuilder BUILDER =
-        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+    // Its size is just initial, if more space is needed, the system will
+    // automatically enlarge the buffer.
+    private static final StringBuilder BUILDER = new StringBuilder(128);
 
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
@@ -68,33 +69,28 @@
         new BasicHeader("Content-Type", "application/json");
     private static final Header HEADER_GZIP_ENCODING =
         new BasicHeader("Content-Encoding", "gzip");
-    private static final String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
-
-    // K/V objects to be uploaded.
-    private final Map<String, Object> kvParams =
-        new HashMap<String, Object>();
 
-    // Streams and their associated meta-data to be uploaded.
-    private final Map<String, RequestParams.StreamWrapper> streamParams =
-        new HashMap<String, RequestParams.StreamWrapper>();
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
-    public JsonStreamerEntity(boolean contentEncoding) {
-        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
-    }
+    private final ResponseHandlerInterface progressHandler;
 
-    public void addPart(String key, Object value) {
-        kvParams.put(key, value);
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
     }
 
-    public void addPart(String key, InputStream inputStream, String name, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
     }
 
     @Override
@@ -137,122 +133,176 @@ public InputStream getContent() throws IOException, UnsupportedOperationExceptio
     }
 
     @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        if (outstream == null) {
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
             throw new IllegalStateException("Output stream cannot be null.");
         }
 
         // Record the time when uploading started.
         long now = System.currentTimeMillis();
 
-        // Keys used by the HashMaps.
-        Set<String> keys;
-
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream upload;
-        if (null != contentEncoding) {
-            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
-        } else {
-            upload = new BufferedOutputStream(outstream);
-        }
+        OutputStream os = null != contentEncoding
+          ? new GZIPOutputStream(out, BUFFER_SIZE)
+          : out;
 
         // Always send a JSON object.
-        upload.write('{');
+        os.write('{');
 
-        // Send the K/V values.
-        keys = kvParams.keySet();
-        for (String key : keys) {
-            // Write the JSON object's key.
-            upload.write(escape(key));
-            upload.write(':');
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        boolean isFileWrapper;
 
+        // Go over all keys and handle each's value.
+        for (String key : keys) {
             // Evaluate the value (which cannot be null).
-            Object value = kvParams.get(key);
+            Object value = jsonParams.get(key);
+
+            // Bail out prematurely if value's null.
+            if (value == null) {
+                continue;
+            }
 
-            if (value instanceof Boolean) {
-                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            // Write the JSON object's key.
+            os.write(escape(key));
+            os.write(':');
+
+            // Check if this is a FileWrapper.
+            isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+            // If a file should be uploaded.
+            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                // All uploads are sent as an object containing the file's details.
+                os.write('{');
+
+                // Determine how to handle this entry.
+                if (isFileWrapper) {
+                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                } else {
+                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                }
+
+                // End the file's object and prepare for next one.
+                os.write('}');
+            } else if (value instanceof Boolean) {
+                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                upload.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number)value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                upload.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number)value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                upload.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number)value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                upload.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number)value).intValue() + "").getBytes());
             } else {
-                upload.write(value.toString().getBytes());
+                os.write(value.toString().getBytes());
             }
 
-            upload.write(',');
-        }
-
-        // Buffer used for reading from input streams.
-        byte[] buffer = new byte[BUFFER_SIZE];
-
-        // Send the stream params.
-        keys = streamParams.keySet();
-        for (String key : keys) {
-            RequestParams.StreamWrapper entry = streamParams.get(key);
-
-            // Write the JSON object's key.
-            upload.write(escape(key));
-
-            // All uploads are sent as an object containing the file's details.
-            upload.write(':');
-            upload.write('{');
-
-            // Send the streams's name.
-            upload.write(STREAM_NAME);
-            upload.write(':');
-            upload.write(escape(entry.name));
-            upload.write(',');
-
-            // Send the streams's content type.
-            upload.write(STREAM_TYPE);
-            upload.write(':');
-            upload.write(escape(entry.contentType));
-            upload.write(',');
-
-            // Prepare the file content's key.
-            upload.write(STREAM_CONTENTS);
-            upload.write(':');
-            upload.write('"');
-
-            // Upload the file's contents in Base64.
-            Base64OutputStream outputStream =
-                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-            // Read from input stream until no more data's left to read.
-            int bytesRead;
-            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
-                outputStream.write(buffer, 0, bytesRead);
-            }
-
-            // Close the Base64 output stream.
-            outputStream.close();
-
-            // End the file's object and prepare for next one.
-            upload.write('"');
-            upload.write('}');
-            upload.write(',');
+            os.write(',');
         }
 
         // Include the elapsed time taken to upload everything.
         // This might be useful for somebody, but it serves us well since
         // there will almost always be a ',' as the last sent character.
-        upload.write(STREAM_ELAPSED);
-        upload.write(':');
+        os.write(STREAM_ELAPSED);
+        os.write(':');
         long elapsedTime = System.currentTimeMillis() - now;
-        upload.write((elapsedTime + "}").getBytes());
+        os.write((elapsedTime + "}").getBytes());
 
         Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
 
         // Flush the contents up the stream.
-        upload.flush();
-        upload.close();
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
     }
 
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
+      }
+
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
     // Changed a bit to suit our needs in this class.
     static byte[] escape(String string) {
@@ -310,11 +360,11 @@ public void writeTo(final OutputStream outstream) throws IOException {
         BUILDER.append('"');
 
         try {
-          return BUILDER.toString().getBytes();
+            return BUILDER.toString().getBytes();
         } finally {
-          // Empty the String buffer.
-          // This is 20-30% faster than instantiating a new object.
-          BUILDER.setLength(0);
+            // Empty the String buffer.
+            // This is 20-30% faster than instantiating a new object.
+            BUILDER.setLength(0);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
new file mode 100644
index 00000000..5ad3402b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -0,0 +1,141 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.ProtocolException;
+import org.apache.http.client.CircularRedirectException;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.utils.URIUtils;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.client.RedirectLocations;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+// taken from: https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception
+class MyRedirectHandler extends DefaultRedirectHandler {
+
+    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
+    private final boolean enableRedirects;
+
+    public MyRedirectHandler(final boolean allowRedirects) {
+        super();
+        this.enableRedirects = allowRedirects;
+    }
+
+    public boolean isRedirectRequested(
+            final HttpResponse response,
+            final HttpContext context) {
+        if (!enableRedirects) {
+            return false;
+        }
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        int statusCode = response.getStatusLine().getStatusCode();
+        switch (statusCode) {
+            case HttpStatus.SC_MOVED_TEMPORARILY:
+            case HttpStatus.SC_MOVED_PERMANENTLY:
+            case HttpStatus.SC_SEE_OTHER:
+            case HttpStatus.SC_TEMPORARY_REDIRECT:
+                return true;
+            default:
+                return false;
+        } //end of switch
+    }
+
+    public URI getLocationURI(
+            final HttpResponse response,
+            final HttpContext context) throws ProtocolException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        //get the location header to find out where to redirect to
+        Header locationHeader = response.getFirstHeader("location");
+        if (locationHeader == null) {
+            // got a redirect response, but no location header
+            throw new ProtocolException(
+                    "Received redirect response " + response.getStatusLine()
+                            + " but no location header"
+            );
+        }
+//HERE IS THE MODIFIED LINE OF CODE
+        String location = locationHeader.getValue().replaceAll(" ", "%20");
+
+        URI uri;
+        try {
+            uri = new URI(location);
+        } catch (URISyntaxException ex) {
+            throw new ProtocolException("Invalid redirect URI: " + location, ex);
+        }
+
+        HttpParams params = response.getParams();
+        // rfc2616 demands the location value be a complete URI
+        // Location       = "Location" ":" absoluteURI
+        if (!uri.isAbsolute()) {
+            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
+                throw new ProtocolException("Relative redirect location '"
+                        + uri + "' not allowed");
+            }
+            // Adjust location URI
+            HttpHost target = (HttpHost) context.getAttribute(
+                    ExecutionContext.HTTP_TARGET_HOST);
+            if (target == null) {
+                throw new IllegalStateException("Target host not available " +
+                        "in the HTTP context");
+            }
+
+            HttpRequest request = (HttpRequest) context.getAttribute(
+                    ExecutionContext.HTTP_REQUEST);
+
+            try {
+                URI requestURI = new URI(request.getRequestLine().getUri());
+                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
+                uri = URIUtils.resolve(absoluteRequestURI, uri);
+            } catch (URISyntaxException ex) {
+                throw new ProtocolException(ex.getMessage(), ex);
+            }
+        }
+
+        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
+
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
+                    REDIRECT_LOCATIONS);
+
+            if (redirectLocations == null) {
+                redirectLocations = new RedirectLocations();
+                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
+            }
+
+            URI redirectURI;
+            if (uri.getFragment() != null) {
+                try {
+                    HttpHost target = new HttpHost(
+                            uri.getHost(),
+                            uri.getPort(),
+                            uri.getScheme());
+                    redirectURI = URIUtils.rewriteURI(uri, target, true);
+                } catch (URISyntaxException ex) {
+                    throw new ProtocolException(ex.getMessage(), ex);
+                }
+            } else {
+                redirectURI = uri;
+            }
+
+            if (redirectLocations.contains(redirectURI)) {
+                throw new CircularRedirectException("Circular redirect to '" +
+                        redirectURI + "'");
+            } else {
+                redirectLocations.add(redirectURI);
+            }
+        }
+
+        return uri;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
old mode 100644
new mode 100755
index 4ea14152..4c4df9ce
--- a/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/main/java/com/loopj/android/http/MySSLSocketFactory.java
@@ -1,10 +1,22 @@
 package com.loopj.android.http;
 
+import org.apache.http.HttpVersion;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
+
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
@@ -14,24 +26,11 @@
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
- 
+
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
- 
-import org.apache.http.HttpVersion;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.http.protocol.HTTP;
 
 /**
  * This file is introduced to fix HTTPS Post bug on API &lt; ICS see
@@ -43,92 +42,90 @@
 
     /**
      * Creates a new SSL Socket Factory with the given KeyStore.
-     * 
+     *
      * @param truststore A KeyStore to create the SSL Socket Factory in context of
-     * @throws NoSuchAlgorithmException
-     * @throws KeyManagementException
-     * @throws KeyStoreException
-     * @throws UnrecoverableKeyException
      */
     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);
- 
+
         X509TrustManager tm = new X509TrustManager() {
             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }
- 
+
             public X509Certificate[] getAcceptedIssuers() {
                 return null;
             }
         };
- 
-        sslContext.init(null, new TrustManager[] { tm }, null);
+
+        sslContext.init(null, new TrustManager[]{tm}, null);
     }
-    
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }
- 
+
     @Override
     public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
-    }	
-    
+    }
+
     /**
      * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
      */
     public void fixHttpsURLConnection() {
-    	HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
+        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
     }
-    
+
     /**
      * Gets a KeyStore containing the Certificate
-     * 
+     *
      * @param cert InputStream of the Certificate
      * @return KeyStore
      */
-	public static KeyStore getKeystoreOfCA(InputStream cert) {
-		
-		// Load CAs from an InputStream
-		InputStream caInput = null;
-		Certificate ca = null;
-		try {
-			CertificateFactory cf = CertificateFactory.getInstance("X.509");
-			caInput = new BufferedInputStream(cert);
-			ca = (Certificate) cf.generateCertificate(caInput);
-		} catch (CertificateException e1) {
-			e1.printStackTrace();
-		} finally {
-			try {
-				caInput.close();
-			} catch (IOException e) {
-				e.printStackTrace();
-			}
-		}
- 
-		// Create a KeyStore containing our trusted CAs
-		String keyStoreType = KeyStore.getDefaultType();
-		KeyStore keyStore = null;
-		try {
-			keyStore = KeyStore.getInstance(keyStoreType);
-			keyStore.load(null, null);
-			keyStore.setCertificateEntry("ca",
-					(java.security.cert.Certificate) ca);
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		return keyStore;
-	}
-	
-	/**
-	 * Gets a Default KeyStore
-	 * 
-	 * @return KeyStore
-	 */
-	public static KeyStore getKeystore() {
+    public static KeyStore getKeystoreOfCA(InputStream cert) {
+
+        // Load CAs from an InputStream
+        InputStream caInput = null;
+        Certificate ca = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            caInput = new BufferedInputStream(cert);
+            ca = cf.generateCertificate(caInput);
+        } catch (CertificateException e1) {
+            e1.printStackTrace();
+        } finally {
+            try {
+                if (caInput != null) {
+                    caInput.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Create a KeyStore containing our trusted CAs
+        String keyStoreType = KeyStore.getDefaultType();
+        KeyStore keyStore = null;
+        try {
+            keyStore = KeyStore.getInstance(keyStoreType);
+            keyStore.load(null, null);
+            keyStore.setCertificateEntry("ca", ca);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return keyStore;
+    }
+
+    /**
+     * Gets a Default KeyStore
+     *
+     * @return KeyStore
+     */
+    public static KeyStore getKeystore() {
         KeyStore trustStore = null;
         try {
             trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -138,12 +135,12 @@ public static KeyStore getKeystore() {
         }
         return trustStore;
     }
- 
-	/**
-	 * Returns a SSlSocketFactory which trusts all certificates
-	 * 
-	 * @return
-	 */
+
+    /**
+     * Returns a SSlSocketFactory which trusts all certificates
+     *
+     * @return SSLSocketFactory
+     */
     public static SSLSocketFactory getFixedSocketFactory() {
         SSLSocketFactory socketFactory;
         try {
@@ -155,31 +152,31 @@ public static SSLSocketFactory getFixedSocketFactory() {
         }
         return socketFactory;
     }
-    
+
     /**
      * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
-     * 
-     * @param keyStore
-     * @return
+     *
+     * @param keyStore custom provided KeyStore instance
+     * @return DefaultHttpClient
      */
-	public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
-		
-	    try {
-		    SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
-		    SchemeRegistry registry = new SchemeRegistry();
-		    registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-		    registry.register(new Scheme("https", sf, 443));
- 
-	        HttpParams params = new BasicHttpParams();
-	        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
-	        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
- 
-	        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
- 
-	        return new DefaultHttpClient(ccm, params);
-	    } catch (Exception e) {
-	        return new DefaultHttpClient();
-	    }
-	}
+    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {
+
+        try {
+            SSLSocketFactory sf = new MySSLSocketFactory(keyStore);
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+            registry.register(new Scheme("https", sf, 443));
+
+            HttpParams params = new BasicHttpParams();
+            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
+
+            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
+
+            return new DefaultHttpClient(ccm, params);
+        } catch (Exception e) {
+            return new DefaultHttpClient();
+        }
+    }
 
 }
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
old mode 100644
new mode 100755
index ee87bd23..2e0fdb8d
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -48,6 +48,7 @@
     private static final String COOKIE_PREFS = "CookiePrefsFile";
     private static final String COOKIE_NAME_STORE = "names";
     private static final String COOKIE_NAME_PREFIX = "cookie_";
+    private boolean omitNonPersistentCookies = false;
 
     private final ConcurrentHashMap<String, Cookie> cookies;
     private final SharedPreferences cookiePrefs;
@@ -59,7 +60,7 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
+        cookies = new ConcurrentHashMap();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -82,6 +83,8 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
+        if (omitNonPersistentCookies && !cookie.isPersistent())
+            return;
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
@@ -143,7 +146,30 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
+        return new ArrayList(cookies.values());
+    }
+
+    /**
+     * Will make PersistentCookieStore instance ignore Cookies, which are non-persistent by
+     * signature (`Cookie.isPersistent`)
+     *
+     * @param omitNonPersistentCookies true if non-persistent cookies should be omited
+     */
+    public void setOmitNonPersistentCookies(boolean omitNonPersistentCookies) {
+        this.omitNonPersistentCookies = omitNonPersistentCookies;
+    }
+
+    /**
+     * Non-standard helper method, to delete cookie
+     *
+     * @param cookie cookie to be removed
+     */
+    public void deleteCookie(Cookie cookie) {
+        String name = cookie.getName();
+        cookies.remove(name);
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        prefsWriter.commit();
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
new file mode 100755
index 00000000..6f3756cf
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/PreemtiveAuthorizationHttpRequestInterceptor.java
@@ -0,0 +1,36 @@
+package com.loopj.android.http;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.AuthState;
+import org.apache.http.auth.Credentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+public class PreemtiveAuthorizationHttpRequestInterceptor implements HttpRequestInterceptor {
+
+    public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
+        AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
+        CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
+                ClientContext.CREDS_PROVIDER);
+        HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+
+        if (authState.getAuthScheme() == null) {
+            AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());
+            Credentials creds = credsProvider.getCredentials(authScope);
+            if (creds != null) {
+                authState.setAuthScheme(new BasicScheme());
+                authState.setCredentials(creds);
+            }
+        }
+    }
+
+}
diff --git a/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
new file mode 100755
index 00000000..f6348da4
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/RangeFileAsyncHttpResponseHandler.java
@@ -0,0 +1,95 @@
+package com.loopj.android.http;
+
+import android.util.Log;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public abstract class RangeFileAsyncHttpResponseHandler extends FileAsyncHttpResponseHandler {
+	private static final String LOG_TAG = "RangeFileAsyncHttpResponseHandler";
+
+	private long current = 0;
+	private boolean append = false;
+
+	/**
+	 * Obtains new RangeFileAsyncHttpResponseHandler and stores response in passed file
+	 * 
+	 * @param file File to store response within, must not be null
+	 */
+	public RangeFileAsyncHttpResponseHandler(File file) {
+		super(file);
+	}
+
+	@Override
+	public void sendResponseMessage(HttpResponse response) throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			StatusLine status = response.getStatusLine();
+			if (status.getStatusCode() == HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE){
+				//already finished
+				if (!Thread.currentThread().isInterrupted())
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), null);
+			}
+			else if (status.getStatusCode() >= 300) {
+				if (!Thread.currentThread().isInterrupted())
+					sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+			}
+			else {
+				if (!Thread.currentThread().isInterrupted()) {
+					Header header = response.getFirstHeader("Content-Range");
+					if (header == null) {
+						append = false;
+						current = 0;
+					}
+					else
+						Log.v(LOG_TAG, "Content-Rnage: " + header.getValue());
+					sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), getResponseData(response.getEntity()));
+				}
+			}
+		}
+	}
+
+	@Override
+	protected byte[] getResponseData(HttpEntity entity) throws IOException {
+		if (entity != null) {
+			InputStream instream = entity.getContent();
+			long contentLength = entity.getContentLength() + current;
+			FileOutputStream buffer = new FileOutputStream(getTargetFile(), append);
+			if (instream != null) {
+				try {
+					byte[] tmp = new byte[BUFFER_SIZE];
+					int l;
+					while (current < contentLength && (l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted())
+					{
+						current += l;
+						buffer.write(tmp, 0, l);
+						sendProgressMessage((int)current, (int)contentLength);
+					}
+				} finally {
+					instream.close();
+					buffer.flush();
+					buffer.close();
+				}
+			}
+		}
+		return null;
+	}
+
+	public void updateRequestHeaders(HttpUriRequest uriRequest) {
+		if (mFile.exists() && mFile.canWrite())
+			current = mFile.length();
+		if (current > 0) {
+			append = true;
+			uriRequest.setHeader("Range", "bytes=" + current + "-");
+		}
+	}
+}
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
old mode 100644
new mode 100755
index 1d56fb42..a35aa634
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -5,7 +5,7 @@
 /**
  * A Handle to an AsyncRequest which can be used to cancel a running request.
  */
-class RequestHandle {
+public class RequestHandle {
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
old mode 100644
new mode 100755
index 42ba1706..a6fdab8d
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -27,7 +27,6 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -65,7 +64,7 @@
  * params.put("like", set); // url params: "like=music&amp;like=art"
  *
  * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
- * list.add("Java");
+ * list.add("Java");<>
  * list.add("C");
  * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
  *
@@ -90,13 +89,17 @@
  */
 public class RequestParams {
 
+    public final static String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
-    protected ConcurrentHashMap<String, String> urlParams;
-    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
-    protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, Object> urlParamsWithObjects;
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -126,7 +129,6 @@ public RequestParams() {
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
-        init();
         if (source != null) {
             for (Map.Entry<String, String> entry : source.entrySet()) {
                 put(entry.getKey(), entry.getValue());
@@ -156,7 +158,6 @@ public RequestParams(final String key, final String value) {
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-        init();
         int len = keysAndValues.length;
         if (len % 2 != 0)
             throw new IllegalArgumentException("Supplied arguments must be even");
@@ -237,8 +238,21 @@ public void put(String key, InputStream stream, String name) {
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
         if (key != null && stream != null) {
-            streamParams.put(key, new StreamWrapper(stream, name, contentType));
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
         }
     }
 
@@ -254,6 +268,30 @@ public void put(String key, Object value) {
         }
     }
 
+    /**
+     * Adds a int value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value int for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
+    /**
+     * Adds a long value to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the value long for the new param.
+     */
+    public void put(String key, long value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds string value to param which can have more than one value.
      *
@@ -269,9 +307,9 @@ public void add(String key, String value) {
                 this.put(key, params);
             }
             if (params instanceof List) {
-                ((List<Object>) params).add(value);
+                ((List) params).add(value);
             } else if (params instanceof Set) {
-                ((Set<Object>) params).add(value);
+                ((Set) params).add(value);
             }
         }
     }
@@ -340,7 +378,17 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Returns an HttpEntity containing all request parameters
+     * Set global flag which determines whether to automatically close input
+     * streams on successful upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
      * @return HttpEntity resulting HttpEntity to be included along with {@link
@@ -349,7 +397,7 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
         if (useJsonStreamer) {
-            return createJsonStreamerEntity();
+            return createJsonStreamerEntity(progressHandler);
         } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
@@ -357,8 +405,9 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
         }
     }
 
-    private HttpEntity createJsonStreamerEntity() throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -372,11 +421,7 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
 
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(),
-                    new FileInputStream(fileWrapper.file),
-                    fileWrapper.file.getName(),
-                    fileWrapper.contentType);
+            entity.addPart(entry.getKey(), entry.getValue());
         }
 
         // Add stream params
@@ -384,9 +429,11 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
+                    StreamWrapper.newInstance(
                         stream.inputStream,
                         stream.name,
-                        stream.contentType);
+                        stream.contentType,
+                        stream.autoClose));
             }
         }
 
@@ -435,15 +482,8 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
         return entity;
     }
 
-    private void init() {
-        urlParams = new ConcurrentHashMap<String, String>();
-        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-        fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
-    }
-
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> lparams = new LinkedList();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -455,36 +495,40 @@ private void init() {
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> params = new LinkedList();
         if (value instanceof Map) {
-            Map<String, Object> map = (Map<String, Object>) value;
-            List<String> list = new ArrayList<String>(map.keySet());
+            Map map = (Map) value;
+            List list = new ArrayList<Object>(map.keySet());
             // Ensure consistent ordering in query string
             Collections.sort(list);
-            for (String nestedKey : list) {
-                Object nestedValue = map.get(nestedKey);
-                if (nestedValue != null) {
-                    params.addAll(getParamsList(key == null ? nestedKey : String.format("%s[%s]", key, nestedKey),
-                            nestedValue));
+            for (Object nestedKey : list) {
+                if (nestedKey instanceof String) {
+                    Object nestedValue = map.get(nestedKey);
+                    if (nestedValue != null) {
+                        params.addAll(getParamsList(key == null ? (String) nestedKey : String.format("%s[%s]", key, nestedKey),
+                                nestedValue));
+                    }
                 }
             }
         } else if (value instanceof List) {
-            List<Object> list = (List<Object>) value;
-            for (Object nestedValue : list) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            List list = (List) value;
+            int listSize = list.size();
+            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
             }
         } else if (value instanceof Object[]) {
             Object[] array = (Object[]) value;
-            for (Object nestedValue : array) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            int arrayLength = array.length;
+            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
             }
         } else if (value instanceof Set) {
-            Set<Object> set = (Set<Object>) value;
+            Set set = (Set) value;
             for (Object nestedValue : set) {
                 params.addAll(getParamsList(key, nestedValue));
             }
-        } else if (value instanceof String) {
-            params.add(new BasicNameValuePair(key, (String) value));
+        } else {
+            params.add(new BasicNameValuePair(key, value.toString()));
         }
         return params;
     }
@@ -494,8 +538,8 @@ protected String getParamString() {
     }
 
     public static class FileWrapper {
-        public File file;
-        public String contentType;
+        public final File file;
+        public final String contentType;
 
         public FileWrapper(File file, String contentType) {
             this.file = file;
@@ -504,14 +548,24 @@ public FileWrapper(File file, String contentType) {
     }
 
     public static class StreamWrapper {
-        public InputStream inputStream;
-        public String name;
-        public String contentType;
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
 
-        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
             this.inputStream = inputStream;
             this.name = name;
             this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                inputStream,
+                name,
+                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
old mode 100644
new mode 100755
index 4641a868..fe5eacc0
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -104,7 +104,7 @@
     void setUseSynchronousMode(boolean useSynchronousMode);
 
     /**
-     * Can set, whether the handler should be asynchronous or synchronous
+     * Returns whether the handler is asynchronous or synchronous
      *
      * @return boolean if the ResponseHandler is running in synchronous mode
      */
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
old mode 100644
new mode 100755
index d8dffa1d..a6968667
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SerializableCookie.java b/library/src/main/java/com/loopj/android/http/SerializableCookie.java
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
old mode 100644
new mode 100755
index 7d134599..bffdf740
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -46,25 +46,26 @@
 
     private static final String LOG_TAG = "SimpleMultipartEntity";
 
-    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
-    private static final byte[] CR_LF = ("\r\n").getBytes();
-    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
-            .getBytes();
+    private static final String STR_CR_LF = "\r\n";
+    private static final byte[] CR_LF = STR_CR_LF.getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY =
+        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
-    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+    private final static char[] MULTIPART_CHARS =
+        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary;
-    private byte[] boundaryLine;
-    private byte[] boundaryEnd;
-    private boolean isRepeatable = false;
+    private final String boundary;
+    private final byte[] boundaryLine;
+    private final byte[] boundaryEnd;
+    private boolean isRepeatable;
 
-    private List<FilePart> fileParts = new ArrayList<FilePart>();
+    private final List<FilePart> fileParts = new ArrayList();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
-    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+    private final ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    private ResponseHandlerInterface progressHandler;
+    private final ResponseHandlerInterface progressHandler;
 
     private int bytesWritten;
 
@@ -78,13 +79,13 @@ public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         }
 
         boundary = buf.toString();
-        boundaryLine = ("--" + boundary + "\r\n").getBytes();
-        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+        boundaryLine = ("--" + boundary + STR_CR_LF).getBytes();
+        boundaryEnd = ("--" + boundary + "--" + STR_CR_LF).getBytes();
 
         this.progressHandler = progressHandler;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
+    public void addPart(String key, String value, String contentType) {
         try {
             out.write(boundaryLine);
             out.write(createContentDisposition(key));
@@ -98,7 +99,7 @@ public void addPart(final String key, final String value, final String contentTy
         }
     }
 
-    public void addPart(final String key, final String value) {
+    public void addPart(String key, String value) {
         addPart(key, value, "text/plain; charset=UTF-8");
     }
 
@@ -106,18 +107,13 @@ public void addPart(String key, File file) {
         addPart(key, file, null);
     }
 
-    public void addPart(final String key, File file, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        fileParts.add(new FilePart(key, file, type));
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
     }
 
     public void addPart(String key, String streamName, InputStream inputStream, String type)
             throws IOException {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
+
         out.write(boundaryLine);
 
         // Headers
@@ -135,27 +131,27 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
 
         out.write(CR_LF);
         out.flush();
-        try {
-            inputStream.close();
-        } catch (final IOException e) {
-            // Not important, just log it
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
+
+        AsyncHttpClient.silentCloseOutputStream(out);
+    }
+
+    private String normalizeContentType(String type) {
+       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + type + "\r\n";
+        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
-    private byte[] createContentDisposition(final String key) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
+            .getBytes();
     }
 
-    private byte[] createContentDisposition(final String key, final String fileName) {
-        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
-                .getBytes();
+    private byte[] createContentDisposition(String key, String fileName) {
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
+            .getBytes();
     }
 
     private void updateProgress(int count) {
@@ -200,20 +196,15 @@ public void writeTo(OutputStream out) throws IOException {
 
             FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
-            int l;
-            while ((l = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-                updateProgress(l);
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
             }
             out.write(CR_LF);
             updateProgress(CR_LF.length);
             out.flush();
-            try {
-                inputStream.close();
-            } catch (final IOException e) {
-                // Not important, just log it
-                Log.w(LOG_TAG, "Cannot close input stream", e);
-            }
+            AsyncHttpClient.silentCloseInputStream(inputStream);
         }
     }
 
diff --git a/library/src/main/java/com/loopj/android/http/SyncHttpClient.java b/library/src/main/java/com/loopj/android/http/SyncHttpClient.java
old mode 100644
new mode 100755
diff --git a/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/TextHttpResponseHandler.java
old mode 100644
new mode 100755
diff --git a/maven_push.gradle b/maven_push.gradle
old mode 100644
new mode 100755
index 7131da65..6fc6fb30
--- a/maven_push.gradle
+++ b/maven_push.gradle
@@ -15,7 +15,7 @@ if (isReleaseBuild()) {
     println 'DEBUG BUILD'
     sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
 }
-if(isReleaseBuild()){
+
 if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
     if (System.console())
         ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
@@ -98,4 +98,3 @@ afterEvaluate { project ->
         archives androidJavadocsJar
     }
 }
-}
diff --git a/releases/android-async-http-1.2.0.jar b/releases/android-async-http-1.2.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.2.1.jar b/releases/android-async-http-1.2.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.0.jar b/releases/android-async-http-1.3.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.1.jar b/releases/android-async-http-1.3.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.3.2.jar b/releases/android-async-http-1.3.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.0.jar b/releases/android-async-http-1.4.0.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.1.jar b/releases/android-async-http-1.4.1.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.2.jar b/releases/android-async-http-1.4.2.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.3.jar b/releases/android-async-http-1.4.3.jar
old mode 100644
new mode 100755
diff --git a/releases/android-async-http-1.4.4.jar b/releases/android-async-http-1.4.4.jar
old mode 100644
new mode 100755
diff --git a/sample/.gitignore b/sample/.gitignore
old mode 100644
new mode 100755
diff --git a/sample/build.gradle b/sample/build.gradle
old mode 100644
new mode 100755
index af693013..b4fdad60
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.7.+'
+        classpath 'com.android.tools.build:gradle:0.+'
     }
 }
 apply plugin: 'android'
@@ -17,13 +17,18 @@ repositories {
 
 android {
     compileSdkVersion 19
-    buildToolsVersion '19.0.1'
+    buildToolsVersion '19.0.3'
 
     defaultConfig {
         minSdkVersion 3
         targetSdkVersion 19
     }
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
     lintOptions {
         abortOnError false
     }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
old mode 100644
new mode 100755
index a7d337e9..b1cac259
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http.sample"
-    android:versionCode="1"
-    android:versionName="1.0">
+          package="com.loopj.android.http.sample"
+          android:versionCode="1"
+          android:versionName="1.0">
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
@@ -12,18 +12,23 @@
         android:theme="@style/AppTheme">
         <activity android:name=".WaypointsActivity">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name=".GetSample" />
-        <activity android:name=".PostSample" />
-        <activity android:name=".DeleteSample" />
-        <activity android:name=".PutSample" />
-        <activity android:name=".JsonSample" />
-        <activity android:name=".FileSample" />
-        <activity android:name=".BinarySample" />
-        <activity android:name=".ThreadingTimeoutSample" />
+        <activity android:name=".GetSample"/>
+        <activity android:name=".PostSample"/>
+        <activity android:name=".DeleteSample"/>
+        <activity android:name=".PutSample"/>
+        <activity android:name=".JsonSample"/>
+        <activity android:name=".FileSample"/>
+        <activity android:name=".BinarySample"/>
+        <activity android:name=".GzipSample"/>
+        <activity android:name=".Redirect302Sample"/>
+        <activity android:name=".ThreadingTimeoutSample"/>
+        <activity android:name=".CancelAllRequestsSample"/>
+        <activity android:name=".CancelRequestHandleSample"/>
+        <activity android:name=".SynchronousClientSample"/>
     </application>
 
 </manifest>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
old mode 100644
new mode 100755
index e134a1b6..a01942fd
--- a/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/BinarySample.java
@@ -1,8 +1,9 @@
 package com.loopj.android.http.sample;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BinaryHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,27 +12,27 @@
     private static final String LOG_TAG = "BinarySample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_binary_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/gzip";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BinaryHttpResponseHandler() {
             @Override
             public void onStart() {
@@ -63,7 +64,7 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
new file mode 100644
index 00000000..fa8df74b
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelAllRequestsSample.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http.sample;
+
+public class CancelAllRequestsSample extends ThreadingTimeoutSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_all;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        getAsyncHttpClient().cancelAllRequests(true);
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
new file mode 100644
index 00000000..fd66c3a0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/CancelRequestHandleSample.java
@@ -0,0 +1,30 @@
+package com.loopj.android.http.sample;
+
+import android.util.Log;
+
+import com.loopj.android.http.RequestHandle;
+
+public class CancelRequestHandleSample extends ThreadingTimeoutSample {
+
+    private static final String LOG_TAG = "ThreadingTimeoutSample";
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_cancel_handle;
+    }
+
+    @Override
+    public void onCancelButtonPressed() {
+        Log.d(LOG_TAG, String.format("Number of handles found: %d", getRequestHandles().size()));
+        int counter = 0;
+        for (RequestHandle handle : getRequestHandles()) {
+            if (!handle.isCancelled() && !handle.isFinished()) {
+                Log.d(LOG_TAG, String.format("Cancelling handle %d", counter));
+                Log.d(LOG_TAG, String.format("Handle %d cancel", counter) + (handle.cancel(true) ? " succeeded" : " failed"));
+            } else {
+                Log.d(LOG_TAG, String.format("Handle %d already non-cancellable", counter));
+            }
+            counter++;
+        }
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
old mode 100644
new mode 100755
index 42104356..bea35ca4
--- a/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/DeleteSample.java
@@ -2,6 +2,8 @@
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,33 +12,33 @@
     private static final String LOG_TAG = "DeleteSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.delete(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.delete(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_delete_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         // HttpDelete is not HttpEntityEnclosingRequestBase, thus cannot contain body
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/delete";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
old mode 100644
new mode 100755
index 68c3620b..c554cc4d
--- a/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/FileSample.java
@@ -3,8 +3,9 @@
 import android.util.Log;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.FileAsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.FileUtil;
 
 import org.apache.http.Header;
@@ -16,27 +17,27 @@
     private static final String LOG_TAG = "FileSample";
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_file_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/robots.txt";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new FileAsyncHttpResponseHandler(this) {
             @Override
             public void onStart() {
@@ -76,7 +77,7 @@ private void debugFile(File file) {
     }
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
old mode 100644
new mode 100755
index 96ab3e64..5464cc6c
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,7 +1,11 @@
 package com.loopj.android.http.sample;
 
+import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +14,32 @@
     private static final String LOG_TAG = "GetSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_get_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "https://httpbin.org/get";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -59,6 +63,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
                     debugResponse(LOG_TAG, new String(errorResponse));
                 }
             }
+
+            @Override
+            public void onRetry(int retryNo) {
+                Toast.makeText(GetSample.this,
+                        String.format("Request is retried, retry no. %d", retryNo),
+                        Toast.LENGTH_SHORT)
+                        .show();
+            }
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
new file mode 100644
index 00000000..ba242939
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http.sample;
+
+public class GzipSample extends JsonSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_gzip_sample;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
old mode 100644
new mode 100755
index ae701c91..cde4e06f
--- a/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/JsonSample.java
@@ -3,8 +3,9 @@
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.BaseJsonHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 import com.loopj.android.http.sample.util.SampleJSON;
 
 import org.apache.http.Header;
@@ -15,32 +16,32 @@
     private static final String LOG_TAG = "JsonSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_json_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return false;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/headers";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new BaseJsonHttpResponseHandler<SampleJSON>() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
old mode 100644
new mode 100755
index 202fd480..2e183d9b
--- a/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PostSample.java
@@ -2,6 +2,8 @@
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +12,32 @@
     private static final String LOG_TAG = "PostSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.post(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.post(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_post_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/post";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
@@ -51,7 +53,7 @@ public void onSuccess(int statusCode, Header[] headers, byte[] response) {
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers,	byte[] errorResponse, Throwable e) {
+            public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) {
                 debugHeaders(LOG_TAG, headers);
                 debugStatusCode(LOG_TAG, statusCode);
                 debugThrowable(LOG_TAG, e);
diff --git a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
old mode 100644
new mode 100755
index f9e6b5dc..d32b5767
--- a/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/PutSample.java
@@ -2,6 +2,8 @@
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -10,32 +12,32 @@
     private static final String LOG_TAG = "PutSample";
 
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.put(this, URL, headers, entity, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.put(this, URL, headers, entity, null, responseHandler);
     }
 
     @Override
-    protected int getSampleTitle() {
+    public int getSampleTitle() {
         return R.string.title_put_sample;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return true;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/put";
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             @Override
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
new file mode 100644
index 00000000..1a10a1a3
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -0,0 +1,79 @@
+package com.loopj.android.http.sample;
+
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class Redirect302Sample extends GetSample {
+
+    private boolean enableRedirects = true;
+    private boolean enableRelativeRedirects = true;
+    private boolean enableCircularRedirects = true;
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, 0, Menu.NONE, "Enable redirects").setCheckable(true);
+        menu.add(Menu.NONE, 1, Menu.NONE, "Enable relative redirects").setCheckable(true);
+        menu.add(Menu.NONE, 2, Menu.NONE, "Enable circular redirects").setCheckable(true);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem menuItemEnableRedirects = menu.findItem(0);
+        if (menuItemEnableRedirects != null)
+            menuItemEnableRedirects.setChecked(enableRedirects);
+        MenuItem menuItemEnableRelativeRedirects = menu.findItem(1);
+        if (menuItemEnableRelativeRedirects != null)
+            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
+        MenuItem menuItemEnableCircularRedirects = menu.findItem(2);
+        if (menuItemEnableCircularRedirects != null)
+            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
+        return super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.isCheckable()) {
+            item.setChecked(!item.isChecked());
+            if (item.getItemId() == 0) {
+                enableRedirects = item.isChecked();
+            } else if (item.getItemId() == 1) {
+                enableRelativeRedirects = item.isChecked();
+            } else if (item.getItemId() == 2) {
+                enableCircularRedirects = item.isChecked();
+            }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/redirect/6";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_redirect_302;
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient() {
+        AsyncHttpClient ahc = super.getAsyncHttpClient();
+        HttpClient client = ahc.getHttpClient();
+        if (client instanceof DefaultHttpClient) {
+            Toast.makeText(this,
+                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
+                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
+                    Toast.LENGTH_SHORT
+            ).show();
+            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
+        }
+        return ahc;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
new file mode 100644
index 00000000..751823e9
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleInterface.java
@@ -0,0 +1,43 @@
+package com.loopj.android.http.sample;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+import java.util.List;
+
+public interface SampleInterface {
+
+    List<RequestHandle> getRequestHandles();
+
+    void addRequestHandle(RequestHandle handle);
+
+    void onRunButtonPressed();
+
+    void onCancelButtonPressed();
+
+    Header[] getRequestHeaders();
+
+    HttpEntity getRequestEntity();
+
+    AsyncHttpClient getAsyncHttpClient();
+
+    void setAsyncHttpClient(AsyncHttpClient client);
+
+    ResponseHandlerInterface getResponseHandler();
+
+    String getDefaultURL();
+
+    boolean isRequestHeadersAllowed();
+
+    boolean isRequestBodyAllowed();
+
+    int getSampleTitle();
+
+    boolean isCancelButtonAllowed();
+
+    RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler);
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
old mode 100644
new mode 100755
index 182425d2..3b26362c
--- a/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/SampleParentActivity.java
@@ -12,7 +12,7 @@
 import android.widget.TextView;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -23,14 +23,16 @@
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 
-public abstract class SampleParentActivity extends Activity {
+public abstract class SampleParentActivity extends Activity implements SampleInterface {
 
     private AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
     private EditText urlEditText, headersEditText, bodyEditText;
     private LinearLayout responseLayout;
+    private final List<RequestHandle> requestHandles = new LinkedList<>();
 
     private static final int LIGHTGREEN = Color.parseColor("#00FF66");
     private static final int LIGHTRED = Color.parseColor("#FF3300");
@@ -58,32 +60,55 @@ protected void onCreate(Bundle savedInstanceState) {
         headersLayout.setVisibility(isRequestHeadersAllowed() ? View.VISIBLE : View.GONE);
 
         runButton.setOnClickListener(onClickListener);
-        if (isCancelButtonAllowed() && cancelButton != null) {
-            cancelButton.setVisibility(View.VISIBLE);
-            cancelButton.setOnClickListener(onClickListener);
+        if (cancelButton != null) {
+            if (isCancelButtonAllowed()) {
+                cancelButton.setVisibility(View.VISIBLE);
+                cancelButton.setOnClickListener(onClickListener);
+            } else {
+                cancelButton.setEnabled(false);
+            }
         }
     }
 
-    private View.OnClickListener onClickListener = new View.OnClickListener() {
+    public List<RequestHandle> getRequestHandles() {
+        return requestHandles;
+    }
+
+    @Override
+    public void addRequestHandle(RequestHandle handle) {
+        if (null != handle) {
+            requestHandles.add(handle);
+        }
+    }
+
+    public void onRunButtonPressed() {
+        addRequestHandle(executeSample(getAsyncHttpClient(),
+                (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
+                getRequestHeaders(),
+                getRequestEntity(),
+                getResponseHandler()));
+    }
+
+    public void onCancelButtonPressed() {
+        asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+    }
+
+    protected View.OnClickListener onClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
             switch (v.getId()) {
                 case R.id.button_run:
-                    executeSample(getAsyncHttpClient(),
-                            (urlEditText == null || urlEditText.getText() == null) ? getDefaultURL() : urlEditText.getText().toString(),
-                            getRequestHeaders(),
-                            getRequestEntity(),
-                            getResponseHandler());
+                    onRunButtonPressed();
                     break;
                 case R.id.button_cancel:
-                    asyncHttpClient.cancelRequests(SampleParentActivity.this, true);
+                    onCancelButtonPressed();
                     break;
             }
         }
     };
 
-    protected Header[] getRequestHeaders() {
-        List<Header> headers = new ArrayList<Header>();
+    public Header[] getRequestHeaders() {
+        List<Header> headers = new ArrayList<>();
         String headersRaw = headersEditText.getText() == null ? null : headersEditText.getText().toString();
 
         if (headersRaw != null && headersRaw.length() > 3) {
@@ -102,7 +127,7 @@ public void onClick(View v) {
         return headers.toArray(new Header[headers.size()]);
     }
 
-    protected HttpEntity getRequestEntity() {
+    public HttpEntity getRequestEntity() {
         if (isRequestBodyAllowed() && bodyEditText.getText() != null) {
             try {
                 return new StringEntity(bodyEditText.getText().toString());
@@ -162,7 +187,7 @@ public static int getContrastColor(int color) {
         return y >= 128 ? Color.BLACK : Color.WHITE;
     }
 
-    private View getColoredView(int bgColor, String msg) {
+    protected View getColoredView(int bgColor, String msg) {
         TextView tv = new TextView(this);
         tv.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
         tv.setText(msg);
@@ -180,23 +205,16 @@ protected final void clearOutputs() {
         responseLayout.removeAllViews();
     }
 
-    protected boolean isCancelButtonAllowed() {
+    public boolean isCancelButtonAllowed() {
         return false;
     }
 
-    protected abstract int getSampleTitle();
-
-    protected abstract boolean isRequestBodyAllowed();
-
-    protected abstract boolean isRequestHeadersAllowed();
-
-    protected abstract String getDefaultURL();
-
-    protected abstract AsyncHttpResponseHandler getResponseHandler();
-
-    protected AsyncHttpClient getAsyncHttpClient() {
+    public AsyncHttpClient getAsyncHttpClient() {
         return this.asyncHttpClient;
     }
 
-    protected abstract void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler);
+    @Override
+    public void setAsyncHttpClient(AsyncHttpClient client) {
+        this.asyncHttpClient = client;
+    }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
new file mode 100644
index 00000000..d0756ad0
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/SynchronousClientSample.java
@@ -0,0 +1,108 @@
+package com.loopj.android.http.sample;
+
+import android.os.Bundle;
+import android.util.Log;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
+import com.loopj.android.http.SyncHttpClient;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+
+public class SynchronousClientSample extends GetSample {
+    private static final String LOG_TAG = "SyncSample";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setAsyncHttpClient(new SyncHttpClient());
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_synchronous;
+    }
+
+    @Override
+    public boolean isRequestBodyAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean isRequestHeadersAllowed() {
+        return true;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "https://httpbin.org/delay/6";
+    }
+
+    @Override
+    public RequestHandle executeSample(final AsyncHttpClient client, final String URL, final Header[] headers, HttpEntity entity, final ResponseHandlerInterface responseHandler) {
+        if (client instanceof SyncHttpClient) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Log.d(LOG_TAG, "Before Request");
+                    client.get(SynchronousClientSample.this, URL, headers, null, responseHandler);
+                    Log.d(LOG_TAG, "After Request");
+                }
+            }).start();
+        } else {
+            Log.e(LOG_TAG, "Error, not using SyncHttpClient");
+        }
+        /**
+         * SyncHttpClient does not return RequestHandle,
+         * it executes each request directly,
+         * therefore those requests are not in cancelable threads
+         * */
+        return null;
+    }
+
+    @Override
+    public ResponseHandlerInterface getResponseHandler() {
+        return new AsyncHttpResponseHandler() {
+
+            @Override
+            public void onStart() {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        clearOutputs();
+                    }
+                });
+            }
+
+            @Override
+            public void onSuccess(final int statusCode, final Header[] headers, final byte[] response) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugResponse(LOG_TAG, new String(response));
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(final int statusCode, final Header[] headers, final byte[] errorResponse, final Throwable e) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        debugHeaders(LOG_TAG, headers);
+                        debugStatusCode(LOG_TAG, statusCode);
+                        debugThrowable(LOG_TAG, e);
+                        if (errorResponse != null) {
+                            debugResponse(LOG_TAG, new String(errorResponse));
+                        }
+                    }
+                });
+            }
+        };
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
old mode 100644
new mode 100755
index 568537fe..059adeac
--- a/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/ThreadingTimeoutSample.java
@@ -4,6 +4,8 @@
 
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestHandle;
+import com.loopj.android.http.ResponseHandlerInterface;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -11,31 +13,31 @@
 public class ThreadingTimeoutSample extends SampleParentActivity {
 
     private static final String LOG_TAG = "ThreadingTimeoutSample";
-    private SparseArray<String> states = new SparseArray<String>();
+    private SparseArray<String> states = new SparseArray<>();
     private int counter = 0;
 
     @Override
-    protected int getSampleTitle() {
-        return R.string.app_name;
+    public int getSampleTitle() {
+        return R.string.title_threading_timeout;
     }
 
     @Override
-    protected boolean isRequestBodyAllowed() {
+    public boolean isRequestBodyAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isRequestHeadersAllowed() {
+    public boolean isRequestHeadersAllowed() {
         return false;
     }
 
     @Override
-    protected boolean isCancelButtonAllowed() {
+    public boolean isCancelButtonAllowed() {
         return true;
     }
 
     @Override
-    protected String getDefaultURL() {
+    public String getDefaultURL() {
         return "http://httpbin.org/delay/6";
     }
 
@@ -44,12 +46,12 @@ private synchronized void setStatus(int id, String status) {
         states.put(id, current == null ? status : current + "," + status);
         clearOutputs();
         for (int i = 0; i < states.size(); i++) {
-            debugResponse(LOG_TAG, states.keyAt(i) + ": " + states.get(states.keyAt(i)));
+            debugResponse(LOG_TAG, String.format("%d (from %d): %s", states.keyAt(i), getCounter(), states.get(states.keyAt(i))));
         }
     }
 
     @Override
-    protected AsyncHttpResponseHandler getResponseHandler() {
+    public ResponseHandlerInterface getResponseHandler() {
         return new AsyncHttpResponseHandler() {
 
             private int id = counter++;
@@ -81,8 +83,12 @@ public void onCancel() {
         };
     }
 
+    public int getCounter() {
+        return counter;
+    }
+
     @Override
-    protected void executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, AsyncHttpResponseHandler responseHandler) {
-        client.get(this, URL, headers, null, responseHandler);
+    public RequestHandle executeSample(AsyncHttpClient client, String URL, Header[] headers, HttpEntity entity, ResponseHandlerInterface responseHandler) {
+        return client.get(this, URL, headers, null, responseHandler);
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
old mode 100644
new mode 100755
index 857a0ffb..dad700c2
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -9,45 +9,46 @@
 
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY", "THREADING TIMEOUTS"};
+    private static final String[] samples = new String[]{
+            "GET",
+            "POST",
+            "DELETE",
+            "PUT",
+            "JSON",
+            "FILE",
+            "BINARY",
+            "GZIP",
+            "302 REDIRECT",
+            "THREADING TIMEOUTS",
+            "CANCEL ALL REQUESTS",
+            "CANCEL REQUEST HANDLE",
+            "SYNCHRONOUS CLIENT"
+    };
+    private static final Class[] targets = {
+            GetSample.class,
+            PostSample.class,
+            DeleteSample.class,
+            PutSample.class,
+            JsonSample.class,
+            FileSample.class,
+            BinarySample.class,
+            GzipSample.class,
+            Redirect302Sample.class,
+            ThreadingTimeoutSample.class,
+            CancelAllRequestsSample.class,
+            CancelRequestHandleSample.class,
+            SynchronousClientSample.class
+    };
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, samples));
+        setListAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, samples));
     }
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        Class<?> targetClass;
-        switch (position) {
-            case 0:
-            default:
-                targetClass = GetSample.class;
-                break;
-            case 1:
-                targetClass = PostSample.class;
-                break;
-            case 2:
-                targetClass = DeleteSample.class;
-                break;
-            case 3:
-                targetClass = PutSample.class;
-                break;
-            case 4:
-                targetClass = JsonSample.class;
-                break;
-            case 5:
-                targetClass = FileSample.class;
-                break;
-            case 6:
-                targetClass = BinarySample.class;
-                break;
-            case 7:
-                targetClass = ThreadingTimeoutSample.class;
-                break;
-        }
-        if (targetClass != null)
-            startActivity(new Intent(this, targetClass));
+        if (position >= 0 && position < targets.length)
+            startActivity(new Intent(this, targets[position]));
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
old mode 100644
new mode 100755
index 2d9d5dda..1398d9d9
--- a/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/util/FileUtil.java
@@ -12,7 +12,7 @@
     public static String convertStreamToString(InputStream is) throws Exception {
         BufferedReader reader = new BufferedReader(new InputStreamReader(is));
         StringBuilder sb = new StringBuilder();
-        String line = null;
+        String line;
         while ((line = reader.readLine()) != null) {
             sb.append(line).append("\n");
         }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java b/sample/src/main/java/com/loopj/android/http/sample/util/SampleJSON.java
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
new file mode 100755
index 00000000..97ba749b
--- /dev/null
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:focusable="true"
+        android:focusableInTouchMode="true"
+        android:orientation="vertical">
+
+        <requestFocus/>
+
+        <EditText
+            android:id="@+id/edit_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:inputType="textUri"/>
+
+        <LinearLayout
+            android:id="@+id/layout_url"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/button_cancel"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_cancel"/>
+
+            <Button
+                android:id="@+id/button_run"
+                style="?android:attr/buttonBarButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_run"/>
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_headers"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_headers"/>
+
+            <EditText
+                android:id="@+id/edit_headers"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_body"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <TextView
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="@string/label_req_body"/>
+
+            <EditText
+                android:id="@+id/edit_body"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:inputType="textMultiLine"
+                android:minLines="3"
+                android:singleLine="false"/>
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/layout_response"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"/>
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/layout/parent_layout.xml b/sample/src/main/res/layout/parent_layout.xml
old mode 100644
new mode 100755
index b32b7b74..d2c7dad6
--- a/sample/src/main/res/layout/parent_layout.xml
+++ b/sample/src/main/res/layout/parent_layout.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:fillViewport="true">
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fillViewport="true">
 
     <LinearLayout
         android:focusable="true"
@@ -11,7 +11,7 @@
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
-        <requestFocus />
+        <requestFocus/>
 
         <LinearLayout
             android:id="@+id/layout_url"
@@ -24,20 +24,20 @@
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:layout_weight="1"
-                android:inputType="textUri" />
+                android:inputType="textUri"/>
 
             <Button
                 android:id="@+id/button_run"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="@string/button_run" />
+                android:text="@string/button_run"/>
 
             <Button
                 android:id="@+id/button_cancel"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:visibility="gone"
-                android:text="@string/button_cancel" />
+                android:text="@string/button_cancel"/>
         </LinearLayout>
 
         <LinearLayout
@@ -49,7 +49,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_headers" />
+                android:text="@string/label_headers"/>
 
             <EditText
                 android:id="@+id/edit_headers"
@@ -57,7 +57,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -70,7 +70,7 @@
             <TextView
                 android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:text="@string/label_req_body" />
+                android:text="@string/label_req_body"/>
 
             <EditText
                 android:id="@+id/edit_body"
@@ -78,7 +78,7 @@
                 android:layout_height="wrap_content"
                 android:inputType="textMultiLine"
                 android:minLines="3"
-                android:singleLine="false" />
+                android:singleLine="false"/>
 
         </LinearLayout>
 
@@ -86,7 +86,7 @@
             android:id="@+id/layout_response"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:orientation="vertical" />
+            android:orientation="vertical"/>
 
     </LinearLayout>
 </ScrollView>
\ No newline at end of file
diff --git a/sample/src/main/res/values-v11/styles.xml b/sample/src/main/res/values-v11/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values-v14/styles.xml b/sample/src/main/res/values-v14/styles.xml
old mode 100644
new mode 100755
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
old mode 100644
new mode 100755
index 9e6bae35..3507db19
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -3,14 +3,20 @@
 
     <string name="app_name">Android Async Http Samples</string>
     <string name="title_get_sample">GET</string>
-    <string name="title_json_sample">GET and JSON parse</string>
+    <string name="title_json_sample">GET JSON and parse it</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
     <string name="title_delete_sample">DELETE</string>
     <string name="title_file_sample">GET to File</string>
     <string name="title_binary_sample">GET binary data</string>
+    <string name="title_cancel_all">Cancel all request</string>
+    <string name="title_cancel_handle">Cancel request handle</string>
+    <string name="title_synchronous">Synchronous GET request</string>
+    <string name="title_threading_timeout">Threading timeouts</string>
+    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
     <string name="button_run">Run</string>
     <string name="label_headers">Headers (key=val, one per line)</string>
     <string name="label_req_body">Request body</string>
     <string name="button_cancel">Cancel</string>
+    <string name="title_redirect_302">302 Redirect handling</string>
 </resources>
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
old mode 100644
new mode 100755
diff --git a/settings.gradle b/settings.gradle
old mode 100644
new mode 100755
