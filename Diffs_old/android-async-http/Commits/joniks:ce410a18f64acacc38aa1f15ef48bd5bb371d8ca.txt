diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 26103183..ca7955b9 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -40,9 +40,7 @@
 import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.RedirectHandler;
-import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpHead;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
@@ -901,6 +899,23 @@ public RequestHandle get(Context context, String url, Header[] headers, RequestP
                 context);
     }
 
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle get(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
     // [-] HTTP GET
     // [+] HTTP POST
 
@@ -954,7 +969,7 @@ public RequestHandle post(Context context, String url, RequestParams params, Res
      * @return RequestHandle of future request process
      */
     public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -972,7 +987,7 @@ public RequestHandle post(Context context, String url, HttpEntity entity, String
      */
     public RequestHandle post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = new HttpPost(URI.create(url).normalize());
+        HttpEntityEnclosingRequestBase request = new HttpPost(getURI(url));
         if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType,
@@ -996,7 +1011,7 @@ public RequestHandle post(Context context, String url, Header[] headers, Request
      */
     public RequestHandle post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
                               ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(URI.create(url).normalize()), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -1055,7 +1070,7 @@ public RequestHandle put(Context context, String url, RequestParams params, Resp
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -1074,7 +1089,7 @@ public RequestHandle put(Context context, String url, HttpEntity entity, String
      * @return RequestHandle of future request process
      */
     public RequestHandle put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(URI.create(url).normalize()), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -1124,7 +1139,7 @@ public RequestHandle patch(Context context, String url, RequestParams params, Re
      * @return RequestHandle of future request process
      */
     public RequestHandle patch(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPatch(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPatch(getURI(url)), entity), contentType, responseHandler, context);
     }
 
     /**
@@ -1143,7 +1158,7 @@ public RequestHandle patch(Context context, String url, HttpEntity entity, Strin
      * @return RequestHandle of future request process
      */
     public RequestHandle patch(Context context, String url, Header[] headers, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
-        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(URI.create(url).normalize()), entity);
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPatch(getURI(url)), entity);
         if (headers != null) request.setHeaders(headers);
         return sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
@@ -1171,7 +1186,7 @@ public RequestHandle delete(String url, ResponseHandlerInterface responseHandler
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        final HttpDelete delete = new HttpDelete(getURI(url));
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
@@ -1185,7 +1200,7 @@ public RequestHandle delete(Context context, String url, ResponseHandlerInterfac
      * @return RequestHandle of future request process
      */
     public RequestHandle delete(Context context, String url, Header[] headers, ResponseHandlerInterface responseHandler) {
-        final HttpDelete delete = new HttpDelete(URI.create(url).normalize());
+        final HttpDelete delete = new HttpDelete(getURI(url));
         if (headers != null) delete.setHeaders(headers);
         return sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
@@ -1218,6 +1233,23 @@ public RequestHandle delete(Context context, String url, Header[] headers, Reque
         return sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example
+     *                        application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
+     * @return RequestHandle of future request process
+     */
+    public RequestHandle delete(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) {
+        return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpDelete(URI.create(url).normalize()), entity), contentType, responseHandler, context);
+    }
+
     // [-] HTTP DELETE
 
     /**
@@ -1299,6 +1331,16 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
         return requestHandle;
     }
 
+    /**
+     * Returns a {@link URI} instance for the specified, absolute URL string.
+     *
+     * @param url absolute URL string, containing scheme, host and path
+     * @return URI instance for the URL string
+     */
+    protected URI getURI(String url) {
+        return URI.create(url).normalize();
+    }
+
     /**
      * Sets state of URL encoding feature, see bug #227, this method allows you to turn off and on
      * this auto-magic feature on-demand.
diff --git a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
index 3b844dfc..539a263f 100755
--- a/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -105,13 +105,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
             sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
                     status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "None, or more than one, Content-Type Header found!"
-                    )
+                    "None, or more than one, Content-Type Header found!"
+                )
             );
             return;
         }
@@ -129,13 +129,13 @@ public final void sendResponseMessage(HttpResponse response) throws IOException
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
             sendFailureMessage(
+                status.getStatusCode(),
+                response.getAllHeaders(),
+                null,
+                new HttpResponseException(
                     status.getStatusCode(),
-                    response.getAllHeaders(),
-                    null,
-                    new HttpResponseException(
-                            status.getStatusCode(),
-                            "Content-Type not allowed!"
-                    )
+                    "Content-Type (" + contentTypeHeader.getValue() + ") not allowed!"
+                )
             );
             return;
         }
diff --git a/library/src/main/java/com/loopj/android/http/HttpDelete.java b/library/src/main/java/com/loopj/android/http/HttpDelete.java
new file mode 100644
index 00000000..7bd0d10b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpDelete.java
@@ -0,0 +1,55 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP DELETE method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpDelete extends HttpEntityEnclosingRequestBase {
+    public final static String METHOD_NAME = "DELETE";
+
+    public HttpDelete() {
+        super();
+    }
+
+    public HttpDelete(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpDelete(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/HttpGet.java b/library/src/main/java/com/loopj/android/http/HttpGet.java
new file mode 100644
index 00000000..880f3c76
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/HttpGet.java
@@ -0,0 +1,56 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+
+import java.net.URI;
+
+/**
+ * The current Android (API level 21) bundled version of the Apache Http Client does not implement
+ * a HttpEntityEnclosingRequestBase type of HTTP GET method.
+ * Until the Android version is updated this can serve in it's stead.
+ * This implementation can and should go away when the official solution arrives.
+ */
+public final class HttpGet extends HttpEntityEnclosingRequestBase {
+
+    public final static String METHOD_NAME = "GET";
+
+    public HttpGet() {
+        super();
+    }
+
+    public HttpGet(final URI uri) {
+        super();
+        setURI(uri);
+    }
+
+    /**
+     * @throws IllegalArgumentException if the uri is invalid.
+    */
+    public HttpGet(final String uri) {
+            super();
+            setURI(URI.create(uri));
+    }
+
+    @Override
+    public String getMethod() {
+        return METHOD_NAME;
+    }
+}
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 0df47d47..aea2d1d1 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -18,6 +18,7 @@
 
 package com.loopj.android.http;
 
+import android.text.TextUtils;
 import android.util.Log;
 
 import org.apache.http.Header;
@@ -51,18 +52,12 @@
     // Buffer used for reading from input streams.
     private final byte[] buffer = new byte[BUFFER_SIZE];
 
-    // Reusable StringBuilder used by escape() method.
-    // Its size is just initial, if more space is needed, the system will
-    // automatically enlarge the buffer.
-    private static final StringBuilder BUILDER = new StringBuilder(128);
-
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
     private static final byte[] JSON_NULL = "null".getBytes();
     private static final byte[] STREAM_NAME = escape("name");
     private static final byte[] STREAM_TYPE = escape("type");
     private static final byte[] STREAM_CONTENTS = escape("contents");
-    private static final byte[] STREAM_ELAPSED = escape("_elapsed");
 
     private static final Header HEADER_JSON_CONTENT =
             new BasicHeader(
@@ -80,11 +75,16 @@
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
+    private final byte[] elapsedField;
+
     private final ResponseHandlerInterface progressHandler;
 
-    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression, String elapsedField) {
         this.progressHandler = progressHandler;
         this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
+        this.elapsedField = TextUtils.isEmpty(elapsedField)
+          ? null
+          : escape(elapsedField);
     }
 
     /**
@@ -147,7 +147,7 @@ public void writeTo(final OutputStream out) throws IOException {
 
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream os = null != contentEncoding
+        OutputStream os = contentEncoding != null
                 ? new GZIPOutputStream(out, BUFFER_SIZE)
                 : out;
 
@@ -157,71 +157,90 @@ public void writeTo(final OutputStream out) throws IOException {
         // Keys used by the HashMaps.
         Set<String> keys = jsonParams.keySet();
 
-        boolean isFileWrapper;
-
-        // Go over all keys and handle each's value.
-        for (String key : keys) {
-            // Evaluate the value (which cannot be null).
-            Object value = jsonParams.get(key);
-
-            // Bail out prematurely if value's null.
-            if (value == null) {
-                continue;
-            }
+        int keysCount = keys.size();
+        if (0 < keysCount) {
+            int keysProcessed = 0;
+            boolean isFileWrapper;
 
-            // Write the JSON object's key.
-            os.write(escape(key));
-            os.write(':');
+            // Go over all keys and handle each's value.
+            for (String key : keys) {
+                // Indicate that this key has been processed.
+                keysProcessed++;
 
-            // Check if this is a FileWrapper.
-            isFileWrapper = value instanceof RequestParams.FileWrapper;
+                try {
+                    // Evaluate the value (which cannot be null).
+                    Object value = jsonParams.get(key);
 
-            // If a file should be uploaded.
-            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
-                // All uploads are sent as an object containing the file's details.
-                os.write('{');
+                    // Write the JSON object's key.
+                    os.write(escape(key));
+                    os.write(':');
 
-                // Determine how to handle this entry.
-                if (isFileWrapper) {
-                    writeToFromFile(os, (RequestParams.FileWrapper) value);
-                } else {
-                    writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                    // Bail out prematurely if value's null.
+                    if (value == null) {
+                        os.write(JSON_NULL);
+                    } else {
+                        // Check if this is a FileWrapper.
+                        isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+                        // If a file should be uploaded.
+                        if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                            // All uploads are sent as an object containing the file's details.
+                            os.write('{');
+
+                            // Determine how to handle this entry.
+                            if (isFileWrapper) {
+                                writeToFromFile(os, (RequestParams.FileWrapper) value);
+                            } else {
+                                writeToFromStream(os, (RequestParams.StreamWrapper) value);
+                            }
+
+                            // End the file's object and prepare for next one.
+                            os.write('}');
+                        } else if (value instanceof JsonValueInterface) {
+                            os.write(((JsonValueInterface) value).getEscapedJsonValue());
+                        } else if (value instanceof org.json.JSONObject) {
+                            os.write(((org.json.JSONObject) value).toString().getBytes());
+                        } else if (value instanceof org.json.JSONArray) {
+                            os.write(((org.json.JSONArray) value).toString().getBytes());
+                        } else if (value instanceof Boolean) {
+                            os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
+                        } else if (value instanceof Long) {
+                            os.write((((Number) value).longValue() + "").getBytes());
+                        } else if (value instanceof Double) {
+                            os.write((((Number) value).doubleValue() + "").getBytes());
+                        } else if (value instanceof Float) {
+                            os.write((((Number) value).floatValue() + "").getBytes());
+                        } else if (value instanceof Integer) {
+                            os.write((((Number) value).intValue() + "").getBytes());
+                        } else {
+                            os.write(escape(value.toString()));
+                        }
+                    }
+                } finally {
+                    // Separate each K:V with a comma, except the last one.
+                    if (elapsedField != null || keysProcessed < keysCount) {
+                        os.write(',');
+                    }
                 }
+            }
 
-                // End the file's object and prepare for next one.
-                os.write('}');
-            } else if (value instanceof JsonValueInterface) {
-                os.write(((JsonValueInterface) value).getEscapedJsonValue());
-            } else if (value instanceof org.json.JSONObject) {
-                os.write(((org.json.JSONObject) value).toString().getBytes());
-            } else if (value instanceof org.json.JSONArray) {
-                os.write(((org.json.JSONArray) value).toString().getBytes());
-            } else if (value instanceof Boolean) {
-                os.write((Boolean) value ? JSON_TRUE : JSON_FALSE);
-            } else if (value instanceof Long) {
-                os.write((((Number) value).longValue() + "").getBytes());
-            } else if (value instanceof Double) {
-                os.write((((Number) value).doubleValue() + "").getBytes());
-            } else if (value instanceof Float) {
-                os.write((((Number) value).floatValue() + "").getBytes());
-            } else if (value instanceof Integer) {
-                os.write((((Number) value).intValue() + "").getBytes());
-            } else {
-                os.write(escape(value.toString()));
+            // Calculate how many milliseconds it took to upload the contents.
+            long elapsedTime = System.currentTimeMillis() - now;
+
+            // Include the elapsed time taken to upload everything.
+            // This might be useful for somebody, but it serves us well since
+            // there will almost always be a ',' as the last sent character.
+            if (elapsedField != null) {
+                os.write(elapsedField);
+                os.write(':');
+                os.write((elapsedTime + "").getBytes());
             }
 
-            os.write(',');
+            Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
         }
 
-        // Include the elapsed time taken to upload everything.
-        // This might be useful for somebody, but it serves us well since
-        // there will almost always be a ',' as the last sent character.
-        os.write(STREAM_ELAPSED);
-        os.write(':');
-        long elapsedTime = System.currentTimeMillis() - now;
-        os.write((elapsedTime + "}").getBytes());
-
-        Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
+        // Close the JSON object.
+        os.write('}');
 
         // Flush the contents up the stream.
         os.flush();
@@ -321,60 +340,57 @@ private void endMetaData(OutputStream os) throws IOException {
             return JSON_NULL;
         }
 
+        // Create a string builder to generate the escaped string.
+        StringBuilder sb = new StringBuilder(128);
+
         // Surround with quotations.
-        BUILDER.append('"');
+        sb.append('"');
 
         int length = string.length(), pos = -1;
         while (++pos < length) {
             char ch = string.charAt(pos);
             switch (ch) {
                 case '"':
-                    BUILDER.append("\\\"");
+                    sb.append("\\\"");
                     break;
                 case '\\':
-                    BUILDER.append("\\\\");
+                    sb.append("\\\\");
                     break;
                 case '\b':
-                    BUILDER.append("\\b");
+                    sb.append("\\b");
                     break;
                 case '\f':
-                    BUILDER.append("\\f");
+                    sb.append("\\f");
                     break;
                 case '\n':
-                    BUILDER.append("\\n");
+                    sb.append("\\n");
                     break;
                 case '\r':
-                    BUILDER.append("\\r");
+                    sb.append("\\r");
                     break;
                 case '\t':
-                    BUILDER.append("\\t");
+                    sb.append("\\t");
                     break;
                 default:
                     // Reference: http://www.unicode.org/versions/Unicode5.1.0/
                     if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
                         String intString = Integer.toHexString(ch);
-                        BUILDER.append("\\u");
+                        sb.append("\\u");
                         int intLength = 4 - intString.length();
                         for (int zero = 0; zero < intLength; zero++) {
-                            BUILDER.append('0');
+                            sb.append('0');
                         }
-                        BUILDER.append(intString.toUpperCase(Locale.US));
+                        sb.append(intString.toUpperCase(Locale.US));
                     } else {
-                        BUILDER.append(ch);
+                        sb.append(ch);
                     }
                     break;
             }
         }
 
         // Surround with quotations.
-        BUILDER.append('"');
-
-        try {
-            return BUILDER.toString().getBytes();
-        } finally {
-            // Empty the String buffer.
-            // This is 20-30% faster than instantiating a new object.
-            BUILDER.setLength(0);
-        }
+        sb.append('"');
+
+        return sb.toString().getBytes();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 28a7a93a..4c4ce49e 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -99,6 +99,7 @@
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
+    protected String elapsedFieldInJsonStreamer = "_elapsed";
     protected boolean autoCloseInputStreams;
     protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
     protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
@@ -412,12 +413,25 @@ public String toString() {
         return result.toString();
     }
 
-    public void setHttpEntityIsRepeatable(boolean isRepeatable) {
-        this.isRepeatable = isRepeatable;
+    public void setHttpEntityIsRepeatable(boolean flag) {
+        this.isRepeatable = flag;
     }
 
-    public void setUseJsonStreamer(boolean useJsonStreamer) {
-        this.useJsonStreamer = useJsonStreamer;
+    public void setUseJsonStreamer(boolean flag) {
+        this.useJsonStreamer = flag;
+    }
+
+    /**
+     * Sets an additional field when upload a JSON object through the streamer
+     * to hold the time, in milliseconds, it took to upload the payload. By
+     * default, this field is set to "_elapsed".
+     *
+     * To disable this feature, call this method with null as the field value.
+     *
+     * @param value field name to add elapsed time, or null to disable
+     */
+    public void setElapsedFieldInJsonStreamer(String value) {
+        this.elapsedFieldInJsonStreamer = value;
     }
 
     /**
@@ -449,8 +463,10 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
     }
 
     private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
-                !fileParams.isEmpty() || !streamParams.isEmpty());
+        JsonStreamerEntity entity = new JsonStreamerEntity(
+            progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty(),
+            elapsedFieldInJsonStreamer);
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
