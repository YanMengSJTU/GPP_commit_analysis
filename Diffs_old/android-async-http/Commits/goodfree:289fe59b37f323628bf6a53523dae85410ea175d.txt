diff --git a/android-app-http/src/com/loopj/android/http/AsyncHttpRequest.java b/android-app-http/src/com/loopj/android/http/AsyncHttpRequest.java
index db926d1e..64239f0f 100644
--- a/android-app-http/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/android-app-http/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -14,7 +14,7 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
@@ -31,91 +31,98 @@
 import org.apache.http.protocol.HttpContext;
 
 class AsyncHttpRequest implements Runnable {
-    private final AbstractHttpClient client;
-    private final HttpContext context;
-    private final HttpUriRequest request;
-    private final AsyncHttpResponseHandler responseHandler;
-    private int executionCount;
+	private final AbstractHttpClient client;
+	private final HttpContext context;
+	private final HttpUriRequest request;
+	private final AsyncHttpResponseHandler responseHandler;
+	private int executionCount;
 
-    public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
-        this.client = client;
-        this.context = context;
-        this.request = request;
-        this.responseHandler = responseHandler;
-    }
+	public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request,
+			AsyncHttpResponseHandler responseHandler) {
+		this.client = client;
+		this.context = context;
+		this.request = request;
+		this.responseHandler = responseHandler;
+	}
 
-    public void run() {
-        try {
-            if(responseHandler != null){
-                responseHandler.sendStartMessage();
-            }
+	@Override
+	public void run() {
+		try {
+			if (responseHandler != null) {
+				responseHandler.sendStartMessage();
+			}
+			makeRequestWithRetries();
+		} catch (IOException e) {
+			if (responseHandler != null) {
+				responseHandler.sendFailureMessage(e, e.getMessage());
+			}
+		}
+	}
 
-            makeRequestWithRetries();
+	private void makeRequest() throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			try {
+				HttpResponse response = client.execute(request, context);
+				if (!Thread.currentThread().isInterrupted()) {
+					if (responseHandler != null) {
+						responseHandler.sendResponseMessage(response);
+					}
+				} else {
+					// TODO: should raise InterruptedException? this block is
+					// reached whenever the request is cancelled before its
+					// response is received
+				}
+			} catch (IOException e) {
+				if (!Thread.currentThread().isInterrupted()) {
+					throw e;
+				}
+			}
+		}
+	}
 
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
-        } catch (IOException e) {
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
-        }
-    }
+	private void makeRequestWithRetries() throws ConnectException {
+		// This is an additional layer of retry logic lifted from droid-fu
+		// See:
+		// https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+		boolean retry = true;
+		IOException cause = null;
+		HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
+		while (retry) {
+			try {
+				makeRequest();
+				return;
+			} catch (UnknownHostException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketException e) {
+				// Added to detect host unreachable
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketTimeoutException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "socket time out");
+				}
+				return;
+			} catch (IOException e) {
+				cause = e;
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			} catch (NullPointerException e) {
+				// there's a bug in HttpClient 4.0.x that on some occasions
+				// causes
+				// DefaultRequestExecutor to throw an NPE, see
+				// http://code.google.com/p/android/issues/detail?id=5255
+				cause = new IOException("NPE in HttpClient" + e.getMessage());
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			}
+		}
 
-    private void makeRequest() throws IOException {
-        if(!Thread.currentThread().isInterrupted()) {
-            HttpResponse response = client.execute(request, context);
-            if(!Thread.currentThread().isInterrupted()) {
-                if(responseHandler != null) {
-                    responseHandler.sendResponseMessage(response);
-                }
-            } else{
-                //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
-            }
-        }
-    }
-
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
-        boolean retry = true;
-        IOException cause = null;
-        HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
-                // Added to detect host unreachable
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
-                }
-                return;
-            }catch (SocketTimeoutException e){
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
-                }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient" + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            }
-        }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
-    }
+		// no retries left, crap out with exception
+		ConnectException ex = new ConnectException();
+		ex.initCause(cause);
+		throw ex;
+	}
 }
