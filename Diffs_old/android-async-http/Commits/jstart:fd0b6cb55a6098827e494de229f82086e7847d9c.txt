diff --git a/.classpath b/.classpath
index 14fcf527..0ca188f9 100644
--- a/.classpath
+++ b/.classpath
@@ -3,6 +3,6 @@
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 83ad73a0..49d3e7c4 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -127,7 +127,7 @@ public AsyncHttpClient() {
 
         SchemeRegistry schemeRegistry = new SchemeRegistry();
         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+        schemeRegistry.register(new Scheme("https", new EasySSLSocketFactory(), 443));
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
diff --git a/src/com/loopj/android/http/EasySSLSocketFactory.java b/src/com/loopj/android/http/EasySSLSocketFactory.java
new file mode 100644
index 00000000..adf287d2
--- /dev/null
+++ b/src/com/loopj/android/http/EasySSLSocketFactory.java
@@ -0,0 +1,139 @@
+package com.loopj.android.http;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.TrustManager;
+
+import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.scheme.LayeredSocketFactory;
+import org.apache.http.conn.scheme.SocketFactory;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+
+/**
+ * This socket factory will create ssl socket that accepts self signed
+ * certificate
+ * 
+ * @author olamy
+ * @version $Id: EasySSLSocketFactory.java 765355 2009-04-15 20:59:07Z evenisse
+ *          $
+ * @since 1.2.3
+ */
+public class EasySSLSocketFactory implements SocketFactory,
+		LayeredSocketFactory {
+
+	private SSLContext sslcontext = null;
+
+	private static SSLContext createEasySSLContext() throws IOException {
+		try {
+			SSLContext context = SSLContext.getInstance("TLS");
+			context.init(null, new TrustManager[] { new EasyX509TrustManager(
+					null) }, null);
+			return context;
+		} catch (Exception e) {
+			throw new IOException(e.getMessage());
+		}
+	}
+
+	private SSLContext getSSLContext() throws IOException {
+		if (this.sslcontext == null) {
+			this.sslcontext = createEasySSLContext();
+		}
+		return this.sslcontext;
+	}
+
+	/**
+	 * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket,
+	 *      java.lang.String, int, java.net.InetAddress, int,
+	 *      org.apache.http.params.HttpParams)
+	 */
+	public Socket connectSocket(Socket sock, String host, int port,
+			InetAddress localAddress, int localPort, HttpParams params)
+			throws IOException, UnknownHostException, ConnectTimeoutException {
+		int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
+		int soTimeout = HttpConnectionParams.getSoTimeout(params);
+
+		InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
+		SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());
+
+		if ((localAddress != null) || (localPort > 0)) {
+			// we need to bind explicitly
+			if (localPort < 0) {
+				localPort = 0; // indicates "any"
+			}
+			InetSocketAddress isa = new InetSocketAddress(localAddress,
+					localPort);
+			sslsock.bind(isa);
+		}
+
+		sslsock.connect(remoteAddress, connTimeout);
+		sslsock.setSoTimeout(soTimeout);
+		return sslsock;
+
+	}
+
+	/**
+	 * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
+	 */
+	public Socket createSocket() throws IOException {
+		return getSSLContext().getSocketFactory().createSocket();
+	}
+
+	/**
+	 * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
+	 */
+	public boolean isSecure(Socket socket) throws IllegalArgumentException {
+		return true;
+	}
+
+	/**
+	 * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket,
+	 *      java.lang.String, int, boolean)
+	 */
+	@Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+                    throws IOException, UnknownHostException {
+            return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+	// -------------------------------------------------------------------
+	// javadoc in org.apache.http.conn.scheme.SocketFactory says :
+	// Both Object.equals() and Object.hashCode() must be overridden
+	// for the correct operation of some connection managers
+	// -------------------------------------------------------------------
+
+	public boolean equals(Object obj) {
+		return ((obj != null) && obj.getClass().equals(
+				EasySSLSocketFactory.class));
+	}
+
+	public int hashCode() {
+		return EasySSLSocketFactory.class.hashCode();
+	}
+
+}
diff --git a/src/com/loopj/android/http/EasyX509TrustManager.java b/src/com/loopj/android/http/EasyX509TrustManager.java
new file mode 100644
index 00000000..9d9216c3
--- /dev/null
+++ b/src/com/loopj/android/http/EasyX509TrustManager.java
@@ -0,0 +1,93 @@
+package com.loopj.android.http;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * @author olamy
+ * @version $Id: EasyX509TrustManager.java 765355 2009-04-15 20:59:07Z evenisse $
+ * @since 1.2.3
+ */
+public class EasyX509TrustManager
+    implements X509TrustManager
+{
+
+    private X509TrustManager standardTrustManager = null;
+
+    /**
+     * Constructor for EasyX509TrustManager.
+     */
+    public EasyX509TrustManager( KeyStore keystore )
+        throws NoSuchAlgorithmException, KeyStoreException
+    {
+        super();
+        TrustManagerFactory factory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm() );
+        factory.init( keystore );
+        TrustManager[] trustmanagers = factory.getTrustManagers();
+        if ( trustmanagers.length == 0 )
+        {
+            throw new NoSuchAlgorithmException( "no trust manager found" );
+        }
+        this.standardTrustManager = (X509TrustManager) trustmanagers[0];
+    }
+
+    /**
+     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)
+     */
+    public void checkClientTrusted( X509Certificate[] certificates, String authType )
+        throws CertificateException
+    {
+        standardTrustManager.checkClientTrusted( certificates, authType );
+    }
+
+    /**
+     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)
+     */
+    public void checkServerTrusted( X509Certificate[] certificates, String authType )
+        throws CertificateException
+    {
+        if ( ( certificates != null ) && ( certificates.length == 1 ) )
+        {
+            certificates[0].checkValidity();
+        }
+        else
+        {
+            standardTrustManager.checkServerTrusted( certificates, authType );
+        }
+    }
+
+    /**
+     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
+     */
+    public X509Certificate[] getAcceptedIssuers()
+    {
+        return this.standardTrustManager.getAcceptedIssuers();
+    }
+
+}
