diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 1f07ca4b..c7e699a1 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -218,8 +218,9 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
         threadPool = Executors.newCachedThreadPool();
-        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
-        clientHeaderMap = new HashMap<String, String>();
+
+        requestMap = new WeakHashMap();
+        clientHeaderMap = new HashMap();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
@@ -993,7 +994,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
             // Add request to request map
             List<RequestHandle> requestList = requestMap.get(context);
             if (requestList == null) {
-                requestList = new LinkedList<RequestHandle>();
+                requestList = new LinkedList();
                 requestMap.put(context, requestList);
             }
 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 8cbddb2a..b59001a9 100644
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -322,11 +322,11 @@ protected void postRunnable(Runnable runnable) {
         boolean missingLooper = null == Looper.myLooper();
         if (runnable != null) {
             if (missingLooper) {
-                // If there is no looper, run on current thread
-                runnable.run();
-            } else {
-                // Otherwise, run on a handler we create
+                // If there is no looper, run on provided handler
                 handler.post(runnable);
+            } else {
+                // Otherwise, run on current thread
+                runnable.run();
             }
         }
     }
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 49375061..a92171bd 100644
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -24,7 +24,7 @@
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
 
-import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -46,15 +46,16 @@
     private static final UnsupportedOperationException ERR_UNSUPPORTED =
         new UnsupportedOperationException("Unsupported operation in this implementation.");
 
-    // Size of the byte-array buffer used to read from streams.
-    private static final int BUFFER_SIZE = 2048;
+    // Size of the byte-array buffer used in I/O streams.
+    private static final int BUFFER_SIZE = 4096;
+
+    // Buffer used for reading from input streams.
+    private final byte[] buffer = new byte[BUFFER_SIZE];
 
     // Reusable StringBuilder used by escape() method.
-    // Base64, at worst, will make a binary stream grow in size by approximately
-    // (n + 2 - ((n + 2) % 3)) / 3 * 4, which is roughly 1.3333333% for a
-    // large 'n'.
-    private static final StringBuilder BUILDER =
-        new StringBuilder((int)(BUFFER_SIZE * 1.35f));
+    // Its size is just initial, if more space is needed, the system will
+    // automatically enlarge the buffer.
+    private static final StringBuilder BUILDER = new StringBuilder(128);
 
     private static final byte[] JSON_TRUE = "true".getBytes();
     private static final byte[] JSON_FALSE = "false".getBytes();
@@ -68,33 +69,29 @@
         new BasicHeader("Content-Type", "application/json");
     private static final Header HEADER_GZIP_ENCODING =
         new BasicHeader("Content-Encoding", "gzip");
-    private static final String APPLICATION_OCTET_STREAM =
-        "application/octet-stream";
 
-    // K/V objects to be uploaded.
-    private final Map<String, Object> kvParams =
-        new HashMap<String, Object>();
 
-    // Streams and their associated meta-data to be uploaded.
-    private final Map<String, RequestParams.StreamWrapper> streamParams =
-        new HashMap<String, RequestParams.StreamWrapper>();
+    // JSON data and associated meta-data to be uploaded.
+    private final Map<String, Object> jsonParams = new HashMap();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
 
-    public JsonStreamerEntity(boolean contentEncoding) {
-        this.contentEncoding = contentEncoding ? HEADER_GZIP_ENCODING : null;
-    }
+    private final ResponseHandlerInterface progressHandler;
 
-    public void addPart(String key, Object value) {
-        kvParams.put(key, value);
+    public JsonStreamerEntity(ResponseHandlerInterface progressHandler, boolean useGZipCompression) {
+        this.progressHandler = progressHandler;
+        this.contentEncoding = useGZipCompression ? HEADER_GZIP_ENCODING : null;
     }
 
-    public void addPart(String key, InputStream inputStream, String name, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        streamParams.put(key, new RequestParams.StreamWrapper(inputStream, name, type));
+    /**
+     * Add content parameter, identified by the given key, to the request.
+     *
+     * @param key entity's name
+     * @param value entity's value (Scalar, FileWrapper, StreamWrapper)
+     */
+    public void addPart(String key, Object value) {
+        jsonParams.put(key, value);
     }
 
     @Override
@@ -137,122 +134,176 @@ public InputStream getContent() throws IOException, UnsupportedOperationExceptio
     }
 
     @Override
-    public void writeTo(final OutputStream outstream) throws IOException {
-        if (outstream == null) {
+    public void writeTo(final OutputStream out) throws IOException {
+        if (out == null) {
             throw new IllegalStateException("Output stream cannot be null.");
         }
 
         // Record the time when uploading started.
         long now = System.currentTimeMillis();
 
-        // Keys used by the HashMaps.
-        Set<String> keys;
-
         // Use GZIP compression when sending streams, otherwise just use
         // a buffered output stream to speed things up a bit.
-        OutputStream upload;
-        if (null != contentEncoding) {
-            upload = new GZIPOutputStream(new BufferedOutputStream(outstream), BUFFER_SIZE);
-        } else {
-            upload = new BufferedOutputStream(outstream);
-        }
+        OutputStream os = null != contentEncoding
+          ? new GZIPOutputStream(out, BUFFER_SIZE)
+          : out;
 
         // Always send a JSON object.
-        upload.write('{');
+        os.write('{');
 
-        // Send the K/V values.
-        keys = kvParams.keySet();
-        for (String key : keys) {
-            // Write the JSON object's key.
-            upload.write(escape(key));
-            upload.write(':');
+        // Keys used by the HashMaps.
+        Set<String> keys = jsonParams.keySet();
+
+        boolean isFileWrapper;
 
+        // Go over all keys and handle each's value.
+        for (String key : keys) {
             // Evaluate the value (which cannot be null).
-            Object value = kvParams.get(key);
+            Object value = jsonParams.get(key);
 
-            if (value instanceof Boolean) {
-                upload.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
+            // Bail out prematurely if value's null.
+            if (value == null) {
+                continue;
+            }
+
+            // Write the JSON object's key.
+            os.write(escape(key));
+            os.write(':');
+
+            // Check if this is a FileWrapper.
+            isFileWrapper = value instanceof RequestParams.FileWrapper;
+
+            // If a file should be uploaded.
+            if (isFileWrapper || value instanceof RequestParams.StreamWrapper) {
+                // All uploads are sent as an object containing the file's details.
+                os.write('{');
+
+                // Determine how to handle this entry.
+                if (isFileWrapper) {
+                    writeToFromFile(os, (RequestParams.FileWrapper)value);
+                } else {
+                    writeToFromStream(os, (RequestParams.StreamWrapper)value);
+                }
+
+                // End the file's object and prepare for next one.
+                os.write('}');
+            } else if (value instanceof Boolean) {
+                os.write((Boolean)value ? JSON_TRUE : JSON_FALSE);
             } else if (value instanceof Long) {
-                upload.write((((Number)value).longValue() + "").getBytes());
+                os.write((((Number)value).longValue() + "").getBytes());
             } else if (value instanceof Double) {
-                upload.write((((Number)value).doubleValue() + "").getBytes());
+                os.write((((Number)value).doubleValue() + "").getBytes());
             } else if (value instanceof Float) {
-                upload.write((((Number)value).floatValue() + "").getBytes());
+                os.write((((Number)value).floatValue() + "").getBytes());
             } else if (value instanceof Integer) {
-                upload.write((((Number)value).intValue() + "").getBytes());
+                os.write((((Number)value).intValue() + "").getBytes());
             } else {
-                upload.write(value.toString().getBytes());
-            }
-
-            upload.write(',');
-        }
-
-        // Buffer used for reading from input streams.
-        byte[] buffer = new byte[BUFFER_SIZE];
-
-        // Send the stream params.
-        keys = streamParams.keySet();
-        for (String key : keys) {
-            RequestParams.StreamWrapper entry = streamParams.get(key);
-
-            // Write the JSON object's key.
-            upload.write(escape(key));
-
-            // All uploads are sent as an object containing the file's details.
-            upload.write(':');
-            upload.write('{');
-
-            // Send the streams's name.
-            upload.write(STREAM_NAME);
-            upload.write(':');
-            upload.write(escape(entry.name));
-            upload.write(',');
-
-            // Send the streams's content type.
-            upload.write(STREAM_TYPE);
-            upload.write(':');
-            upload.write(escape(entry.contentType));
-            upload.write(',');
-
-            // Prepare the file content's key.
-            upload.write(STREAM_CONTENTS);
-            upload.write(':');
-            upload.write('"');
-
-            // Upload the file's contents in Base64.
-            Base64OutputStream outputStream =
-                new Base64OutputStream(upload, Base64.NO_CLOSE | Base64.NO_WRAP);
-
-            // Read from input stream until no more data's left to read.
-            int bytesRead;
-            while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
-                outputStream.write(buffer, 0, bytesRead);
+                os.write(value.toString().getBytes());
             }
 
-            // Close the Base64 output stream.
-            outputStream.close();
-
-            // End the file's object and prepare for next one.
-            upload.write('"');
-            upload.write('}');
-            upload.write(',');
+            os.write(',');
         }
 
         // Include the elapsed time taken to upload everything.
         // This might be useful for somebody, but it serves us well since
         // there will almost always be a ',' as the last sent character.
-        upload.write(STREAM_ELAPSED);
-        upload.write(':');
+        os.write(STREAM_ELAPSED);
+        os.write(':');
         long elapsedTime = System.currentTimeMillis() - now;
-        upload.write((elapsedTime + "}").getBytes());
+        os.write((elapsedTime + "}").getBytes());
 
         Log.i(LOG_TAG, "Uploaded JSON in " + Math.floor(elapsedTime / 1000) + " seconds");
 
         // Flush the contents up the stream.
-        upload.flush();
-        upload.close();
+        os.flush();
+        AsyncHttpClient.silentCloseOutputStream(os);
     }
 
+    private void writeToFromStream(OutputStream os, RequestParams.StreamWrapper entry)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, entry.name, entry.contentType);
+
+        int bytesRead;
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from input stream until no more data's left to read.
+        while ((bytesRead = entry.inputStream.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Close input stream.
+        if (entry.autoClose) {
+            // Safely close the input stream.
+            AsyncHttpClient.silentCloseInputStream(entry.inputStream);
+        }
+    }
+
+    private void writeToFromFile(OutputStream os, RequestParams.FileWrapper wrapper)
+            throws IOException {
+
+        // Send the meta data.
+        writeMetaData(os, wrapper.file.getName(), wrapper.contentType);
+
+        int bytesRead, bytesWritten = 0, totalSize = (int)wrapper.file.length();
+
+        // Open the file for reading.
+        FileInputStream in = new FileInputStream(wrapper.file);
+
+        // Upload the file's contents in Base64.
+        Base64OutputStream bos =
+            new Base64OutputStream(os, Base64.NO_CLOSE | Base64.NO_WRAP);
+
+        // Read from file until no more data's left to read.
+        while ((bytesRead = in.read(buffer)) != -1) {
+            bos.write(buffer, 0, bytesRead);
+            bytesWritten += bytesRead;
+            progressHandler.sendProgressMessage(bytesWritten, totalSize);
+        }
+
+        // Close the Base64 output stream.
+        AsyncHttpClient.silentCloseOutputStream(bos);
+
+        // End the meta data.
+        endMetaData(os);
+
+        // Safely close the input stream.
+        AsyncHttpClient.silentCloseInputStream(in);
+    }
+
+    private void writeMetaData(OutputStream os, String name, String contentType) throws IOException {
+        // Send the streams's name.
+        os.write(STREAM_NAME);
+        os.write(':');
+        os.write(escape(name));
+        os.write(',');
+
+        // Send the streams's content type.
+        os.write(STREAM_TYPE);
+        os.write(':');
+        os.write(escape(contentType));
+        os.write(',');
+
+        // Prepare the file content's key.
+        os.write(STREAM_CONTENTS);
+        os.write(':');
+        os.write('"');
+    }
+
+    private void endMetaData(OutputStream os) throws IOException {
+        os.write('"');
+      }
+
     // Curtosy of Simple-JSON: http://goo.gl/XoW8RF
     // Changed a bit to suit our needs in this class.
     static byte[] escape(String string) {
@@ -310,11 +361,11 @@ public void writeTo(final OutputStream outstream) throws IOException {
         BUILDER.append('"');
 
         try {
-          return BUILDER.toString().getBytes();
+            return BUILDER.toString().getBytes();
         } finally {
-          // Empty the String buffer.
-          // This is 20-30% faster than instantiating a new object.
-          BUILDER.setLength(0);
+            // Empty the String buffer.
+            // This is 20-30% faster than instantiating a new object.
+            BUILDER.setLength(0);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index ca328e6b..3e6e4e06 100644
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -60,7 +60,8 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<String, Cookie>();
+        cookies = new ConcurrentHashMap();
+
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -146,7 +147,7 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList<Cookie>(cookies.values());
+        return new ArrayList(cookies.values());
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index bd9acb29..a35aa634 100644
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -9,7 +9,7 @@
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference<AsyncHttpRequest>(request);
+        this.request = new WeakReference(request);
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index d10c2061..cd91dcbf 100644
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -27,7 +27,6 @@
 import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -90,13 +89,18 @@
  */
 public class RequestParams {
 
+    public final static String APPLICATION_OCTET_STREAM =
+        "application/octet-stream";
+
     protected final static String LOG_TAG = "RequestParams";
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
-    protected ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<String, String>();
-    protected ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<String, StreamWrapper>();
-    protected ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<String, FileWrapper>();
-    protected ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<String, Object>();
+    protected boolean autoCloseInputStreams;
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
+
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -235,8 +239,21 @@ public void put(String key, InputStream stream, String name) {
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String name, String contentType) {
+        put(key, stream, name, contentType, autoCloseInputStreams);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param name        the name of the stream.
+     * @param contentType the content type of the file, eg. application/json
+     * @param autoClose   close input stream automatically on successful upload
+     */
+    public void put(String key, InputStream stream, String name, String contentType, boolean autoClose) {
         if (key != null && stream != null) {
-            streamParams.put(key, new StreamWrapper(stream, name, contentType));
+            streamParams.put(key, StreamWrapper.newInstance(stream, name, contentType, autoClose));
         }
     }
 
@@ -362,7 +379,17 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
     }
 
     /**
-     * Returns an HttpEntity containing all request parameters
+     * Set global flag which determines whether to automatically close input
+     * streams on successful upload.
+     *
+     * @param flag boolean whether to automatically close input streams
+     */
+    public void setAutoCloseInputStreams(boolean flag) {
+        autoCloseInputStreams = flag;
+    }
+
+    /**
+     * Returns an HttpEntity containing all request parameters.
      *
      * @param progressHandler HttpResponseHandler for reporting progress on entity submit
      * @return HttpEntity resulting HttpEntity to be included along with {@link
@@ -371,7 +398,7 @@ public void setUseJsonStreamer(boolean useJsonStreamer) {
      */
     public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOException {
         if (useJsonStreamer) {
-            return createJsonStreamerEntity();
+            return createJsonStreamerEntity(progressHandler);
         } else if (streamParams.isEmpty() && fileParams.isEmpty()) {
             return createFormEntity();
         } else {
@@ -379,8 +406,9 @@ public HttpEntity getEntity(ResponseHandlerInterface progressHandler) throws IOE
         }
     }
 
-    private HttpEntity createJsonStreamerEntity() throws IOException {
-        JsonStreamerEntity entity = new JsonStreamerEntity(!fileParams.isEmpty() || !streamParams.isEmpty());
+    private HttpEntity createJsonStreamerEntity(ResponseHandlerInterface progressHandler) throws IOException {
+        JsonStreamerEntity entity = new JsonStreamerEntity(progressHandler,
+            !fileParams.isEmpty() || !streamParams.isEmpty());
 
         // Add string params
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
@@ -394,11 +422,7 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
 
         // Add file params
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            FileWrapper fileWrapper = entry.getValue();
-            entity.addPart(entry.getKey(),
-                    new FileInputStream(fileWrapper.file),
-                    fileWrapper.file.getName(),
-                    fileWrapper.contentType);
+            entity.addPart(entry.getKey(), entry.getValue());
         }
 
         // Add stream params
@@ -406,9 +430,11 @@ private HttpEntity createJsonStreamerEntity() throws IOException {
             StreamWrapper stream = entry.getValue();
             if (stream.inputStream != null) {
                 entity.addPart(entry.getKey(),
+                    StreamWrapper.newInstance(
                         stream.inputStream,
                         stream.name,
-                        stream.contentType);
+                        stream.contentType,
+                        stream.autoClose));
             }
         }
 
@@ -458,7 +484,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> lparams = new LinkedList();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -470,7 +496,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList<BasicNameValuePair>();
+        List<BasicNameValuePair> params = new LinkedList();
         if (value instanceof Map) {
             Map map = (Map) value;
             List list = new ArrayList<Object>(map.keySet());
@@ -511,8 +537,8 @@ protected String getParamString() {
     }
 
     public static class FileWrapper {
-        public File file;
-        public String contentType;
+        public final File file;
+        public final String contentType;
 
         public FileWrapper(File file, String contentType) {
             this.file = file;
@@ -521,14 +547,24 @@ public FileWrapper(File file, String contentType) {
     }
 
     public static class StreamWrapper {
-        public InputStream inputStream;
-        public String name;
-        public String contentType;
+        public final InputStream inputStream;
+        public final String name;
+        public final String contentType;
+        public final boolean autoClose;
 
-        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+        public StreamWrapper(InputStream inputStream, String name, String contentType, boolean autoClose) {
             this.inputStream = inputStream;
             this.name = name;
             this.contentType = contentType;
+            this.autoClose = autoClose;
+        }
+
+        static StreamWrapper newInstance(InputStream inputStream, String name, String contentType, boolean autoClose) {
+            return new StreamWrapper(
+                inputStream,
+                name,
+                contentType == null ? APPLICATION_OCTET_STREAM : contentType,
+                autoClose);
         }
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index 3b6ad196..a6968667 100644
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
-    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index e14ba396..bffdf740 100644
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -46,22 +46,20 @@
 
     private static final String LOG_TAG = "SimpleMultipartEntity";
 
-    private static final String APPLICATION_OCTET_STREAM =
-            "application/octet-stream";
     private static final String STR_CR_LF = "\r\n";
     private static final byte[] CR_LF = STR_CR_LF.getBytes();
     private static final byte[] TRANSFER_ENCODING_BINARY =
-            ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
+        ("Content-Transfer-Encoding: binary" + STR_CR_LF).getBytes();
 
     private final static char[] MULTIPART_CHARS =
-            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+        "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
     private final String boundary;
     private final byte[] boundaryLine;
     private final byte[] boundaryEnd;
     private boolean isRepeatable;
 
-    private final List<FilePart> fileParts = new ArrayList<FilePart>();
+    private final List<FilePart> fileParts = new ArrayList();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
@@ -87,7 +85,7 @@ public SimpleMultipartEntity(ResponseHandlerInterface progressHandler) {
         this.progressHandler = progressHandler;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
+    public void addPart(String key, String value, String contentType) {
         try {
             out.write(boundaryLine);
             out.write(createContentDisposition(key));
@@ -101,7 +99,7 @@ public void addPart(final String key, final String value, final String contentTy
         }
     }
 
-    public void addPart(final String key, final String value) {
+    public void addPart(String key, String value) {
         addPart(key, value, "text/plain; charset=UTF-8");
     }
 
@@ -109,18 +107,13 @@ public void addPart(String key, File file) {
         addPart(key, file, null);
     }
 
-    public void addPart(final String key, File file, String type) {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
-        fileParts.add(new FilePart(key, file, type));
+    public void addPart(String key, File file, String type) {
+        fileParts.add(new FilePart(key, file, normalizeContentType(type)));
     }
 
     public void addPart(String key, String streamName, InputStream inputStream, String type)
             throws IOException {
-        if (type == null) {
-            type = APPLICATION_OCTET_STREAM;
-        }
+
         out.write(boundaryLine);
 
         // Headers
@@ -138,27 +131,27 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
 
         out.write(CR_LF);
         out.flush();
-        try {
-            inputStream.close();
-        } catch (final IOException e) {
-            // Not important, just log it
-            Log.w(LOG_TAG, "Cannot close input stream", e);
-        }
+
+        AsyncHttpClient.silentCloseOutputStream(out);
+    }
+
+    private String normalizeContentType(String type) {
+       return type == null ? RequestParams.APPLICATION_OCTET_STREAM : type;
     }
 
     private byte[] createContentType(String type) {
-        String result = "Content-Type: " + type + STR_CR_LF;
+        String result = "Content-Type: " + normalizeContentType(type) + STR_CR_LF;
         return result.getBytes();
     }
 
-    private byte[] createContentDisposition(final String key) {
+    private byte[] createContentDisposition(String key) {
         return ("Content-Disposition: form-data; name=\"" + key + "\"" + STR_CR_LF)
-                .getBytes();
+            .getBytes();
     }
 
-    private byte[] createContentDisposition(final String key, final String fileName) {
+    private byte[] createContentDisposition(String key, String fileName) {
         return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"" + STR_CR_LF)
-                .getBytes();
+            .getBytes();
     }
 
     private void updateProgress(int count) {
@@ -203,20 +196,15 @@ public void writeTo(OutputStream out) throws IOException {
 
             FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
-            int l;
-            while ((l = inputStream.read(tmp)) != -1) {
-                out.write(tmp, 0, l);
-                updateProgress(l);
+            int bytesRead;
+            while ((bytesRead = inputStream.read(tmp)) != -1) {
+                out.write(tmp, 0, bytesRead);
+                updateProgress(bytesRead);
             }
             out.write(CR_LF);
             updateProgress(CR_LF.length);
             out.flush();
-            try {
-                inputStream.close();
-            } catch (final IOException e) {
-                // Not important, just log it
-                Log.w(LOG_TAG, "Cannot close input stream", e);
-            }
+            AsyncHttpClient.silentCloseInputStream(inputStream);
         }
     }
 
diff --git a/sample/src/main/res/layout-v14/parent_layout.xml b/sample/src/main/res/layout-v14/parent_layout.xml
index dbcb55e2..97ba749b 100644
--- a/sample/src/main/res/layout-v14/parent_layout.xml
+++ b/sample/src/main/res/layout-v14/parent_layout.xml
@@ -15,7 +15,7 @@
 
         <EditText
             android:id="@+id/edit_url"
-            android:layout_width="0dp"
+            android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:inputType="textUri"/>
 
