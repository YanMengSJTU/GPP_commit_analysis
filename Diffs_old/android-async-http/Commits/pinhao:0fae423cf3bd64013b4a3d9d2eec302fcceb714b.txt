diff --git a/.classpath b/.classpath
index 14fcf527..69b7cb08 100644
--- a/.classpath
+++ b/.classpath
@@ -1,8 +1,8 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
index 2b7a4fa0..202ff68c 100644
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -4,7 +4,7 @@
     public static void makeRequest() {
         AsyncHttpClient client = new AsyncHttpClient();
 
-        client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+        client.get("http://www.google.com", new TextHttpResponseHandler() {
             @Override
             public void onSuccess(String response) {
                 System.out.println(response);
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 6053a569..eab2427f 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -81,10 +81,10 @@
  * <p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ * client.get("http://www.google.com", new TextHttpResponseHandler() {
  *     &#064;Override
- *     public void onSuccess(String response) {
- *         System.out.println(response);
+ *     public void onSuccess(String responseBody) {
+ *         System.out.println(responseBody);
  *     }
  * });
  * </pre>
@@ -95,6 +95,7 @@
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     private static final int DEFAULT_MAX_RETRIES = 5;
+    private static final int DEFAULT_RETRY_SLEEP_TIME_MILLIS = 1500;
     private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
     private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
     private static final String ENCODING_GZIP = "gzip";
@@ -113,6 +114,14 @@
      * Creates a new AsyncHttpClient.
      */
     public AsyncHttpClient() {
+        this(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS);
+    }
+
+    public AsyncHttpClient(int maxRetries) {
+      this(maxRetries, DEFAULT_RETRY_SLEEP_TIME_MILLIS);
+  	}
+
+    public AsyncHttpClient(int maxRetries, int retrySleepTimeMS) {
         BasicHttpParams httpParams = new BasicHttpParams();
 
         ConnManagerParams.setTimeout(httpParams, socketTimeout);
@@ -163,7 +172,9 @@ public void process(HttpResponse response, HttpContext context) {
             }
         });
 
-        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+        if(maxRetries < 0) maxRetries = DEFAULT_MAX_RETRIES;
+        if(retrySleepTimeMS <0) retrySleepTimeMS = DEFAULT_RETRY_SLEEP_TIME_MILLIS;
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(maxRetries, retrySleepTimeMS));
 
         threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
 
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
index 0bfbccf7..8a86348a 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -19,9 +19,6 @@
 package com.loopj.android.http;
 
 import java.io.IOException;
-import java.net.ConnectException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 
 import org.apache.http.HttpResponse;
@@ -35,7 +32,6 @@
     private final HttpContext context;
     private final HttpUriRequest request;
     private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
     private int executionCount;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
@@ -43,32 +39,23 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
     }
 
     public void run() {
-        try {
-            if(responseHandler != null){
-                responseHandler.sendStartMessage();
-            }
+        if (responseHandler != null) {
+            responseHandler.sendStartMessage();
+        }
 
+        try {
             makeRequestWithRetries();
-
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
         } catch (IOException e) {
-            if(responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                if(this.isBinaryRequest) {
-                    responseHandler.sendFailureMessage(e, (byte[]) null);
-                } else {
-                    responseHandler.sendFailureMessage(e, (String) null);
-                }
+            if (responseHandler != null) {
+                responseHandler.sendFailureMessage(0, null, e);
             }
         }
+        if (responseHandler != null) {
+            responseHandler.sendFinishMessage();
+        }
     }
 
     private void makeRequest() throws IOException {
@@ -78,53 +65,48 @@ private void makeRequest() throws IOException {
                 if(responseHandler != null) {
                     responseHandler.sendResponseMessage(response);
                 }
-            } else{
-                //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
             }
         }
     }
 
-    private void makeRequestWithRetries() throws ConnectException {
+    private void makeRequestWithRetries() throws IOException {
         // This is an additional layer of retry logic lifted from droid-fu
         // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
         boolean retry = true;
         IOException cause = null;
         HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
-                // Added to detect host unreachable
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
+        try
+        {
+            while (retry) {
+                try {
+                    makeRequest();
+                    return;
+                } catch (UnknownHostException e) {
+                    // switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException
+                    // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
+                    // (to assist in genuine cases of unknown host) which seems better than outright failure
+                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
+                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (IOException e) {
+                    cause = e;
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (NullPointerException e) {
+                    // there's a bug in HttpClient 4.0.x that on some occasions causes
+                    // DefaultRequestExecutor to throw an NPE, see
+                    // http://code.google.com/p/android/issues/detail?id=5255
+                    cause = new IOException("NPE in HttpClient: " + e.getMessage());
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                return;
-            }catch (SocketTimeoutException e){
-                if(responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
+                if(retry && (responseHandler != null)) {
+                  responseHandler.sendRetryMessage();
                 }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient" + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
             }
+        } catch (Exception e) {
+            // catch anything else to ensure failure message is propagated
+            cause = new IOException("Unhandled exception: " + e.getMessage());
         }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
+        
+        // cleaned up to throw IOException
+        throw(cause);
     }
 }
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 86fbdec9..c42a17b2 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -25,10 +25,11 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
+import org.apache.http.util.ByteArrayBuffer;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
 
 /**
  * Used to intercept and handle the responses from requests made using 
@@ -49,12 +50,12 @@
  *     }
  *
  *     &#064;Override
- *     public void onSuccess(String response) {
+ *     public void onSuccess(int statusCode, byte[] responseBody ) {
  *         // Successfully got a response
  *     }
  * 
  *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
+ *     public void onFailure(int statusCode, byte[] responseBody, Throwable e) {
  *         // Response failed :(
  *     }
  *
@@ -70,20 +71,39 @@
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
+    protected static final int RETRY_MESSAGE = 5;
+
+    protected static final int BUFFER_SIZE = 4096;
 
     private Handler handler;
 
+    // avoid leaks by using a non-anonymous handler class
+    // with a weak reference
+    static class ResponderHandler extends Handler {
+        private final WeakReference<AsyncHttpResponseHandler> mResponder; 
+
+        ResponderHandler(AsyncHttpResponseHandler service) {
+            mResponder = new WeakReference<AsyncHttpResponseHandler>(service);
+        }
+        @Override
+        public void handleMessage(Message msg)
+        {
+            AsyncHttpResponseHandler service = mResponder.get();
+             if (service != null) {
+                  service.handleMessage(msg);
+             }
+        }
+    }
+    
     /**
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
-        // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
+        // Set up a handler to post events back to the correct thread if
+        // possible
+        if (Looper.myLooper() != null) {
+            handler = new ResponderHandler(this);
         }
     }
 
@@ -103,52 +123,56 @@ public void onStart() {}
     public void onFinish() {}
 
     /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param content the body of the HTTP response from the server
+     * Fired when a request returns successfully, override to handle in your own
+     * code
+     * 
+     * @param statusCode the status code of the response
+     * @param responseBody the body of the HTTP response from the server
      */
-    public void onSuccess(String content) {}
+    public void onSuccess(int statusCode, byte[] responseBody) {
+    }
+
 
     /**
-     * Fired when a request returns successfully, override to handle in your own code
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     * 
      * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
+     * @param responseBody the response body, if any
+     * @param error the underlying cause of the failure
      */
-    public void onSuccess(int statusCode, String content) {
-        onSuccess(content);
+    public void onFailure(int statusCode, byte[] responseBody, Throwable error) {
     }
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @deprecated use {@link #onFailure(Throwable, String)}
+     * Fired when a bytes are received, override to handle in your own
+     * code
+     * 
+     * @param current the current number of bytes loaded from the response
+     * @param total the total number of bytes in the response
      */
-    public void onFailure(Throwable error) {}
+    public void onProgress(int current, int total) {
+    }
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param content the response body, if any
+     * Fired when a retry occurs, override to handle in your own
+     * code
+     * 
      */
-    public void onFailure(Throwable error, String content) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
+    public void onRetry() {
     }
-
+    
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
     //
 
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
+    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[] { Integer.valueOf(statusCode), responseBody }));
     }
 
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-    
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    protected void sendFailureMessage(int statusCode, byte[] responseBody, Throwable error) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] { Integer.valueOf(statusCode), responseBody, error }));
     }
 
     protected void sendStartMessage() {
@@ -159,48 +183,71 @@ protected void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
+    protected void sendProgressMessage(int current, int total) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[] { current, total }));
+    }
 
+    protected void sendRetryMessage() {
+      sendMessage(obtainMessage(RETRY_MESSAGE, null));
+  }
+    
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
 
-    protected void handleSuccessMessage(int statusCode, String responseBody) {
+    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
         onSuccess(statusCode, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, byte[] responseBody, Throwable error) {
+        onFailure(statusCode, responseBody, error);
     }
 
+    protected void handleProgressMessage(int current, int total) {
+        onProgress(current, total);
+    }
 
-
+    protected void handleRetryMessage() {
+      onRetry();
+  }
+    
     // Methods which emulate android's Handler and Message methods
     protected void handleMessage(Message msg) {
         Object[] response;
 
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
-                break;
-            case START_MESSAGE:
-                onStart();
-                break;
-            case FINISH_MESSAGE:
-                onFinish();
-                break;
+        switch (msg.what) {
+        case SUCCESS_MESSAGE:
+            response = (Object[]) msg.obj;
+            handleSuccessMessage(((Integer) response[0]).intValue(), (byte[]) response[1]);
+            break;
+        case FAILURE_MESSAGE:
+            response = (Object[]) msg.obj;
+            handleFailureMessage(((Integer) response[0]).intValue(), (byte[]) response[1], (Throwable) response[2]);
+            break;
+        case START_MESSAGE:
+            onStart();
+            break;
+        case FINISH_MESSAGE:
+            onFinish();
+            break;
+        case PROGRESS_MESSAGE:
+            response = (Object[]) msg.obj;
+            onProgress(((Integer) response[0]).intValue(), ((Integer) response[1]).intValue());
+            break;
+        case RETRY_MESSAGE:
+            onRetry();
+          break;
         }
     }
 
     protected void sendMessage(Message msg) {
-        if(handler != null){
-            handler.sendMessage(msg);
-        } else {
-            handleMessage(msg);
+        // do not send messages if request has been cancelled
+        if (!Thread.currentThread().isInterrupted()) {
+            if (handler != null) {
+                handler.sendMessage(msg);
+            } else {
+                handleMessage(msg);
+            }
         }
     }
 
@@ -216,25 +263,54 @@ protected Message obtainMessage(int responseMessage, Object response) {
         return msg;
     }
 
-    // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try{
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l, count = 0;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            count += l;
+                            buffer.append(tmp, 0, l);
+                            sendProgressMessage(count, (int) contentLength);
+                        }
+                    } finally {
+                        instream.close();
+                    }
+                    responseBody = buffer.buffer();
+                } catch( OutOfMemoryError e ) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
             }
-        } catch(IOException e) {
-            sendFailureMessage(e, (String) null);
         }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
+        return (responseBody);
+    }
+    
+    // Interface to AsyncHttpRequest
+    void sendResponseMessage(HttpResponse response) throws IOException {
+        // do not process if request has been cancelled
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            byte[] responseBody = null;
+            responseBody = getResponseData(response.getEntity());
+            if (status.getStatusCode() >= 300) {
+                sendFailureMessage(status.getStatusCode(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+            } else {
+                sendSuccessMessage(status.getStatusCode(), responseBody);
+            }
         }
     }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index aff1c631..647dffc0 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -18,16 +18,12 @@
 
 package com.loopj.android.http;
 
-import android.os.Message;
+import java.io.IOException;
+
 import org.apache.http.Header;
-import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
-
-import java.io.IOException;
 
 /**
  * Used to intercept and handle the responses from requests made using
@@ -100,64 +96,21 @@ public void onSuccess(int statusCode, byte[] binaryData) {
      * Fired when a request fails to complete, override to handle in your own code
      * @param error the underlying cause of the failure
      * @param binaryData the response body, if any
-     * @deprecated
      */
-    public void onFailure(Throwable error, byte[] binaryData) {
+    public void onFailure(int statusCode, byte[] binaryData, Throwable error) {
         // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
-    }
-
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
     }
 
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
-    }
 
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (byte[])response[1]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
 
     // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
+    void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
         byte[] responseBody = null;
         if(contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+            sendFailureMessage(status.getStatusCode(), responseBody, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -169,24 +122,9 @@ void sendResponseMessage(HttpResponse response) {
         }
         if(!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+            sendFailureMessage(status.getStatusCode(), responseBody, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
             return;
         }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, (byte[]) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
+        super.sendResponseMessage( response );
     }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..c39a15f2
--- /dev/null
+++ b/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,59 @@
+package com.loopj.android.http;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.http.HttpEntity;
+
+/**
+ * 
+ * @author sweetlilmre
+ *
+ *  Implements a response handler that will store the response in the provided
+ *  File object.
+ *  
+ *  Events will be sent as per the AsyncHttpResponseHandler base class, however
+ *  all byte[] values returned will be null.
+ */
+public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+  
+    private File mFile;
+
+    public File getFile() {
+      return (mFile);
+    }
+    
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        this.mFile = file;
+    }
+  
+    @Override
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+      if (entity != null) {
+          InputStream instream = entity.getContent();
+          long contentLength = entity.getContentLength();
+          FileOutputStream buffer = new FileOutputStream(this.mFile);
+          if (instream != null) {
+              try {
+                  byte[] tmp = new byte[BUFFER_SIZE];
+                  int l, count = 0;;
+                  // do not send messages if request has been cancelled
+                  while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                      count += l;
+                      buffer.write(tmp, 0, l);
+                      sendProgressMessage(count, (int) contentLength);
+                  }
+              } finally {
+                  instream.close();
+                  buffer.flush();
+                  buffer.close();
+              }
+          }
+      }
+      return (null);
+  }
+  
+}
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 084bf339..e9232f58 100644
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -18,7 +18,8 @@
 
 package com.loopj.android.http;
 
-import org.apache.http.HttpStatus;
+import java.io.UnsupportedEncodingException;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -40,6 +41,7 @@
  */
 public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
     protected static final int SUCCESS_JSON_MESSAGE = 100;
+    protected static final int FAILURE_JSON_MESSAGE = 101;
 
     //
     // Callbacks to be overridden, typically anonymously
@@ -85,8 +87,32 @@ public void onSuccess(int statusCode, JSONArray response) {
         onSuccess(response);
     }
 
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
+    
+    /**
+     * Fired when a request fails and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * <br/>
+     * <strong>NOTE:</strong> remember to override the superclass {@link AsyncHttpResponseHandler#onFailure(int, byte[], Throwable) onFailure}
+     * method to cover all failure scenarios
+     * @param statusCode the status code of the response
+     * @param errorResponse the parsed json object found in the server response (if any)
+     * @param error the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, JSONObject errorResponse, Throwable error) {}
+    
+    /**
+     * Fired when a request fails and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     * <br/>
+     * <strong>NOTE:</strong> remember to override the superclass {@link AsyncHttpResponseHandler#onFailure(int, byte[], Throwable) onFailure}
+     * method to cover all failure scenarios
+     * @param statusCode the status code of the response
+     * @param errorResponse the parsed json array found in the server response (if any)
+     * @param error the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, JSONArray errorResponse, Throwable error) {}
 
 
     //
@@ -94,19 +120,28 @@ public void onFailure(Throwable e, JSONArray errorResponse) {}
     //
 
     @Override
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-    	if (statusCode != HttpStatus.SC_NO_CONTENT){
-	        try {
-	            Object jsonResponse = parseResponse(responseBody);
-	            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, jsonResponse}));
-	        } catch(JSONException e) {
-	            sendFailureMessage(e, responseBody);
-	        }
-    	}else{
-    		sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
-    	}
+    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
+        try {
+            Object jsonResponse = parseResponse(responseBody);
+            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[] { Integer.valueOf(statusCode), jsonResponse }));
+        } catch (JSONException e) {
+            sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] {Integer.valueOf(0), responseBody, e}));
+        }
     }
 
+    @Override
+    protected void sendFailureMessage(int statusCode, byte[] responseBody, Throwable error) {
+        try {
+            if (responseBody != null) {
+                Object jsonResponse = parseResponse(responseBody);
+                sendMessage(obtainMessage(FAILURE_JSON_MESSAGE, new Object[] {Integer.valueOf(statusCode), jsonResponse, error}));
+            } else {
+                sendMessage(obtainMessage(FAILURE_JSON_MESSAGE, new Object[] {Integer.valueOf(statusCode), (JSONObject)null, error}));
+            }
+        } catch (JSONException ex) {
+            sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] {Integer.valueOf(0), responseBody, error}));
+        }
+    }
 
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
@@ -114,11 +149,16 @@ protected void sendSuccessMessage(int statusCode, String responseBody) {
 
     @Override
     protected void handleMessage(Message msg) {
+        Object[] response;
         switch(msg.what){
             case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
+                response = (Object[]) msg.obj;
                 handleSuccessJsonMessage(((Integer) response[0]).intValue(), response[1]);
                 break;
+            case FAILURE_JSON_MESSAGE:
+                response = (Object[]) msg.obj;
+                handleFailureJsonMessage(((Integer) response[0]).intValue(), response[1], (Throwable) response[2]);
+                break;
             default:
                 super.handleMessage(msg);
         }
@@ -130,40 +170,40 @@ protected void handleSuccessJsonMessage(int statusCode, Object jsonResponse) {
         } else if(jsonResponse instanceof JSONArray) {
             onSuccess(statusCode, (JSONArray)jsonResponse);
         } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
+            onFailure(statusCode, (JSONObject)null, new JSONException("Unexpected type " + jsonResponse.getClass().getName()));
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-		responseBody = responseBody.trim();
-		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
-			result = new JSONTokener(responseBody).nextValue();
-		}
-		if (result == null) {
-			result = responseBody;
-		}
-		return result;
+    protected void handleFailureJsonMessage(int statusCode, Object jsonResponse, Throwable error) {
+        if (jsonResponse instanceof JSONObject) {
+            onFailure(statusCode, (JSONObject) jsonResponse, error);
+        } else if (jsonResponse instanceof JSONArray) {
+            onFailure(statusCode, (JSONArray) jsonResponse, error);
+        } else {
+            onFailure(0, (JSONObject)null, error);
+        }
     }
-
-    @Override
-    protected void handleFailureMessage(Throwable e, String responseBody) {
+    
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
+        Object result = null;
+        String responseBodyText = null;
         try {
-            if (responseBody != null) {
-                Object jsonResponse = parseResponse(responseBody);
-                if(jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject)jsonResponse);
-                } else if(jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray)jsonResponse);
-                } else {
-                    onFailure(e, responseBody);
-                }
-            }else {
-                onFailure(e, "");
-            }
-        }catch(JSONException ex) {
-            onFailure(e, responseBody);
+            responseBodyText = new String(responseBody, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new JSONException("Unable to convert response to UTF-8 string");
+        }
+        
+        // trim the string to prevent start with blank, and test if the string
+        // is valid JSON, because the parser don't do this :(. If Json is not
+        // valid this will return null
+        responseBodyText = responseBodyText.trim();
+        if (responseBodyText.startsWith("{") || responseBodyText.startsWith("[")) {
+            result = new JSONTokener(responseBodyText).nextValue();
         }
+        if (result == null) {
+            result = responseBodyText;
+        }
+        return result;
     }
+
 }
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index cca963a1..05640b2a 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -18,12 +18,13 @@
 
 package com.loopj.android.http;
 
-import java.io.InputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -42,9 +43,9 @@
  * <p>
  * <pre>
  * RequestParams params = new RequestParams();
- * params.put("username", "james");
- * params.put("password", "123456");
- * params.put("email", "my&#064;email.com");
+ * params.add("username", "james");
+ * params.add("password", "123456");
+ * params.add("email", "my&#064;email.com");
  * params.put("profile_picture", new File("pic.jpg")); // Upload a File
  * params.put("profile_picture2", someInputStream); // Upload an InputStream
  * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
@@ -56,9 +57,8 @@
 public class RequestParams {
     private static String ENCODING = "UTF-8";
 
-    protected ConcurrentHashMap<String, String> urlParams;
+    protected List<BasicNameValuePair> urlParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
-    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
 
     /**
      * Constructs a new empty <code>RequestParams</code> instance.
@@ -76,7 +76,7 @@ public RequestParams(Map<String, String> source) {
         init();
 
         for(Map.Entry<String, String> entry : source.entrySet()) {
-            put(entry.getKey(), entry.getValue());
+            add(entry.getKey(), entry.getValue());
         }
     }
 
@@ -89,7 +89,7 @@ public RequestParams(Map<String, String> source) {
     public RequestParams(String key, String value) {
         init();
 
-        put(key, value);
+        add(key, value);
     }
 
     /**
@@ -107,7 +107,7 @@ public RequestParams(Object... keysAndValues) {
       for (int i = 0; i < len; i += 2) {
         String key = String.valueOf(keysAndValues[i]);
         String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
+        add(key, val);
       }
     }
 
@@ -116,9 +116,9 @@ public RequestParams(Object... keysAndValues) {
      * @param key the key name for the new param.
      * @param value the value string for the new param.
      */
-    public void put(String key, String value){
+    public void add(String key, String value){
         if(key != null && value != null) {
-            urlParams.put(key, value);
+            urlParams.add(new BasicNameValuePair(key, value));
         }
     }
 
@@ -131,17 +131,6 @@ public void put(String key, File file) throws FileNotFoundException {
         put(key, new FileInputStream(file), file.getName());
     }
 
-    /**
-     * Adds param with more than one value.
-     * @param key the key name for the new param.
-     * @param values is the ArrayList with values for the param.
-     */
-    public void put(String key, ArrayList<String> values)  {
-        if(key != null && values != null) {
-            urlParamsWithArray.put(key, values);
-        }
-    }
-
     /**
      * Adds an input stream to the request.
      * @param key the key name for the new param.
@@ -181,19 +170,18 @@ public void put(String key, InputStream stream, String fileName, String contentT
     public void remove(String key){
         urlParams.remove(key);
         fileParams.remove(key);
-        urlParamsWithArray.remove(key);
     }
 
     @Override
     public String toString() {
         StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+        for(BasicNameValuePair pair : urlParams) {
             if(result.length() > 0)
                 result.append("&");
 
-            result.append(entry.getKey());
+            result.append(pair.getName());
             result.append("=");
-            result.append(entry.getValue());
+            result.append(pair.getValue());
         }
 
         for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
@@ -205,20 +193,6 @@ public String toString() {
             result.append("FILE");
         }
 
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            if(result.length() > 0)
-                result.append("&");
-
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                if (values.indexOf(value) != 0)
-                    result.append("&");
-                result.append(entry.getKey());
-                result.append("=");
-                result.append(value);
-            }
-        }
-
         return result.toString();
     }
 
@@ -232,8 +206,8 @@ public HttpEntity getEntity() {
             SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
 
             // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
+            for(BasicNameValuePair pair : urlParams) {
+                multipartEntity.addPart(pair.getName(), pair.getValue());
             }
 
             // Add file params
@@ -252,14 +226,6 @@ public HttpEntity getEntity() {
                 currentIndex++;
             }
 
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
-
             entity = multipartEntity;
         } else {
             try {
@@ -273,23 +239,15 @@ public HttpEntity getEntity() {
     }
 
     private void init(){
-        urlParams = new ConcurrentHashMap<String, String>();
+        urlParams = Collections.synchronizedList(new ArrayList<BasicNameValuePair>());
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
-        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
     }
 
     protected List<BasicNameValuePair> getParamsList() {
         List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
-        }
-
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            ArrayList<String> values = entry.getValue();
-            for (String value : values) {
-                lparams.add(new BasicNameValuePair(entry.getKey(), value));
-            }
+        for(BasicNameValuePair pair : urlParams) {
+            lparams.add(pair);
         }
 
         return lparams;
diff --git a/src/com/loopj/android/http/RetryHandler.java b/src/com/loopj/android/http/RetryHandler.java
index 715456fb..70bef056 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/src/com/loopj/android/http/RetryHandler.java
@@ -41,7 +41,6 @@
 import android.os.SystemClock;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
     private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
     private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
 
@@ -60,9 +59,11 @@
     }
 
     private final int maxRetries;
+    private final int retrySleepTimeMS;
 
-    public RetryHandler(int maxRetries) {
+    public RetryHandler(int maxRetries, int retrySleepTimeMS) {
         this.maxRetries = maxRetries;
+        this.retrySleepTimeMS = retrySleepTimeMS;
     }
 
     public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
@@ -92,8 +93,8 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             retry = !requestType.equals("POST");
         }
 
-        if(retry) {
-            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+        if (retry) {
+            SystemClock.sleep(retrySleepTimeMS);
         } else {
             exception.printStackTrace();
         }
diff --git a/src/com/loopj/android/http/SyncHttpClient.java b/src/com/loopj/android/http/SyncHttpClient.java
index 8f55991e..d5c20385 100644
--- a/src/com/loopj/android/http/SyncHttpClient.java
+++ b/src/com/loopj/android/http/SyncHttpClient.java
@@ -1,5 +1,7 @@
 package com.loopj.android.http;
 
+import java.io.IOException;
+
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
@@ -15,9 +17,9 @@
 	 * field to be accessible
 	 */
 	private String result;
-	AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
+	AsyncHttpResponseHandler responseHandler = new TextHttpResponseHandler() {
 
-		void sendResponseMessage(org.apache.http.HttpResponse response) {
+		void sendResponseMessage(org.apache.http.HttpResponse response) throws IOException {
 			responseCode = response.getStatusLine().getStatusCode();
 			super.sendResponseMessage(response);
 		};
@@ -37,7 +39,7 @@ public void onSuccess(String content) {
 		}
 
 		@Override
-		public void onFailure(Throwable error, String content) {
+		public void onFailure(String content, Throwable error) {
 			result = onRequestFailed(error, content);
 		}
 	};
diff --git a/src/com/loopj/android/http/TextHttpResponseHandler.java b/src/com/loopj/android/http/TextHttpResponseHandler.java
new file mode 100644
index 00000000..f0acf050
--- /dev/null
+++ b/src/com/loopj/android/http/TextHttpResponseHandler.java
@@ -0,0 +1,125 @@
+package com.loopj.android.http;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Used to intercept and handle the responses from requests made using 
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * designed to be anonymously overridden with your own response handling code.
+ * <p>
+ * Additionally, you can override the {@link #onFailure(String, Throwable)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String responseBody ) {
+ *         // Successfully got a response
+ *     }
+ * 
+ *     &#064;Override
+ *     public void onFailure(String responseBody, Throwable e) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private String _encoding;
+    /**
+     * Creates a new TextHttpResponseHandler
+     */
+    
+    public TextHttpResponseHandler()
+    {
+        this("UTF-8");
+    }
+    
+    public TextHttpResponseHandler(String encoding) {
+        super();
+        _encoding = encoding;
+    }
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own
+     * code
+     * 
+     * @param responseBody the body of the HTTP response from the server
+     */
+    public void onSuccess(String responseBody) {
+    }
+    
+    /**
+     * Fired when a request returns successfully, override to handle in your own
+     * code
+     * 
+     * @param statusCode the status code of the response
+     * @param responseBody the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, String responseBody) {
+      onSuccess( responseBody );
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     * 
+     * @param responseBody the response body, if any
+     * @param error the underlying cause of the failure
+     */    
+    public void onFailure(String responseBody, Throwable e) {
+    }
+    
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     * 
+     * @param statusCode the status code of the response
+     * @param responseBody the response body, if any
+     * @param error the underlying cause of the failure
+     */    
+    public void onFailure(int statusCode, String responseBody, Throwable e) {
+      onFailure( responseBody, e );
+    }
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    @Override
+    protected void handleSuccessMessage(int statusCode,byte[] responseBody) {
+        try {
+            onSuccess(statusCode, new String(responseBody, _encoding));
+        } catch (UnsupportedEncodingException e) {
+            onFailure(0, (String) null, e);
+        }
+    }
+
+    @Override
+    protected void handleFailureMessage(int statusCode, byte[] responseBody, Throwable error) {
+        try {
+            onFailure(statusCode, new String(responseBody, _encoding), error);
+        } catch (UnsupportedEncodingException e) {
+            onFailure(0, (String) null, e);
+        }
+    }
+    
+}
