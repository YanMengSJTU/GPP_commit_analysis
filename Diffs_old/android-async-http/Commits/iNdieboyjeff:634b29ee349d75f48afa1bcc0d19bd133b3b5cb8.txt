diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index 7997bd0f..758ad956 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -210,7 +210,7 @@ public void process(HttpResponse response, HttpContext context) {
                 if (encoding != null) {
                     for (HeaderElement element : encoding.getElements()) {
                         if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
-                            response.setEntity(new InflatingEntity(response.getEntity()));
+                            response.setEntity(new InflatingEntity(entity));
                             break;
                         }
                     }
@@ -310,6 +310,23 @@ public void setProxy(String hostname, int port) {
         final HttpParams httpParams = this.httpClient.getParams();
         httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
+    /**
+     * Sets the Proxy by it's hostname,port,username and password
+     *
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
+     * @param username the username
+     * @param password the password
+     */
+     public void setProxy(String hostname,int port,String username,String password){
+         httpClient.getCredentialsProvider().setCredentials(
+    		    new AuthScope(hostname, port),
+    		    new UsernamePasswordCredentials(username, password));
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+     }
+
 
     /**
      * Sets the SSLSocketFactory to user when making requests. By default,
@@ -574,7 +591,7 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
+        post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -606,7 +623,7 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
                      AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if (params != null) request.setEntity(paramsToEntity(params));
+        if (params != null) request.setEntity(paramsToEntity(params, responseHandler));
         if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
@@ -668,7 +685,7 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
+        put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
     }
 
     /**
@@ -793,11 +810,18 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
-    private HttpEntity paramsToEntity(RequestParams params) {
+    private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpEntity entity = null;
 
-        if (params != null) {
-            entity = params.getEntity();
+        try {
+            if (params != null) {
+                entity = params.getEntity(responseHandler);
+            }
+        } catch (Throwable t) {
+            if (responseHandler != null)
+                responseHandler.sendFailureMessage(0, null, t, (String) null);
+            else
+                t.printStackTrace();
         }
 
         return entity;
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 854b2e29..10669285 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -72,6 +72,7 @@
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
 
     private Handler handler;
     private String responseCharset = "UTF-8";
@@ -110,6 +111,15 @@ public void handleMessage(Message msg) {
     // Callbacks to be overridden, typically anonymously
     //
 
+    /**
+     * Fired when the request progress, override to handle in your own code
+     *
+     * @param bytesWritten offset from start of file
+     * @param totalSize total size of file
+     */
+    public void onProgress(int bytesWritten, int totalSize) {
+    }
+
     /**
      * Fired when the request is started, override to handle in your own code
      */
@@ -202,6 +212,10 @@ public void onFailure(int statusCode, Header[] headers, Throwable error, String
     // Pre-processing of messages (executes in background threadpool thread)
     //
 
+    protected void sendProgressMessage(int bytesWritten, int totalSize) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, totalSize}));
+    }
+
     protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
@@ -265,6 +279,10 @@ protected void handleMessage(Message msg) {
             case FINISH_MESSAGE:
                 onFinish();
                 break;
+            case PROGRESS_MESSAGE:
+                response = (Object[]) msg.obj;
+                onProgress((Integer) response[0], (Integer) response[1]);
+                break;
         }
     }
 
@@ -279,7 +297,7 @@ protected void sendMessage(Message msg) {
     protected Message obtainMessage(int responseMessage, Object response) {
         Message msg;
         if (handler != null) {
-            msg = this.handler.obtainMessage(responseMessage, response);
+            msg = handler.obtainMessage(responseMessage, response);
         } else {
             msg = Message.obtain();
             if (msg != null) {
@@ -292,6 +310,10 @@ protected Message obtainMessage(int responseMessage, Object response) {
 
     // Interface to AsyncHttpRequest
     protected void sendResponseMessage(HttpResponse response) {
+        if (response == null) {
+            sendFailureMessage(0, null, new IllegalStateException("No response"), (String) null);
+            return;
+        }
         StatusLine status = response.getStatusLine();
         String responseBody = null;
         try {
@@ -302,6 +324,12 @@ protected void sendResponseMessage(HttpResponse response) {
                 responseBody = EntityUtils.toString(entity, getCharset());
             }
         } catch (IOException e) {
+            try {
+                if (response.getEntity() != null)
+                    response.getEntity().consumeContent();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
             sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (String) null);
             return;
         }
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 08255419..d8e5cdda 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -57,7 +57,7 @@
  */
 public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
     // Allow images by default
-    private static String[] mAllowedContentTypes = new String[]{
+    private String[] mAllowedContentTypes = new String[]{
             "image/jpeg",
             "image/png"
     };
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
index 5121f5b1..18e2b106 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -22,10 +22,11 @@
 import org.apache.http.client.entity.UrlEncodedFormEntity;
 import org.apache.http.client.utils.URLEncodedUtils;
 import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.protocol.HTTP;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
@@ -54,9 +55,11 @@
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
+
+    private static final String LOG_TAG = "RequestParams";
 
     protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
     protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
 
@@ -127,27 +130,28 @@ public void put(String key, String value) {
     }
 
     /**
-     * Adds a integer param to the request.
+     * Adds a file to the request.
      *
-     * @param key   the key name for the new param.
-     * @param value the integer value for the new param.
+     * @param key  the key name for the new param.
+     * @param file the file to add.
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
      */
-    public void put(String key, int value) {
-        if (key != null) {
-            urlParams.put(key, String.valueOf(value));
-        }
+    public void put(String key, File file) throws FileNotFoundException {
+        put(key, file, null);
     }
 
     /**
      * Adds a file to the request.
      *
-     * @param key  the key name for the new param.
-     * @param file the file to add.
-     *
-     * @throws java.io.FileNotFoundException if the file is not found
+     * @param key         the key name for the new param.
+     * @param file        the file to add.
+     * @param contentType the content type of the file, eg. application/json
+     * @throws java.io.FileNotFoundException throws if wrong File argument was passed
      */
-    public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
+    public void put(String key, File file, String contentType) throws FileNotFoundException {
+        if (key != null && file != null) {
+            fileParams.put(key, new FileWrapper(file, contentType));
+        }
     }
 
     /**
@@ -162,23 +166,6 @@ public void put(String key, ArrayList<String> values) {
         }
     }
 
-    /**
-     * Adds value to param which can have more than one value.
-     *
-     * @param key   the key name for the param, either existing or new.
-     * @param value the value string for the new param.
-     */
-    public void add(String key, String value) {
-        if (key != null && value != null) {
-            ArrayList<String> paramArray = urlParamsWithArray.get(key);
-            if (paramArray == null) {
-                paramArray = new ArrayList<String>();
-                this.put(key, paramArray);
-            }
-            paramArray.add(value);
-        }
-    }
-
     /**
      * Adds an input stream to the request.
      *
@@ -192,12 +179,12 @@ public void put(String key, InputStream stream) {
     /**
      * Adds an input stream to the request.
      *
-     * @param key      the key name for the new param.
-     * @param stream   the input stream to add.
-     * @param fileName the name of the file.
+     * @param key    the key name for the new param.
+     * @param stream the input stream to add.
+     * @param name   the name of the stream.
      */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
+    public void put(String key, InputStream stream, String name) {
+        put(key, stream, name, null);
     }
 
     /**
@@ -205,12 +192,12 @@ public void put(String key, InputStream stream, String fileName) {
      *
      * @param key         the key name for the new param.
      * @param stream      the input stream to add.
-     * @param fileName    the name of the file.
+     * @param name        the name of the stream.
      * @param contentType the content type of the file, eg. application/json
      */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
+    public void put(String key, InputStream stream, String name, String contentType) {
         if (key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+            streamParams.put(key, new StreamWrapper(stream, name, contentType));
         }
     }
 
@@ -221,6 +208,7 @@ public void put(String key, InputStream stream, String fileName, String contentT
      */
     public void remove(String key) {
         urlParams.remove(key);
+        streamParams.remove(key);
         fileParams.remove(key);
         urlParamsWithArray.remove(key);
     }
@@ -237,6 +225,15 @@ public String toString() {
             result.append(entry.getValue());
         }
 
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("STREAM");
+        }
+
         for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
             if (result.length() > 0)
                 result.append("&");
@@ -266,57 +263,64 @@ public String toString() {
     /**
      * Returns an HttpEntity containing all request parameters
      *
-     * @return an HttpEntity containing all request parameters
+     * @param progressHandler HttpResponseHandler for reporting progress on entity submit
+     * @return HttpEntity resulting HttpEntity to be included along with {@link org.apache.http.client.methods.HttpEntityEnclosingRequestBase}
+     * @throws IOException if one of the streams cannot be read
      */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
+    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+            return createFormEntity();
+        } else {
+            return createMultipartEntity(progressHandler);
+        }
+    }
 
-        if (!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+    private HttpEntity createFormEntity() {
+        try {
+            return new UrlEncodedFormEntity(getParamsList(), HTTP.UTF_8);
+        } catch (UnsupportedEncodingException e) {
+            return null; // Actually cannot happen when using utf-8
+        }
+    }
 
-            // Add string params
-            for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
+    private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
 
-            // Add dupe params
-            for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
 
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if (file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if (file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
+        // Add dupe params
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray
+                .entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                entity.addPart(entry.getKey(), value);
             }
+        }
 
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
+                        stream.contentType);
             }
         }
 
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+        }
+
         return entity;
     }
 
     private void init() {
         urlParams = new ConcurrentHashMap<String, String>();
+        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
         urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
     }
@@ -339,26 +343,28 @@ private void init() {
     }
 
     protected String getParamString() {
-        return URLEncodedUtils.format(getParamsList(), ENCODING);
+        return URLEncodedUtils.format(getParamsList(), HTTP.UTF_8);
     }
 
     private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
+        public File file;
         public String contentType;
 
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
+        public FileWrapper(File file, String contentType) {
+            this.file = file;
             this.contentType = contentType;
         }
+    }
 
-        public String getFileName() {
-            if (fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
+    private static class StreamWrapper {
+        public InputStream inputStream;
+        public String name;
+        public String contentType;
+
+        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+            this.inputStream = inputStream;
+            this.name = name;
+            this.contentType = contentType;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
index 59eb5ffa..ccb01aa1 100644
--- a/library/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -88,7 +88,10 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         if (retry) {
             // resend all idempotent requests
             HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
-            String requestType = currentReq != null ? currentReq.getMethod() : "";
+            if (currentReq == null) {
+                return false;
+            }
+            String requestType = currentReq.getMethod();
             retry = !requestType.equals("POST");
         }
 
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
index b072b8b0..30346ffe 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -23,128 +23,223 @@
 
 package com.loopj.android.http;
 
+import android.util.Log;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
 
-import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
+/**
+ * Simplified multipart entity mainly used for sending one or more files.
+ */
 class SimpleMultipartEntity implements HttpEntity {
+
+    private static final String LOG_TAG = "SimpleMultipartEntity";
+
+    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
+    private static final byte[] CR_LF = ("\r\n").getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
+            .getBytes();
+
     private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary = null;
+    private String boundary;
+    private byte[] boundaryLine;
+    private byte[] boundaryEnd;
+
+    private List<FilePart> fileParts = new ArrayList<FilePart>();
+
+    // The buffer we use for building the message excluding files and the last
+    // boundary
+    private ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    private AsyncHttpResponseHandler progressHandler;
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
+    private int bytesWritten;
 
-    public SimpleMultipartEntity() {
+    private int totalSize;
+
+    public SimpleMultipartEntity(AsyncHttpResponseHandler progressHandler) {
         final StringBuilder buf = new StringBuilder();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
         }
-        this.boundary = buf.toString();
 
+        boundary = buf.toString();
+        boundaryLine = ("--" + boundary + "\r\n").getBytes();
+        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+
+        this.progressHandler = progressHandler;
     }
 
-    public void writeFirstBoundaryIfNeeds() {
-        if (!isSetFirst) {
-            writeBoundary();
+    public void addPart(final String key, final String value, final String contentType) {
+        try {
+            out.write(boundaryLine);
+            out.write(createContentDisposition(key));
+            out.write(createContentType(contentType));
+            out.write(CR_LF);
+            out.write(value.getBytes());
+            out.write(CR_LF);
+        } catch (final IOException e) {
+            // Can't happen on ByteArrayOutputStream
+            Log.e(LOG_TAG, "addPart ByteArrayOutputStream exception", e);
         }
+    }
 
-        isSetFirst = true;
+    public void addPart(final String key, final String value) {
+        addPart(key, value, "text/plain; charset=UTF-8");
     }
 
-    public void writeBoundary() {
-        try {
-            out.write(("--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
+    public void addPart(String key, File file) {
+        addPart(key, file, null);
+    }
+
+    public void addPart(final String key, File file, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
         }
+        fileParts.add(new FilePart(key, file, type));
     }
 
-    public void writeLastBoundaryIfNeeds() {
-        if (isSetLast) {
-            return;
+    public void addPart(String key, String streamName, InputStream inputStream, String type)
+            throws IOException {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        out.write(boundaryLine);
+
+        // Headers
+        out.write(createContentDisposition(key, streamName));
+        out.write(createContentType(type));
+        out.write(TRANSFER_ENCODING_BINARY);
+        out.write(CR_LF);
+
+        // Stream (file)
+        final byte[] tmp = new byte[4096];
+        int l;
+        while ((l = inputStream.read(tmp)) != -1) {
+            out.write(tmp, 0, l);
         }
 
+        out.write(CR_LF);
+        out.flush();
         try {
-            out.write(("--" + boundary + "--\r\n").getBytes());
-            out.flush();
+            inputStream.close();
         } catch (final IOException e) {
-            e.printStackTrace();
+            // Not important, just log it
+            Log.w(LOG_TAG, "Cannot close input stream", e);
         }
+    }
 
-        isSetLast = true;
+    private byte[] createContentType(String type) {
+        String result = "Content-Type: " + type + "\r\n";
+        return result.getBytes();
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
-        writeBoundary();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" + key + "\"\r\n").getBytes());
-            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
+    private byte[] createContentDisposition(final String key) {
+        return new StringBuilder()
+                .append("Content-Disposition: form-data; name=\"")
+                .append(key)
+                .append("\"\r\n")
+                .toString()
+                .getBytes();
     }
 
-    public void addPart(final String key, final String value) {
-        addPart(key, value, "text/plain; charset=UTF-8");
+    private byte[] createContentDisposition(final String key, final String fileName) {
+        return new StringBuilder()
+                .append("Content-Disposition: form-data; name=\"")
+                .append(key)
+                .append("\"; filename=\"")
+                .append(fileName)
+                .append("\"\r\n")
+                .toString()
+                .getBytes();
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast) {
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    private void updateProgress(int count) {
+        bytesWritten += count;
+        progressHandler.sendProgressMessage(bytesWritten, totalSize);
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast) {
-        writeBoundary();
-        try {
-            type = "Content-Type: " + type + "\r\n";
-            out.write(("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+    private class FilePart {
+        public File file;
+        public byte[] header;
 
+        public FilePart(String key, File file, String type) {
+            header = createHeader(key, file.getName(), type);
+            this.file = file;
+        }
+
+        private byte[] createHeader(String key, String filename, String type) {
+            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
+            try {
+                headerStream.write(boundaryLine);
+
+                // Headers
+                headerStream.write(createContentDisposition(key, filename));
+                headerStream.write(createContentType(type));
+                headerStream.write(TRANSFER_ENCODING_BINARY);
+                headerStream.write(CR_LF);
+            } catch (IOException e) {
+                // Can't happen on ByteArrayOutputStream
+                Log.e(LOG_TAG, "createHeader ByteArrayOutputStream exception", e);
+            }
+            return headerStream.toByteArray();
+        }
+
+        public long getTotalLength() {
+            long streamLength = file.length();
+            return header.length + streamLength;
+        }
+
+        public void writeTo(OutputStream out) throws IOException {
+            out.write(header);
+            updateProgress(header.length);
+
+            FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
             int l;
-            while ((l = fin.read(tmp)) != -1) {
+            while ((l = inputStream.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
+                updateProgress(l);
             }
-            out.write(("\r\n").getBytes());
-
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
+            out.write(CR_LF);
+            updateProgress(CR_LF.length);
+            out.flush();
             try {
-                fin.close();
+                inputStream.close();
             } catch (final IOException e) {
-                e.printStackTrace();
+                // Not important, just log it
+                Log.w(LOG_TAG, "Cannot close input stream", e);
             }
         }
     }
 
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
+    // The following methods are from the HttpEntity interface
 
     @Override
     public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
+        long contentLen = out.size();
+        for (FilePart filePart : fileParts) {
+            long len = filePart.getTotalLength();
+            if (len < 0) {
+                return -1; // Should normally not happen
+            }
+            contentLen += len;
+        }
+        contentLen += boundaryEnd.length;
+        return contentLen;
     }
 
     @Override
@@ -169,8 +264,16 @@ public boolean isStreaming() {
 
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
-        writeLastBoundaryIfNeeds();
-        outstream.write(out.toByteArray());
+        bytesWritten = 0;
+        totalSize = (int) getContentLength();
+        out.writeTo(outstream);
+        updateProgress(out.size());
+
+        for (FilePart filePart : fileParts) {
+            filePart.writeTo(outstream);
+        }
+        outstream.write(boundaryEnd);
+        updateProgress(boundaryEnd.length);
     }
 
     @Override
@@ -179,8 +282,7 @@ public Header getContentEncoding() {
     }
 
     @Override
-    public void consumeContent() throws IOException,
-            UnsupportedOperationException {
+    public void consumeContent() throws IOException, UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
                     "Streaming entity does not implement #consumeContent()");
@@ -188,9 +290,8 @@ public void consumeContent() throws IOException,
     }
 
     @Override
-    public InputStream getContent() throws IOException,
-            UnsupportedOperationException {
-        writeLastBoundaryIfNeeds();
-        return new ByteArrayInputStream(out.toByteArray());
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw new UnsupportedOperationException(
+                "getContent() is not supported. Use writeTo() instead.");
     }
 }
\ No newline at end of file
diff --git a/sample/build.gradle b/sample/build.gradle
index f328c0e3..20fdcb60 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.5.+'
+        classpath 'com.android.tools.build:gradle:0.6.+'
     }
 }
 apply plugin: 'android'
diff --git a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
index 3e29e6c7..f5096ae2 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
@@ -64,6 +64,7 @@ private void startRequest() {
             @Override
             public void onSuccess(int statusCode, Header[] headers, String content) {
                 setStatusMessage("Succeeded", Color.parseColor("#DD00FF00"));
+                printThrowable(null);
                 printHeaders(headers);
                 printContents(content);
                 printStatusCode(statusCode);
