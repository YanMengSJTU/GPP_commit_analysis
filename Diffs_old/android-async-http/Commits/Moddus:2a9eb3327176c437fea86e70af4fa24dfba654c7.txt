diff --git a/.classpath b/.classpath
deleted file mode 100644
index 14fcf527..00000000
--- a/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/.gitignore b/.gitignore
index ad0f40fb..d3b22564 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,15 +1,40 @@
+# Custom
 _site
+
+# Ant
 MANIFEST.MF
 ./*.jar
 build.num
 build
+
+# ADT
+.classpath
+.project
+.settings
 local.properties
-bin/
-gen/
+bin
+gen
 _layouts
+proguard.cfg
+
+# OSX
 .DS_Store
+
+# Github
 gh-pages
+
+# Gradle
+.gradle
 build
-.gradle/
-.idea
+
+# IDEA
 *.iml
+*.ipr
+*.iws
+out
+.idea
+
+# Maven
+target
+release.properties
+pom.xml.*
diff --git a/.project b/.project
deleted file mode 100644
index a9793139..00000000
--- a/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>android-async-http</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..20458a51
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,41 @@
+branches:
+  only:
+    - master
+language:
+  - java
+jdk:
+  - openjdk6
+before_install:
+  # environment info
+  - mvn -version
+  - gradle -v
+  - uname -a
+  # required libs for android build tools
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+  # for gradle output style
+  - export TERM=dumb
+  # newer version of gradle
+  - wget http://services.gradle.org/distributions/gradle-1.8-bin.zip
+  - unzip -qq gradle-1.8-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.8
+  - export PATH=$GRADLE_HOME/bin:$PATH
+  # just to test gradle version, against our provided one
+  - gradle -v
+  # newest android SDK 22.0.5
+  - wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz
+  - tar -zxf android-sdk_r22.0.5-linux.tgz
+  - export ANDROID_HOME=`pwd`/android-sdk-linux
+  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+  # manually set sdk.dir variable, according to local paths
+  - echo "sdk.dir=$ANDROID_HOME" > local.properties
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-18 --force --no-ui
+  # build tools cannot be installed through "android update sdk" as of now
+  - wget http://dl.google.com/android/repository/build-tools_r18.0.1-linux.zip
+  - mkdir -p $ANDROID_HOME/build-tools
+  - unzip -qq build-tools_r18.0.1-linux.zip -d $ANDROID_HOME/build-tools/
+  - mv $ANDROID_HOME/build-tools/android-4.3 $ANDROID_HOME/build-tools/18.0.1
+  # verify files exist in right paths
+  - find $ANDROID_HOME/build-tools
+  - file $ANDROID_HOME/build-tools/18.0.1/aapt
+  # - mvn clean test install
diff --git a/README.md b/README.md
index 1602a534..3d7bd95e 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,8 @@
 Asynchronous Http Client for Android
 ====================================
 
+Travis CI state : [![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
+
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
 
@@ -22,4 +24,4 @@ Documentation, Features and Examples
 ------------------------------------
 Full details and documentation can be found on the project page here:
 
-http://loopj.com/android-async-http/
\ No newline at end of file
+http://loopj.com/android-async-http/
diff --git a/build.gradle b/build.gradle
index c24812f8..6dbebcf5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,27 +4,19 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.5.+'
+        classpath 'com.android.tools.build:gradle:0.6.+'
     }
 }
 
-apply plugin: 'android-library'
+allprojects {
+    group = 'com.loopj.android'
+    version = '1.4.4-SNAPSHOT'
 
-group 'com.loopj.android.http'
-version '1.4.4-SNAPSHOT'
-
-android {
-    compileSdkVersion 17
-    buildToolsVersion '17.0.0'
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-        }
+    repositories {
+        mavenCentral()
     }
-}
 
-task jar(type: Jar) {
-    from android.sourceSets.main.java
+    tasks.withType(JavaCompile) {
+        options.encoding = "UTF-8"
+    }
 }
diff --git a/build.xml b/build.xml
deleted file mode 100644
index 1cd94b37..00000000
--- a/build.xml
+++ /dev/null
@@ -1,98 +0,0 @@
-<project default="package">
-    <property file="local.properties"/>
-    <property file="project.properties"/>
-
-    <!-- Package properties -->
-    <property name="package.name" value="android-async-http" />
-    <property name="package.packagename" value="com.loopj.android.http" />
-    
-    <!-- Get git commit -->
-    <available file=".git" type="dir" property="git.present"/>
-
-    <target name="git-details">
-        <exec executable="git" outputproperty="git.status">
-            <arg value="status" />
-        </exec>
-        <echo message="${git.status}"/>
-        
-        <exec executable="git" outputproperty="package.versionname">
-          <arg value="describe"/>
-          <arg value="--tags"/>
-          <arg value="--dirty"/>
-          <arg value="--always"/>
-        </exec>
-        <echo message="${package.versionname}" />
-    </target>
-
-    <!-- Standard jar stuff -->
-    <property environment="env"/>
-    <condition property="android.base" value="${sdk.dir}" else="${env.ANDROID_HOME}">
-      <isset property="sdk.dir" />
-    </condition>
-    <fail message="Please set either the sdk.dir property or the ANDROID_HOME environment variable to point to your Android SDK installation.">
-      <condition>
-        <not>
-          <available file="${android.base}" type="dir"/>
-        </not>
-      </condition>
-    </fail>
-
-    <property name="lib.dir" value="${android.base}/platforms/${target}" />
-    <property name="build.dir" value="./build"/>
-    <property name="classes.dir"  value="${build.dir}/classes"/>
-    <buildnumber file="build.num" />
-
-    <!-- Set up classpath -->
-    <path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar" />
-    </path>
-
-    <!-- Build javadoc -->
-    <target name="doc">
-        <javadoc 
-            classpathref="classpath"
-            sourcepath="gen:src"
-            destdir="doc"
-            packagenames="${package.packagename}"
-            linkoffline="http://d.android.com/reference ${android.base}/docs/reference" 
-            additionalparam="-author  -version"
-            />
-    </target>
-
-    <!-- Compile java files into classes -->
-    <target name="compile">
-        <mkdir dir="${build.dir}" />
-        <mkdir dir="${classes.dir}" />
-
-        <javac
-            includeantruntime="false"
-            srcdir="src"
-            destdir="${classes.dir}"
-            classpathref="classpath"
-            debug="true"
-            debuglevel="lines,source" />
-    </target>
-
-    <!-- Package a jar from compiled class files -->
-    <target name="jar" depends="git-details,compile">
-        <manifest file="MANIFEST.MF">
-            <attribute name="Built-By" value="${user.name}" />
-            <attribute name="Implementation-Version" value="${package.versionname}"/> 
-        </manifest>
-
-        <jar destfile="${package.name}-${package.versionname}.jar" basedir="build/classes" includes="com/loopj/android/http/**/*.class" manifest="MANIFEST.MF" />
-    </target>
-
-    <!-- Clean out the build files -->
-    <target name="clean">
-        <delete dir="build" />
-        <delete dir="doc" />
-        <delete>
-            <fileset dir="." includes="*.jar"/>
-            <fileset file="MANIFEST.MF"/>
-        </delete>
-    </target>
-
-    <!-- Compile and package a jar -->
-    <target name="package" depends="compile,jar" />
-</project>
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
index 1c7b81e8..3febe0ce 100644
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -1,6 +1,3 @@
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-
 public class ExampleUsage {
     public static void makeRequest() {
         AsyncHttpClient client = new AsyncHttpClient();
@@ -12,4 +9,4 @@ public void onSuccess(String response) {
             }
         });
     }
-}
\ No newline at end of file
+}
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
index f2b6c97b..105d1c88 100644
--- a/examples/TwitterRestClient.java
+++ b/examples/TwitterRestClient.java
@@ -1,9 +1,5 @@
 // Static wrapper library around AsyncHttpClient
 
-import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
-import com.loopj.android.http.RequestParams;
-
 public class TwitterRestClient {
     private static final String BASE_URL = "http://api.twitter.com/1/";
 
@@ -20,4 +16,4 @@ public static void post(String url, RequestParams params, AsyncHttpResponseHandl
     private static String getAbsoluteUrl(String relativeUrl) {
         return BASE_URL + relativeUrl;
     }
-}
\ No newline at end of file
+}
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
index be9afc16..7d0bce1c 100644
--- a/examples/TwitterRestClientUsage.java
+++ b/examples/TwitterRestClientUsage.java
@@ -1,23 +1,18 @@
-import com.loopj.android.http.JsonHttpResponseHandler;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 class TwitterRestClientUsage {
     public void getPublicTimeline() {
         TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
             @Override
             public void onSuccess(JSONArray timeline) {
                 try {
-                    JSONObject firstEvent = (JSONObject)timeline.get(0);
+                    JSONObject firstEvent = (JSONObject) timeline.get(0);
                     String tweetText = firstEvent.getString("text");
 
                     // Do something with the response
                     System.out.println(tweetText);
-                } catch(JSONException e) {
+                } catch (JSONException e) {
                     e.printStackTrace();
                 }
             }
         });
     }
-}
\ No newline at end of file
+}
diff --git a/AndroidManifest.xml b/library/AndroidManifest.xml
similarity index 55%
rename from AndroidManifest.xml
rename to library/AndroidManifest.xml
index 5684532c..fc7a6a3c 100644
--- a/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,11 +1,15 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.3"
-    android:versionCode="1">
-    <application
-        android:name="android_async_http">
-    </application>
-    <uses-sdk android:minSdkVersion="3" />
+    android:versionName="1.4.4"
+    android:versionCode="2">
+
+    <uses-sdk
+        android:minSdkVersion="3"
+        android:targetSdkVersion="18" />
+
     <uses-permission android:name="android.permission.INTERNET" />
+
+    <application />
+
 </manifest> 
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..81185aea
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'android-library'
+
+dependencies {
+    compile 'com.android.support:support-v4:18.0.+'
+}
+
+android {
+    compileSdkVersion 18
+    buildToolsVersion '18.0.1'
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            res.srcDirs = ['res']
+        }
+    }
+}
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
similarity index 69%
rename from src/com/loopj/android/http/AsyncHttpClient.java
rename to library/src/com/loopj/android/http/AsyncHttpClient.java
index 15bf7524..834f931e 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -20,12 +20,26 @@
 
 import android.content.Context;
 import com.loopj.android.http.methods.HttpPatch;
-import org.apache.http.*;
+
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpResponseInterceptor;
+import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.CookieStore;
 import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.*;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpHead;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
@@ -47,7 +61,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
-import java.util.*;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -55,14 +73,16 @@
 
 
 /**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
+ * The ouwjngaiosjaeos0~gaeopw~sn+~opgawnp+oiajn~+hips~+hrop+fdsgdsgfddfggfdgfddfgdfgfdfggdfdgfdgfdfgdfgdfgdgfdfgdgfdfg
+ * dfg
+ * AsyncHttpClient can be used to make asynchronous GET, POST, PUT and
  * DELETE HTTP requests in your Android applications. Requests can be made
  * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
+ * and responses can be handled by passing an anonymously overridden
  * {@link AsyncHttpResponseHandler} instance.
- * <p>
+ * <p/>
  * For example:
- * <p>
+ * <p/>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -151,7 +171,7 @@ public void process(HttpResponse response, HttpContext context) {
 
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
 
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
+        threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
 
         requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
         clientHeaderMap = new HashMap<String, String>();
@@ -167,7 +187,7 @@ public HttpClient getHttpClient() {
     }
 
     /**
-     * Get the underlying HttpContext instance. This is useful for getting 
+     * Get the underlying HttpContext instance. This is useful for getting
      * and setting fine-grained settings for requests by accessing the
      * context's attributes such as the CookieStore.
      */
@@ -177,6 +197,7 @@ public HttpContext getHttpContext() {
 
     /**
      * Sets an optional CookieStore to use when making requests
+     *
      * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
      */
     public void setCookieStore(CookieStore cookieStore) {
@@ -186,6 +207,7 @@ public void setCookieStore(CookieStore cookieStore) {
     /**
      * Overrides the threadpool implementation used when queuing/pooling
      * requests. By default, Executors.newCachedThreadPool() is used.
+     *
      * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
      */
     public void setThreadPool(ThreadPoolExecutor threadPool) {
@@ -195,6 +217,7 @@ public void setThreadPool(ThreadPoolExecutor threadPool) {
     /**
      * Sets the User-Agent header to be sent with each request. By default,
      * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     *
      * @param userAgent the string to use in the User-Agent header.
      */
     public void setUserAgent(String userAgent) {
@@ -202,10 +225,11 @@ public void setUserAgent(String userAgent) {
     }
 
     /**
-     * Sets the connection time oout. By default, 10 seconds
+     * Set the connection timeout. By default, 10 seconds.
+     *
      * @param timeout the connect/socket timeout in milliseconds
      */
-    public void setTimeout(int timeout){
+    public void setTimeout(int timeout) {
         final HttpParams httpParams = this.httpClient.getParams();
         ConnManagerParams.setTimeout(httpParams, timeout);
         HttpConnectionParams.setSoTimeout(httpParams, timeout);
@@ -215,16 +239,18 @@ public void setTimeout(int timeout){
     /**
      * Sets the SSLSocketFactory to user when making requests. By default,
      * a new, default SSLSocketFactory is used.
+     *
      * @param sslSocketFactory the socket factory to use for https requests.
      */
     public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
         this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
     }
-    
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
+     *
      * @param header the name of the header
-     * @param value the contents of the header
+     * @param value  the contents of the header
      */
     public void addHeader(String header, String value) {
         clientHeaderMap.put(header, value);
@@ -232,46 +258,47 @@ public void addHeader(String header, String value) {
 
     /**
      * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
      * @param username
      * @param password
      */
-    public void setBasicAuth(String user, String pass){
+    public void setBasicAuth(String username, String password) {
         AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
+        setBasicAuth(username, password, scope);
     }
-    
-   /**
+
+    /**
      * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
      * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     *
      * @param username
      * @param password
-     * @param scope - an AuthScope object
-     *
+     * @param scope    - an AuthScope object
      */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
+    public void setBasicAuth(String username, String password, AuthScope scope) {
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
         this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
     }
 
     /**
      * Cancels any pending (or potentially active) requests associated with the
      * passed Context.
-     * <p>
+     * <p/>
      * <b>Note:</b> This will only affect requests which were created with a non-null
      * android Context. This method is intended to be used in the onDestroy
      * method of your android activities to destroy all requests which are no
      * longer required.
      *
-     * @param context the android Context instance associated to the request.
+     * @param context               the android Context instance associated to the request.
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
      */
     public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
+        if (requestList != null) {
+            for (WeakReference<Future<?>> requestRef : requestList) {
                 Future<?> request = requestRef.get();
-                if(request != null) {
+                if (request != null) {
                     request.cancel(mayInterruptIfRunning);
                 }
             }
@@ -279,6 +306,67 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         requestMap.remove(context);
     }
 
+    //
+    // HTTP HEAD Requests
+    //
+
+    /**
+     * Perform a HTTP HEAD request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(String url, AsyncHttpResponseHandler responseHandler) {
+        head(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        head(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request without any parameters and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        head(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(url, params)), null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated
+     * the request with customized headers
+     *
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param params additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpUriRequest request = new HttpHead(getUrlWithQueryString(url, params));
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
 
     //
     // HTTP GET Requests
@@ -286,7 +374,8 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
 
     /**
      * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(String url, AsyncHttpResponseHandler responseHandler) {
@@ -295,8 +384,9 @@ public void get(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -305,8 +395,9 @@ public void get(String url, RequestParams params, AsyncHttpResponseHandler respo
 
     /**
      * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
@@ -315,28 +406,29 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
 
     /**
      * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP GET request and track the Android Context which initiated
      * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
@@ -348,7 +440,8 @@ public void get(Context context, String url, Header[] headers, RequestParams par
 
     /**
      * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(String url, AsyncHttpResponseHandler responseHandler) {
@@ -357,8 +450,9 @@ public void post(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -367,9 +461,10 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
 
     /**
      * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -378,10 +473,11 @@ public void post(Context context, String url, RequestParams params, AsyncHttpRes
 
     /**
      * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
@@ -391,21 +487,21 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     /**
      * Perform a HTTP POST request and track the Android Context which initiated
      * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional POST parameters to send with the request.
+     * @param contentType     the content type of the payload you are sending, for
+     *                        example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
+        if (params != null) request.setEntity(paramsToEntity(params));
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
     }
@@ -414,21 +510,21 @@ public void post(Context context, String url, Header[] headers, RequestParams pa
      * Perform a HTTP POST request and track the Android Context which initiated
      * the request. Set headers only for this request
      *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for
+     *                        example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -438,7 +534,8 @@ public void post(Context context, String url, Header[] headers, HttpEntity entit
 
     /**
      * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(String url, AsyncHttpResponseHandler responseHandler) {
@@ -447,8 +544,9 @@ public void put(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -457,9 +555,10 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
 
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -469,29 +568,31 @@ public void put(Context context, String url, RequestParams params, AsyncHttpResp
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
      * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
      * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+    public void put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -528,7 +629,8 @@ public void patch( Context context, String url,Header[] headers, HttpEntity enti
 
     /**
      * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(String url, AsyncHttpResponseHandler responseHandler) {
@@ -537,41 +639,43 @@ public void delete(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
+        if (headers != null) delete.setHeaders(headers);
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
 
     // Private stuff
     protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
+        if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
         }
 
         Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
 
-        if(context != null) {
+        if (context != null) {
             // Add request to request map
             List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
+            if (requestList == null) {
                 requestList = new LinkedList<WeakReference<Future<?>>>();
                 requestMap.put(context, requestList);
             }
@@ -583,7 +687,7 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
     }
 
     public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
+        if (params != null) {
             String paramString = params.getParamString();
             if (url.indexOf("?") == -1) {
                 url += "?" + paramString;
@@ -598,7 +702,7 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
     private HttpEntity paramsToEntity(RequestParams params) {
         HttpEntity entity = null;
 
-        if(params != null) {
+        if (params != null) {
             entity = params.getEntity();
         }
 
@@ -606,7 +710,7 @@ private HttpEntity paramsToEntity(RequestParams params) {
     }
 
     private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
+        if (entity != null) {
             requestBase.setEntity(entity);
         }
 
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
similarity index 72%
rename from src/com/loopj/android/http/AsyncHttpRequest.java
rename to library/src/com/loopj/android/http/AsyncHttpRequest.java
index bf43a42c..f7d9c6fb 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -21,6 +21,7 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.http.protocol.HttpContext;
 
@@ -43,7 +44,7 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
+        if (responseHandler instanceof BinaryHttpResponseHandler) {
             this.isBinaryRequest = true;
         }
     }
@@ -51,19 +52,19 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
     @Override
     public void run() {
         try {
-            if(responseHandler != null){
+            if (responseHandler != null) {
                 responseHandler.sendStartMessage();
             }
 
             makeRequestWithRetries();
 
-            if(responseHandler != null) {
+            if (responseHandler != null) {
                 responseHandler.sendFinishMessage();
             }
         } catch (IOException e) {
-            if(responseHandler != null) {
+            if (responseHandler != null) {
                 responseHandler.sendFinishMessage();
-                if(this.isBinaryRequest) {
+                if (this.isBinaryRequest) {
                     responseHandler.sendFailureMessage(e, (byte[]) null);
                 } else {
                     responseHandler.sendFailureMessage(e, (String) null);
@@ -73,21 +74,21 @@ public void run() {
     }
 
     private void makeRequest() throws IOException {
-        if(!Thread.currentThread().isInterrupted()) {
-        	try {
-        		HttpResponse response = client.execute(request, context);
-        		if(!Thread.currentThread().isInterrupted()) {
-        			if(responseHandler != null) {
-        				responseHandler.sendResponseMessage(response);
-        			}
-        		} else{
-        			//TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
-        		}
-        	} catch (IOException e) {
-        		if(!Thread.currentThread().isInterrupted()) {
-        			throw e;
-        		}
-        	}
+        if (!Thread.currentThread().isInterrupted()) {
+            try {
+                HttpResponse response = client.execute(request, context);
+                if (!Thread.currentThread().isInterrupted()) {
+                    if (responseHandler != null) {
+                        responseHandler.sendResponseMessage(response);
+                    }
+                } else {
+                    //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
+                }
+            } catch (IOException e) {
+                if (!Thread.currentThread().isInterrupted()) {
+                    throw e;
+                }
+            }
         }
     }
 
@@ -102,18 +103,22 @@ private void makeRequestWithRetries() throws ConnectException {
                 makeRequest();
                 return;
             } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "can't resolve host");
+                }
+                return;
+            } catch (ConnectTimeoutException e) {
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "connection timed out");
+                }
+            } catch (SocketException e) {
                 // Added to detect host unreachable
-                if(responseHandler != null) {
+                if (responseHandler != null) {
                     responseHandler.sendFailureMessage(e, "can't resolve host");
                 }
                 return;
-            }catch (SocketTimeoutException e){
-                if(responseHandler != null) {
+            } catch (SocketTimeoutException e) {
+                if (responseHandler != null) {
                     responseHandler.sendFailureMessage(e, "socket time out");
                 }
                 return;
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
similarity index 86%
rename from src/com/loopj/android/http/AsyncHttpResponseHandler.java
rename to library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 24b4b278..d57fba7c 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,6 +21,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
@@ -32,15 +33,15 @@
 import java.io.IOException;
 
 /**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
  * designed to be anonymously overridden with your own response handling code.
- * <p>
+ * <p/>
  * Additionally, you can override the {@link #onFailure(Throwable, String)},
  * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p>
+ * <p/>
  * For example:
- * <p>
+ * <p/>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -53,7 +54,7 @@
  *     public void onSuccess(String response) {
  *         // Successfully got a response
  *     }
- * 
+ *
  *     &#064;Override
  *     public void onFailure(Throwable e, String response) {
  *         // Response failed :(
@@ -79,10 +80,10 @@
      */
     public AsyncHttpResponseHandler() {
         // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
+        if (Looper.myLooper() != null) {
+            handler = new Handler() {
                 @Override
-                public void handleMessage(Message msg){
+                public void handleMessage(Message msg) {
                     AsyncHttpResponseHandler.this.handleMessage(msg);
                 }
             };
@@ -97,24 +98,29 @@ public void handleMessage(Message msg){
     /**
      * Fired when the request is started, override to handle in your own code
      */
-    public void onStart() {}
+    public void onStart() {
+    }
 
     /**
      * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
      */
-    public void onFinish() {}
+    public void onFinish() {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param content the body of the HTTP response from the server
      */
-    public void onSuccess(String content) {}
+    public void onSuccess(String content) {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param content the body of the HTTP response from the server
+     * @param headers    the headers of the HTTP response
+     * @param content    the body of the HTTP response from the server
      */
     public void onSuccess(int statusCode, Header[] headers, String content) {
         onSuccess(statusCode, content);
@@ -122,25 +128,28 @@ public void onSuccess(int statusCode, Header[] headers, String content) {
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
+     * @param content    the body of the HTTP response from the server
      */
-    public void onSuccess(int statusCode, String content)
-    {
+    public void onSuccess(int statusCode, String content) {
         onSuccess(content);
     }
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
+     *
      * @param error the underlying cause of the failure
      * @deprecated use {@link #onFailure(Throwable, String)}
      */
     @Deprecated
-    public void onFailure(Throwable error) {}
+    public void onFailure(Throwable error) {
+    }
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
+     *
+     * @param error   the underlying cause of the failure
      * @param content the response body, if any
      */
     public void onFailure(Throwable error, String content) {
@@ -160,7 +169,7 @@ protected void sendSuccessMessage(int statusCode, Header[] headers, String respo
     protected void sendFailureMessage(Throwable e, String responseBody) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
     }
-    
+
     protected void sendFailureMessage(Throwable e, byte[] responseBody) {
         sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
     }
@@ -187,19 +196,18 @@ protected void handleFailureMessage(Throwable e, String responseBody) {
     }
 
 
-
     // Methods which emulate android's Handler and Message methods
     protected void handleMessage(Message msg) {
         Object[] response;
 
-        switch(msg.what) {
+        switch (msg.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
+                response = (Object[]) msg.obj;
                 handleSuccessMessage(((Integer) response[0]).intValue(), (Header[]) response[1], (String) response[2]);
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Throwable) response[0], (String) response[1]);
                 break;
             case START_MESSAGE:
                 onStart();
@@ -211,7 +219,7 @@ protected void handleMessage(Message msg) {
     }
 
     protected void sendMessage(Message msg) {
-        if(handler != null){
+        if (handler != null) {
             handler.sendMessage(msg);
         } else {
             handleMessage(msg);
@@ -220,9 +228,9 @@ protected void sendMessage(Message msg) {
 
     protected Message obtainMessage(int responseMessage, Object response) {
         Message msg = null;
-        if(handler != null){
+        if (handler != null) {
             msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
+        } else {
             msg = Message.obtain();
             msg.what = responseMessage;
             msg.obj = response;
@@ -231,21 +239,21 @@ protected Message obtainMessage(int responseMessage, Object response) {
     }
 
     // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
+    protected void sendResponseMessage(HttpResponse response) {
         StatusLine status = response.getStatusLine();
         String responseBody = null;
         try {
             HttpEntity entity = null;
             HttpEntity temp = response.getEntity();
-            if(temp != null) {
+            if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
                 responseBody = EntityUtils.toString(entity, "UTF-8");
             }
-        } catch(IOException e) {
+        } catch (IOException e) {
             sendFailureMessage(e, (String) null);
         }
 
-        if(status.getStatusCode() >= 300) {
+        if (status.getStatusCode() >= 300) {
             sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
             sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
similarity index 85%
rename from src/com/loopj/android/http/BinaryHttpResponseHandler.java
rename to library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 30d33f64..3265a467 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -32,12 +32,12 @@
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * {@link AsyncHttpClient}. Receives response body as byte array with a
+ * content-type whitelist. (e.g. checks Content-Type against allowed list,
  * Content-length).
- * <p>
+ * <p/>
  * For example:
- * <p>
+ * <p/>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * String[] allowedTypes = new String[] { "image/png" };
@@ -56,9 +56,9 @@
  */
 public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
     // Allow images by default
-    private static String[] mAllowedContentTypes = new String[] {
-        "image/jpeg",
-        "image/png"
+    private static String[] mAllowedContentTypes = new String[]{
+            "image/jpeg",
+            "image/png"
     };
 
     /**
@@ -84,12 +84,15 @@ public BinaryHttpResponseHandler(String[] allowedContentTypes) {
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param binaryData the body of the HTTP response from the server
      */
-    public void onSuccess(byte[] binaryData) {}
+    public void onSuccess(byte[] binaryData) {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param statusCode the status code of the response
      * @param binaryData the body of the HTTP response from the server
      */
@@ -99,7 +102,8 @@ public void onSuccess(int statusCode, byte[] binaryData) {
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
+     *
+     * @param error      the underlying cause of the failure
      * @param binaryData the response body, if any
      * @deprecated
      */
@@ -139,14 +143,14 @@ protected void handleFailureMessage(Throwable e, byte[] responseBody) {
     @Override
     protected void handleMessage(Message msg) {
         Object[] response;
-        switch(msg.what) {
+        switch (msg.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
+                response = (Object[]) msg.obj;
+                handleSuccessMessage((Integer) response[0], (byte[]) response[1]);
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (byte[]) response[1]);
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Throwable) response[0], (byte[]) response[1]);
                 break;
             default:
                 super.handleMessage(msg);
@@ -156,23 +160,23 @@ protected void handleMessage(Message msg) {
 
     // Interface to AsyncHttpRequest
     @Override
-    void sendResponseMessage(HttpResponse response) {
+    protected void sendResponseMessage(HttpResponse response) {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
         byte[] responseBody = null;
-        if(contentTypeHeaders.length != 1) {
+        if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
             sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
         boolean foundAllowedContentType = false;
-        for(String anAllowedContentType : mAllowedContentTypes) {
-            if(Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
+        for (String anAllowedContentType : mAllowedContentTypes) {
+            if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
                 foundAllowedContentType = true;
             }
         }
-        if(!foundAllowedContentType) {
+        if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
             sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
             return;
@@ -180,15 +184,15 @@ void sendResponseMessage(HttpResponse response) {
         try {
             HttpEntity entity = null;
             HttpEntity temp = response.getEntity();
-            if(temp != null) {
+            if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
             }
             responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
+        } catch (IOException e) {
             sendFailureMessage(e, (byte[]) null);
         }
 
-        if(status.getStatusCode() >= 300) {
+        if (status.getStatusCode() >= 300) {
             sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
             sendSuccessMessage(status.getStatusCode(), responseBody);
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..8b9d549f
--- /dev/null
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,96 @@
+package com.loopj.android.http;
+
+import android.os.Message;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private File mFile;
+
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        this.mFile = file;
+    }
+
+    public void onSuccess(File file) {
+    }
+
+    public void onSuccess(int statusCode, File file) {
+        onSuccess(file);
+    }
+
+    public void onFailure(Throwable e, File response) {
+    }
+
+
+    protected void sendSuccessMessage(int statusCode, File file) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, file}));
+    }
+
+    protected void sendFailureMessage(Throwable e, File file) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, file}));
+    }
+
+    protected void handleSuccessMessage(int statusCode, File responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(Throwable e, File responseBody) {
+        onFailure(e, responseBody);
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+        switch (msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[]) msg.obj;
+                handleSuccessMessage(((Integer) response[0]).intValue(), (File) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Throwable) response[0], (File) response[1]);
+                break;
+            default:
+                super.handleMessage(msg);
+                break;
+        }
+    }
+
+    @Override
+    protected void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+
+        try {
+            FileOutputStream buffer = new FileOutputStream(this.mFile);
+            InputStream is = response.getEntity().getContent();
+
+            int nRead;
+            byte[] data = new byte[16384];
+
+            while ((nRead = is.read(data, 0, data.length)) != -1)
+                buffer.write(data, 0, nRead);
+
+            buffer.flush();
+            buffer.close();
+
+        } catch (IOException e) {
+            sendFailureMessage(e, this.mFile);
+        }
+
+        if (status.getStatusCode() >= 300) {
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), this.mFile);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
similarity index 70%
rename from src/com/loopj/android/http/JsonHttpResponseHandler.java
rename to library/src/com/loopj/android/http/JsonHttpResponseHandler.java
index db022080..6019953d 100644
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -30,11 +30,11 @@
  * Used to intercept and handle the responses from requests made using
  * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
  * or {@link JSONArray}.
- * <p>
+ * <p/>
  * This class is designed to be passed to get, post, put and delete requests
  * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
  * methods anonymously overridden.
- * <p>
+ * <p/>
  * Additionally, you can override the other event methods from the
  * parent class.
  */
@@ -49,26 +49,31 @@
      * Fired when a request returns successfully and contains a json object
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param response the parsed json object found in the server response (if any)
      */
-    public void onSuccess(JSONObject response) {}
+    public void onSuccess(JSONObject response) {
+    }
 
 
     /**
      * Fired when a request returns successfully and contains a json array
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param response the parsed json array found in the server response (if any)
      */
-    public void onSuccess(JSONArray response) {}
+    public void onSuccess(JSONArray response) {
+    }
 
     /**
      * Fired when a request returns successfully and contains a json object
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param response the parsed json object found in the server response (if any)
+     * @param headers    the headers of the HTTP response
+     * @param response   the parsed json object found in the server response (if any)
      */
     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
         onSuccess(statusCode, response);
@@ -78,8 +83,9 @@ public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
      * Fired when a request returns successfully and contains a json object
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param statusCode the status code of the response
-     * @param response the parsed json object found in the server response (if any)
+     * @param response   the parsed json object found in the server response (if any)
      */
     public void onSuccess(int statusCode, JSONObject response) {
         onSuccess(response);
@@ -89,9 +95,10 @@ public void onSuccess(int statusCode, JSONObject response) {
      * Fired when a request returns successfully and contains a json array
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param statusCode the status code of the response
-     * @param headers the headers of the HTTP response
-     * @param response the parsed json array found in the server response (if any)
+     * @param headers    the headers of the HTTP response
+     * @param response   the parsed json array found in the server response (if any)
      */
     public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
         onSuccess(statusCode, response);
@@ -101,15 +108,19 @@ public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
      * Fired when a request returns successfully and contains a json array
      * at the base of the response string. Override to handle in your
      * own code.
+     *
      * @param statusCode the status code of the response
-     * @param response the parsed json array found in the server response (if any)
+     * @param response   the parsed json array found in the server response (if any)
      */
-    public void onSuccess(int statusCode,  JSONArray response) {
+    public void onSuccess(int statusCode, JSONArray response) {
         onSuccess(response);
     }
 
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
+    public void onFailure(Throwable e, JSONObject errorResponse) {
+    }
+
+    public void onFailure(Throwable e, JSONArray errorResponse) {
+    }
 
 
     //
@@ -118,16 +129,16 @@ public void onFailure(Throwable e, JSONArray errorResponse) {}
 
     @Override
     protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        if (statusCode != HttpStatus.SC_NO_CONTENT){        
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
             try {
                 Object jsonResponse = parseResponse(responseBody);
-	        sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
-    	    } catch(JSONException e) {
-    	        sendFailureMessage(e, responseBody);
-    	    }
+                sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+            } catch (JSONException e) {
+                sendFailureMessage(e, responseBody);
+            }
         } else {
             sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
-    	}
+        }
     }
 
 
@@ -137,37 +148,37 @@ protected void sendSuccessMessage(int statusCode, Header[] headers, String respo
 
     @Override
     protected void handleMessage(Message msg) {
-        switch(msg.what){
+        switch (msg.what) {
             case SUCCESS_JSON_MESSAGE:
                 Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage(((Integer) response[0]).intValue(),(Header[]) response[1] ,response[2]);
+                handleSuccessJsonMessage(((Integer) response[0]).intValue(), (Header[]) response[1], response[2]);
                 break;
             default:
                 super.handleMessage(msg);
         }
     }
 
-    protected void handleSuccessJsonMessage(int statusCode,Header[] headers, Object jsonResponse) {
-        if(jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, headers, (JSONObject)jsonResponse);
-        } else if(jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, headers, (JSONArray)jsonResponse);
+    protected void handleSuccessJsonMessage(int statusCode, Header[] headers, Object jsonResponse) {
+        if (jsonResponse instanceof JSONObject) {
+            onSuccess(statusCode, headers, (JSONObject) jsonResponse);
+        } else if (jsonResponse instanceof JSONArray) {
+            onSuccess(statusCode, headers, (JSONArray) jsonResponse);
         } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
+            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
         }
     }
 
     protected Object parseResponse(String responseBody) throws JSONException {
         Object result = null;
         //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-		responseBody = responseBody.trim();
-		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
-			result = new JSONTokener(responseBody).nextValue();
-		}
-		if (result == null) {
-			result = responseBody;
-		}
-		return result;
+        responseBody = responseBody.trim();
+        if (responseBody.startsWith("{") || responseBody.startsWith("[")) {
+            result = new JSONTokener(responseBody).nextValue();
+        }
+        if (result == null) {
+            result = responseBody;
+        }
+        return result;
     }
 
     @Override
@@ -175,17 +186,19 @@ protected void handleFailureMessage(Throwable e, String responseBody) {
         try {
             if (responseBody != null) {
                 Object jsonResponse = parseResponse(responseBody);
-                if(jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject)jsonResponse);
-                } else if(jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray)jsonResponse);
+                if (jsonResponse instanceof JSONObject) {
+                    onFailure(e, (JSONObject) jsonResponse);
+                } else if (jsonResponse instanceof JSONArray) {
+                    onFailure(e, (JSONArray) jsonResponse);
+                } else if (jsonResponse instanceof String) {
+                    onFailure(e, (String) jsonResponse);
                 } else {
                     onFailure(e, responseBody);
                 }
-            }else {
+            } else {
                 onFailure(e, "");
             }
-        }catch(JSONException ex) {
+        } catch (JSONException ex) {
             onFailure(e, responseBody);
         }
     }
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/com/loopj/android/http/PersistentCookieStore.java
similarity index 89%
rename from src/com/loopj/android/http/PersistentCookieStore.java
rename to library/src/com/loopj/android/http/PersistentCookieStore.java
index f6e39281..13228abb 100644
--- a/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/com/loopj/android/http/PersistentCookieStore.java
@@ -38,9 +38,9 @@
  * {@link CookieStore} interface. Cookies are stored and will persist on the
  * user's device between application sessions since they are serialized and
  * stored in {@link SharedPreferences}.
- * <p>
+ * <p/>
  * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
+ * {@link AsyncHttpClient#setCookieStore}, but can also be used with a
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
@@ -60,13 +60,13 @@ public PersistentCookieStore(Context context) {
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if(storedCookieNames != null) {
+        if (storedCookieNames != null) {
             String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for(String name : cookieNames) {
+            for (String name : cookieNames) {
                 String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if(encodedCookie != null) {
+                if (encodedCookie != null) {
                     Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if(decodedCookie != null) {
+                    if (decodedCookie != null) {
                         cookies.put(name, decodedCookie);
                     }
                 }
@@ -82,7 +82,7 @@ public void addCookie(Cookie cookie) {
         String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
-        if(!cookie.isExpired(new Date())) {
+        if (!cookie.isExpired(new Date())) {
             cookies.put(name, cookie);
         } else {
             cookies.remove(name);
@@ -99,7 +99,7 @@ public void addCookie(Cookie cookie) {
     public void clear() {
         // Clear cookies from persistent store
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for(String name : cookies.keySet()) {
+        for (String name : cookies.keySet()) {
             prefsWriter.remove(COOKIE_NAME_PREFIX + name);
         }
         prefsWriter.remove(COOKIE_NAME_STORE);
@@ -114,10 +114,10 @@ public boolean clearExpired(Date date) {
         boolean clearedAny = false;
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
 
-        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
             String name = entry.getKey();
             Cookie cookie = entry.getValue();
-            if(cookie.isExpired(date)) {
+            if (cookie.isExpired(date)) {
                 // Clear cookies from local store
                 cookies.remove(name);
 
@@ -130,7 +130,7 @@ public boolean clearExpired(Date date) {
         }
 
         // Update names in persistent store
-        if(clearedAny) {
+        if (clearedAny) {
             prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
         }
         prefsWriter.commit();
@@ -165,10 +165,10 @@ protected Cookie decodeCookie(String cookieStr) {
         ByteArrayInputStream is = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-           ObjectInputStream ois = new ObjectInputStream(is);
-           cookie = ((SerializableCookie)ois.readObject()).getCookie();
+            ObjectInputStream ois = new ObjectInputStream(is);
+            cookie = ((SerializableCookie) ois.readObject()).getCookie();
         } catch (Exception e) {
-           e.printStackTrace();
+            e.printStackTrace();
         }
 
         return cookie;
@@ -180,7 +180,7 @@ protected String byteArrayToHexString(byte[] b) {
         StringBuffer sb = new StringBuffer(b.length * 2);
         for (byte element : b) {
             int v = element & 0xff;
-            if(v < 16) {
+            if (v < 16) {
                 sb.append('0');
             }
             sb.append(Integer.toHexString(v));
@@ -191,9 +191,9 @@ protected String byteArrayToHexString(byte[] b) {
     protected byte[] hexStringToByteArray(String s) {
         int len = s.length();
         byte[] data = new byte[len / 2];
-        for(int i=0; i<len; i+=2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
similarity index 73%
rename from src/com/loopj/android/http/RequestParams.java
rename to library/src/com/loopj/android/http/RequestParams.java
index deb9cf15..794d374d 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -22,8 +22,11 @@
 import org.apache.http.client.entity.UrlEncodedFormEntity;
 import org.apache.http.client.utils.URLEncodedUtils;
 import org.apache.http.message.BasicNameValuePair;
-
-import java.io.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -33,9 +36,9 @@
 /**
  * A collection of string request parameters or files to send along with
  * requests made from an {@link AsyncHttpClient} instance.
- * <p>
+ * <p/>
  * For example:
- * <p>
+ * <p/>
  * <pre>
  * RequestParams params = new RequestParams();
  * params.put("username", "james");
@@ -66,12 +69,13 @@ public RequestParams() {
     /**
      * Constructs a new RequestParams instance containing the key/value
      * string params from the specified map.
+     *
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
         init();
 
-        for(Map.Entry<String, String> entry : source.entrySet()) {
+        for (Map.Entry<String, String> entry : source.entrySet()) {
             put(entry.getKey(), entry.getValue());
         }
     }
@@ -79,7 +83,8 @@ public RequestParams(Map<String, String> source) {
     /**
      * Constructs a new RequestParams instance and populate it with a single
      * initial key/value string param.
-     * @param key the key name for the intial param.
+     *
+     * @param key   the key name for the intial param.
      * @param value the value string for the initial param.
      */
     public RequestParams(String key, String value) {
@@ -91,36 +96,51 @@ public RequestParams(String key, String value) {
     /**
      * Constructs a new RequestParams instance and populate it with multiple
      * initial key/value string param.
+     *
      * @param keysAndValues a sequence of keys and values. Objects are
-     * automatically converted to Strings (including the value {@code null}).
+     *                      automatically converted to Strings (including the value {@code null}).
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
+        init();
+        int len = keysAndValues.length;
+        if (len % 2 != 0)
+            throw new IllegalArgumentException("Supplied arguments must be even");
+        for (int i = 0; i < len; i += 2) {
+            String key = String.valueOf(keysAndValues[i]);
+            String val = String.valueOf(keysAndValues[i + 1]);
+            put(key, val);
+        }
     }
 
     /**
      * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key   the key name for the new param.
      * @param value the value string for the new param.
      */
-    public void put(String key, String value){
-        if(key != null && value != null) {
+    public void put(String key, String value) {
+        if (key != null && value != null) {
             urlParams.put(key, value);
         }
     }
 
+    /**
+     * Adds a integer param to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the integer value for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds a file to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key  the key name for the new param.
      * @param file the file to add.
      */
     public void put(String key, File file) throws FileNotFoundException {
@@ -129,22 +149,24 @@ public void put(String key, File file) throws FileNotFoundException {
 
     /**
      * Adds param with more than one value.
-     * @param key the key name for the new param.
+     *
+     * @param key    the key name for the new param.
      * @param values is the ArrayList with values for the param.
      */
-    public void put(String key, ArrayList<String> values)  {
-        if(key != null && values != null) {
+    public void put(String key, ArrayList<String> values) {
+        if (key != null && values != null) {
             urlParamsWithArray.put(key, values);
         }
     }
 
     /**
      * Adds value to param which can have more than one value.
-     * @param key the key name for the param, either existing or new.
+     *
+     * @param key   the key name for the param, either existing or new.
      * @param value the value string for the new param.
      */
     public void add(String key, String value) {
-        if(key != null && value != null) {
+        if (key != null && value != null) {
             ArrayList<String> paramArray = urlParamsWithArray.get(key);
             if (paramArray == null) {
                 paramArray = new ArrayList<String>();
@@ -156,7 +178,8 @@ public void add(String key, String value) {
 
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key    the key name for the new param.
      * @param stream the input stream to add.
      */
     public void put(String key, InputStream stream) {
@@ -165,8 +188,9 @@ public void put(String key, InputStream stream) {
 
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
+     *
+     * @param key      the key name for the new param.
+     * @param stream   the input stream to add.
      * @param fileName the name of the file.
      */
     public void put(String key, InputStream stream, String fileName) {
@@ -175,22 +199,24 @@ public void put(String key, InputStream stream, String fileName) {
 
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param fileName    the name of the file.
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
+        if (key != null && stream != null) {
             fileParams.put(key, new FileWrapper(stream, fileName, contentType));
         }
     }
 
     /**
      * Removes a parameter from the request.
+     *
      * @param key the key name for the parameter to remove.
      */
-    public void remove(String key){
+    public void remove(String key) {
         urlParams.remove(key);
         fileParams.remove(key);
         urlParamsWithArray.remove(key);
@@ -199,8 +225,8 @@ public void remove(String key){
     @Override
     public String toString() {
         StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            if (result.length() > 0)
                 result.append("&");
 
             result.append(entry.getKey());
@@ -208,8 +234,8 @@ public String toString() {
             result.append(entry.getValue());
         }
 
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if (result.length() > 0)
                 result.append("&");
 
             result.append(entry.getKey());
@@ -217,8 +243,8 @@ public String toString() {
             result.append("FILE");
         }
 
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-            if(result.length() > 0)
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            if (result.length() > 0)
                 result.append("&");
 
             ArrayList<String> values = entry.getValue();
@@ -234,22 +260,22 @@ public String toString() {
         return result.toString();
     }
 
-   /**
+    /**
      * Returns an HttpEntity containing all request parameters
      */
     public HttpEntity getEntity() {
         HttpEntity entity = null;
 
-        if(!fileParams.isEmpty()) {
+        if (!fileParams.isEmpty()) {
             SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
 
             // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
                 multipartEntity.addPart(entry.getKey(), entry.getValue());
             }
 
             // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
                 ArrayList<String> values = entry.getValue();
                 for (String value : values) {
                     multipartEntity.addPart(entry.getKey(), value);
@@ -259,11 +285,11 @@ public HttpEntity getEntity() {
             // Add file params
             int currentIndex = 0;
             int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
                 FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
+                if (file.inputStream != null) {
                     boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
+                    if (file.contentType != null) {
                         multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
                     } else {
                         multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
@@ -284,7 +310,7 @@ public HttpEntity getEntity() {
         return entity;
     }
 
-    private void init(){
+    private void init() {
         urlParams = new ConcurrentHashMap<String, String>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
         urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
@@ -293,11 +319,11 @@ private void init(){
     protected List<BasicNameValuePair> getParamsList() {
         List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
         }
 
-        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
             ArrayList<String> values = entry.getValue();
             for (String value : values) {
                 lparams.add(new BasicNameValuePair(entry.getKey(), value));
@@ -323,7 +349,7 @@ public FileWrapper(InputStream inputStream, String fileName, String contentType)
         }
 
         public String getFileName() {
-            if(fileName != null) {
+            if (fileName != null) {
                 return fileName;
             } else {
                 return "nofilename";
diff --git a/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
similarity index 90%
rename from src/com/loopj/android/http/RetryHandler.java
rename to library/src/com/loopj/android/http/RetryHandler.java
index de0ed1c8..b7459fb1 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -29,7 +29,6 @@
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
-
 import javax.net.ssl.SSLException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -37,6 +36,7 @@
 import java.net.UnknownHostException;
 import java.util.HashSet;
 import java.util.Iterator;
+import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
     private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
@@ -70,7 +70,7 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
         boolean sent = (b != null && b.booleanValue());
 
-        if(executionCount > maxRetries) {
+        if (executionCount > maxRetries) {
             // Do not retry if over max retry count
             retry = false;
         } else if (isInList(exceptionBlacklist, exception)) {
@@ -84,14 +84,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             retry = true;
         }
 
-        if(retry) {
+        if (retry) {
             // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
+            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
             String requestType = currentReq.getMethod();
             retry = !requestType.equals("POST");
         }
 
-        if(retry) {
+        if (retry) {
             SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
         } else {
             exception.printStackTrace();
@@ -99,14 +99,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
 
         return retry;
     }
-    
+
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-    	Iterator<Class<?>> itr = list.iterator();
-    	while (itr.hasNext()) {
-    		if (itr.next().isInstance(error)) {
-    			return true;
-    		}
-    	}
-    	return false;
+        Iterator<Class<?>> itr = list.iterator();
+        while (itr.hasNext()) {
+            if (itr.next().isInstance(error)) {
+                return true;
+            }
+        }
+        return false;
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/library/src/com/loopj/android/http/SerializableCookie.java
similarity index 85%
rename from src/com/loopj/android/http/SerializableCookie.java
rename to library/src/com/loopj/android/http/SerializableCookie.java
index f3ac72b0..d9730d21 100644
--- a/src/com/loopj/android/http/SerializableCookie.java
+++ b/library/src/com/loopj/android/http/SerializableCookie.java
@@ -43,7 +43,7 @@ public SerializableCookie(Cookie cookie) {
 
     public Cookie getCookie() {
         Cookie bestCookie = cookie;
-        if(clientCookie != null) {
+        if (clientCookie != null) {
             bestCookie = clientCookie;
         }
         return bestCookie;
@@ -61,13 +61,13 @@ private void writeObject(ObjectOutputStream out) throws IOException {
     }
 
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String)in.readObject();
-        String value = (String)in.readObject();
+        String name = (String) in.readObject();
+        String value = (String) in.readObject();
         clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String)in.readObject());
-        clientCookie.setDomain((String)in.readObject());
-        clientCookie.setExpiryDate((Date)in.readObject());
-        clientCookie.setPath((String)in.readObject());
+        clientCookie.setComment((String) in.readObject());
+        clientCookie.setDomain((String) in.readObject());
+        clientCookie.setExpiryDate((Date) in.readObject());
+        clientCookie.setPath((String) in.readObject());
         clientCookie.setVersion(in.readInt());
         clientCookie.setSecure(in.readBoolean());
     }
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
similarity index 85%
rename from src/com/loopj/android/http/SimpleMultipartEntity.java
rename to library/src/com/loopj/android/http/SimpleMultipartEntity.java
index 13d02f25..ec475d30 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -26,8 +26,14 @@
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.message.BasicHeader;
-
-import java.io.*;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.Random;
 
 class SimpleMultipartEntity implements HttpEntity {
@@ -49,8 +55,8 @@ public SimpleMultipartEntity() {
 
     }
 
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
+    public void writeFirstBoundaryIfNeeds() {
+        if (!isSetFirst) {
             writeBoundary();
         }
 
@@ -66,7 +72,7 @@ public void writeBoundary() {
     }
 
     public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
+        if (isSetLast) {
             return;
         }
 
@@ -76,14 +82,14 @@ public void writeLastBoundaryIfNeeds() {
         } catch (final IOException e) {
             e.printStackTrace();
         }
-        
+
         isSetLast = true;
     }
 
     public void addPart(final String key, final String value, final String contentType) {
         writeBoundary();
         try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n").getBytes());
+            out.write(("Content-Disposition: form-data; name=\"" + key + "\"\r\n").getBytes());
             out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
             out.write(value.getBytes());
             out.write(("\r\n").getBytes());
@@ -93,18 +99,18 @@ public void addPart(final String key, final String value, final String contentTy
     }
 
     public void addPart(final String key, final String value) {
-        addPart(key,value,"text/plain; charset=UTF-8");
+        addPart(key, value, "text/plain; charset=UTF-8");
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
+    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast) {
         addPart(key, fileName, fin, "application/octet-stream", isLast);
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
+    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast) {
         writeBoundary();
         try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
+            type = "Content-Type: " + type + "\r\n";
+            out.write(("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n").getBytes());
             out.write(type.getBytes());
             out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
 
@@ -114,7 +120,7 @@ public void addPart(final String key, final String fileName, final InputStream f
                 out.write(tmp, 0, l);
             }
             out.write(("\r\n").getBytes());
-            
+
         } catch (final IOException e) {
             e.printStackTrace();
         } finally {
@@ -173,17 +179,17 @@ public Header getContentEncoding() {
 
     @Override
     public void consumeContent() throws IOException,
-    UnsupportedOperationException {
+            UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
+                    "Streaming entity does not implement #consumeContent()");
         }
     }
 
     @Override
     public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-    	writeLastBoundaryIfNeeds();
+            UnsupportedOperationException {
+        writeLastBoundaryIfNeeds();
         return new ByteArrayInputStream(out.toByteArray());
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
new file mode 100644
index 00000000..8b775098
--- /dev/null
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -0,0 +1,125 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.os.Message;
+
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public abstract class SyncHttpClient extends AsyncHttpClient {
+    private int responseCode;
+    /*
+     * as this is a synchronous request this is just a helping mechanism to pass
+     * the result back to this method. Therefore the result object has to be a
+     * field to be accessible
+     */
+    protected String result;
+    protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
+
+        @Override
+        protected void sendResponseMessage(org.apache.http.HttpResponse response) {
+            responseCode = response.getStatusLine().getStatusCode();
+            super.sendResponseMessage(response);
+        }
+
+        ;
+
+        @Override
+        protected void sendMessage(Message msg) {
+            /*
+			 * Dont use the handler and send it directly to the analysis
+			 * (because its all the same thread)
+			 */
+            handleMessage(msg);
+        }
+
+        @Override
+        public void onSuccess(String content) {
+            result = content;
+        }
+
+        @Override
+        public void onFailure(Throwable error, String content) {
+            result = onRequestFailed(error, content);
+        }
+    };
+
+    /**
+     * @return the response code for the last request, might be usefull
+     * sometimes
+     */
+    public int getResponseCode() {
+        return responseCode;
+    }
+
+    // Private stuff
+    @Override
+    protected void sendRequest(DefaultHttpClient client,
+                               HttpContext httpContext, HttpUriRequest uriRequest,
+                               String contentType, AsyncHttpResponseHandler responseHandler,
+                               Context context) {
+        if (contentType != null) {
+            uriRequest.addHeader("Content-Type", contentType);
+        }
+
+		/*
+		 * will execute the request directly
+		 */
+        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
+                .run();
+    }
+
+    public abstract String onRequestFailed(Throwable error, String content);
+
+    public void delete(String url, RequestParams queryParams,
+                       AsyncHttpResponseHandler responseHandler) {
+        // TODO what about query params??
+        delete(url, responseHandler);
+    }
+
+    public String get(String url, RequestParams params) {
+        this.get(url, params, responseHandler);
+		/*
+		 * the response handler will have set the result when this line is
+		 * reached
+		 */
+        return result;
+    }
+
+    public String get(String url) {
+        this.get(url, null, responseHandler);
+        return result;
+    }
+
+    public String put(String url, RequestParams params) {
+        this.put(url, params, responseHandler);
+        return result;
+    }
+
+    public String put(String url) {
+        this.put(url, null, responseHandler);
+        return result;
+    }
+
+    public String post(String url, RequestParams params) {
+        this.post(url, params, responseHandler);
+        return result;
+    }
+
+    public String post(String url) {
+        this.post(url, null, responseHandler);
+        return result;
+    }
+
+    public String delete(String url, RequestParams params) {
+        this.delete(url, params, responseHandler);
+        return result;
+    }
+
+    public String delete(String url) {
+        this.delete(url, null, responseHandler);
+        return result;
+    }
+
+}
diff --git a/project.properties b/project.properties
deleted file mode 100644
index 1880987e..00000000
--- a/project.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-3
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..e469038a
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include 'library'
