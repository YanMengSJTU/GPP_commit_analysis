diff --git a/lint.xml b/lint.xml
new file mode 100644
index 00000000..ee0eead5
--- /dev/null
+++ b/lint.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 7d675a59..0422b8d9 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -14,11 +14,12 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-*/
+ */
 
 package com.loopj.android.http;
 
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.regex.Pattern;
 
 import org.apache.http.Header;
@@ -26,173 +27,248 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
 
 import android.os.Message;
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * {@link AsyncHttpClient}. Receives response body as byte array with a
+ * content-type whitelist. (e.g. checks Content-Type against allowed list,
  * Content-length).
  * <p>
  * For example:
  * <p>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
- * String[] allowedTypes = new String[] { "image/png" };
- * client.get("http://www.example.com/image.png", new BinaryHttpResponseHandler(allowedTypes) {
- *     &#064;Override
- *     public void onSuccess(byte[] imageData) {
- *         // Successfully got a response
- *     }
- *
- *     &#064;Override
- *     public void onFailure(Throwable e, byte[] imageData) {
- *         // Response failed :(
- *     }
+ * String[] allowedTypes = new String[]
+ * { &quot;image/png&quot; };
+ * client.get(&quot;http://www.example.com/image.png&quot;, new BinaryHttpResponseHandler(allowedTypes)
+ * {
+ * 	&#064;Override
+ * 	public void onSuccess(byte[] imageData)
+ * 	{
+ * 		// Successfully got a response
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onFailure(Throwable e, byte[] imageData)
+ * 	{
+ * 		// Response failed :(
+ * 	}
  * });
  * </pre>
  */
-public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
-    // Allow images by default
-    private static String[] mAllowedContentTypes = new String[] {
-        "image/jpeg",
-        "image/png"
-    };
-
-    /**
-     * Creates a new BinaryHttpResponseHandler
-     */
-    public BinaryHttpResponseHandler() {
-        super();
-    }
-
-    /**
-     * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
-     * content types with passed String array (hopefully) of content types.
-     */
-    public BinaryHttpResponseHandler(String[] allowedContentTypes) {
-        this();
-        mAllowedContentTypes = allowedContentTypes;
-    }
-
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(byte[] binaryData) {}
-
-    /**
-     * Fired when a request returns successfully, override to handle in your own code
-     * @param statusCode the status code of the response
-     * @param binaryData the body of the HTTP response from the server
-     */
-    public void onSuccess(int statusCode, byte[] binaryData) {
-        onSuccess(binaryData);
-    }
-
-    /**
-     * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
-     * @param binaryData the response body, if any
-     * @deprecated
-     */
-    @Deprecated
-    public void onFailure(Throwable error, byte[] binaryData) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
-    }
-
-    @Override
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
-    }
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    @Override
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch(msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], response[1].toString());
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
-
-    // Interface to AsyncHttpRequest
-    @Override
-    void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-        Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        byte[] responseBody = null;
-        if(contentTypeHeaders.length != 1) {
-            //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
-            return;
-        }
-        Header contentTypeHeader = contentTypeHeaders[0];
-        boolean foundAllowedContentType = false;
-        for(String anAllowedContentType : mAllowedContentTypes) {
-            if(Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
-                foundAllowedContentType = true;
-            }
-        }
-        if(!foundAllowedContentType) {
-            //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
-            return;
-        }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if(temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, (byte[]) null);
-        }
-
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
-    }
+public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler
+{
+	private static final int PROGRESS_CHANGE_MESSAGE = 6;
+	private static final int DEFAULT_BUF_SIZE = 1024*1024;
+	
+	// Allow all contentType
+	private static String[] mAllowedContentTypes = null;
+
+	/**
+	 * Creates a new BinaryHttpResponseHandler
+	 */
+	public BinaryHttpResponseHandler()
+	{
+		super();
+	}
+
+	/**
+	 * Creates a new BinaryHttpResponseHandler, and overrides the default
+	 * allowed content types with passed String array (hopefully) of content
+	 * types.
+	 */
+	public BinaryHttpResponseHandler(String[] allowedContentTypes)
+	{
+		this();
+		mAllowedContentTypes = allowedContentTypes;
+	}
+	
+	public void onDidDownload(int statusCode, byte[] downloaded, long lenght) throws IOException
+	{
+	}
+	
+	public void onProgressDidChange(int statusCode, long lenght, long totalLenght)
+	{
+	}
+
+	//
+	// Callbacks to be overridden, typically anonymously
+	//
+
+	/**
+	 * Fired when a request returns successfully, override to handle in your own
+	 * code
+	 * 
+	 * @param binaryData
+	 *            the body of the HTTP response from the server
+	 */
+	public void onSuccess(byte[] binaryData)
+	{
+	}
+
+	/**
+	 * Fired when a request returns successfully, override to handle in your own
+	 * code
+	 * 
+	 * @param statusCode
+	 *            the status code of the response
+	 * @param binaryData
+	 *            the body of the HTTP response from the server
+	 */
+	public void onSuccess(int statusCode, byte[] binaryData)
+	{
+		onSuccess(binaryData);
+	}
+
+	/**
+	 * Fired when a request fails to complete, override to handle in your own
+	 * code
+	 * 
+	 * @param error
+	 *            the underlying cause of the failure
+	 * @param binaryData
+	 *            the response body, if any
+	 * @deprecated
+	 */
+	@Deprecated
+	public void onFailure(Throwable error, byte[] binaryData)
+	{
+		// By default, call the deprecated onFailure(Throwable) for
+		// compatibility
+		onFailure(error);
+	}
+	
+	protected void sendProgressChangeMessage(int statusCode, long length, long totalLength)
+	{
+		sendMessage(obtainMessage(PROGRESS_CHANGE_MESSAGE, new Object[]
+		{ statusCode, length, totalLength }));
+	}
+
+	//
+	// Pre-processing of messages (executes in background threadpool thread)
+	//
+
+	protected void sendSuccessMessage(int statusCode, byte[] responseBody)
+	{
+		sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]
+		{ statusCode, responseBody }));
+	}
+
+	@Override
+	protected void sendFailureMessage(Throwable e, byte[] responseBody)
+	{
+		sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]
+		{ e, responseBody }));
+	}
+
+	//
+	// Pre-processing of messages (in original calling thread, typically the UI
+	// thread)
+	//
+
+	protected void handleSuccessMessage(int statusCode, byte[] responseBody)
+	{
+		onSuccess(statusCode, responseBody);
+	}
+
+	protected void handleFailureMessage(Throwable e, byte[] responseBody)
+	{
+		onFailure(e, responseBody);
+	}
+
+	// Methods which emulate android's Handler and Message methods
+	@Override
+	protected void handleMessage(Message msg)
+	{
+		Object[] response;
+		switch (msg.what)
+		{
+		
+		case PROGRESS_CHANGE_MESSAGE:
+			response = (Object[]) msg.obj;
+			onProgressDidChange(((Number)(response[0])).intValue(), ((Number)(response[1])).longValue(), ((Number)(response[2])).longValue());
+			break;
+		case SUCCESS_MESSAGE:
+			response = (Object[]) msg.obj;
+			handleSuccessMessage(((Integer) response[0]).intValue(), (byte[]) response[1]);
+			break;
+		case FAILURE_MESSAGE:
+			response = (Object[]) msg.obj;	
+			handleFailureMessage((Throwable) response[0], response[1].toString());
+			break;
+		default:
+			super.handleMessage(msg);
+			break;
+		}
+	}
+
+	// Interface to AsyncHttpRequest
+	@Override
+	void sendResponseMessage(HttpResponse response)
+	{
+		StatusLine status = response.getStatusLine();
+		Header[] contentTypeHeaders = response.getHeaders("Content-Type");
+		byte[] responseBody = new byte[0];
+		if (contentTypeHeaders.length != 1)
+		{
+			// malformed/ambiguous HTTP Header, ABORT!
+			sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+			return;
+		}
+		Header contentTypeHeader = contentTypeHeaders[0];
+		boolean foundAllowedContentType = true;
+		if (mAllowedContentTypes != null)
+		{
+			foundAllowedContentType = false;
+			for (String anAllowedContentType : mAllowedContentTypes)
+			{
+				if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue()))
+				{
+					foundAllowedContentType = true;
+				}
+			}
+		}
+		if (!foundAllowedContentType)
+		{
+			// Content-Type not in allowed list, ABORT!
+			sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+			return;
+		}
+		try
+		{
+			int statusCode = status.getStatusCode();
+			HttpEntity temp = response.getEntity();
+			if (temp != null)
+			{
+				InputStream stream = temp.getContent();
+				byte[] beffer = new byte[DEFAULT_BUF_SIZE];
+				long totalLength = temp.getContentLength();
+				int readedBytes = 0;
+				int allReadBytes = 0; 
+				while((readedBytes = stream.read(beffer)) != -1)
+				{
+					onDidDownload(statusCode, beffer, readedBytes);
+					allReadBytes += readedBytes;
+					sendProgressChangeMessage(statusCode, allReadBytes, totalLength);
+				}
+				sendSuccessMessage(statusCode, responseBody);
+			}
+		}
+		catch (IOException e)
+		{
+			sendFailureMessage(e, (byte[]) null);
+		}
+
+		if (status.getStatusCode() >= 300)
+		{
+			sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+		}
+		else
+		{
+			sendSuccessMessage(status.getStatusCode(), responseBody);
+		}
+	}
 }
\ No newline at end of file
