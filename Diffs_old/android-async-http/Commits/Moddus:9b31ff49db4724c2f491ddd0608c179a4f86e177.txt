diff --git a/.travis.yml b/.travis.yml
index 20458a51..a7560a7b 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -38,4 +38,6 @@ before_install:
   # verify files exist in right paths
   - find $ANDROID_HOME/build-tools
   - file $ANDROID_HOME/build-tools/18.0.1/aapt
-  # - mvn clean test install
+  - echo "nexusUsername=dummy" >> library/gradle.properties
+  - echo "nexusPassword=dummy" >> library/gradle.properties
+
diff --git a/README.md b/README.md
index 3d7bd95e..a576fb38 100644
--- a/README.md
+++ b/README.md
@@ -19,6 +19,30 @@ Features
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
 - Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
 
+Maven
+-----
+You can now integrate this library in your project via Maven. There are available two kind of builds.
+
+**development snapshots**
+https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
+```
+Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
+GroupId: com.loopj.android
+ArtifactId: async-http-client
+Version: 1.4.4-SNAPSHOT
+Packaging: JAR or AAR
+```
+
+**releases, maven central**
+
+http://central.maven.org/maven2/com/loopj/android/android-async-http/
+```
+Maven URL: http://repo1.maven.org/maven2/
+GroupId: com.loopj.android
+ArtifactId: async-http-client
+Version: 1.4.3
+Packaging: JAR or AAR
+```
 
 Documentation, Features and Examples
 ------------------------------------
diff --git a/build.gradle b/build.gradle
index 6dbebcf5..d239f5ad 100644
--- a/build.gradle
+++ b/build.gradle
@@ -8,6 +8,10 @@ buildscript {
     }
 }
 
+def isReleaseBuild() {
+    return version.contains("SNAPSHOT") == false
+}
+
 allprojects {
     group = 'com.loopj.android'
     version = '1.4.4-SNAPSHOT'
@@ -20,3 +24,5 @@ allprojects {
         options.encoding = "UTF-8"
     }
 }
+
+apply plugin: 'android-reporting'
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
new file mode 100644
index 00000000..998daa1f
--- /dev/null
+++ b/examples/CookieVideoView.java
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.media.MediaPlayer.OnCompletionListener;
+import android.media.MediaPlayer.OnErrorListener;
+import android.media.MediaPlayer.OnInfoListener;
+import android.net.Uri;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.widget.MediaController;
+import android.widget.MediaController.MediaPlayerControl;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.http.cookie.Cookie;
+
+/**
+ * Displays a video file.  The VideoView class
+ * can load images from various sources (such as resources or content
+ * providers), takes care of computing its measurement from the video so that
+ * it can be used in any layout manager, and provides various display options
+ * such as scaling and tinting.
+ *
+ * @author Jungho Bang <me@bangtoven.com>
+ */
+public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
+    private String TAG = "CookieVideoView";
+    // settable by the client
+    private Uri         mUri;
+    private Map<String, String> mHeaders;
+
+    // all possible internal states
+    private static final int STATE_ERROR              = -1;
+    private static final int STATE_IDLE               = 0;
+    private static final int STATE_PREPARING          = 1;
+    private static final int STATE_PREPARED           = 2;
+    private static final int STATE_PLAYING            = 3;
+    private static final int STATE_PAUSED             = 4;
+    private static final int STATE_PLAYBACK_COMPLETED = 5;
+
+    // mCurrentState is a VideoView object's current state.
+    // mTargetState is the state that a method caller intends to reach.
+    // For instance, regardless the VideoView object's current state,
+    // calling pause() intends to bring the object to a target state
+    // of STATE_PAUSED.
+    private int mCurrentState = STATE_IDLE;
+    private int mTargetState  = STATE_IDLE;
+
+    // All the stuff we need for playing and showing a video
+    private SurfaceHolder mSurfaceHolder = null;
+    private MediaPlayer mMediaPlayer = null;
+    private int         mVideoWidth;
+    private int         mVideoHeight;
+    private int         mSurfaceWidth;
+    private int         mSurfaceHeight;
+    private MediaController mMediaController;
+    private OnCompletionListener mOnCompletionListener;
+    private MediaPlayer.OnPreparedListener mOnPreparedListener;
+    private int         mCurrentBufferPercentage;
+    private OnErrorListener mOnErrorListener;
+    private OnInfoListener  mOnInfoListener;
+    private int         mSeekWhenPrepared;  // recording the seek position while preparing
+    private boolean     mCanPause;
+    private boolean     mCanSeekBack;
+    private boolean     mCanSeekForward;
+	private Context 	mContext;
+
+    public CookieVideoView(Context context) {
+        super(context);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initVideoView(context);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        //Log.i("@@@@", "onMeasure");
+        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
+        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
+        if (mVideoWidth > 0 && mVideoHeight > 0) {
+            if ( mVideoWidth * height  > width * mVideoHeight ) {
+                //Log.i("@@@", "image too tall, correcting");
+                height = width * mVideoHeight / mVideoWidth;
+            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
+                //Log.i("@@@", "image too wide, correcting");
+                width = height * mVideoWidth / mVideoHeight;
+            } else {
+                //Log.i("@@@", "aspect ratio is correct: " +
+                        //width+"/"+height+"="+
+                        //mVideoWidth+"/"+mVideoHeight);
+            }
+        }
+        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
+        setMeasuredDimension(width, height);
+    }
+
+    @SuppressLint("NewApi")
+	@Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(CookieVideoView.class.getName());
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+	@Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(CookieVideoView.class.getName());
+    }
+
+    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
+        int result = desiredSize;
+        int specMode = MeasureSpec.getMode(measureSpec);
+        int specSize =  MeasureSpec.getSize(measureSpec);
+
+        switch (specMode) {
+            case MeasureSpec.UNSPECIFIED:
+                /* Parent says we can be as big as we want. Just don't be larger
+                 * than max size imposed on ourselves.
+                 */
+                result = desiredSize;
+                break;
+
+            case MeasureSpec.AT_MOST:
+                /* Parent says we can be as big as we want, up to specSize.
+                 * Don't be larger than specSize, and don't be larger than
+                 * the max size imposed on ourselves.
+                 */
+                result = Math.min(desiredSize, specSize);
+                break;
+
+            case MeasureSpec.EXACTLY:
+                // No choice. Do what we are told.
+                result = specSize;
+                break;
+        }
+        return result;
+}
+
+    private void initVideoView(Context context) {
+        mVideoWidth = 0;
+        mVideoHeight = 0;
+        getHolder().addCallback(mSHCallback);
+        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        mCurrentState = STATE_IDLE;
+        mTargetState  = STATE_IDLE;
+        mContext = context;
+    }
+
+    public void setVideoPath(String path) {
+        setVideoURI(Uri.parse(path));
+    }
+
+    public void setVideoURI(Uri uri) {
+    	mUri = uri;
+        mHeaders = getCookieHeader();
+    	mSeekWhenPrepared = 0;
+        openVideo();
+        requestLayout();
+        invalidate();
+    }
+    
+    private Map<String,String> getCookieHeader() {
+    	String hostDomain = mUri.getHost();
+    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
+    	for(Cookie cookie : cookieList) {
+    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
+    			Map<String,String> header = new HashMap<String, String>();
+    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
+    	    	Log.d(TAG,"Cookie: "+header.toString());
+    	        return header;
+    	    }
+    	}
+    	return null;
+    }
+    
+    public void stopPlayback() {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.stop();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            mTargetState  = STATE_IDLE;
+        }
+    }
+
+    private void openVideo() {
+        if (mUri == null || mSurfaceHolder == null) {
+            // not ready for playback just yet, will try again later
+            return;
+        }
+        // Tell the music playback service to pause
+        // TODO: these constants need to be published somewhere in the framework.
+        Intent i = new Intent("com.android.music.musicservicecommand");
+        i.putExtra("command", "pause");
+        mContext.sendBroadcast(i);
+
+        // we shouldn't clear the target state, because somebody might have
+        // called start() previously
+        release(false);
+        try {
+            mMediaPlayer = new MediaPlayer();
+            mMediaPlayer.setOnPreparedListener(mPreparedListener);
+            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
+            mMediaPlayer.setOnCompletionListener(mCompletionListener);
+            mMediaPlayer.setOnErrorListener(mErrorListener);
+            mMediaPlayer.setOnInfoListener(mOnInfoListener);
+            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
+            mCurrentBufferPercentage = 0;
+            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
+            mMediaPlayer.setDisplay(mSurfaceHolder);
+            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mMediaPlayer.setScreenOnWhilePlaying(true);
+            mMediaPlayer.prepareAsync();
+            // we don't set the target state here either, but preserve the
+            // target state that was there before.
+            mCurrentState = STATE_PREPARING;
+            attachMediaController();
+        } catch (IOException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        } catch (IllegalArgumentException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        }
+    }
+
+    public void setMediaController(MediaController controller) {
+        if (mMediaController != null) {
+            mMediaController.hide();
+        }
+        mMediaController = controller;
+        attachMediaController();
+    }
+
+    private void attachMediaController() {
+        if (mMediaPlayer != null && mMediaController != null) {
+            mMediaController.setMediaPlayer(this);
+            View anchorView = this.getParent() instanceof View ?
+                    (View)this.getParent() : this;
+            mMediaController.setAnchorView(anchorView);
+            mMediaController.setEnabled(isInPlaybackState());
+        }
+    }
+
+    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
+        new MediaPlayer.OnVideoSizeChangedListener() {
+            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
+                mVideoWidth = mp.getVideoWidth();
+                mVideoHeight = mp.getVideoHeight();
+                if (mVideoWidth != 0 && mVideoHeight != 0) {
+                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                    requestLayout();
+                }
+            }
+    };
+
+    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
+        public void onPrepared(MediaPlayer mp) {
+            mCurrentState = STATE_PREPARED;
+
+            // Get the capabilities of the player for this stream
+//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
+//                                      MediaPlayer.BYPASS_METADATA_FILTER);
+//            
+//          if (data != null) {
+//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
+//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
+//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
+//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
+//            } else {
+                mCanPause = mCanSeekBack = mCanSeekForward = true;
+//            }
+
+            if (mOnPreparedListener != null) {
+                mOnPreparedListener.onPrepared(mMediaPlayer);
+            }
+            if (mMediaController != null) {
+                mMediaController.setEnabled(true);
+            }
+            mVideoWidth = mp.getVideoWidth();
+            mVideoHeight = mp.getVideoHeight();
+
+            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
+            if (seekToPosition != 0) {
+                seekTo(seekToPosition);
+            }
+            if (mVideoWidth != 0 && mVideoHeight != 0) {
+                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
+                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
+                    // We didn't actually change the size (it was already at the size
+                    // we need), so we won't get a "surface changed" callback, so
+                    // start the video here instead of in the callback.
+                    if (mTargetState == STATE_PLAYING) {
+                        start();
+                        if (mMediaController != null) {
+                            mMediaController.show();
+                        }
+                    } else if (!isPlaying() &&
+                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
+                       if (mMediaController != null) {
+                           // Show the media controls when we're paused into a video and make 'em stick.
+                           mMediaController.show(0);
+                       }
+                   }
+                }
+            } else {
+                // We don't know the video size yet, but should start anyway.
+                // The video size might be reported to us later.
+                if (mTargetState == STATE_PLAYING) {
+                    start();
+                }
+            }
+        }
+    };
+
+    private MediaPlayer.OnCompletionListener mCompletionListener =
+        new MediaPlayer.OnCompletionListener() {
+        public void onCompletion(MediaPlayer mp) {
+            mCurrentState = STATE_PLAYBACK_COMPLETED;
+            mTargetState = STATE_PLAYBACK_COMPLETED;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+            if (mOnCompletionListener != null) {
+                mOnCompletionListener.onCompletion(mMediaPlayer);
+            }
+        }
+    };
+
+    private MediaPlayer.OnErrorListener mErrorListener =
+        new MediaPlayer.OnErrorListener() {
+        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
+            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+
+            /* If an error handler has been supplied, use it and finish. */
+            if (mOnErrorListener != null) {
+                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
+                    return true;
+                }
+            }
+
+            /* Otherwise, pop up an error dialog so the user knows that
+             * something bad has happened. Only try and pop up the dialog
+             * if we're attached to a window. When we're going away and no
+             * longer have a window, don't bother showing the user an error.
+             */
+            if (getWindowToken() != null) {
+//                Resources r = mContext.getResources();
+                int messageId;
+
+                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
+                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
+                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
+                } else {
+                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
+                    messageId = R.string.VideoView_error_text_unknown;
+                }
+
+                new AlertDialog.Builder(mContext)
+                        .setMessage(messageId)
+                        //eg. <string name="VideoView_error_button">OK</string>
+                        .setPositiveButton(R.string.VideoView_error_button,
+                                new DialogInterface.OnClickListener() {
+                                    public void onClick(DialogInterface dialog, int whichButton) {
+                                        /* If we get here, there is no onError listener, so
+                                         * at least inform them that the video is over.
+                                         */
+                                        if (mOnCompletionListener != null) {
+                                            mOnCompletionListener.onCompletion(mMediaPlayer);
+                                        }
+                                    }
+                                })
+                        .setCancelable(false)
+                        .show();
+            }
+            return true;
+        }
+    };
+
+    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
+        new MediaPlayer.OnBufferingUpdateListener() {
+        public void onBufferingUpdate(MediaPlayer mp, int percent) {
+            mCurrentBufferPercentage = percent;
+        }
+    };
+
+    /**
+     * Register a callback to be invoked when the media file
+     * is loaded and ready to go.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
+    {
+        mOnPreparedListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when the end of a media file
+     * has been reached during playback.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnCompletionListener(OnCompletionListener l)
+    {
+        mOnCompletionListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an error occurs
+     * during playback or setup.  If no listener is specified,
+     * or if the listener returned false, VideoView will inform
+     * the user of any errors.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnErrorListener(OnErrorListener l)
+    {
+        mOnErrorListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an informational event
+     * occurs during playback or setup.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnInfoListener(OnInfoListener l) {
+        mOnInfoListener = l;
+    }
+
+    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
+    {
+        public void surfaceChanged(SurfaceHolder holder, int format,
+                                    int w, int h)
+        {
+            mSurfaceWidth = w;
+            mSurfaceHeight = h;
+            boolean isValidState =  (mTargetState == STATE_PLAYING);
+            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
+            if (mMediaPlayer != null && isValidState && hasValidSize) {
+                if (mSeekWhenPrepared != 0) {
+                    seekTo(mSeekWhenPrepared);
+                }
+                start();
+            }
+        }
+
+        public void surfaceCreated(SurfaceHolder holder)
+        {
+            mSurfaceHolder = holder;
+            openVideo();
+        }
+
+        public void surfaceDestroyed(SurfaceHolder holder)
+        {
+            // after we return from this we can't use the surface any more
+            mSurfaceHolder = null;
+            if (mMediaController != null) mMediaController.hide();
+            release(true);
+        }
+    };
+
+    /*
+     * release the media player in any state
+     */
+    private void release(boolean cleartargetstate) {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.reset();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            if (cleartargetstate) {
+                mTargetState  = STATE_IDLE;
+            }
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTrackballEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event)
+    {
+        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
+                                     keyCode != KeyEvent.KEYCODE_MENU &&
+                                     keyCode != KeyEvent.KEYCODE_CALL &&
+                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
+        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
+            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
+                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                } else {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
+                if (!mMediaPlayer.isPlaying()) {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                }
+                return true;
+            } else {
+                toggleMediaControlsVisiblity();
+            }
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    private void toggleMediaControlsVisiblity() {
+        if (mMediaController.isShowing()) {
+            mMediaController.hide();
+        } else {
+            mMediaController.show();
+        }
+    }
+
+    public void start() {
+        if (isInPlaybackState()) {
+            mMediaPlayer.start();
+            mCurrentState = STATE_PLAYING;
+        }
+        mTargetState = STATE_PLAYING;
+    }
+
+    public void pause() {
+        if (isInPlaybackState()) {
+            if (mMediaPlayer.isPlaying()) {
+                mMediaPlayer.pause();
+                mCurrentState = STATE_PAUSED;
+            }
+        }
+        mTargetState = STATE_PAUSED;
+    }
+
+    public void suspend() {
+        release(false);
+    }
+
+    public void resume() {
+        openVideo();
+    }
+
+    public int getDuration() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getDuration();
+        }
+
+        return -1;
+    }
+
+    public int getCurrentPosition() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getCurrentPosition();
+        }
+        return 0;
+    }
+
+    public void seekTo(int msec) {
+        if (isInPlaybackState()) {
+            mMediaPlayer.seekTo(msec);
+            mSeekWhenPrepared = 0;
+        } else {
+            mSeekWhenPrepared = msec;
+        }
+    }
+
+    public boolean isPlaying() {
+        return isInPlaybackState() && mMediaPlayer.isPlaying();
+    }
+
+    public int getBufferPercentage() {
+        if (mMediaPlayer != null) {
+            return mCurrentBufferPercentage;
+        }
+        return 0;
+    }
+
+    private boolean isInPlaybackState() {
+        return (mMediaPlayer != null &&
+                mCurrentState != STATE_ERROR &&
+                mCurrentState != STATE_IDLE &&
+                mCurrentState != STATE_PREPARING);
+    }
+
+    public boolean canPause() {
+        return mCanPause;
+    }
+
+    public boolean canSeekBackward() {
+        return mCanSeekBack;
+    }
+
+    public boolean canSeekForward() {
+        return mCanSeekForward;
+    }
+}
\ No newline at end of file
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
new file mode 100644
index 00000000..ce949817
--- /dev/null
+++ b/examples/TestCaseExampleUsage.java
@@ -0,0 +1,63 @@
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import android.test.InstrumentationTestCase;
+import android.util.Log;
+
+// Credits to Wuyexiong <forever_crying@qq.com>
+// See: https://github.com/loopj/android-async-http/pull/236
+public class TestCaseExampleUsage extends InstrumentationTestCase
+{
+	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
+
+	public void testAsync() throws Throwable
+	{
+		final CountDownLatch signal = new CountDownLatch(1);
+		runTestOnUiThread(new Runnable()
+		{
+			@Override
+			public void run()
+			{
+				AsyncHttpClient client = new AsyncHttpClient();
+
+				client.get("http://www.google.com", new AsyncHttpResponseHandler()
+				{
+					@Override
+					public void onStart()
+					{
+						Log.v(TAG , "onStart");
+					}
+
+					@Override
+					public void onSuccess(String response)
+					{
+						Log.v(TAG , "onSuccess");
+						System.out.println(response);
+					}
+
+					@Override
+					public void onFailure(Throwable error, String content)
+					{
+						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
+					}
+
+					@Override
+					public void onFinish()
+					{
+						Log.v(TAG , "onFinish");
+						signal.countDown();
+					}
+				});
+
+				try {
+					signal.await(30, TimeUnit.SECONDS);
+				} catch (InterruptedException e) {
+				}
+				Log.v(TAG , "TestCaseExampleUsage Over");
+			}
+		});
+	}
+}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..0de12ce9
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,12 @@
+VERSION_NAME=1.4.4-SNAPSHOT
+VERSION_CODE=144
+GROUP=com.loopj.android
+
+POM_DESCRIPTION=An Asynchronous HTTP Library for Android
+POM_URL=loopj.com/android-async-http/
+POM_SCM_URL=https://github.com/loopj/android-async-http
+POM_SCM_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index fc7a6a3c..1ad7c0fc 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.4"
-    android:versionCode="2">
+    android:versionName="1.4.4-SNAPSHOT"
+    android:versionCode="144">
 
     <uses-sdk
         android:minSdkVersion="3"
diff --git a/library/build.gradle b/library/build.gradle
index 81185aea..680db873 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -16,3 +16,16 @@ android {
         }
     }
 }
+
+android.libraryVariants.all { variant ->
+
+    task("generate${variant.name}Javadoc", type: Javadoc) {
+        description "Generates Javadoc for $variant.name."
+        source = variant.javaCompile.source
+        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
+        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+    }
+
+}
+
+apply from: '../maven_push.gradle'
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100644
index 00000000..d6aa0de5
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=ActionBar-PullToRefresh Library
+POM_ARTIFACT_ID=android-async-http
+POM_PACKAGING=aar
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index 834f931e..36a7c572 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -24,6 +24,7 @@
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
 import org.apache.http.HttpResponse;
@@ -43,12 +44,14 @@
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
+import org.apache.http.conn.params.ConnRoutePNames;
 import org.apache.http.conn.scheme.PlainSocketFactory;
 import org.apache.http.conn.scheme.Scheme;
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
 import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
@@ -80,9 +83,9 @@
  * with additional parameters by passing a {@link RequestParams} instance,
  * and responses can be handled by passing an anonymously overridden
  * {@link AsyncHttpResponseHandler} instance.
- * <p/>
+ * <p>&nbsp;</p>
  * For example:
- * <p/>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -94,7 +97,9 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.3";
+    // This property won't be available soon, don't use it
+    @Deprecated
+    private static final String VERSION = "1.4.4";
 
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
@@ -136,6 +141,10 @@ public AsyncHttpClient() {
         schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
+        threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        clientHeaderMap = new HashMap<String, String>();
+
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
         httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
@@ -170,17 +179,14 @@ public void process(HttpResponse response, HttpContext context) {
         });
 
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
     }
 
     /**
      * Get the underlying HttpClient instance. This is useful for setting
      * additional fine-grained settings for requests by accessing the
      * client's ConnectionManager, HttpParams and SchemeRegistry.
+     *
+     * @return underlying HttpClient instance
      */
     public HttpClient getHttpClient() {
         return this.httpClient;
@@ -190,6 +196,8 @@ public HttpClient getHttpClient() {
      * Get the underlying HttpContext instance. This is useful for getting
      * and setting fine-grained settings for requests by accessing the
      * context's attributes such as the CookieStore.
+     *
+     * @return underlying HttpContext instance
      */
     public HttpContext getHttpContext() {
         return this.httpContext;
@@ -214,6 +222,21 @@ public void setThreadPool(ThreadPoolExecutor threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Simple interface method, to enable or disable redirects.
+     * If you set manually RedirectHandler on underlying HttpClient, effects of this method will be canceled.
+     *
+     * @param enableRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects) {
+        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
+            @Override
+            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
+                return enableRedirects;
+            }
+        });
+    }
+
     /**
      * Sets the User-Agent header to be sent with each request. By default,
      * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
@@ -236,6 +259,18 @@ public void setTimeout(int timeout) {
         HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
     }
 
+    /**
+     * Sets the Proxy by it's hostname and port
+     *
+     * @param hostname  the hostname (IP or DNS name)
+     * @param port  the port number. -1 indicates the scheme default port.
+     */
+    public void setProxy(String hostname, int port){
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+    }
+
     /**
      * Sets the SSLSocketFactory to user when making requests. By default,
      * a new, default SSLSocketFactory is used.
@@ -246,6 +281,14 @@ public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
         this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
     }
 
+    /**
+     * Sets the maximum number of retries for a particular Request.
+     * @param retries maximum number of retries per request
+     */
+    public void setMaxRetries(int retries) {
+        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries));
+    }
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
      *
@@ -256,12 +299,21 @@ public void addHeader(String header, String value) {
         clientHeaderMap.put(header, value);
     }
 
+    /**
+     * Remove header from all requests this client makes (before sending).
+     *
+     * @param header the name of the header
+     */
+    public void removeHeader(String header) {
+        clientHeaderMap.remove(header);
+    }
+
     /**
      * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
      * setBasicAuth('username','password',AuthScope.ANY)
      *
-     * @param username
-     * @param password
+     * @param username Basic Auth username
+     * @param password Basic Auth password
      */
     public void setBasicAuth(String username, String password) {
         AuthScope scope = AuthScope.ANY;
@@ -272,8 +324,8 @@ public void setBasicAuth(String username, String password) {
      * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
      * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
      *
-     * @param username
-     * @param password
+     * @param username Basic Auth username
+     * @param password Basic Auth password
      * @param scope    - an AuthScope object
      */
     public void setBasicAuth(String username, String password, AuthScope scope) {
@@ -284,7 +336,7 @@ public void setBasicAuth(String username, String password, AuthScope scope) {
     /**
      * Cancels any pending (or potentially active) requests associated with the
      * passed Context.
-     * <p/>
+     * <p>&nbsp;</p>
      * <b>Note:</b> This will only affect requests which were created with a non-null
      * android Context. This method is intended to be used in the onDestroy
      * method of your android activities to destroy all requests which are no
@@ -312,7 +364,8 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
 
     /**
      * Perform a HTTP HEAD request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(String url, AsyncHttpResponseHandler responseHandler) {
@@ -321,8 +374,9 @@ public void head(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP HEAD request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional HEAD parameters to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -331,8 +385,9 @@ public void head(String url, RequestParams params, AsyncHttpResponseHandler resp
 
     /**
      * Perform a HTTP HEAD request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
@@ -341,9 +396,10 @@ public void head(Context context, String url, AsyncHttpResponseHandler responseH
 
     /**
      * Perform a HTTP HEAD request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional HEAD parameters to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -354,15 +410,16 @@ public void head(Context context, String url, RequestParams params, AsyncHttpRes
      * Perform a HTTP HEAD request and track the Android Context which initiated
      * the request with customized headers
      *
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional HEAD parameters to send with the request.
+     * @param context         Context to execute request against
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional HEAD parameters to send with the request.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpUriRequest request = new HttpHead(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
@@ -420,6 +477,7 @@ public void get(Context context, String url, RequestParams params, AsyncHttpResp
      * Perform a HTTP GET request and track the Android Context which initiated
      * the request with customized headers
      *
+     * @param context         Context to execute request against
      * @param url             the URL to send the request to.
      * @param headers         set headers only for this request
      * @param params          additional GET parameters to send with the request.
@@ -476,9 +534,9 @@ public void post(Context context, String url, RequestParams params, AsyncHttpRes
      *
      * @param context         the Android Context which initiated the request.
      * @param url             the URL to send the request to.
-     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
      * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
      */
     public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
@@ -663,6 +721,21 @@ public void delete(Context context, String url, Header[] headers, AsyncHttpRespo
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param params          additional DELETE parameters or files to send along with request
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(url, params));
+        if(headers != null) httpDelete.setHeaders(headers);
+        sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
+    }
+
 
     // Private stuff
     protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
@@ -689,7 +762,7 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
     public static String getUrlWithQueryString(String url, RequestParams params) {
         if (params != null) {
             String paramString = params.getParamString();
-            if (url.indexOf("?") == -1) {
+            if (!url.contains("?")) {
                 url += "?" + paramString;
             } else {
                 url += "&" + paramString;
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index d57fba7c..df297bb8 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -36,12 +36,12 @@
  * Used to intercept and handle the responses from requests made using
  * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
  * designed to be anonymously overridden with your own response handling code.
- * <p/>
+ * <p>&nbsp;</p>
  * Additionally, you can override the {@link #onFailure(Throwable, String)},
  * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p/>
+ * <p>&nbsp;</p>
  * For example:
- * <p/>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -74,6 +74,17 @@
     protected static final int FINISH_MESSAGE = 3;
 
     private Handler handler;
+    private String responseCharset = "UTF-8";
+
+    /**
+     * Sets the charset for the response string. If not set, the default is UTF-8.
+     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     *
+     * @param charset to be used for the response string.
+     */
+    public void setCharset(final String charset) {
+        this.responseCharset = charset;
+    }
 
     /**
      * Creates a new AsyncHttpResponseHandler
@@ -163,7 +174,7 @@ public void onFailure(Throwable error, String content) {
     //
 
     protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), headers, responseBody}));
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
 
     protected void sendFailureMessage(Throwable e, String responseBody) {
@@ -203,7 +214,7 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (Header[]) response[1], (String) response[2]);
+                handleSuccessMessage((Integer) response[0], (Header[]) response[1], (String) response[2]);
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
@@ -232,8 +243,10 @@ protected Message obtainMessage(int responseMessage, Object response) {
             msg = this.handler.obtainMessage(responseMessage, response);
         } else {
             msg = Message.obtain();
-            msg.what = responseMessage;
-            msg.obj = response;
+            if (msg != null) {
+                msg.what = responseMessage;
+                msg.obj = response;
+            }
         }
         return msg;
     }
@@ -247,10 +260,11 @@ protected void sendResponseMessage(HttpResponse response) {
             HttpEntity temp = response.getEntity();
             if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
+                responseBody = EntityUtils.toString(entity, responseCharset);
             }
         } catch (IOException e) {
             sendFailureMessage(e, (String) null);
+            return;
         }
 
         if (status.getStatusCode() >= 300) {
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index 3265a467..0ea4d5c3 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -35,9 +35,9 @@
  * {@link AsyncHttpClient}. Receives response body as byte array with a
  * content-type whitelist. (e.g. checks Content-Type against allowed list,
  * Content-length).
- * <p/>
+ * <p>&nbsp;</p>
  * For example:
- * <p/>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * String[] allowedTypes = new String[] { "image/png" };
@@ -71,6 +71,8 @@ public BinaryHttpResponseHandler() {
     /**
      * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
      * content types with passed String array (hopefully) of content types.
+     *
+     * @param allowedContentTypes content types array, eg. 'image/jpeg'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
         this();
@@ -166,7 +168,7 @@ protected void sendResponseMessage(HttpResponse response) {
         byte[] responseBody = null;
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -178,7 +180,7 @@ protected void sendResponseMessage(HttpResponse response) {
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
             return;
         }
         try {
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 8b9d549f..b3d477ca 100644
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -54,7 +54,7 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (File) response[1]);
+                handleSuccessMessage((Integer) response[0], (File) response[1]);
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 6019953d..72df100f 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -30,11 +30,11 @@
  * Used to intercept and handle the responses from requests made using
  * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
  * or {@link JSONArray}.
- * <p/>
+ * <p>&nbsp;</p>
  * This class is designed to be passed to get, post, put and delete requests
  * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
  * methods anonymously overridden.
- * <p/>
+ * <p>&nbsp;</p>
  * Additionally, you can override the other event methods from the
  * parent class.
  */
@@ -128,14 +128,19 @@ public void onFailure(Throwable e, JSONArray errorResponse) {
     //
 
     @Override
-    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
+    protected void sendSuccessMessage(final int statusCode, final Header[] headers, final String responseBody) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
-            try {
-                Object jsonResponse = parseResponse(responseBody);
-                sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
-            } catch (JSONException e) {
-                sendFailureMessage(e, responseBody);
-            }
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        Object jsonResponse = parseResponse(responseBody);
+                        sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+                    } catch (JSONException e) {
+                        sendFailureMessage(e, responseBody);
+                    }
+                }
+            }).start();
         } else {
             sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, new JSONObject()}));
         }
@@ -151,7 +156,7 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_JSON_MESSAGE:
                 Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage(((Integer) response[0]).intValue(), (Header[]) response[1], response[2]);
+                handleSuccessJsonMessage((Integer) response[0], (Header[]) response[1], response[2]);
                 break;
             default:
                 super.handleMessage(msg);
@@ -182,24 +187,30 @@ protected Object parseResponse(String responseBody) throws JSONException {
     }
 
     @Override
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        try {
-            if (responseBody != null) {
-                Object jsonResponse = parseResponse(responseBody);
-                if (jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject) jsonResponse);
-                } else if (jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray) jsonResponse);
-                } else if (jsonResponse instanceof String) {
-                    onFailure(e, (String) jsonResponse);
-                } else {
+    protected void handleFailureMessage(final Throwable e, final String responseBody) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    if (responseBody != null) {
+                        Object jsonResponse = parseResponse(responseBody);
+                        if (jsonResponse instanceof JSONObject) {
+                            onFailure(e, (JSONObject) jsonResponse);
+                        } else if (jsonResponse instanceof JSONArray) {
+                            onFailure(e, (JSONArray) jsonResponse);
+                        } else if (jsonResponse instanceof String) {
+                            onFailure(e, (String) jsonResponse);
+                        } else {
+                            onFailure(e, responseBody);
+                        }
+                    } else {
+                        onFailure(e, "");
+                    }
+                } catch (JSONException ex) {
                     onFailure(e, responseBody);
                 }
-            } else {
-                onFailure(e, "");
             }
-        } catch (JSONException ex) {
-            onFailure(e, responseBody);
-        }
+        }).start();
+
     }
 }
diff --git a/library/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/com/loopj/android/http/PersistentCookieStore.java
index 13228abb..218fc065 100644
--- a/library/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/com/loopj/android/http/PersistentCookieStore.java
@@ -38,7 +38,7 @@
  * {@link CookieStore} interface. Cookies are stored and will persist on the
  * user's device between application sessions since they are serialized and
  * stored in {@link SharedPreferences}.
- * <p/>
+ * <p>&nbsp;</p>
  * Instances of this class are designed to be used with
  * {@link AsyncHttpClient#setCookieStore}, but can also be used with a
  * regular old apache HttpClient/HttpContext if you prefer.
@@ -53,6 +53,8 @@
 
     /**
      * Construct a persistent cookie store.
+     *
+     * @param context Context to attach cookie store to
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
@@ -177,7 +179,7 @@ protected Cookie decodeCookie(String cookieStr) {
     // Using some super basic byte array <-> hex conversions so we don't have
     // to rely on any large Base64 libraries. Can be overridden if you like!
     protected String byteArrayToHexString(byte[] b) {
-        StringBuffer sb = new StringBuffer(b.length * 2);
+        StringBuilder sb = new StringBuilder(b.length * 2);
         for (byte element : b) {
             int v = element & 0xff;
             if (v < 16) {
diff --git a/library/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
index 794d374d..7f9eae96 100644
--- a/library/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -36,9 +36,9 @@
 /**
  * A collection of string request parameters or files to send along with
  * requests made from an {@link AsyncHttpClient} instance.
- * <p/>
+ * <p>&nbsp;</p>
  * For example:
- * <p/>
+ * <p>&nbsp;</p>
  * <pre>
  * RequestParams params = new RequestParams();
  * params.put("username", "james");
@@ -142,6 +142,8 @@ public void put(String key, int value) {
      *
      * @param key  the key name for the new param.
      * @param file the file to add.
+     *
+     * @throws java.io.FileNotFoundException if the file is not found
      */
     public void put(String key, File file) throws FileNotFoundException {
         put(key, new FileInputStream(file), file.getName());
@@ -262,6 +264,8 @@ public String toString() {
 
     /**
      * Returns an HttpEntity containing all request parameters
+     *
+     * @return an HttpEntity containing all request parameters
      */
     public HttpEntity getEntity() {
         HttpEntity entity = null;
diff --git a/library/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
index b7459fb1..01c89495 100644
--- a/library/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -68,7 +68,7 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         boolean retry = true;
 
         Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
+        boolean sent = (b != null && b);
 
         if (executionCount > maxRetries) {
             // Do not retry if over max retry count
@@ -87,7 +87,7 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
         if (retry) {
             // resend all idempotent requests
             HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
-            String requestType = currentReq.getMethod();
+            String requestType = currentReq != null ? currentReq.getMethod() : "";
             retry = !requestType.equals("POST");
         }
 
@@ -101,9 +101,8 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
     }
 
     protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
-        Iterator<Class<?>> itr = list.iterator();
-        while (itr.hasNext()) {
-            if (itr.next().isInstance(error)) {
+        for (Class<?> aList : list) {
+            if (aList.isInstance(error)) {
                 return true;
             }
         }
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
index ec475d30..c6e804b4 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -46,7 +46,7 @@
     boolean isSetFirst = false;
 
     public SimpleMultipartEntity() {
-        final StringBuffer buf = new StringBuffer();
+        final StringBuilder buf = new StringBuilder();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
@@ -115,7 +115,7 @@ public void addPart(final String key, final String fileName, final InputStream f
             out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
 
             final byte[] tmp = new byte[4096];
-            int l = 0;
+            int l;
             while ((l = fin.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
             }
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
index 5c3d6ac4..99722b33 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -101,6 +101,11 @@ public String put(String url) {
         return result;
     }
 
+    public String post(String url, HttpEntity entity){
+        this.post(null, url, entity, null, responseHandler);
+        return result;
+    }
+
     public String post(String url, RequestParams params) {
         this.post(url, params, responseHandler);
         return result;
diff --git a/maven_push.gradle b/maven_push.gradle
new file mode 100644
index 00000000..1c7ec711
--- /dev/null
+++ b/maven_push.gradle
@@ -0,0 +1,104 @@
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+configurations {
+    archives {
+        extendsFrom configurations.default
+    }
+}
+
+def sonatypeRepositoryUrl
+if (isReleaseBuild()) {
+    println 'RELEASE BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+} else {
+    println 'DEBUG BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
+    if (System.console())
+        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
+    else
+        ext.set('signing.password', 'dummy')
+}
+
+if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
+    if (System.console())
+        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
+    else
+    	ext.set('nexusPassword', 'dummy')
+}
+
+afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+                pom.artifactId = POM_ARTIFACT_ID
+
+                repository(url: sonatypeRepositoryUrl) {
+                    authentication(userName: nexusUsername, password: nexusPassword)
+                }
+
+                pom.project {
+                    name POM_NAME
+                    packaging POM_PACKAGING
+                    description POM_DESCRIPTION
+                    url POM_URL
+
+                    scm {
+                        url POM_SCM_URL
+                        connection POM_SCM_CONNECTION
+                        developerConnection POM_SCM_DEV_CONNECTION
+                    }
+
+                    licenses {
+                        license {
+                            name POM_LICENCE_NAME
+                            url POM_LICENCE_URL
+                            distribution POM_LICENCE_DIST
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id "loopj"
+                            name "James Smith"
+                        }
+                        developer {
+                            id "smarek"
+                            name "Marek Sebera"
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+
+    task androidReleaseJar(type: Jar, dependsOn: assembleRelease) {
+        from "$buildDir/classes/release/"
+    }
+
+    task androidJavadocsJar(type: Jar) {
+        classifier = 'javadoc'
+        from generateReleaseJavadoc.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+        classifier = 'sources'
+        from android.sourceSets.main.allSource
+    }
+
+    artifacts {
+        archives androidReleaseJar
+        archives androidSourcesJar
+        archives androidJavadocsJar
+    }
+}
