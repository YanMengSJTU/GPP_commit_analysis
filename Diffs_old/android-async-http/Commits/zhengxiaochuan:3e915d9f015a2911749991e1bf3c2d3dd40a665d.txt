diff --git a/.classpath b/.classpath
deleted file mode 100644
index 14fcf527..00000000
--- a/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/.gitignore b/.gitignore
index 0900c481..d3b22564 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,40 @@
+# Custom
 _site
+
+# Ant
 MANIFEST.MF
-*.jar
+./*.jar
 build.num
 build
+
+# ADT
+.classpath
+.project
+.settings
 local.properties
-bin/
-gen/
+bin
+gen
 _layouts
+proguard.cfg
+
+# OSX
 .DS_Store
-gh-pages
\ No newline at end of file
+
+# Github
+gh-pages
+
+# Gradle
+.gradle
+build
+
+# IDEA
+*.iml
+*.ipr
+*.iws
+out
+.idea
+
+# Maven
+target
+release.properties
+pom.xml.*
diff --git a/.project b/.project
deleted file mode 100644
index a9793139..00000000
--- a/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>android-async-http</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..a7560a7b
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,43 @@
+branches:
+  only:
+    - master
+language:
+  - java
+jdk:
+  - openjdk6
+before_install:
+  # environment info
+  - mvn -version
+  - gradle -v
+  - uname -a
+  # required libs for android build tools
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get update; fi
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+  # for gradle output style
+  - export TERM=dumb
+  # newer version of gradle
+  - wget http://services.gradle.org/distributions/gradle-1.8-bin.zip
+  - unzip -qq gradle-1.8-bin.zip
+  - export GRADLE_HOME=$PWD/gradle-1.8
+  - export PATH=$GRADLE_HOME/bin:$PATH
+  # just to test gradle version, against our provided one
+  - gradle -v
+  # newest android SDK 22.0.5
+  - wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz
+  - tar -zxf android-sdk_r22.0.5-linux.tgz
+  - export ANDROID_HOME=`pwd`/android-sdk-linux
+  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+  # manually set sdk.dir variable, according to local paths
+  - echo "sdk.dir=$ANDROID_HOME" > local.properties
+  - echo yes | android update sdk -t tools,platform-tools,extra-android-support,extra-android-m2repository,android-18 --force --no-ui
+  # build tools cannot be installed through "android update sdk" as of now
+  - wget http://dl.google.com/android/repository/build-tools_r18.0.1-linux.zip
+  - mkdir -p $ANDROID_HOME/build-tools
+  - unzip -qq build-tools_r18.0.1-linux.zip -d $ANDROID_HOME/build-tools/
+  - mv $ANDROID_HOME/build-tools/android-4.3 $ANDROID_HOME/build-tools/18.0.1
+  # verify files exist in right paths
+  - find $ANDROID_HOME/build-tools
+  - file $ANDROID_HOME/build-tools/18.0.1/aapt
+  - echo "nexusUsername=dummy" >> library/gradle.properties
+  - echo "nexusPassword=dummy" >> library/gradle.properties
+
diff --git a/README.md b/README.md
index 1602a534..a576fb38 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,8 @@
 Asynchronous Http Client for Android
 ====================================
 
+Travis CI state : [![Build Status](https://travis-ci.org/loopj/android-async-http.png?branch=master)](https://travis-ci.org/loopj/android-async-http)
+
 An asynchronous, callback-based Http client for Android built on top of Apache's [HttpClient](http://hc.apache.org/httpcomponents-client-ga/) libraries.
 
 
@@ -17,9 +19,33 @@ Features
 - Optional built-in response parsing into **JSON** (JsonHttpResponseHandler)
 - Optional **persistent cookie store**, saves cookies into your app's SharedPreferences
 
+Maven
+-----
+You can now integrate this library in your project via Maven. There are available two kind of builds.
+
+**development snapshots**
+https://oss.sonatype.org/content/repositories/snapshots/com/loopj/android/android-async-http/
+```
+Maven URL: https://oss.sonatype.org/content/repositories/snapshots/
+GroupId: com.loopj.android
+ArtifactId: async-http-client
+Version: 1.4.4-SNAPSHOT
+Packaging: JAR or AAR
+```
+
+**releases, maven central**
+
+http://central.maven.org/maven2/com/loopj/android/android-async-http/
+```
+Maven URL: http://repo1.maven.org/maven2/
+GroupId: com.loopj.android
+ArtifactId: async-http-client
+Version: 1.4.3
+Packaging: JAR or AAR
+```
 
 Documentation, Features and Examples
 ------------------------------------
 Full details and documentation can be found on the project page here:
 
-http://loopj.com/android-async-http/
\ No newline at end of file
+http://loopj.com/android-async-http/
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..d239f5ad
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,28 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.6.+'
+    }
+}
+
+def isReleaseBuild() {
+    return version.contains("SNAPSHOT") == false
+}
+
+allprojects {
+    group = 'com.loopj.android'
+    version = '1.4.4-SNAPSHOT'
+
+    repositories {
+        mavenCentral()
+    }
+
+    tasks.withType(JavaCompile) {
+        options.encoding = "UTF-8"
+    }
+}
+
+apply plugin: 'android-reporting'
diff --git a/build.xml b/build.xml
deleted file mode 100644
index 316d6b94..00000000
--- a/build.xml
+++ /dev/null
@@ -1,100 +0,0 @@
-<project default="package">
-    <property file="local.properties"/>
-    <property file="project.properties"/>
-
-    <!-- Package properties -->
-    <property name="package.name" value="android-async-http" />
-    <property name="package.packagename" value="com.loopj.android.http" />
-    
-    <!-- Get git commit -->
-    <available file=".git" type="dir" property="git.present"/>
-
-    <target name="git-details">
-        <exec executable="git" outputproperty="git.status">
-            <arg value="status" />
-        </exec>
-        <echo message="${git.status}"/>
-        
-        <exec executable="git" outputproperty="package.versionname">
-          <arg value="describe"/>
-          <arg value="--tags"/>
-          <arg value="--dirty"/>
-          <arg value="--always"/>
-        </exec>
-        <echo message="${package.versionname}" />
-    </target>
-
-    <!-- Standard jar stuff -->
-    <property environment="env"/>
-    <condition property="android.base" value="${sdk.dir}" else="${env.ANDROID_HOME}">
-      <isset property="sdk.dir" />
-    </condition>
-    <fail message="Please set either the sdk.dir property or the ANDROID_HOME environment variable to point to your Android SDK installation.">
-      <condition>
-        <not>
-          <available file="${android.base}" type="dir"/>
-        </not>
-      </condition>
-    </fail>
-
-    <property name="lib.dir" value="${android.base}/platforms/${target}" />
-    <property name="build.dir" value="./build"/>
-    <property name="classes.dir"  value="${build.dir}/classes"/>
-    <buildnumber file="build.num" />
-
-    <!-- Set up classpath -->
-    <path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar" />
-    </path>
-
-    <!-- Build javadoc -->
-    <target name="doc">
-        <javadoc 
-            classpathref="classpath"
-            sourcepath="gen:src"
-            destdir="doc"
-            packagenames="${package.packagename}"
-            linkoffline="http://d.android.com/reference ${android.base}/docs/reference" 
-            additionalparam="-author  -version"
-            />
-    </target>
-
-    <!-- Compile java files into classes -->
-    <target name="compile">
-        <mkdir dir="${build.dir}" />
-        <mkdir dir="${classes.dir}" />
-
-        <javac
-            includeantruntime="false"
-            srcdir="."
-            destdir="${classes.dir}"
-            classpathref="classpath"
-            debug="true"
-            debuglevel="lines,source" />
-    </target>
-
-    <!-- Package a jar from compiled class files -->
-    <target name="jar" depends="git-details,compile">
-        <delete dir="." includes="**/*.jar" />
-        <delete file="MANIFEST.MF" />
-        <manifest file="MANIFEST.MF">
-            <attribute name="Built-By" value="${user.name}" />
-            <attribute name="Implementation-Version" value="${package.versionname}"/> 
-        </manifest>
-
-        <jar destfile="${package.versionname}.jar" basedir="build/classes" includes="com/loopj/android/http/**/*.class" manifest="MANIFEST.MF" />
-    </target>
-
-    <!-- Clean out the build files -->
-    <target name="clean">
-        <delete dir="build" />
-        <delete dir="doc" />
-        <delete>
-            <fileset dir="." includes="*.jar"/>
-            <fileset file="MANIFEST.MF"/>
-        </delete>
-    </target>
-
-    <!-- Compile and package a jar -->
-    <target name="package" depends="compile,jar" />
-</project>
diff --git a/examples/CookieVideoView.java b/examples/CookieVideoView.java
new file mode 100644
index 00000000..998daa1f
--- /dev/null
+++ b/examples/CookieVideoView.java
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.media.MediaPlayer.OnCompletionListener;
+import android.media.MediaPlayer.OnErrorListener;
+import android.media.MediaPlayer.OnInfoListener;
+import android.net.Uri;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.widget.MediaController;
+import android.widget.MediaController.MediaPlayerControl;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.http.cookie.Cookie;
+
+/**
+ * Displays a video file.  The VideoView class
+ * can load images from various sources (such as resources or content
+ * providers), takes care of computing its measurement from the video so that
+ * it can be used in any layout manager, and provides various display options
+ * such as scaling and tinting.
+ *
+ * @author Jungho Bang <me@bangtoven.com>
+ */
+public class CookieVideoView extends SurfaceView implements MediaPlayerControl {
+    private String TAG = "CookieVideoView";
+    // settable by the client
+    private Uri         mUri;
+    private Map<String, String> mHeaders;
+
+    // all possible internal states
+    private static final int STATE_ERROR              = -1;
+    private static final int STATE_IDLE               = 0;
+    private static final int STATE_PREPARING          = 1;
+    private static final int STATE_PREPARED           = 2;
+    private static final int STATE_PLAYING            = 3;
+    private static final int STATE_PAUSED             = 4;
+    private static final int STATE_PLAYBACK_COMPLETED = 5;
+
+    // mCurrentState is a VideoView object's current state.
+    // mTargetState is the state that a method caller intends to reach.
+    // For instance, regardless the VideoView object's current state,
+    // calling pause() intends to bring the object to a target state
+    // of STATE_PAUSED.
+    private int mCurrentState = STATE_IDLE;
+    private int mTargetState  = STATE_IDLE;
+
+    // All the stuff we need for playing and showing a video
+    private SurfaceHolder mSurfaceHolder = null;
+    private MediaPlayer mMediaPlayer = null;
+    private int         mVideoWidth;
+    private int         mVideoHeight;
+    private int         mSurfaceWidth;
+    private int         mSurfaceHeight;
+    private MediaController mMediaController;
+    private OnCompletionListener mOnCompletionListener;
+    private MediaPlayer.OnPreparedListener mOnPreparedListener;
+    private int         mCurrentBufferPercentage;
+    private OnErrorListener mOnErrorListener;
+    private OnInfoListener  mOnInfoListener;
+    private int         mSeekWhenPrepared;  // recording the seek position while preparing
+    private boolean     mCanPause;
+    private boolean     mCanSeekBack;
+    private boolean     mCanSeekForward;
+	private Context 	mContext;
+
+    public CookieVideoView(Context context) {
+        super(context);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+        initVideoView(context);
+    }
+
+    public CookieVideoView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initVideoView(context);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        //Log.i("@@@@", "onMeasure");
+        int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
+        int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
+        if (mVideoWidth > 0 && mVideoHeight > 0) {
+            if ( mVideoWidth * height  > width * mVideoHeight ) {
+                //Log.i("@@@", "image too tall, correcting");
+                height = width * mVideoHeight / mVideoWidth;
+            } else if ( mVideoWidth * height  < width * mVideoHeight ) {
+                //Log.i("@@@", "image too wide, correcting");
+                width = height * mVideoWidth / mVideoHeight;
+            } else {
+                //Log.i("@@@", "aspect ratio is correct: " +
+                        //width+"/"+height+"="+
+                        //mVideoWidth+"/"+mVideoHeight);
+            }
+        }
+        //Log.i("@@@@@@@@@@", "setting size: " + width + 'x' + height);
+        setMeasuredDimension(width, height);
+    }
+
+    @SuppressLint("NewApi")
+	@Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(CookieVideoView.class.getName());
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+	@Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(CookieVideoView.class.getName());
+    }
+
+    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
+        int result = desiredSize;
+        int specMode = MeasureSpec.getMode(measureSpec);
+        int specSize =  MeasureSpec.getSize(measureSpec);
+
+        switch (specMode) {
+            case MeasureSpec.UNSPECIFIED:
+                /* Parent says we can be as big as we want. Just don't be larger
+                 * than max size imposed on ourselves.
+                 */
+                result = desiredSize;
+                break;
+
+            case MeasureSpec.AT_MOST:
+                /* Parent says we can be as big as we want, up to specSize.
+                 * Don't be larger than specSize, and don't be larger than
+                 * the max size imposed on ourselves.
+                 */
+                result = Math.min(desiredSize, specSize);
+                break;
+
+            case MeasureSpec.EXACTLY:
+                // No choice. Do what we are told.
+                result = specSize;
+                break;
+        }
+        return result;
+}
+
+    private void initVideoView(Context context) {
+        mVideoWidth = 0;
+        mVideoHeight = 0;
+        getHolder().addCallback(mSHCallback);
+        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        mCurrentState = STATE_IDLE;
+        mTargetState  = STATE_IDLE;
+        mContext = context;
+    }
+
+    public void setVideoPath(String path) {
+        setVideoURI(Uri.parse(path));
+    }
+
+    public void setVideoURI(Uri uri) {
+    	mUri = uri;
+        mHeaders = getCookieHeader();
+    	mSeekWhenPrepared = 0;
+        openVideo();
+        requestLayout();
+        invalidate();
+    }
+    
+    private Map<String,String> getCookieHeader() {
+    	String hostDomain = mUri.getHost();
+    	List<Cookie> cookieList = new PersistentCookieStore(mContext).getCookies();
+    	for(Cookie cookie : cookieList) {
+    		if (cookie.getDomain().equalsIgnoreCase(hostDomain)) {
+    			Map<String,String> header = new HashMap<String, String>();
+    	    	header.put("Cookie", cookie.getName() + "=" + cookie.getValue());
+    	    	Log.d(TAG,"Cookie: "+header.toString());
+    	        return header;
+    	    }
+    	}
+    	return null;
+    }
+    
+    public void stopPlayback() {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.stop();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            mTargetState  = STATE_IDLE;
+        }
+    }
+
+    private void openVideo() {
+        if (mUri == null || mSurfaceHolder == null) {
+            // not ready for playback just yet, will try again later
+            return;
+        }
+        // Tell the music playback service to pause
+        // TODO: these constants need to be published somewhere in the framework.
+        Intent i = new Intent("com.android.music.musicservicecommand");
+        i.putExtra("command", "pause");
+        mContext.sendBroadcast(i);
+
+        // we shouldn't clear the target state, because somebody might have
+        // called start() previously
+        release(false);
+        try {
+            mMediaPlayer = new MediaPlayer();
+            mMediaPlayer.setOnPreparedListener(mPreparedListener);
+            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
+            mMediaPlayer.setOnCompletionListener(mCompletionListener);
+            mMediaPlayer.setOnErrorListener(mErrorListener);
+            mMediaPlayer.setOnInfoListener(mOnInfoListener);
+            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
+            mCurrentBufferPercentage = 0;
+            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
+            mMediaPlayer.setDisplay(mSurfaceHolder);
+            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mMediaPlayer.setScreenOnWhilePlaying(true);
+            mMediaPlayer.prepareAsync();
+            // we don't set the target state here either, but preserve the
+            // target state that was there before.
+            mCurrentState = STATE_PREPARING;
+            attachMediaController();
+        } catch (IOException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        } catch (IllegalArgumentException ex) {
+            Log.w(TAG, "Unable to open content: " + mUri, ex);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
+            return;
+        }
+    }
+
+    public void setMediaController(MediaController controller) {
+        if (mMediaController != null) {
+            mMediaController.hide();
+        }
+        mMediaController = controller;
+        attachMediaController();
+    }
+
+    private void attachMediaController() {
+        if (mMediaPlayer != null && mMediaController != null) {
+            mMediaController.setMediaPlayer(this);
+            View anchorView = this.getParent() instanceof View ?
+                    (View)this.getParent() : this;
+            mMediaController.setAnchorView(anchorView);
+            mMediaController.setEnabled(isInPlaybackState());
+        }
+    }
+
+    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
+        new MediaPlayer.OnVideoSizeChangedListener() {
+            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
+                mVideoWidth = mp.getVideoWidth();
+                mVideoHeight = mp.getVideoHeight();
+                if (mVideoWidth != 0 && mVideoHeight != 0) {
+                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                    requestLayout();
+                }
+            }
+    };
+
+    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
+        public void onPrepared(MediaPlayer mp) {
+            mCurrentState = STATE_PREPARED;
+
+            // Get the capabilities of the player for this stream
+//            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
+//                                      MediaPlayer.BYPASS_METADATA_FILTER);
+//            
+//          if (data != null) {
+//                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
+//                        || data.getBoolean(Metadata.PAUSE_AVAILABLE);
+//                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
+//                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
+//                        || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
+//            } else {
+                mCanPause = mCanSeekBack = mCanSeekForward = true;
+//            }
+
+            if (mOnPreparedListener != null) {
+                mOnPreparedListener.onPrepared(mMediaPlayer);
+            }
+            if (mMediaController != null) {
+                mMediaController.setEnabled(true);
+            }
+            mVideoWidth = mp.getVideoWidth();
+            mVideoHeight = mp.getVideoHeight();
+
+            int seekToPosition = mSeekWhenPrepared;  // mSeekWhenPrepared may be changed after seekTo() call
+            if (seekToPosition != 0) {
+                seekTo(seekToPosition);
+            }
+            if (mVideoWidth != 0 && mVideoHeight != 0) {
+                //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight);
+                getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
+                    // We didn't actually change the size (it was already at the size
+                    // we need), so we won't get a "surface changed" callback, so
+                    // start the video here instead of in the callback.
+                    if (mTargetState == STATE_PLAYING) {
+                        start();
+                        if (mMediaController != null) {
+                            mMediaController.show();
+                        }
+                    } else if (!isPlaying() &&
+                               (seekToPosition != 0 || getCurrentPosition() > 0)) {
+                       if (mMediaController != null) {
+                           // Show the media controls when we're paused into a video and make 'em stick.
+                           mMediaController.show(0);
+                       }
+                   }
+                }
+            } else {
+                // We don't know the video size yet, but should start anyway.
+                // The video size might be reported to us later.
+                if (mTargetState == STATE_PLAYING) {
+                    start();
+                }
+            }
+        }
+    };
+
+    private MediaPlayer.OnCompletionListener mCompletionListener =
+        new MediaPlayer.OnCompletionListener() {
+        public void onCompletion(MediaPlayer mp) {
+            mCurrentState = STATE_PLAYBACK_COMPLETED;
+            mTargetState = STATE_PLAYBACK_COMPLETED;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+            if (mOnCompletionListener != null) {
+                mOnCompletionListener.onCompletion(mMediaPlayer);
+            }
+        }
+    };
+
+    private MediaPlayer.OnErrorListener mErrorListener =
+        new MediaPlayer.OnErrorListener() {
+        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
+            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
+            mCurrentState = STATE_ERROR;
+            mTargetState = STATE_ERROR;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+
+            /* If an error handler has been supplied, use it and finish. */
+            if (mOnErrorListener != null) {
+                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
+                    return true;
+                }
+            }
+
+            /* Otherwise, pop up an error dialog so the user knows that
+             * something bad has happened. Only try and pop up the dialog
+             * if we're attached to a window. When we're going away and no
+             * longer have a window, don't bother showing the user an error.
+             */
+            if (getWindowToken() != null) {
+//                Resources r = mContext.getResources();
+                int messageId;
+
+                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
+                    //eg. <string name="VideoView_error_text_invalid_progressive_playback">This video isn\'t valid for streaming to this device.</string>
+                    messageId = R.string.VideoView_error_text_invalid_progressive_playback;
+                } else {
+                    //eg. <string name="VideoView_error_text_unknown">Can\'t play this video.</string>
+                    messageId = R.string.VideoView_error_text_unknown;
+                }
+
+                new AlertDialog.Builder(mContext)
+                        .setMessage(messageId)
+                        //eg. <string name="VideoView_error_button">OK</string>
+                        .setPositiveButton(R.string.VideoView_error_button,
+                                new DialogInterface.OnClickListener() {
+                                    public void onClick(DialogInterface dialog, int whichButton) {
+                                        /* If we get here, there is no onError listener, so
+                                         * at least inform them that the video is over.
+                                         */
+                                        if (mOnCompletionListener != null) {
+                                            mOnCompletionListener.onCompletion(mMediaPlayer);
+                                        }
+                                    }
+                                })
+                        .setCancelable(false)
+                        .show();
+            }
+            return true;
+        }
+    };
+
+    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
+        new MediaPlayer.OnBufferingUpdateListener() {
+        public void onBufferingUpdate(MediaPlayer mp, int percent) {
+            mCurrentBufferPercentage = percent;
+        }
+    };
+
+    /**
+     * Register a callback to be invoked when the media file
+     * is loaded and ready to go.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
+    {
+        mOnPreparedListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when the end of a media file
+     * has been reached during playback.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnCompletionListener(OnCompletionListener l)
+    {
+        mOnCompletionListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an error occurs
+     * during playback or setup.  If no listener is specified,
+     * or if the listener returned false, VideoView will inform
+     * the user of any errors.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnErrorListener(OnErrorListener l)
+    {
+        mOnErrorListener = l;
+    }
+
+    /**
+     * Register a callback to be invoked when an informational event
+     * occurs during playback or setup.
+     *
+     * @param l The callback that will be run
+     */
+    public void setOnInfoListener(OnInfoListener l) {
+        mOnInfoListener = l;
+    }
+
+    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
+    {
+        public void surfaceChanged(SurfaceHolder holder, int format,
+                                    int w, int h)
+        {
+            mSurfaceWidth = w;
+            mSurfaceHeight = h;
+            boolean isValidState =  (mTargetState == STATE_PLAYING);
+            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
+            if (mMediaPlayer != null && isValidState && hasValidSize) {
+                if (mSeekWhenPrepared != 0) {
+                    seekTo(mSeekWhenPrepared);
+                }
+                start();
+            }
+        }
+
+        public void surfaceCreated(SurfaceHolder holder)
+        {
+            mSurfaceHolder = holder;
+            openVideo();
+        }
+
+        public void surfaceDestroyed(SurfaceHolder holder)
+        {
+            // after we return from this we can't use the surface any more
+            mSurfaceHolder = null;
+            if (mMediaController != null) mMediaController.hide();
+            release(true);
+        }
+    };
+
+    /*
+     * release the media player in any state
+     */
+    private void release(boolean cleartargetstate) {
+        if (mMediaPlayer != null) {
+            mMediaPlayer.reset();
+            mMediaPlayer.release();
+            mMediaPlayer = null;
+            mCurrentState = STATE_IDLE;
+            if (cleartargetstate) {
+                mTargetState  = STATE_IDLE;
+            }
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTrackballEvent(MotionEvent ev) {
+        if (isInPlaybackState() && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event)
+    {
+        boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_UP &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &&
+                                     keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &&
+                                     keyCode != KeyEvent.KEYCODE_MENU &&
+                                     keyCode != KeyEvent.KEYCODE_CALL &&
+                                     keyCode != KeyEvent.KEYCODE_ENDCALL;
+        if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
+            if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK ||
+                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                } else {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
+                if (!mMediaPlayer.isPlaying()) {
+                    start();
+                    mMediaController.hide();
+                }
+                return true;
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
+                if (mMediaPlayer.isPlaying()) {
+                    pause();
+                    mMediaController.show();
+                }
+                return true;
+            } else {
+                toggleMediaControlsVisiblity();
+            }
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    private void toggleMediaControlsVisiblity() {
+        if (mMediaController.isShowing()) {
+            mMediaController.hide();
+        } else {
+            mMediaController.show();
+        }
+    }
+
+    public void start() {
+        if (isInPlaybackState()) {
+            mMediaPlayer.start();
+            mCurrentState = STATE_PLAYING;
+        }
+        mTargetState = STATE_PLAYING;
+    }
+
+    public void pause() {
+        if (isInPlaybackState()) {
+            if (mMediaPlayer.isPlaying()) {
+                mMediaPlayer.pause();
+                mCurrentState = STATE_PAUSED;
+            }
+        }
+        mTargetState = STATE_PAUSED;
+    }
+
+    public void suspend() {
+        release(false);
+    }
+
+    public void resume() {
+        openVideo();
+    }
+
+    public int getDuration() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getDuration();
+        }
+
+        return -1;
+    }
+
+    public int getCurrentPosition() {
+        if (isInPlaybackState()) {
+            return mMediaPlayer.getCurrentPosition();
+        }
+        return 0;
+    }
+
+    public void seekTo(int msec) {
+        if (isInPlaybackState()) {
+            mMediaPlayer.seekTo(msec);
+            mSeekWhenPrepared = 0;
+        } else {
+            mSeekWhenPrepared = msec;
+        }
+    }
+
+    public boolean isPlaying() {
+        return isInPlaybackState() && mMediaPlayer.isPlaying();
+    }
+
+    public int getBufferPercentage() {
+        if (mMediaPlayer != null) {
+            return mCurrentBufferPercentage;
+        }
+        return 0;
+    }
+
+    private boolean isInPlaybackState() {
+        return (mMediaPlayer != null &&
+                mCurrentState != STATE_ERROR &&
+                mCurrentState != STATE_IDLE &&
+                mCurrentState != STATE_PREPARING);
+    }
+
+    public boolean canPause() {
+        return mCanPause;
+    }
+
+    public boolean canSeekBackward() {
+        return mCanSeekBack;
+    }
+
+    public boolean canSeekForward() {
+        return mCanSeekForward;
+    }
+}
\ No newline at end of file
diff --git a/examples/ExampleUsage.java b/examples/ExampleUsage.java
index 2b7a4fa0..b5c4fc6f 100644
--- a/examples/ExampleUsage.java
+++ b/examples/ExampleUsage.java
@@ -1,5 +1,3 @@
-import com.loopj.android.http.*;
-
 public class ExampleUsage {
     public static void makeRequest() {
         AsyncHttpClient client = new AsyncHttpClient();
diff --git a/examples/TestCaseExampleUsage.java b/examples/TestCaseExampleUsage.java
new file mode 100644
index 00000000..ce949817
--- /dev/null
+++ b/examples/TestCaseExampleUsage.java
@@ -0,0 +1,63 @@
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+
+import android.test.InstrumentationTestCase;
+import android.util.Log;
+
+// Credits to Wuyexiong <forever_crying@qq.com>
+// See: https://github.com/loopj/android-async-http/pull/236
+public class TestCaseExampleUsage extends InstrumentationTestCase
+{
+	protected String TAG = TestCaseExampleUsage.class.getSimpleName();
+
+	public void testAsync() throws Throwable
+	{
+		final CountDownLatch signal = new CountDownLatch(1);
+		runTestOnUiThread(new Runnable()
+		{
+			@Override
+			public void run()
+			{
+				AsyncHttpClient client = new AsyncHttpClient();
+
+				client.get("http://www.google.com", new AsyncHttpResponseHandler()
+				{
+					@Override
+					public void onStart()
+					{
+						Log.v(TAG , "onStart");
+					}
+
+					@Override
+					public void onSuccess(String response)
+					{
+						Log.v(TAG , "onSuccess");
+						System.out.println(response);
+					}
+
+					@Override
+					public void onFailure(Throwable error, String content)
+					{
+						Log.e(TAG , "onFailure error : " + error.toString() + "content : " + content);
+					}
+
+					@Override
+					public void onFinish()
+					{
+						Log.v(TAG , "onFinish");
+						signal.countDown();
+					}
+				});
+
+				try {
+					signal.await(30, TimeUnit.SECONDS);
+				} catch (InterruptedException e) {
+				}
+				Log.v(TAG , "TestCaseExampleUsage Over");
+			}
+		});
+	}
+}
\ No newline at end of file
diff --git a/examples/TwitterRestClient.java b/examples/TwitterRestClient.java
index 387a8711..395273df 100644
--- a/examples/TwitterRestClient.java
+++ b/examples/TwitterRestClient.java
@@ -1,7 +1,5 @@
 // Static wrapper library around AsyncHttpClient
 
-import com.loopj.android.http.*;
-
 public class TwitterRestClient {
     private static final String BASE_URL = "http://api.twitter.com/1/";
 
diff --git a/examples/TwitterRestClientUsage.java b/examples/TwitterRestClientUsage.java
index a4c89c8c..297bfecc 100644
--- a/examples/TwitterRestClientUsage.java
+++ b/examples/TwitterRestClientUsage.java
@@ -1,18 +1,15 @@
-import org.json.*;
-import com.loopj.android.http.*;
-
 class TwitterRestClientUsage {
     public void getPublicTimeline() {
         TwitterRestClient.get("statuses/public_timeline.json", null, new JsonHttpResponseHandler() {
             @Override
             public void onSuccess(JSONArray timeline) {
                 try {
-                    JSONObject firstEvent = (JSONObject)timeline.get(0);
+                    JSONObject firstEvent = (JSONObject) timeline.get(0);
                     String tweetText = firstEvent.getString("text");
 
                     // Do something with the response
                     System.out.println(tweetText);
-                } catch(JSONException e) {
+                } catch (JSONException e) {
                     e.printStackTrace();
                 }
             }
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..0de12ce9
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,12 @@
+VERSION_NAME=1.4.4-SNAPSHOT
+VERSION_CODE=144
+GROUP=com.loopj.android
+
+POM_DESCRIPTION=An Asynchronous HTTP Library for Android
+POM_URL=loopj.com/android-async-http/
+POM_SCM_URL=https://github.com/loopj/android-async-http
+POM_SCM_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:loopj/android-async-http.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
diff --git a/AndroidManifest.xml b/library/AndroidManifest.xml
similarity index 54%
rename from AndroidManifest.xml
rename to library/AndroidManifest.xml
index fbeab8b4..1ad7c0fc 100644
--- a/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,11 +1,15 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.loopj.android.http"
-    android:versionName="1.4.1"
-    android:versionCode="1">
-    <application
-        android:name="android_async_http">
-    </application>
-    <uses-sdk android:minSdkVersion="3" />
+    android:versionName="1.4.4-SNAPSHOT"
+    android:versionCode="144">
+
+    <uses-sdk
+        android:minSdkVersion="3"
+        android:targetSdkVersion="18" />
+
     <uses-permission android:name="android.permission.INTERNET" />
+
+    <application />
+
 </manifest> 
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..680db873
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'android-library'
+
+dependencies {
+    compile 'com.android.support:support-v4:18.0.+'
+}
+
+android {
+    compileSdkVersion 18
+    buildToolsVersion '18.0.1'
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            res.srcDirs = ['res']
+        }
+    }
+}
+
+android.libraryVariants.all { variant ->
+
+    task("generate${variant.name}Javadoc", type: Javadoc) {
+        description "Generates Javadoc for $variant.name."
+        source = variant.javaCompile.source
+        ext.androidJar = "${android.plugin.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
+        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+    }
+
+}
+
+apply from: '../maven_push.gradle'
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100644
index 00000000..d6aa0de5
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=ActionBar-PullToRefresh Library
+POM_ARTIFACT_ID=android-async-http
+POM_PACKAGING=aar
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
similarity index 58%
rename from src/com/loopj/android/http/AsyncHttpClient.java
rename to library/src/com/loopj/android/http/AsyncHttpClient.java
index 188fe730..efe76848 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -18,22 +18,13 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.zip.GZIPInputStream;
+import android.content.Context;
+import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
 import org.apache.http.HttpEntity;
+import org.apache.http.HttpHost;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpRequestInterceptor;
 import org.apache.http.HttpResponse;
@@ -46,39 +37,53 @@
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpHead;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
+import org.apache.http.conn.params.ConnRoutePNames;
 import org.apache.http.conn.scheme.PlainSocketFactory;
 import org.apache.http.conn.scheme.Scheme;
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
 import org.apache.http.entity.HttpEntityWrapper;
 import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.BasicHttpContext;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
-import android.content.Context;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
 
 
 /**
- * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and
  * DELETE HTTP requests in your Android applications. Requests can be made
  * with additional parameters by passing a {@link RequestParams} instance,
- * and responses can be handled by passing an anonymously overridden 
+ * and responses can be handled by passing an anonymously overridden
  * {@link AsyncHttpResponseHandler} instance.
- * <p>
+ * <p>&nbsp;</p>
  * For example:
- * <p>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -90,7 +95,9 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    private static final String VERSION = "1.4.1";
+    // This property won't be available soon, don't use it
+    @Deprecated
+    private static final String VERSION = "1.4.4";
 
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
     private static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
@@ -98,6 +105,7 @@
     private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
     private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
     private static final String ENCODING_GZIP = "gzip";
+    private static final String LOG_TAG = "AsyncHttpClient";
 
     private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
     private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
@@ -110,9 +118,41 @@
 
 
     /**
-     * Creates a new AsyncHttpClient.
+     * Creates a new AsyncHttpClient with default constructor arguments values
      */
     public AsyncHttpClient() {
+        this(false, 80, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public AsyncHttpClient(int httpPort) {
+        this(false, httpPort, 443);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public AsyncHttpClient(int httpPort, int httpsPort) {
+        this(false, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates a new AsyncHttpClient.
+     *
+     * @param fixNoHttpResponseException See issue https://github.com/loopj/android-async-http/issues/143
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        if (fixNoHttpResponseException)
+            Log.d(LOG_TAG, "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
         BasicHttpParams httpParams = new BasicHttpParams();
 
         ConnManagerParams.setTimeout(httpParams, socketTimeout);
@@ -127,14 +167,28 @@ public AsyncHttpClient() {
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
         HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
+        // Fix to SSL flaw in API < ICS
+        // See https://code.google.com/p/android/issues/detail?id=13117
+        SSLSocketFactory sslSocketFactory;
+        if (fixNoHttpResponseException)
+            sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();
+        else
+            sslSocketFactory = SSLSocketFactory.getSocketFactory();
+
         SchemeRegistry schemeRegistry = new SchemeRegistry();
-        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
-        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), httpPort));
+        schemeRegistry.register(new Scheme("https", sslSocketFactory, httpsPort));
+
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
+        threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
+        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        clientHeaderMap = new HashMap<String, String>();
+
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
         httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
             public void process(HttpRequest request, HttpContext context) {
                 if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
                     request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
@@ -146,6 +200,7 @@ public void process(HttpRequest request, HttpContext context) {
         });
 
         httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+            @Override
             public void process(HttpResponse response, HttpContext context) {
                 final HttpEntity entity = response.getEntity();
                 if (entity == null) {
@@ -164,26 +219,25 @@ public void process(HttpResponse response, HttpContext context) {
         });
 
         httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
-
-        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
-
-        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
-        clientHeaderMap = new HashMap<String, String>();
     }
 
     /**
      * Get the underlying HttpClient instance. This is useful for setting
      * additional fine-grained settings for requests by accessing the
      * client's ConnectionManager, HttpParams and SchemeRegistry.
+     *
+     * @return underlying HttpClient instance
      */
     public HttpClient getHttpClient() {
         return this.httpClient;
     }
 
     /**
-     * Get the underlying HttpContext instance. This is useful for getting 
+     * Get the underlying HttpContext instance. This is useful for getting
      * and setting fine-grained settings for requests by accessing the
      * context's attributes such as the CookieStore.
+     *
+     * @return underlying HttpContext instance
      */
     public HttpContext getHttpContext() {
         return this.httpContext;
@@ -191,6 +245,7 @@ public HttpContext getHttpContext() {
 
     /**
      * Sets an optional CookieStore to use when making requests
+     *
      * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
      */
     public void setCookieStore(CookieStore cookieStore) {
@@ -200,15 +255,32 @@ public void setCookieStore(CookieStore cookieStore) {
     /**
      * Overrides the threadpool implementation used when queuing/pooling
      * requests. By default, Executors.newCachedThreadPool() is used.
+     *
      * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
      */
     public void setThreadPool(ThreadPoolExecutor threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Simple interface method, to enable or disable redirects.
+     * If you set manually RedirectHandler on underlying HttpClient, effects of this method will be canceled.
+     *
+     * @param enableRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects) {
+        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
+            @Override
+            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
+                return enableRedirects;
+            }
+        });
+    }
+
     /**
      * Sets the User-Agent header to be sent with each request. By default,
      * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     *
      * @param userAgent the string to use in the User-Agent header.
      */
     public void setUserAgent(String userAgent) {
@@ -216,76 +288,117 @@ public void setUserAgent(String userAgent) {
     }
 
     /**
-     * Sets the connection time oout. By default, 10 seconds
+     * Set the connection timeout. By default, 10 seconds.
+     *
      * @param timeout the connect/socket timeout in milliseconds
      */
-    public void setTimeout(int timeout){
+    public void setTimeout(int timeout) {
         final HttpParams httpParams = this.httpClient.getParams();
         ConnManagerParams.setTimeout(httpParams, timeout);
         HttpConnectionParams.setSoTimeout(httpParams, timeout);
         HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
     }
 
+    /**
+     * Sets the Proxy by it's hostname and port
+     *
+     * @param hostname the hostname (IP or DNS name)
+     * @param port     the port number. -1 indicates the scheme default port.
+     */
+    public void setProxy(String hostname, int port) {
+        final HttpHost proxy = new HttpHost(hostname, port);
+        final HttpParams httpParams = this.httpClient.getParams();
+        httpParams.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
+    }
+
     /**
      * Sets the SSLSocketFactory to user when making requests. By default,
      * a new, default SSLSocketFactory is used.
+     *
      * @param sslSocketFactory the socket factory to use for https requests.
      */
     public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
         this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
     }
-    
+
+    /**
+     * Sets the maximum number of retries for a particular Request.
+     *
+     * @param retries maximum number of retries per request
+     */
+    public void setMaxRetries(int retries) {
+        this.httpClient.setHttpRequestRetryHandler(new RetryHandler(retries));
+    }
+
     /**
      * Sets headers that will be added to all requests this client makes (before sending).
+     *
      * @param header the name of the header
-     * @param value the contents of the header
+     * @param value  the contents of the header
      */
     public void addHeader(String header, String value) {
         clientHeaderMap.put(header, value);
     }
 
+    /**
+     * Remove header from all requests this client makes (before sending).
+     *
+     * @param header the name of the header
+     */
+    public void removeHeader(String header) {
+        clientHeaderMap.remove(header);
+    }
+
     /**
      * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
-     * setBasicAuth('username','password',AuthScope.ANY) 
-     * @param username
-     * @param password
+     * setBasicAuth('username','password',AuthScope.ANY)
+     *
+     * @param username Basic Auth username
+     * @param password Basic Auth password
      */
-    public void setBasicAuth(String user, String pass){
+    public void setBasicAuth(String username, String password) {
         AuthScope scope = AuthScope.ANY;
-        setBasicAuth(user, pass, scope);
+        setBasicAuth(username, password, scope);
     }
-    
-   /**
+
+    /**
      * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
      * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
-     * @param username
-     * @param password
-     * @param scope - an AuthScope object
      *
+     * @param username Basic Auth username
+     * @param password Basic Auth password
+     * @param scope    - an AuthScope object
      */
-    public void setBasicAuth( String user, String pass, AuthScope scope){
-        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
+    public void setBasicAuth(String username, String password, AuthScope scope) {
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
         this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
     }
 
+    /**
+     * Removes set basic auth credentials
+     */
+    public void clearBasicAuth() {
+        this.httpClient.getCredentialsProvider().clear();
+    }
+
     /**
      * Cancels any pending (or potentially active) requests associated with the
      * passed Context.
-     * <p>
+     * <p>&nbsp;</p>
      * <b>Note:</b> This will only affect requests which were created with a non-null
      * android Context. This method is intended to be used in the onDestroy
      * method of your android activities to destroy all requests which are no
      * longer required.
      *
-     * @param context the android Context instance associated to the request.
+     * @param context               the android Context instance associated to the request.
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
      */
     public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-        if(requestList != null) {
-            for(WeakReference<Future<?>> requestRef : requestList) {
+        if (requestList != null) {
+            for (WeakReference<Future<?>> requestRef : requestList) {
                 Future<?> request = requestRef.get();
-                if(request != null) {
+                if (request != null) {
                     request.cancel(mayInterruptIfRunning);
                 }
             }
@@ -293,6 +406,72 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
         requestMap.remove(context);
     }
 
+    //
+    // HTTP HEAD Requests
+    //
+
+    /**
+     * Perform a HTTP HEAD request, without any parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(String url, AsyncHttpResponseHandler responseHandler) {
+        head(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request with parameters.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        head(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request without any parameters and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        head(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void head(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, new HttpHead(getUrlWithQueryString(url, params)), null, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP HEAD request and track the Android Context which initiated
+     * the request with customized headers
+     *
+     * @param context         Context to execute request against
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional HEAD parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle
+     *                        the response.
+     */
+    public void head(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpUriRequest request = new HttpHead(getUrlWithQueryString(url, params));
+        if (headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
 
     //
     // HTTP GET Requests
@@ -300,7 +479,8 @@ public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
 
     /**
      * Perform a HTTP GET request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(String url, AsyncHttpResponseHandler responseHandler) {
@@ -309,8 +489,9 @@ public void get(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP GET request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -319,8 +500,9 @@ public void get(String url, RequestParams params, AsyncHttpResponseHandler respo
 
     /**
      * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
@@ -329,28 +511,30 @@ public void get(Context context, String url, AsyncHttpResponseHandler responseHa
 
     /**
      * Perform a HTTP GET request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP GET request and track the Android Context which initiated
      * the request with customized headers
-     * 
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional GET parameters to send with the request.
+     *
+     * @param context         Context to execute request against
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional GET parameters to send with the request.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
         HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, null, responseHandler,
                 context);
     }
@@ -362,7 +546,8 @@ public void get(Context context, String url, Header[] headers, RequestParams par
 
     /**
      * Perform a HTTP POST request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(String url, AsyncHttpResponseHandler responseHandler) {
@@ -371,8 +556,9 @@ public void post(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP POST request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -381,9 +567,10 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
 
     /**
      * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional POST parameters or files to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional POST parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -392,11 +579,12 @@ public void post(Context context, String url, RequestParams params, AsyncHttpRes
 
     /**
      * Perform a HTTP POST request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
-     * @param responseHandler the response handler instance that should handle the response.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link org.apache.http.HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response ha   ndler instance that should handle the response.
      */
     public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
@@ -405,21 +593,21 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     /**
      * Perform a HTTP POST request and track the Android Context which initiated
      * the request. Set headers only for this request
-     * 
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param params additional POST parameters to send with the request.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param params          additional POST parameters to send with the request.
+     * @param contentType     the content type of the payload you are sending, for
+     *                        example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
-        if(headers != null) request.setHeaders(headers);
+        if (params != null) request.setEntity(paramsToEntity(params));
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
     }
@@ -428,21 +616,21 @@ public void post(Context context, String url, Header[] headers, RequestParams pa
      * Perform a HTTP POST request and track the Android Context which initiated
      * the request. Set headers only for this request
      *
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set headers only for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for
-     *        example, use this to send string/json/xml payloads to a server by
-     *        passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for
-     *        example application/json if sending a json payload.
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set headers only for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for
+     *                        example, use this to send string/json/xml payloads to a server by
+     *                        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for
+     *                        example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle
-     *        the response.
+     *                        the response.
      */
     public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
-            AsyncHttpResponseHandler responseHandler) {
+                     AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -452,7 +640,8 @@ public void post(Context context, String url, Header[] headers, HttpEntity entit
 
     /**
      * Perform a HTTP PUT request, without any parameters.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(String url, AsyncHttpResponseHandler responseHandler) {
@@ -461,8 +650,9 @@ public void put(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP PUT request with parameters.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
+     *
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -471,9 +661,10 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
 
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param params additional PUT parameters or files to send with the request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param params          additional PUT parameters or files to send with the request.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
@@ -483,29 +674,31 @@ public void put(Context context, String url, RequestParams params, AsyncHttpResp
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
      * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP PUT request and track the Android Context which initiated the request.
      * And set one-time headers for the request
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
-     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
-     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param entity          a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType     the content type of the payload you are sending, for example application/json if sending a json payload.
      * @param responseHandler the response handler instance that should handle the response.
      */
-    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+    public void put(Context context, String url, Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
-        if(headers != null) request.setHeaders(headers);
+        if (headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
     }
 
@@ -515,7 +708,8 @@ public void put(Context context, String url,Header[] headers, HttpEntity entity,
 
     /**
      * Perform a HTTP DELETE request.
-     * @param url the URL to send the request to.
+     *
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(String url, AsyncHttpResponseHandler responseHandler) {
@@ -524,41 +718,58 @@ public void delete(String url, AsyncHttpResponseHandler responseHandler) {
 
     /**
      * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
-    
+
     /**
      * Perform a HTTP DELETE request.
-     * @param context the Android Context which initiated the request.
-     * @param url the URL to send the request to.
-     * @param headers set one-time headers for this request
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
         final HttpDelete delete = new HttpDelete(url);
-        if(headers != null) delete.setHeaders(headers);
+        if (headers != null) delete.setHeaders(headers);
         sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
     }
 
+    /**
+     * Perform a HTTP DELETE request.
+     *
+     * @param context         the Android Context which initiated the request.
+     * @param url             the URL to send the request to.
+     * @param headers         set one-time headers for this request
+     * @param params          additional DELETE parameters or files to send along with request
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpDelete httpDelete = new HttpDelete(getUrlWithQueryString(url, params));
+        if (headers != null) httpDelete.setHeaders(headers);
+        sendRequest(httpClient, httpContext, httpDelete, null, responseHandler, context);
+    }
+
 
     // Private stuff
     protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
-        if(contentType != null) {
+        if (contentType != null) {
             uriRequest.addHeader("Content-Type", contentType);
         }
 
         Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
 
-        if(context != null) {
+        if (context != null) {
             // Add request to request map
             List<WeakReference<Future<?>>> requestList = requestMap.get(context);
-            if(requestList == null) {
+            if (requestList == null) {
                 requestList = new LinkedList<WeakReference<Future<?>>>();
                 requestMap.put(context, requestList);
             }
@@ -570,9 +781,13 @@ protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, Ht
     }
 
     public static String getUrlWithQueryString(String url, RequestParams params) {
-        if(params != null) {
+        if (params != null) {
             String paramString = params.getParamString();
-            url += "?" + paramString;
+            if (!url.contains("?")) {
+                url += "?" + paramString;
+            } else {
+                url += "&" + paramString;
+            }
         }
 
         return url;
@@ -581,7 +796,7 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
     private HttpEntity paramsToEntity(RequestParams params) {
         HttpEntity entity = null;
 
-        if(params != null) {
+        if (params != null) {
             entity = params.getEntity();
         }
 
@@ -589,7 +804,7 @@ private HttpEntity paramsToEntity(RequestParams params) {
     }
 
     private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
-        if(entity != null){
+        if (entity != null) {
             requestBase.setEntity(entity);
         }
 
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
similarity index 66%
rename from src/com/loopj/android/http/AsyncHttpRequest.java
rename to library/src/com/loopj/android/http/AsyncHttpRequest.java
index 83effe31..fa28d254 100644
--- a/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -18,17 +18,20 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-
 import org.apache.http.HttpResponse;
+import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.http.protocol.HttpContext;
 
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
 class AsyncHttpRequest implements Runnable {
     private final AbstractHttpClient client;
     private final HttpContext context;
@@ -42,26 +45,27 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if(responseHandler instanceof BinaryHttpResponseHandler) {
+        if (responseHandler instanceof BinaryHttpResponseHandler) {
             this.isBinaryRequest = true;
         }
     }
 
+    @Override
     public void run() {
         try {
-            if(responseHandler != null){
+            if (responseHandler != null) {
                 responseHandler.sendStartMessage();
             }
 
             makeRequestWithRetries();
 
-            if(responseHandler != null) {
+            if (responseHandler != null) {
                 responseHandler.sendFinishMessage();
             }
         } catch (IOException e) {
-            if(responseHandler != null) {
+            if (responseHandler != null) {
                 responseHandler.sendFinishMessage();
-                if(this.isBinaryRequest) {
+                if (this.isBinaryRequest) {
                     responseHandler.sendFailureMessage(e, (byte[]) null);
                 } else {
                     responseHandler.sendFailureMessage(e, (String) null);
@@ -71,14 +75,20 @@ public void run() {
     }
 
     private void makeRequest() throws IOException {
-        if(!Thread.currentThread().isInterrupted()) {
-            HttpResponse response = client.execute(request, context);
-            if(!Thread.currentThread().isInterrupted()) {
-                if(responseHandler != null) {
-                    responseHandler.sendResponseMessage(response);
+        if (!Thread.currentThread().isInterrupted()) {
+            try {
+                HttpResponse response = client.execute(request, context);
+                if (!Thread.currentThread().isInterrupted()) {
+                    if (responseHandler != null) {
+                        responseHandler.sendResponseMessage(response);
+                    }
+                } else {
+                    //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
+                }
+            } catch (IOException e) {
+                if (!Thread.currentThread().isInterrupted()) {
+                    throw e;
                 }
-            } else{
-                //TODO: should raise InterruptedException? this block is reached whenever the request is cancelled before its response is received
             }
         }
     }
@@ -93,17 +103,31 @@ private void makeRequestWithRetries() throws ConnectException {
             try {
                 makeRequest();
                 return;
+            } catch (ClientProtocolException e) {
+                if(responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "cannot repeat the request");
+                }
+                return;
             } catch (UnknownHostException e) {
-		        if(responseHandler != null) {
-		            responseHandler.sendFailureMessage(e, "can't resolve host");
-		        }
-	        	return;
-            }catch (SocketException e){
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "can't resolve host");
+                }
+                return;
+            } catch (ConnectTimeoutException e) {
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "connection timed out");
+                }
+            } catch (SocketException e) {
                 // Added to detect host unreachable
-                if(responseHandler != null) {
+                if (responseHandler != null) {
                     responseHandler.sendFailureMessage(e, "can't resolve host");
                 }
                 return;
+            } catch (SocketTimeoutException e) {
+                if (responseHandler != null) {
+                    responseHandler.sendFailureMessage(e, "socket time out");
+                }
+                return;
             } catch (IOException e) {
                 cause = e;
                 retry = retryHandler.retryRequest(cause, ++executionCount, context);
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
similarity index 54%
rename from src/com/loopj/android/http/AsyncHttpResponseHandler.java
rename to library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 6c6ba088..7fdd9890 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,6 +21,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+
+import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -31,15 +33,15 @@
 import java.io.IOException;
 
 /**
- * Used to intercept and handle the responses from requests made using 
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is 
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
  * designed to be anonymously overridden with your own response handling code.
- * <p>
+ * <p>&nbsp;</p>
  * Additionally, you can override the {@link #onFailure(Throwable, String)},
  * {@link #onStart()}, and {@link #onFinish()} methods as required.
- * <p>
+ * <p>&nbsp;</p>
  * For example:
- * <p>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
@@ -52,7 +54,7 @@
  *     public void onSuccess(String response) {
  *         // Successfully got a response
  *     }
- * 
+ *
  *     &#064;Override
  *     public void onFailure(Throwable e, String response) {
  *         // Response failed :(
@@ -72,15 +74,27 @@
     protected static final int FINISH_MESSAGE = 3;
 
     private Handler handler;
+    private String responseCharset = "UTF-8";
+
+    /**
+     * Sets the charset for the response string. If not set, the default is UTF-8.
+     *
+     * @param charset to be used for the response string.
+     * @see <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">Charset</a>
+     */
+    public void setCharset(final String charset) {
+        this.responseCharset = charset;
+    }
 
     /**
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
         // Set up a handler to post events back to the correct thread if possible
-        if(Looper.myLooper() != null) {
-            handler = new Handler(){
-                public void handleMessage(Message msg){
+        if (Looper.myLooper() != null) {
+            handler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
                     AsyncHttpResponseHandler.this.handleMessage(msg);
                 }
             };
@@ -95,23 +109,39 @@ public void handleMessage(Message msg){
     /**
      * Fired when the request is started, override to handle in your own code
      */
-    public void onStart() {}
+    public void onStart() {
+    }
 
     /**
      * Fired in all cases when the request is finished, after both success and failure, override to handle in your own code
      */
-    public void onFinish() {}
+    public void onFinish() {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param content the body of the HTTP response from the server
      */
-    public void onSuccess(String content) {}
+    public void onSuccess(String content) {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param statusCode the status code of the response
-     * @param content the body of the HTTP response from the server
+     * @param headers    the headers of the HTTP response
+     * @param content    the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, Header[] headers, String content) {
+        onSuccess(statusCode, content);
+    }
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     *
+     * @param statusCode the status code of the response
+     * @param content    the body of the HTTP response from the server
      */
     public void onSuccess(int statusCode, String content) {
         onSuccess(content);
@@ -119,14 +149,18 @@ public void onSuccess(int statusCode, String content) {
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
+     *
      * @param error the underlying cause of the failure
      * @deprecated use {@link #onFailure(Throwable, String)}
      */
-    public void onFailure(Throwable error) {}
+    @Deprecated
+    public void onFailure(Throwable error) {
+    }
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
+     *
+     * @param error   the underlying cause of the failure
      * @param content the response body, if any
      */
     public void onFailure(Throwable error, String content) {
@@ -134,21 +168,56 @@ public void onFailure(Throwable error, String content) {
         onFailure(error);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode return HTTP status code
+     * @param error   the underlying cause of the failure
+     * @param content the response body, if any
+     */
+    public void onFailure(int statusCode, Throwable error, String content) {
+        // By default, call the chain method onFailure(Throwable,String)
+        onFailure(error, content);
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode return HTTP status code
+     * @param headers return headers, if any
+     * @param error   the underlying cause of the failure
+     * @param content the response body, if any
+     */
+    public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+        // By default, call the chain method onFailure(int,Throwable,String)
+        onFailure(statusCode, error, content);
+    }
+
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
     //
 
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{new Integer(statusCode), responseBody}));
+    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
+    }
+
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
     }
 
+    @Deprecated
     protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
     }
-    
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
+    }
+
+    @Deprecated
+    protected void sendFailureMessage( Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
     }
 
     protected void sendStartMessage() {
@@ -164,28 +233,27 @@ protected void sendFinishMessage() {
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
 
-    protected void handleSuccessMessage(int statusCode, String responseBody) {
-        onSuccess(statusCode, responseBody);
+    protected void handleSuccessMessage(int statusCode, Header[] headers, String responseBody) {
+        onSuccess(statusCode, headers, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
     }
 
 
-
     // Methods which emulate android's Handler and Message methods
     protected void handleMessage(Message msg) {
         Object[] response;
 
-        switch(msg.what) {
+        switch (msg.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue(), (String) response[1]);
+                response = (Object[]) msg.obj;
+                handleSuccessMessage((Integer) response[0], (Header[]) response[1], (String) response[2]);
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (String)response[1]);
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (String) response[3]);
                 break;
             case START_MESSAGE:
                 onStart();
@@ -197,7 +265,7 @@ protected void handleMessage(Message msg) {
     }
 
     protected void sendMessage(Message msg) {
-        if(handler != null){
+        if (handler != null) {
             handler.sendMessage(msg);
         } else {
             handleMessage(msg);
@@ -205,36 +273,39 @@ protected void sendMessage(Message msg) {
     }
 
     protected Message obtainMessage(int responseMessage, Object response) {
-        Message msg = null;
-        if(handler != null){
+        Message msg;
+        if (handler != null) {
             msg = this.handler.obtainMessage(responseMessage, response);
-        }else{
-            msg = new Message();
-            msg.what = responseMessage;
-            msg.obj = response;
+        } else {
+            msg = Message.obtain();
+            if (msg != null) {
+                msg.what = responseMessage;
+                msg.obj = response;
+            }
         }
         return msg;
     }
 
     // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
+    protected void sendResponseMessage(HttpResponse response) {
         StatusLine status = response.getStatusLine();
         String responseBody = null;
         try {
-            HttpEntity entity = null;
+            HttpEntity entity;
             HttpEntity temp = response.getEntity();
-            if(temp != null) {
+            if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, "UTF-8");
+                responseBody = EntityUtils.toString(entity, responseCharset);
             }
-        } catch(IOException e) {
-            sendFailureMessage(e, (String) null);
+        } catch (IOException e) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (String) null);
+            return;
         }
 
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        if (status.getStatusCode() >= 300) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
+            sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
similarity index 67%
rename from src/com/loopj/android/http/BinaryHttpResponseHandler.java
rename to library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index aff1c631..08255419 100644
--- a/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http;
 
 import android.os.Message;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
@@ -28,15 +29,16 @@
 import org.apache.http.util.EntityUtils;
 
 import java.io.IOException;
+import java.util.regex.Pattern;
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. Receives response body as byte array with a 
- * content-type whitelist. (e.g. checks Content-Type against allowed list, 
+ * {@link AsyncHttpClient}. Receives response body as byte array with a
+ * content-type whitelist. (e.g. checks Content-Type against allowed list,
  * Content-length).
- * <p>
+ * <p>&nbsp;</p>
  * For example:
- * <p>
+ * <p>&nbsp;</p>
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * String[] allowedTypes = new String[] { "image/png" };
@@ -55,9 +57,9 @@
  */
 public class BinaryHttpResponseHandler extends AsyncHttpResponseHandler {
     // Allow images by default
-    private static String[] mAllowedContentTypes = new String[] {
-        "image/jpeg",
-        "image/png"
+    private static String[] mAllowedContentTypes = new String[]{
+            "image/jpeg",
+            "image/png"
     };
 
     /**
@@ -70,6 +72,8 @@ public BinaryHttpResponseHandler() {
     /**
      * Creates a new BinaryHttpResponseHandler, and overrides the default allowed
      * content types with passed String array (hopefully) of content types.
+     *
+     * @param allowedContentTypes content types array, eg. 'image/jpeg'
      */
     public BinaryHttpResponseHandler(String[] allowedContentTypes) {
         this();
@@ -83,12 +87,15 @@ public BinaryHttpResponseHandler(String[] allowedContentTypes) {
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param binaryData the body of the HTTP response from the server
      */
-    public void onSuccess(byte[] binaryData) {}
+    public void onSuccess(byte[] binaryData) {
+    }
 
     /**
      * Fired when a request returns successfully, override to handle in your own code
+     *
      * @param statusCode the status code of the response
      * @param binaryData the body of the HTTP response from the server
      */
@@ -98,13 +105,17 @@ public void onSuccess(int statusCode, byte[] binaryData) {
 
     /**
      * Fired when a request fails to complete, override to handle in your own code
-     * @param error the underlying cause of the failure
+     *
+     * @param statusCode response HTTP statuse code
+     * @param headers    response headers, if any
+     * @param error      the underlying cause of the failure
      * @param binaryData the response body, if any
      * @deprecated
      */
-    public void onFailure(Throwable error, byte[] binaryData) {
+    @Deprecated
+    public void onFailure(int statusCode, Header[] headers, Throwable error, byte[] binaryData) {
         // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(error);
+        onFailure(statusCode, error, null);
     }
 
 
@@ -116,8 +127,9 @@ protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
     }
 
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{e, responseBody}));
+    @Override
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
     }
 
     //
@@ -128,21 +140,22 @@ protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
         onSuccess(statusCode, responseBody);
     }
 
-    protected void handleFailureMessage(Throwable e, byte[] responseBody) {
-        onFailure(e, responseBody);
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
     }
 
     // Methods which emulate android's Handler and Message methods
+    @Override
     protected void handleMessage(Message msg) {
         Object[] response;
-        switch(msg.what) {
+        switch (msg.what) {
             case SUCCESS_MESSAGE:
-                response = (Object[])msg.obj;
-                handleSuccessMessage(((Integer) response[0]).intValue() , (byte[]) response[1]);
+                response = (Object[]) msg.obj;
+                handleSuccessMessage((Integer) response[0], (byte[]) response[1]);
                 break;
             case FAILURE_MESSAGE:
-                response = (Object[])msg.obj;
-                handleFailureMessage((Throwable)response[0], (byte[])response[1]);
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (byte[]) response[3]);
                 break;
             default:
                 super.handleMessage(msg);
@@ -151,42 +164,43 @@ protected void handleMessage(Message msg) {
     }
 
     // Interface to AsyncHttpRequest
-    void sendResponseMessage(HttpResponse response) {
+    @Override
+    protected void sendResponseMessage(HttpResponse response) {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
         byte[] responseBody = null;
-        if(contentTypeHeaders.length != 1) {
+        if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), responseBody);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
         boolean foundAllowedContentType = false;
-        for(String anAllowedContentType : mAllowedContentTypes) {
-            if(anAllowedContentType.equals(contentTypeHeader.getValue())) {
+        for (String anAllowedContentType : mAllowedContentTypes) {
+            if (Pattern.matches(anAllowedContentType, contentTypeHeader.getValue())) {
                 foundAllowedContentType = true;
             }
         }
-        if(!foundAllowedContentType) {
+        if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), responseBody);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
             return;
         }
         try {
             HttpEntity entity = null;
             HttpEntity temp = response.getEntity();
-            if(temp != null) {
+            if (temp != null) {
                 entity = new BufferedHttpEntity(temp);
             }
             responseBody = EntityUtils.toByteArray(entity);
-        } catch(IOException e) {
-            sendFailureMessage(e, (byte[]) null);
+        } catch (IOException e) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (byte[]) null);
         }
 
-        if(status.getStatusCode() >= 300) {
-            sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
+        if (status.getStatusCode() >= 300) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
         } else {
             sendSuccessMessage(status.getStatusCode(), responseBody);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
new file mode 100644
index 00000000..7bb674fc
--- /dev/null
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -0,0 +1,109 @@
+package com.loopj.android.http;
+
+import android.os.Message;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    private File mFile;
+
+    public FileAsyncHttpResponseHandler(File file) {
+        super();
+        this.mFile = file;
+    }
+
+    public void onSuccess(File file) {
+    }
+
+    public void onSuccess(int statusCode, File file) {
+        onSuccess(file);
+    }
+
+    public void onFailure(Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(e, response);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, File response) {
+        // By default call lower chain method
+        onFailure(statusCode, e, response);
+    }
+
+
+    protected void sendSuccessMessage(int statusCode, File file) {
+        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, file}));
+    }
+
+    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, File file) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, file}));
+    }
+
+    protected void handleSuccessMessage(int statusCode, File responseBody) {
+        onSuccess(statusCode, responseBody);
+    }
+
+    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, File responseBody) {
+        onFailure(statusCode, headers, e, responseBody);
+    }
+
+    // Methods which emulate android's Handler and Message methods
+    protected void handleMessage(Message msg) {
+        Object[] response;
+        switch (msg.what) {
+            case SUCCESS_MESSAGE:
+                response = (Object[]) msg.obj;
+                handleSuccessMessage((Integer) response[0], (File) response[1]);
+                break;
+            case FAILURE_MESSAGE:
+                response = (Object[]) msg.obj;
+                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (File) response[3]);
+                break;
+            default:
+                super.handleMessage(msg);
+                break;
+        }
+    }
+
+    @Override
+    protected void sendResponseMessage(HttpResponse response) {
+        StatusLine status = response.getStatusLine();
+
+        try {
+            FileOutputStream buffer = new FileOutputStream(this.mFile);
+            InputStream is = response.getEntity().getContent();
+
+            int nRead;
+            byte[] data = new byte[16384];
+
+            while ((nRead = is.read(data, 0, data.length)) != -1)
+                buffer.write(data, 0, nRead);
+
+            buffer.flush();
+            buffer.close();
+
+        } catch (IOException e) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, this.mFile);
+        }
+
+        if (status.getStatusCode() >= 300) {
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
+        } else {
+            sendSuccessMessage(status.getStatusCode(), this.mFile);
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
new file mode 100644
index 00000000..33855fc9
--- /dev/null
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -0,0 +1,239 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import android.os.Message;
+
+import org.apache.http.Header;
+import org.apache.http.HttpStatus;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
+ * or {@link JSONArray}.
+ * <p>&nbsp;</p>
+ * This class is designed to be passed to get, post, put and delete requests
+ * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
+ * methods anonymously overridden.
+ * <p>&nbsp;</p>
+ * Additionally, you can override the other event methods from the
+ * parent class.
+ */
+public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
+    protected static final int SUCCESS_JSON_MESSAGE = 100;
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param response the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(JSONObject response) {
+    }
+
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param response the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(JSONArray response) {
+    }
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param statusCode the status code of the response
+     * @param headers    the headers of the HTTP response
+     * @param response   the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
+        onSuccess(statusCode, response);
+    }
+
+    /**
+     * Fired when a request returns successfully and contains a json object
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param statusCode the status code of the response
+     * @param response   the parsed json object found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONObject response) {
+        onSuccess(response);
+    }
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param statusCode the status code of the response
+     * @param headers    the headers of the HTTP response
+     * @param response   the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
+        onSuccess(statusCode, response);
+    }
+
+    /**
+     * Fired when a request returns successfully and contains a json array
+     * at the base of the response string. Override to handle in your
+     * own code.
+     *
+     * @param statusCode the status code of the response
+     * @param response   the parsed json array found in the server response (if any)
+     */
+    public void onSuccess(int statusCode, JSONArray response) {
+        onSuccess(response);
+    }
+
+    public void onFailure(Throwable e, JSONObject errorResponse) {
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, JSONObject errorResponse) {
+        onFailure(e, errorResponse);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONObject errorResponse) {
+        onFailure(statusCode, e, errorResponse);
+    }
+
+    public void onFailure(Throwable e, JSONArray errorResponse) {
+        onFailure(e);
+    }
+
+    public void onFailure(int statusCode, Throwable e, JSONArray errorResponse) {
+        onFailure(e, errorResponse);
+    }
+
+    public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray errorResponse) {
+        onFailure(statusCode, e, errorResponse);
+    }
+
+
+    //
+    // Pre-processing of messages (executes in background threadpool thread)
+    //
+
+    @Override
+    protected void sendSuccessMessage(final int statusCode, final Header[] headers, final String responseBody) {
+        if (statusCode != HttpStatus.SC_NO_CONTENT) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        Object jsonResponse = parseResponse(responseBody);
+                        sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+                    } catch (JSONException e) {
+                        sendFailureMessage(statusCode, headers, e, responseBody);
+                    }
+                }
+            }).start();
+        } else {
+            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, new JSONObject()}));
+        }
+    }
+
+
+    //
+    // Pre-processing of messages (in original calling thread, typically the UI thread)
+    //
+
+    @Override
+    protected void handleMessage(Message msg) {
+        switch (msg.what) {
+            case SUCCESS_JSON_MESSAGE:
+                Object[] response = (Object[]) msg.obj;
+                handleSuccessJsonMessage((Integer) response[0], (Header[]) response[1], response[2]);
+                break;
+            default:
+                super.handleMessage(msg);
+        }
+    }
+
+    protected void handleSuccessJsonMessage(int statusCode, Header[] headers, Object jsonResponse) {
+        if (jsonResponse instanceof JSONObject) {
+            onSuccess(statusCode, headers, (JSONObject) jsonResponse);
+        } else if (jsonResponse instanceof JSONArray) {
+            onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+        } else if (jsonResponse instanceof String) {
+            onSuccess(statusCode, headers, (String) jsonResponse);
+        } else {
+            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+        }
+    }
+
+    protected Object parseResponse(String responseBody) throws JSONException {
+        if (null == responseBody)
+            return null;
+        Object result = null;
+        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+        responseBody = responseBody.trim();
+        if (responseBody.startsWith("{") || responseBody.startsWith("[")) {
+            result = new JSONTokener(responseBody).nextValue();
+        }
+        if (result == null) {
+            result = responseBody;
+        }
+        return result;
+    }
+
+    @Override
+    protected void handleFailureMessage(final int statusCode, final Header[] headers, final Throwable e, final String responseBody) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    if (responseBody != null) {
+                        Object jsonResponse = parseResponse(responseBody);
+                        if (jsonResponse instanceof JSONObject) {
+                            onFailure(statusCode, headers, e, (JSONObject) jsonResponse);
+                        } else if (jsonResponse instanceof JSONArray) {
+                            onFailure(statusCode, headers, e, (JSONArray) jsonResponse);
+                        } else if (jsonResponse instanceof String) {
+                            onFailure(statusCode, headers, e, (String) jsonResponse);
+                        } else {
+                            onFailure(statusCode, headers, e, responseBody);
+                        }
+                    } else {
+                        onFailure(e, "");
+                    }
+                } catch (JSONException ex) {
+                    onFailure(statusCode, headers, e, responseBody);
+                }
+            }
+        }).start();
+
+    }
+}
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/com/loopj/android/http/MySSLSocketFactory.java
new file mode 100644
index 00000000..fdfbffc9
--- /dev/null
+++ b/library/src/com/loopj/android/http/MySSLSocketFactory.java
@@ -0,0 +1,83 @@
+package com.loopj.android.http;
+
+import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * This file is introduced to fix HTTPS Post bug on API &lt; ICS
+ * see http://code.google.com/p/android/issues/detail?id=13117#c14
+ */
+public class MySSLSocketFactory extends SSLSocketFactory {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+
+    public MySSLSocketFactory(KeyStore truststore)
+            throws NoSuchAlgorithmException, KeyManagementException,
+            KeyStoreException, UnrecoverableKeyException {
+        super(truststore);
+
+        TrustManager tm = new X509TrustManager() {
+            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                return null;
+            }
+
+            @Override
+            public void checkClientTrusted(
+                    java.security.cert.X509Certificate[] chain, String authType)
+                    throws java.security.cert.CertificateException {
+            }
+
+            @Override
+            public void checkServerTrusted(
+                    java.security.cert.X509Certificate[] chain, String authType)
+                    throws java.security.cert.CertificateException {
+            }
+        };
+        sslContext.init(null, new TrustManager[]{tm}, null);
+    }
+
+    @Override
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
+    }
+
+    @Override
+    public Socket createSocket() throws IOException {
+        return sslContext.getSocketFactory().createSocket();
+    }
+
+    public static KeyStore getKeystore() {
+        KeyStore trustStore = null;
+        try {
+            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            trustStore.load(null, null);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+        return trustStore;
+    }
+
+    public static SSLSocketFactory getFixedSocketFactory() {
+        SSLSocketFactory socketFactory;
+        try {
+            socketFactory = new MySSLSocketFactory(getKeystore());
+            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+        } catch (Throwable t) {
+            t.printStackTrace();
+            socketFactory = SSLSocketFactory.getSocketFactory();
+        }
+        return socketFactory;
+    }
+
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/library/src/com/loopj/android/http/PersistentCookieStore.java
similarity index 86%
rename from src/com/loopj/android/http/PersistentCookieStore.java
rename to library/src/com/loopj/android/http/PersistentCookieStore.java
index 94076682..69d790fa 100644
--- a/src/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/com/loopj/android/http/PersistentCookieStore.java
@@ -18,6 +18,13 @@
 
 package com.loopj.android.http;
 
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.text.TextUtils;
+
+import org.apache.http.client.CookieStore;
+import org.apache.http.cookie.Cookie;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
@@ -27,21 +34,14 @@
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.client.CookieStore;
-import org.apache.http.cookie.Cookie;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.text.TextUtils;
-
 /**
  * A persistent cookie store which implements the Apache HttpClient
  * {@link CookieStore} interface. Cookies are stored and will persist on the
  * user's device between application sessions since they are serialized and
  * stored in {@link SharedPreferences}.
- * <p>
+ * <p>&nbsp;</p>
  * Instances of this class are designed to be used with
- * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
+ * {@link AsyncHttpClient#setCookieStore}, but can also be used with a
  * regular old apache HttpClient/HttpContext if you prefer.
  */
 public class PersistentCookieStore implements CookieStore {
@@ -54,6 +54,8 @@
 
     /**
      * Construct a persistent cookie store.
+     *
+     * @param context Context to attach cookie store to
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
@@ -61,13 +63,13 @@ public PersistentCookieStore(Context context) {
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
-        if(storedCookieNames != null) {
+        if (storedCookieNames != null) {
             String[] cookieNames = TextUtils.split(storedCookieNames, ",");
-            for(String name : cookieNames) {
+            for (String name : cookieNames) {
                 String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
-                if(encodedCookie != null) {
+                if (encodedCookie != null) {
                     Cookie decodedCookie = decodeCookie(encodedCookie);
-                    if(decodedCookie != null) {
+                    if (decodedCookie != null) {
                         cookies.put(name, decodedCookie);
                     }
                 }
@@ -80,10 +82,10 @@ public PersistentCookieStore(Context context) {
 
     @Override
     public void addCookie(Cookie cookie) {
-        String name = cookie.getName();
+        String name = cookie.getName() + cookie.getDomain();
 
         // Save cookie into local store, or remove if expired
-        if(!cookie.isExpired(new Date())) {
+        if (!cookie.isExpired(new Date())) {
             cookies.put(name, cookie);
         } else {
             cookies.remove(name);
@@ -98,16 +100,16 @@ public void addCookie(Cookie cookie) {
 
     @Override
     public void clear() {
-        // Clear cookies from local store
-        cookies.clear();
-
         // Clear cookies from persistent store
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
-        for(String name : cookies.keySet()) {
+        for (String name : cookies.keySet()) {
             prefsWriter.remove(COOKIE_NAME_PREFIX + name);
         }
         prefsWriter.remove(COOKIE_NAME_STORE);
         prefsWriter.commit();
+
+        // Clear cookies from local store
+        cookies.clear();
     }
 
     @Override
@@ -115,10 +117,10 @@ public boolean clearExpired(Date date) {
         boolean clearedAny = false;
         SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
 
-        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
             String name = entry.getKey();
             Cookie cookie = entry.getValue();
-            if(cookie.isExpired(date)) {
+            if (cookie.isExpired(date)) {
                 // Clear cookies from local store
                 cookies.remove(name);
 
@@ -131,7 +133,7 @@ public boolean clearExpired(Date date) {
         }
 
         // Update names in persistent store
-        if(clearedAny) {
+        if (clearedAny) {
             prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
         }
         prefsWriter.commit();
@@ -166,10 +168,10 @@ protected Cookie decodeCookie(String cookieStr) {
         ByteArrayInputStream is = new ByteArrayInputStream(bytes);
         Cookie cookie = null;
         try {
-           ObjectInputStream ois = new ObjectInputStream(is);
-           cookie = ((SerializableCookie)ois.readObject()).getCookie();
+            ObjectInputStream ois = new ObjectInputStream(is);
+            cookie = ((SerializableCookie) ois.readObject()).getCookie();
         } catch (Exception e) {
-           e.printStackTrace();
+            e.printStackTrace();
         }
 
         return cookie;
@@ -178,10 +180,10 @@ protected Cookie decodeCookie(String cookieStr) {
     // Using some super basic byte array <-> hex conversions so we don't have
     // to rely on any large Base64 libraries. Can be overridden if you like!
     protected String byteArrayToHexString(byte[] b) {
-        StringBuffer sb = new StringBuffer(b.length * 2);
+        StringBuilder sb = new StringBuilder(b.length * 2);
         for (byte element : b) {
             int v = element & 0xff;
-            if(v < 16) {
+            if (v < 16) {
                 sb.append('0');
             }
             sb.append(Integer.toHexString(v));
@@ -192,8 +194,8 @@ protected String byteArrayToHexString(byte[] b) {
     protected byte[] hexStringToByteArray(String s) {
         int len = s.length();
         byte[] data = new byte[len / 2];
-        for(int i=0; i<len; i+=2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/src/com/loopj/android/http/RequestParams.java b/library/src/com/loopj/android/http/RequestParams.java
similarity index 60%
rename from src/com/loopj/android/http/RequestParams.java
rename to library/src/com/loopj/android/http/RequestParams.java
index d8110e25..5121f5b1 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/library/src/com/loopj/android/http/RequestParams.java
@@ -18,27 +18,28 @@
 
 package com.loopj.android.http;
 
-import java.io.InputStream;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.apache.http.message.BasicNameValuePair;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-
 /**
  * A collection of string request parameters or files to send along with
  * requests made from an {@link AsyncHttpClient} instance.
- * <p>
+ * <p>&nbsp;</p>
  * For example:
- * <p>
+ * <p>&nbsp;</p>
  * <pre>
  * RequestParams params = new RequestParams();
  * params.put("username", "james");
@@ -57,6 +58,7 @@
 
     protected ConcurrentHashMap<String, String> urlParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
+    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
 
     /**
      * Constructs a new empty <code>RequestParams</code> instance.
@@ -68,12 +70,13 @@ public RequestParams() {
     /**
      * Constructs a new RequestParams instance containing the key/value
      * string params from the specified map.
+     *
      * @param source the source key/value string map to add.
      */
     public RequestParams(Map<String, String> source) {
         init();
 
-        for(Map.Entry<String, String> entry : source.entrySet()) {
+        for (Map.Entry<String, String> entry : source.entrySet()) {
             put(entry.getKey(), entry.getValue());
         }
     }
@@ -81,7 +84,8 @@ public RequestParams(Map<String, String> source) {
     /**
      * Constructs a new RequestParams instance and populate it with a single
      * initial key/value string param.
-     * @param key the key name for the intial param.
+     *
+     * @param key   the key name for the intial param.
      * @param value the value string for the initial param.
      */
     public RequestParams(String key, String value) {
@@ -93,45 +97,92 @@ public RequestParams(String key, String value) {
     /**
      * Constructs a new RequestParams instance and populate it with multiple
      * initial key/value string param.
+     *
      * @param keysAndValues a sequence of keys and values. Objects are
-     * automatically converted to Strings (including the value {@code null}).
+     *                      automatically converted to Strings (including the value {@code null}).
      * @throws IllegalArgumentException if the number of arguments isn't even.
      */
     public RequestParams(Object... keysAndValues) {
-      init();
-      int len = keysAndValues.length;
-      if (len % 2 != 0)
-        throw new IllegalArgumentException("Supplied arguments must be even");
-      for (int i = 0; i < len; i += 2) {
-        String key = String.valueOf(keysAndValues[i]);
-        String val = String.valueOf(keysAndValues[i + 1]);
-        put(key, val);
-      }
+        init();
+        int len = keysAndValues.length;
+        if (len % 2 != 0)
+            throw new IllegalArgumentException("Supplied arguments must be even");
+        for (int i = 0; i < len; i += 2) {
+            String key = String.valueOf(keysAndValues[i]);
+            String val = String.valueOf(keysAndValues[i + 1]);
+            put(key, val);
+        }
     }
 
     /**
      * Adds a key/value string pair to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key   the key name for the new param.
      * @param value the value string for the new param.
      */
-    public void put(String key, String value){
-        if(key != null && value != null) {
+    public void put(String key, String value) {
+        if (key != null && value != null) {
             urlParams.put(key, value);
         }
     }
 
+    /**
+     * Adds a integer param to the request.
+     *
+     * @param key   the key name for the new param.
+     * @param value the integer value for the new param.
+     */
+    public void put(String key, int value) {
+        if (key != null) {
+            urlParams.put(key, String.valueOf(value));
+        }
+    }
+
     /**
      * Adds a file to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key  the key name for the new param.
      * @param file the file to add.
+     *
+     * @throws java.io.FileNotFoundException if the file is not found
      */
     public void put(String key, File file) throws FileNotFoundException {
         put(key, new FileInputStream(file), file.getName());
     }
 
+    /**
+     * Adds param with more than one value.
+     *
+     * @param key    the key name for the new param.
+     * @param values is the ArrayList with values for the param.
+     */
+    public void put(String key, ArrayList<String> values) {
+        if (key != null && values != null) {
+            urlParamsWithArray.put(key, values);
+        }
+    }
+
+    /**
+     * Adds value to param which can have more than one value.
+     *
+     * @param key   the key name for the param, either existing or new.
+     * @param value the value string for the new param.
+     */
+    public void add(String key, String value) {
+        if (key != null && value != null) {
+            ArrayList<String> paramArray = urlParamsWithArray.get(key);
+            if (paramArray == null) {
+                paramArray = new ArrayList<String>();
+                this.put(key, paramArray);
+            }
+            paramArray.add(value);
+        }
+    }
+
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
+     *
+     * @param key    the key name for the new param.
      * @param stream the input stream to add.
      */
     public void put(String key, InputStream stream) {
@@ -140,8 +191,9 @@ public void put(String key, InputStream stream) {
 
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
+     *
+     * @param key      the key name for the new param.
+     * @param stream   the input stream to add.
      * @param fileName the name of the file.
      */
     public void put(String key, InputStream stream, String fileName) {
@@ -150,31 +202,34 @@ public void put(String key, InputStream stream, String fileName) {
 
     /**
      * Adds an input stream to the request.
-     * @param key the key name for the new param.
-     * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     *
+     * @param key         the key name for the new param.
+     * @param stream      the input stream to add.
+     * @param fileName    the name of the file.
      * @param contentType the content type of the file, eg. application/json
      */
     public void put(String key, InputStream stream, String fileName, String contentType) {
-        if(key != null && stream != null) {
+        if (key != null && stream != null) {
             fileParams.put(key, new FileWrapper(stream, fileName, contentType));
         }
     }
 
     /**
      * Removes a parameter from the request.
+     *
      * @param key the key name for the parameter to remove.
      */
-    public void remove(String key){
+    public void remove(String key) {
         urlParams.remove(key);
         fileParams.remove(key);
+        urlParamsWithArray.remove(key);
     }
 
     @Override
     public String toString() {
         StringBuilder result = new StringBuilder();
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-            if(result.length() > 0)
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            if (result.length() > 0)
                 result.append("&");
 
             result.append(entry.getKey());
@@ -182,8 +237,8 @@ public String toString() {
             result.append(entry.getValue());
         }
 
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-            if(result.length() > 0)
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if (result.length() > 0)
                 result.append("&");
 
             result.append(entry.getKey());
@@ -191,31 +246,55 @@ public String toString() {
             result.append("FILE");
         }
 
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
+            ArrayList<String> values = entry.getValue();
+            for (int i = 0; i < values.size(); i++) {
+                if (i != 0)
+                    result.append("&");
+                result.append(entry.getKey());
+                result.append("=");
+                result.append(values.get(i));
+            }
+        }
+
         return result.toString();
     }
 
-   /**
+    /**
      * Returns an HttpEntity containing all request parameters
+     *
+     * @return an HttpEntity containing all request parameters
      */
     public HttpEntity getEntity() {
         HttpEntity entity = null;
 
-        if(!fileParams.isEmpty()) {
+        if (!fileParams.isEmpty()) {
             SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
 
             // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
                 multipartEntity.addPart(entry.getKey(), entry.getValue());
             }
 
+            // Add dupe params
+            for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+                ArrayList<String> values = entry.getValue();
+                for (String value : values) {
+                    multipartEntity.addPart(entry.getKey(), value);
+                }
+            }
+
             // Add file params
             int currentIndex = 0;
             int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
                 FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
+                if (file.inputStream != null) {
                     boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
+                    if (file.contentType != null) {
                         multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
                     } else {
                         multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
@@ -236,18 +315,26 @@ public HttpEntity getEntity() {
         return entity;
     }
 
-    private void init(){
+    private void init() {
         urlParams = new ConcurrentHashMap<String, String>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
+        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
     }
 
     protected List<BasicNameValuePair> getParamsList() {
         List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
 
-        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
         }
 
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                lparams.add(new BasicNameValuePair(entry.getKey(), value));
+            }
+        }
+
         return lparams;
     }
 
@@ -267,11 +354,11 @@ public FileWrapper(InputStream inputStream, String fileName, String contentType)
         }
 
         public String getFileName() {
-            if(fileName != null) {
+            if (fileName != null) {
                 return fileName;
             } else {
                 return "nofilename";
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/loopj/android/http/RetryHandler.java b/library/src/com/loopj/android/http/RetryHandler.java
similarity index 81%
rename from src/com/loopj/android/http/RetryHandler.java
rename to library/src/com/loopj/android/http/RetryHandler.java
index 96d7c00a..59eb5ffa 100644
--- a/src/com/loopj/android/http/RetryHandler.java
+++ b/library/src/com/loopj/android/http/RetryHandler.java
@@ -23,21 +23,21 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.util.HashSet;
-
-import javax.net.ssl.SSLHandshakeException;
+import android.os.SystemClock;
 
 import org.apache.http.NoHttpResponseException;
-import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.HttpRequestRetryHandler;
+import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HttpContext;
 
-import android.os.SystemClock;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.HashSet;
+
+import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
     private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
@@ -55,7 +55,7 @@
         // never retry timeouts
         exceptionBlacklist.add(InterruptedIOException.class);
         // never retry SSL handshake failures
-        exceptionBlacklist.add(SSLHandshakeException.class);
+        exceptionBlacklist.add(SSLException.class);
     }
 
     private final int maxRetries;
@@ -64,19 +64,20 @@ public RetryHandler(int maxRetries) {
         this.maxRetries = maxRetries;
     }
 
+    @Override
     public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
         boolean retry = true;
 
         Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
-        boolean sent = (b != null && b.booleanValue());
+        boolean sent = (b != null && b);
 
-        if(executionCount > maxRetries) {
+        if (executionCount > maxRetries) {
             // Do not retry if over max retry count
             retry = false;
-        } else if (exceptionBlacklist.contains(exception.getClass())) {
+        } else if (isInList(exceptionBlacklist, exception)) {
             // immediately cancel retry if the error is blacklisted
             retry = false;
-        } else if (exceptionWhitelist.contains(exception.getClass())) {
+        } else if (isInList(exceptionWhitelist, exception)) {
             // immediately retry if error is whitelisted
             retry = true;
         } else if (!sent) {
@@ -84,14 +85,14 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
             retry = true;
         }
 
-        if(retry) {
+        if (retry) {
             // resend all idempotent requests
-            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
-            String requestType = currentReq.getMethod();
+            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
+            String requestType = currentReq != null ? currentReq.getMethod() : "";
             retry = !requestType.equals("POST");
         }
 
-        if(retry) {
+        if (retry) {
             SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
         } else {
             exception.printStackTrace();
@@ -99,4 +100,13 @@ public boolean retryRequest(IOException exception, int executionCount, HttpConte
 
         return retry;
     }
+
+    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
+        for (Class<?> aList : list) {
+            if (aList.isInstance(error)) {
+                return true;
+            }
+        }
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/library/src/com/loopj/android/http/SerializableCookie.java
similarity index 85%
rename from src/com/loopj/android/http/SerializableCookie.java
rename to library/src/com/loopj/android/http/SerializableCookie.java
index cc12993c..d9730d21 100644
--- a/src/com/loopj/android/http/SerializableCookie.java
+++ b/library/src/com/loopj/android/http/SerializableCookie.java
@@ -18,15 +18,15 @@
 
 package com.loopj.android.http;
 
-import java.io.Serializable;
+import org.apache.http.cookie.Cookie;
+import org.apache.http.impl.cookie.BasicClientCookie;
+
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import java.io.IOException;
+import java.io.Serializable;
 import java.util.Date;
 
-import org.apache.http.cookie.Cookie;
-import org.apache.http.impl.cookie.BasicClientCookie;
-
 /**
  * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
  * designed for use in {@link PersistentCookieStore}.
@@ -43,7 +43,7 @@ public SerializableCookie(Cookie cookie) {
 
     public Cookie getCookie() {
         Cookie bestCookie = cookie;
-        if(clientCookie != null) {
+        if (clientCookie != null) {
             bestCookie = clientCookie;
         }
         return bestCookie;
@@ -61,13 +61,13 @@ private void writeObject(ObjectOutputStream out) throws IOException {
     }
 
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        String name = (String)in.readObject();
-        String value = (String)in.readObject();
+        String name = (String) in.readObject();
+        String value = (String) in.readObject();
         clientCookie = new BasicClientCookie(name, value);
-        clientCookie.setComment((String)in.readObject());
-        clientCookie.setDomain((String)in.readObject());
-        clientCookie.setExpiryDate((Date)in.readObject());
-        clientCookie.setPath((String)in.readObject());
+        clientCookie.setComment((String) in.readObject());
+        clientCookie.setDomain((String) in.readObject());
+        clientCookie.setExpiryDate((Date) in.readObject());
+        clientCookie.setPath((String) in.readObject());
         clientCookie.setVersion(in.readInt());
         clientCookie.setSecure(in.readBoolean());
     }
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
similarity index 77%
rename from src/com/loopj/android/http/SimpleMultipartEntity.java
rename to library/src/com/loopj/android/http/SimpleMultipartEntity.java
index bff0efcc..b072b8b0 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -23,20 +23,20 @@
 
 package com.loopj.android.http;
 
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
-import java.io.InputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Random;
 
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-
 class SimpleMultipartEntity implements HttpEntity {
     private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
@@ -47,7 +47,7 @@
     boolean isSetFirst = false;
 
     public SimpleMultipartEntity() {
-        final StringBuffer buf = new StringBuffer();
+        final StringBuilder buf = new StringBuilder();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
@@ -56,25 +56,30 @@ public SimpleMultipartEntity() {
 
     }
 
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
-            try {
-                out.write(("--" + boundary + "\r\n").getBytes());
-            } catch (final IOException e) {
-                e.printStackTrace();
-            }
+    public void writeFirstBoundaryIfNeeds() {
+        if (!isSetFirst) {
+            writeBoundary();
         }
 
         isSetFirst = true;
     }
 
+    public void writeBoundary() {
+        try {
+            out.write(("--" + boundary + "\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
     public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
+        if (isSetLast) {
             return;
         }
 
         try {
-            out.write(("\r\n--" + boundary + "--\r\n").getBytes());
+            out.write(("--" + boundary + "--\r\n").getBytes());
+            out.flush();
         } catch (final IOException e) {
             e.printStackTrace();
         }
@@ -82,37 +87,41 @@ public void writeLastBoundaryIfNeeds() {
         isSetLast = true;
     }
 
-    public void addPart(final String key, final String value) {
-        writeFirstBoundaryIfNeeds();
+    public void addPart(final String key, final String value, final String contentType) {
+        writeBoundary();
         try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n\r\n").getBytes());
+            out.write(("Content-Disposition: form-data; name=\"" + key + "\"\r\n").getBytes());
+            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
             out.write(value.getBytes());
-            out.write(("\r\n--" + boundary + "\r\n").getBytes());
+            out.write(("\r\n").getBytes());
         } catch (final IOException e) {
             e.printStackTrace();
         }
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
+    public void addPart(final String key, final String value) {
+        addPart(key, value, "text/plain; charset=UTF-8");
+    }
+
+    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast) {
         addPart(key, fileName, fin, "application/octet-stream", isLast);
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeFirstBoundaryIfNeeds();
+    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast) {
+        writeBoundary();
         try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
+            type = "Content-Type: " + type + "\r\n";
+            out.write(("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n").getBytes());
             out.write(type.getBytes());
             out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
 
             final byte[] tmp = new byte[4096];
-            int l = 0;
+            int l;
             while ((l = fin.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
             }
-            if(!isLast)
-                out.write(("\r\n--" + boundary + "\r\n").getBytes());
-            out.flush();
+            out.write(("\r\n").getBytes());
+
         } catch (final IOException e) {
             e.printStackTrace();
         } finally {
@@ -160,6 +169,7 @@ public boolean isStreaming() {
 
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
+        writeLastBoundaryIfNeeds();
         outstream.write(out.toByteArray());
     }
 
@@ -170,16 +180,17 @@ public Header getContentEncoding() {
 
     @Override
     public void consumeContent() throws IOException,
-    UnsupportedOperationException {
+            UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
-            "Streaming entity does not implement #consumeContent()");
+                    "Streaming entity does not implement #consumeContent()");
         }
     }
 
     @Override
     public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
+            UnsupportedOperationException {
+        writeLastBoundaryIfNeeds();
         return new ByteArrayInputStream(out.toByteArray());
     }
 }
\ No newline at end of file
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
new file mode 100644
index 00000000..8e73471a
--- /dev/null
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -0,0 +1,129 @@
+package com.loopj.android.http;
+
+import android.content.Context;
+import android.os.Message;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+public abstract class SyncHttpClient extends AsyncHttpClient {
+    private int responseCode;
+    /*
+     * as this is a synchronous request this is just a helping mechanism to pass
+     * the result back to this method. Therefore the result object has to be a
+     * field to be accessible
+     */
+    protected String result;
+    protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
+
+        @Override
+        protected void sendResponseMessage(org.apache.http.HttpResponse response) {
+            responseCode = response.getStatusLine().getStatusCode();
+            super.sendResponseMessage(response);
+        }
+
+        @Override
+        protected void sendMessage(Message msg) {
+            /*
+			 * Dont use the handler and send it directly to the analysis
+			 * (because its all the same thread)
+			 */
+            handleMessage(msg);
+        }
+
+        @Override
+        public void onSuccess(String content) {
+            result = content;
+        }
+
+        @Override
+        public void onFailure(Throwable error, String content) {
+            result = onRequestFailed(error, content);
+        }
+    };
+
+    /**
+     * @return the response code for the last request, might be usefull
+     * sometimes
+     */
+    public int getResponseCode() {
+        return responseCode;
+    }
+
+    // Private stuff
+    @Override
+    protected void sendRequest(DefaultHttpClient client,
+                               HttpContext httpContext, HttpUriRequest uriRequest,
+                               String contentType, AsyncHttpResponseHandler responseHandler,
+                               Context context) {
+        if (contentType != null) {
+            uriRequest.addHeader("Content-Type", contentType);
+        }
+
+		/*
+		 * will execute the request directly
+		 */
+        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
+                .run();
+    }
+
+    public abstract String onRequestFailed(Throwable error, String content);
+
+    public void delete(String url, RequestParams queryParams,
+                       AsyncHttpResponseHandler responseHandler) {
+        // TODO what about query params??
+        delete(url, responseHandler);
+    }
+
+    public String get(String url, RequestParams params) {
+        this.get(url, params, responseHandler);
+		/*
+		 * the response handler will have set the result when this line is
+		 * reached
+		 */
+        return result;
+    }
+
+    public String get(String url) {
+        this.get(url, null, responseHandler);
+        return result;
+    }
+
+    public String put(String url, RequestParams params) {
+        this.put(url, params, responseHandler);
+        return result;
+    }
+
+    public String put(String url) {
+        this.put(url, null, responseHandler);
+        return result;
+    }
+
+    public String post(String url, HttpEntity entity){
+        this.post(null, url, entity, null, responseHandler);
+        return result;
+    }
+
+    public String post(String url, RequestParams params) {
+        this.post(url, params, responseHandler);
+        return result;
+    }
+
+    public String post(String url) {
+        this.post(url, null, responseHandler);
+        return result;
+    }
+
+    public String delete(String url, RequestParams params) {
+        this.delete(url, params, responseHandler);
+        return result;
+    }
+
+    public String delete(String url) {
+        this.delete(url, null, responseHandler);
+        return result;
+    }
+
+}
diff --git a/local.properties.dist b/local.properties.dist
deleted file mode 100644
index 5ecd58e1..00000000
--- a/local.properties.dist
+++ /dev/null
@@ -1 +0,0 @@
-sdk.dir=/usr/local/android_sdk/
\ No newline at end of file
diff --git a/maven_push.gradle b/maven_push.gradle
new file mode 100644
index 00000000..1c7ec711
--- /dev/null
+++ b/maven_push.gradle
@@ -0,0 +1,104 @@
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+configurations {
+    archives {
+        extendsFrom configurations.default
+    }
+}
+
+def sonatypeRepositoryUrl
+if (isReleaseBuild()) {
+    println 'RELEASE BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+} else {
+    println 'DEBUG BUILD'
+    sonatypeRepositoryUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+if (ext.properties.containsKey('signing.keyId') && !ext.properties.containsKey('signing.password')) {
+    if (System.console())
+        ext.set('signing.password', System.console().readPassword("\n\$ Type in GPG key password: "))
+    else
+        ext.set('signing.password', 'dummy')
+}
+
+if (System.env.TERM != 'dumb' && !ext.properties.containsKey('nexusPassword')) {
+    if (System.console())
+        ext.set('nexusPassword', new String(System.console().readPassword("\n\$ Type in password for Sonatype nexus account ${nexusUsername}: ")))
+    else
+    	ext.set('nexusPassword', 'dummy')
+}
+
+afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+                pom.artifactId = POM_ARTIFACT_ID
+
+                repository(url: sonatypeRepositoryUrl) {
+                    authentication(userName: nexusUsername, password: nexusPassword)
+                }
+
+                pom.project {
+                    name POM_NAME
+                    packaging POM_PACKAGING
+                    description POM_DESCRIPTION
+                    url POM_URL
+
+                    scm {
+                        url POM_SCM_URL
+                        connection POM_SCM_CONNECTION
+                        developerConnection POM_SCM_DEV_CONNECTION
+                    }
+
+                    licenses {
+                        license {
+                            name POM_LICENCE_NAME
+                            url POM_LICENCE_URL
+                            distribution POM_LICENCE_DIST
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id "loopj"
+                            name "James Smith"
+                        }
+                        developer {
+                            id "smarek"
+                            name "Marek Sebera"
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+
+    task androidReleaseJar(type: Jar, dependsOn: assembleRelease) {
+        from "$buildDir/classes/release/"
+    }
+
+    task androidJavadocsJar(type: Jar) {
+        classifier = 'javadoc'
+        from generateReleaseJavadoc.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+        classifier = 'sources'
+        from android.sourceSets.main.allSource
+    }
+
+    artifacts {
+        archives androidReleaseJar
+        archives androidSourcesJar
+        archives androidJavadocsJar
+    }
+}
diff --git a/project.properties b/project.properties
deleted file mode 100644
index 1880987e..00000000
--- a/project.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-3
diff --git a/releases/android-async-http-1.2.0.jar b/releases/android-async-http-1.2.0.jar
new file mode 100644
index 00000000..3fd4789b
Binary files /dev/null and b/releases/android-async-http-1.2.0.jar differ
diff --git a/releases/android-async-http-1.2.1.jar b/releases/android-async-http-1.2.1.jar
new file mode 100644
index 00000000..4db7cf11
Binary files /dev/null and b/releases/android-async-http-1.2.1.jar differ
diff --git a/releases/android-async-http-1.3.0.jar b/releases/android-async-http-1.3.0.jar
new file mode 100644
index 00000000..faebdf0f
Binary files /dev/null and b/releases/android-async-http-1.3.0.jar differ
diff --git a/releases/android-async-http-1.3.1.jar b/releases/android-async-http-1.3.1.jar
new file mode 100644
index 00000000..107b032d
Binary files /dev/null and b/releases/android-async-http-1.3.1.jar differ
diff --git a/releases/android-async-http-1.3.2.jar b/releases/android-async-http-1.3.2.jar
new file mode 100644
index 00000000..0af40632
Binary files /dev/null and b/releases/android-async-http-1.3.2.jar differ
diff --git a/releases/android-async-http-1.4.0.jar b/releases/android-async-http-1.4.0.jar
new file mode 100644
index 00000000..2109150d
Binary files /dev/null and b/releases/android-async-http-1.4.0.jar differ
diff --git a/releases/android-async-http-1.4.1.jar b/releases/android-async-http-1.4.1.jar
new file mode 100644
index 00000000..551f5fbf
Binary files /dev/null and b/releases/android-async-http-1.4.1.jar differ
diff --git a/releases/android-async-http-1.4.2.jar b/releases/android-async-http-1.4.2.jar
new file mode 100644
index 00000000..1c568cb9
Binary files /dev/null and b/releases/android-async-http-1.4.2.jar differ
diff --git a/releases/android-async-http-1.4.3.jar b/releases/android-async-http-1.4.3.jar
new file mode 100644
index 00000000..3a749a59
Binary files /dev/null and b/releases/android-async-http-1.4.3.jar differ
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..e469038a
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include 'library'
diff --git a/src/com/loopj/android/http/JsonHttpResponseHandler.java b/src/com/loopj/android/http/JsonHttpResponseHandler.java
deleted file mode 100644
index 8d3973ac..00000000
--- a/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-    Android Asynchronous Http Client
-    Copyright (c) 2011 James Smith <james@loopj.com>
-    http://loopj.com
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-*/
-
-package com.loopj.android.http;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-import android.os.Message;
-
-/**
- * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
- * or {@link JSONArray}.
- * <p>
- * This class is designed to be passed to get, post, put and delete requests
- * with the {@link #onSuccess(JSONObject)} or {@link #onSuccess(JSONArray)}
- * methods anonymously overridden.
- * <p>
- * Additionally, you can override the other event methods from the
- * parent class.
- */
-public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    protected static final int SUCCESS_JSON_MESSAGE = 100;
-
-    //
-    // Callbacks to be overridden, typically anonymously
-    //
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(JSONObject response) {}
-
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(JSONArray response) {}
-
-    /**
-     * Fired when a request returns successfully and contains a json object
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json object found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, JSONObject response) {
-        onSuccess(response);
-    }
-
-
-    /**
-     * Fired when a request returns successfully and contains a json array
-     * at the base of the response string. Override to handle in your
-     * own code.
-     * @param statusCode the status code of the response
-     * @param response the parsed json array found in the server response (if any)
-     */
-    public void onSuccess(int statusCode, JSONArray response) {
-        onSuccess(response);
-    }
-
-    public void onFailure(Throwable e, JSONObject errorResponse) {}
-    public void onFailure(Throwable e, JSONArray errorResponse) {}
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
-    @Override
-    protected void sendSuccessMessage(int statusCode, String responseBody) {
-        try {
-            Object jsonResponse = parseResponse(responseBody);
-            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, jsonResponse}));
-        } catch(JSONException e) {
-            sendFailureMessage(e, responseBody);
-        }
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    @Override
-    protected void handleMessage(Message msg) {
-        switch(msg.what){
-            case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage(((Integer) response[0]).intValue(), response[1]);
-                break;
-            default:
-                super.handleMessage(msg);
-        }
-    }
-
-    protected void handleSuccessJsonMessage(int statusCode, Object jsonResponse) {
-        if(jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, (JSONObject)jsonResponse);
-        } else if(jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, (JSONArray)jsonResponse);
-        } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject)null);
-        }
-    }
-
-    protected Object parseResponse(String responseBody) throws JSONException {
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-		responseBody = responseBody.trim();
-		if(responseBody.startsWith("{") || responseBody.startsWith("[")) {
-			result = new JSONTokener(responseBody).nextValue();
-		}
-		if (result == null) {
-			result = responseBody;
-		}
-		return result;
-    }
-
-    @Override
-    protected void handleFailureMessage(Throwable e, String responseBody) {
-        try {
-            if (responseBody != null) {
-                Object jsonResponse = parseResponse(responseBody);
-                if(jsonResponse instanceof JSONObject) {
-                    onFailure(e, (JSONObject)jsonResponse);
-                } else if(jsonResponse instanceof JSONArray) {
-                    onFailure(e, (JSONArray)jsonResponse);
-                } else {
-                    onFailure(e, responseBody);
-                }
-            }else {
-                onFailure(e, "");
-            }
-        }catch(JSONException ex) {
-            onFailure(e, responseBody);
-        }
-    }
-}
diff --git a/src/com/loopj/android/http/SyncHttpClient.java b/src/com/loopj/android/http/SyncHttpClient.java
deleted file mode 100644
index 8f55991e..00000000
--- a/src/com/loopj/android/http/SyncHttpClient.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package com.loopj.android.http;
-
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-import android.content.Context;
-import android.os.Message;
-
-public abstract class SyncHttpClient extends AsyncHttpClient {
-	private int responseCode;
-	/*
-	 * as this is a synchronous request this is just a helping mechanism to pass
-	 * the result back to this method. Therefore the result object has to be a
-	 * field to be accessible
-	 */
-	private String result;
-	AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
-
-		void sendResponseMessage(org.apache.http.HttpResponse response) {
-			responseCode = response.getStatusLine().getStatusCode();
-			super.sendResponseMessage(response);
-		};
-
-		@Override
-		protected void sendMessage(Message msg) {
-			/*
-			 * Dont use the handler and send it directly to the analysis
-			 * (because its all the same thread)
-			 */
-			handleMessage(msg);
-		}
-
-		@Override
-		public void onSuccess(String content) {
-			result = content;
-		}
-
-		@Override
-		public void onFailure(Throwable error, String content) {
-			result = onRequestFailed(error, content);
-		}
-	};
-
-	/**
-	 * @return the response code for the last request, might be usefull
-	 *         sometimes
-	 */
-	public int getResponseCode() {
-		return responseCode;
-	}
-
-	// Private stuff
-	protected void sendRequest(DefaultHttpClient client,
-			HttpContext httpContext, HttpUriRequest uriRequest,
-			String contentType, AsyncHttpResponseHandler responseHandler,
-			Context context) {
-		if (contentType != null) {
-			uriRequest.addHeader("Content-Type", contentType);
-		}
-
-		/*
-		 * will execute the request directly
-		 */
-		new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
-				.run();
-	}
-
-	public abstract String onRequestFailed(Throwable error, String content);
-
-	public void delete(String url, RequestParams queryParams,
-			AsyncHttpResponseHandler responseHandler) {
-		// TODO what about query params??
-		delete(url, responseHandler);
-	}
-
-	public String get(String url, RequestParams params) {
-		this.get(url, params, responseHandler);
-		/*
-		 * the response handler will have set the result when this line is
-		 * reached
-		 */
-		return result;
-	}
-
-	public String get(String url) {
-		this.get(url, null, responseHandler);
-		return result;
-	}
-
-	public String put(String url, RequestParams params) {
-		this.put(url, params, responseHandler);
-		return result;
-	}
-
-	public String put(String url) {
-		this.put(url, null, responseHandler);
-		return result;
-	}
-
-	public String post(String url, RequestParams params) {
-		this.post(url, params, responseHandler);
-		return result;
-	}
-
-	public String post(String url) {
-		this.post(url, null, responseHandler);
-		return result;
-	}
-
-	public String delete(String url, RequestParams params) {
-		this.delete(url, params, responseHandler);
-		return result;
-	}
-
-	public String delete(String url) {
-		this.delete(url, null, responseHandler);
-		return result;
-	}
-
-}
