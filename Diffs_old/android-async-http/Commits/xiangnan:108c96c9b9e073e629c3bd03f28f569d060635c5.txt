diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
index 97164780..2e2f68c9 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http;
 
 import android.content.Context;
+import android.os.Looper;
 import android.util.Log;
 
 import org.apache.http.Header;
@@ -38,6 +39,7 @@
 import org.apache.http.client.CookieStore;
 import org.apache.http.client.CredentialsProvider;
 import org.apache.http.client.HttpClient;
+import org.apache.http.client.RedirectHandler;
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
@@ -45,6 +47,7 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
 import org.apache.http.client.protocol.ClientContext;
 import org.apache.http.conn.params.ConnManagerParams;
 import org.apache.http.conn.params.ConnPerRouteBean;
@@ -56,7 +59,6 @@
 import org.apache.http.entity.HttpEntityWrapper;
 import org.apache.http.impl.auth.BasicScheme;
 import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.client.DefaultRedirectHandler;
 import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
 import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
@@ -100,7 +102,6 @@
  */
 public class AsyncHttpClient {
 
-    public static final String VERSION = "1.4.5";
     public static final int DEFAULT_MAX_CONNECTIONS = 10;
     public static final int DEFAULT_SOCKET_TIMEOUT = 10 * 1000;
     public static final int DEFAULT_MAX_RETRIES = 5;
@@ -213,13 +214,12 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
         HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
-        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
 
         ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
 
-        threadPool = Executors.newCachedThreadPool();
-        requestMap = new WeakHashMap<>();
-        clientHeaderMap = new HashMap<>();
+        threadPool = getDefaultThreadPool();
+        requestMap = new WeakHashMap<Context, List<RequestHandle>>();
+        clientHeaderMap = new HashMap<String, String>();
 
         httpContext = new SyncBasicHttpContext(new BasicHttpContext());
         httpClient = new DefaultHttpClient(cm, httpParams);
@@ -263,6 +263,7 @@ public void process(HttpResponse response, HttpContext context) {
         });
 
         httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
             public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {
                 AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
                 CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(
@@ -337,19 +338,69 @@ public void setThreadPool(ThreadPoolExecutor threadPool) {
         this.threadPool = threadPool;
     }
 
+    /**
+     * Returns the current executor service used. By default, Executors.newFixedThreadPool() is
+     * used.
+     *
+     * @return current executor service used
+     */
+    public ExecutorService getThreadPool() {
+        return threadPool;
+    }
+
+    /**
+     * Get the default threading pool to be used for this HTTP client.
+     *
+     * @return The default threading pool to be used
+     */
+    protected ExecutorService getDefaultThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
     /**
      * Simple interface method, to enable or disable redirects. If you set manually RedirectHandler
      * on underlying HttpClient, effects of this method will be canceled.
+     * <p/>
+     * Default setting is to disallow redirects.
+     *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @param enableCircularRedirects boolean
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects, final boolean enableCircularRedirects) {
+        httpClient.getParams().setBooleanParameter(ClientPNames.REJECT_RELATIVE_REDIRECT, !enableRelativeRedirects);
+        httpClient.getParams().setBooleanParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, enableCircularRedirects);
+        httpClient.setRedirectHandler(new MyRedirectHandler(enableRedirects));
+    }
+
+    /**
+     * Circular redirects are enabled by default
      *
+     * @param enableRedirects         boolean
+     * @param enableRelativeRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
+     */
+    public void setEnableRedirects(final boolean enableRedirects, final boolean enableRelativeRedirects) {
+        setEnableRedirects(enableRedirects, enableRelativeRedirects, true);
+    }
+
+    /**
      * @param enableRedirects boolean
+     * @see #setEnableRedirects(boolean, boolean, boolean)
      */
     public void setEnableRedirects(final boolean enableRedirects) {
-        httpClient.setRedirectHandler(new DefaultRedirectHandler() {
-            @Override
-            public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
-                return enableRedirects;
-            }
-        });
+        setEnableRedirects(enableRedirects, enableRedirects, enableRedirects);
+    }
+
+    /**
+     * Allows you to set custom RedirectHandler implementation, if the default provided doesn't suit
+     * your needs
+     *
+     * @param customRedirectHandler RedirectHandler instance
+     * @see com.loopj.android.http.MyRedirectHandler
+     */
+    public void setRedirectHandler(final RedirectHandler customRedirectHandler) {
+        httpClient.setRedirectHandler(customRedirectHandler);
     }
 
     /**
@@ -558,13 +609,27 @@ public void clearBasicAuth() {
      * @param mayInterruptIfRunning specifies if active requests should be cancelled along with
      *                              pending requests.
      */
-    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
-        List<RequestHandle> requestList = requestMap.get(context);
-        if (requestList != null) {
-            for (RequestHandle requestHandle : requestList) {
-                requestHandle.cancel(mayInterruptIfRunning);
+    public void cancelRequests(final Context context, final boolean mayInterruptIfRunning) {
+        if (context == null) {
+            Log.e(LOG_TAG, "Passed null Context to cancelRequests");
+            return;
+        }
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                List<RequestHandle> requestList = requestMap.get(context);
+                if (requestList != null) {
+                    for (RequestHandle requestHandle : requestList) {
+                        requestHandle.cancel(mayInterruptIfRunning);
+                    }
+                    requestMap.remove(context);
+                }
             }
-            requestMap.remove(context);
+        };
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            new Thread(r).start();
+        } else {
+            r.run();
         }
     }
 
@@ -1005,7 +1070,7 @@ protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpCo
             // Add request to request map
             List<RequestHandle> requestList = requestMap.get(context);
             if (requestList == null) {
-                requestList = new LinkedList<>();
+                requestList = new LinkedList();
                 requestMap.put(context, requestList);
             }
 
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
index 721dd283..81786ceb 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpRequest.java
@@ -166,9 +166,7 @@ public boolean isDone() {
 
     public boolean cancel(boolean mayInterruptIfRunning) {
         isCancelled = true;
-        if (mayInterruptIfRunning && request != null && !request.isAborted()) {
-            request.abort();
-        }
+        request.abort();
         return isCancelled();
     }
 }
diff --git a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
index 5c24e380..b345d872 100755
--- a/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -91,10 +91,10 @@
 
     protected static final int BUFFER_SIZE = 4096;
 
-    private final Handler handler;
     public static final String DEFAULT_CHARSET = "UTF-8";
     private String responseCharset = DEFAULT_CHARSET;
-    private Boolean useSynchronousMode = false;
+    private Handler handler;
+    private boolean useSynchronousMode;
 
     private URI requestURI = null;
     private Header[] requestHeaders = null;
@@ -142,6 +142,21 @@ public boolean getUseSynchronousMode() {
 
     @Override
     public void setUseSynchronousMode(boolean value) {
+        // A looper must be prepared before setting asynchronous mode.
+        if (!value && Looper.myLooper() == null) {
+            value = true;
+            Log.w(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
+        }
+
+        // If using synchronous mode.
+        if (!value && handler == null) {
+            // Create a handler on current thread to submit tasks
+            handler = new ResponderHandler(this);
+        } else if (value && handler != null) {
+            // TODO: Consider adding a flag to remove all queued messages.
+            handler = null;
+        }
+
         useSynchronousMode = value;
     }
 
@@ -163,19 +178,8 @@ public String getCharset() {
      * Creates a new AsyncHttpResponseHandler
      */
     public AsyncHttpResponseHandler() {
-	boolean missingLooper = null == Looper.myLooper();
-	// Try to create handler
-	if (!missingLooper)
-		handler = new ResponderHandler(this);
-	else {
-		// There is no Looper on this thread so synchronous mode should be used.
-		handler = null;
-		setUseSynchronousMode(true);
-		Log.i(LOG_TAG, "Current thread has not called Looper.prepare(). Forcing synchronous mode.");
-	}
-
-        // Init Looper by calling postRunnable without an argument.
-        postRunnable(null);
+        // Use asynchronous mode by default.
+        setUseSynchronousMode(false);
     }
 
     /**
@@ -185,7 +189,7 @@ public AsyncHttpResponseHandler() {
      * @param totalSize    total size of file
      */
     public void onProgress(int bytesWritten, int totalSize) {
-        Log.v(LOG_TAG, String.format("Progress %d from %d (%d%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten / totalSize) * 100 : -1));
+        Log.v(LOG_TAG, String.format("Progress %d from %d (%2.0f%%)", bytesWritten, totalSize, (totalSize > 0) ? (bytesWritten * 1.0 / totalSize) * 100 : -1));
     }
 
     /**
@@ -314,7 +318,7 @@ protected void handleMessage(Message message) {
     }
 
     protected void sendMessage(Message msg) {
-        if (getUseSynchronousMode()) {
+        if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
         } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
             handler.sendMessage(msg);
@@ -328,9 +332,9 @@ protected void sendMessage(Message msg) {
      */
     protected void postRunnable(Runnable runnable) {
         if (runnable != null) {
-            if (getUseSynchronousMode()){
-		// This response handler is synchronous, run on current thread
-		runnable.run();
+            if (getUseSynchronousMode() || handler == null) {
+                // This response handler is synchronous, run on current thread
+                runnable.run();
             } else {
                 // Otherwise, run on provided handler
                 handler.post(runnable);
@@ -346,7 +350,17 @@ protected void postRunnable(Runnable runnable) {
      * @return Message instance, should not be null
      */
     protected Message obtainMessage(int responseMessageId, Object responseMessageData) {
-	return Message.obtain(handler, responseMessageId, responseMessageData);
+        Message msg;
+        if (handler == null) {
+            msg = Message.obtain();
+            if (msg != null) {
+                msg.what = responseMessageId;
+                msg.obj = responseMessageData;
+            }
+        } else {
+            msg = Message.obtain(handler, responseMessageId, responseMessageData);
+        }
+        return msg;
     }
 
     @Override
diff --git a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
index 192d49a9..6db13641 100755
--- a/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
+++ b/library/src/main/java/com/loopj/android/http/JsonStreamerEntity.java
@@ -71,7 +71,7 @@
         new BasicHeader("Content-Encoding", "gzip");
 
     // JSON data and associated meta-data to be uploaded.
-    private final Map<String, Object> jsonParams = new HashMap<>();
+    private final Map<String, Object> jsonParams = new HashMap();
 
     // Whether to use gzip compression while uploading
     private final Header contentEncoding;
diff --git a/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
new file mode 100644
index 00000000..5ad3402b
--- /dev/null
+++ b/library/src/main/java/com/loopj/android/http/MyRedirectHandler.java
@@ -0,0 +1,141 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.ProtocolException;
+import org.apache.http.client.CircularRedirectException;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.utils.URIUtils;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.client.RedirectLocations;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+// taken from: https://stackoverflow.com/questions/3420767/httpclient-redirecting-to-url-with-spaces-throwing-exception
+class MyRedirectHandler extends DefaultRedirectHandler {
+
+    private static final String REDIRECT_LOCATIONS = "http.protocol.redirect-locations";
+    private final boolean enableRedirects;
+
+    public MyRedirectHandler(final boolean allowRedirects) {
+        super();
+        this.enableRedirects = allowRedirects;
+    }
+
+    public boolean isRedirectRequested(
+            final HttpResponse response,
+            final HttpContext context) {
+        if (!enableRedirects) {
+            return false;
+        }
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        int statusCode = response.getStatusLine().getStatusCode();
+        switch (statusCode) {
+            case HttpStatus.SC_MOVED_TEMPORARILY:
+            case HttpStatus.SC_MOVED_PERMANENTLY:
+            case HttpStatus.SC_SEE_OTHER:
+            case HttpStatus.SC_TEMPORARY_REDIRECT:
+                return true;
+            default:
+                return false;
+        } //end of switch
+    }
+
+    public URI getLocationURI(
+            final HttpResponse response,
+            final HttpContext context) throws ProtocolException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        //get the location header to find out where to redirect to
+        Header locationHeader = response.getFirstHeader("location");
+        if (locationHeader == null) {
+            // got a redirect response, but no location header
+            throw new ProtocolException(
+                    "Received redirect response " + response.getStatusLine()
+                            + " but no location header"
+            );
+        }
+//HERE IS THE MODIFIED LINE OF CODE
+        String location = locationHeader.getValue().replaceAll(" ", "%20");
+
+        URI uri;
+        try {
+            uri = new URI(location);
+        } catch (URISyntaxException ex) {
+            throw new ProtocolException("Invalid redirect URI: " + location, ex);
+        }
+
+        HttpParams params = response.getParams();
+        // rfc2616 demands the location value be a complete URI
+        // Location       = "Location" ":" absoluteURI
+        if (!uri.isAbsolute()) {
+            if (params.isParameterTrue(ClientPNames.REJECT_RELATIVE_REDIRECT)) {
+                throw new ProtocolException("Relative redirect location '"
+                        + uri + "' not allowed");
+            }
+            // Adjust location URI
+            HttpHost target = (HttpHost) context.getAttribute(
+                    ExecutionContext.HTTP_TARGET_HOST);
+            if (target == null) {
+                throw new IllegalStateException("Target host not available " +
+                        "in the HTTP context");
+            }
+
+            HttpRequest request = (HttpRequest) context.getAttribute(
+                    ExecutionContext.HTTP_REQUEST);
+
+            try {
+                URI requestURI = new URI(request.getRequestLine().getUri());
+                URI absoluteRequestURI = URIUtils.rewriteURI(requestURI, target, true);
+                uri = URIUtils.resolve(absoluteRequestURI, uri);
+            } catch (URISyntaxException ex) {
+                throw new ProtocolException(ex.getMessage(), ex);
+            }
+        }
+
+        if (params.isParameterFalse(ClientPNames.ALLOW_CIRCULAR_REDIRECTS)) {
+
+            RedirectLocations redirectLocations = (RedirectLocations) context.getAttribute(
+                    REDIRECT_LOCATIONS);
+
+            if (redirectLocations == null) {
+                redirectLocations = new RedirectLocations();
+                context.setAttribute(REDIRECT_LOCATIONS, redirectLocations);
+            }
+
+            URI redirectURI;
+            if (uri.getFragment() != null) {
+                try {
+                    HttpHost target = new HttpHost(
+                            uri.getHost(),
+                            uri.getPort(),
+                            uri.getScheme());
+                    redirectURI = URIUtils.rewriteURI(uri, target, true);
+                } catch (URISyntaxException ex) {
+                    throw new ProtocolException(ex.getMessage(), ex);
+                }
+            } else {
+                redirectURI = uri;
+            }
+
+            if (redirectLocations.contains(redirectURI)) {
+                throw new CircularRedirectException("Circular redirect to '" +
+                        redirectURI + "'");
+            } else {
+                redirectLocations.add(redirectURI);
+            }
+        }
+
+        return uri;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
index 813de602..2e0fdb8d 100755
--- a/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
+++ b/library/src/main/java/com/loopj/android/http/PersistentCookieStore.java
@@ -60,7 +60,7 @@
      */
     public PersistentCookieStore(Context context) {
         cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
-        cookies = new ConcurrentHashMap<>();
+        cookies = new ConcurrentHashMap();
 
         // Load any previously stored cookies into the store
         String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
@@ -146,7 +146,7 @@ public boolean clearExpired(Date date) {
 
     @Override
     public List<Cookie> getCookies() {
-        return new ArrayList<>(cookies.values());
+        return new ArrayList(cookies.values());
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestHandle.java b/library/src/main/java/com/loopj/android/http/RequestHandle.java
index cbfe02a9..a35aa634 100755
--- a/library/src/main/java/com/loopj/android/http/RequestHandle.java
+++ b/library/src/main/java/com/loopj/android/http/RequestHandle.java
@@ -9,7 +9,7 @@
     private final WeakReference<AsyncHttpRequest> request;
 
     public RequestHandle(AsyncHttpRequest request) {
-        this.request = new WeakReference<>(request);
+        this.request = new WeakReference(request);
     }
 
     /**
diff --git a/library/src/main/java/com/loopj/android/http/RequestParams.java b/library/src/main/java/com/loopj/android/http/RequestParams.java
index 860bcbc6..a6fdab8d 100755
--- a/library/src/main/java/com/loopj/android/http/RequestParams.java
+++ b/library/src/main/java/com/loopj/android/http/RequestParams.java
@@ -64,7 +64,7 @@
  * params.put("like", set); // url params: "like=music&amp;like=art"
  *
  * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // Ordered collection
- * list.add("Java");
+ * list.add("Java");<>
  * list.add("C");
  * params.put("languages", list); // url params: "languages[]=Java&amp;languages[]=C"
  *
@@ -96,10 +96,10 @@
     protected boolean isRepeatable;
     protected boolean useJsonStreamer;
     protected boolean autoCloseInputStreams;
-    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap<>();
-    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap<>();
-    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap<>();
-    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap<>();
+    protected final ConcurrentHashMap<String, String> urlParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, StreamWrapper> streamParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, FileWrapper> fileParams = new ConcurrentHashMap();
+    protected final ConcurrentHashMap<String, Object> urlParamsWithObjects = new ConcurrentHashMap();
     protected String contentEncoding = HTTP.UTF_8;
 
     /**
@@ -483,7 +483,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     protected List<BasicNameValuePair> getParamsList() {
-        List<BasicNameValuePair> lparams = new LinkedList<>();
+        List<BasicNameValuePair> lparams = new LinkedList();
 
         for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
             lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
@@ -495,7 +495,7 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
     }
 
     private List<BasicNameValuePair> getParamsList(String key, Object value) {
-        List<BasicNameValuePair> params = new LinkedList<>();
+        List<BasicNameValuePair> params = new LinkedList();
         if (value instanceof Map) {
             Map map = (Map) value;
             List list = new ArrayList<Object>(map.keySet());
@@ -512,21 +512,23 @@ private HttpEntity createMultipartEntity(ResponseHandlerInterface progressHandle
             }
         } else if (value instanceof List) {
             List list = (List) value;
-            for (Object nestedValue : list) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            int listSize = list.size();
+            for (int nestedValueIndex = 0; nestedValueIndex < listSize; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), list.get(nestedValueIndex)));
             }
         } else if (value instanceof Object[]) {
             Object[] array = (Object[]) value;
-            for (Object nestedValue : array) {
-                params.addAll(getParamsList(String.format("%s[]", key), nestedValue));
+            int arrayLength = array.length;
+            for (int nestedValueIndex = 0; nestedValueIndex < arrayLength; nestedValueIndex++) {
+                params.addAll(getParamsList(String.format("%s[%d]", key, nestedValueIndex), array[nestedValueIndex]));
             }
         } else if (value instanceof Set) {
             Set set = (Set) value;
             for (Object nestedValue : set) {
                 params.addAll(getParamsList(key, nestedValue));
             }
-        } else if (value instanceof String) {
-            params.add(new BasicNameValuePair(key, (String) value));
+        } else {
+            params.add(new BasicNameValuePair(key, value.toString()));
         }
         return params;
     }
diff --git a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
index 4641a868..fe5eacc0 100755
--- a/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
+++ b/library/src/main/java/com/loopj/android/http/ResponseHandlerInterface.java
@@ -104,7 +104,7 @@
     void setUseSynchronousMode(boolean useSynchronousMode);
 
     /**
-     * Can set, whether the handler should be asynchronous or synchronous
+     * Returns whether the handler is asynchronous or synchronous
      *
      * @return boolean if the ResponseHandler is running in synchronous mode
      */
diff --git a/library/src/main/java/com/loopj/android/http/RetryHandler.java b/library/src/main/java/com/loopj/android/http/RetryHandler.java
index 8d59c2e4..a6968667 100755
--- a/library/src/main/java/com/loopj/android/http/RetryHandler.java
+++ b/library/src/main/java/com/loopj/android/http/RetryHandler.java
@@ -40,8 +40,8 @@
 import javax.net.ssl.SSLException;
 
 class RetryHandler implements HttpRequestRetryHandler {
-    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet<>();
-    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet<>();
+    private final static HashSet<Class<?>> exceptionWhitelist = new HashSet();
+    private final static HashSet<Class<?>> exceptionBlacklist = new HashSet();
 
     static {
         // Retry if the server dropped connection on us
diff --git a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
index b9d1adff..bffdf740 100755
--- a/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/main/java/com/loopj/android/http/SimpleMultipartEntity.java
@@ -59,7 +59,7 @@
     private final byte[] boundaryEnd;
     private boolean isRepeatable;
 
-    private final List<FilePart> fileParts = new ArrayList<>();
+    private final List<FilePart> fileParts = new ArrayList();
 
     // The buffer we use for building the message excluding files and the last
     // boundary
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index dbf1a7c3..b1cac259 100755
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -23,6 +23,8 @@
         <activity android:name=".JsonSample"/>
         <activity android:name=".FileSample"/>
         <activity android:name=".BinarySample"/>
+        <activity android:name=".GzipSample"/>
+        <activity android:name=".Redirect302Sample"/>
         <activity android:name=".ThreadingTimeoutSample"/>
         <activity android:name=".CancelAllRequestsSample"/>
         <activity android:name=".CancelRequestHandleSample"/>
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
index 7cce9d41..5464cc6c 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/GetSample.java
@@ -1,5 +1,7 @@
 package com.loopj.android.http.sample;
 
+import android.widget.Toast;
+
 import com.loopj.android.http.AsyncHttpClient;
 import com.loopj.android.http.AsyncHttpResponseHandler;
 import com.loopj.android.http.RequestHandle;
@@ -61,6 +63,14 @@ public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Th
                     debugResponse(LOG_TAG, new String(errorResponse));
                 }
             }
+
+            @Override
+            public void onRetry(int retryNo) {
+                Toast.makeText(GetSample.this,
+                        String.format("Request is retried, retry no. %d", retryNo),
+                        Toast.LENGTH_SHORT)
+                        .show();
+            }
         };
     }
 }
diff --git a/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
new file mode 100644
index 00000000..ba242939
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/GzipSample.java
@@ -0,0 +1,14 @@
+package com.loopj.android.http.sample;
+
+public class GzipSample extends JsonSample {
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_gzip_sample;
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/gzip";
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
new file mode 100644
index 00000000..1a10a1a3
--- /dev/null
+++ b/sample/src/main/java/com/loopj/android/http/sample/Redirect302Sample.java
@@ -0,0 +1,79 @@
+package com.loopj.android.http.sample;
+
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.loopj.android.http.AsyncHttpClient;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class Redirect302Sample extends GetSample {
+
+    private boolean enableRedirects = true;
+    private boolean enableRelativeRedirects = true;
+    private boolean enableCircularRedirects = true;
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, 0, Menu.NONE, "Enable redirects").setCheckable(true);
+        menu.add(Menu.NONE, 1, Menu.NONE, "Enable relative redirects").setCheckable(true);
+        menu.add(Menu.NONE, 2, Menu.NONE, "Enable circular redirects").setCheckable(true);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem menuItemEnableRedirects = menu.findItem(0);
+        if (menuItemEnableRedirects != null)
+            menuItemEnableRedirects.setChecked(enableRedirects);
+        MenuItem menuItemEnableRelativeRedirects = menu.findItem(1);
+        if (menuItemEnableRelativeRedirects != null)
+            menuItemEnableRelativeRedirects.setChecked(enableRelativeRedirects);
+        MenuItem menuItemEnableCircularRedirects = menu.findItem(2);
+        if (menuItemEnableCircularRedirects != null)
+            menuItemEnableCircularRedirects.setChecked(enableCircularRedirects);
+        return super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.isCheckable()) {
+            item.setChecked(!item.isChecked());
+            if (item.getItemId() == 0) {
+                enableRedirects = item.isChecked();
+            } else if (item.getItemId() == 1) {
+                enableRelativeRedirects = item.isChecked();
+            } else if (item.getItemId() == 2) {
+                enableCircularRedirects = item.isChecked();
+            }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public String getDefaultURL() {
+        return "http://httpbin.org/redirect/6";
+    }
+
+    @Override
+    public int getSampleTitle() {
+        return R.string.title_redirect_302;
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient() {
+        AsyncHttpClient ahc = super.getAsyncHttpClient();
+        HttpClient client = ahc.getHttpClient();
+        if (client instanceof DefaultHttpClient) {
+            Toast.makeText(this,
+                    String.format("redirects: %b\nrelative redirects: %b\ncircular redirects: %b",
+                            enableRedirects, enableRelativeRedirects, enableCircularRedirects),
+                    Toast.LENGTH_SHORT
+            ).show();
+            ahc.setEnableRedirects(enableRedirects, enableRelativeRedirects, enableCircularRedirects);
+        }
+        return ahc;
+    }
+}
diff --git a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
index 9522b14c..dad700c2 100755
--- a/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/WaypointsActivity.java
@@ -9,7 +9,36 @@
 
 public class WaypointsActivity extends ListActivity {
 
-    private static final String[] samples = new String[]{"GET", "POST", "DELETE", "PUT", "JSON", "FILE", "BINARY", "THREADING TIMEOUTS", "CANCEL ALL REQUESTS", "CANCEL REQUEST HANDLE", "SYNCHRONOUS CLIENT"};
+    private static final String[] samples = new String[]{
+            "GET",
+            "POST",
+            "DELETE",
+            "PUT",
+            "JSON",
+            "FILE",
+            "BINARY",
+            "GZIP",
+            "302 REDIRECT",
+            "THREADING TIMEOUTS",
+            "CANCEL ALL REQUESTS",
+            "CANCEL REQUEST HANDLE",
+            "SYNCHRONOUS CLIENT"
+    };
+    private static final Class[] targets = {
+            GetSample.class,
+            PostSample.class,
+            DeleteSample.class,
+            PutSample.class,
+            JsonSample.class,
+            FileSample.class,
+            BinarySample.class,
+            GzipSample.class,
+            Redirect302Sample.class,
+            ThreadingTimeoutSample.class,
+            CancelAllRequestsSample.class,
+            CancelRequestHandleSample.class,
+            SynchronousClientSample.class
+    };
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -19,44 +48,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        Class<?> targetClass;
-        switch (position) {
-            case 0:
-            default:
-                targetClass = GetSample.class;
-                break;
-            case 1:
-                targetClass = PostSample.class;
-                break;
-            case 2:
-                targetClass = DeleteSample.class;
-                break;
-            case 3:
-                targetClass = PutSample.class;
-                break;
-            case 4:
-                targetClass = JsonSample.class;
-                break;
-            case 5:
-                targetClass = FileSample.class;
-                break;
-            case 6:
-                targetClass = BinarySample.class;
-                break;
-            case 7:
-                targetClass = ThreadingTimeoutSample.class;
-                break;
-            case 8:
-                targetClass = CancelAllRequestsSample.class;
-                break;
-            case 9:
-                targetClass = CancelRequestHandleSample.class;
-                break;
-            case 10:
-                targetClass = SynchronousClientSample.class;
-                break;
-        }
-        if (targetClass != null)
-            startActivity(new Intent(this, targetClass));
+        if (position >= 0 && position < targets.length)
+            startActivity(new Intent(this, targets[position]));
     }
 }
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index 8147ecf3..3507db19 100755
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -3,7 +3,7 @@
 
     <string name="app_name">Android Async Http Samples</string>
     <string name="title_get_sample">GET</string>
-    <string name="title_json_sample">GET and JSON parse</string>
+    <string name="title_json_sample">GET JSON and parse it</string>
     <string name="title_post_sample">POST</string>
     <string name="title_put_sample">PUT</string>
     <string name="title_delete_sample">DELETE</string>
@@ -13,8 +13,10 @@
     <string name="title_cancel_handle">Cancel request handle</string>
     <string name="title_synchronous">Synchronous GET request</string>
     <string name="title_threading_timeout">Threading timeouts</string>
+    <string name="title_gzip_sample">GET Gzipped JSON and parse it</string>
     <string name="button_run">Run</string>
     <string name="label_headers">Headers (key=val, one per line)</string>
     <string name="label_req_body">Request body</string>
     <string name="button_cancel">Cancel</string>
+    <string name="title_redirect_302">302 Redirect handling</string>
 </resources>
