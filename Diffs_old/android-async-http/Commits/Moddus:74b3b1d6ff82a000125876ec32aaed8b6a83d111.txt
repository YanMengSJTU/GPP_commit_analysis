diff --git a/README.md b/README.md
index a576fb38..bcb46116 100644
--- a/README.md
+++ b/README.md
@@ -39,7 +39,7 @@ http://central.maven.org/maven2/com/loopj/android/android-async-http/
 ```
 Maven URL: http://repo1.maven.org/maven2/
 GroupId: com.loopj.android
-ArtifactId: async-http-client
+ArtifactId: android-async-http
 Version: 1.4.3
 Packaging: JAR or AAR
 ```
diff --git a/library/src/com/loopj/android/http/AsyncHttpClient.java b/library/src/com/loopj/android/http/AsyncHttpClient.java
index ee695bdd..42bf4663 100644
--- a/library/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/library/src/com/loopj/android/http/AsyncHttpClient.java
@@ -97,8 +97,6 @@
  * </pre>
  */
 public class AsyncHttpClient {
-    // This property won't be available soon, don't use it
-    @Deprecated
     private static final String VERSION = "1.4.4";
 
     private static final int DEFAULT_MAX_CONNECTIONS = 10;
@@ -110,8 +108,8 @@
     private static final String ENCODING_GZIP = "gzip";
     private static final String LOG_TAG = "AsyncHttpClient";
 
-    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
-    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+    private int maxConnections = DEFAULT_MAX_CONNECTIONS;
+    private int timeout = DEFAULT_SOCKET_TIMEOUT;
 
     private final DefaultHttpClient httpClient;
     private final HttpContext httpContext;
@@ -120,7 +118,6 @@
     private final Map<String, String> clientHeaderMap;
     private boolean isUrlEncodingEnabled = true;
 
-
     /**
      * Creates a new AsyncHttpClient with default constructor arguments values
      */
@@ -204,12 +201,12 @@ public AsyncHttpClient(SchemeRegistry schemeRegistry) {
 
         BasicHttpParams httpParams = new BasicHttpParams();
 
-        ConnManagerParams.setTimeout(httpParams, socketTimeout);
+        ConnManagerParams.setTimeout(httpParams, timeout);
         ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
         ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
 
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setSoTimeout(httpParams, timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
         HttpConnectionParams.setTcpNoDelay(httpParams, true);
         HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
 
@@ -324,16 +321,51 @@ public void setUserAgent(String userAgent) {
         HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
     }
 
+
+    /**
+     * Returns current limit of parallel connections
+     *
+     * @return maximum limit of parallel connections, default is 10
+     */
+    public int getMaxConnections() {
+        return maxConnections;
+    }
+
+    /**
+     * Sets maximum limit of parallel connections
+     *
+     * @param maxConnections maximum parallel connections, must be at least 1
+     */
+    public void setMaxConnections(int maxConnections) {
+        if (maxConnections < 1)
+            maxConnections = DEFAULT_MAX_CONNECTIONS;
+        this.maxConnections = maxConnections;
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(this.maxConnections));
+    }
+
+    /**
+     * Returns current socket timeout limit (milliseconds), default is 10000 (10sec)
+     *
+     * @return Socket Timeout limit in milliseconds
+     */
+    public int getTimeout() {
+        return timeout;
+    }
+
     /**
-     * Set the connection timeout. By default, 10 seconds.
+     * Set the connection and socket timeout. By default, 10 seconds.
      *
-     * @param timeout the connect/socket timeout in milliseconds
+     * @param timeout the connect/socket timeout in milliseconds, at least 1 second
      */
     public void setTimeout(int timeout) {
+        if (timeout < 1000)
+            timeout = DEFAULT_SOCKET_TIMEOUT;
+        this.timeout = timeout;
         final HttpParams httpParams = this.httpClient.getParams();
-        ConnManagerParams.setTimeout(httpParams, timeout);
-        HttpConnectionParams.setSoTimeout(httpParams, timeout);
-        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+        ConnManagerParams.setTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, this.timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, this.timeout);
     }
 
     /**
@@ -918,7 +950,7 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
             }
         } catch (Throwable t) {
             if (responseHandler != null)
-                responseHandler.sendFailureMessage(0, null, t, (String) null);
+                responseHandler.sendFailureMessage(0, null, (byte[]) null, t);
             else
                 t.printStackTrace();
         }
@@ -926,7 +958,7 @@ private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler
         return entity;
     }
 
-    public boolean isUrlEncodingEnabled(){
+    public boolean isUrlEncodingEnabled() {
         return isUrlEncodingEnabled;
     }
 
diff --git a/library/src/com/loopj/android/http/AsyncHttpRequest.java b/library/src/com/loopj/android/http/AsyncHttpRequest.java
index 339c6c0f..1f7c8a3a 100644
--- a/library/src/com/loopj/android/http/AsyncHttpRequest.java
+++ b/library/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -19,18 +19,13 @@
 package com.loopj.android.http;
 
 import org.apache.http.HttpResponse;
-import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.HttpRequestRetryHandler;
 import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.http.protocol.HttpContext;
 
 import java.io.IOException;
-import java.net.ConnectException;
 import java.net.MalformedURLException;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 
 class AsyncHttpRequest implements Runnable {
@@ -38,7 +33,6 @@
     private final HttpContext context;
     private final HttpUriRequest request;
     private final AsyncHttpResponseHandler responseHandler;
-    private boolean isBinaryRequest;
     private int executionCount;
 
     public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, AsyncHttpResponseHandler responseHandler) {
@@ -46,110 +40,81 @@ public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriR
         this.context = context;
         this.request = request;
         this.responseHandler = responseHandler;
-        if (responseHandler instanceof BinaryHttpResponseHandler) {
-            this.isBinaryRequest = true;
-        }
     }
 
     @Override
     public void run() {
-        try {
-            if (responseHandler != null) {
-                responseHandler.sendStartMessage();
-            }
+        if (responseHandler != null) {
+            responseHandler.sendStartMessage();
+        }
 
+        try {
             makeRequestWithRetries();
-
-            if (responseHandler != null) {
-                responseHandler.sendFinishMessage();
-            }
         } catch (IOException e) {
             if (responseHandler != null) {
-                responseHandler.sendFinishMessage();
-                if (this.isBinaryRequest) {
-                    responseHandler.sendFailureMessage(e, (byte[]) null);
-                } else {
-                    responseHandler.sendFailureMessage(e, (String) null);
-                }
+                responseHandler.sendFailureMessage(0, null, null, e);
             }
         }
+        
+        if (responseHandler != null) {
+            responseHandler.sendFinishMessage();
+        }
     }
 
-    private void makeRequest() throws IOException, InterruptedException {
+    private void makeRequest() throws IOException {
         if (!Thread.currentThread().isInterrupted()) {
-            try {
-                // Fixes #115
-                if (request.getURI().getScheme() == null)
-                    throw new MalformedURLException("No valid URI scheme was provided");
-                HttpResponse response = client.execute(request, context);
-                if (!Thread.currentThread().isInterrupted()) {
-                    if (responseHandler != null) {
-                        responseHandler.sendResponseMessage(response);
-                    }
-                } else {
-                    throw new InterruptedException("makeRequest was interrupted");
-                }
-            } catch (IOException e) {
-                if (!Thread.currentThread().isInterrupted()) {
-                    throw e;
+            // Fixes #115
+            if (request.getURI().getScheme() == null) {
+                // subclass of IOException so processed in the caller
+                throw new MalformedURLException("No valid URI scheme was provided");
+            }
+
+            HttpResponse response = client.execute(request, context);
+
+            if (!Thread.currentThread().isInterrupted()) {
+                if (responseHandler != null) {
+                    responseHandler.sendResponseMessage(response);
                 }
             }
         }
     }
 
-    private void makeRequestWithRetries() throws ConnectException {
-        // This is an additional layer of retry logic lifted from droid-fu
-        // See: https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+    private void makeRequestWithRetries() throws IOException {
         boolean retry = true;
         IOException cause = null;
         HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
-        while (retry) {
-            try {
-                makeRequest();
-                return;
-            } catch (ClientProtocolException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "cannot repeat the request");
-                }
-                return;
-            } catch (UnknownHostException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
+        try
+        {
+            while (retry) {
+                try {
+                    makeRequest();
+                    return;
+                } catch (UnknownHostException e) {
+                    // switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException
+                    // while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry
+                    // (to assist in genuine cases of unknown host) which seems better than outright failure
+                    cause = new IOException("UnknownHostException exception: " + e.getMessage());
+                    retry = (executionCount > 0) && retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (NullPointerException e) {
+                    // there's a bug in HttpClient 4.0.x that on some occasions causes
+                    // DefaultRequestExecutor to throw an NPE, see
+                    // http://code.google.com/p/android/issues/detail?id=5255
+                    cause = new IOException("NPE in HttpClient: " + e.getMessage());
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
+                } catch (IOException e) {
+                    cause = e;
+                    retry = retryHandler.retryRequest(cause, ++executionCount, context);
                 }
-                return;
-            } catch (ConnectTimeoutException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "connection timed out");
-                }
-            } catch (SocketException e) {
-                // Added to detect host unreachable
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "can't resolve host");
+                if(retry && (responseHandler != null)) {
+                    responseHandler.sendRetryMessage();
                 }
-                return;
-            } catch (SocketTimeoutException e) {
-                if (responseHandler != null) {
-                    responseHandler.sendFailureMessage(e, "socket time out");
-                }
-                return;
-            } catch (IOException e) {
-                cause = e;
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (NullPointerException e) {
-                // there's a bug in HttpClient 4.0.x that on some occasions causes
-                // DefaultRequestExecutor to throw an NPE, see
-                // http://code.google.com/p/android/issues/detail?id=5255
-                cause = new IOException("NPE in HttpClient" + e.getMessage());
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
-            } catch (InterruptedException e) {
-                cause = new IOException("Request was interrupted while executing");
-                retry = retryHandler.retryRequest(cause, ++executionCount, context);
             }
+        } catch (Exception e) {
+            // catch anything else to ensure failure message is propagated
+            cause = new IOException("Unhandled exception: " + e.getMessage());
         }
-
-        // no retries left, crap out with exception
-        ConnectException ex = new ConnectException();
-        ex.initCause(cause);
-        throw ex;
+        
+        // cleaned up to throw IOException
+        throw(cause);
     }
 }
diff --git a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 5525391a..276c797e 100644
--- a/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,24 +21,27 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.util.Log;
 
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
+import org.apache.http.util.ByteArrayBuffer;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.lang.ref.WeakReference;
 
 /**
  * Used to intercept and handle the responses from requests made using
- * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
+ * {@link AsyncHttpClient}. The {@link #onSuccess(int, org.apache.http.Header[], byte[])} method is
  * designed to be anonymously overridden with your own response handling code.
  * <p>&nbsp;</p>
- * Additionally, you can override the {@link #onFailure(Throwable, String)},
- * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * Additionally, you can override the {@link #onFailure(int, org.apache.http.Header[], byte[], Throwable)},
+ * {@link #onStart()}, {@link #onFinish()}, {@link #onRetry()} and {@link #onProgress(int, int)} methods as required.
  * <p>&nbsp;</p>
  * For example:
  * <p>&nbsp;</p>
@@ -51,16 +54,26 @@
  *     }
  *
  *     &#064;Override
- *     public void onSuccess(String response) {
+ *     public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
  *         // Successfully got a response
  *     }
  *
  *     &#064;Override
- *     public void onFailure(Throwable e, String response) {
+ *     public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
  *         // Response failed :(
  *     }
  *
  *     &#064;Override
+ *     public void onRetry() {
+ *         // Request was retried
+ *     }
+ *
+ *     &#064;Override
+ *     public void onProgress(int bytesWritten, int totalSize) {
+ *         // Progress notification
+ *     }
+ *
+ *     &#064;Override
  *     public void onFinish() {
  *         // Completed the request (either success or failure)
  *     }
@@ -68,14 +81,52 @@
  * </pre>
  */
 public class AsyncHttpResponseHandler {
+    private static final String LOG_TAG = "AsyncHttpResponseHandler";
+
     protected static final int SUCCESS_MESSAGE = 0;
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
     protected static final int PROGRESS_MESSAGE = 4;
+    protected static final int RETRY_MESSAGE = 5;
+
+    protected static final int BUFFER_SIZE = 4096;
 
     private Handler handler;
-    private String responseCharset = "UTF-8";
+    public static final String DEFAULT_CHARSET = "UTF-8";
+    private String responseCharset = DEFAULT_CHARSET;
+    private Boolean useSynchronousMode = false;
+
+    // avoid leaks by using a non-anonymous handler class
+    // with a weak reference
+    static class ResponderHandler extends Handler {
+        private final WeakReference<AsyncHttpResponseHandler> mResponder;
+
+        ResponderHandler(AsyncHttpResponseHandler service) {
+            mResponder = new WeakReference<AsyncHttpResponseHandler>(service);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncHttpResponseHandler service = mResponder.get();
+            if (service != null) {
+                service.handleMessage(msg);
+            }
+        }
+    }
+
+    public boolean getUseSynchronousMode() {
+        return (useSynchronousMode);
+    }
+
+    /**
+     * Set the response handler to use synchronous mode or not
+     *
+     * @param value true indicates that synchronous mode should be used
+     */
+    public void setUseSynchronousMode(Boolean value) {
+        useSynchronousMode = value;
+    }
 
     /**
      * Sets the charset for the response string. If not set, the default is UTF-8.
@@ -97,12 +148,7 @@ public String getCharset() {
     public AsyncHttpResponseHandler() {
         // Set up a handler to post events back to the correct thread if possible
         if (Looper.myLooper() != null) {
-            handler = new Handler() {
-                @Override
-                public void handleMessage(Message msg) {
-                    AsyncHttpResponseHandler.this.handleMessage(msg);
-                }
-            };
+            handler = new ResponderHandler(this);
         }
     }
 
@@ -136,7 +182,9 @@ public void onFinish() {
      * Fired when a request returns successfully, override to handle in your own code
      *
      * @param content the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
+    @Deprecated
     public void onSuccess(String content) {
     }
 
@@ -146,6 +194,7 @@ public void onSuccess(String content) {
      * @param statusCode the status code of the response
      * @param headers    the headers of the HTTP response
      * @param content    the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
     public void onSuccess(int statusCode, Header[] headers, String content) {
         onSuccess(statusCode, content);
@@ -156,11 +205,30 @@ public void onSuccess(int statusCode, Header[] headers, String content) {
      *
      * @param statusCode the status code of the response
      * @param content    the body of the HTTP response from the server
+     * @deprecated use {@link #onSuccess(int, Header[], byte[])}
      */
+    @Deprecated
     public void onSuccess(int statusCode, String content) {
         onSuccess(content);
     }
 
+    /**
+     * Fired when a request returns successfully, override to handle in your own code
+     *
+     * @param statusCode   the status code of the response
+     * @param headers      return headers, if any
+     * @param responseBody the body of the HTTP response from the server
+     */
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        try {
+            String response = new String(responseBody, getCharset());
+            onSuccess(statusCode, headers, response);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, e.toString());
+            onFailure(statusCode, headers, e, (String) null);
+        }
+    }
+
     /**
      * Fired when a request fails to complete, override to handle in your own code
      *
@@ -176,7 +244,9 @@ public void onFailure(Throwable error) {
      *
      * @param error   the underlying cause of the failure
      * @param content the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(Throwable error, String content) {
         // By default, call the deprecated onFailure(Throwable) for compatibility
         onFailure(error);
@@ -188,7 +258,9 @@ public void onFailure(Throwable error, String content) {
      * @param statusCode return HTTP status code
      * @param error      the underlying cause of the failure
      * @param content    the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(int statusCode, Throwable error, String content) {
         // By default, call the chain method onFailure(Throwable,String)
         onFailure(error, content);
@@ -201,12 +273,39 @@ public void onFailure(int statusCode, Throwable error, String content) {
      * @param headers    return headers, if any
      * @param error      the underlying cause of the failure
      * @param content    the response body, if any
+     * @deprecated use {@link #onFailure(int, Header[], byte[], Throwable)}
      */
+    @Deprecated
     public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
         // By default, call the chain method onFailure(int,Throwable,String)
         onFailure(statusCode, error, content);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode   return HTTP status code
+     * @param headers      return headers, if any
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        String response = null;
+        try {
+            response = new String(responseBody, getCharset());
+            onFailure(statusCode, headers, error, response);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, e.toString());
+            onFailure(statusCode, headers, e, null);
+        }
+    }
+
+    /**
+     * Fired when a retry occurs, override to handle in your own code
+     */
+    public void onRetry() {
+    }
+
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
@@ -216,26 +315,12 @@ protected void sendProgressMessage(int bytesWritten, int totalSize) {
         sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{bytesWritten, totalSize}));
     }
 
-    protected void sendSuccessMessage(int statusCode, Header[] headers, String responseBody) {
+    protected void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody) {
         sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, headers, responseBody}));
     }
 
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
-    }
-
-    @Deprecated
-    protected void sendFailureMessage(Throwable e, String responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
-    }
-
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
-    }
-
-    @Deprecated
-    protected void sendFailureMessage(Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{0, null, e, responseBody}));
+    protected void sendFailureMessage(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, error}));
     }
 
     protected void sendStartMessage() {
@@ -246,20 +331,10 @@ protected void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    protected void handleSuccessMessage(int statusCode, Header[] headers, String responseBody) {
-        onSuccess(statusCode, headers, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, String responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
+    protected void sendRetryMessage() {
+        sendMessage(obtainMessage(RETRY_MESSAGE, null));
     }
 
-
     // Methods which emulate android's Handler and Message methods
     protected void handleMessage(Message msg) {
         Object[] response;
@@ -267,11 +342,17 @@ protected void handleMessage(Message msg) {
         switch (msg.what) {
             case SUCCESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (Header[]) response[1], (String) response[2]);
+                if (response != null && response.length >= 3)
+                    onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
+                else
+                    Log.e(LOG_TAG, "SUCCESS_MESSAGE didn't got enough params");
                 break;
             case FAILURE_MESSAGE:
                 response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (String) response[3]);
+                if (response != null && response.length >= 4)
+                    onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]);
+                else
+                    Log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params");
                 break;
             case START_MESSAGE:
                 onStart();
@@ -281,16 +362,22 @@ protected void handleMessage(Message msg) {
                 break;
             case PROGRESS_MESSAGE:
                 response = (Object[]) msg.obj;
-                onProgress((Integer) response[0], (Integer) response[1]);
+                if (response != null && response.length >= 2)
+                    onProgress((Integer) response[0], (Integer) response[1]);
+                else
+                    Log.e(LOG_TAG, "PROGRESS_MESSAGE didn't got enough params");
+                break;
+            case RETRY_MESSAGE:
+                onRetry();
                 break;
         }
     }
 
     protected void sendMessage(Message msg) {
-        if (handler != null) {
-            handler.sendMessage(msg);
-        } else {
+        if (getUseSynchronousMode() || handler == null) {
             handleMessage(msg);
+        } else if (!Thread.currentThread().isInterrupted()) { // do not send messages if request has been cancelled
+            handler.sendMessage(msg);
         }
     }
 
@@ -315,35 +402,56 @@ protected Message obtainMessage(int responseMessage, Object response) {
     }
 
     // Interface to AsyncHttpRequest
-    protected void sendResponseMessage(HttpResponse response) {
-        if (response == null) {
-            sendFailureMessage(0, null, new IllegalStateException("No response"), (String) null);
-            return;
-        }
-        StatusLine status = response.getStatusLine();
-        String responseBody = null;
-        try {
-            HttpEntity entity;
-            HttpEntity temp = response.getEntity();
-            if (temp != null) {
-                entity = new BufferedHttpEntity(temp);
-                responseBody = EntityUtils.toString(entity, getCharset());
-            }
-        } catch (IOException e) {
-            try {
-                if (response.getEntity() != null)
-                    response.getEntity().consumeContent();
-            } catch (Throwable t) {
-                t.printStackTrace();
+    void sendResponseMessage(HttpResponse response) throws IOException {
+        // do not process if request has been cancelled
+        if (!Thread.currentThread().isInterrupted()) {
+            StatusLine status = response.getStatusLine();
+            byte[] responseBody;
+            responseBody = getResponseData(response.getEntity());
+            // additional cancellation check as getResponseData() can take non-zero time to process
+            if (!Thread.currentThread().isInterrupted()) {
+                if (status.getStatusCode() >= 300) {
+                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));
+                } else {
+                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+                }
             }
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (String) null);
-            return;
         }
+    }
 
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+        byte[] responseBody = null;
+        if (entity != null) {
+            InputStream instream = entity.getContent();
+            if (instream != null) {
+                long contentLength = entity.getContentLength();
+                if (contentLength > Integer.MAX_VALUE) {
+                    throw new IllegalArgumentException("HTTP entity too large to be buffered in memory");
+                }
+                if (contentLength < 0) {
+                    contentLength = BUFFER_SIZE;
+                }
+                try {
+                    ByteArrayBuffer buffer = new ByteArrayBuffer((int) contentLength);
+                    try {
+                        byte[] tmp = new byte[BUFFER_SIZE];
+                        int l, count = 0;
+                        // do not send messages if request has been cancelled
+                        while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                            count += l;
+                            buffer.append(tmp, 0, l);
+                            sendProgressMessage(count, (int) contentLength);
+                        }
+                    } finally {
+                        instream.close();
+                    }
+                    responseBody = buffer.buffer();
+                } catch (OutOfMemoryError e) {
+                    System.gc();
+                    throw new IOException("File too large to fit into available memory");
+                }
+            }
         }
+        return responseBody;
     }
 }
diff --git a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
index aed1faa1..bc80d658 100644
--- a/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/BinaryHttpResponseHandler.java
@@ -20,12 +20,9 @@
 
 import android.os.Message;
 import org.apache.http.Header;
-import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpResponseException;
-import org.apache.http.entity.BufferedHttpEntity;
-import org.apache.http.util.EntityUtils;
 
 import java.io.IOException;
 import java.util.regex.Pattern;
@@ -103,74 +100,44 @@ public void onSuccess(int statusCode, byte[] binaryData) {
     }
 
     /**
-     * Fired when a request fails to complete, override to handle in your own code
+     * Fired when a request returns successfully, override to handle in your own code
      *
-     * @param statusCode response HTTP statuse code
-     * @param headers    response headers, if any
-     * @param error      the underlying cause of the failure
-     * @param binaryData the response body, if any
-     * @deprecated
+     * @param statusCode    response HTTP statuse code
+     * @param headers       response headers, if any
+     * @param responseData  the response body, if any
      */
-    @Deprecated
-    public void onFailure(int statusCode, Header[] headers, Throwable error, byte[] binaryData) {
-        // By default, call the deprecated onFailure(Throwable) for compatibility
-        onFailure(statusCode, error, null);
-    }
-
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
 
-    protected void sendSuccessMessage(int statusCode, byte[] responseBody) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, responseBody}));
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseData) {
+        onSuccess(statusCode, responseData);
     }
 
+    /**
+     * Fired when a request fails to complete, override to handle in your own code
+     *
+     * @param statusCode    response HTTP statuse code
+     * @param headers       response headers, if any
+     * @param responseData  the response body, if any
+     * @param error         the underlying cause of the failure
+     */
+
     @Override
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, responseBody}));
+    public void onFailure(int statusCode, Header[] headers, byte[] responseData, Throwable error) {
+        onFailure(statusCode, error, null);
     }
 
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
     //
 
-    protected void handleSuccessMessage(int statusCode, byte[] responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, byte[] responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
-    }
-
-    // Methods which emulate android's Handler and Message methods
-    @Override
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch (msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (byte[]) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (byte[]) response[3]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
-    }
-
     // Interface to AsyncHttpRequest
     @Override
-    protected void sendResponseMessage(HttpResponse response) {
+    protected void sendResponseMessage(HttpResponse response) throws IOException {
         StatusLine status = response.getStatusLine();
         Header[] contentTypeHeaders = response.getHeaders("Content-Type");
-        byte[] responseBody = null;
         if (contentTypeHeaders.length != 1) {
             //malformed/ambiguous HTTP Header, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "None, or more than one, Content-Type Header found!"));
             return;
         }
         Header contentTypeHeader = contentTypeHeaders[0];
@@ -182,24 +149,9 @@ protected void sendResponseMessage(HttpResponse response) {
         }
         if (!foundAllowedContentType) {
             //Content-Type not in allowed list, ABORT!
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"), (String) null);
+            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), null, new HttpResponseException(status.getStatusCode(), "Content-Type not allowed!"));
             return;
         }
-        try {
-            HttpEntity entity = null;
-            HttpEntity temp = response.getEntity();
-            if (temp != null) {
-                entity = new BufferedHttpEntity(temp);
-            }
-            responseBody = EntityUtils.toByteArray(entity);
-        } catch (IOException e) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, (byte[]) null);
-        }
-
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), responseBody);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), responseBody);
-        }
+        super.sendResponseMessage( response );
     }
 }
diff --git a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
index 7bb674fc..76049ccd 100644
--- a/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/FileAsyncHttpResponseHandler.java
@@ -1,11 +1,7 @@
 package com.loopj.android.http;
 
-import android.os.Message;
-
 import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpResponseException;
+import org.apache.http.HttpEntity;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -44,66 +40,40 @@ public void onFailure(int statusCode, Header[] headers, Throwable e, File respon
         onFailure(statusCode, e, response);
     }
 
-
-    protected void sendSuccessMessage(int statusCode, File file) {
-        sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[]{statusCode, file}));
-    }
-
-    protected void sendFailureMessage(int statusCode, Header[] headers, Throwable e, File file) {
-        sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, e, file}));
-    }
-
-    protected void handleSuccessMessage(int statusCode, File responseBody) {
-        onSuccess(statusCode, responseBody);
-    }
-
-    protected void handleFailureMessage(int statusCode, Header[] headers, Throwable e, File responseBody) {
-        onFailure(statusCode, headers, e, responseBody);
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        onFailure(statusCode, headers, error, mFile);
     }
 
-    // Methods which emulate android's Handler and Message methods
-    protected void handleMessage(Message msg) {
-        Object[] response;
-        switch (msg.what) {
-            case SUCCESS_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleSuccessMessage((Integer) response[0], (File) response[1]);
-                break;
-            case FAILURE_MESSAGE:
-                response = (Object[]) msg.obj;
-                handleFailureMessage((Integer) response[0], (Header[]) response[1], (Throwable) response[2], (File) response[3]);
-                break;
-            default:
-                super.handleMessage(msg);
-                break;
-        }
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        onSuccess(statusCode, mFile);
     }
 
     @Override
-    protected void sendResponseMessage(HttpResponse response) {
-        StatusLine status = response.getStatusLine();
-
-        try {
-            FileOutputStream buffer = new FileOutputStream(this.mFile);
-            InputStream is = response.getEntity().getContent();
-
-            int nRead;
-            byte[] data = new byte[16384];
-
-            while ((nRead = is.read(data, 0, data.length)) != -1)
-                buffer.write(data, 0, nRead);
-
-            buffer.flush();
-            buffer.close();
-
-        } catch (IOException e) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), e, this.mFile);
-        }
-
-        if (status.getStatusCode() >= 300) {
-            sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()), this.mFile);
-        } else {
-            sendSuccessMessage(status.getStatusCode(), this.mFile);
-        }
-    }
-}
\ No newline at end of file
+    byte[] getResponseData(HttpEntity entity) throws IOException {
+      if (entity != null) {
+          InputStream instream = entity.getContent();
+          long contentLength = entity.getContentLength();
+          FileOutputStream buffer = new FileOutputStream(this.mFile);
+          if (instream != null) {
+              try {
+                  byte[] tmp = new byte[BUFFER_SIZE];
+                  int l, count = 0;
+                  // do not send messages if request has been cancelled
+                  while ((l = instream.read(tmp)) != -1 && !Thread.currentThread().isInterrupted()) {
+                      count += l;
+                      buffer.write(tmp, 0, l);
+                      sendProgressMessage(count, (int) contentLength);
+                  }
+              } finally {
+                  instream.close();
+                  buffer.flush();
+                  buffer.close();
+              }
+          }
+      }
+      return null;
+  }
+  
+}
diff --git a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
index 8eccbf85..f6191607 100644
--- a/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
+++ b/library/src/com/loopj/android/http/JsonHttpResponseHandler.java
@@ -19,6 +19,7 @@
 package com.loopj.android.http;
 
 import android.os.Message;
+import android.util.Log;
 import org.apache.http.Header;
 import org.apache.http.HttpStatus;
 import org.json.JSONArray;
@@ -26,6 +27,8 @@
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
+import java.io.UnsupportedEncodingException;
+
 /**
  * Used to intercept and handle the responses from requests made using
  * {@link AsyncHttpClient}, with automatic parsing into a {@link JSONObject}
@@ -39,8 +42,7 @@
  * parent class.
  */
 public class JsonHttpResponseHandler extends AsyncHttpResponseHandler {
-    protected static final int SUCCESS_JSON_MESSAGE = 100;
-
+    private static final String LOG_TAG = "JsonHttpResponseHandler";
     //
     // Callbacks to be overridden, typically anonymously
     //
@@ -140,13 +142,8 @@ public void onFailure(int statusCode, Header[] headers, Throwable e, JSONArray e
         onFailure(statusCode, e, errorResponse);
     }
 
-
-    //
-    // Pre-processing of messages (executes in background threadpool thread)
-    //
-
     @Override
-    protected void sendSuccessMessage(final int statusCode, final Header[] headers, final String responseBody) {
+    public void onSuccess(final int statusCode, final Header[] headers, final byte[] responseBody) {
         if (statusCode != HttpStatus.SC_NO_CONTENT) {
             new Thread(new Runnable() {
                 @Override
@@ -156,70 +153,35 @@ public void run() {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, jsonResponse}));
+                                if (jsonResponse instanceof JSONObject) {
+                                    onSuccess(statusCode, headers, (JSONObject) jsonResponse);
+                                } else if (jsonResponse instanceof JSONArray) {
+                                    onSuccess(statusCode, headers, (JSONArray) jsonResponse);
+                                } else if (jsonResponse instanceof String) {
+                                    onSuccess(statusCode, headers, (String) jsonResponse);
+                                } else {
+                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+                                }
+
                             }
                         });
-                    } catch (final JSONException e) {
+                    } catch (final JSONException ex) {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                sendFailureMessage(statusCode, headers, e, responseBody);
+                                onFailure(ex, (JSONObject) null);
                             }
                         });
                     }
                 }
             }).start();
         } else {
-            sendMessage(obtainMessage(SUCCESS_JSON_MESSAGE, new Object[]{statusCode, headers, new JSONObject()}));
-        }
-    }
-
-
-    //
-    // Pre-processing of messages (in original calling thread, typically the UI thread)
-    //
-
-    @Override
-    protected void handleMessage(Message msg) {
-        switch (msg.what) {
-            case SUCCESS_JSON_MESSAGE:
-                Object[] response = (Object[]) msg.obj;
-                handleSuccessJsonMessage((Integer) response[0], (Header[]) response[1], response[2]);
-                break;
-            default:
-                super.handleMessage(msg);
-        }
-    }
-
-    protected void handleSuccessJsonMessage(int statusCode, Header[] headers, Object jsonResponse) {
-        if (jsonResponse instanceof JSONObject) {
-            onSuccess(statusCode, headers, (JSONObject) jsonResponse);
-        } else if (jsonResponse instanceof JSONArray) {
-            onSuccess(statusCode, headers, (JSONArray) jsonResponse);
-        } else if (jsonResponse instanceof String) {
-            onSuccess(statusCode, headers, (String) jsonResponse);
-        } else {
-            onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
+            onSuccess(statusCode, headers, new JSONObject());
         }
     }
 
-    protected Object parseResponse(String responseBody) throws JSONException {
-        if (null == responseBody)
-            return null;
-        Object result = null;
-        //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
-        responseBody = responseBody.trim();
-        if (responseBody.startsWith("{") || responseBody.startsWith("[")) {
-            result = new JSONTokener(responseBody).nextValue();
-        }
-        if (result == null) {
-            result = responseBody;
-        }
-        return result;
-    }
-
     @Override
-    protected void handleFailureMessage(final int statusCode, final Header[] headers, final Throwable e, final String responseBody) {
+    public void onFailure(final int statusCode, final Header[] headers, final byte[] responseBody, final Throwable e) {
         if (responseBody != null) {
             new Thread(new Runnable() {
                 @Override
@@ -236,16 +198,16 @@ public void run() {
                                 } else if (jsonResponse instanceof String) {
                                     onFailure(statusCode, headers, e, (String) jsonResponse);
                                 } else {
-                                    onFailure(statusCode, headers, e, responseBody);
+                                    onFailure(new JSONException("Unexpected type " + jsonResponse.getClass().getName()), (JSONObject) null);
                                 }
                             }
                         });
 
-                    } catch (JSONException ex) {
+                    } catch (final JSONException ex) {
                         postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                onFailure(statusCode, headers, e, responseBody);
+                                onFailure(ex, (JSONObject) null);
                             }
                         });
 
@@ -253,8 +215,28 @@ public void run() {
                 }
             }).start();
         } else {
-            onFailure(e, "");
+            Log.v(LOG_TAG, "response body is null, calling onFailure(Throwable, JSONObject)");
+            onFailure(e, (JSONObject) null);
         }
+    }
 
+    protected Object parseResponse(byte[] responseBody) throws JSONException {
+        if (null == responseBody)
+            return null;
+        Object result = null;
+        try {
+            //trim the string to prevent start with blank, and test if the string is valid JSON, because the parser don't do this :(. If Json is not valid this will return null
+            String jsonString = new String(responseBody, "UTF-8").trim();
+            if (jsonString.startsWith("{") || jsonString.startsWith("[")) {
+                result = new JSONTokener(jsonString).nextValue();
+            }
+            if (result == null) {
+                result = jsonString;
+            }
+        } catch (UnsupportedEncodingException ex) {
+            Log.v(LOG_TAG, "JSON parsing failed, calling onFailure(Throwable, JSONObject)");
+            onFailure(ex, (JSONObject) null);
+        }
+        return result;
     }
 }
diff --git a/library/src/com/loopj/android/http/MySSLSocketFactory.java b/library/src/com/loopj/android/http/MySSLSocketFactory.java
index fdfbffc9..86eeaab9 100644
--- a/library/src/com/loopj/android/http/MySSLSocketFactory.java
+++ b/library/src/com/loopj/android/http/MySSLSocketFactory.java
@@ -4,7 +4,6 @@
 
 import java.io.IOException;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.KeyManagementException;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
@@ -48,7 +47,7 @@ public void checkServerTrusted(
     }
 
     @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
+    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }
 
diff --git a/library/src/com/loopj/android/http/SimpleMultipartEntity.java b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
index f060e64f..4ae3add4 100644
--- a/library/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/library/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -148,22 +148,12 @@ public void addPart(String key, String streamName, InputStream inputStream, Stri
     }
 
     private byte[] createContentDisposition(final String key) {
-        return new StringBuilder()
-                .append("Content-Disposition: form-data; name=\"")
-                .append(key)
-                .append("\"\r\n")
-                .toString()
+        return ("Content-Disposition: form-data; name=\"" + key + "\"\r\n")
                 .getBytes();
     }
 
     private byte[] createContentDisposition(final String key, final String fileName) {
-        return new StringBuilder()
-                .append("Content-Disposition: form-data; name=\"")
-                .append(key)
-                .append("\"; filename=\"")
-                .append(fileName)
-                .append("\"\r\n")
-                .toString()
+        return ("Content-Disposition: form-data; name=\"" + key + "\"; filename=\"" + fileName + "\"\r\n")
                 .getBytes();
     }
 
diff --git a/library/src/com/loopj/android/http/SyncHttpClient.java b/library/src/com/loopj/android/http/SyncHttpClient.java
index 59a97566..a8cf7465 100644
--- a/library/src/com/loopj/android/http/SyncHttpClient.java
+++ b/library/src/com/loopj/android/http/SyncHttpClient.java
@@ -1,59 +1,59 @@
 package com.loopj.android.http;
 
 import android.content.Context;
-import android.os.Message;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.protocol.HttpContext;
 
-public abstract class SyncHttpClient extends AsyncHttpClient {
-    private int responseCode;
-    /*
-     * as this is a synchronous request this is just a helping mechanism to pass
-     * the result back to this method. Therefore the result object has to be a
-     * field to be accessible
+public class SyncHttpClient extends AsyncHttpClient {
+
+    /**
+     * Creates a new SyncHttpClient with default constructor arguments values
      */
-    protected String result;
-    protected AsyncHttpResponseHandler responseHandler = new AsyncHttpResponseHandler() {
-
-        @Override
-        protected void sendResponseMessage(HttpResponse response) {
-            responseCode = response.getStatusLine().getStatusCode();
-            super.sendResponseMessage(response);
-        };
-
-        @Override
-        protected void sendMessage(Message msg) {
-            /*
-             * Dont use the handler and send it directly to the analysis
-			 * (because its all the same thread)
-			 */
-            handleMessage(msg);
-        }
+    public SyncHttpClient() {
+        super(false, 80, 443);
+    }
 
-        @Override
-        public void onSuccess(String content) {
-            result = content;
-        }
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort non-standard HTTP-only port
+     */
+    public SyncHttpClient(int httpPort) {
+        super(false, httpPort, 443);
+    }
 
-        @Override
-        public void onFailure(Throwable error, String content) {
-            result = onRequestFailed(error, content);
-        }
-    };
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param httpPort  non-standard HTTP-only port
+     * @param httpsPort non-standard HTTPS-only port
+     */
+    public SyncHttpClient(int httpPort, int httpsPort) {
+        super(false, httpPort, httpsPort);
+    }
 
     /**
-     * @return the response code for the last request, might be usefull
-     * sometimes
+     * Creates new SyncHttpClient using given params
+     *
+     * @param fixNoHttpResponseException Whether to fix or not issue, by ommiting SSL verification
+     * @param httpPort                   HTTP port to be used, must be greater than 0
+     * @param httpsPort                  HTTPS port to be used, must be greater than 0
      */
-    public int getResponseCode() {
-        return responseCode;
+    public SyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) {
+        super(fixNoHttpResponseException, httpPort, httpsPort);
+    }
+
+    /**
+     * Creates a new SyncHttpClient.
+     *
+     * @param schemeRegistry SchemeRegistry to be used
+     */
+    public SyncHttpClient(SchemeRegistry schemeRegistry) {
+        super(schemeRegistry);
     }
 
-    // Private stuff
     @Override
     protected void sendRequest(DefaultHttpClient client,
                                HttpContext httpContext, HttpUriRequest uriRequest,
@@ -63,12 +63,14 @@ protected void sendRequest(DefaultHttpClient client,
             uriRequest.addHeader("Content-Type", contentType);
         }
 
+        responseHandler.setUseSynchronousMode(true);
+
 		/*
          * will execute the request directly
-		 */
-        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler)
-                .run();
+		*/
+        new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler).run();
     }
+<<<<<<< HEAD
 
     public abstract String onRequestFailed(Throwable error, String content);
 
@@ -135,4 +137,6 @@ public String patch(Context context, String url, HttpEntity entity, String conte
         this.patch(context, url, entity, contentType, responseHandler);
         return result;
     }
+=======
+>>>>>>> upstream/master
 }
diff --git a/library/src/com/loopj/android/http/TextHttpResponseHandler.java b/library/src/com/loopj/android/http/TextHttpResponseHandler.java
new file mode 100644
index 00000000..f99ba1d6
--- /dev/null
+++ b/library/src/com/loopj/android/http/TextHttpResponseHandler.java
@@ -0,0 +1,115 @@
+package com.loopj.android.http;
+
+import org.apache.http.Header;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is
+ * designed to be anonymously overridden with your own response handling code.
+ * <p/>
+ * Additionally, you can override the {@link #onFailure(String, Throwable)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p/>
+ * For example:
+ * <p/>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new TextHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onStart() {
+ *         // Initiated the request
+ *     }
+ *
+ *     &#064;Override
+ *     public void onSuccess(String responseBody) {
+ *         // Successfully got a response
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFailure(String responseBody, Throwable e) {
+ *         // Response failed :(
+ *     }
+ *
+ *     &#064;Override
+ *     public void onFinish() {
+ *         // Completed the request (either success or failure)
+ *     }
+ * });
+ * </pre>
+ */
+public class TextHttpResponseHandler extends AsyncHttpResponseHandler {
+
+    /**
+     * Creates a new TextHttpResponseHandler
+     */
+
+    public TextHttpResponseHandler() {
+        this(DEFAULT_CHARSET);
+    }
+
+    public TextHttpResponseHandler(String encoding) {
+        super();
+        setCharset(encoding);
+    }
+
+    //
+    // Callbacks to be overridden, typically anonymously
+    //
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     *
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(String responseBody, Throwable error) {
+    }
+
+    /**
+     * Fired when a request fails to complete, override to handle in your own
+     * code
+     *
+     * @param statusCode   the status code of the response
+     * @param headers      HTTP response headers
+     * @param responseBody the response body, if any
+     * @param error        the underlying cause of the failure
+     */
+    public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
+        onFailure(responseBody, error);
+    }
+
+    /**
+     * Fired when a request returns successfully, override to handle in your own
+     * code
+     *
+     * @param statusCode the status code of the response
+     * @param headers HTTP response headers
+     * @param responseBody the body of the HTTP response from the server
+     */
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, String responseBody) {
+        onSuccess( statusCode, responseBody );
+    }
+
+    @Override
+    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
+        try {
+            onSuccess(statusCode, headers, new String(responseBody, getCharset()));
+        } catch (UnsupportedEncodingException e) {
+            onFailure(0, headers, (String) null, e);
+        }
+    }
+
+    @Override
+    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
+        try {
+            onFailure(statusCode, headers, new String(responseBody, getCharset()), error);
+        } catch (UnsupportedEncodingException e) {
+            onFailure(0, headers, (String) null, e);
+        }
+    }
+
+}
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
deleted file mode 100644
index d7ef938f..00000000
--- a/sample/AndroidManifest.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.loopj.android.http.sample"
-    android:versionName="1.4.4-SNAPSHOT"
-    android:versionCode="144">
-
-    <uses-sdk
-        android:minSdkVersion="3"
-        android:targetSdkVersion="18" />
-
-    <application
-        android:name="Android Async Http Sample"
-        android:allowBackup="true"
-        android:allowClearUserData="true">
-        <activity android:name=".MainActivity" />
-    </application>
-
-</manifest> 
diff --git a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
index f5096ae2..62571c72 100644
--- a/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
+++ b/sample/src/main/java/com/loopj/android/http/sample/MainActivity.java
@@ -11,7 +11,7 @@
 import android.widget.Toast;
 
 import com.loopj.android.http.AsyncHttpClient;
-import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.TextHttpResponseHandler;
 
 import org.apache.http.Header;
 
@@ -59,23 +59,23 @@ public void onClick(View v) {
     }
 
     private void startRequest() {
-        aclient.get(this, getURLString(), new AsyncHttpResponseHandler() {
+        aclient.get(this, getURLString(), new TextHttpResponseHandler() {
 
             @Override
-            public void onSuccess(int statusCode, Header[] headers, String content) {
+            public void onSuccess(int statusCode, Header[] headers, String responseBody) {
                 setStatusMessage("Succeeded", Color.parseColor("#DD00FF00"));
                 printThrowable(null);
                 printHeaders(headers);
-                printContents(content);
+                printContents(responseBody);
                 printStatusCode(statusCode);
             }
 
             @Override
-            public void onFailure(int statusCode, Header[] headers, Throwable error, String content) {
+            public void onFailure(int statusCode, Header[] headers, String responseBody, Throwable error) {
                 setStatusMessage("Failed", Color.parseColor("#99FF0000"));
                 printThrowable(error);
                 printHeaders(headers);
-                printContents(content);
+                printContents(responseBody);
                 printStatusCode(statusCode);
             }
 
diff --git a/sample/src/main/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
index 27cb01e6..7d92ae61 100644
--- a/sample/src/main/res/layout/activity_main.xml
+++ b/sample/src/main/res/layout/activity_main.xml
@@ -25,13 +25,13 @@
                 android:layout_weight="1"
                 android:inputType="textUri"
                 android:saveEnabled="true"
-                android:text="https://raw.github.com/loopj/android-async-http/master/README.md" />
+                android:text="@string/default_url" />
 
             <Button
                 android:id="@+id/request_get"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:text="GET" />
+                android:text="@string/action_get" />
 
         </LinearLayout>
 
@@ -41,7 +41,7 @@
             android:layout_height="wrap_content"
             android:background="#33000000"
             android:padding="5dip"
-            android:text="Not Yet Started" />
+            android:text="@string/status_n_a" />
 
         <TextView
             android:id="@+id/return_code"
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index de2d6b37..86fe3bbb 100644
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -3,6 +3,8 @@
 
     <string name="app_name">Android Async Http Sample</string>
     <string name="action_settings">Settings</string>
-    <string name="hello_world">Hello world!</string>
+    <string name="default_url">https://raw.github.com/loopj/android-async-http/master/README.md</string>
+    <string name="action_get">GET</string>
+    <string name="status_n_a">Not Yet Started</string>
 
 </resources>
