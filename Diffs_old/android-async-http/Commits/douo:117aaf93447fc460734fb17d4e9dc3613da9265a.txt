diff --git a/.classpath b/.classpath
deleted file mode 100644
index df2a6908..00000000
--- a/.classpath
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="src" path="examples"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
index 5f0750d7..222dc67b 100644
--- a/src/com/loopj/android/http/AsyncHttpClient.java
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -18,18 +18,7 @@
 
 package com.loopj.android.http;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.zip.GZIPInputStream;
+import android.content.Context;
 
 import org.apache.http.Header;
 import org.apache.http.HeaderElement;
@@ -67,7 +56,18 @@
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.SyncBasicHttpContext;
 
-import android.content.Context;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
 
 
 /**
@@ -389,7 +389,11 @@ public void post(String url, RequestParams params, AsyncHttpResponseHandler resp
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        post(context, url, paramsToEntity(params), null, responseHandler);
+        try {
+            post(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+        } catch (IOException e) {
+            responseHandler.sendFailureMessage(e, (String) null);
+        }
     }
 
     /**
@@ -420,7 +424,14 @@ public void post(Context context, String url, HttpEntity entity, String contentT
     public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
             AsyncHttpResponseHandler responseHandler) {
         HttpEntityEnclosingRequestBase request = new HttpPost(url);
-        if(params != null) request.setEntity(paramsToEntity(params));
+        if (params != null) {
+            try {
+                request.setEntity(paramsToEntity(params, responseHandler));
+            } catch (IOException e) {
+                responseHandler.sendFailureMessage(e, (String) null);
+            }
+        }
+
         if(headers != null) request.setHeaders(headers);
         sendRequest(httpClient, httpContext, request, contentType,
                 responseHandler, context);
@@ -479,7 +490,11 @@ public void put(String url, RequestParams params, AsyncHttpResponseHandler respo
      * @param responseHandler the response handler instance that should handle the response.
      */
     public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
-        put(context, url, paramsToEntity(params), null, responseHandler);
+        try {
+            put(context, url, paramsToEntity(params, responseHandler), null, responseHandler);
+        } catch (IOException e) {
+            responseHandler.sendFailureMessage(e, (String) null);
+        }
     }
 
     /**
@@ -584,11 +599,13 @@ public static String getUrlWithQueryString(String url, RequestParams params) {
         return url;
     }
 
-    private HttpEntity paramsToEntity(RequestParams params) {
+    private HttpEntity paramsToEntity(RequestParams params, AsyncHttpResponseHandler responseHandler)
+            throws IOException {
+
         HttpEntity entity = null;
 
-        if(params != null) {
-            entity = params.getEntity();
+        if (params != null) {
+            entity = params.getEntity(responseHandler);
         }
 
         return entity;
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
index 2030265f..4cd1aef9 100644
--- a/src/com/loopj/android/http/AsyncHttpResponseHandler.java
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -21,8 +21,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+
 import org.apache.http.Header;
-import java.io.IOException;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -30,9 +30,7 @@
 import org.apache.http.entity.BufferedHttpEntity;
 import org.apache.http.util.EntityUtils;
 
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
+import java.io.IOException;
 
 /**
  * Used to intercept and handle the responses from requests made using 
@@ -74,6 +72,7 @@
     protected static final int FAILURE_MESSAGE = 1;
     protected static final int START_MESSAGE = 2;
     protected static final int FINISH_MESSAGE = 3;
+    protected static final int PROGRESS_MESSAGE = 4;
 
     private Handler handler;
 
@@ -151,6 +150,10 @@ public void onFailure(Throwable error, String content) {
         onFailure(error);
     }
 
+    /**
+     * Fired when the request progress, override to handle in your own code
+     */
+    public void onProgress(int position, int length) {}
 
     //
     // Pre-processing of messages (executes in background threadpool thread)
@@ -176,6 +179,9 @@ protected void sendFinishMessage() {
         sendMessage(obtainMessage(FINISH_MESSAGE, null));
     }
 
+    protected void sendProgressMessage(int position, int length) {
+        sendMessage(obtainMessage(PROGRESS_MESSAGE, new Object[]{position, length}));
+    }
 
     //
     // Pre-processing of messages (in original calling thread, typically the UI thread)
@@ -210,6 +216,10 @@ protected void handleMessage(Message msg) {
             case FINISH_MESSAGE:
                 onFinish();
                 break;
+            case PROGRESS_MESSAGE:
+            	response = (Object[])msg.obj;
+            	onProgress(((Integer)response[0]).intValue(), ((Integer)response[1]).intValue());
+            	break;
         }
     }
 
@@ -224,7 +234,7 @@ protected void sendMessage(Message msg) {
     protected Message obtainMessage(int responseMessage, Object response) {
         Message msg = null;
         if(handler != null){
-            msg = this.handler.obtainMessage(responseMessage, response);
+            msg = handler.obtainMessage(responseMessage, response);
         }else{
             msg = Message.obtain();
             msg.what = responseMessage;
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
index da60424a..c1b51dcb 100644
--- a/src/com/loopj/android/http/RequestParams.java
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -18,10 +18,16 @@
 
 package com.loopj.android.http;
 
-import java.io.InputStream;
+import org.apache.http.HttpEntity;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.protocol.HTTP;
+
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -29,11 +35,6 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.HttpEntity;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.utils.URLEncodedUtils;
-import org.apache.http.message.BasicNameValuePair;
-
 /**
  * A collection of string request parameters or files to send along with
  * requests made from an {@link AsyncHttpClient} instance.
@@ -54,9 +55,11 @@
  * </pre>
  */
 public class RequestParams {
-    private static String ENCODING = "UTF-8";
+
+    private static final String TAG = "RequestParams";
 
     protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, StreamWrapper> streamParams;
     protected ConcurrentHashMap<String, FileWrapper> fileParams;
     protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
     private String encoding ;
@@ -128,7 +131,20 @@ public void put(String key, String value){
      * @param file the file to add.
      */
     public void put(String key, File file) throws FileNotFoundException {
-        put(key, new FileInputStream(file), file.getName());
+        put(key, file, null);
+    }
+
+    /**
+     * Adds a file to the request.
+     * 
+     * @param key the key name for the new param.
+     * @param file the file to add.
+     * @param contentType the content type of the file, eg. application/json
+     */
+    public void put(String key, File file, String contentType) throws FileNotFoundException {
+        if (key != null && file != null) {
+            fileParams.put(key, new FileWrapper(file, contentType));
+        }
     }
 
     /**
@@ -171,22 +187,22 @@ public void put(String key, InputStream stream) {
      * Adds an input stream to the request.
      * @param key the key name for the new param.
      * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     * @param name the name of the stream.
      */
-    public void put(String key, InputStream stream, String fileName) {
-        put(key, stream, fileName, null);
+    public void put(String key, InputStream stream, String name) {
+        put(key, stream, name, null);
     }
 
     /**
      * Adds an input stream to the request.
      * @param key the key name for the new param.
      * @param stream the input stream to add.
-     * @param fileName the name of the file.
+     * @param name the name of the stream.
      * @param contentType the content type of the file, eg. application/json
      */
-    public void put(String key, InputStream stream, String fileName, String contentType) {
+    public void put(String key, InputStream stream, String name, String contentType) {
         if(key != null && stream != null) {
-            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+            streamParams.put(key, new StreamWrapper(stream, name, contentType));
         }
     }
 
@@ -196,6 +212,7 @@ public void put(String key, InputStream stream, String fileName, String contentT
      */
     public void remove(String key){
         urlParams.remove(key);
+        streamParams.remove(key);
         fileParams.remove(key);
         urlParamsWithArray.remove(key);
     }
@@ -212,10 +229,19 @@ public String toString() {
             result.append(entry.getValue());
         }
 
-        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
             if(result.length() > 0)
                 result.append("&");
 
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("STREAM");
+        }
+
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if (result.length() > 0)
+                result.append("&");
+
             result.append(entry.getKey());
             result.append("=");
             result.append("FILE");
@@ -238,59 +264,66 @@ public String toString() {
         return result.toString();
     }
 
-   /**
+    /**
      * Returns an HttpEntity containing all request parameters
+     * 
+     * @throws IOException if one of the streams cannot be read
      */
-    public HttpEntity getEntity() {
-        HttpEntity entity = null;
+    public HttpEntity getEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        if (streamParams.isEmpty() && fileParams.isEmpty()) {
+            return createFormEntity();
+        } else {
+            return createMultipartEntity(progressHandler);
+        }
+    }
 
-        if(!fileParams.isEmpty()) {
-            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+    private HttpEntity createFormEntity() {
+        try {
+            return new UrlEncodedFormEntity(getParamsList(), encoding);
+        } catch (UnsupportedEncodingException e) {
+            return null; // Actually cannot happen when using utf-8
+        }
+    }
 
-            // Add string params
-            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
-                multipartEntity.addPart(entry.getKey(), entry.getValue());
-            }
+    private HttpEntity createMultipartEntity(AsyncHttpResponseHandler progressHandler) throws IOException {
+        SimpleMultipartEntity entity = new SimpleMultipartEntity(progressHandler);
 
-            // Add dupe params
-            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
-                ArrayList<String> values = entry.getValue();
-                for (String value : values) {
-                    multipartEntity.addPart(entry.getKey(), value);
-                }
-            }
+        // Add string params
+        for (ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            entity.addPart(entry.getKey(), entry.getValue());
+        }
 
-            // Add file params
-            int currentIndex = 0;
-            int lastIndex = fileParams.entrySet().size() - 1;
-            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
-                FileWrapper file = entry.getValue();
-                if(file.inputStream != null) {
-                    boolean isLast = currentIndex == lastIndex;
-                    if(file.contentType != null) {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
-                    } else {
-                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
-                    }
-                }
-                currentIndex++;
+        // Add dupe params
+        for (ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray
+                .entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                entity.addPart(entry.getKey(), value);
             }
+        }
 
-            entity = multipartEntity;
-        } else {
-            try {
-                entity = new UrlEncodedFormEntity(getParamsList(), encoding);
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
+        // Add stream params
+        for (ConcurrentHashMap.Entry<String, StreamWrapper> entry : streamParams.entrySet()) {
+            StreamWrapper stream = entry.getValue();
+            if (stream.inputStream != null) {
+                entity.addPart(entry.getKey(), stream.name, stream.inputStream,
+                        stream.contentType);
             }
         }
 
+        // Add file params
+        for (ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            FileWrapper fileWrapper = entry.getValue();
+            entity.addPart(entry.getKey(), fileWrapper.file, fileWrapper.contentType);
+        }
+
         return entity;
     }
 
     private void init(){
-    	encoding = ENCODING;
+    	encoding = HTTP.UTF_8;
         urlParams = new ConcurrentHashMap<String, String>();
+        streamParams = new ConcurrentHashMap<String, StreamWrapper>();
         fileParams = new ConcurrentHashMap<String, FileWrapper>();
         urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
     }
@@ -317,22 +350,24 @@ protected String getParamString() {
     }
 
     private static class FileWrapper {
-        public InputStream inputStream;
-        public String fileName;
+        public File file;
         public String contentType;
 
-        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
-            this.inputStream = inputStream;
-            this.fileName = fileName;
+        public FileWrapper(File file, String contentType) {
+            this.file = file;
             this.contentType = contentType;
         }
+    }
 
-        public String getFileName() {
-            if(fileName != null) {
-                return fileName;
-            } else {
-                return "nofilename";
-            }
+    private static class StreamWrapper {
+        public InputStream inputStream;
+        public String name;
+        public String contentType;
+
+        public StreamWrapper(InputStream inputStream, String name, String contentType) {
+            this.inputStream = inputStream;
+            this.name = name;
+            this.contentType = contentType;
         }
     }
     
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
index 3221ec1e..28dfdb8e 100644
--- a/src/com/loopj/android/http/SimpleMultipartEntity.java
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -23,128 +23,219 @@
 
 package com.loopj.android.http;
 
-import java.io.ByteArrayInputStream;
+import android.util.Log;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-
+/**
+ * Simplified multipart entity mainly used for sending one or more files.
+ */
 class SimpleMultipartEntity implements HttpEntity {
+
+    private static final String TAG = "SimpleMultipartEntity";
+
+    private static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
+    private static final byte[] CR_LF = ("\r\n").getBytes();
+    private static final byte[] TRANSFER_ENCODING_BINARY = "Content-Transfer-Encoding: binary\r\n"
+            .getBytes();
+
     private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
 
-    private String boundary = null;
+    private String boundary;
+    private byte[] boundaryLine;
+    private byte[] boundaryEnd;
+    
+    private List<FilePart> fileParts = new ArrayList<FilePart>();
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    boolean isSetLast = false;
-    boolean isSetFirst = false;
+    // The buffer we use for building the message excluding files and the last
+    // boundary
+    private ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    public SimpleMultipartEntity() {
+    private AsyncHttpResponseHandler progressHandler;
+
+    private int bytesWritten;
+
+    private int totalSize;
+
+    public SimpleMultipartEntity(AsyncHttpResponseHandler progressHandler) {
         final StringBuffer buf = new StringBuffer();
         final Random rand = new Random();
         for (int i = 0; i < 30; i++) {
             buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
         }
-        this.boundary = buf.toString();
 
+        boundary = buf.toString();
+        boundaryLine = ("--" + boundary + "\r\n").getBytes();
+        boundaryEnd = ("--" + boundary + "--\r\n").getBytes();
+
+        this.progressHandler = progressHandler;
     }
 
-    public void writeFirstBoundaryIfNeeds(){
-        if(!isSetFirst){
-            writeBoundary();
+    public void addPart(final String key, final String value, final String contentType) {
+        try {
+            out.write(boundaryLine);
+            out.write(createContentDisposition(key));
+            out.write(createContentType(contentType));
+            out.write(CR_LF);
+            out.write(value.getBytes());
+            out.write(CR_LF);
+        } catch (final IOException e) {
+            // Can't happen on ByteArrayOutputStream
         }
+    }
+    
+    public void addPart(final String key, final String value) {
+        addPart(key, value, "text/plain; charset=UTF-8");
+    }
 
-        isSetFirst = true;
+    public void addPart(String key, File file) {
+        addPart(key, file, null);
     }
 
-    public void writeBoundary() {
-        try {
-            out.write(("--" + boundary + "\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
+    public void addPart(final String key, File file, String type) {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
         }
+        fileParts.add(new FilePart(key, file, type));
     }
 
-    public void writeLastBoundaryIfNeeds() {
-        if(isSetLast){
-            return;
+    public void addPart(String key, String streamName, InputStream inputStream, String type)
+            throws IOException {
+        if (type == null) {
+            type = APPLICATION_OCTET_STREAM;
+        }
+        out.write(boundaryLine);
+
+        // Headers
+        out.write(createContentDisposition(key, streamName));
+        out.write(createContentType(type));
+        out.write(TRANSFER_ENCODING_BINARY);
+        out.write(CR_LF);
+
+        // Stream (file)
+        final byte[] tmp = new byte[4096];
+        int l = 0;
+        while ((l = inputStream.read(tmp)) != -1) {
+            out.write(tmp, 0, l);
         }
 
+        out.write(CR_LF);
+        out.flush();
         try {
-            out.write(("--" + boundary + "--\r\n").getBytes());
-            out.flush();
+            inputStream.close();
         } catch (final IOException e) {
-            e.printStackTrace();
+            // Not important, just log it
+            Log.w(TAG, "Cannot close input stream", e);
         }
-        
-        isSetLast = true;
     }
 
-    public void addPart(final String key, final String value, final String contentType) {
-        writeBoundary();
-        try {
-            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n").getBytes());
-            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
-            out.write(value.getBytes());
-            out.write(("\r\n").getBytes());
-        } catch (final IOException e) {
-            e.printStackTrace();
-        }
+    private byte[] createContentType(String type) {
+        String result = "Content-Type: " + type + "\r\n";
+        return result.getBytes();
     }
 
-    public void addPart(final String key, final String value) {
-        addPart(key,value,"text/plain; charset=UTF-8");
+    private byte[] createContentDisposition(final String key) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("Content-Disposition: form-data; name=\"");
+        builder.append(key);
+        builder.append("\"\r\n");
+        return builder.toString().getBytes();
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
-        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    private byte[] createContentDisposition(final String key, final String fileName) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("Content-Disposition: form-data; name=\"");
+        builder.append(key);
+        builder.append("\"; filename=\"");
+        builder.append(fileName);
+        builder.append("\"\r\n");
+        return builder.toString().getBytes();
     }
 
-    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
-        writeBoundary();
-        try {
-            type = "Content-Type: "+type+"\r\n";
-            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
-            out.write(type.getBytes());
-            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+    private void updateProgress(int count) {
+        bytesWritten += count;
+        progressHandler.sendProgressMessage(bytesWritten, totalSize);
+    }
+    
+    private class FilePart {
+        public File file;
+        public byte[] header;
+
+        public FilePart(String key, File file, String type) {
+            header = createHeader(key, file.getName(), type);
+            this.file = file;
+        }
 
+        private byte[] createHeader(String key, String filename, String type) {
+            ByteArrayOutputStream headerStream = new ByteArrayOutputStream();
+            try {
+                headerStream.write(boundaryLine);
+
+                // Headers
+                headerStream.write(createContentDisposition(key, filename));
+                headerStream.write(createContentType(type));
+                headerStream.write(TRANSFER_ENCODING_BINARY);
+                headerStream.write(CR_LF);
+            } catch (IOException e) {
+                // Can't happen on ByteArrayOutputStream
+            }
+            return headerStream.toByteArray();
+        }
+
+        public long getTotalLength() {
+            long streamLength = file.length();
+            return header.length + streamLength;
+        }
+
+        public void writeTo(OutputStream out) throws IOException {
+            out.write(header);
+            updateProgress(header.length);
+
+            FileInputStream inputStream = new FileInputStream(file);
             final byte[] tmp = new byte[4096];
             int l = 0;
-            while ((l = fin.read(tmp)) != -1) {
+            while ((l = inputStream.read(tmp)) != -1) {
                 out.write(tmp, 0, l);
+                updateProgress(l);
             }
-            out.write(("\r\n").getBytes());
-            
-        } catch (final IOException e) {
-            e.printStackTrace();
-        } finally {
+            out.write(CR_LF);
+            updateProgress(CR_LF.length);
+            out.flush();
             try {
-                fin.close();
+                inputStream.close();
             } catch (final IOException e) {
-                e.printStackTrace();
+                // Not important, just log it
+                Log.w(TAG, "Cannot close input stream", e);
             }
         }
     }
 
-    public void addPart(final String key, final File value, final boolean isLast) {
-        try {
-            addPart(key, value.getName(), new FileInputStream(value), isLast);
-        } catch (final FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
+    // The following methods are from the HttpEntity interface
 
     @Override
     public long getContentLength() {
-        writeLastBoundaryIfNeeds();
-        return out.toByteArray().length;
+        long contentLen = out.size();
+        for (FilePart filePart : fileParts) {
+            long len = filePart.getTotalLength();
+            if (len < 0) {
+                return -1; // Should normally not happen
+            }
+            contentLen += len;
+        }
+        contentLen += boundaryEnd.length;
+        return contentLen;
     }
 
     @Override
@@ -169,8 +260,16 @@ public boolean isStreaming() {
 
     @Override
     public void writeTo(final OutputStream outstream) throws IOException {
-        writeLastBoundaryIfNeeds();
-        outstream.write(out.toByteArray());
+        bytesWritten = 0;
+        totalSize = (int) getContentLength();
+        out.writeTo(outstream);
+        updateProgress(out.size());
+
+        for (FilePart filePart : fileParts) {
+            filePart.writeTo(outstream);
+        }
+        outstream.write(boundaryEnd);
+        updateProgress(boundaryEnd.length);
     }
 
     @Override
@@ -179,8 +278,7 @@ public Header getContentEncoding() {
     }
 
     @Override
-    public void consumeContent() throws IOException,
-    UnsupportedOperationException {
+    public void consumeContent() throws IOException, UnsupportedOperationException {
         if (isStreaming()) {
             throw new UnsupportedOperationException(
             "Streaming entity does not implement #consumeContent()");
@@ -188,9 +286,8 @@ public void consumeContent() throws IOException,
     }
 
     @Override
-    public InputStream getContent() throws IOException,
-    UnsupportedOperationException {
-    	writeLastBoundaryIfNeeds();
-        return new ByteArrayInputStream(out.toByteArray());
+    public InputStream getContent() throws IOException, UnsupportedOperationException {
+        throw new UnsupportedOperationException(
+                "getContent() is not supported. Use writeTo() instead.");
     }
 }
\ No newline at end of file
