diff --git a/.classpath b/.classpath
new file mode 100644
index 00000000..87665aec
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..04e6b04f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+.settings
+bin/
+gen/
\ No newline at end of file
diff --git a/.project b/.project
new file mode 100644
index 00000000..bea411d8
--- /dev/null
+++ b/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>AsyncHttpClient</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
new file mode 100644
index 00000000..628c04e5
--- /dev/null
+++ b/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    android:versionCode="1"
+    android:versionName="1.4.1" package="com.loopj.android.http">
+
+    <application  android:label="http">
+        <activity
+            android:name="framework.sample.TestActivity"
+            android:configChanges="orientation|keyboardHidden"
+            android:label="http"
+            android:screenOrientation="portrait"
+            android:windowSoftInputMode="stateHidden" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+    <uses-sdk android:minSdkVersion="5" />
+    
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+</manifest>
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 00000000..3bb87f73
--- /dev/null
+++ b/README.md
@@ -0,0 +1,95 @@
+An improved Android Asynchronous HTTP Library.
+-------------------
+
+基于Android Asynchronous HTTP Library改进版网络加载框架：
+
+1.增加GET方式下可缓存加载功能。
+
+2.便于JSON-RPC,XML-RPC方式调用。
+
+Android Asynchronous HTTP Library (https://github.com/loopj/android-async-http)
+
+
+用法：
+--------------------
+
+    private static final int REQUEST_GET_ID = 0;
+	private static final int REQUEST_POST_ID = 1;
+	private static final int REQUEST_POST_JSON_ID = 2;
+	private static final int REQUEST_POST_XML_ID = 3;
+
+	public void sample(Context context) {
+		get(context);
+		postParams(context);
+		postJSONObject(context);
+		postXML(context);
+	}
+
+	/**
+	 * get by url
+	 */
+	private void get(Context context) {
+		RequestManager.getInstance().get(context, "http://test.com/api.php", requestListener, REQUEST_GET_ID);
+	}
+
+	/**
+	 * post by RequestParams
+	 */
+	private void postParams(Context context) {
+		final RequestParams params = new RequestParams();
+		params.put("key1", "value1");
+		params.put("key2", "value2");
+		RequestManager.getInstance().post(context, "http://test.com/api.php", params, requestListener, REQUEST_POST_ID);
+	}
+
+	/**
+	 * post by JSONObject
+	 */
+	private void postJSONObject(Context context) {
+		final JSONObject json = new JSONObject();
+		try {
+			json.put("key1", "value1");
+			json.put("key2", "value2");
+		} catch (JSONException e) {
+			e.printStackTrace();
+		}
+		RequestManager.getInstance().post(context, "http://test.com/api.php", json, requestListener,
+				REQUEST_POST_JSON_ID);
+	}
+
+	/**
+	 * post by xml
+	 */
+	private void postXML(Context context) {
+		final String xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?><key1>value1</key1><key2>value2</key2>";
+		RequestManager.getInstance()
+				.post(context, "http://test.com/api.php", xml, requestListener, REQUEST_POST_XML_ID);
+	}
+
+	/**
+	 * request listener
+	 */
+	private RequestListener requestListener = new RequestListener() {
+		@Override
+		public void onStart() {
+			// showDialog();
+		}
+
+		@Override
+		public void onCompleted(int statusCode, byte[] data, long lastModified, String description, int actionId) {
+			// dismissDialog();
+			if (REQUEST_GET_ID == actionId) {
+				if (RequestListener.OK == statusCode) {
+					// sucess
+				} else {
+					// handler error case
+				}
+			} else if (REQUEST_POST_ID == actionId) {
+
+			} else if (REQUEST_POST_JSON_ID == actionId) {
+
+			} else if (REQUEST_POST_XML_ID == actionId) {
+
+			}
+		}
+	};
diff --git a/default.properties b/default.properties
new file mode 100644
index 00000000..948be06e
--- /dev/null
+++ b/default.properties
@@ -0,0 +1,12 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-8
+android.library=true
diff --git a/project.properties b/project.properties
new file mode 100644
index 00000000..a2de03ee
--- /dev/null
+++ b/project.properties
@@ -0,0 +1,12 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system use,
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-8
+android.library=true
diff --git a/release/android-app-http.jar b/release/android-app-http.jar
new file mode 100644
index 00000000..d7e2adb6
Binary files /dev/null and b/release/android-app-http.jar differ
diff --git a/src/com/allthelucky/http/RequestListener.java b/src/com/allthelucky/http/RequestListener.java
new file mode 100644
index 00000000..f5d98cdc
--- /dev/null
+++ b/src/com/allthelucky/http/RequestListener.java
@@ -0,0 +1,37 @@
+package com.allthelucky.http;
+
+/**
+ * Request Listener for AsyncHttpResponseHandler
+ * 
+ * @author savant-pan
+ * 
+ */
+public interface RequestListener {
+	/**
+	 * Status OK
+	 */
+	public final static int OK = 0;
+	/**
+	 * Status ERR
+	 */
+	public final static int ERR = 1;
+
+	/**
+	 * callback when Request start
+	 */
+	void onStart();
+
+	/**
+	 * callback when Request end
+	 * 
+	 * @param data
+	 *            byte array if any
+	 * @param statusCode
+	 *            Request Status
+	 * @param description
+	 *            description
+	 * @param actionId
+	 *            request identifier
+	 */
+	void onCompleted(int statusCode, byte[] data, long lastModified, String description, int actionId);
+}
diff --git a/src/com/allthelucky/http/RequestManager.java b/src/com/allthelucky/http/RequestManager.java
new file mode 100644
index 00000000..5f776ea3
--- /dev/null
+++ b/src/com/allthelucky/http/RequestManager.java
@@ -0,0 +1,612 @@
+package com.allthelucky.http;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
+import org.json.JSONObject;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.AsyncTask;
+import android.text.TextUtils;
+
+import com.loopj.android.http.AsyncHttpClient;
+import com.loopj.android.http.AsyncHttpResponseHandler;
+import com.loopj.android.http.RequestParams;
+
+/**
+ * Request Manager based on AsyncHttpClient
+ * 
+ * @author savant-pan
+ * 
+ */
+public class RequestManager {
+	private final AsyncHttpClient asyncHttpClient;
+	private static RequestManager INSTANCE = null;
+
+	protected RequestManager() {
+		this.asyncHttpClient = new AsyncHttpClient();
+	}
+
+	public static RequestManager getInstance() {
+		if (INSTANCE == null) {
+			INSTANCE = new RequestManager();
+		}
+		return INSTANCE;
+	}
+
+	/**
+	 * 清空缓存文件
+	 * 
+	 * @param context
+	 */
+	public static void clearHttpCache(Context context) {
+		final String fl[] = context.fileList();
+		try {
+			for (String f : fl) {
+				context.deleteFile(f);
+			}
+			RequestChacheManager.getInstance(context).deleteAll();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void cancel(Context context) {
+		asyncHttpClient.cancelRequests(context, true);
+	}
+
+	/**
+	 * 参数列表请求
+	 * 
+	 * @param context
+	 * @param url
+	 * @param params
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void post(Context context, String url, RequestParams params, RequestListener requestListener, int actionId) {
+		asyncHttpClient.post(context, url, params, new HttpResponseHandler(requestListener, actionId));
+	}
+
+	/**
+	 * JSON　参数请求
+	 * 
+	 * @param context
+	 * @param url
+	 * @param params
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void post(Context context, String url, JSONObject params, RequestListener requestListener, int actionId) {
+		asyncHttpClient.post(context, url, rpcToEntity(params.toString(), "application/json"), "application/json",
+				new HttpResponseHandler(requestListener, actionId));
+	}
+
+	/**
+	 * JSON　参数请求
+	 * 
+	 * @param context
+	 * @param url
+	 * @param headers
+	 * @param params
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void post(Context context, String url, Header[] headers, JSONObject params, RequestListener requestListener,
+			int actionId) {
+		asyncHttpClient.post(context, url, headers, rpcToEntity(params.toString(), "application/json"),
+				"application/json", new HttpResponseHandler(requestListener, actionId));
+	}
+
+	/**
+	 * XML　参数请求
+	 * 
+	 * @param context
+	 * @param url
+	 * @param params
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void post(Context context, String url, String params, RequestListener requestListener, int actionId) {
+		asyncHttpClient.post(context, url, rpcToEntity(params, "application/xml"), "application/xml",
+				new HttpResponseHandler(requestListener, actionId));
+	}
+
+	/**
+	 * XML　参数请求
+	 * 
+	 * @param context
+	 * @param url
+	 * @param headers
+	 * @param params
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void post(Context context, String url, Header[] headers, String params, RequestListener requestListener,
+			int actionId) {
+		asyncHttpClient.post(context, url, headers, rpcToEntity(params, "application/xml"), "application/xml",
+				new HttpResponseHandler(requestListener, actionId));
+	}
+
+	/**
+	 * 将JSON/XML字符串转为HttpEntity(StringEntity)
+	 * 
+	 * @param params
+	 * @param contentType
+	 * @return
+	 */
+	private static HttpEntity rpcToEntity(String params, String contentType) {
+		StringEntity entity = null;
+		if (!TextUtils.isEmpty(params)) {
+			try {
+				entity = new StringEntity(params, HTTP.UTF_8);
+				entity.setContentType(new BasicHeader(HTTP.CONTENT_TYPE, contentType));
+			} catch (UnsupportedEncodingException e) {
+				e.printStackTrace();
+			}
+		}
+		return entity;
+	}
+
+	/**
+	 * get数据
+	 * 
+	 * @param context
+	 * @param url
+	 * @param requestListener
+	 * @param actionId
+	 */
+	public void get(Context context, String url, RequestListener requestListener, int actionId) {
+		get(context, urlEncode(url), null, requestListener, false, actionId);
+	}
+
+	/**
+	 * get数据
+	 * 
+	 * @param context
+	 * @param url
+	 * @param requestListener
+	 * @param isCache
+	 * @param actionId
+	 */
+	public synchronized void get(final Context context, final String url, final RequestParams params,
+			final RequestListener requestListener, final boolean isCache, final int actionId) {
+		if (!isCache) {
+			asyncHttpClient.get(context, url, params, new HttpResponseHandler(requestListener, actionId));
+		} else {
+			if (!hasNetwork(context)) {
+				new AsyncTask<Void, Void, byte[]>() {
+					protected void onPreExecute() {
+						requestListener.onStart();
+					}
+
+					@Override
+					protected byte[] doInBackground(Void... params) {
+						return loadCacheResource(context, url);
+					}
+
+					protected void onPostExecute(byte[] result) {
+						boolean flag = (result != null);
+						requestListener.onCompleted((flag ? RequestListener.OK : RequestListener.ERR), result, -1l,
+								flag ? "load cache ok" : "load cache error", actionId);
+					}
+				}.execute();
+			} else {
+				loadAndSaveResource(context, url, requestListener, actionId);
+			}
+		}
+	}
+
+	/**
+	 * 加载并缓存网络数据
+	 * 
+	 * @param context
+	 * @param url
+	 * @param requestListener
+	 * @param actionId
+	 */
+	private void loadAndSaveResource(final Context context, final String url, final RequestListener requestListener,
+			final int actionId) {
+		asyncHttpClient.get(context, url, new HttpResponseHandler(context, url, requestListener, actionId));
+	}
+
+	/**
+	 * 网络请求处理
+	 */
+	private class HttpResponseHandler extends AsyncHttpResponseHandler {
+		private RequestListener requestListener;
+		private int actionId;
+		private Context context;
+		private String url;
+
+		public HttpResponseHandler(RequestListener requestListener, int actionId) {
+			super();
+			this.requestListener = requestListener;
+			this.actionId = actionId;
+		}
+
+		public HttpResponseHandler(Context context, String url, RequestListener requestListener, int actionId) {
+			super();
+			this.context = context;
+			this.url = url;
+			this.requestListener = requestListener;
+			this.actionId = actionId;
+		}
+
+		@Override
+		public void onStart() {
+			super.onStart();
+			requestListener.onStart();
+		}
+
+		@Override
+		protected void onSuccess(int intValue, Header[] headers, final byte[] response, final long lastModified) {
+			super.onSuccess(intValue, headers, response, lastModified);
+			requestListener.onCompleted(RequestListener.OK, response, lastModified, "server response ok", actionId);
+			if (context != null && url != null && isLastModified(lastModified)) {
+				new AsyncTask<Void, Void, Void>() {
+					@Override
+					protected Void doInBackground(Void... params) {
+						saveCacheResource(context, url, response, lastModified);
+						return null;
+					}
+				}.execute();
+			}
+		}
+
+		@Override
+		protected void onFailure(Throwable throwable, String response) {
+			requestListener.onCompleted(RequestListener.ERR, null, -1l, response, actionId);
+		}
+
+		@Override
+		protected boolean isLastModified(long lastModified) {
+			if (context != null && url != null) {// Only "GET" call
+				if (!hasCache(context, url)) {
+					return true;
+				} else {
+					final long ret = RequestChacheManager.getInstance(context).getLastModified(url);
+					return ret != -1 && ret != lastModified;
+				}
+			} else {
+				return super.isLastModified(lastModified);
+			}
+		}
+
+		@Override
+		protected byte[] loadCache() {
+			return loadCacheResource(context, url);
+		}
+	}
+
+	/**
+	 * 读缓存
+	 * 
+	 * @param context
+	 * @param url
+	 */
+	private byte[] loadCacheResource(Context context, final String url) {
+		FileInputStream ins = null;
+		try {
+			ins = context.openFileInput(convertFilename(url));
+			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			byte[] bytes = new byte[4096];
+			int len = 0;
+			while ((len = ins.read(bytes)) > 0) {
+				bos.write(bytes, 0, len);
+			}
+			bos.flush();
+			return bos.toByteArray();
+		} catch (Exception e) {
+			e.printStackTrace();
+			return null;
+		} finally {
+			if (ins != null) {
+				try {
+					ins.close();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	private void saveCacheResource(Context context, String url, byte[] response, long lastModified) {
+		ByteArrayInputStream ins = null;
+		FileOutputStream os = null;
+		try {
+			ins = new ByteArrayInputStream(response);
+			os = context.openFileOutput(convertFilename(url), Context.MODE_PRIVATE);
+			byte[] buffer = new byte[1024];
+			int len = 0;
+			while ((len = ins.read(buffer)) > 0) {
+				os.write(buffer, 0, len);
+			}
+			os.flush();
+
+			RequestChacheManager.getInstance(context).update(url, lastModified);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		} finally {
+			if (ins != null) {
+				try {
+					ins.close();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+			if (os != null) {
+				try {
+					os.close();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	/**
+	 * 检测缓存
+	 */
+	private boolean hasCache(Context context, String url) {
+		FileInputStream ins = null;
+		try {
+			ins = context.openFileInput(convertFilename(url));
+			return true;
+		} catch (Exception e) {
+			return false;
+		} finally {
+			if (ins != null) {
+				try {
+					ins.close();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	/**
+	 * 检验网络是否有连接，有则true，无则false
+	 * 
+	 * @param context
+	 * @return
+	 */
+	public static boolean hasNetwork(Context context) {
+		ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+		NetworkInfo ni = cm.getActiveNetworkInfo();
+		if (ni != null && ni.isConnected()) {
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * 对字符串进行MD5加密。
+	 */
+	private static String convertFilename(String strInput) {
+		StringBuffer buf = null;
+		try {
+			MessageDigest md = MessageDigest.getInstance("MD5");
+			md.update(strInput.getBytes("UTF-8"));
+			byte b[] = md.digest();
+			buf = new StringBuffer(b.length * 2);
+			for (int i = 0; i < b.length; i++) {
+				if (((int) b[i] & 0xff) < 0x10) { /* & 0xff转换无符号整型 */
+					buf.append("0");
+				}
+				buf.append(Long.toHexString((int) b[i] & 0xff)); /* 转换16进制,下方法同 */
+			}
+		} catch (Exception ex) {
+			ex.printStackTrace();
+		}
+		return buf.toString().substring(8, 24);
+	}
+
+	/**
+	 * 网址汉字编码
+	 */
+	private static String urlEncode(String str) {
+		StringBuffer buf = new StringBuffer();
+		byte c;
+		byte[] utfBuf;
+		try {
+			utfBuf = str.getBytes("UTF-8");
+		} catch (UnsupportedEncodingException e) {
+			System.out.println("URLEncode: Failed to get UTF-8 bytes from string.");
+			utfBuf = str.getBytes();
+		}
+		for (int i = 0; i < utfBuf.length; i++) {
+			c = utfBuf[i];
+			if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
+					|| (c == '.' || c == '-' || c == '*' || c == '_')
+					|| (c == ':' || c == '/' || c == '=' || c == '?' || c == '&' || c == '%')) {
+				buf.append((char) c);
+			} else {
+				buf.append("%").append(Integer.toHexString((0x000000FF & c)));
+			}
+		}
+		return buf.toString();
+	}
+
+}
+
+/**
+ * RequestDBHelper
+ */
+class RequestDBHelper extends SQLiteOpenHelper {
+	private static final String DB_NAME = "requestCache.db";
+	private static final int DB_VER = 1;
+	private static final String TABLE_CREATE = "create table request_cache(url varchar(32) primary key,  lastmodified varchar(16))";
+
+	public RequestDBHelper(Context context) {
+		super(context, DB_NAME, null, DB_VER);
+	}
+
+	@Override
+	public void onCreate(SQLiteDatabase db) {
+		db.execSQL(TABLE_CREATE);
+	}
+
+	@Override
+	public void onUpgrade(SQLiteDatabase arg0, int arg1, int arg2) {
+
+	}
+}
+
+/**
+ * RequestChacheManager for "GET" method if isCahce
+ * 
+ * @author savant-pan
+ * 
+ */
+class RequestChacheManager {
+	private static RequestChacheManager INSTANCE = null;
+	private RequestDBHelper requestDBHelper = null;
+
+	private RequestChacheManager(Context context) {
+		this.requestDBHelper = new RequestDBHelper(context);
+	}
+
+	/**
+	 * get instance of RequestChacheManager
+	 * 
+	 * @param context
+	 *            Context value
+	 * @return
+	 */
+	public static RequestChacheManager getInstance(Context context) {
+		if (INSTANCE == null) {
+			INSTANCE = new RequestChacheManager(context);
+		}
+		return INSTANCE;
+	}
+
+	/**
+	 * update record: add or update
+	 * 
+	 * @param item
+	 */
+	public void update(String url, long lastModified) {
+		SQLiteDatabase db = requestDBHelper.getWritableDatabase();
+		if (!find(url)) { // add if not exist
+			db.execSQL("insert into request_cache(url, lastmodified) values(?,?)",
+					new Object[] { url, String.valueOf(lastModified) });
+		} else { // update is exist
+			db.execSQL("update request_cache set lastmodified=? where url=?",
+					new Object[] { String.valueOf(lastModified), url });
+		}
+	}
+
+	/**
+	 * get lastmotified value by url
+	 * 
+	 * @param filename
+	 * @return
+	 */
+	public long getLastModified(String url) {
+		SQLiteDatabase db = requestDBHelper.getReadableDatabase();
+		Cursor cursor = null;
+		try {
+			long ret = 0l;
+			cursor = db.rawQuery("select * from request_cache where url=?", new String[] { url });
+			if (cursor.moveToFirst()) {
+				final String last = cursor.getString(cursor.getColumnIndex("lastmodified"));
+				ret = Long.valueOf(last);
+			}
+			return ret;
+		} catch (Exception e) {
+			e.printStackTrace();
+			return 0l;
+		} finally {
+			if (cursor != null) {
+				cursor.close();
+			}
+		}
+	}
+
+	/**
+	 * check exists of url
+	 * 
+	 * @param url
+	 * @return
+	 */
+	private boolean find(String url) {
+		SQLiteDatabase db = requestDBHelper.getReadableDatabase();
+		Cursor cursor = null;
+		try {
+			boolean flag = false;
+			cursor = db.rawQuery("select * from request_cache where url=?", new String[] { url });
+			if (cursor.moveToFirst()) {
+				flag = true;
+			}
+			return flag;
+		} catch (Exception e) {
+			e.printStackTrace();
+			return false;
+		} finally {
+			if (cursor != null) {
+				cursor.close();
+			}
+		}
+	}
+
+	/**
+	 * delete all records
+	 */
+	public void deleteAll() {
+		List<String> all = getUrls();
+		for (String url : all) {
+			SQLiteDatabase database = requestDBHelper.getWritableDatabase();
+			database.execSQL("delete from request_cache where url=?", new Object[] { url });
+		}
+	}
+
+	/**
+	 * get all urls in database
+	 * 
+	 * @return
+	 */
+	private List<String> getUrls() {
+		List<String> ret = new ArrayList<String>();
+		SQLiteDatabase db = requestDBHelper.getReadableDatabase();
+		Cursor cursor = null;
+		try {
+			cursor = db.rawQuery("select * from request_cache", null);
+			if (cursor.moveToFirst()) {
+				do {
+					final String url = cursor.getString(0);
+					ret.add(url);
+				} while (cursor.moveToNext());
+			}
+		} catch (IllegalStateException e) {
+			e.printStackTrace();
+		} finally {
+			if (cursor != null) {
+				cursor.close();
+			}
+		}
+		return ret;
+	}
+}
+
diff --git a/src/com/loopj/android/http/AsyncHttpClient.java b/src/com/loopj/android/http/AsyncHttpClient.java
new file mode 100644
index 00000000..c23dc732
--- /dev/null
+++ b/src/com/loopj/android/http/AsyncHttpClient.java
@@ -0,0 +1,620 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.zip.GZIPInputStream;
+
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpResponseInterceptor;
+import org.apache.http.HttpVersion;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CookieStore;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.protocol.ClientContext;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.conn.params.ConnPerRouteBean;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.entity.HttpEntityWrapper;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.BasicHttpContext;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.SyncBasicHttpContext;
+
+import android.content.Context;
+
+
+/**
+ * The AsyncHttpClient can be used to make asynchronous GET, POST, PUT and 
+ * DELETE HTTP requests in your Android applications. Requests can be made
+ * with additional parameters by passing a {@link RequestParams} instance,
+ * and responses can be handled by passing an anonymously overridden 
+ * {@link AsyncHttpResponseHandler} instance.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get("http://www.google.com", new AsyncHttpResponseHandler() {
+ *     &#064;Override
+ *     public void onSuccess(String response) {
+ *         System.out.println(response);
+ *     }
+ * });
+ * </pre>
+ */
+public class AsyncHttpClient {
+    private static final String VERSION = "1.4.3";
+
+    private static final int DEFAULT_MAX_CONNECTIONS = 15;
+    private static final int DEFAULT_SOCKET_TIMEOUT = 15 * 1000;
+    private static final int DEFAULT_MAX_RETRIES = 3;
+    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
+    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
+    private static final String ENCODING_GZIP = "gzip";
+
+    private static int maxConnections = DEFAULT_MAX_CONNECTIONS;
+    private static int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+    private final DefaultHttpClient httpClient;
+    private final HttpContext httpContext;
+    private ThreadPoolExecutor threadPool;
+    private final Map<Context, List<WeakReference<Future<?>>>> requestMap;
+    private final Map<String, String> clientHeaderMap;
+
+
+    /**
+     * Creates a new AsyncHttpClient.
+     */
+    public AsyncHttpClient() {
+        BasicHttpParams httpParams = new BasicHttpParams();
+
+        ConnManagerParams.setTimeout(httpParams, socketTimeout);
+        ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));
+        ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);
+
+        HttpConnectionParams.setSoTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, socketTimeout);
+        HttpConnectionParams.setTcpNoDelay(httpParams, true);
+        HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);
+
+        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);
+        HttpProtocolParams.setUserAgent(httpParams, String.format("android-async-http/%s (http://loopj.com/android-async-http)", VERSION));
+
+        SchemeRegistry schemeRegistry = new SchemeRegistry();
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(httpParams, schemeRegistry);
+
+        httpContext = new SyncBasicHttpContext(new BasicHttpContext());
+        httpClient = new DefaultHttpClient(cm, httpParams);
+        httpClient.addRequestInterceptor(new HttpRequestInterceptor() {
+            @Override
+            public void process(HttpRequest request, HttpContext context) {
+                if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) {
+                    request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);
+                }
+                for (String header : clientHeaderMap.keySet()) {
+                    request.addHeader(header, clientHeaderMap.get(header));
+                }
+            }
+        });
+
+        httpClient.addResponseInterceptor(new HttpResponseInterceptor() {
+            @Override
+            public void process(HttpResponse response, HttpContext context) {
+                final HttpEntity entity = response.getEntity();
+                if (entity == null) {
+                    return;
+                }
+                final Header encoding = entity.getContentEncoding();
+                if (encoding != null) {
+                    for (HeaderElement element : encoding.getElements()) {
+                        if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) {
+                            response.setEntity(new InflatingEntity(response.getEntity()));
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+        httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES));
+
+        threadPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();
+
+        requestMap = new WeakHashMap<Context, List<WeakReference<Future<?>>>>();
+        clientHeaderMap = new HashMap<String, String>();
+    }
+
+    /**
+     * Get the underlying HttpClient instance. This is useful for setting
+     * additional fine-grained settings for requests by accessing the
+     * client's ConnectionManager, HttpParams and SchemeRegistry.
+     */
+    public HttpClient getHttpClient() {
+        return this.httpClient;
+    }
+
+    /**
+     * Get the underlying HttpContext instance. This is useful for getting 
+     * and setting fine-grained settings for requests by accessing the
+     * context's attributes such as the CookieStore.
+     */
+    public HttpContext getHttpContext() {
+        return this.httpContext;
+    }
+
+    /**
+     * Sets an optional CookieStore to use when making requests
+     * @param cookieStore The CookieStore implementation to use, usually an instance of {@link PersistentCookieStore}
+     */
+    public void setCookieStore(CookieStore cookieStore) {
+        httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
+    }
+
+    /**
+     * Overrides the threadpool implementation used when queuing/pooling
+     * requests. By default, Executors.newCachedThreadPool() is used.
+     * @param threadPool an instance of {@link ThreadPoolExecutor} to use for queuing/pooling requests.
+     */
+    public void setThreadPool(ThreadPoolExecutor threadPool) {
+        this.threadPool = threadPool;
+    }
+
+    /**
+     * Sets the User-Agent header to be sent with each request. By default,
+     * "Android Asynchronous Http Client/VERSION (http://loopj.com/android-async-http/)" is used.
+     * @param userAgent the string to use in the User-Agent header.
+     */
+    public void setUserAgent(String userAgent) {
+        HttpProtocolParams.setUserAgent(this.httpClient.getParams(), userAgent);
+    }
+
+    /**
+     * Sets the connection time oout. By default, 10 seconds
+     * @param timeout the connect/socket timeout in milliseconds
+     */
+    public void setTimeout(int timeout){
+        final HttpParams httpParams = this.httpClient.getParams();
+        ConnManagerParams.setTimeout(httpParams, timeout);
+        HttpConnectionParams.setSoTimeout(httpParams, timeout);
+        HttpConnectionParams.setConnectionTimeout(httpParams, timeout);
+    }
+
+    /**
+     * Sets the SSLSocketFactory to user when making requests. By default,
+     * a new, default SSLSocketFactory is used.
+     * @param sslSocketFactory the socket factory to use for https requests.
+     */
+    public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+        this.httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", sslSocketFactory, 443));
+    }
+    
+    /**
+     * Sets headers that will be added to all requests this client makes (before sending).
+     * @param header the name of the header
+     * @param value the contents of the header
+     */
+    public void addHeader(String header, String value) {
+        clientHeaderMap.put(header, value);
+    }
+
+    /**
+     * Sets basic authentication for the request. Uses AuthScope.ANY. This is the same as
+     * setBasicAuth('username','password',AuthScope.ANY) 
+     * @param username
+     * @param password
+     */
+    public void setBasicAuth(String user, String pass){
+        AuthScope scope = AuthScope.ANY;
+        setBasicAuth(user, pass, scope);
+    }
+    
+   /**
+     * Sets basic authentication for the request. You should pass in your AuthScope for security. It should be like this
+     * setBasicAuth("username","password", new AuthScope("host",port,AuthScope.ANY_REALM))
+     * @param username
+     * @param password
+     * @param scope - an AuthScope object
+     *
+     */
+    public void setBasicAuth( String user, String pass, AuthScope scope){
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user,pass);
+        this.httpClient.getCredentialsProvider().setCredentials(scope, credentials);
+    }
+
+    /**
+     * Cancels any pending (or potentially active) requests associated with the
+     * passed Context.
+     * <p>
+     * <b>Note:</b> This will only affect requests which were created with a non-null
+     * android Context. This method is intended to be used in the onDestroy
+     * method of your android activities to destroy all requests which are no
+     * longer required.
+     *
+     * @param context the android Context instance associated to the request.
+     * @param mayInterruptIfRunning specifies if active requests should be cancelled along with pending requests.
+     */
+    public void cancelRequests(Context context, boolean mayInterruptIfRunning) {
+        List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+        if(requestList != null) {
+            for(WeakReference<Future<?>> requestRef : requestList) {
+                Future<?> request = requestRef.get();
+                if(request != null) {
+                    request.cancel(mayInterruptIfRunning);
+                }
+            }
+        }
+        requestMap.remove(context);
+    }
+
+
+    //
+    // HTTP GET Requests
+    //
+
+    /**
+     * Perform a HTTP GET request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(String url, AsyncHttpResponseHandler responseHandler) {
+        get(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        get(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request without any parameters and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        get(context, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void get(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(url, params)), null, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP GET request and track the Android Context which initiated
+     * the request with customized headers
+     * 
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param params additional GET parameters to send with the request.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void get(Context context, String url, Header[] headers, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        HttpUriRequest request = new HttpGet(getUrlWithQueryString(url, params));
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, null, responseHandler,
+                context);
+    }
+
+
+    //
+    // HTTP POST Requests
+    //
+
+    /**
+     * Perform a HTTP POST request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(String url, AsyncHttpResponseHandler responseHandler) {
+        post(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        post(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional POST parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        post(context, url, paramsToEntity(params), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void post(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(url), entity), contentType, responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated
+     * the request. Set headers only for this request
+     * 
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param params additional POST parameters to send with the request.
+     * @param contentType the content type of the payload you are sending, for
+     *        example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void post(Context context, String url, Header[] headers, RequestParams params, String contentType,
+            AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = new HttpPost(url);
+        if(params != null) request.setEntity(paramsToEntity(params));
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType,
+                responseHandler, context);
+    }
+
+    /**
+     * Perform a HTTP POST request and track the Android Context which initiated
+     * the request. Set headers only for this request
+     *
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set headers only for this request
+     * @param entity a raw {@link HttpEntity} to send with the request, for
+     *        example, use this to send string/json/xml payloads to a server by
+     *        passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for
+     *        example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle
+     *        the response.
+     */
+    public void post(Context context, String url, Header[] headers, HttpEntity entity, String contentType,
+            AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPost(url), entity);
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    //
+    // HTTP PUT Requests
+    //
+
+    /**
+     * Perform a HTTP PUT request, without any parameters.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(String url, AsyncHttpResponseHandler responseHandler) {
+        put(null, url, null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request with parameters.
+     * @param url the URL to send the request to.
+     * @param params additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        put(null, url, params, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param params additional PUT parameters or files to send with the request.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
+        put(context, url, paramsToEntity(params), null, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * And set one-time headers for the request
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPut(url), entity), contentType, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP PUT request and track the Android Context which initiated the request.
+     * And set one-time headers for the request
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set one-time headers for this request
+     * @param entity a raw {@link HttpEntity} to send with the request, for example, use this to send string/json/xml payloads to a server by passing a {@link org.apache.http.entity.StringEntity}.
+     * @param contentType the content type of the payload you are sending, for example application/json if sending a json payload.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void put(Context context, String url,Header[] headers, HttpEntity entity, String contentType, AsyncHttpResponseHandler responseHandler) {
+        HttpEntityEnclosingRequestBase request = addEntityToRequestBase(new HttpPut(url), entity);
+        if(headers != null) request.setHeaders(headers);
+        sendRequest(httpClient, httpContext, request, contentType, responseHandler, context);
+    }
+
+    //
+    // HTTP DELETE Requests
+    //
+
+    /**
+     * Perform a HTTP DELETE request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(String url, AsyncHttpResponseHandler responseHandler) {
+        delete(null, url, responseHandler);
+    }
+
+    /**
+     * Perform a HTTP DELETE request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(url);
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+    
+    /**
+     * Perform a HTTP DELETE request.
+     * @param context the Android Context which initiated the request.
+     * @param url the URL to send the request to.
+     * @param headers set one-time headers for this request
+     * @param responseHandler the response handler instance that should handle the response.
+     */
+    public void delete(Context context, String url, Header[] headers, AsyncHttpResponseHandler responseHandler) {
+        final HttpDelete delete = new HttpDelete(url);
+        if(headers != null) delete.setHeaders(headers);
+        sendRequest(httpClient, httpContext, delete, null, responseHandler, context);
+    }
+
+
+    // Private stuff
+    protected void sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, AsyncHttpResponseHandler responseHandler, Context context) {
+        if(contentType != null) {
+            uriRequest.addHeader("Content-Type", contentType);
+        }
+
+        Future<?> request = threadPool.submit(new AsyncHttpRequest(client, httpContext, uriRequest, responseHandler));
+
+        if(context != null) {
+            // Add request to request map
+            List<WeakReference<Future<?>>> requestList = requestMap.get(context);
+            if(requestList == null) {
+                requestList = new LinkedList<WeakReference<Future<?>>>();
+                requestMap.put(context, requestList);
+            }
+
+            requestList.add(new WeakReference<Future<?>>(request));
+
+            // TODO: Remove dead weakrefs from requestLists?
+        }
+    }
+
+    public static String getUrlWithQueryString(String url, RequestParams params) {
+        if(params != null) {
+            String paramString = params.getParamString();
+            if (url.indexOf("?") == -1) {
+                url += "?" + paramString;
+            } else {
+                url += "&" + paramString;
+            }
+        }
+
+        return url;
+    }
+
+    private HttpEntity paramsToEntity(RequestParams params) {
+        HttpEntity entity = null;
+
+        if(params != null) {
+            entity = params.getEntity();
+        }
+
+        return entity;
+    }
+
+    private HttpEntityEnclosingRequestBase addEntityToRequestBase(HttpEntityEnclosingRequestBase requestBase, HttpEntity entity) {
+        if(entity != null){
+            requestBase.setEntity(entity);
+        }
+
+        return requestBase;
+    }
+
+    private static class InflatingEntity extends HttpEntityWrapper {
+        public InflatingEntity(HttpEntity wrapped) {
+            super(wrapped);
+        }
+
+        @Override
+        public InputStream getContent() throws IOException {
+            return new GZIPInputStream(wrappedEntity.getContent());
+        }
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+    }
+}
diff --git a/src/com/loopj/android/http/AsyncHttpRequest.java b/src/com/loopj/android/http/AsyncHttpRequest.java
new file mode 100644
index 00000000..64239f0f
--- /dev/null
+++ b/src/com/loopj/android/http/AsyncHttpRequest.java
@@ -0,0 +1,128 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpRequestRetryHandler;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.protocol.HttpContext;
+
+class AsyncHttpRequest implements Runnable {
+	private final AbstractHttpClient client;
+	private final HttpContext context;
+	private final HttpUriRequest request;
+	private final AsyncHttpResponseHandler responseHandler;
+	private int executionCount;
+
+	public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request,
+			AsyncHttpResponseHandler responseHandler) {
+		this.client = client;
+		this.context = context;
+		this.request = request;
+		this.responseHandler = responseHandler;
+	}
+
+	@Override
+	public void run() {
+		try {
+			if (responseHandler != null) {
+				responseHandler.sendStartMessage();
+			}
+			makeRequestWithRetries();
+		} catch (IOException e) {
+			if (responseHandler != null) {
+				responseHandler.sendFailureMessage(e, e.getMessage());
+			}
+		}
+	}
+
+	private void makeRequest() throws IOException {
+		if (!Thread.currentThread().isInterrupted()) {
+			try {
+				HttpResponse response = client.execute(request, context);
+				if (!Thread.currentThread().isInterrupted()) {
+					if (responseHandler != null) {
+						responseHandler.sendResponseMessage(response);
+					}
+				} else {
+					// TODO: should raise InterruptedException? this block is
+					// reached whenever the request is cancelled before its
+					// response is received
+				}
+			} catch (IOException e) {
+				if (!Thread.currentThread().isInterrupted()) {
+					throw e;
+				}
+			}
+		}
+	}
+
+	private void makeRequestWithRetries() throws ConnectException {
+		// This is an additional layer of retry logic lifted from droid-fu
+		// See:
+		// https://github.com/kaeppler/droid-fu/blob/master/src/main/java/com/github/droidfu/http/BetterHttpRequestBase.java
+		boolean retry = true;
+		IOException cause = null;
+		HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();
+		while (retry) {
+			try {
+				makeRequest();
+				return;
+			} catch (UnknownHostException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketException e) {
+				// Added to detect host unreachable
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "can't resolve host");
+				}
+				return;
+			} catch (SocketTimeoutException e) {
+				if (responseHandler != null) {
+					responseHandler.sendFailureMessage(e, "socket time out");
+				}
+				return;
+			} catch (IOException e) {
+				cause = e;
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			} catch (NullPointerException e) {
+				// there's a bug in HttpClient 4.0.x that on some occasions
+				// causes
+				// DefaultRequestExecutor to throw an NPE, see
+				// http://code.google.com/p/android/issues/detail?id=5255
+				cause = new IOException("NPE in HttpClient" + e.getMessage());
+				retry = retryHandler.retryRequest(cause, ++executionCount, context);
+			}
+		}
+
+		// no retries left, crap out with exception
+		ConnectException ex = new ConnectException();
+		ex.initCause(cause);
+		throw ex;
+	}
+}
diff --git a/src/com/loopj/android/http/AsyncHttpResponseHandler.java b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
new file mode 100644
index 00000000..dd92db53
--- /dev/null
+++ b/src/com/loopj/android/http/AsyncHttpResponseHandler.java
@@ -0,0 +1,218 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ */
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.StatusLine;
+import org.apache.http.client.HttpResponseException;
+import org.apache.http.entity.BufferedHttpEntity;
+import org.apache.http.util.EntityUtils;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+/**
+ * Used to intercept and handle the responses from requests made using
+ * {@link AsyncHttpClient}. The {@link #onSuccess(String)} method is designed to
+ * be anonymously overridden with your own response handling code.
+ * <p>
+ * Additionally, you can override the {@link #onFailure(Throwable, String)},
+ * {@link #onStart()}, and {@link #onFinish()} methods as required.
+ * <p>
+ * For example:
+ * <p>
+ * 
+ * <pre>
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.get(&quot;http://www.google.com&quot;, new AsyncHttpResponseHandler() {
+ * 	&#064;Override
+ * 	public void onStart() {
+ * 		// Initiated the request
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onSuccess(String response) {
+ * 		// Successfully got a response
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onFailure(Throwable e, String response) {
+ * 		// Response failed :(
+ * 	}
+ * 
+ * 	&#064;Override
+ * 	public void onFinish() {
+ * 		// Completed the request (either success or failure)
+ * 	}
+ * });
+ * </pre>
+ */
+public class AsyncHttpResponseHandler {
+	protected static final int SUCCESS_MESSAGE = 0;
+	protected static final int FAILURE_MESSAGE = 1;
+	protected static final int START_MESSAGE = 2;
+	protected static final int FINISH_MESSAGE = 3;
+
+	private Handler handler;
+
+	/**
+	 * Creates a new AsyncHttpResponseHandler
+	 */
+	public AsyncHttpResponseHandler() {
+		// Set up a handler to post events back to the correct thread if
+		// possible
+		if (Looper.myLooper() != null) {
+			handler = new Handler() {
+				@Override
+				public void handleMessage(Message msg) {
+					AsyncHttpResponseHandler.this.handleMessage(msg);
+				}
+			};
+		}
+	}
+
+	//
+	// Callbacks to be overridden, typically anonymously
+	//
+
+	//
+	// Pre-processing of messages (executes in background threadpool thread)
+	//
+	protected void sendStartMessage() {
+		sendMessage(obtainMessage(START_MESSAGE, null));
+	}
+
+	protected void sendSuccessMessage(int statusCode, Header[] headers, byte[] responseBody, long lastModified) {
+		sendMessage(obtainMessage(SUCCESS_MESSAGE, new Object[] { new Integer(statusCode), headers, responseBody,
+				lastModified }));
+	}
+
+	protected void sendFailureMessage(Throwable e, String responseBody) {
+		sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[] { e, responseBody }));
+	}
+
+	// Methods which emulate android's Handler and Message methods
+	protected void handleMessage(Message msg) {
+		Object[] response;
+		switch (msg.what) {
+		case START_MESSAGE:
+			onStart();
+			break;
+		case SUCCESS_MESSAGE:
+			response = (Object[]) msg.obj;
+			onSuccess(((Integer) response[0]).intValue(), (Header[]) response[1], (byte[]) response[2],
+					(Long) response[3]);
+			break;
+		case FAILURE_MESSAGE:
+			response = (Object[]) msg.obj;
+			onFailure((Throwable) response[0], (String) response[1]);
+			break;
+		}
+	}
+
+	/**
+	 * Fired when the request is started, override to handle in your own code
+	 */
+	public void onStart() {
+	}
+
+	protected void onSuccess(int intValue, Header[] headers, byte[] response, long lastModified) {
+
+	}
+
+	protected void onFailure(Throwable throwable, String errorMsg) {
+
+	}
+
+	protected void sendMessage(Message msg) {
+		if (handler != null) {
+			handler.sendMessage(msg);
+		} else {
+			handleMessage(msg);
+		}
+	}
+
+	protected Message obtainMessage(int responseMessage, Object response) {
+		Message msg = null;
+		if (handler != null) {
+			msg = this.handler.obtainMessage(responseMessage, response);
+		} else {
+			msg = Message.obtain();
+			msg.what = responseMessage;
+			msg.obj = response;
+		}
+		return msg;
+	}
+
+	// Interface to AsyncHttpRequest
+	void sendResponseMessage(HttpResponse response) {
+		StatusLine status = response.getStatusLine();
+		long lastModified = -1l;
+		try {
+			final String last = response.getLastHeader("last-modified").getValue();
+			if (null != last && !"".equals(last)) {
+				java.util.Date d = new java.util.Date(last);
+				lastModified = d.getTime();
+			}
+		} catch (Exception e) {
+		}
+
+		boolean modified = isLastModified(lastModified);
+		if (!modified) {
+			sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), loadCache(), lastModified);
+			return;
+		}
+
+		byte[] responseBody = null;
+		try {
+			HttpEntity entity = null;
+			HttpEntity temp = response.getEntity();
+
+			if (temp != null) {
+				entity = new BufferedHttpEntity(temp);
+				responseBody = EntityUtils.toByteArray(entity);
+			}
+		} catch (IOException e) {
+			sendFailureMessage(e, null);
+			return;
+		}
+
+		if (status.getStatusCode() >= 300) {
+			sendFailureMessage(new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()),
+					status.getReasonPhrase());
+		} else {
+			sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, lastModified);
+		}
+	}
+
+	protected boolean isLastModified(long lastModified) {
+		return true;
+	}
+
+	protected byte[] loadCache() {
+		return null;
+	}
+	
+}
diff --git a/src/com/loopj/android/http/PersistentCookieStore.java b/src/com/loopj/android/http/PersistentCookieStore.java
new file mode 100644
index 00000000..11b2a2bf
--- /dev/null
+++ b/src/com/loopj/android/http/PersistentCookieStore.java
@@ -0,0 +1,200 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.http.client.CookieStore;
+import org.apache.http.cookie.Cookie;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.text.TextUtils;
+
+/**
+ * A persistent cookie store which implements the Apache HttpClient
+ * {@link CookieStore} interface. Cookies are stored and will persist on the
+ * user's device between application sessions since they are serialized and
+ * stored in {@link SharedPreferences}.
+ * <p>
+ * Instances of this class are designed to be used with
+ * {@link AsyncHttpClient#setCookieStore}, but can also be used with a 
+ * regular old apache HttpClient/HttpContext if you prefer.
+ */
+public class PersistentCookieStore implements CookieStore {
+    private static final String COOKIE_PREFS = "CookiePrefsFile";
+    private static final String COOKIE_NAME_STORE = "names";
+    private static final String COOKIE_NAME_PREFIX = "cookie_";
+
+    private final ConcurrentHashMap<String, Cookie> cookies;
+    private final SharedPreferences cookiePrefs;
+
+    /**
+     * Construct a persistent cookie store.
+     */
+    public PersistentCookieStore(Context context) {
+        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);
+        cookies = new ConcurrentHashMap<String, Cookie>();
+
+        // Load any previously stored cookies into the store
+        String storedCookieNames = cookiePrefs.getString(COOKIE_NAME_STORE, null);
+        if(storedCookieNames != null) {
+            String[] cookieNames = TextUtils.split(storedCookieNames, ",");
+            for(String name : cookieNames) {
+                String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
+                if(encodedCookie != null) {
+                    Cookie decodedCookie = decodeCookie(encodedCookie);
+                    if(decodedCookie != null) {
+                        cookies.put(name, decodedCookie);
+                    }
+                }
+            }
+
+            // Clear out expired cookies
+            clearExpired(new Date());
+        }
+    }
+
+    @Override
+    public void addCookie(Cookie cookie) {
+        String name = cookie.getName() + cookie.getDomain();
+
+        // Save cookie into local store, or remove if expired
+        if(!cookie.isExpired(new Date())) {
+            cookies.put(name, cookie);
+        } else {
+            cookies.remove(name);
+        }
+
+        // Save cookie into persistent store
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));
+        prefsWriter.commit();
+    }
+
+    @Override
+    public void clear() {
+        // Clear cookies from persistent store
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+        for(String name : cookies.keySet()) {
+            prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+        }
+        prefsWriter.remove(COOKIE_NAME_STORE);
+        prefsWriter.commit();
+
+        // Clear cookies from local store
+        cookies.clear();
+    }
+
+    @Override
+    public boolean clearExpired(Date date) {
+        boolean clearedAny = false;
+        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
+
+        for(ConcurrentHashMap.Entry<String, Cookie> entry : cookies.entrySet()) {
+            String name = entry.getKey();
+            Cookie cookie = entry.getValue();
+            if(cookie.isExpired(date)) {
+                // Clear cookies from local store
+                cookies.remove(name);
+
+                // Clear cookies from persistent store
+                prefsWriter.remove(COOKIE_NAME_PREFIX + name);
+
+                // We've cleared at least one
+                clearedAny = true;
+            }
+        }
+
+        // Update names in persistent store
+        if(clearedAny) {
+            prefsWriter.putString(COOKIE_NAME_STORE, TextUtils.join(",", cookies.keySet()));
+        }
+        prefsWriter.commit();
+
+        return clearedAny;
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+        return new ArrayList<Cookie>(cookies.values());
+    }
+
+
+    //
+    // Cookie serialization/deserialization
+    //
+
+    protected String encodeCookie(SerializableCookie cookie) {
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        try {
+            ObjectOutputStream outputStream = new ObjectOutputStream(os);
+            outputStream.writeObject(cookie);
+        } catch (Exception e) {
+            return null;
+        }
+
+        return byteArrayToHexString(os.toByteArray());
+    }
+
+    protected Cookie decodeCookie(String cookieStr) {
+        byte[] bytes = hexStringToByteArray(cookieStr);
+        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+        Cookie cookie = null;
+        try {
+           ObjectInputStream ois = new ObjectInputStream(is);
+           cookie = ((SerializableCookie)ois.readObject()).getCookie();
+        } catch (Exception e) {
+           e.printStackTrace();
+        }
+
+        return cookie;
+    }
+
+    // Using some super basic byte array <-> hex conversions so we don't have
+    // to rely on any large Base64 libraries. Can be overridden if you like!
+    protected String byteArrayToHexString(byte[] b) {
+        StringBuffer sb = new StringBuffer(b.length * 2);
+        for (byte element : b) {
+            int v = element & 0xff;
+            if(v < 16) {
+                sb.append('0');
+            }
+            sb.append(Integer.toHexString(v));
+        }
+        return sb.toString().toUpperCase();
+    }
+
+    protected byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for(int i=0; i<len; i+=2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
+        }
+        return data;
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/RequestParams.java b/src/com/loopj/android/http/RequestParams.java
new file mode 100644
index 00000000..cbb0c288
--- /dev/null
+++ b/src/com/loopj/android/http/RequestParams.java
@@ -0,0 +1,321 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.InputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.apache.http.message.BasicNameValuePair;
+
+/**
+ * A collection of string request parameters or files to send along with
+ * requests made from an {@link AsyncHttpClient} instance.
+ * <p>
+ * For example:
+ * <p>
+ * <pre>
+ * RequestParams params = new RequestParams();
+ * params.put("username", "james");
+ * params.put("password", "123456");
+ * params.put("email", "my&#064;email.com");
+ * params.put("profile_picture", new File("pic.jpg")); // Upload a File
+ * params.put("profile_picture2", someInputStream); // Upload an InputStream
+ * params.put("profile_picture3", new ByteArrayInputStream(someBytes)); // Upload some bytes
+ *
+ * AsyncHttpClient client = new AsyncHttpClient();
+ * client.post("http://myendpoint.com", params, responseHandler);
+ * </pre>
+ */
+public class RequestParams {
+    private static String ENCODING = "UTF-8";
+
+    protected ConcurrentHashMap<String, String> urlParams;
+    protected ConcurrentHashMap<String, FileWrapper> fileParams;
+    protected ConcurrentHashMap<String, ArrayList<String>> urlParamsWithArray;
+
+    /**
+     * Constructs a new empty <code>RequestParams</code> instance.
+     */
+    public RequestParams() {
+        init();
+    }
+
+    /**
+     * Constructs a new RequestParams instance containing the key/value
+     * string params from the specified map.
+     * @param source the source key/value string map to add.
+     */
+    public RequestParams(Map<String, String> source) {
+        init();
+
+        for(Map.Entry<String, String> entry : source.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with a single
+     * initial key/value string param.
+     * @param key the key name for the intial param.
+     * @param value the value string for the initial param.
+     */
+    public RequestParams(String key, String value) {
+        init();
+
+        put(key, value);
+    }
+
+    /**
+     * Constructs a new RequestParams instance and populate it with multiple
+     * initial key/value string param.
+     * @param keysAndValues a sequence of keys and values. Objects are
+     * automatically converted to Strings (including the value {@code null}).
+     * @throws IllegalArgumentException if the number of arguments isn't even.
+     */
+    public RequestParams(Object... keysAndValues) {
+      init();
+      int len = keysAndValues.length;
+      if (len % 2 != 0)
+        throw new IllegalArgumentException("Supplied arguments must be even");
+      for (int i = 0; i < len; i += 2) {
+        String key = String.valueOf(keysAndValues[i]);
+        String val = String.valueOf(keysAndValues[i + 1]);
+        put(key, val);
+      }
+    }
+
+    /**
+     * Adds a key/value string pair to the request.
+     * @param key the key name for the new param.
+     * @param value the value string for the new param.
+     */
+    public void put(String key, String value){
+        if(key != null && value != null) {
+            urlParams.put(key, value);
+        }
+    }
+
+    /**
+     * Adds a file to the request.
+     * @param key the key name for the new param.
+     * @param file the file to add.
+     */
+    public void put(String key, File file) throws FileNotFoundException {
+        put(key, new FileInputStream(file), file.getName());
+    }
+
+    /**
+     * Adds param with more than one value.
+     * @param key the key name for the new param.
+     * @param values is the ArrayList with values for the param.
+     */
+    public void put(String key, ArrayList<String> values)  {
+        if(key != null && values != null) {
+            urlParamsWithArray.put(key, values);
+        }
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     */
+    public void put(String key, InputStream stream) {
+        put(key, stream, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     * @param fileName the name of the file.
+     */
+    public void put(String key, InputStream stream, String fileName) {
+        put(key, stream, fileName, null);
+    }
+
+    /**
+     * Adds an input stream to the request.
+     * @param key the key name for the new param.
+     * @param stream the input stream to add.
+     * @param fileName the name of the file.
+     * @param contentType the content type of the file, eg. application/json
+     */
+    public void put(String key, InputStream stream, String fileName, String contentType) {
+        if(key != null && stream != null) {
+            fileParams.put(key, new FileWrapper(stream, fileName, contentType));
+        }
+    }
+
+    /**
+     * Removes a parameter from the request.
+     * @param key the key name for the parameter to remove.
+     */
+    public void remove(String key){
+        urlParams.remove(key);
+        fileParams.remove(key);
+        urlParamsWithArray.remove(key);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append(entry.getValue());
+        }
+
+        for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            result.append(entry.getKey());
+            result.append("=");
+            result.append("FILE");
+        }
+
+        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            if(result.length() > 0)
+                result.append("&");
+
+            ArrayList<String> values = entry.getValue();
+            for (int i = 0; i < values.size(); i++) {
+                if (i != 0)
+                    result.append("&");
+                result.append(entry.getKey());
+                result.append("=");
+                result.append(values.get(i));
+            }
+        }
+
+        return result.toString();
+    }
+
+   /**
+     * Returns an HttpEntity containing all request parameters
+     */
+    public HttpEntity getEntity() {
+        HttpEntity entity = null;
+
+        if(!fileParams.isEmpty()) {
+            SimpleMultipartEntity multipartEntity = new SimpleMultipartEntity();
+
+            // Add string params
+            for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+                multipartEntity.addPart(entry.getKey(), entry.getValue());
+            }
+
+            // Add dupe params
+            for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+                ArrayList<String> values = entry.getValue();
+                for (String value : values) {
+                    multipartEntity.addPart(entry.getKey(), value);
+                }
+            }
+
+            // Add file params
+            int currentIndex = 0;
+            int lastIndex = fileParams.entrySet().size() - 1;
+            for(ConcurrentHashMap.Entry<String, FileWrapper> entry : fileParams.entrySet()) {
+                FileWrapper file = entry.getValue();
+                if(file.inputStream != null) {
+                    boolean isLast = currentIndex == lastIndex;
+                    if(file.contentType != null) {
+                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, file.contentType, isLast);
+                    } else {
+                        multipartEntity.addPart(entry.getKey(), file.getFileName(), file.inputStream, isLast);
+                    }
+                }
+                currentIndex++;
+            }
+
+            entity = multipartEntity;
+        } else {
+            try {
+                entity = new UrlEncodedFormEntity(getParamsList(), ENCODING);
+            } catch (UnsupportedEncodingException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return entity;
+    }
+
+    private void init(){
+        urlParams = new ConcurrentHashMap<String, String>();
+        fileParams = new ConcurrentHashMap<String, FileWrapper>();
+        urlParamsWithArray = new ConcurrentHashMap<String, ArrayList<String>>();
+    }
+
+    protected List<BasicNameValuePair> getParamsList() {
+        List<BasicNameValuePair> lparams = new LinkedList<BasicNameValuePair>();
+
+        for(ConcurrentHashMap.Entry<String, String> entry : urlParams.entrySet()) {
+            lparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
+        }
+
+        for(ConcurrentHashMap.Entry<String, ArrayList<String>> entry : urlParamsWithArray.entrySet()) {
+            ArrayList<String> values = entry.getValue();
+            for (String value : values) {
+                lparams.add(new BasicNameValuePair(entry.getKey(), value));
+            }
+        }
+
+        return lparams;
+    }
+
+    protected String getParamString() {
+        return URLEncodedUtils.format(getParamsList(), ENCODING);
+    }
+
+    private static class FileWrapper {
+        public InputStream inputStream;
+        public String fileName;
+        public String contentType;
+
+        public FileWrapper(InputStream inputStream, String fileName, String contentType) {
+            this.inputStream = inputStream;
+            this.fileName = fileName;
+            this.contentType = contentType;
+        }
+
+        public String getFileName() {
+            if(fileName != null) {
+                return fileName;
+            } else {
+                return "nofilename";
+            }
+        }
+    }
+}
diff --git a/src/com/loopj/android/http/RetryHandler.java b/src/com/loopj/android/http/RetryHandler.java
new file mode 100644
index 00000000..5256aad2
--- /dev/null
+++ b/src/com/loopj/android/http/RetryHandler.java
@@ -0,0 +1,114 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+/*
+    Some of the retry logic in this class is heavily borrowed from the
+    fantastic droid-fu project: https://github.com/donnfelker/droid-fu
+*/
+
+package com.loopj.android.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.HashSet;
+import java.util.Iterator;
+
+import javax.net.ssl.SSLException;
+
+import org.apache.http.NoHttpResponseException;
+import org.apache.http.client.HttpRequestRetryHandler;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import android.os.SystemClock;
+
+class RetryHandler implements HttpRequestRetryHandler {
+    private static final int RETRY_SLEEP_TIME_MILLIS = 1500;
+    private static HashSet<Class<?>> exceptionWhitelist = new HashSet<Class<?>>();
+    private static HashSet<Class<?>> exceptionBlacklist = new HashSet<Class<?>>();
+
+    static {
+        // Retry if the server dropped connection on us
+        exceptionWhitelist.add(NoHttpResponseException.class);
+        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
+        exceptionWhitelist.add(UnknownHostException.class);
+        // retry-this, since it may happens as part of a Wi-Fi to 3G failover
+        exceptionWhitelist.add(SocketException.class);
+
+        // never retry timeouts
+        exceptionBlacklist.add(InterruptedIOException.class);
+        // never retry SSL handshake failures
+        exceptionBlacklist.add(SSLException.class);
+    }
+
+    private final int maxRetries;
+
+    public RetryHandler(int maxRetries) {
+        this.maxRetries = maxRetries;
+    }
+
+    @Override
+    public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
+        boolean retry = true;
+
+        Boolean b = (Boolean) context.getAttribute(ExecutionContext.HTTP_REQ_SENT);
+        boolean sent = (b != null && b.booleanValue());
+
+        if(executionCount > maxRetries) {
+            // Do not retry if over max retry count
+            retry = false;
+        } else if (isInList(exceptionBlacklist, exception)) {
+            // immediately cancel retry if the error is blacklisted
+            retry = false;
+        } else if (isInList(exceptionWhitelist, exception)) {
+            // immediately retry if error is whitelisted
+            retry = true;
+        } else if (!sent) {
+            // for most other errors, retry only if request hasn't been fully sent yet
+            retry = true;
+        }
+
+        if(retry) {
+            // resend all idempotent requests
+            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute( ExecutionContext.HTTP_REQUEST );
+            String requestType = currentReq.getMethod();
+            retry = !requestType.equals("POST");
+        }
+
+        if(retry) {
+            SystemClock.sleep(RETRY_SLEEP_TIME_MILLIS);
+        } else {
+            exception.printStackTrace();
+        }
+
+        return retry;
+    }
+    
+    protected boolean isInList(HashSet<Class<?>> list, Throwable error) {
+    	Iterator<Class<?>> itr = list.iterator();
+    	while (itr.hasNext()) {
+    		if (itr.next().isInstance(error)) {
+    			return true;
+    		}
+    	}
+    	return false;
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SerializableCookie.java b/src/com/loopj/android/http/SerializableCookie.java
new file mode 100644
index 00000000..cc12993c
--- /dev/null
+++ b/src/com/loopj/android/http/SerializableCookie.java
@@ -0,0 +1,74 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+package com.loopj.android.http;
+
+import java.io.Serializable;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.IOException;
+import java.util.Date;
+
+import org.apache.http.cookie.Cookie;
+import org.apache.http.impl.cookie.BasicClientCookie;
+
+/**
+ * A wrapper class around {@link Cookie} and/or {@link BasicClientCookie}
+ * designed for use in {@link PersistentCookieStore}.
+ */
+public class SerializableCookie implements Serializable {
+    private static final long serialVersionUID = 6374381828722046732L;
+
+    private transient final Cookie cookie;
+    private transient BasicClientCookie clientCookie;
+
+    public SerializableCookie(Cookie cookie) {
+        this.cookie = cookie;
+    }
+
+    public Cookie getCookie() {
+        Cookie bestCookie = cookie;
+        if(clientCookie != null) {
+            bestCookie = clientCookie;
+        }
+        return bestCookie;
+    }
+
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        out.writeObject(cookie.getName());
+        out.writeObject(cookie.getValue());
+        out.writeObject(cookie.getComment());
+        out.writeObject(cookie.getDomain());
+        out.writeObject(cookie.getExpiryDate());
+        out.writeObject(cookie.getPath());
+        out.writeInt(cookie.getVersion());
+        out.writeBoolean(cookie.isSecure());
+    }
+
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        String name = (String)in.readObject();
+        String value = (String)in.readObject();
+        clientCookie = new BasicClientCookie(name, value);
+        clientCookie.setComment((String)in.readObject());
+        clientCookie.setDomain((String)in.readObject());
+        clientCookie.setExpiryDate((Date)in.readObject());
+        clientCookie.setPath((String)in.readObject());
+        clientCookie.setVersion(in.readInt());
+        clientCookie.setSecure(in.readBoolean());
+    }
+}
\ No newline at end of file
diff --git a/src/com/loopj/android/http/SimpleMultipartEntity.java b/src/com/loopj/android/http/SimpleMultipartEntity.java
new file mode 100644
index 00000000..3221ec1e
--- /dev/null
+++ b/src/com/loopj/android/http/SimpleMultipartEntity.java
@@ -0,0 +1,196 @@
+/*
+    Android Asynchronous Http Client
+    Copyright (c) 2011 James Smith <james@loopj.com>
+    http://loopj.com
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+*/
+
+/*
+    This code is taken from Rafael Sanches' blog.
+    http://blog.rafaelsanches.com/2011/01/29/upload-using-multipart-post-using-httpclient-in-android/
+*/
+
+package com.loopj.android.http;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Random;
+
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+class SimpleMultipartEntity implements HttpEntity {
+    private final static char[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
+
+    private String boundary = null;
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    boolean isSetLast = false;
+    boolean isSetFirst = false;
+
+    public SimpleMultipartEntity() {
+        final StringBuffer buf = new StringBuffer();
+        final Random rand = new Random();
+        for (int i = 0; i < 30; i++) {
+            buf.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]);
+        }
+        this.boundary = buf.toString();
+
+    }
+
+    public void writeFirstBoundaryIfNeeds(){
+        if(!isSetFirst){
+            writeBoundary();
+        }
+
+        isSetFirst = true;
+    }
+
+    public void writeBoundary() {
+        try {
+            out.write(("--" + boundary + "\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void writeLastBoundaryIfNeeds() {
+        if(isSetLast){
+            return;
+        }
+
+        try {
+            out.write(("--" + boundary + "--\r\n").getBytes());
+            out.flush();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+        
+        isSetLast = true;
+    }
+
+    public void addPart(final String key, final String value, final String contentType) {
+        writeBoundary();
+        try {
+            out.write(("Content-Disposition: form-data; name=\"" +key+"\"\r\n").getBytes());
+            out.write(("Content-Type: " + contentType + "\r\n\r\n").getBytes());
+            out.write(value.getBytes());
+            out.write(("\r\n").getBytes());
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void addPart(final String key, final String value) {
+        addPart(key,value,"text/plain; charset=UTF-8");
+    }
+
+    public void addPart(final String key, final String fileName, final InputStream fin, final boolean isLast){
+        addPart(key, fileName, fin, "application/octet-stream", isLast);
+    }
+
+    public void addPart(final String key, final String fileName, final InputStream fin, String type, final boolean isLast){
+        writeBoundary();
+        try {
+            type = "Content-Type: "+type+"\r\n";
+            out.write(("Content-Disposition: form-data; name=\""+ key+"\"; filename=\"" + fileName + "\"\r\n").getBytes());
+            out.write(type.getBytes());
+            out.write("Content-Transfer-Encoding: binary\r\n\r\n".getBytes());
+
+            final byte[] tmp = new byte[4096];
+            int l = 0;
+            while ((l = fin.read(tmp)) != -1) {
+                out.write(tmp, 0, l);
+            }
+            out.write(("\r\n").getBytes());
+            
+        } catch (final IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                fin.close();
+            } catch (final IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void addPart(final String key, final File value, final boolean isLast) {
+        try {
+            addPart(key, value.getName(), new FileInputStream(value), isLast);
+        } catch (final FileNotFoundException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public long getContentLength() {
+        writeLastBoundaryIfNeeds();
+        return out.toByteArray().length;
+    }
+
+    @Override
+    public Header getContentType() {
+        return new BasicHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    @Override
+    public boolean isRepeatable() {
+        return false;
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return false;
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        writeLastBoundaryIfNeeds();
+        outstream.write(out.toByteArray());
+    }
+
+    @Override
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    @Override
+    public void consumeContent() throws IOException,
+    UnsupportedOperationException {
+        if (isStreaming()) {
+            throw new UnsupportedOperationException(
+            "Streaming entity does not implement #consumeContent()");
+        }
+    }
+
+    @Override
+    public InputStream getContent() throws IOException,
+    UnsupportedOperationException {
+    	writeLastBoundaryIfNeeds();
+        return new ByteArrayInputStream(out.toByteArray());
+    }
+}
\ No newline at end of file
