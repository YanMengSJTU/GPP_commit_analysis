diff --git a/tape/build.gradle b/tape/build.gradle
index e425522..09c852c 100644
--- a/tape/build.gradle
+++ b/tape/build.gradle
@@ -11,6 +11,7 @@ dependencies {
   testCompile 'commons-io:commons-io:2.4'
   testCompile 'com.squareup.burst:burst-junit4:1.1.0'
   testCompile 'com.squareup.okio:okio:1.10.0'
+  compile 'io.reactivex:rxjava:1.1.4'
 }
 
 checkstyle {
diff --git a/tape/src/main/java/com/squareup/tape2/ObservableQueue.java b/tape/src/main/java/com/squareup/tape2/ObservableQueue.java
new file mode 100644
index 0000000..56647bb
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/ObservableQueue.java
@@ -0,0 +1,147 @@
+package com.squareup.tape2;
+
+import rx.Observable;
+import rx.Scheduler;
+import rx.Single;
+import rx.exceptions.Exceptions;
+import rx.functions.Func0;
+import rx.schedulers.Schedulers;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+
+/**
+ *
+ * This class brings two changes over {@link ObjectQueue}.
+ * <ul>
+ * <li>
+ *     Reactive APIs over {@link ObjectQueue}
+ * </li>
+ * <li>
+ *     Every operation is synchronized and posted on queueScheduler thread.
+ * </li>
+ * </ul>
+ *
+ * <p> Closing ObjectQueue is asynchronous and is posted at the end of thread.</p>
+ *
+ * <p>If an operation is posted to queue after the close operation and before close returned, it will fail.</p>
+ * @param <T>
+ */
+final class ObservableQueue<T> {
+
+    private final ObjectQueue<T> objectQueue;
+
+    private final Scheduler queueScheduler = Schedulers.from(Executors.newSingleThreadExecutor());
+
+    public static <T> ObservableQueue<T> createPersistedObservableQueue(
+            final File file,
+            final ObjectQueue.Converter<T> converter) throws IOException {
+        return new ObservableQueue<>(file, converter);
+    }
+
+    public static <T> ObservableQueue<T> createInMemoryObservableQueue() {
+        return new ObservableQueue<>();
+    }
+
+    private ObservableQueue(File file, ObjectQueue.Converter<T> converter) throws IOException {
+        objectQueue = ObjectQueue.create(file, converter);
+    }
+
+    private ObservableQueue() {
+        objectQueue = ObjectQueue.<T>createInMemory();
+    }
+
+    public Single<Boolean> close() {
+        return Single.fromCallable(new Callable<Boolean>() {
+            @Override
+            public Boolean call() {
+                try {
+                    objectQueue.close();
+                    return true;
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<Integer> size() {
+        return Single.defer(new Func0<Single<Integer>>() {
+            @Override
+            public Single<Integer> call() {
+                return Single.just(objectQueue.size());
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<Boolean> add(final T entry) {
+        return Single.fromCallable(new Callable<Boolean>() {
+            @Override
+            public Boolean call() {
+                try {
+                    objectQueue.add(entry);
+                    return true;
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<T> peek() {
+        return Single.defer(new Func0<Single<T>>() {
+            @Override
+            public Single<T> call() {
+                try {
+                    return Single.just(objectQueue.peek());
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<List<T>> peek(final int n) {
+        return Single.defer(new Func0<Single<List<T>>>() {
+            @Override
+            public Single<List<T>> call() {
+                try {
+                    return Single.just(objectQueue.peek(n));
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<Boolean> remove(final int n) {
+        return Single.fromCallable(new Callable<Boolean>() {
+            @Override
+            public Boolean call() {
+                try {
+                    objectQueue.remove(n);
+                    return true;
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+
+    public Single<Boolean> remove() {
+        return Single.fromCallable(new Callable<Boolean>() {
+            @Override
+            public Boolean call() {
+                try {
+                    objectQueue.remove();
+                    return true;
+                } catch (IOException e) {
+                    throw Exceptions.propagate(e);
+                }
+            }
+        }).subscribeOn(queueScheduler);
+    }
+}
diff --git a/tape/src/test/java/com/squareup/tape2/ObservableQueueTest.java b/tape/src/test/java/com/squareup/tape2/ObservableQueueTest.java
new file mode 100644
index 0000000..c7085e6
--- /dev/null
+++ b/tape/src/test/java/com/squareup/tape2/ObservableQueueTest.java
@@ -0,0 +1,81 @@
+package com.squareup.tape2;
+
+import com.squareup.burst.BurstJUnit4;
+import com.squareup.burst.annotation.Burst;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(BurstJUnit4.class)
+public class ObservableQueueTest {
+    public enum QueueFactory {
+        FILE() {
+            @Override public <T> ObservableQueue<T> create(File file, FileObjectQueue.Converter<T> converter)
+                    throws IOException {
+                return ObservableQueue.createPersistedObservableQueue(file, converter);
+            }
+        },
+        MEMORY() {
+            @Override
+            public <T> ObservableQueue<T> create(File file, FileObjectQueue.Converter<T> converter) {
+                return ObservableQueue.createInMemoryObservableQueue();
+            }
+        };
+
+        public abstract <T> ObservableQueue<T> create(File file, FileObjectQueue.Converter<T> converter)
+                throws IOException;
+    }
+
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+    @Burst
+    QueueFactory factory;
+    ObservableQueue<String> queue;
+
+    @Before
+    public void setUp() throws IOException {
+        File parent = folder.getRoot();
+        File file = new File(parent, "object-queue");
+
+        queue = factory.create(file, new StringConverter());
+        queue.add("one").toBlocking().value();
+        queue.add("two").toBlocking().value();
+        queue.add("three").toBlocking().value();
+    }
+
+    @Test
+    public void size() {
+        assertThat(queue.size().toBlocking().value()).isEqualTo(3);
+    }
+
+    @Test public void peek() throws IOException {
+        assertThat(queue.peek().toBlocking().value()).isEqualTo("one");
+    }
+
+    @Test public void peekMultiple() throws IOException {
+        assertThat(queue.peek(2).toBlocking().value()).containsExactly("one", "two");
+    }
+
+    @Test public void peekMaxCanExceedQueueDepth() throws IOException {
+        assertThat(queue.peek(6).toBlocking().value()).containsExactly("one", "two", "three");
+    }
+
+    static class StringConverter implements FileObjectQueue.Converter<String> {
+        @Override public String from(byte[] bytes) throws IOException {
+            return new String(bytes, "UTF-8");
+        }
+
+        @Override public void toStream(String s, OutputStream os) throws IOException {
+            os.write(s.getBytes("UTF-8"));
+        }
+    }
+}
+
