diff --git a/c-tape/queuefile.c b/c-tape/queuefile.c
index 1ccf6e0..3d337fc 100644
--- a/c-tape/queuefile.c
+++ b/c-tape/queuefile.c
@@ -494,43 +494,42 @@ static bool QueueFile_expandIfNecessary(QueueFile* qf, uint32_t dataLength) {
     return false;
   }
 
-  // Calculate the position of the tail end of the data in the ring buffer
-  bool wasEmpty = QueueFile_isEmpty(qf);
-  if(!wasEmpty) {
-      uint32_t endOfLastElement = QueueFile_wrapPosition(qf, qf->last->position +
-                                                         Element_HEADER_LENGTH +
-                                                         qf->last->length);
-
-      // If the buffer is split, we need to make it contiguous, so append the
-      // tail of the queue to after the end of the old file.
-      if (endOfLastElement < qf->first->position) {
-        uint32_t count = endOfLastElement - Element_HEADER_LENGTH;
-        if (!FileIo_transferTo(qf->file, QueueFile_HEADER_LENGTH,
-                              qf->fileLength, count)) {
-          return false;
-        }
-      }
-
-
-      // Commit the expansion.
-      if (qf->last->position < qf->first->position) {
-        uint32_t newLastPosition = qf->fileLength + qf->last->position -
-                                   QueueFile_HEADER_LENGTH;
-        if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
-                                   qf->first->position, newLastPosition)) {
-          return false;
-        }
-        if (!freeAndAssignNonNull(&qf->last,
-                                 Element_new(newLastPosition, qf->last->length))) {
-          return false;
-        }
-      } else {
-        if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
-                                  qf->first->position, qf->last->position)) {
-          return false;
-        }
-      }
+  if (!QueueFile_isEmpty(qf)) {
+	  // Calculate the position of the tail end of the data in the ring buffer
+	  uint32_t endOfLastElement = QueueFile_wrapPosition(qf, qf->last->position +
+	                                                     Element_HEADER_LENGTH +
+	                                                     qf->last->length);
+
+	  // If the buffer is split, we need to make it contiguous, so append the
+	  // tail of the queue to after the end of the old file.
+	  if (endOfLastElement < qf->first->position) {
+	    uint32_t count = endOfLastElement - Element_HEADER_LENGTH;
+	    if (!FileIo_transferTo(qf->file, QueueFile_HEADER_LENGTH,
+	                          qf->fileLength, count)) {
+	      return false;
+	    }
+	  }
+
+	  // Commit the expansion.
+	  if (qf->last->position < qf->first->position) {
+	    uint32_t newLastPosition = qf->fileLength + qf->last->position -
+	                               QueueFile_HEADER_LENGTH;
+	    if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
+	                               qf->first->position, newLastPosition)) {
+	      return false;
+	    }
+	    if (!freeAndAssignNonNull(&qf->last,
+	                             Element_new(newLastPosition, qf->last->length))) {
+	      return false;
+	    }
+	  } else {
+	    if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
+	                              qf->first->position, qf->last->position)) {
+	      return false;
+	    }
+	  }
   }
+
   qf->fileLength = newLength;
   return true;
 }
