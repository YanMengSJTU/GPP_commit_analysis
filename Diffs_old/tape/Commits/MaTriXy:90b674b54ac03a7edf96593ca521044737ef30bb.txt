diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index a96fb32..97776ba 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -21,6 +21,6 @@ elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  ./gradlew uploadArchives
   echo "Snapshot deployed!"
 fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
deleted file mode 100644
index 91f444b..0000000
--- a/.buildscript/settings.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
-</settings>
diff --git a/.gitignore b/.gitignore
index 133735f..68183bb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,22 +1,12 @@
-.classpath
-.project
-.settings
-eclipsebin
-
-bin
-gen
-build
-out
-lib
-
-target
-pom.xml.*
-release.properties
-
+# IntelliJ
 .idea
 *.iml
-classes
-
-obj
 
+# OS X
 .DS_Store
+
+# Gradle
+.gradle
+build
+local.properties
+reports
diff --git a/.travis.yml b/.travis.yml
index ce88ca8..3ceb134 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,14 +1,6 @@
-language: android
-
-android:
-  components:
-    - build-tools-20.0.0
-    - android-16
-  licenses:
-    - android-sdk-license-5be876d5
+language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
 after_success:
@@ -16,8 +8,8 @@ after_success:
 
 env:
   global:
-    - secure: "gPnO4rMnW2zFPsx5ROwM1+8+r+fsm2z0n477RMcN+2xWu5QrmfKcdPBj7QFBfWDkwIi/EdASEcID6MzFXPwcU21io18NKt9OMgpuzGyUf2W5oVJN/jYIlC5vPXFeGfsH2Eh3ZMhztSH2ADN9lPAxvThY//FhEMj+MH/z8zVljHA="
-    - secure: "A4Lps6F7ZcHHQT1zWbdrzp58uho2NcMYsAxB9D/Bbmxwm1uHJ/N8BN2rQilmsu46PzSN9WngKpK04mPn8hTXQPMcnymmM0p4aWQqmwfRDe4QLn1baXkjXUDrdAprRwVEJ2RF2cZXBn64zCtHVRD+TA36FSAx+on/JYDVceKu03Y="
+    - secure: "ClEdIniNlok5b6YUdD/en7FnsV/X+41NTisd7XWJvzta+Q5llF30VcVobDvMfrlTsqugl3epMSmgOO+8fisw/sV1DCt7J7UHQfVj+ZDPqhWubDFWc6KzvRDp4VOLNE9B/mLOe7bPC/I5NwGAqECsPSu+EV/Zf7ERL+1ewh8kzxY="
+    - secure: "Q6cjZvLjk77JjYD1F9cGMCWSka2GwlHpefvT8pxG2Se5e4Pr/qyVhS9Z5mIgRqZ16KuweTV/xsixFHrha3gzEAwa1hkOw6kvzR4z9dx0XmpvORuo1h4Ag0LCxAR70ZueGyStqpaXoFmTWB1z0WWwooAd0kgDwMDSOcH60Pv4mew="
 
 branches:
   except:
@@ -27,7 +19,3 @@ notifications:
   email: false
 
 sudo: false
-
-cache:
-  directories:
-    - $HOME/.m2
diff --git a/README.md b/README.md
index 79797f9..36ed5f6 100644
--- a/README.md
+++ b/README.md
@@ -9,15 +9,14 @@ synchronous; data will be written to disk before an operation returns. The
 underlying file is structured to survive process and even system crashes and if
 an I/O exception is thrown during a mutating change, the change is aborted.
 
+**NOTE:** The current implementation is built for file systems that support
+atomic segment writes (like YAFFS). Most conventional file systems don't support
+this; if the power goes out while writing a segment, the segment will contain
+garbage and the file will be corrupt.
+
 An `ObjectQueue` represents an ordering of arbitrary objects which can be backed
 either by the filesystem (via `QueueFile`) or in memory only.
 
-`TaskQueue` is a special object queue which holds `Task`s, objects which have a
-notion of being executed. Instances are managed by an external executor which
-prepares and executes enqueued tasks.
-
-*Some examples are available on [the website][1].*
-
 
 
 Download
@@ -26,20 +25,146 @@ Download
 Download [the latest JAR][2] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup</groupId>
+  <groupId>com.squareup.tape2</groupId>
   <artifactId>tape</artifactId>
-  <version>1.2.3</version>
+  <version>2.0.0-SNAPSHOT</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup:tape:1.2.3'
+compile 'com.squareup.tape2:tape:2.0.0-SNAPSHOT'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
+Usage
+-----
+
+Create a `QueueFile` instance.
+
+```java
+File file = // ...
+QueueFile queueFile = new QueueFile.Builder(file).build();
+```
+
+Add some data to the queue to the end of the queue. `QueueFile` accepts a `byte[]` of arbitrary length.
+
+```java
+queueFile.add("data".getBytes());
+```
+
+Read data at the head of the queue.
+
+```java
+byte[] data = queueFile.peek();
+```
+
+Remove processed elements.
+
+```java
+// Remove the eldest element.
+queueFile.remove();
+
+// Remove multiple elements.
+queueFile.remove(n);
+
+// Remove all elements.
+queueFile.clear();
+```
+
+Read and process multiple elements with the iterator API.
+
+```java
+Iterator<byte[]> iterator = queueFile.iterator();
+while (iterator.hasNext()) {
+  byte[] element = iterator.next();
+  process(element);
+  iterator.remove();
+}
+```
+
+While `QueueFile` works with `byte[]`, `ObjectQueue` works with arbitrary Java objects with a similar API. An `ObjectQueue` may be backed by a persistent `QueueFile`, or in memory. A persistent `ObjectQueue` requires a [`Converter`](#converter) to encode and decode objects.
+
+```java
+// A persistent ObjectQueue.
+ObjectQueue<String> queue = ObjectQueue.create(queueFile, converter);
+
+// An in-memory ObjectQueue.
+ObjectQueue<String> queue = ObjectQueue.createInMemory();
+```
+
+Add some data to the queue to the end of the queue.
+
+```java
+queue.add("data");
+```
+
+Read data at the head of the queue.
+
+```java
+// Peek the eldest elements.
+String data = queue.peek();
+
+// Peek the eldest `n` elements.
+List<String> data = queue.peek(n);
+
+// Peek all elements.
+List<String> data = queue.asList();
+```
+
+Remove processed elements.
+
+```java
+// Remove the eldest element.
+queue.remove();
+
+// Remove multiple elements.
+queue.remove(n);
+
+// Remove all elements.
+queue.clear();
+```
+
+Read and process multiple elements with the iterator API.
+
+```java
+Iterator<String> iterator = queue.iterator();
+while (iterator.hasNext()) {
+  String element = iterator.next();
+  process(element);
+  iterator.remove();
+}
+```
+
+
+
+Converter
+---------
+
+A `Converter` encodes objects to bytes and decodes objects from bytes.
+
+```java
+/** Converter which uses Moshi to serialize instances of class T to disk. */
+class MoshiConverter<T> implements Converter<T> {
+  private final JsonAdapter<T> jsonAdapter;
+
+  public MoshiConverter(Moshi moshi, Class<T> type) {
+    this.jsonAdapter = moshi.adapter(type);
+  }
+
+  @Override public String from(byte[] bytes) throws IOException {
+    return jsonAdapter.fromJson(new Buffer().write(bytes));
+  }
+
+  @Override public void toStream(T o, OutputStream os) throws IOException {
+    return jsonAdapter.toJson(Okio.buffer(Okio.sink(os)), val);
+  }
+}
+```
+
+
 License
 -------
 
diff --git a/RELEASING.md b/RELEASING.md
new file mode 100644
index 0000000..87290eb
--- /dev/null
+++ b/RELEASING.md
@@ -0,0 +1,16 @@
+Releasing
+========
+
+ 1. Change the version in `gradle.properties` to a non-SNAPSHOT verson.
+ 2. Update the `CHANGELOG.md` for the impending release.
+ 3. Update the `README.md` with the new version.
+ 4. `git commit -am "Prepare for release X.Y.Z."` (where X.Y.Z is the new version)
+ 5. `./gradlew clean uploadArchives`.
+ 6. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
+ 7. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
+ 8. Update the `gradle.properties` to the next SNAPSHOT version.
+ 9. `git commit -am "Prepare next development version."`
+ 10. `git push && git push --tags`
+ 11. Update the two sample modules to point to the newly released version.
+
+If step 5 or 6 fails, drop the Sonatype repo, fix the problem, commit, and start again at step 5.
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..ba658dc
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,24 @@
+buildscript {
+  dependencies {
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.8'
+  }
+
+  repositories {
+    maven { url 'https://plugins.gradle.org/m2/' }
+  }
+}
+
+subprojects { project ->
+  group = GROUP
+  version = VERSION_NAME
+
+  repositories {
+    mavenCentral()
+  }
+
+  tasks.withType(JavaCompile) {
+    options.compilerArgs += ['-Xlint:all', '-Xlint:-path', '-Werror']
+  }
+
+  apply plugin: 'net.ltgt.errorprone'
+}
diff --git a/c-tape/.gitignore b/c-tape/.gitignore
deleted file mode 100644
index dcd3cfd..0000000
--- a/c-tape/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-Debug/*
-Release/*
-test.queue
-*.o
-*.d
-.cproject
diff --git a/c-tape/Makefile b/c-tape/Makefile
deleted file mode 100644
index 82f5d83..0000000
--- a/c-tape/Makefile
+++ /dev/null
@@ -1,31 +0,0 @@
-
-SRCS=$(wildcard *.c)
-OBJS=$(SRCS:.c=.o)
-DEPS=$(SRCS:.c=.d)
-
-TEST_SRCS=$(wildcard tests/*.c)
-TEST_OBJS=$(TEST_SRCS:.c=.o)
-TEST_DEPS=$(TEST_SRCS:.c=.d)
-
-OPT_FLAGS=-O3
-
-all: c-tape
-
-debug: OPT_FLAGS=-ggdb
-debug: all
-
-
-c-tape: $(OBJS) $(TEST_OBJS)
-	@echo 'Building target: $@'
-	gcc  -o "c-tape" $(OBJS) $(TEST_OBJS)
-	@echo 'Finished building target: $@'
-	@echo ' '
-
-%.o: %.c
-	@echo 'Building file: $@'
-	gcc $(OPT_FLAGS) -Wall -Wextra -Werror -Wconversion -c -fmessage-length=0 -Wno-unused-function -MMD -MP -MF"$(@:%.o=%.d)" -MT"$(@:%.o=%.d)" -o "$@" "$<"
-	@echo 'Finished building: $@'
-	@echo ' '
-
-clean:
-	rm -rf $(OBJS) $(DEPS) $(TEST_OBJS) $(TEST_DEPS) "c-tape"
\ No newline at end of file
diff --git a/c-tape/fileio.c b/c-tape/fileio.c
deleted file mode 100644
index 51326fb..0000000
--- a/c-tape/fileio.c
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-
-#ifdef HAS_SENDFILE
-#include <sys/sendfile.h>
-#endif // HAS_SENDFILE
-
-#include <sys/stat.h>
-#include <unistd.h> // for fsync()
-
-#include "fileio.h"
-#include "logutil.h"
-#include "types.h"
-
-// copy buffer is on stack, use a variable s.t. we can override value in tests.
-static uint32_t copyBufferSize = 4096;
-
-// sanity limit of 2GB
-#define FILE_HARD_SANITY_LIMIT ((uint32_t)(1<<31))
-
-static bool for_testing_failAllWrites = false;
-
-/**
- * File utility primitives somewhat patterned on RandomAccessFile.
- */
-
-bool FileIo_seek(FILE* file, uint32_t position) {
-  if (position > FILE_HARD_SANITY_LIMIT) {
-    LOG(LFATAL, "Requested seek (%d) exceeds sanity hard limit %d", position,
-        FILE_HARD_SANITY_LIMIT);
-    return false;
-  }
-
-  if (fseek(file, (long)position, SEEK_SET) < 0) {
-    LOG(LWARN, "Error setting file position to %d. fhandle %d", position,
-        fileno(file));
-    return false;
-  }
-  return true;
-}
-
-bool FileIo_write(FILE* file, const byte* buffer, uint32_t buffer_offset,
-                  uint32_t length) {
-  if (for_testing_failAllWrites) {
-    LOG(LDEBUG, "Failing write as requested. see for_testing_failAllWrites");
-    return false;
-  }
-  if (length > FILE_HARD_SANITY_LIMIT || buffer_offset > FILE_HARD_SANITY_LIMIT) {
-    LOG(LFATAL, "Requested file write %d or offset %d exceeds sanity hard limit %d",
-        length, buffer_offset, FILE_HARD_SANITY_LIMIT);
-    return false;
-  }
-  if (fwrite(buffer + buffer_offset, (size_t) 1, (size_t) length, file) != length) {
-    LOG(LWARN, "Error writing data, fhandle %d", fileno(file));
-    return false;
-  }
-  if (fflush(file) != 0 || fsync(fileno(file)) != 0) {
-    LOG(LWARN, "Error flushing file, fhandle %d", fileno(file));
-    return false;
-  }
-  return true;
-}
-
-bool FileIo_read(FILE* file, void* buffer, uint32_t buffer_offset,
-                 uint32_t length) {
-  if (length > FILE_HARD_SANITY_LIMIT) {
-    LOG(LFATAL, "Requested seek (%d) exceeds sanity hard limit %d", length,
-        FILE_HARD_SANITY_LIMIT);
-    return false;
-  }
-  if (fread(buffer + buffer_offset, (size_t) 1, (size_t) length, file) != length) {
-    LOG(LWARN, "Error reading element from fhandle %d", fileno(file));
-    return false;
-  }
-  return true;
-}
-
-off_t FileIo_getLength(FILE* file) {
-  struct stat filestat;
-  if (fstat(fileno(file), &filestat) != 0) {
-    LOG(LWARN, "Error getting file stat. fhandle %d", fileno(file));
-    return -1;
-  }
-  return filestat.st_size;
-}
-
-bool FileIo_writeZeros(FILE* file, uint32_t length) {
-  if (for_testing_failAllWrites) {
-    LOG(LDEBUG, "Failing write as requested. see for_testing_failAllWrites");
-    return false;
-  }
-
-  // Length must be multiple of 4.
-  if (length % sizeof(uint32_t) != 0) {
-    LOG(LFATAL, "Initial file length must be multiple of 4 bytes, got %d",
-        length);
-    return false;
-  }
-
-  byte buf[] = {0,0,0,0};
-  uint32_t c;
-  for (c = 0; c <= length / 4; c++) {
-    if (fwrite(buf, sizeof(buf), (size_t)1, file) != 1) {
-      return false;
-    }
-  }
-
-  if (fflush(file) != 0 || fsync(fileno(file)) != 0) {
-    LOG(LWARN, "Error flushing file, fhandle %d", fileno(file));
-    return false;
-  }
-  return true;
-}
-
-bool FileIo_setLength(FILE* file, uint32_t length) {
-  // Some systems allow the file length to be adjusted using truncate, as
-  // some JVMs do.
-  
-  if (for_testing_failAllWrites) {
-    LOG(LDEBUG, "Failing write as requested. see for_testing_failAllWrites");
-    return false;
-  }
-
-  if (length > FILE_HARD_SANITY_LIMIT) {
-    LOG(LFATAL, "Requested file size (%d) exceeds sanity hard limit %d", length,
-        FILE_HARD_SANITY_LIMIT);
-    return false;
-  }
-  if (ftruncate(fileno(file), (off_t)length) != 0 || fsync(fileno(file)) != 0) {
-    LOG(LWARN, "Error setting file length to %d, fhandle %d", length,
-        fileno(file));
-    return false;
-  }
-  return true;
-}
-
-
-bool FileIo_transferTo(FILE* file, uint32_t source, uint32_t destination,
-                       uint32_t length) {
-  // TODO(jochen): if needed, overlap handling to be more accommodating.
-  // TODO(jochen): investigate whether fread and fwrite make efficient use of
-  //               buffering in the FILE handling code.
-
-  if (for_testing_failAllWrites) {
-    LOG(LDEBUG, "Failing write as requested. see for_testing_failAllWrites");
-    return false;
-  }
-
-#ifdef HAS_SENDFILE
-
-  if (!FileIo_seek(file, source)) return false;
-  ssize_t wrote = sendfile(fileno(file), fileno(file), NULL, (size_t) length);
-  if (wrote == -1 || wrote != (size_t) length) {
-    LOG(LWARN, "Error in sendfile. src=%d dest=%d len=%d (%d), fhandle %d",
-        source, destination, length, read, fileno(file));
-    return false;
-  }
-
-#else
-
-  if ((destination > source && source + length > destination) ||
-      (destination < source && destination + length > source)){
-    LOG(LWARN, "Can't transfer between overlapping parts of file. "
-        "src=%d dest=%d len=%d, fhandle %d",
-        source, destination, length, fileno(file));
-    return false;
-  }
-  byte buffer[copyBufferSize];
-
-  while (length > 0) {
-    if (!FileIo_seek(file, source)) return false;
-
-    uint32_t copylen = length < copyBufferSize ? length : copyBufferSize;
-    size_t read = fread(buffer, (size_t) 1, (size_t) copylen, file);
-    if (read < copylen) {
-      LOG(LWARN, "Error reading file, src=%d dest=%d len=%d (%d), fhandle %d",
-          source, destination, length, copylen, fileno(file));
-      return false;
-    }
-    if (!FileIo_seek(file, destination)) return false;
-    size_t wrote = fwrite(buffer, (size_t) 1, read, file);
-    if (wrote < read) {
-      LOG(LWARN, "Error writing file, src=%d dest=%d len=%d (%d), fhandle %d",
-          source, destination, length, read, fileno(file));
-      return false;
-    }
-    length -= wrote;
-    source += wrote;
-    destination += wrote;
-  }
-  if (fflush(file) != 0 || fsync(fileno(file)) != 0) {
-    LOG(LWARN, "Error flushing file, fhandle %d", fileno(file));
-    return false;
-  }
-  
-#endif // HAS_SENDFILE
-  
-  return true;
-}
-
-void _for_testing_FileIo_failAllWrites(int fail) {
-  for_testing_failAllWrites = fail;
-}
-
-uint32_t _for_testing_setTransferToCopyBufferSize(uint32_t newSize) {
-  uint32_t old = copyBufferSize;
-  copyBufferSize = newSize;
-  return old;
-}
diff --git a/c-tape/fileio.h b/c-tape/fileio.h
deleted file mode 100644
index 5ea89b4..0000000
--- a/c-tape/fileio.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef FILEIO_H_
-#define FILEIO_H_
-
-#include"types.h"
-
-/**
- * File utility primitives somewhat patterned on RandomAccessFile.
- */
-
-/** Moves the file pointer to given position */
-bool FileIo_seek(FILE* file, uint32_t position);
-
-/** Writes buffer to file, flushes to media. */
-bool FileIo_write(FILE* file, const byte* buffer, uint32_t buffer_offset,
-                  uint32_t length);
-
-bool FileIo_read(FILE* file, void* buffer, uint32_t buffer_offset,
-                 uint32_t length);
-
-/** @return file length or -1 on error */
-off_t FileIo_getLength(FILE* file);
-
-/**
-  * Writes length 0s to file, flushes to media. Starts at current file position.
-  * @param length must be multiple of 4.
-  */
-bool FileIo_writeZeros(FILE* file, uint32_t length);
-
-/**
- * Sets the file length.
- * (Some systems allow the file length to be adjusted using truncate, as
- * some JVMs do for RandomAccessFile.setLength.
- * TODO(jochen): test this for iOS and Android).
- */
-bool FileIo_setLength(FILE* file, uint32_t length);
-
-/**
- * Copies part of a file to another offset, the caller is responsible for
- * checking that there is enough data from the source to cover length.
- * The parts to transfer may not overlap.
- * TODO: investigate whether fread and fwrite make efficient use of the
- *       FILE's read cache.
- */
-bool FileIo_transferTo(FILE* file, uint32_t source, uint32_t destination,
-                       uint32_t length);
-
-/**
- * For testing only, enable or disable writes, for some reason the _Bool
- * macro expansion causes warnings? when called with a bool??
- */
-void _for_testing_FileIo_failAllWrites(int fail);
-
-/**
- * For testing only, set the size of the copy buffer for the transferTo function.
- * returns the old size.
- */
-uint32_t _for_testing_setTransferToCopyBufferSize(uint32_t newSize);
-
-#endif
diff --git a/c-tape/logutil.c b/c-tape/logutil.c
deleted file mode 100644
index 8100177..0000000
--- a/c-tape/logutil.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <execinfo.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "logutil.h"
-
-static enum loglevel currentloglevel = _LOGLEVEL_WARN;
-static enum loglevel currentDebugFailloglevel = 9999;
-
-
-void _log_setlevel(enum loglevel ll) {
-  currentloglevel = ll;
-}
-
-void _log_debug_failatlevel(enum loglevel ll) {
-  currentDebugFailloglevel = ll;
-}
-
-static void printStackTrace();
-
-int _log_vprintf(enum loglevel level, char* file, int line, char* msg, ...) {
-  if (currentloglevel <= level) {
-    va_list args;
-    va_start (args, msg);
-    fprintf (stdout, "%s:%d [%d] ", file, line, level);
-    vfprintf (stdout, msg, args);
-    fprintf (stdout, "\n");
-    va_end (args);
-
-    if (currentloglevel >= currentDebugFailloglevel) {
-      fprintf(stdout, "*** quitting, logged above debug fail level, see LOG_SETDEBUGFAILLEVEL_WARN or LOG_SETDEBUGFAILLEVEL_FATAL\n");
-      printStackTrace();
-      abort();
-    }
-    return 1;
-  }
-  return 0;
-}
-
-static void printStackTrace() {
-  void* addrlist[100];
-  int addrlen = backtrace(addrlist, (int)(sizeof(addrlist) / sizeof(void*)));
-  if (addrlen == 0) {
-    fprintf(stderr, "\n" );
-    return;
-  }
-  char** symbols = backtrace_symbols(addrlist, addrlen);
-  int i;
-  for (i = 1; i < addrlen; i++ )
-    fprintf(stderr, "%s\n", symbols[i]);
-  free(symbols);
-}
diff --git a/c-tape/logutil.h b/c-tape/logutil.h
deleted file mode 100644
index cd24131..0000000
--- a/c-tape/logutil.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef LOGUTIL_H_
-#define LOGUTIL_H_
-
-/*
- * Bare bones logging tool.
- *
- * Usage example:
- *
- *   LOG(LINFO, "This prints to a logfile, hello %s, this is a number: %d", name, value);
- *   LOG_SETLEVEL_WARN;
- *   LOG(LFATAL, "This prints to a logfile, hello %s, this is a number: %d", name, value);
- *
- * TODO(jochen): consider using log4c.
- */
-
-#define LOG _log_vprintf
-
-// TODO(jochen): use varidic macros.
-#define LDEBUG _LOGLEVEL_DEBUG, __FILE__, __LINE__
-#define LINFO _LOGLEVEL_INFO, __FILE__, __LINE__
-#define LWARN _LOGLEVEL_WARN, __FILE__, __LINE__
-#define LFATAL _LOGLEVEL_FATAL, __FILE__, __LINE__
-
-#define LOG_SETLEVEL_DEBUG _log_setlevel(_LOGLEVEL_DEBUG)
-#define LOG_SETLEVEL_INFO _log_setlevel(_LOGLEVEL_INFO)
-#define LOG_SETLEVEL_WARN _log_setlevel(_LOGLEVEL_WARN)
-#define LOG_SETLEVEL_FATAL _log_setlevel(_LOGLEVEL_FATAL)
-
-
-/** Used for debug builds, will fail program with stack trace */
-#define LOG_SETDEBUGFAILLEVEL_WARN _log_debug_failatlevel(_LOGLEVEL_WARN)
-/** Used for debug builds, will fail program with stack trace */
-#define LOG_SETDEBUGFAILLEVEL_FATAL _log_debug_failatlevel(_LOGLEVEL_FATAL)
-
-enum loglevel {
-  _LOGLEVEL_DEBUG = 0, _LOGLEVEL_INFO, _LOGLEVEL_WARN, _LOGLEVEL_FATAL
-};
-
-void _log_setlevel(enum loglevel);
-void _log_debug_failatlevel(enum loglevel);
-
-/** returns 1 if something was printed, else 0 */
-int _log_vprintf(enum loglevel, char* file, int line, char* msg, ...);
-
-#endif
diff --git a/c-tape/queuefile.c b/c-tape/queuefile.c
deleted file mode 100644
index 4e1a44d..0000000
--- a/c-tape/queuefile.c
+++ /dev/null
@@ -1,787 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <pthread.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "fileio.h"
-#include "logutil.h"
-#include "queuefile.h"
-
-/*
- * Port of Tape project from Java. https://github.com/square/tape
- *
- * Integers are forced to be 32-bit, maximum file size supported is 2^32 (4GB).
- *
- * See description in queuefile.h.
- */
-
-/** frees if oldPointer is not NULL, assigns newPointer. */
-#define freeAndAssign(OLD, NEW) _freeAndAssign((void**)(OLD), (void*)(NEW))
-static bool _freeAndAssign(void** oldPointer, void* newPointer);
-
-/** frees and assigns oldPointer IFF newPointer is not NULL. */
-#define freeAndAssignNonNull(OLD, NEW) _freeAndAssignNonNull((void**)(OLD), (void*)(NEW))
-static bool _freeAndAssignNonNull(void** oldPointer, void* newPointer);
-
-// Use macro to maintain line number
-#define NULLARG(P) ((P) == NULL ? LOG(LWARN, "Null argument passed") || 1 : 0)
-#define CHECKOOM(P) ((P) == NULL ? LOG(LWARN, "Out of memory") || 1 : 0)
-
-// For sanity tests
-#define MAX_FILENAME_LEN 4096
-
-// ------------------------------ Element -----------------------------------
-
-
-#define Element_HEADER_LENGTH 4
-
-/** A pointer to an element. */
-typedef struct {
-  /** Position in file. */
-  uint32_t position;
-  /** The length of the data. */
-  uint32_t length;
-} Element;
-
-/**
- * Constructs a new element.
- *
- * @param position within file
- * @param length   of data
- */
-static Element* Element_new(uint32_t position, uint32_t length) {
-  Element* e = malloc(sizeof(Element));
-  if (CHECKOOM(e)) return NULL;
-  e->position = position;
-  e->length = length;
-  return e;
-}
-
-static void Element_fprintf(Element* e, FILE* fout) {
-  fprintf(fout, "Element:[position = %d, length = %d]",
-          e->position, e->length);
-}
-
-
-// ------------------------------ QueueFile -----------------------------------
-
-
-/** Initial file size in bytes. */
-#define QueueFile_INITIAL_LENGTH 4096 // one file system block
-
-/** Length of header in bytes. */
-#define QueueFile_HEADER_LENGTH 16 // May not be shorter than 16 bytes.
-
-struct _QueueFile {
-  
-  /**
-   * The underlying file. Uses a ring buffer to store entries. Designed so that
-   * a modification isn't committed or visible until we write the header. The
-   * header is much smaller than a segment. So long as the underlying file
-   * system supports atomic segment writes, changes to the queue are atomic.
-   * Storing the file length ensures we can recover from a failed expansion
-   * (i.e. if setting the file length succeeds but the process dies before the
-   * data can be copied).
-   *
-   *   Format:
-   *     Header              (16 bytes)
-   *     Element Ring Buffer (File Length - 16 bytes)
-   *
-   *   Header:
-   *     File Length            (4 bytes)
-   *     Element Count          (4 bytes)
-   *     First Element Position (4 bytes, =0 if null)
-   *     Last Element Position  (4 bytes, =0 if null)
-   *
-   *   Element:
-   *     Length (4 bytes)
-   *     Data   (Length bytes)
-   */
-  FILE* file;
-  
-  /** Cached file length. Always a power of 2. */
-  uint32_t fileLength;
-  
-  /** Number of elements. */
-  uint32_t elementCount;
-  
-  /** Pointer to first (or eldest) element. */
-  Element* first;
-  
-  /** Pointer to last (or newest) element. */
-  Element* last;
-  
-  /** In-memory buffer. Big enough to hold the header. */
-  byte buffer[QueueFile_HEADER_LENGTH];
-
-  /** mutex to synchronize method access */
-  pthread_mutex_t mutex;
-};
-
-static bool initialize(char* filename);
-static bool QueueFile_readHeader(QueueFile* qf);
-
-// see description in queuefile.h.
-QueueFile* QueueFile_new(char* filename) {
-  if (NULLARG(filename)) return NULL;
-  QueueFile* qf = malloc(sizeof(QueueFile));
-  if (CHECKOOM(qf)) return NULL;
-  memset(qf, 0, sizeof(QueueFile)); // making sure pointers & counters are null!
-  
-  qf->file = fopen(filename, "r+");
-  if (qf->file == NULL) {
-    if (initialize(filename)) {
-      qf->file = fopen(filename, "r+");
-    }
-    if (qf->file == NULL) {
-      free(qf);
-      return NULL;
-    }
-  }
-  if (!QueueFile_readHeader(qf)) {
-    fclose(qf->file);
-    free(qf);
-    return NULL;
-  }
-
-  // TODO(jochen): consider NP mutex options, audit code for re-entrancy and
-  //    eliminate recursive option if needed.
-  // NOTE: there was a problem with static initializers on OSX
-  //    http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51906
-  pthread_mutexattr_t mta;
-  pthread_mutexattr_init(&mta);
-  pthread_mutexattr_settype(&mta, PTHREAD_MUTEX_RECURSIVE);
-  pthread_mutex_init(&qf->mutex, &mta);
-
-  return qf;
-}
-
-// see description in queuefile.h.
-bool QueueFile_closeAndFree(QueueFile* qf) {
-  pthread_mutex_lock(&qf->mutex);
-  bool success = !fclose(qf->file);
-  if (success) {
-    if (qf != NULL) {
-      if (qf->first != NULL) {
-        free(qf->first);
-      }
-      if (qf->last != NULL && qf->last != qf->first) free(qf->last);
-      qf->first = qf->last = NULL;
-    }
-  }
-  pthread_mutex_unlock(&qf->mutex);
-
-  if (success)
-    free(qf);
-
-  return success;
-}
-
-/**
- * Stores unsigned int in buffer (big endian).
- */
-static void writeInt(byte* buffer, uint32_t offset, uint32_t value) {
-  buffer[offset] = (byte) (value >> 24);
-  buffer[offset + 1] = (byte) (value >> 16);
-  buffer[offset + 2] = (byte) (value >> 8);
-  buffer[offset + 3] = (byte) value;
-}
-
-/**
- * Stores unsigned ints into a buffer, in the order of parameters passed.
- */
-static void writeInts(byte* buffer, uint32_t v1, uint32_t v2, uint32_t v3,
-                      uint32_t v4) {
-  writeInt(buffer, 0, v1);
-  writeInt(buffer, 4, v2);
-  writeInt(buffer, 8, v3);
-  writeInt(buffer, 12, v4);
-}
-
-/** Reads an unsigned int from a buffer (assumes big endian). */
-static uint32_t readInt(byte* buffer, uint32_t offset) {
-  return ((buffer[offset] & 0xff) << 24)
-         + ((buffer[offset + 1] & 0xff) << 16)
-         + ((buffer[offset + 2] & 0xff) << 8)
-         + (buffer[offset + 3] & 0xff);
-}
-
-
-
-static Element* QueueFile_readElement(QueueFile* qf, uint32_t position);
-
-/** Reads the header. */
-static bool QueueFile_readHeader(QueueFile* qf) {
-  if (!FileIo_seek(qf->file, 0) ||
-      !FileIo_read(qf->file, qf->buffer, 0, (uint32_t) sizeof(qf->buffer))) {
-    return false;
-  }
-
-  qf->fileLength = readInt(qf->buffer, 0);
-  uint32_t actualLength = (uint32_t) FileIo_getLength(qf->file);
-  if (qf->fileLength > actualLength) {
-    LOG(LWARN, "File is truncated. Expected length: %d, Actual length: %d",
-        qf->fileLength,  actualLength);
-    return false;
-  }
-
-  qf->elementCount = readInt(qf->buffer, 4);
-  uint32_t firstOffset = readInt(qf->buffer, 8);
-  uint32_t lastOffset = readInt(qf->buffer, 12);
-  return freeAndAssign(&qf->first, QueueFile_readElement(qf, firstOffset)) &&
-         freeAndAssign(&qf->last, QueueFile_readElement(qf, lastOffset));
-}
-
-/**
- * Writes header atomically. The arguments contain the updated values. The
- * class member fields should not have changed yet. This only updates the
- * state in the file. It's up to the caller to update the class member
- * variables *after* this call succeeds. Assumes segment writes are atomic in
- * the underlying file system.
- */
-static bool QueueFile_writeHeader(QueueFile* qf, uint32_t fileLength,
-                                  uint32_t elementCount, uint32_t firstPosition,
-                                  uint32_t lastPosition) {
-  writeInts(qf->buffer, fileLength, elementCount, firstPosition, lastPosition);
-  return FileIo_seek(qf->file, 0) &&
-         FileIo_write(qf->file, qf->buffer, 0, QueueFile_HEADER_LENGTH);
-}
-
-
-/** 
- * Returns the Element for the given offset. CALLER MUST FREE MEMORY.
- */
-static Element* QueueFile_readElement(QueueFile* qf, uint32_t position) {
-  if (position == 0 ||
-      !FileIo_seek(qf->file, position) ||
-      !FileIo_read(qf->file, qf->buffer, 0, (uint32_t) sizeof(uint32_t))) {
-    return NULL;
-  }
-  uint32_t length = readInt(qf->buffer, 0);
-  return Element_new(position, length);
-}
-
-
-char* makeTempFilename(const char* name, int maxLen);
-
-/** Atomically initializes a new file. */
-static bool initialize(char* filename) {
-  if (QueueFile_HEADER_LENGTH < 16) {
-    LOG(LFATAL, "Configuration error, header length must be >= 16 bytes");
-    return false;
-  }
-
-  char* tempname = makeTempFilename(filename, MAX_FILENAME_LEN);
-  if (tempname == NULL) {
-    LOG(LWARN, "Filename too long or out of memory: %s", filename);
-    return false;
-  }
-
-  FILE* tempfile = fopen(tempname, "w+");
-  if (tempfile == NULL) {
-    free(tempname);
-    return false;
-  }
-  
-  bool success = false;
-  // TODO(jochen): if truncate in setLength does not work for target platform, consider
-  //  appending 0s using FileIo_writeZeros.
-  if (FileIo_setLength(tempfile, QueueFile_INITIAL_LENGTH)) {
-    byte headerBuffer[QueueFile_HEADER_LENGTH];
-    writeInts(headerBuffer, QueueFile_INITIAL_LENGTH, 0, 0, 0);
-    success = FileIo_write(tempfile, headerBuffer, 0, QueueFile_HEADER_LENGTH);
-  }
-
-  fclose(tempfile);
-  success = success && rename(tempname, filename) == 0;
-  if (!success) {
-    LOG(LFATAL, "Error initializing temporary file %s", tempname);
-    remove(tempname);
-  }
-  free(tempname);
-  return success;
-}
-
-/** Wraps the position if it exceeds the end of the file. */
-static uint32_t QueueFile_wrapPosition(const QueueFile* qf, uint32_t position) {
-  return position < qf->fileLength ?
-         position : QueueFile_HEADER_LENGTH + position - qf->fileLength;
-}
-
-/**
- * Writes count bytes from buffer to position in file. Automatically wraps
- * write if position is past the end of the file or if buffer overlaps it.
- *
- * @param position in file to write to
- * @param buffer   to write from
- * @param count    # of bytes to write
- */
-static bool QueueFile_ringWrite(QueueFile* qf, uint32_t position,
-                                const byte* buffer,
-    uint32_t offset, uint32_t count) {
-  bool success = false;
-  position = QueueFile_wrapPosition(qf, position);
-  if (position + count <= qf->fileLength) {
-    success = FileIo_seek(qf->file, position) &&
-              FileIo_write(qf->file, buffer, offset, count);
-  } else {
-    // The write overlaps the EOF.
-    // # of bytes to write before the EOF.
-    uint32_t beforeEof = qf->fileLength - position;
-    success = FileIo_seek(qf->file, position) &&
-              FileIo_write(qf->file, buffer, offset, beforeEof) &&
-              FileIo_seek(qf->file, QueueFile_HEADER_LENGTH) &&
-              FileIo_write(qf->file, buffer, offset + beforeEof,
-                           count - beforeEof);
-  }
-  return success;
-}
-
-/**
- * Reads count bytes into buffer from file. Wraps if necessary.
- *
- * @param position in file to read from
- * @param buffer   to read into
- * @param count    # of bytes to read
- */
-static bool QueueFile_ringRead(QueueFile* qf, uint32_t position, byte* buffer,
-                               uint32_t offset, uint32_t count) {
-  bool success = false;
-  position = QueueFile_wrapPosition(qf, position);
-  if (position + count <= qf->fileLength) {
-    success = FileIo_seek(qf->file, position) &&
-              FileIo_read(qf->file, buffer, 0, count);
-  } else {
-    // The read overlaps the EOF.
-    // # of bytes to read before the EOF.
-    uint32_t beforeEof = qf->fileLength - position;
-
-    success = FileIo_seek(qf->file, position) &&
-              FileIo_read(qf->file, buffer, offset, beforeEof) &&
-              FileIo_seek(qf->file, QueueFile_HEADER_LENGTH) &&
-              FileIo_read(qf->file, buffer, offset + beforeEof, count -
-                          beforeEof);
-  }
-  return success;
-}
-
-// see description in queuefile.h.
-bool QueueFile_isEmpty(QueueFile* qf) {
-  if (NULLARG(qf)) return true;
-  pthread_mutex_lock(&qf->mutex);
-  uint32_t elementCount = qf->elementCount == 0;
-  pthread_mutex_unlock(&qf->mutex);
-  return elementCount;
-}
-
-static bool QueueFile_expandIfNecessary(QueueFile* qf, uint32_t dataLength);
-
-// see description in queuefile.h.
-bool QueueFile_add(QueueFile* qf, const byte* data, uint32_t offset,
-                   uint32_t count) {
-  if (NULLARG(qf) || NULLARG(data)) return false;
-
-  bool success = false;
-  pthread_mutex_lock(&qf->mutex);
-
-  if (QueueFile_expandIfNecessary(qf, count)) {
-    
-    // Insert a new element after the current last element.
-    bool wasEmpty = QueueFile_isEmpty(qf);
-    uint32_t position = wasEmpty ? QueueFile_HEADER_LENGTH :
-                        QueueFile_wrapPosition(qf, qf->last->position +
-                                               Element_HEADER_LENGTH +
-                                               qf->last->length);
-    Element* newLast = Element_new(position, count);
-
-    // Write length & data.
-    writeInt(qf->buffer, 0, count);
-    if (newLast != NULL) {
-      if (QueueFile_ringWrite(qf, newLast->position, qf->buffer, 0,
-                              Element_HEADER_LENGTH) &&
-        QueueFile_ringWrite(qf, newLast->position + Element_HEADER_LENGTH, data,
-                            offset, count)) {
-
-        // Commit the addition. If wasEmpty, first == last.
-        uint32_t firstPosition = wasEmpty ? newLast->position : qf->first->position;
-        success = QueueFile_writeHeader(qf, qf->fileLength, qf->elementCount + 1,
-                                        firstPosition, newLast->position);
-      }
-      if (success) {
-        if (freeAndAssignNonNull(&qf->last, newLast)) {
-          if (wasEmpty) freeAndAssignNonNull(&qf->first,
-                                             Element_new(qf->last->position,
-                                                         qf->last->length));
-          success = true;
-          qf->elementCount++;
-        }
-      } else {
-        free(newLast);
-      }
-    }
-  }
-
-  pthread_mutex_unlock(&qf->mutex);
-  return success;
-}
-
-/** Returns the number of used bytes. */
-static uint32_t QueueFile_usedBytes(QueueFile* qf) {
-  if (qf->elementCount == 0) return QueueFile_HEADER_LENGTH;
-
-  if (qf->last->position >= qf->first->position) {
-    // Contiguous queue.
-    return (qf->last->position - qf->first->position)   // all but last entry
-           + Element_HEADER_LENGTH + qf->last->length // last entry
-           + QueueFile_HEADER_LENGTH;
-  } else {
-    // tail < head. The queue wraps.
-    return qf->last->position                      // buffer front + header
-           + Element_HEADER_LENGTH + qf->last->length // last entry
-           + qf->fileLength - qf->first->position;        // buffer end
-  }
-}
-
-/** Returns number of unused bytes. */
-static uint32_t QueueFile_remainingBytes(QueueFile* qf) {
-  return qf->fileLength - QueueFile_usedBytes(qf);
-}
-
-/**
- * If necessary, expands the file to accommodate an additional element of the
- * given length.
- *
- * @param dataLength length of data being added
- * @returns false only if an error was encountered.
- */
-static bool QueueFile_expandIfNecessary(QueueFile* qf, uint32_t dataLength) {
-  uint32_t elementLength = Element_HEADER_LENGTH + dataLength;
-  uint32_t remainingBytes = QueueFile_remainingBytes(qf);
-  if (remainingBytes >= elementLength) {
-    return true;
-  }
-
-  // Expand.
-  uint32_t previousLength = qf->fileLength;
-  uint32_t newLength;
-
-  // Double the length until we can fit the new data.
-  do {
-    remainingBytes += previousLength;
-    newLength = previousLength << 1;
-    previousLength = newLength;
-  } while (remainingBytes < elementLength);
-
-  // TODO(jochen): if truncate in setLength does not work for target platform,
-  //  consider appending 0s using FileIo_writeZeros.
-  if (!FileIo_setLength(qf->file, newLength)) {
-    return false;
-  }
-
-  // Calculate the position of the tail end of the data in the ring buffer
-  uint32_t endOfLastElement = QueueFile_wrapPosition(qf, qf->last->position +
-                                                     Element_HEADER_LENGTH +
-                                                     qf->last->length);
-
-  // If the buffer is split, we need to make it contiguous, so append the
-  // tail of the queue to after the end of the old file.
-  if (endOfLastElement < qf->first->position) {
-    uint32_t count = endOfLastElement - Element_HEADER_LENGTH;
-    if (!FileIo_transferTo(qf->file, QueueFile_HEADER_LENGTH,
-                          qf->fileLength, count)) {
-      return false;
-    }
-  }
-
-  // Commit the expansion.
-  if (qf->last->position < qf->first->position) {
-    uint32_t newLastPosition = qf->fileLength + qf->last->position -
-                               QueueFile_HEADER_LENGTH;
-    if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
-                               qf->first->position, newLastPosition)) {
-      return false;
-    }
-    if (!freeAndAssignNonNull(&qf->last,
-                             Element_new(newLastPosition, qf->last->length))) {
-      return false;
-    }
-  } else {
-    if (!QueueFile_writeHeader(qf, newLength, qf->elementCount,
-                              qf->first->position, qf->last->position)) {
-      return false;
-    }
-  }
-  qf->fileLength = newLength;
-  return true;
-}
-
-// see description in queuefile.h.
-byte* QueueFile_peek(QueueFile* qf, uint32_t* returnedLength) {
-  if (NULLARG(qf) || NULLARG(returnedLength) || QueueFile_isEmpty(qf)) return NULL;
-  pthread_mutex_lock(&qf->mutex);
-  *returnedLength = 0;
-
-  uint32_t length = qf->first->length;
-  byte* data = malloc((size_t) length);
-  if (CHECKOOM(data)) return NULL;
-  if (!QueueFile_ringRead(qf, qf->first->position + Element_HEADER_LENGTH,
-                         data, 0, length)) {
-    free(data);
-    data = NULL;
-  }
-  *returnedLength = length;
-
-  pthread_mutex_unlock(&qf->mutex);
-  return data;
-}
-
-
-struct _QueueFile_ElementStream {
-  QueueFile* qf;
-  uint32_t position;
-  uint32_t remaining;
-};
-
-// see description in queuefile.h.
-bool QueueFile_readElementStream(QueueFile_ElementStream* stream, byte* buffer,
-                                 uint32_t length, uint32_t* lengthRemaining) {
-  if (NULLARG(stream) || NULLARG(buffer) || NULLARG(lengthRemaining) ||
-      NULLARG(stream->qf)) return false;
-  *lengthRemaining = 0;
-  if (stream->remaining == 0) {
-    return true;
-  }
-  if (length > stream->remaining) length = stream->remaining;
-  if (QueueFile_ringRead(stream->qf, stream->position, buffer, 0, length)) {
-    stream->position = QueueFile_wrapPosition(stream->qf,
-                                              stream->position + length);
-    stream->remaining -= length;
-    *lengthRemaining = stream->remaining;
-  } else {
-    return false;
-  }
-  return true;
-}
-
-// see description in queuefile.h.
-int QueueFile_readElementStreamNextByte(QueueFile_ElementStream* stream) {
-  byte buffer;
-  uint32_t remaining;
-  if (stream->remaining == 0) {
-    return -1;
-  }
-  if (!QueueFile_readElementStream(stream, &buffer, (uint32_t) sizeof(byte),
-                                  &remaining)) {
-    return -1;
-  }
-  return (int)buffer;
-}
-
-// see description in queuefile.h.
-bool QueueFile_peekWithElementReader(QueueFile* qf,
-                                     QueueFile_ElementReaderFunc reader) {
-  if (NULLARG(reader) || NULLARG(qf)) return false;
-  pthread_mutex_lock(&qf->mutex);
-
-  bool success = false;
-  if (qf->elementCount == 0) {
-    success = true;
-  } else {
-    if (qf->first == NULL) {
-      LOG(LFATAL, "Internal error: queue should have a first element.");
-    } else {
-      Element* current = QueueFile_readElement(qf, qf->first->position);
-      if (current != NULL) {
-        QueueFile_ElementStream stream;
-        stream.qf = qf;
-        stream.position = QueueFile_wrapPosition(qf, current->position +
-                                                 Element_HEADER_LENGTH);
-        stream.remaining = current->length;
-        free(current);
-        (*reader)(&stream, stream.remaining);
-        success = true;
-      }
-    }
-  }
-  
-  pthread_mutex_unlock(&qf->mutex);
-  return success;
-}
-
-// see description in queuefile.h.
-bool QueueFile_forEach(QueueFile* qf, QueueFile_ElementReaderFunc reader) {
-  if (NULLARG(reader) || NULLARG(qf)) return false;
-  pthread_mutex_lock(&qf->mutex);
-
-  bool success = false;
-  if (qf->elementCount == 0) {
-    success = true;
-  } else {
-    if (qf->first == NULL) {
-      LOG(LFATAL, "Internal error: queue should have a first element.");
-    } else {
-      uint32_t nextReadPosition = qf->first->position;
-      uint32_t i;
-      bool stopRequested = false;
-      success = true;
-      for (i = 0; i < qf->elementCount && !stopRequested && success; i++) {
-        Element* current = QueueFile_readElement(qf, nextReadPosition);
-        if (current != NULL) {
-          QueueFile_ElementStream stream;
-          stream.qf = qf;
-          stream.position = QueueFile_wrapPosition(qf, current->position +
-                                                   Element_HEADER_LENGTH);
-          stream.remaining = current->length;
-          stopRequested = !(*reader)(&stream, stream.remaining);
-          nextReadPosition = QueueFile_wrapPosition(qf, current->position +
-                                                    Element_HEADER_LENGTH +
-                                                    current->length);
-          free(current);
-        } else {
-          success = false;
-        }
-      }
-    }
-  }
-  
-  pthread_mutex_unlock(&qf->mutex);
-  return success;
-}
-
-// see description in queuefile.h.
-uint32_t QueueFile_size(QueueFile* qf) {
-  if (NULLARG(qf)) return 0;
-  pthread_mutex_lock(&qf->mutex);
-  uint32_t elementCount = qf->elementCount;
-  pthread_mutex_unlock(&qf->mutex);
-  return elementCount;
-}
-
-// see description in queuefile.h.
-bool QueueFile_remove(QueueFile* qf) {
-  if (NULLARG(qf)) return false;
-  pthread_mutex_lock(&qf->mutex);
-
-  bool success = false;
-  if (!QueueFile_isEmpty(qf)) {
-    if (qf->elementCount == 1) {
-      success = QueueFile_clear(qf);
-    } else {
-      // assert elementCount > 1
-      uint32_t newFirstPosition = QueueFile_wrapPosition(qf,
-                                                         qf->first->position +
-                                                         Element_HEADER_LENGTH +
-                                                         qf->first->length);
-      if (QueueFile_ringRead(qf, newFirstPosition, qf->buffer, 0,
-                            Element_HEADER_LENGTH)) {
-        int length = readInt(qf->buffer, 0);
-        if (QueueFile_writeHeader(qf, qf->fileLength, qf->elementCount - 1,
-                                 newFirstPosition, qf->last->position)) {
-          if (freeAndAssignNonNull(&qf->first, Element_new(newFirstPosition,
-                                                          (uint32_t) length))) {
-            --qf->elementCount;
-            success = true;
-          }
-        }
-      }
-    }
-  }
-
-  pthread_mutex_unlock(&qf->mutex);
-  return success;
-}
-
-// see description in queuefile.h.
-bool QueueFile_clear(QueueFile* qf) {
-  if (NULLARG(qf)) return false;
-  bool success = false;
-  pthread_mutex_lock(&qf->mutex);
-
-  if (QueueFile_writeHeader(qf, QueueFile_INITIAL_LENGTH, 0, 0, 0)) {
-    qf->elementCount = 0;
-    if (qf->first != NULL) {
-      free(qf->first);
-    }
-    qf->first = NULL;
-    if (qf->last != NULL) {
-      free(qf->last);
-    }
-    qf->last = NULL;
-    if (qf->fileLength > QueueFile_INITIAL_LENGTH) {
-      if (FileIo_setLength(qf->file, QueueFile_INITIAL_LENGTH)) {
-        qf->fileLength = QueueFile_INITIAL_LENGTH;
-        success = true;
-      }
-    } else {
-      success = true;
-    }
-  }
-
-  pthread_mutex_unlock(&qf->mutex);
-  return success;
-}
-
-// TODO(jochen): bool QueueFile_fprintf(QueueFile *qf);
-
-FILE* _for_testing_QueueFile_getFhandle(QueueFile *qf) {
-  return qf->file;
-}
-
-
-// ---------------------------- Utility Functions ------------------------------
-
-
-/**
- * Make a temporary filename (appends ".tmp") at most maxLen chars long.
- * Caller must free result.
- */
-char* makeTempFilename(const char* filename, int maxLen) {
-  // Use a temp file so we don't leave a partially-initialized file.
-  if (filename == NULL || maxLen < 4) {
-    return NULL;
-  }
-  size_t len = strnlen(filename, (size_t) maxLen - 5) + 5;
-  char* tempname = malloc(len);
-  if (CHECKOOM(tempname)) {
-    return NULL;
-  }
-  strncpy(tempname, filename, len);
-  tempname[len-1] = '\0'; // make sure it's terminated if filename was too long.
-  strcat(tempname, ".tmp");
-  return tempname;
-}
-
-static bool _freeAndAssignNonNull(void** oldPointer, void* newPointer) {
-  if (newPointer != NULL) {
-    if (*oldPointer != NULL) {
-      free(*oldPointer);
-    }
-    *oldPointer = newPointer;
-    return true;
-  }
-  return false;
-}
-
-static bool _freeAndAssign(void** oldPointer, void* newPointer) {
-  if (*oldPointer != NULL) {
-    free(*oldPointer);
-  }
-  *oldPointer = newPointer;
-  return true;
-}
diff --git a/c-tape/queuefile.h b/c-tape/queuefile.h
deleted file mode 100644
index d587726..0000000
--- a/c-tape/queuefile.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/*
- * Port of Tape project from Java. https://github.com/square/tape
- *
- * Integers are forced to be 32-bit, maximum file size supported is 2^32 (4GB).
- *
- * Original description:
- *
- * A reliable, efficient, file-based, FIFO queue. Additions and removals are
- * O(1). All operations are atomic. Writes are synchronous; data will be written
- * to disk before an operation returns. The underlying file is structured to
- * survive process and even system crashes. If an I/O exception is thrown during
- * a mutating change, the change is aborted. It is safe to continue to use a
- * {@code QueueFile} instance after an exception.
- *
- * All operations are synchronized. In a traditional queue, the remove
- * operation returns an element. In this queue, {@link #peek} and {@link
- * #remove} are used in conjunction. Use {@code peek} to retrieve the first
- * element, and then {@code remove} to remove it after successful processing. If
- * the system crashes after {@code peek} and during processing, the element will
- * remain in the queue, to be processed when the system restarts.
- *
- * NOTE: The current implementation is built
- * for file systems that support atomic segment writes (like YAFFS). Most
- * conventional file systems don't support this; if the power goes out while
- * writing a segment, the segment will contain garbage and the file will be
- * corrupt. We'll add journaling support so this class can be used with more
- * file systems later.
- *
- */
-
-
-#ifndef QUEUEFILE_H_
-#define QUEUEFILE_H_
-
-#include"types.h"
-
-struct _QueueFile;
-typedef struct _QueueFile QueueFile;
-
-/** 
- * Create new queuefile.
- * @param filename
- * @return new queuefile or NULL on error. 
- */
-QueueFile* QueueFile_new(char* filename);
-
-/** 
- * Closes the underlying file and frees all memory including
- * the pointer passed.
- * @param qf queuefile
- * @return false if an error occurred
- */
-bool QueueFile_closeAndFree(QueueFile* qf);
-
-/**
- * Adds an element to the end of the queue.
- * @param qf queuefile
- * @param data to copy bytes from
- * @param offset to start from in buffer
- * @param count number of bytes to copy
- * @return false if an error occurred
- */
-bool QueueFile_add(QueueFile* qf, const byte* data, uint32_t offset,
-                   uint32_t count);
-
-/** 
- * Reads the eldest element. Returns null if the queue is empty.
- * @param qf queuefile
- * @param returnedLength contains the size of the returned buffer.
- * @return element buffer (null if queue is empty) CALLER MUST FREE THIS
- */
-byte* QueueFile_peek(QueueFile* qf, uint32_t* returnedLength);
-
-
-struct _QueueFile_ElementStream;
-typedef struct _QueueFile_ElementStream QueueFile_ElementStream;
-
-/**
- * Read data from an element stream.
- * @param stream pointer to element stream.
- * @param buffer  to copy bytes to.
- * @param length  size of buffer.
- * @param lengthRemaining if not null, will be set to number of bytes left.
- * @return false if an error occurred.
- *
- * *********************************************************
- * WARNING! MUST ONLY BE USED INSIDE A CALLBACK FROM FOREACH
- * as this ensures the queuefile is under mutex lock.
- * the validity of stream is only guaranteed under this callback.
- * *********************************************************
- */
-bool QueueFile_readElementStream(QueueFile_ElementStream* stream, byte* buffer,
-                                 uint32_t length, uint32_t* lengthRemaining);
-
-/**
- * Reads the next byte.
- * @param stream pointer to element stream.
- * @return as int, or -1 if the element has ended, or on error.
- *
- * *********************************************************
- * WARNING! MUST ONLY BE USED INSIDE A CALLBACK FROM FOREACH
- * as this ensures the queuefile is under mutex lock.
- * the validity of stream is only guaranteed under this callback.
- * *********************************************************
- */
-int QueueFile_readElementStreamNextByte(QueueFile_ElementStream* stream);
-
-/**
- * Function which is called by forEach or peekWithElementReader for each element.
- * @param stream pointer to element stream.
- * @param remaining number of bytes in element.
- * @return false to stop the iteration.
- */
-typedef bool (*QueueFile_ElementReaderFunc)(QueueFile_ElementStream* stream,
-                                            uint32_t remaining);
-
-/**
- * Invokes the given reader once for the first element in the queue.
- * There will be no callback if the queue is empty.
- * @param qf queuefile.
- * @param reader function pointer for callback.
- * @return false if an error occurred.
- */
-bool QueueFile_peekWithElementReader(QueueFile* qf,
-                                     QueueFile_ElementReaderFunc reader);
-
-/**
- * Invokes the given reader once for each element in the queue, from eldest to
- * most recently added. Note that this is under lock.
- * There will be no callback if the queue is empty.
- * @param qf queuefile.
- * @param reader function pointer for callback.
- * @return false if an error occurred.
- */
-bool QueueFile_forEach(QueueFile* qf, QueueFile_ElementReaderFunc reader);
-
-/** Returns true if there are no entries or NULL passed. */
-bool QueueFile_isEmpty(QueueFile* qf);
-
-/** 
- * Clears this queue. Truncates the file to the initial size.
- * @param qf queuefile.
- * @param reader function pointer for callback.
- * @return false if an error occurred.
- */
-bool QueueFile_clear(QueueFile* qf);
-
-/** 
- * @param qf queuefile.
- * @return the number of elements in this queue, or 0 if NULL is passed. 
- */
-uint32_t QueueFile_size(QueueFile* qf);
-
-/**
- * Removes the eldest element.
- * @param qf queuefile.
- * @return false if empty or NULL passed.
- */
-bool QueueFile_remove(QueueFile* qf);
-
-
-FILE* _for_testing_QueueFile_getFhandle(QueueFile* qf);
-
-#endif //queuefile_h
diff --git a/c-tape/tests/minunit.h b/c-tape/tests/minunit.h
deleted file mode 100644
index 31dd904..0000000
--- a/c-tape/tests/minunit.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef MINUNIT_H_
-#define MINUNIT_H_
-
-/*
- * Some minimal unit testing functions.
- */
-
-#define mu_assert(test) do { if (!(test)) { fprintf(stderr, "%s:%d test fail: assertion failure\n",__FILE__, __LINE__); abort(); } } while (0)
-#define mu_assertm(test, message) do { if (!(test)) { fprintf(stderr, "%s:%d test fail:  %s\n",__FILE__, __LINE__, message); abort(); } } while (0)
-#define mu_assertmv(test, ...) do { if (!(test)) { fprintf(stderr, "%s:%d test fail:  ",__FILE__, __LINE__); vfprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); abort(); } } while (0)
-#define mu_assert_notnull(test) do { if (!(test)) { fprintf(stderr, "%s:%d test fail:  null pointer\n",__FILE__, __LINE__); abort(); } } while (0)
-#define mu_assert_memcmp(m1, m2, l) do { if(m1==NULL||m2==NULL||memcmp(m1,m2,(size_t)l)!=0) { fprintf(stderr, "%s:%d test fail:  data doesn't match\n",__FILE__, __LINE__); abort(); } } while (0)
-#define mu_run_test(testfn) do { mu_setup(); tests_run++; testfn(); mu_teardown(); } while (0)
-extern int tests_run;
-
-#endif
diff --git a/c-tape/tests/queuefile_test.c b/c-tape/tests/queuefile_test.c
deleted file mode 100644
index 20a2e93..0000000
--- a/c-tape/tests/queuefile_test.c
+++ /dev/null
@@ -1,528 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <sys/queue.h>
-
-#include "minunit.h"
-
-#include "../logutil.h"
-#include "../queuefile.h"
-#include "../types.h"
-#include "../fileio.h"
-
-/**
- * Takes up 33401 bytes in the queue (N*(N+1)/2+4*N). Picked 254 instead of
- * 255 so that the number of bytes isn't a multiple of 4.
- */
-#define N 254
-static byte* values[N];
-
-#define TEST_QUEUE_FILENAME "test.queue"
-static QueueFile* queue;
-int tests_run = 0;
-
-
-typedef STAILQ_HEAD(listHead_t, listEntry_t) listHead;
-static void _assertPeekCompare(QueueFile *queue, const byte* data,
-                               uint32_t length);
-static void _assertPeekCompareRemove(QueueFile *queue, const byte* data,
-                                     uint32_t length);
-static void _assertPeekCompareRemoveDequeue(QueueFile *queue,
-                                            listHead *expectqueue);
-
-static void mu_setup() {
-  int i;
-  for (i = 0; i < N; i++) {
-    values[i] = malloc((size_t) i);
-    // Example: values[3] = { 3, 2, 1 }
-    int ii;
-    for (ii = 0; ii < i; ii++) values[i][ii] = (byte) (i - ii);
-  }
-
-  // Default case is start with a clean queue.
-  remove(TEST_QUEUE_FILENAME);
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-  mu_assert_notnull(queue);
-}
-
-static void mu_teardown() {
-  QueueFile_closeAndFree(queue);
-  int i;
-  for (i = 0; i < N; i++) {
-    free(values[i]);
-  }
-}
-
-static void testSimpleAddOneElement() {
-  byte* expected = values[253];
-  QueueFile_add(queue, expected, 0, 253);
-  _assertPeekCompare(queue, expected, 253);
-}
-
-static void testAddOneElement() {
-  byte* expected = values[253];
-  QueueFile_add(queue, expected, 0, 253);
-  _assertPeekCompare(queue, expected, 253);
-  QueueFile_closeAndFree(queue);
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-  _assertPeekCompare(queue, expected, 253);
-}
-
-
-// stuct for test queue.
-struct listEntry_t {
-  byte *data;
-  uint32_t length;
-  STAILQ_ENTRY(listEntry_t) next_entry;
-};
-
-struct listEntry_t* listEntry_new(byte *argdata, uint32_t arglen) {
-  struct listEntry_t* retval = malloc(sizeof(struct listEntry_t));
-  mu_assert_notnull(retval);
-  retval->data = argdata;
-  retval->length = arglen;
-  return retval;
-};
-
-static void testAddAndRemoveElements() {
-  QueueFile_closeAndFree(queue);
-  time_t start = time(NULL);
-
-  listHead expect = STAILQ_HEAD_INITIALIZER(expect);
-  struct listEntry_t* entry;
-
-  int round;
-  for (round = 0; round < 5; round++) {
-    queue = QueueFile_new(TEST_QUEUE_FILENAME);
-    int i;
-    for (i = 0; i < N; i++) {
-      QueueFile_add(queue, values[i], 0, (uint32_t) i);
-      entry = listEntry_new(values[i], (uint32_t) i);
-      STAILQ_INSERT_TAIL(&expect, entry, next_entry);
-    }
-
-    // Leave N elements in round N, 15 total for 5 rounds. Removing all the
-    // elements would be like starting with an empty queue.
-    for (i = 0; i < N - round - 1; i++) {
-      _assertPeekCompareRemoveDequeue(queue, &expect);
-    }
-    QueueFile_closeAndFree(queue);
-  }
-
-  // Remove and validate remaining 15 elements.
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-  mu_assert(QueueFile_size(queue) == 15);
-
-  int expectCount = 0;
-  STAILQ_FOREACH(entry, &expect, next_entry) {
-    ++expectCount;
-  }
-  mu_assert(expectCount == 15);
-
-  while (!STAILQ_EMPTY(&expect)) {
-    _assertPeekCompareRemoveDequeue(queue, &expect);
-  }
-
-  time_t stop = time(NULL);
-  LOG(LINFO, "Ran in %lf seconds.", difftime(stop, start));
-}
-
-/** Tests queue expansion when the data crosses EOF. */
-static void testSplitExpansion() {
-  // This should result in 3560 bytes.
-  int max = 80;
-
-  listHead expect = STAILQ_HEAD_INITIALIZER(expect);
-  struct listEntry_t* entry;
-
-  int i;
-  for (i = 0; i < max; i++) {
-    QueueFile_add(queue, values[i], 0, (uint32_t) i);
-    entry = listEntry_new(values[i], (uint32_t) i);
-    STAILQ_INSERT_TAIL(&expect, entry, next_entry);
-  }
-
-  // Remove all but 1.
-  for (i = 1; i < max; i++) {
-    _assertPeekCompareRemoveDequeue(queue, &expect);
-  }
-
-  off_t flen1 = FileIo_getLength(_for_testing_QueueFile_getFhandle(queue));
-
-  // This should wrap around before expanding.
-  for (i = 0; i < N; i++) {
-    QueueFile_add(queue, values[i], 0, (uint32_t) i);
-    entry = listEntry_new(values[i], (uint32_t) i);
-    STAILQ_INSERT_TAIL(&expect, entry, next_entry);
-  }
-
-  while (!STAILQ_EMPTY(&expect)) {
-    _assertPeekCompareRemoveDequeue(queue, &expect);
-  }
-
-  off_t flen2 = FileIo_getLength(_for_testing_QueueFile_getFhandle(queue));
-  mu_assertm(flen1 == flen2, "file size should remain same");
-}
-
-#define ARR_A_SIZE 5
-static const byte arrA[ARR_A_SIZE] = {1, 2, 3, 4, 5};
-#define ARR_B_SIZE 3
-static const byte arrB[ARR_B_SIZE] = {3, 4, 5};
-
-static int forEachIterationCount = 0;
-static bool forEachReader(QueueFile_ElementStream* stream, uint32_t length) {
-  if (forEachIterationCount == 0) {
-    mu_assert(length == ARR_A_SIZE);
-    mu_assert_notnull(stream);
-
-    // Read in small chunks to test reader.
-    byte actual[ARR_A_SIZE];
-    int elementIteration = 0;
-    uint32_t expectedRemaining[] = { 3, 1, 0 };
-    uint32_t remaining = ARR_A_SIZE;
-    do {
-      // i.e. read past end i.e. 3 reads of 2 > 5
-      mu_assert(QueueFile_readElementStream(stream, actual + ARR_A_SIZE -
-                                            remaining, 2, &remaining));
-      mu_assert(expectedRemaining[elementIteration] == remaining);
-      ++elementIteration;
-    } while (remaining > 0 && elementIteration < 4);
-    mu_assert(elementIteration == 3);
-    mu_assert_memcmp(actual, arrA, ARR_A_SIZE);
-  } else if (forEachIterationCount == 1) {
-    mu_assert(length == ARR_B_SIZE);
-    mu_assert_notnull(stream);
-    byte actual[ARR_B_SIZE];
-    uint32_t remaining;
-    mu_assert(QueueFile_readElementStream(stream,
-        actual, ARR_B_SIZE, &remaining));
-    mu_assert(remaining == 0);
-    mu_assert_memcmp(actual, arrB, ARR_B_SIZE);
-  } else {
-    mu_assertm(false, "Should never iterate beyond 2");
-  }
-  forEachIterationCount++;
-  return true;
-}
-
-static void testForEach() {
-  mu_assert(QueueFile_add(queue, arrA, 0, ARR_A_SIZE));
-  mu_assert(QueueFile_add(queue, arrB, 0, ARR_B_SIZE));
-
-  mu_assert(QueueFile_forEach(queue, forEachReader));
-  _assertPeekCompare(queue, arrA, ARR_A_SIZE);
-  mu_assertm(forEachIterationCount == 2, "expected 2 iterations");
-}
-
-
-static bool peekReaderAblock(QueueFile_ElementStream* stream, uint32_t length) {
-  mu_assert(length == ARR_A_SIZE);
-  byte actual[length];
-  uint32_t remaining;
-  mu_assert(QueueFile_readElementStream(stream, actual, length, &remaining));
-  mu_assert(remaining == 0);
-  mu_assert_memcmp(actual, arrA, length);
-  return true;
-}
-
-static bool peekReaderAbytewise(QueueFile_ElementStream* stream, uint32_t length) {
-  mu_assert(length == ARR_A_SIZE);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == 1);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == 2);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == 3);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == 4);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == 5);
-  mu_assert(QueueFile_readElementStreamNextByte(stream) == -1);
-  return true;
-}
-
-static bool peekReaderBblock(QueueFile_ElementStream* stream, uint32_t length) {
-  mu_assert(length == ARR_B_SIZE);
-  byte actual[length];
-  uint32_t remaining;
-  mu_assert(QueueFile_readElementStream(stream, actual, length, &remaining));
-  mu_assert(remaining == 0);
-  mu_assert_memcmp(actual, arrB, length);
-  return true;
-}
-
-static void testPeekWithElementReader() {
-  mu_assert(QueueFile_add(queue, arrA, 0, ARR_A_SIZE));
-  mu_assert(QueueFile_add(queue, arrB, 0, ARR_B_SIZE));
-
-  QueueFile_peekWithElementReader(queue, peekReaderAblock); // ignore response.
-  QueueFile_peekWithElementReader(queue, peekReaderAbytewise); // ignore response.
-
-  mu_assert(QueueFile_remove(queue));
-
-  QueueFile_peekWithElementReader(queue, peekReaderBblock); // ignore response.
-
-  mu_assert(QueueFile_size(queue) == 1);
-  _assertPeekCompare(queue, arrB, ARR_B_SIZE);
-}
-
-/**
- * Exercise a bug where wrapped elements were getting corrupted when the
- * QueueFile was forced to expand in size and a portion of the final Element
- * had been wrapped into space at the beginning of the file.
- */
-static void testFileExpansionDoesntCorruptWrappedElements() {
-
-  // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
-  uint32_t valuesCount = 5;
-  uint32_t valuesLength = 1024;
-  byte* values[valuesCount];
-  uint32_t blockNum;
-  for (blockNum = 0; blockNum < valuesCount; blockNum++) {
-    values[blockNum] = malloc((size_t) valuesLength);
-    uint32_t i;
-    for (i = 0; i < valuesLength; i++) {
-      values[blockNum][i] = (byte) (blockNum + 1);
-    }
-  }
-
-  // First, add the first two blocks to the queue, remove one leaving a
-  // 1K space at the beginning of the buffer.
-  mu_assert(QueueFile_add(queue, values[0], 0, valuesLength));
-  mu_assert(QueueFile_add(queue, values[1], 0, valuesLength));
-  mu_assert(QueueFile_remove(queue));
-
-  // The trailing end of block "4" will be wrapped to the start of the buffer.
-  mu_assert(QueueFile_add(queue, values[2], 0, valuesLength));
-  mu_assert(QueueFile_add(queue, values[3], 0, valuesLength));
-
-  // Cause buffer to expand as there isn't space between the end of block "4"
-  // and the start of block "2".  Internally the queue should cause block "4"
-  // to be contiguous, but there was a bug where that wasn't happening.
-  mu_assert(QueueFile_add(queue, values[4], 0, valuesLength));
-
-  // Make sure values are not corrupted, specifically block "4" that wasn't
-  // being made contiguous in the version with the bug.
-  uint32_t i;
-  for (i = 1; i < valuesCount; i++) { // start at 1!
-    uint32_t length;
-    byte* value = QueueFile_peek(queue, &length);
-    mu_assert(length == valuesLength);
-    mu_assert(QueueFile_remove(queue));
-
-    uint32_t j;
-    for (j = 0; j < length; j++) {
-      mu_assert(value[j] == i + 1);
-    }
-    free(value);
-  }
-
-  for (blockNum = 0; blockNum < valuesCount; blockNum++) {
-    free(values[blockNum]);
-  }
-}
-
-/**
- * Exercise a bug where wrapped elements were getting corrupted when the
- * QueueFile was forced to expand in size and a portion of the final Element
- * had been wrapped into space at the beginning of the file - if multiple
- * Elements have been written to empty buffer space at the start does the
- * expansion correctly update all their positions?
- */
-static void testFileExpansionCorrectlyMovesElements() {
-
-  // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
-  uint32_t valuesCount = 5;
-  uint32_t valuesLength = 1024;
-  byte* values[valuesCount];
-  uint32_t blockNum;
-  for (blockNum = 0; blockNum < valuesCount; blockNum++) {
-    values[blockNum] = malloc((size_t) valuesLength);
-    uint32_t i;
-    for (i = 0; i < valuesLength; i++) {
-      values[blockNum][i] = (byte) (blockNum + 1);
-    }
-  }
-
-  // smaller data elements
-  uint32_t smallerCount = 3;
-  uint32_t smallerLength = 256;
-  byte* smaller[smallerCount];
-  for (blockNum = 0; blockNum < smallerCount; blockNum++) {
-    smaller[blockNum] = malloc((size_t) smallerLength);
-    uint32_t i;
-    for (i = 0; i < smallerLength; i++) {
-      smaller[blockNum][i] = (byte) (blockNum + 6);
-    }
-  }
-
-  // First, add the first two blocks to the queue, remove one leaving a
-  // 1K space at the beginning of the buffer.
-  mu_assert(QueueFile_add(queue, values[0], 0, valuesLength));
-  mu_assert(QueueFile_add(queue, values[1], 0, valuesLength));
-  mu_assert(QueueFile_remove(queue));
-
-  // The trailing end of block "4" will be wrapped to the start of the buffer.
-  mu_assert(QueueFile_add(queue, values[2], 0, valuesLength));
-  mu_assert(QueueFile_add(queue, values[3], 0, valuesLength));
-
-  // Now fill in some space with smaller blocks, none of which will cause
-  // an expansion.
-  mu_assert(QueueFile_add(queue, smaller[0], 0, smallerLength));
-  mu_assert(QueueFile_add(queue, smaller[1], 0, smallerLength));
-  mu_assert(QueueFile_add(queue, smaller[2], 0, smallerLength));
-
-  // Cause buffer to expand as there isn't space between the end of the
-  // smaller block "8" and the start of block "2".  Internally the queue
-  // should cause all of tbe smaller blocks, and the trailing end of
-  // block "5" to be moved to the end of the file.
-  mu_assert(QueueFile_add(queue, values[4], 0, valuesLength));
-
-  uint32_t expectedBlockLen = 7;
-  byte expectedBlockNumbers[] = {2, 3, 4, 6, 7, 8, 5};
-  uint32_t expectedLengths[] = {valuesLength, valuesLength, valuesLength,
-      smallerLength, smallerLength, smallerLength, valuesLength};
-
-  // Make sure values are not corrupted, specifically block "4" that wasn't
-  // being made contiguous in the version with the bug.
-  uint32_t i;
-  for (i = 0; i < expectedBlockLen; i++) {
-    byte expectedBlockNumber = expectedBlockNumbers[i];
-    uint32_t length;
-    byte* value = QueueFile_peek(queue, &length);
-    mu_assert(length == expectedLengths[i]);
-    mu_assert(QueueFile_remove(queue));
-
-    uint32_t j;
-    for (j = 0; j < length; j++) {
-      mu_assert(value[j] == expectedBlockNumber);
-    }
-    free(value);
-  }
-  mu_assert(QueueFile_isEmpty(queue));
-
-  for (blockNum = 0; blockNum < valuesCount; blockNum++) {
-    free(values[blockNum]);
-  }
-
-  for (blockNum = 0; blockNum < smallerCount; blockNum++) {
-    free(smaller[blockNum]);
-  }
-}
-
-static void testFailedAdd() {
-  mu_assert(QueueFile_add(queue, values[253], 0, 253));
-  _for_testing_FileIo_failAllWrites(true);
-  mu_assert(!QueueFile_add(queue, values[252], 0, 252));
-  _for_testing_FileIo_failAllWrites(false);
-
-  // Allow a subsequent add to succeed.
-  mu_assert(QueueFile_add(queue, values[251], 0, 251));
-
-  QueueFile_closeAndFree(queue);
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-
-  mu_assert(QueueFile_size(queue) == 2);
-  _assertPeekCompareRemove(queue, values[253], 253);
-  _assertPeekCompareRemove(queue, values[251], 251);
-}
-
-static void testFailedRemoval() {
-  mu_assert(QueueFile_add(queue, values[253], 0, 253));
-  _for_testing_FileIo_failAllWrites(true);
-  mu_assert(!QueueFile_remove(queue));
-  _for_testing_FileIo_failAllWrites(false);
-
-  QueueFile_closeAndFree(queue);
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-
-  mu_assert(QueueFile_size(queue) == 1);
-  _assertPeekCompareRemove(queue, values[253], 253);
-  mu_assert(QueueFile_add(queue, values[99], 0, 99));
-  _assertPeekCompareRemove(queue, values[99], 99);
-}
-
-static void testFailedExpansion() {
-  mu_assert(QueueFile_add(queue, values[253], 0, 253));
-  _for_testing_FileIo_failAllWrites(true);
-  byte bigbuf[8000];
-  mu_assert(!QueueFile_add(queue, bigbuf, 0, 8000));
-  _for_testing_FileIo_failAllWrites(false);
-
-  QueueFile_closeAndFree(queue);
-  queue = QueueFile_new(TEST_QUEUE_FILENAME);
-
-  mu_assert(QueueFile_size(queue) == 1);
-
-  _assertPeekCompare(queue, values[253], 253);
-  mu_assert(4096 == FileIo_getLength(_for_testing_QueueFile_getFhandle(queue)));
-  mu_assert(QueueFile_add(queue, values[99], 0, 99));
-  _assertPeekCompareRemove(queue, values[253], 253);
-  _assertPeekCompareRemove(queue, values[99], 99);
-}
-
-static void testTransferToWithSmallBuffer() {
-  uint32_t oldBufferSize = _for_testing_setTransferToCopyBufferSize(5);
-  testFileExpansionDoesntCorruptWrappedElements();
-  _for_testing_setTransferToCopyBufferSize(oldBufferSize);
-}
-
-int main() {
-  LOG_SETDEBUGFAILLEVEL_WARN;
-  mu_run_test(testSimpleAddOneElement);
-  mu_run_test(testAddOneElement);
-  mu_run_test(testAddAndRemoveElements);
-  mu_run_test(testSplitExpansion);
-  mu_run_test(testFileExpansionDoesntCorruptWrappedElements);
-  mu_run_test(testFileExpansionCorrectlyMovesElements);
-  mu_run_test(testFailedAdd);
-  mu_run_test(testFailedRemoval);
-  mu_run_test(testFailedExpansion);
-  mu_run_test(testForEach);
-  mu_run_test(testPeekWithElementReader);
-  mu_run_test(testTransferToWithSmallBuffer);
-
-  printf("%d tests passed.\n", tests_run);
-  return 0;
-}
-
-
-
-// ------------- utility methods ---------------
-
-static void _assertPeekCompare(QueueFile *queue, const byte* data,
-                               uint32_t length) {
-  uint32_t qlength;
-  byte* actual = QueueFile_peek(queue, &qlength);
-  mu_assert(qlength == length);
-  mu_assert_memcmp(data, actual, length);
-  free(actual);
-}
-
-static void _assertPeekCompareRemove(QueueFile *queue, const byte* data,
-                                     uint32_t length) {
-  _assertPeekCompare(queue, data, length);
-  mu_assert(QueueFile_remove(queue));
-}
-
-static void _assertPeekCompareRemoveDequeue(QueueFile *queue,
-                                            struct listHead_t *expectqueue) {
-  struct listEntry_t *entry = STAILQ_FIRST(expectqueue);
-  mu_assert_notnull(entry);
-  _assertPeekCompareRemove(queue, entry->data, entry->length);
-  STAILQ_REMOVE_HEAD(expectqueue, next_entry);
-  free(entry);
-}
-
diff --git a/c-tape/types.h b/c-tape/types.h
deleted file mode 100644
index 8d21731..0000000
--- a/c-tape/types.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef TYPES_H_
-#define TYPES_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-
-typedef uint8_t byte;
-
-#endif
diff --git a/checkstyle.xml b/checkstyle.xml
index 1b515bb..9cea4b9 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -4,117 +4,134 @@
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 
 <module name="Checker">
-    <module name="NewlineAtEndOfFile"/>
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
-
-    <!-- Trailing spaces -->
-    <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
+  <!--module name="NewlineAtEndOfFile"/-->
+  <module name="FileLength"/>
+  <module name="FileTabCharacter"/>
+
+  <!-- Trailing spaces -->
+  <module name="RegexpSingleline">
+    <property name="format" value="\s+$"/>
+    <property name="message" value="Line has trailing spaces."/>
+  </module>
+
+  <!-- Space after 'for' and 'if' -->
+  <module name="RegexpSingleline">
+    <property name="format" value="^\s*(for|if)[^ ]\("/>
+    <property name="message" value="Space needed before opening parenthesis."/>
+  </module>
+
+  <!-- For each spacing -->
+  <module name="RegexpSingleline">
+    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+    <property name="message" value="Space needed around ':' character."/>
+  </module>
+
+  <module name="TreeWalker">
+    <!--<property name="cacheFile" value="${checkstyle.cache.file}"/>-->
+
+    <!-- Checks for Javadoc comments.                     -->
+    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+    <!--module name="JavadocMethod"/-->
+    <!--module name="JavadocType"/-->
+    <!--module name="JavadocVariable"/-->
+    <!--module name="JavadocStyle"/-->
+
+
+    <!-- Checks for Naming Conventions.                  -->
+    <!-- See http://checkstyle.sf.net/config_naming.html -->
+    <!--<module name="ConstantName"/>-->
+    <module name="LocalFinalVariableName"/>
+    <module name="LocalVariableName"/>
+    <module name="MemberName"/>
+    <module name="MethodName">
+      <property name="format" value="^[a-z][a-zA-Z0-9_]*$"/>
     </module>
+    <module name="PackageName"/>
+    <module name="ParameterName"/>
+    <module name="StaticVariableName"/>
+    <module name="TypeName"/>
+
+
+    <!-- Checks for imports                              -->
+    <!-- See http://checkstyle.sf.net/config_import.html -->
+    <module name="AvoidStarImport"/>
+    <module name="IllegalImport"/>
+    <module name="RedundantImport"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
+
 
-    <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <!--module name="JavadocMethod"/-->
-        <module name="JavadocType"/>
-        <!--module name="JavadocVariable"/-->
-        <module name="JavadocStyle"/>
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <module name="ConstantName"/>
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-            <property name="max" value="120"/>
-        </module>
-        <module name="MethodLength"/>
-        <module name="ParameterNumber"/>
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!--module name="ModifierOrder"/-->
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks"/>
-        <module name="EmptyBlock"/>
-        <module name="LeftCurly"/>
-        <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
-        <module name="EmptyStatement"/>
-        <module name="EqualsAvoidNull"/>
-        <module name="EqualsHashCode"/>
-        <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
-        <module name="InnerAssignment"/>
-        <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <!--module name="DesignForExtension"/-->
-        <module name="FinalClass"/>
-        <module name="HideUtilityClassConstructor"/>
-        <module name="InterfaceIsType"/>
-        <!--module name="VisibilityModifier"/-->
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <module name="ArrayTypeStyle"/>
-        <!--module name="FinalParameters"/-->
-        <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
+    <!-- Checks for Size Violations.                    -->
+    <!-- See http://checkstyle.sf.net/config_sizes.html -->
+    <module name="LineLength">
+      <property name="max" value="100"/>
+    </module>
+    <module name="MethodLength">
+      <property name="max" value="200"/>
     </module>
+    <!--module name="ParameterNumber"/-->
+
+
+    <!-- Checks for whitespace                               -->
+    <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+    <module name="GenericWhitespace"/>
+    <module name="EmptyForIteratorPad"/>
+    <module name="MethodParamPad"/>
+    <module name="NoWhitespaceAfter"/>
+    <module name="NoWhitespaceBefore"/>
+    <module name="OperatorWrap"/>
+    <module name="ParenPad"/>
+    <module name="TypecastParenPad"/>
+    <module name="WhitespaceAfter"/>
+    <module name="WhitespaceAround"/>
+
+
+    <!-- Modifier Checks                                    -->
+    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+    <module name="ModifierOrder"/>
+    <module name="RedundantModifier"/>
+
+
+    <!-- Checks for blocks. You know, those {}'s         -->
+    <!-- See http://checkstyle.sf.net/config_blocks.html -->
+    <!--module name="AvoidNestedBlocks"/-->
+    <!--module name="EmptyBlock"/-->
+    <module name="LeftCurly"/>
+    <!--module name="NeedBraces"/-->
+    <module name="RightCurly"/>
+
+
+    <!-- Checks for common coding problems               -->
+    <!-- See http://checkstyle.sf.net/config_coding.html -->
+    <!--module name="AvoidInlineConditionals"/-->
+    <module name="CovariantEquals"/>
+    <module name="EmptyStatement"/>
+    <!--<module name="EqualsAvoidNull"/>-->
+    <module name="EqualsHashCode"/>
+    <!--module name="HiddenField"/-->
+    <module name="IllegalInstantiation"/>
+    <!--<module name="InnerAssignment"/>-->
+    <!--module name="MagicNumber"/-->
+    <module name="MissingSwitchDefault"/>
+    <module name="RedundantThrows"/>
+    <module name="SimplifyBooleanExpression"/>
+    <module name="SimplifyBooleanReturn"/>
+
+    <!-- Checks for class design                         -->
+    <!-- See http://checkstyle.sf.net/config_design.html -->
+    <!--module name="DesignForExtension"/-->
+    <!--module name="FinalClass"/-->
+    <!--module name="HideUtilityClassConstructor"/-->
+    <!--module name="InterfaceIsType"/-->
+    <!--module name="VisibilityModifier"/-->
+
+
+    <!-- Miscellaneous other checks.                   -->
+    <!-- See http://checkstyle.sf.net/config_misc.html -->
+    <!--module name="ArrayTypeStyle"/-->
+    <!--module name="FinalParameters"/-->
+    <!--module name="TodoComment"/-->
+    <module name="UpperEll"/>
+  </module>
 </module>
diff --git a/deploy_website.sh b/deploy_website.sh
index 6664c71..85c4353 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -3,9 +3,6 @@
 set -ex
 
 REPO="git@github.com:square/tape.git"
-GROUP_ID="com.squareup"
-ARTIFACT_ID="tape"
-
 DIR=temp-clone
 
 # Delete any existing temporary website clone
@@ -20,18 +17,12 @@ cd $DIR
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000..ffc6bbf
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,16 @@
+GROUP=com.squareup.tape2
+VERSION_NAME=2.0.0-SNAPSHOT
+
+POM_DESCRIPTION=A lightning fast, transactional, file-based FIFO for Android and Java.
+
+POM_URL=https://github.com/square/tape/
+POM_SCM_URL=https://github.com/square/tape/
+POM_SCM_CONNECTION=scm:git:git://github.com/square/tape.git
+POM_SCM_DEV_CONNECTION=scm:git:ssh://git@github.com/square/tape.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
new file mode 100644
index 0000000..ea3f6bb
--- /dev/null
+++ b/gradle/gradle-mvn-push.gradle
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+version = VERSION_NAME
+group = GROUP
+
+def isReleaseBuild() {
+  return VERSION_NAME.contains("SNAPSHOT") == false
+}
+
+def getReleaseRepositoryUrl() {
+  return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+      : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+}
+
+def getSnapshotRepositoryUrl() {
+  return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+      : "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+def getRepositoryUsername() {
+  return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
+}
+
+def getRepositoryPassword() {
+  return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
+}
+
+afterEvaluate { project ->
+  uploadArchives {
+    repositories {
+      mavenDeployer {
+        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        repository(url: getReleaseRepositoryUrl()) {
+          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+        }
+        snapshotRepository(url: getSnapshotRepositoryUrl()) {
+          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+        }
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+  }
+
+  signing {
+    required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+    sign configurations.archives
+  }
+
+  if (project.getPlugins().hasPlugin('com.android.application') ||
+      project.getPlugins().hasPlugin('com.android.library')) {
+    task install(type: Upload, dependsOn: assemble) {
+      repositories.mavenInstaller {
+        configuration = configurations.archives
+
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+
+    task androidJavadocs(type: Javadoc) {
+      source = android.sourceSets.main.java.source
+      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+      classifier = 'javadoc'
+      from androidJavadocs.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+      classifier = 'sources'
+      from android.sourceSets.main.java.source
+    }
+  } else {
+    install {
+      repositories.mavenInstaller {
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+
+    task sourcesJar(type: Jar, dependsOn:classes) {
+      classifier = 'sources'
+      from sourceSets.main.allSource
+    }
+
+    task javadocJar(type: Jar, dependsOn:javadoc) {
+      classifier = 'javadoc'
+      from javadoc.destinationDir
+    }
+  }
+
+  if (JavaVersion.current().isJava8Compatible()) {
+    allprojects {
+      tasks.withType(Javadoc) {
+        options.addStringOption('Xdoclint:none', '-quiet')
+      }
+    }
+  }
+
+  artifacts {
+    if (project.getPlugins().hasPlugin('com.android.application') ||
+        project.getPlugins().hasPlugin('com.android.library')) {
+      archives androidSourcesJar
+      archives androidJavadocsJar
+    } else {
+      archives sourcesJar
+      archives javadocJar
+    }
+  }
+}
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..3baa851
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..f3fdc34
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Sep 02 22:21:42 PDT 2016
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 0000000..27309d9
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..f6d5974
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index 6224bc7..0000000
--- a/pom.xml
+++ /dev/null
@@ -1,186 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>com.squareup</groupId>
-  <artifactId>tape-parent</artifactId>
-  <version>1.2.4-SNAPSHOT</version>
-  <packaging>pom</packaging>
-
-  <name>Tape (Parent)</name>
-  <description>A lightning fast, transactional, file-based FIFO for Android and Java.</description>
-  <url>http://github.com/square/tape/</url>
-
-  <modules>
-    <module>tape</module>
-    <module>tape-sample</module>
-  </modules>
-
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <android.version>4.1.1.4</android.version>
-    <android.platform>16</android.platform>
-    <http-request.version>2.2</http-request.version>
-    <dagger.version>0.9</dagger.version>
-    <otto.version>1.3.1</otto.version>
-    <gson.version>2.2</gson.version>
-    <junit.version>4.10</junit.version>
-    <fest.version>1.4</fest.version>
-    <commons-io.version>2.4</commons-io.version>
-    <mockito.version>1.9.5</mockito.version>
-  </properties>
-
-  <scm>
-    <url>http://github.com/square/tape</url>
-    <connection>scm:git:git://github.com/square/tape.git</connection>
-    <developerConnection>scm:git:git@github.com:square/tape.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <organization>
-    <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
-  </organization>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/square/tape/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache License Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger</artifactId>
-        <version>${dagger.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>otto</artifactId>
-        <version>${otto.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.github.kevinsawicki</groupId>
-        <artifactId>http-request</artifactId>
-        <version>${http-request.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.easytesting</groupId>
-        <artifactId>fest-assert</artifactId>
-        <version>${fest.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>commons-io</groupId>
-        <artifactId>commons-io</artifactId>
-        <version>${commons-io.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.1</version>
-          <configuration>
-            <source>1.6</source>
-            <target>1.6</target>
-          </configuration>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-checkstyle-plugin</artifactId>
-          <version>2.9.1</version>
-          <configuration>
-            <failsOnError>true</failsOnError>
-            <configLocation>../checkstyle.xml</configLocation>
-            <consoleOutput>true</consoleOutput>
-          </configuration>
-          <executions>
-            <execution>
-              <phase>verify</phase>
-              <goals>
-                <goal>checkstyle</goal>
-              </goals>
-            </execution>
-          </executions>
-        </plugin>
-
-        <plugin>
-          <groupId>com.simpligility.maven.plugins</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>4.2.0</version>
-          <configuration>
-            <sdk>
-              <platform>${android.platform}</platform>
-            </sdk>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000..ad9d303
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,3 @@
+include ':tape'
+
+rootProject.name = 'tape-parent'
diff --git a/tape-sample/pom.xml b/tape-sample/pom.xml
deleted file mode 100644
index a31dee2..0000000
--- a/tape-sample/pom.xml
+++ /dev/null
@@ -1,55 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup</groupId>
-    <artifactId>tape-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <name>Tape Android Sample</name>
-  <artifactId>tape-sample</artifactId>
-  <packaging>apk</packaging>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>tape</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>otto</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.github.kevinsawicki</groupId>
-      <artifactId>http-request</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>com.simpligility.maven.plugins</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-        <extensions>true</extensions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/tape-sample/src/main/AndroidManifest.xml b/tape-sample/src/main/AndroidManifest.xml
deleted file mode 100644
index 8d33058..0000000
--- a/tape-sample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.squareup.tape.sample"
-          android:versionCode="1"
-          android:versionName="1.0">
-
-  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="16"/>
-
-  <uses-permission android:name="android.permission.INTERNET"/>
-
-  <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
-
-  <application android:icon="@drawable/icon"
-               android:label="@string/application_name"
-               android:name=".SampleApplication">
-
-    <activity android:label="@string/activity_name"
-              android:name=".SampleActivity">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.DEFAULT"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
-      </intent-filter>
-    </activity>
-
-    <service android:name=".ImageUploadTaskService"/>
-
-  </application>
-</manifest>
\ No newline at end of file
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java b/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java
deleted file mode 100644
index bb4b93e..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import com.google.gson.Gson;
-import com.squareup.tape.FileObjectQueue;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Reader;
-import java.io.Writer;
-
-/**
- * Use GSON to serialize classes to a bytes.
- * <p>
- * Note: This will only work when concrete classes are specified for {@code T}. If you want to specify an interface for
- * {@code T} then you need to also include the concrete class name in the serialized byte array so that you can
- * deserialize to the appropriate type.
- */
-public class GsonConverter<T> implements FileObjectQueue.Converter<T> {
-  private final Gson gson;
-  private final Class<T> type;
-
-  public GsonConverter(Gson gson, Class<T> type) {
-    this.gson = gson;
-    this.type = type;
-  }
-
-  @Override public T from(byte[] bytes) {
-    Reader reader = new InputStreamReader(new ByteArrayInputStream(bytes));
-    return gson.fromJson(reader, type);
-  }
-
-  @Override public void toStream(T object, OutputStream bytes) throws IOException {
-    Writer writer = new OutputStreamWriter(bytes);
-    gson.toJson(object, writer);
-    writer.close();
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadQueueSizeEvent.java b/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadQueueSizeEvent.java
deleted file mode 100644
index e3397cd..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadQueueSizeEvent.java
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-public class ImageUploadQueueSizeEvent {
-  public final int size;
-
-  public ImageUploadQueueSizeEvent(int size) {
-    this.size = size;
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadSuccessEvent.java b/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadSuccessEvent.java
deleted file mode 100644
index e3dedb4..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadSuccessEvent.java
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-public class ImageUploadSuccessEvent {
-  public final String url;
-
-  public ImageUploadSuccessEvent(String url) {
-    this.url = url;
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTask.java b/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTask.java
deleted file mode 100644
index 749406a..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTask.java
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.util.Log;
-import com.github.kevinsawicki.http.HttpRequest;
-import com.squareup.tape.Task;
-
-import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static com.github.kevinsawicki.http.HttpRequest.post;
-
-/** Uploads the specified file to imgur.com. */
-public class ImageUploadTask implements Task<ImageUploadTask.Callback> {
-  private static final long serialVersionUID = 126142781146165256L;
-
-  private static final String TAG = "Tape:ImageUploadTask";
-  private static final String IMGUR_API_KEY = "74e20e836f0307a90683c4643a2b656e";
-  private static final String IMGUR_UPLOAD_URL = "http://api.imgur.com/2/upload";
-  private static final Pattern IMGUR_URL_REGEX = Pattern.compile("<imgur_page>(.+?)</imgur_page>");
-  private static final Handler MAIN_THREAD = new Handler(Looper.getMainLooper());
-
-  public interface Callback {
-    void onSuccess(String url);
-    void onFailure();
-  }
-
-  private final File file;
-
-  public ImageUploadTask(File file) {
-    this.file = file;
-  }
-
-  @Override public void execute(final Callback callback) {
-    // Image uploading is slow. Execute HTTP POST on a background thread.
-    new Thread(new Runnable() {
-      @Override public void run() {
-        try {
-          HttpRequest request = post(IMGUR_UPLOAD_URL)
-              .part("key", IMGUR_API_KEY)
-              .part("image", file);
-
-          if (request.ok()) {
-            Matcher m = IMGUR_URL_REGEX.matcher(request.body());
-            m.find();
-            final String url = m.group(1);
-            Log.i(TAG, "Upload success! " + url);
-
-            // Get back to the main thread before invoking a callback.
-            MAIN_THREAD.post(new Runnable() {
-              @Override public void run() {
-                callback.onSuccess(url);
-              }
-            });
-          } else {
-            Log.i(TAG, "Upload failed :(  Will retry.");
-
-            // Get back to the main thread before invoking a callback.
-            MAIN_THREAD.post(new Runnable() {
-              @Override public void run() {
-                callback.onFailure();
-              }
-            });
-          }
-        } catch (RuntimeException e) {
-          e.printStackTrace();
-          throw e;
-        }
-      }
-    }).start();
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskQueue.java b/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskQueue.java
deleted file mode 100644
index cabc987..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskQueue.java
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import android.content.Context;
-import android.content.Intent;
-import com.google.gson.Gson;
-import com.squareup.otto.Bus;
-import com.squareup.otto.Produce;
-import com.squareup.tape.FileObjectQueue;
-import com.squareup.tape.FileObjectQueue.Converter;
-import com.squareup.tape.ObjectQueue;
-import com.squareup.tape.TaskQueue;
-
-import java.io.File;
-import java.io.IOException;
-
-public class ImageUploadTaskQueue extends TaskQueue<ImageUploadTask> {
-  private static final String FILENAME = "image_upload_task_queue";
-
-  private final Context context;
-  private final Bus bus;
-
-  private ImageUploadTaskQueue(ObjectQueue<ImageUploadTask> delegate, Context context, Bus bus) {
-    super(delegate);
-    this.context = context;
-    this.bus = bus;
-    bus.register(this);
-
-    if (size() > 0) {
-      startService();
-    }
-  }
-
-  private void startService() {
-    context.startService(new Intent(context, ImageUploadTaskService.class));
-  }
-
-  @Override public void add(ImageUploadTask entry) {
-    super.add(entry);
-    bus.post(produceSizeChanged());
-    startService();
-  }
-
-  @Override public void remove() {
-    super.remove();
-    bus.post(produceSizeChanged());
-  }
-
-  @SuppressWarnings("UnusedDeclaration") // Used by event bus.
-  @Produce public ImageUploadQueueSizeEvent produceSizeChanged() {
-    return new ImageUploadQueueSizeEvent(size());
-  }
-
-  public static ImageUploadTaskQueue create(Context context, Gson gson, Bus bus) {
-    Converter<ImageUploadTask> converter = new GsonConverter<ImageUploadTask>(gson, ImageUploadTask.class);
-    File queueFile = new File(context.getFilesDir(), FILENAME);
-    FileObjectQueue<ImageUploadTask> delegate;
-    try {
-      delegate = new FileObjectQueue<ImageUploadTask>(queueFile, converter);
-    } catch (IOException e) {
-      throw new RuntimeException("Unable to create file queue.", e);
-    }
-    return new ImageUploadTaskQueue(delegate, context, bus);
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskService.java b/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskService.java
deleted file mode 100644
index af36bc8..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/ImageUploadTaskService.java
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-import android.util.Log;
-import com.squareup.otto.Bus;
-import com.squareup.tape.sample.ImageUploadTask.Callback;
-
-import javax.inject.Inject;
-
-public class ImageUploadTaskService extends Service implements Callback {
-  private static final String TAG = "Tape:ImageUploadTaskService";
-
-  @Inject ImageUploadTaskQueue queue;
-  @Inject Bus bus;
-
-  private boolean running;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    ((SampleApplication) getApplication()).inject(this);
-    Log.i(TAG, "Service starting!");
-  }
-
-  @Override public int onStartCommand(Intent intent, int flags, int startId) {
-    executeNext();
-    return START_STICKY;
-  }
-
-  private void executeNext() {
-    if (running) return; // Only one task at a time.
-
-    ImageUploadTask task = queue.peek();
-    if (task != null) {
-      running = true;
-      task.execute(this);
-    } else {
-      Log.i(TAG, "Service stopping!");
-      stopSelf(); // No more tasks are present. Stop.
-    }
-  }
-
-  @Override public void onSuccess(final String url) {
-    running = false;
-    queue.remove();
-    bus.post(new ImageUploadSuccessEvent(url));
-    executeNext();
-  }
-
-  @Override public void onFailure() {
-  }
-
-  @Override public IBinder onBind(Intent intent) {
-    return null;
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/SampleActivity.java b/tape-sample/src/main/java/com/squareup/tape/sample/SampleActivity.java
deleted file mode 100644
index 7a8dbac..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/SampleActivity.java
+++ /dev/null
@@ -1,92 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.database.Cursor;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-import com.squareup.otto.Bus;
-import com.squareup.otto.Subscribe;
-
-import javax.inject.Inject;
-import java.io.File;
-
-import static android.content.Intent.ACTION_PICK;
-import static android.provider.MediaStore.MediaColumns.DATA;
-import static android.widget.Toast.LENGTH_SHORT;
-
-public class SampleActivity extends Activity {
-  private static final int PICK_IMAGE = 4 + 8 + 15 + 16 + 23 + 42;
-
-  @Inject ImageUploadTaskQueue queue; // NOTE: Injection starts queue processing!
-  @Inject Bus bus;
-
-  private TextView status;
-  private ArrayAdapter<String> uploads;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    ((SampleApplication) getApplication()).inject(this);
-
-    setContentView(R.layout.sample_activity);
-
-    // Status text reports number of pending uploads in the queue.
-    status = (TextView) findViewById(R.id.status);
-
-    // Hook up adapter to list of uploaded images.
-    uploads = new ArrayAdapter<String>(this, R.layout.upload, android.R.id.text1);
-    ListView uploadList = (ListView) findViewById(R.id.uploads);
-    uploadList.setAdapter(uploads);
-
-    // Upload button delegates to the gallery for selecting an image.
-    findViewById(R.id.upload).setOnClickListener(new OnClickListener() {
-      @Override public void onClick(View view) {
-        Intent pickImageIntent = new Intent(ACTION_PICK);
-        pickImageIntent.setType("image/*");
-        startActivityForResult(pickImageIntent, PICK_IMAGE);
-      }
-    });
-  }
-
-  @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-    if (requestCode == PICK_IMAGE && resultCode == RESULT_OK) {
-      // Fetch the path to the selected image.
-      Cursor cursor = getContentResolver().query(data.getData(), new String[] { DATA }, null, null, null);
-      cursor.moveToFirst();
-      File image = new File(cursor.getString(cursor.getColumnIndex(DATA)));
-      cursor.close();
-
-      // Add the image upload task to the queue.
-      queue.add(new ImageUploadTask(image));
-      Toast.makeText(this, R.string.task_added, LENGTH_SHORT).show();
-    }
-  }
-
-  @SuppressWarnings("UnusedDeclaration") // Used by event bus.
-  @Subscribe public void onQueueSizeChanged(ImageUploadQueueSizeEvent event) {
-    status.setText(getString(R.string.status, event.size));
-  }
-
-  @SuppressWarnings("UnusedDeclaration") // Used by event bus.
-  @Subscribe public void onUploadSuccess(ImageUploadSuccessEvent event) {
-    Toast.makeText(this, R.string.task_completed, LENGTH_SHORT).show();
-    uploads.add(event.url);
-  }
-
-  @Override protected void onResume() {
-    super.onResume();
-    bus.register(this); // Register for events when we are becoming the active activity.
-  }
-
-  @Override protected void onPause() {
-    super.onPause();
-    bus.unregister(this); // Unregister from events when we are no longer active.
-  }
-}
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/SampleApplication.java b/tape-sample/src/main/java/com/squareup/tape/sample/SampleApplication.java
deleted file mode 100644
index 29e922b..0000000
--- a/tape-sample/src/main/java/com/squareup/tape/sample/SampleApplication.java
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape.sample;
-
-import android.app.Application;
-import android.content.Context;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.squareup.otto.Bus;
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-
-import javax.inject.Singleton;
-
-public class SampleApplication extends Application {
-  private ObjectGraph objectGraph;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    objectGraph = ObjectGraph.create(new SampleModule(this));
-  }
-
-  public void inject(Object object) {
-    objectGraph.inject(object);
-  }
-
-  @Module(
-      entryPoints = {
-          SampleActivity.class, //
-          ImageUploadTaskQueue.class, //
-          ImageUploadTaskService.class //
-      }
-  )
-  static class SampleModule {
-    private final Context appContext;
-
-    SampleModule(Context appContext) {
-      this.appContext = appContext;
-    }
-
-    @Provides @Singleton ImageUploadTaskQueue provideTaskQueue(Gson gson, Bus bus) {
-      return ImageUploadTaskQueue.create(appContext, gson, bus);
-    }
-
-    @Provides @Singleton Bus provideBus() {
-      return new Bus();
-    }
-
-    @Provides @Singleton Gson provideGson() {
-      return new GsonBuilder().create();
-    }
-  }
-}
diff --git a/tape-sample/src/main/res/drawable-hdpi/icon.png b/tape-sample/src/main/res/drawable-hdpi/icon.png
deleted file mode 100644
index c22836b..0000000
Binary files a/tape-sample/src/main/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/tape-sample/src/main/res/drawable-mdpi/icon.png b/tape-sample/src/main/res/drawable-mdpi/icon.png
deleted file mode 100644
index 02b876a..0000000
Binary files a/tape-sample/src/main/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/tape-sample/src/main/res/drawable-xhdpi/icon.png b/tape-sample/src/main/res/drawable-xhdpi/icon.png
deleted file mode 100644
index 5b467bc..0000000
Binary files a/tape-sample/src/main/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/tape-sample/src/main/res/layout/sample_activity.xml b/tape-sample/src/main/res/layout/sample_activity.xml
deleted file mode 100644
index a9833ab..0000000
--- a/tape-sample/src/main/res/layout/sample_activity.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent"
-              android:padding="8dp"
-              android:gravity="center_horizontal">
-  <Button
-      android:id="@+id/upload"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:textSize="24sp"
-      android:text="@string/upload"
-      />
-  <TextView
-      android:id="@+id/status"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:layout_marginTop="20dp"
-      android:textSize="16sp"
-      />
-  <ListView
-      android:id="@+id/uploads"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:layout_marginTop="20dp"
-      />
-</LinearLayout>
\ No newline at end of file
diff --git a/tape-sample/src/main/res/layout/upload.xml b/tape-sample/src/main/res/layout/upload.xml
deleted file mode 100644
index 943ef6e..0000000
--- a/tape-sample/src/main/res/layout/upload.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<TextView xmlns:android="http://schemas.android.com/apk/res/android"
-          android:id="@android:id/text1"
-          android:layout_width="match_parent"
-          android:layout_height="match_parent"
-          android:padding="10dp"
-          android:textSize="16sp"
-          android:autoLink="web"/>
\ No newline at end of file
diff --git a/tape-sample/src/main/res/values/strings.xml b/tape-sample/src/main/res/values/strings.xml
deleted file mode 100644
index 63095e8..0000000
--- a/tape-sample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<resources>
-  <string name="activity_name">Tape</string>
-  <string name="application_name">Tape Sample</string>
-  <string name="upload">Upload Image</string>
-  <string name="status">%s uploads pending.</string>
-  <string name="task_added">Added new upload task.</string>
-  <string name="task_completed">An upload task completed.</string>
-</resources>
diff --git a/tape/build.gradle b/tape/build.gradle
new file mode 100644
index 0000000..6a7be58
--- /dev/null
+++ b/tape/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java'
+apply plugin: 'checkstyle'
+
+targetCompatibility = JavaVersion.VERSION_1_7
+sourceCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  testCompile 'junit:junit:4.12'
+  testCompile 'com.google.truth:truth:0.32'
+  testCompile 'com.squareup.burst:burst-junit4:1.1.1'
+  testCompile 'com.squareup.okio:okio:1.11.0'
+}
+
+checkstyle {
+  configFile rootProject.file('checkstyle.xml')
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/tape/gradle.properties b/tape/gradle.properties
new file mode 100644
index 0000000..25ed8c5
--- /dev/null
+++ b/tape/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Tape
+POM_ARTIFACT_ID=tape
+POM_PACKAGING=jar
diff --git a/tape/pom.xml b/tape/pom.xml
deleted file mode 100644
index df806d6..0000000
--- a/tape/pom.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup</groupId>
-    <artifactId>tape-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <name>Tape</name>
-  <artifactId>tape</artifactId>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>commons-io</groupId>
-      <artifactId>commons-io</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/tape/src/main/java/com/squareup/tape/FileException.java b/tape/src/main/java/com/squareup/tape/FileException.java
deleted file mode 100644
index e08c741..0000000
--- a/tape/src/main/java/com/squareup/tape/FileException.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import java.io.File;
-import java.io.IOException;
-
-/** Encapsulates an {@link IOException} in an extension of {@link RuntimeException}. */
-public class FileException extends RuntimeException {
-  private final File file;
-
-  public FileException(String message, IOException e, File file) {
-    super(message, e);
-    this.file = file;
-  }
-
-  public File getFile() {
-    return file;
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/FileObjectQueue.java b/tape/src/main/java/com/squareup/tape/FileObjectQueue.java
deleted file mode 100644
index 2c70b48..0000000
--- a/tape/src/main/java/com/squareup/tape/FileObjectQueue.java
+++ /dev/null
@@ -1,171 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.List;
-
-import static java.util.Collections.unmodifiableList;
-
-/**
- * Base queue class, implements common functionality for a QueueFile-backed
- * queue manager.  This class is not thread safe; instances should be kept
- * thread-confined.
- * <p>
- * The {@link #add( Object )}, {@link #peek()}, {@link #remove()}, and
- * {@link #setListener(ObjectQueue.Listener)} methods may throw a
- * {@link FileException} if the underlying {@link QueueFile} experiences an
- * {@link java.io.IOException}.
- *
- * @param <T> The type of elements in the queue.
- */
-public class FileObjectQueue<T> implements ObjectQueue<T> {
-  /** Backing storage implementation. */
-  private final QueueFile queueFile;
-  /** Reusable byte output buffer. */
-  private final DirectByteArrayOutputStream bytes = new DirectByteArrayOutputStream();
-  /** Keep file around for error reporting. */
-  private final File file;
-  private final Converter<T> converter;
-  private Listener<T> listener;
-
-  public FileObjectQueue(File file, Converter<T> converter) throws IOException {
-    this.file = file;
-    this.converter = converter;
-    this.queueFile = new QueueFile(file);
-  }
-
-  @Override public int size() {
-    return queueFile.size();
-  }
-
-  @Override public final void add(T entry) {
-    try {
-      bytes.reset();
-      converter.toStream(entry, bytes);
-      queueFile.add(bytes.getArray(), 0, bytes.size());
-      if (listener != null) listener.onAdd(this, entry);
-    } catch (IOException e) {
-      throw new FileException("Failed to add entry.", e, file);
-    }
-  }
-
-  @Override public T peek() {
-    try {
-      byte[] bytes = queueFile.peek();
-      if (bytes == null) return null;
-      return converter.from(bytes);
-    } catch (IOException e) {
-      throw new FileException("Failed to peek.", e, file);
-    }
-  }
-
-  /**
-   * Reads up to {@code max} entries from the head of the queue without removing the entries.
-   * If the queue's {@link #size()} is less than {@code max} then only {@link #size()} entries
-   * are read.
-   */
-  public List<T> peek(final int max) {
-    try {
-      final List<T> entries = new ArrayList<T>(max);
-      queueFile.forEach(new QueueFile.ElementVisitor() {
-        int count;
-        @Override public boolean read(InputStream in, int length) throws IOException {
-          byte[] data = new byte[length];
-          in.read(data, 0, length);
-
-          entries.add(converter.from(data));
-          return ++count < max;
-        }
-      });
-      return unmodifiableList(entries);
-    } catch (IOException e) {
-      throw new FileException("Failed to peek.", e, file);
-    }
-  }
-
-  public List<T> asList() {
-    return peek(size());
-  }
-
-  @Override public final void remove() {
-    try {
-      queueFile.remove();
-      if (listener != null) listener.onRemove(this);
-    } catch (IOException e) {
-      throw new FileException("Failed to remove.", e, file);
-    }
-  }
-
-  public final void remove(int n) throws IOException {
-    try {
-      queueFile.remove(n);
-      if (listener != null) {
-        for (int i = 0; i < n; i++) {
-          listener.onRemove(this);
-        }
-      }
-    } catch (IOException e) {
-      throw new FileException("Failed to remove.", e, file);
-    }
-  }
-
-  public final void close() {
-    try {
-      queueFile.close();
-    } catch (IOException e) {
-      throw new FileException("Failed to close.", e, file);
-    }
-  }
-
-  @Override public void setListener(final Listener<T> listener) {
-    if (listener != null) {
-      try {
-        queueFile.forEach(new QueueFile.ElementVisitor() {
-          @Override public boolean read(InputStream in, int length) throws IOException {
-            byte[] data = new byte[length];
-            in.read(data, 0, length);
-
-            listener.onAdd(FileObjectQueue.this, converter.from(data));
-            return true;
-          }
-        });
-      } catch (IOException e) {
-        throw new FileException("Unable to iterate over QueueFile contents.", e, file);
-      }
-    }
-    this.listener = listener;
-  }
-
-  /**
-   * Convert a byte stream to and from a concrete type.
-   *
-   * @param <T> Object type.
-   */
-  public interface Converter<T> {
-    /** Converts bytes to an object. */
-    T from(byte[] bytes) throws IOException;
-
-    /** Converts o to bytes written to the specified stream. */
-    void toStream(T o, OutputStream bytes) throws IOException;
-  }
-
-  /** Enables direct access to the internal array. Avoids unnecessary copying. */
-  private static class DirectByteArrayOutputStream extends ByteArrayOutputStream {
-    public DirectByteArrayOutputStream() {
-      super();
-    }
-
-    /**
-     * Gets a reference to the internal byte array.  The {@link #size()} method indicates how many
-     * bytes contain actual data added since the last {@link #reset()} call.
-     */
-    public byte[] getArray() {
-      return buf;
-    }
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/InMemoryObjectQueue.java b/tape/src/main/java/com/squareup/tape/InMemoryObjectQueue.java
deleted file mode 100644
index 42e14c3..0000000
--- a/tape/src/main/java/com/squareup/tape/InMemoryObjectQueue.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * A queue for objects that are not serious enough to be written to disk.  Objects in this queue
- * are kept in memory and will not be serialized.
- *
- * @param <T> The type of elements in the queue.
- */
-public class InMemoryObjectQueue<T> implements ObjectQueue<T> {
-  private final Queue<T> tasks;
-  private Listener<T> listener;
-
-  @SuppressWarnings("unchecked")
-  public InMemoryObjectQueue() {
-    tasks = (Queue<T>) new LinkedList();
-  }
-
-  @Override public void add(T entry) {
-    tasks.add(entry);
-    if (listener != null) listener.onAdd(this, entry);
-  }
-
-  @Override public T peek() {
-    return tasks.peek();
-  }
-
-  @Override public int size() {
-    return tasks.size();
-  }
-
-  @Override public void remove() {
-    tasks.remove();
-    if (listener != null) listener.onRemove(this);
-  }
-
-  @Override public void setListener(Listener<T> listener) {
-    if (listener != null) {
-      for (T task : tasks) {
-        listener.onAdd(this, task);
-      }
-    }
-    this.listener = listener;
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/ObjectQueue.java b/tape/src/main/java/com/squareup/tape/ObjectQueue.java
deleted file mode 100644
index 6eb8b25..0000000
--- a/tape/src/main/java/com/squareup/tape/ObjectQueue.java
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2011 Square, Inc.
-package com.squareup.tape;
-
-/**
- * A queue of objects.
- *
- * @param <T> The type of queue for the elements.
- */
-public interface ObjectQueue<T> {
-
-  /** Returns the number of entries in the queue. */
-  int size();
-
-  /** Enqueues an entry that can be processed at any time. */
-  void add(T entry);
-
-  /**
-   * Returns the head of the queue, or {@code null} if the queue is empty. Does not modify the
-   * queue.
-   */
-  T peek();
-
-  /** Removes the head of the queue. */
-  void remove();
-
-  /**
-   * Sets a listener on this queue. Invokes {@link Listener#onAdd} once for each entry that's
-   * already in the queue. If an error occurs while reading the data, the listener will not receive
-   * further notifications.
-   */
-  void setListener(Listener<T> listener);
-
-  /**
-   * Listens for changes to the queue.
-   *
-   * @param <T> The type of elements in the queue.
-   */
-  public interface Listener<T> {
-
-    /** Called after an entry is added. */
-    void onAdd(ObjectQueue<T> queue, T entry);
-
-    /** Called after an entry is removed. */
-    void onRemove(ObjectQueue<T> queue);
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/QueueFile.java b/tape/src/main/java/com/squareup/tape/QueueFile.java
deleted file mode 100644
index 71103de..0000000
--- a/tape/src/main/java/com/squareup/tape/QueueFile.java
+++ /dev/null
@@ -1,673 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.tape;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.RandomAccessFile;
-import java.nio.channels.FileChannel;
-import java.util.NoSuchElementException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static java.lang.Math.min;
-
-/**
- * A reliable, efficient, file-based, FIFO queue. Additions and removals are O(1). All operations
- * are atomic. Writes are synchronous; data will be written to disk before an operation returns.
- * The underlying file is structured to survive process and even system crashes. If an I/O
- * exception is thrown during a mutating change, the change is aborted. It is safe to continue to
- * use a {@code QueueFile} instance after an exception.
- *
- * <p>All operations are synchronized. In a traditional queue, the remove operation returns an
- * element. In this queue, {@link #peek} and {@link #remove} are used in conjunction. Use
- * {@code peek} to retrieve the first element, and then {@code remove} to remove it after
- * successful processing. If the system crashes after {@code peek} and during processing, the
- * element will remain in the queue, to be processed when the system restarts.
- *
- * <p><strong>NOTE:</strong> The current implementation is built for file systems that support
- * atomic segment writes (like YAFFS). Most conventional file systems don't support this; if the
- * power goes out while writing a segment, the segment will contain garbage and the file will be
- * corrupt. We'll add journaling support so this class can be used with more file systems later.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class QueueFile implements Closeable {
-  private static final Logger LOGGER = Logger.getLogger(QueueFile.class.getName());
-
-  /** Initial file size in bytes. */
-  private static final int INITIAL_LENGTH = 4096; // one file system block
-
-  /** A block of nothing to write over old data. */
-  private static final byte[] ZEROES = new byte[INITIAL_LENGTH];
-
-  /** Length of header in bytes. */
-  static final int HEADER_LENGTH = 16;
-
-  /**
-   * The underlying file. Uses a ring buffer to store entries. Designed so that a modification
-   * isn't committed or visible until we write the header. The header is much smaller than a
-   * segment. So long as the underlying file system supports atomic segment writes, changes to the
-   * queue are atomic. Storing the file length ensures we can recover from a failed expansion
-   * (i.e. if setting the file length succeeds but the process dies before the data can be copied).
-   * <p/>
-   * <pre>
-   *   Format:
-   *     Header              (16 bytes)
-   *     Element Ring Buffer (File Length - 16 bytes)
-   * <p/>
-   *   Header:
-   *     File Length            (4 bytes)
-   *     Element Count          (4 bytes)
-   *     First Element Position (4 bytes, =0 if null)
-   *     Last Element Position  (4 bytes, =0 if null)
-   * <p/>
-   *   Element:
-   *     Length (4 bytes)
-   *     Data   (Length bytes)
-   * </pre>
-   *
-   * Visible for testing.
-   */
-  final RandomAccessFile raf;
-
-  /** Cached file length. Always a power of 2. */
-  int fileLength;
-
-  /** Number of elements. */
-  private int elementCount;
-
-  /** Pointer to first (or eldest) element. */
-  private Element first;
-
-  /** Pointer to last (or newest) element. */
-  private Element last;
-
-  /** In-memory buffer. Big enough to hold the header. */
-  private final byte[] buffer = new byte[16];
-
-  /**
-   * Constructs a new queue backed by the given file. Only one instance should access a given file
-   * at a time.
-   */
-  public QueueFile(File file) throws IOException {
-    if (!file.exists()) {
-      initialize(file);
-    }
-    raf = open(file);
-    readHeader();
-  }
-
-  QueueFile(RandomAccessFile raf) throws IOException {
-    this.raf = raf;
-    readHeader();
-  }
-
-  /**
-   * Stores an {@code int} in the {@code byte[]}. The behavior is equivalent to calling
-   * {@link RandomAccessFile#writeInt}.
-   */
-  private static void writeInt(byte[] buffer, int offset, int value) {
-    buffer[offset] = (byte) (value >> 24);
-    buffer[offset + 1] = (byte) (value >> 16);
-    buffer[offset + 2] = (byte) (value >> 8);
-    buffer[offset + 3] = (byte) value;
-  }
-
-  /** Reads an {@code int} from the {@code byte[]}. */
-  private static int readInt(byte[] buffer, int offset) {
-    return ((buffer[offset] & 0xff) << 24)
-        + ((buffer[offset + 1] & 0xff) << 16)
-        + ((buffer[offset + 2] & 0xff) << 8)
-        + (buffer[offset + 3] & 0xff);
-  }
-
-  private void readHeader() throws IOException {
-    raf.seek(0);
-    raf.readFully(buffer);
-    fileLength = readInt(buffer, 0);
-    if (fileLength > raf.length()) {
-      throw new IOException(
-          "File is truncated. Expected length: " + fileLength + ", Actual length: " + raf.length());
-    } else if (fileLength <= 0) {
-      throw new IOException(
-          "File is corrupt; length stored in header (" + fileLength + ") is invalid.");
-    }
-    elementCount = readInt(buffer, 4);
-    int firstOffset = readInt(buffer, 8);
-    int lastOffset = readInt(buffer, 12);
-    first = readElement(firstOffset);
-    last = readElement(lastOffset);
-  }
-
-  /**
-   * Writes header atomically. The arguments contain the updated values. The class member fields
-   * should not have changed yet. This only updates the state in the file. It's up to the caller to
-   * update the class member variables *after* this call succeeds. Assumes segment writes are
-   * atomic in the underlying file system.
-   */
-  private void writeHeader(int fileLength, int elementCount, int firstPosition, int lastPosition)
-      throws IOException {
-    writeInt(buffer, 0, fileLength);
-    writeInt(buffer, 4, elementCount);
-    writeInt(buffer, 8, firstPosition);
-    writeInt(buffer, 12, lastPosition);
-    raf.seek(0);
-    raf.write(buffer);
-  }
-
-  private Element readElement(int position) throws IOException {
-    if (position == 0) return Element.NULL;
-    ringRead(position, buffer, 0, Element.HEADER_LENGTH);
-    int length = readInt(buffer, 0);
-    return new Element(position, length);
-  }
-
-  private static void initialize(File file) throws IOException {
-    // Use a temp file so we don't leave a partially-initialized file.
-    File tempFile = new File(file.getPath() + ".tmp");
-    RandomAccessFile raf = open(tempFile);
-    try {
-      raf.setLength(INITIAL_LENGTH);
-      raf.seek(0);
-      byte[] headerBuffer = new byte[16];
-      writeInt(headerBuffer, 0, INITIAL_LENGTH);
-      raf.write(headerBuffer);
-    } finally {
-      raf.close();
-    }
-
-    // A rename is atomic.
-    if (!tempFile.renameTo(file)) {
-      throw new IOException("Rename failed!");
-    }
-  }
-
-  /** Opens a random access file that writes synchronously. */
-  private static RandomAccessFile open(File file) throws FileNotFoundException {
-    return new RandomAccessFile(file, "rwd");
-  }
-
-  /** Wraps the position if it exceeds the end of the file. */
-  private int wrapPosition(int position) {
-    return position < fileLength ? position
-        : HEADER_LENGTH + position - fileLength;
-  }
-
-  /**
-   * Writes count bytes from buffer to position in file. Automatically wraps write if position is
-   * past the end of the file or if buffer overlaps it.
-   *
-   * @param position in file to write to
-   * @param buffer to write from
-   * @param count # of bytes to write
-   */
-  private void ringWrite(int position, byte[] buffer, int offset, int count) throws IOException {
-    position = wrapPosition(position);
-    if (position + count <= fileLength) {
-      raf.seek(position);
-      raf.write(buffer, offset, count);
-    } else {
-      // The write overlaps the EOF.
-      // # of bytes to write before the EOF.
-      int beforeEof = fileLength - position;
-      raf.seek(position);
-      raf.write(buffer, offset, beforeEof);
-      raf.seek(HEADER_LENGTH);
-      raf.write(buffer, offset + beforeEof, count - beforeEof);
-    }
-  }
-
-  private void ringErase(int position, int length) throws IOException {
-    while (length > 0) {
-      int chunk = min(length, ZEROES.length);
-      ringWrite(position, ZEROES, 0, chunk);
-      length -= chunk;
-      position += chunk;
-    }
-  }
-
-  /**
-   * Reads count bytes into buffer from file. Wraps if necessary.
-   *
-   * @param position in file to read from
-   * @param buffer to read into
-   * @param count # of bytes to read
-   */
-  private void ringRead(int position, byte[] buffer, int offset, int count) throws IOException {
-    position = wrapPosition(position);
-    if (position + count <= fileLength) {
-      raf.seek(position);
-      raf.readFully(buffer, offset, count);
-    } else {
-      // The read overlaps the EOF.
-      // # of bytes to read before the EOF.
-      int beforeEof = fileLength - position;
-      raf.seek(position);
-      raf.readFully(buffer, offset, beforeEof);
-      raf.seek(HEADER_LENGTH);
-      raf.readFully(buffer, offset + beforeEof, count - beforeEof);
-    }
-  }
-
-  /**
-   * Adds an element to the end of the queue.
-   *
-   * @param data to copy bytes from
-   */
-  public void add(byte[] data) throws IOException {
-    add(data, 0, data.length);
-  }
-
-  /**
-   * Adds an element to the end of the queue.
-   *
-   * @param data to copy bytes from
-   * @param offset to start from in buffer
-   * @param count number of bytes to copy
-   * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code count < 0}, or if {@code
-   * offset + count} is bigger than the length of {@code buffer}.
-   */
-  public synchronized void add(byte[] data, int offset, int count) throws IOException {
-    if (data == null) {
-      throw new NullPointerException("data == null");
-    }
-    if ((offset | count) < 0 || count > data.length - offset) {
-      throw new IndexOutOfBoundsException();
-    }
-
-    expandIfNecessary(count);
-
-    // Insert a new element after the current last element.
-    boolean wasEmpty = isEmpty();
-    int position = wasEmpty ? HEADER_LENGTH
-        : wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
-    Element newLast = new Element(position, count);
-
-    // Write length.
-    writeInt(buffer, 0, count);
-    ringWrite(newLast.position, buffer, 0, Element.HEADER_LENGTH);
-
-    // Write data.
-    ringWrite(newLast.position + Element.HEADER_LENGTH, data, offset, count);
-
-    // Commit the addition. If wasEmpty, first == last.
-    int firstPosition = wasEmpty ? newLast.position : first.position;
-    writeHeader(fileLength, elementCount + 1, firstPosition, newLast.position);
-    last = newLast;
-    elementCount++;
-    if (wasEmpty) first = last; // first element
-  }
-
-  private int usedBytes() {
-    if (elementCount == 0) return HEADER_LENGTH;
-
-    if (last.position >= first.position) {
-      // Contiguous queue.
-      return (last.position - first.position)   // all but last entry
-          + Element.HEADER_LENGTH + last.length // last entry
-          + HEADER_LENGTH;
-    } else {
-      // tail < head. The queue wraps.
-      return last.position                      // buffer front + header
-          + Element.HEADER_LENGTH + last.length // last entry
-          + fileLength - first.position;        // buffer end
-    }
-  }
-
-  private int remainingBytes() {
-    return fileLength - usedBytes();
-  }
-
-  /** Returns true if this queue contains no entries. */
-  public synchronized boolean isEmpty() {
-    return elementCount == 0;
-  }
-
-  /**
-   * If necessary, expands the file to accommodate an additional element of the given length.
-   *
-   * @param dataLength length of data being added
-   */
-  private void expandIfNecessary(int dataLength) throws IOException {
-    int elementLength = Element.HEADER_LENGTH + dataLength;
-    int remainingBytes = remainingBytes();
-    if (remainingBytes >= elementLength) return;
-
-    // Expand.
-    int previousLength = fileLength;
-    int newLength;
-    // Double the length until we can fit the new data.
-    do {
-      remainingBytes += previousLength;
-      newLength = previousLength << 1;
-      previousLength = newLength;
-    } while (remainingBytes < elementLength);
-
-    setLength(newLength);
-
-    // Calculate the position of the tail end of the data in the ring buffer
-    int endOfLastElement = wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
-
-    // If the buffer is split, we need to make it contiguous
-    if (endOfLastElement <= first.position) {
-      FileChannel channel = raf.getChannel();
-      channel.position(fileLength); // destination position
-      int count = endOfLastElement - HEADER_LENGTH;
-      if (channel.transferTo(HEADER_LENGTH, count, channel) != count) {
-        throw new AssertionError("Copied insufficient number of bytes!");
-      }
-      ringErase(HEADER_LENGTH, count);
-    }
-
-    // Commit the expansion.
-    if (last.position < first.position) {
-      int newLastPosition = fileLength + last.position - HEADER_LENGTH;
-      writeHeader(newLength, elementCount, first.position, newLastPosition);
-      last = new Element(newLastPosition, last.length);
-    } else {
-      writeHeader(newLength, elementCount, first.position, last.position);
-    }
-
-    fileLength = newLength;
-  }
-
-  /** Sets the length of the file. */
-  private void setLength(int newLength) throws IOException {
-    // Set new file length (considered metadata) and sync it to storage.
-    raf.setLength(newLength);
-    raf.getChannel().force(true);
-  }
-
-  /** Reads the eldest element. Returns null if the queue is empty. */
-  public synchronized byte[] peek() throws IOException {
-    if (isEmpty()) return null;
-    int length = first.length;
-    byte[] data = new byte[length];
-    ringRead(first.position + Element.HEADER_LENGTH, data, 0, length);
-    return data;
-  }
-
-  /**
-   * Invokes reader with the eldest element, if an element is available.
-   *
-   * @deprecated use {@link #peek(ElementVisitor)}
-   */
-  @Deprecated public synchronized void peek(ElementReader reader) throws IOException {
-    if (elementCount > 0) {
-      reader.read(new ElementInputStream(first), first.length);
-    }
-  }
-
-  /** Invokes {@code visitor} with the eldest element, if an element is available. */
-  public synchronized void peek(ElementVisitor visitor) throws IOException {
-    if (elementCount > 0) {
-      visitor.read(new ElementInputStream(first), first.length);
-    }
-  }
-
-  /**
-   * Invokes the given reader once for each element in the queue, from eldest to
-   * most recently added.
-   *
-   * @deprecated use {@link #forEach(ElementVisitor)}
-   */
-  @Deprecated public synchronized void forEach(final ElementReader reader) throws IOException {
-    forEach(new ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        reader.read(in, length);
-        return true;
-      }
-    });
-  }
-
-  /**
-   * Invokes the given reader once for each element in the queue, from eldest to most recently
-   * added. Continues until all elements are read or {@link ElementVisitor#read reader.read()}
-   * returns {@code false}.
-   *
-   * @return number of elements visited
-   */
-  public synchronized int forEach(ElementVisitor reader) throws IOException {
-    int position = first.position;
-    for (int i = 0; i < elementCount; i++) {
-      Element current = readElement(position);
-      boolean shouldContinue = reader.read(new ElementInputStream(current), current.length);
-      if (!shouldContinue) {
-        return i + 1;
-      }
-      position = wrapPosition(current.position + Element.HEADER_LENGTH + current.length);
-    }
-    return elementCount;
-  }
-
-  private final class ElementInputStream extends InputStream {
-    private int position;
-    private int remaining;
-
-    private ElementInputStream(Element element) {
-      position = wrapPosition(element.position + Element.HEADER_LENGTH);
-      remaining = element.length;
-    }
-
-    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      if ((offset | length) < 0 || length > buffer.length - offset) {
-        throw new ArrayIndexOutOfBoundsException();
-      }
-      if (remaining == 0) {
-        return -1;
-      }
-      if (length > remaining) length = remaining;
-      ringRead(position, buffer, offset, length);
-      position = wrapPosition(position + length);
-      remaining -= length;
-      return length;
-    }
-
-    @Override public int read() throws IOException {
-      if (remaining == 0) return -1;
-      raf.seek(position);
-      int b = raf.read();
-      position = wrapPosition(position + 1);
-      remaining--;
-      return b;
-    }
-  }
-
-  /** Returns the number of elements in this queue. */
-  public synchronized int size() {
-    return elementCount;
-  }
-
-  /**
-   * Removes the eldest element.
-   *
-   * @throws NoSuchElementException if the queue is empty
-   */
-  public synchronized void remove() throws IOException {
-    remove(1);
-  }
-
-  /**
-   * Removes the eldest {@code n} elements.
-   *
-   * @throws NoSuchElementException if the queue is empty
-   */
-  public synchronized void remove(int n) throws IOException {
-    if (isEmpty()) {
-      throw new NoSuchElementException();
-    }
-    if (n < 0) {
-      throw new IllegalArgumentException("Cannot remove negative (" + n + ") number of elements.");
-    }
-    if (n == 0) {
-      return;
-    }
-    if (n == elementCount) {
-      clear();
-      return;
-    }
-    if (n > elementCount) {
-      throw new IllegalArgumentException(
-          "Cannot remove more elements (" + n + ") than present in queue (" + elementCount + ").");
-    }
-
-    final int eraseStartPosition = first.position;
-    int eraseTotalLength = 0;
-
-    // Read the position and length of the new first element.
-    int newFirstPosition = first.position;
-    int newFirstLength = first.length;
-    for (int i = 0; i < n; i++) {
-      eraseTotalLength += Element.HEADER_LENGTH + newFirstLength;
-      newFirstPosition = wrapPosition(newFirstPosition + Element.HEADER_LENGTH + newFirstLength);
-      ringRead(newFirstPosition, buffer, 0, Element.HEADER_LENGTH);
-      newFirstLength = readInt(buffer, 0);
-    }
-
-    // Commit the header.
-    writeHeader(fileLength, elementCount - n, newFirstPosition, last.position);
-    elementCount -= n;
-    first = new Element(newFirstPosition, newFirstLength);
-
-    // Commit the erase.
-    ringErase(eraseStartPosition, eraseTotalLength);
-  }
-
-  /** Clears this queue. Truncates the file to the initial size. */
-  public synchronized void clear() throws IOException {
-    // Commit the header.
-    writeHeader(INITIAL_LENGTH, 0, 0, 0);
-
-    // Zero out data.
-    raf.seek(HEADER_LENGTH);
-    raf.write(ZEROES, 0, INITIAL_LENGTH - HEADER_LENGTH);
-
-    elementCount = 0;
-    first = Element.NULL;
-    last = Element.NULL;
-    if (fileLength > INITIAL_LENGTH) setLength(INITIAL_LENGTH);
-    fileLength = INITIAL_LENGTH;
-  }
-
-  /** Closes the underlying file. */
-  @Override public synchronized void close() throws IOException {
-    raf.close();
-  }
-
-  @Override public String toString() {
-    final StringBuilder builder = new StringBuilder();
-    builder.append(getClass().getSimpleName()).append('[');
-    builder.append("fileLength=").append(fileLength);
-    builder.append(", size=").append(elementCount);
-    builder.append(", first=").append(first);
-    builder.append(", last=").append(last);
-    builder.append(", element lengths=[");
-    try {
-      forEach(new ElementReader() {
-        boolean first = true;
-
-        @Override public void read(InputStream in, int length) throws IOException {
-          if (first) {
-            first = false;
-          } else {
-            builder.append(", ");
-          }
-          builder.append(length);
-        }
-      });
-    } catch (IOException e) {
-      LOGGER.log(Level.WARNING, "read error", e);
-    }
-    builder.append("]]");
-    return builder.toString();
-  }
-
-  /** A pointer to an element. */
-  static class Element {
-    static final Element NULL = new Element(0, 0);
-
-    /** Length of element header in bytes. */
-    static final int HEADER_LENGTH = 4;
-
-    /** Position in file. */
-    final int position;
-
-    /** The length of the data. */
-    final int length;
-
-    /**
-     * Constructs a new element.
-     *
-     * @param position within file
-     * @param length of data
-     */
-    Element(int position, int length) {
-      this.position = position;
-      this.length = length;
-    }
-
-    @Override public String toString() {
-      return getClass().getSimpleName() + "["
-          + "position = " + position
-          + ", length = " + length + "]";
-    }
-  }
-
-  /**
-   * Reads queue elements. Enables partial reads as opposed to reading all of the bytes into a
-   * {@code byte[]}.
-   *
-   * @deprecated use {@link ElementVisitor} instead.
-   */
-  @Deprecated public interface ElementReader {
-
-    /*
-     * TODO: Support remove() call from read().
-     */
-
-    /**
-     * Called once per element.
-     *
-     * @param in stream of element data. Reads as many bytes as requested, unless fewer than the
-     * request number of bytes remains, in which case it reads all the remaining bytes. Not
-     * buffered.
-     * @param length of element data in bytes
-     */
-    void read(InputStream in, int length) throws IOException;
-  }
-
-  /**
-   * Reads queue elements. Enables partial reads as opposed to reading all of
-   * the bytes into a byte[].  Can opt to skip remaining elements.
-   */
-  public interface ElementVisitor {
-    /**
-     * Called once per element.
-     *
-     * @param in stream of element data. Reads as many bytes as requested, unless fewer than the
-     * request number of bytes remains, in which case it reads all the remaining bytes. Not
-     * buffered.
-     * @param length of element data in bytes
-     * @return an indication whether the {@link #forEach} operation should continue; If
-     * {@code true}, continue, otherwise halt.
-     */
-    boolean read(InputStream in, int length) throws IOException;
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/SerializedConverter.java b/tape/src/main/java/com/squareup/tape/SerializedConverter.java
deleted file mode 100644
index f9f17e8..0000000
--- a/tape/src/main/java/com/squareup/tape/SerializedConverter.java
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
-import java.io.Serializable;
-
-/**
- * Serialized object queue converter.
- *
- * <b>This class is not thread safe; instances should be kept thread-confined.</b>
- *
- * @param <T> Object type.
- */
-public class SerializedConverter<T extends Serializable> implements FileObjectQueue.Converter<T> {
-  /** Deserialize a stream to an object. */
-  @SuppressWarnings("unchecked")
-  private T deserialize(InputStream in) throws IOException {
-    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in, 1024));
-    T entry;
-    try {
-      entry = (T) oin.readUnshared();
-    } catch (ClassNotFoundException e) {
-      // This can only happen if we make an incompatible change.
-      throw new AssertionError(e);
-    }
-    return entry;
-  }
-
-  /** Deserialize bytes to an object. */
-  @Override public T from(byte[] bytes) throws IOException {
-    return deserialize(new ByteArrayInputStream(bytes));
-  }
-
-  /** Serializes o to bytes. */
-   @Override public void toStream(T o, OutputStream bytes) throws IOException {
-    ObjectOutputStream out = new ObjectOutputStream(bytes);
-    out.writeUnshared(o);
-    out.close();
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape/Task.java b/tape/src/main/java/com/squareup/tape/Task.java
deleted file mode 100644
index 228c84b..0000000
--- a/tape/src/main/java/com/squareup/tape/Task.java
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import java.io.Serializable;
-
-/**
- * An idempotent task that can be enqueued, persisted (using serialization),
- * and executed at a later time.
- *
- * @param <T> The type of callback.
- */
-public interface Task<T> extends Serializable {
-
-  /**
-   * Executes this task. The members of this task instance have been injected
-   * prior to calling this method.
-   *
-   * @param callback to report result to
-   */
-  void execute(T callback);
-}
diff --git a/tape/src/main/java/com/squareup/tape/TaskInjector.java b/tape/src/main/java/com/squareup/tape/TaskInjector.java
deleted file mode 100644
index d50c2a6..0000000
--- a/tape/src/main/java/com/squareup/tape/TaskInjector.java
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-/**
- * Inject dependencies into tasks of any kind.
- *
- * @param <T> The type of tasks to inject.
- */
-public interface TaskInjector<T extends Task> {
-  void injectMembers(T task);
-}
diff --git a/tape/src/main/java/com/squareup/tape/TaskQueue.java b/tape/src/main/java/com/squareup/tape/TaskQueue.java
deleted file mode 100644
index 32cb2bb..0000000
--- a/tape/src/main/java/com/squareup/tape/TaskQueue.java
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-/**
- * Persistent task queue. Not safe for concurrent use.
- *
- * @param <T> The type of tasks in the queue.
- */
-public class TaskQueue<T extends Task> implements ObjectQueue<T> {
-
-  private final TaskInjector<T> taskInjector;
-  private final ObjectQueue<T> delegate;
-
-  public TaskQueue(ObjectQueue<T> delegate) {
-    this(delegate, null);
-  }
-
-  public TaskQueue(ObjectQueue<T> delegate, TaskInjector<T> taskInjector) {
-    this.delegate = delegate;
-    this.taskInjector = taskInjector;
-  }
-
-  /**
-   * {@inheritDoc}
-   *
-   * Overridden to inject members into Tasks.
-   */
-  @Override public T peek() {
-    T task = delegate.peek();
-    if (task != null && taskInjector != null) {
-      taskInjector.injectMembers(task);
-    }
-    return task;
-  }
-
-  @Override public int size() {
-    return delegate.size();
-  }
-
-  @Override public void add(T entry) {
-    delegate.add(entry);
-  }
-
-  @Override public void remove() {
-    delegate.remove();
-  }
-
-  @Override public void setListener(final Listener<T> listener) {
-    if (listener != null) {
-      // Intercept event delivery to pass the correct TaskQueue instance to listener.
-      delegate.setListener(new Listener<T>() {
-        @Override
-        public void onAdd(ObjectQueue<T> queue, T entry) {
-          listener.onAdd(TaskQueue.this, entry);
-        }
-
-        @Override
-        public void onRemove(ObjectQueue<T> queue) {
-          listener.onRemove(TaskQueue.this);
-        }
-      });
-    } else {
-      delegate.setListener(null);
-    }
-  }
-}
diff --git a/tape/src/main/java/com/squareup/tape2/FileObjectQueue.java b/tape/src/main/java/com/squareup/tape2/FileObjectQueue.java
new file mode 100644
index 0000000..3dd112c
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/FileObjectQueue.java
@@ -0,0 +1,112 @@
+// Copyright 2012 Square, Inc.
+package com.squareup.tape2;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Iterator;
+
+final class FileObjectQueue<T> extends ObjectQueue<T> {
+  /** Backing storage implementation. */
+  private final QueueFile queueFile;
+  /** Reusable byte output buffer. */
+  private final DirectByteArrayOutputStream bytes = new DirectByteArrayOutputStream();
+  @Private final Converter<T> converter;
+
+  FileObjectQueue(QueueFile queueFile, Converter<T> converter) {
+    this.queueFile = queueFile;
+    this.converter = converter;
+  }
+
+  @Override public QueueFile file() {
+    return queueFile;
+  }
+
+  @Override public int size() {
+    return queueFile.size();
+  }
+
+  @Override public boolean isEmpty() {
+    return queueFile.isEmpty();
+  }
+
+  @Override public void add(T entry) throws IOException {
+    bytes.reset();
+    converter.toStream(entry, bytes);
+    queueFile.add(bytes.getArray(), 0, bytes.size());
+  }
+
+  @Override public T peek() throws IOException {
+    byte[] bytes = queueFile.peek();
+    if (bytes == null) return null;
+    return converter.from(bytes);
+  }
+
+  @Override public void remove() throws IOException {
+    queueFile.remove();
+  }
+
+  @Override public void remove(int n) throws IOException {
+    queueFile.remove(n);
+  }
+
+  @Override public void clear() throws IOException {
+    queueFile.clear();
+  }
+
+  @Override public void close() throws IOException {
+    queueFile.close();
+  }
+
+  /**
+   * Returns an iterator over entries in this queue.
+   *
+   * <p>The iterator disallows modifications to the queue during iteration. Removing entries from
+   * the head of the queue is permitted during iteration using {@link Iterator#remove()}.
+   *
+   * <p>The iterator may throw an unchecked {@link RuntimeException} during {@link Iterator#next()}
+   * or {@link Iterator#remove()}.
+   */
+  @Override public Iterator<T> iterator() {
+    return new QueueFileIterator(queueFile.iterator());
+  }
+
+  private final class QueueFileIterator implements Iterator<T> {
+    final Iterator<byte[]> iterator;
+
+    @Private QueueFileIterator(Iterator<byte[]> iterator) {
+      this.iterator = iterator;
+    }
+
+    @Override public boolean hasNext() {
+      return iterator.hasNext();
+    }
+
+    @Override public T next() {
+      byte[] data = iterator.next();
+      try {
+        return converter.from(data);
+      } catch (IOException e) {
+        throw new RuntimeException("todo: throw a proper error", e);
+      }
+    }
+
+    @Override public void remove() {
+      iterator.remove();
+    }
+  }
+
+  /** Enables direct access to the internal array. Avoids unnecessary copying. */
+  private static class DirectByteArrayOutputStream extends ByteArrayOutputStream {
+    public DirectByteArrayOutputStream() {
+      super();
+    }
+
+    /**
+     * Gets a reference to the internal byte array.  The {@link #size()} method indicates how many
+     * bytes contain actual data added since the last {@link #reset()} call.
+     */
+    public byte[] getArray() {
+      return buf;
+    }
+  }
+}
diff --git a/tape/src/main/java/com/squareup/tape2/InMemoryObjectQueue.java b/tape/src/main/java/com/squareup/tape2/InMemoryObjectQueue.java
new file mode 100644
index 0000000..7b0b483
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/InMemoryObjectQueue.java
@@ -0,0 +1,123 @@
+// Copyright 2012 Square, Inc.
+package com.squareup.tape2;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+final class InMemoryObjectQueue<T> extends ObjectQueue<T> {
+  private final Deque<T> entries;
+  /**
+   * The number of times this file has been structurally modified — it is incremented during {@link
+   * #remove(int)} and {@link #add(Object)}. Used by {@link InMemoryObjectQueue.EntryIterator} to
+   * guard against concurrent modification.
+   */
+  @Private int modCount = 0;
+  @Private boolean closed;
+
+  InMemoryObjectQueue() {
+    entries = new ArrayDeque<>();
+  }
+
+  @Override public QueueFile file() {
+    return null;
+  }
+
+  @Override public void add(T entry) throws IOException {
+    if (closed) throw new IOException("closed");
+    modCount++;
+    entries.addLast(entry);
+  }
+
+  @Override public T peek() throws IOException {
+    if (closed) throw new IOException("closed");
+    return entries.peekFirst();
+  }
+
+  @Override public List<T> asList() throws IOException {
+    return new ArrayList<>(entries);
+  }
+
+  @Override public int size() {
+    return entries.size();
+  }
+
+  @Override public void remove(int n) throws IOException {
+    if (closed) throw new IOException("closed");
+    modCount++;
+    for (int i = 0; i < n; i++) {
+      entries.removeFirst();
+    }
+  }
+
+  /**
+   * Returns an iterator over entries in this queue.
+   *
+   * <p>The iterator disallows modifications to the queue during iteration. Removing entries from
+   * the head of the queue is permitted during iteration using{@link Iterator#remove()}.
+   */
+  @Override public Iterator<T> iterator() {
+    return new EntryIterator(entries.iterator());
+  }
+
+  @Override public void close() throws IOException {
+    closed = true;
+  }
+
+  private final class EntryIterator implements Iterator<T> {
+    private final Iterator<T> delegate;
+    private int index = 0;
+
+    /**
+     * The {@link #modCount} value that the iterator believes that the backing QueueFile should
+     * have. If this expectation is violated, the iterator has detected concurrent modification.
+     */
+    private int expectedModCount = modCount;
+
+    @Private EntryIterator(Iterator<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public boolean hasNext() {
+      checkForComodification();
+      return delegate.hasNext();
+    }
+
+    @Override public T next() {
+      if (closed) throw new IllegalStateException("closed");
+      checkForComodification();
+
+      T next = delegate.next();
+      index += 1;
+      return next;
+    }
+
+    @Override public void remove() {
+      if (closed) throw new IllegalStateException("closed");
+      checkForComodification();
+
+      if (size() == 0) throw new NoSuchElementException();
+      if (index != 1) {
+        throw new UnsupportedOperationException("Removal is only permitted from the head.");
+      }
+
+      try {
+        InMemoryObjectQueue.this.remove();
+      } catch (IOException e) {
+        throw new RuntimeException("todo: throw a proper error", e);
+      }
+
+      expectedModCount = modCount;
+      index -= 1;
+    }
+
+    private void checkForComodification() {
+      if (modCount != expectedModCount) throw new ConcurrentModificationException();
+    }
+  }
+}
\ No newline at end of file
diff --git a/tape/src/main/java/com/squareup/tape2/ObjectQueue.java b/tape/src/main/java/com/squareup/tape2/ObjectQueue.java
new file mode 100644
index 0000000..155a71f
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/ObjectQueue.java
@@ -0,0 +1,92 @@
+// Copyright 2011 Square, Inc.
+package com.squareup.tape2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+/** A queue of objects. */
+public abstract class ObjectQueue<T> implements Iterable<T>, Closeable {
+  /** A queue for objects that are atomically and durably serialized to {@code file}. */
+  public static <T> ObjectQueue<T> create(QueueFile qf, Converter<T> converter) {
+    return new FileObjectQueue<>(qf, converter);
+  }
+
+  /**
+   * A queue for objects that are not serious enough to be written to disk. Objects in this queue
+   * are kept in memory and will not be serialized.
+   */
+  public static <T> ObjectQueue<T> createInMemory() {
+    return new InMemoryObjectQueue<>();
+  }
+
+  /** The underlying {@link QueueFile} backing this queue, or null if it's only in memory. */
+  public abstract QueueFile file();
+
+  /** Returns the number of entries in the queue. */
+  public abstract int size();
+
+  /** Returns {@code true} if this queue contains no entries. */
+  public boolean isEmpty() {
+    return size() == 0;
+  }
+
+  /** Enqueues an entry that can be processed at any time. */
+  public abstract void add(T entry) throws IOException;
+
+  /**
+   * Returns the head of the queue, or {@code null} if the queue is empty. Does not modify the
+   * queue.
+   */
+  public abstract T peek() throws IOException;
+
+  /**
+   * Reads up to {@code max} entries from the head of the queue without removing the entries.
+   * If the queue's {@link #size()} is less than {@code max} then only {@link #size()} entries
+   * are read.
+   */
+  public List<T> peek(int max) throws IOException {
+    int end = Math.min(max, size());
+    List<T> subList = new ArrayList<T>(end);
+    Iterator<T> iterator = iterator();
+    for (int i = 0; i < end; i++) {
+      subList.add(iterator.next());
+    }
+    return Collections.unmodifiableList(subList);
+  }
+
+  /** Returns the entries in the queue as an unmodifiable {@link List}. */
+  public List<T> asList() throws IOException {
+    return peek(size());
+  }
+
+  /** Removes the head of the queue. */
+  public void remove() throws IOException {
+    remove(1);
+  }
+
+  /** Removes {@code n} entries from the head of the queue. */
+  public abstract void remove(int n) throws IOException;
+
+  /** Clears this queue. Also truncates the file to the initial size. */
+  public void clear() throws IOException {
+    remove(size());
+  }
+
+  /**
+   * Convert a byte stream to and from a concrete type.
+   *
+   * @param <T> Object type.
+   */
+  public interface Converter<T> {
+    /** Converts bytes to an object. */
+    T from(byte[] bytes) throws IOException;
+
+    /** Converts o to bytes written to the specified stream. */
+    void toStream(T o, OutputStream bytes) throws IOException;
+  }
+}
diff --git a/tape/src/main/java/com/squareup/tape2/Private.java b/tape/src/main/java/com/squareup/tape2/Private.java
new file mode 100644
index 0000000..3a02e36
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/Private.java
@@ -0,0 +1,24 @@
+package com.squareup.tape2;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the given field or method has package visibility solely to prevent the creation of
+ * a synthetic method. In practice, you should treat this field/method as if it were private. <p>
+ *
+ * When a private method is called from an inner class, the Java compiler generates a simple package
+ * private shim method that the class generated from the inner class can call. This results in
+ * unnecessary bloat and runtime method call overhead. It also gets us closer to the dex method
+ * count limit. <p>
+ *
+ * If you'd like to see warnings for these synthetic methods in IntelliJ, turn on the inspections
+ * "Private method only used from inner class" and "Private member access between outer and inner
+ * classes". <p>
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE})
+@interface Private {
+}
diff --git a/tape/src/main/java/com/squareup/tape2/QueueFile.java b/tape/src/main/java/com/squareup/tape2/QueueFile.java
new file mode 100644
index 0000000..f5fcfa0
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape2/QueueFile.java
@@ -0,0 +1,752 @@
+/*
+ * Copyright (C) 2010 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.tape2;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import static java.lang.Math.min;
+
+/**
+ * A reliable, efficient, file-based, FIFO queue. Additions and removals are O(1). All operations
+ * are atomic. Writes are synchronous; data will be written to disk before an operation returns.
+ * The underlying file is structured to survive process and even system crashes. If an I/O
+ * exception is thrown during a mutating change, the change is aborted. It is safe to continue to
+ * use a {@code QueueFile} instance after an exception.
+ *
+ * <p><strong>Note that this implementation is not synchronized.</strong>
+ *
+ * <p>In a traditional queue, the remove operation returns an element. In this queue,
+ * {@link #peek} and {@link #remove} are used in conjunction. Use
+ * {@code peek} to retrieve the first element, and then {@code remove} to remove it after
+ * successful processing. If the system crashes after {@code peek} and during processing, the
+ * element will remain in the queue, to be processed when the system restarts.
+ *
+ * <p><strong>NOTE:</strong> The current implementation is built for file systems that support
+ * atomic segment writes (like YAFFS). Most conventional file systems don't support this; if the
+ * power goes out while writing a segment, the segment will contain garbage and the file will be
+ * corrupt. We'll add journaling support so this class can be used with more file systems later.
+ *
+ * Construct instances with {@link Builder}.
+ *
+ * @author Bob Lee (bob@squareup.com)
+ */
+public final class QueueFile implements Closeable, Iterable<byte[]> {
+  /** Leading bit set to 1 indicating a versioned header and the version of 1. */
+  private static final int VERSIONED_HEADER = 0x80000001;
+
+  /** Initial file size in bytes. */
+  static final int INITIAL_LENGTH = 4096; // one file system block
+
+  /** A block of nothing to write over old data. */
+  private static final byte[] ZEROES = new byte[INITIAL_LENGTH];
+
+  /**
+   * The underlying file. Uses a ring buffer to store entries. Designed so that a modification
+   * isn't committed or visible until we write the header. The header is much smaller than a
+   * segment. So long as the underlying file system supports atomic segment writes, changes to the
+   * queue are atomic. Storing the file length ensures we can recover from a failed expansion
+   * (i.e. if setting the file length succeeds but the process dies before the data can be copied).
+   * <p>
+   * This implementation supports two versions of the on-disk format.
+   * <pre>
+   * Format:
+   *   16-32 bytes      Header
+   *   ...              Data
+   *
+   * Header (32 bytes):
+   *   1 bit            Versioned indicator [0 = legacy (see "Legacy Header"), 1 = versioned]
+   *   31 bits          Version, always 1
+   *   8 bytes          File length
+   *   4 bytes          Element count
+   *   8 bytes          Head element position
+   *   8 bytes          Tail element position
+   *
+   * Legacy Header (16 bytes):
+   *   1 bit            Legacy indicator, always 0 (see "Header")
+   *   31 bits          File length
+   *   4 bytes          Element count
+   *   4 bytes          Head element position
+   *   4 bytes          Tail element position
+   *
+   * Element:
+   *   4 bytes          Data length
+   *   ...              Data
+   * </pre>
+   */
+  final RandomAccessFile raf;
+
+  /** Keep file around for error reporting. */
+  final File file;
+
+  /** True when using the versioned header format. Otherwise use the legacy format. */
+  boolean versioned;
+
+  /** The header length in bytes: 16 or 32. */
+  int headerLength;
+
+  /** Cached file length. Always a power of 2. */
+  long fileLength;
+
+  /** Number of elements. */
+  @Private int elementCount;
+
+  /** Pointer to first (or eldest) element. */
+  @Private Element first;
+
+  /** Pointer to last (or newest) element. */
+  private Element last;
+
+  /** In-memory buffer. Big enough to hold the header. */
+  private final byte[] buffer = new byte[32];
+
+  /**
+   * The number of times this file has been structurally modified — it is incremented during
+   * {@link #remove(int)} and {@link #add(byte[], int, int)}. Used by {@link ElementIterator}
+   * to guard against concurrent modification.
+   */
+  @Private int modCount = 0;
+
+  /** When true, removing an element will also overwrite data with zero bytes. */
+  private final boolean zero;
+
+  @Private boolean closed;
+
+  private static RandomAccessFile initializeFromFile(File file, boolean forceLegacy)
+      throws IOException {
+    if (!file.exists()) {
+      // Use a temp file so we don't leave a partially-initialized file.
+      File tempFile = new File(file.getPath() + ".tmp");
+      RandomAccessFile raf = open(tempFile);
+      try {
+        raf.setLength(INITIAL_LENGTH);
+        raf.seek(0);
+        if (forceLegacy) {
+          raf.writeInt(INITIAL_LENGTH);
+        } else {
+          raf.writeInt(VERSIONED_HEADER);
+          raf.writeLong(INITIAL_LENGTH);
+        }
+      } finally {
+        raf.close();
+      }
+
+      // A rename is atomic.
+      if (!tempFile.renameTo(file)) {
+        throw new IOException("Rename failed!");
+      }
+    }
+
+    return open(file);
+  }
+
+  /** Opens a random access file that writes synchronously. */
+  private static RandomAccessFile open(File file) throws FileNotFoundException {
+    return new RandomAccessFile(file, "rwd");
+  }
+
+  QueueFile(File file, RandomAccessFile raf, boolean zero, boolean forceLegacy) throws IOException {
+    this.file = file;
+    this.raf = raf;
+    this.zero = zero;
+
+    raf.seek(0);
+    raf.readFully(buffer);
+
+    versioned = !forceLegacy && (buffer[0] & 0x80) != 0;
+    long firstOffset;
+    long lastOffset;
+    if (versioned) {
+      headerLength = 32;
+
+      int version = readInt(buffer, 0) & 0x7FFFFFFF;
+      if (version != 1) {
+        throw new IOException(
+            "Unable to read version " + version + " format. Supported versions are 1 and legacy.");
+      }
+      fileLength = readLong(buffer, 4);
+      elementCount = readInt(buffer, 12);
+      firstOffset = readLong(buffer, 16);
+      lastOffset = readLong(buffer, 24);
+    } else {
+      headerLength = 16;
+
+      fileLength = readInt(buffer, 0);
+      elementCount = readInt(buffer, 4);
+      firstOffset = readInt(buffer, 8);
+      lastOffset = readInt(buffer, 12);
+    }
+
+    if (fileLength > raf.length()) {
+      throw new IOException(
+          "File is truncated. Expected length: " + fileLength + ", Actual length: " + raf.length());
+    } else if (fileLength <= headerLength) {
+      throw new IOException(
+          "File is corrupt; length stored in header (" + fileLength + ") is invalid.");
+    }
+
+    first = readElement(firstOffset);
+    last = readElement(lastOffset);
+  }
+
+  /**
+   * Stores an {@code int} in the {@code byte[]}. The behavior is equivalent to calling
+   * {@link RandomAccessFile#writeInt}.
+   */
+  private static void writeInt(byte[] buffer, int offset, int value) {
+    buffer[offset    ] = (byte) (value >> 24);
+    buffer[offset + 1] = (byte) (value >> 16);
+    buffer[offset + 2] = (byte) (value >> 8);
+    buffer[offset + 3] = (byte) value;
+  }
+
+  /** Reads an {@code int} from the {@code byte[]}. */
+  private static int readInt(byte[] buffer, int offset) {
+    return ((buffer[offset    ] & 0xff) << 24)
+        +  ((buffer[offset + 1] & 0xff) << 16)
+        +  ((buffer[offset + 2] & 0xff) << 8)
+        +   (buffer[offset + 3] & 0xff);
+  }
+
+  /**
+   * Stores an {@code long} in the {@code byte[]}. The behavior is equivalent to calling
+   * {@link RandomAccessFile#writeLong}.
+   */
+  private static void writeLong(byte[] buffer, int offset, long value) {
+    buffer[offset    ] = (byte) (value >> 56);
+    buffer[offset + 1] = (byte) (value >> 48);
+    buffer[offset + 2] = (byte) (value >> 40);
+    buffer[offset + 3] = (byte) (value >> 32);
+    buffer[offset + 4] = (byte) (value >> 24);
+    buffer[offset + 5] = (byte) (value >> 16);
+    buffer[offset + 6] = (byte) (value >> 8);
+    buffer[offset + 7] = (byte) value;
+  }
+
+  /** Reads an {@code long} from the {@code byte[]}. */
+  private static long readLong(byte[] buffer, int offset) {
+    return ((buffer[offset    ] & 0xffL) << 56)
+        +  ((buffer[offset + 1] & 0xffL) << 48)
+        +  ((buffer[offset + 2] & 0xffL) << 40)
+        +  ((buffer[offset + 3] & 0xffL) << 32)
+        +  ((buffer[offset + 4] & 0xffL) << 24)
+        +  ((buffer[offset + 5] & 0xffL) << 16)
+        +  ((buffer[offset + 6] & 0xffL) << 8)
+        +   (buffer[offset + 7] & 0xffL);
+  }
+
+  /**
+   * Writes header atomically. The arguments contain the updated values. The class member fields
+   * should not have changed yet. This only updates the state in the file. It's up to the caller to
+   * update the class member variables *after* this call succeeds. Assumes segment writes are
+   * atomic in the underlying file system.
+   */
+  private void writeHeader(long fileLength, int elementCount, long firstPosition, long lastPosition)
+      throws IOException {
+    raf.seek(0);
+
+    if (versioned) {
+      writeInt(buffer, 0, VERSIONED_HEADER);
+      writeLong(buffer, 4, fileLength);
+      writeInt(buffer, 12, elementCount);
+      writeLong(buffer, 16, firstPosition);
+      writeLong(buffer, 24, lastPosition);
+      raf.write(buffer, 0, 32);
+      return;
+    }
+
+    // Legacy queue header.
+    writeInt(buffer, 0, (int) fileLength); // Signed, so leading bit is always 0 aka legacy.
+    writeInt(buffer, 4, elementCount);
+    writeInt(buffer, 8, (int) firstPosition);
+    writeInt(buffer, 12, (int) lastPosition);
+    raf.write(buffer, 0, 16);
+  }
+
+  @Private Element readElement(long position) throws IOException {
+    if (position == 0) return Element.NULL;
+    ringRead(position, buffer, 0, Element.HEADER_LENGTH);
+    int length = readInt(buffer, 0);
+    return new Element(position, length);
+  }
+
+  /** Wraps the position if it exceeds the end of the file. */
+  @Private long wrapPosition(long position) {
+    return position < fileLength ? position
+        : headerLength + position - fileLength;
+  }
+
+  /**
+   * Writes count bytes from buffer to position in file. Automatically wraps write if position is
+   * past the end of the file or if buffer overlaps it.
+   *
+   * @param position in file to write to
+   * @param buffer to write from
+   * @param count # of bytes to write
+   */
+  private void ringWrite(long position, byte[] buffer, int offset, int count) throws IOException {
+    position = wrapPosition(position);
+    if (position + count <= fileLength) {
+      raf.seek(position);
+      raf.write(buffer, offset, count);
+    } else {
+      // The write overlaps the EOF.
+      // # of bytes to write before the EOF. Guaranteed to be less than Integer.MAX_VALUE.
+      int beforeEof = (int) (fileLength - position);
+      raf.seek(position);
+      raf.write(buffer, offset, beforeEof);
+      raf.seek(headerLength);
+      raf.write(buffer, offset + beforeEof, count - beforeEof);
+    }
+  }
+
+  private void ringErase(long position, long length) throws IOException {
+    while (length > 0) {
+      int chunk = (int) min(length, ZEROES.length);
+      ringWrite(position, ZEROES, 0, chunk);
+      length -= chunk;
+      position += chunk;
+    }
+  }
+
+  /**
+   * Reads count bytes into buffer from file. Wraps if necessary.
+   *
+   * @param position in file to read from
+   * @param buffer to read into
+   * @param count # of bytes to read
+   */
+  @Private void ringRead(long position, byte[] buffer, int offset, int count) throws IOException {
+    position = wrapPosition(position);
+    if (position + count <= fileLength) {
+      raf.seek(position);
+      raf.readFully(buffer, offset, count);
+    } else {
+      // The read overlaps the EOF.
+      // # of bytes to read before the EOF. Guaranteed to be less than Integer.MAX_VALUE.
+      int beforeEof = (int) (fileLength - position);
+      raf.seek(position);
+      raf.readFully(buffer, offset, beforeEof);
+      raf.seek(headerLength);
+      raf.readFully(buffer, offset + beforeEof, count - beforeEof);
+    }
+  }
+
+  /**
+   * Adds an element to the end of the queue.
+   *
+   * @param data to copy bytes from
+   */
+  public void add(byte[] data) throws IOException {
+    add(data, 0, data.length);
+  }
+
+  /**
+   * Adds an element to the end of the queue.
+   *
+   * @param data to copy bytes from
+   * @param offset to start from in buffer
+   * @param count number of bytes to copy
+   * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code count < 0}, or if {@code
+   * offset + count} is bigger than the length of {@code buffer}.
+   */
+  public void add(byte[] data, int offset, int count) throws IOException {
+    if (data == null) {
+      throw new NullPointerException("data == null");
+    }
+    if ((offset | count) < 0 || count > data.length - offset) {
+      throw new IndexOutOfBoundsException();
+    }
+    if (closed) throw new IOException("closed");
+
+    expandIfNecessary(count);
+
+    // Insert a new element after the current last element.
+    boolean wasEmpty = isEmpty();
+    long position = wasEmpty ? headerLength
+        : wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
+    Element newLast = new Element(position, count);
+
+    // Write length.
+    writeInt(buffer, 0, count);
+    ringWrite(newLast.position, buffer, 0, Element.HEADER_LENGTH);
+
+    // Write data.
+    ringWrite(newLast.position + Element.HEADER_LENGTH, data, offset, count);
+
+    // Commit the addition. If wasEmpty, first == last.
+    long firstPosition = wasEmpty ? newLast.position : first.position;
+    writeHeader(fileLength, elementCount + 1, firstPosition, newLast.position);
+    last = newLast;
+    elementCount++;
+    modCount++;
+    if (wasEmpty) first = last; // first element
+  }
+
+  private long usedBytes() {
+    if (elementCount == 0) return headerLength;
+
+    if (last.position >= first.position) {
+      // Contiguous queue.
+      return (last.position - first.position)   // all but last entry
+          + Element.HEADER_LENGTH + last.length // last entry
+          + headerLength;
+    } else {
+      // tail < head. The queue wraps.
+      return last.position                      // buffer front + header
+          + Element.HEADER_LENGTH + last.length // last entry
+          + fileLength - first.position;        // buffer end
+    }
+  }
+
+  private long remainingBytes() {
+    return fileLength - usedBytes();
+  }
+
+  /** Returns true if this queue contains no entries. */
+  public boolean isEmpty() {
+    return elementCount == 0;
+  }
+
+  /**
+   * If necessary, expands the file to accommodate an additional element of the given length.
+   *
+   * @param dataLength length of data being added
+   */
+  private void expandIfNecessary(long dataLength) throws IOException {
+    long elementLength = Element.HEADER_LENGTH + dataLength;
+    long remainingBytes = remainingBytes();
+    if (remainingBytes >= elementLength) return;
+
+    // Expand.
+    long previousLength = fileLength;
+    long newLength;
+    // Double the length until we can fit the new data.
+    do {
+      remainingBytes += previousLength;
+      newLength = previousLength << 1;
+      previousLength = newLength;
+    } while (remainingBytes < elementLength);
+
+    setLength(newLength);
+
+    // Calculate the position of the tail end of the data in the ring buffer
+    long endOfLastElement = wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
+    long count = 0;
+    // If the buffer is split, we need to make it contiguous
+    if (endOfLastElement <= first.position) {
+      FileChannel channel = raf.getChannel();
+      channel.position(fileLength); // destination position
+      count = endOfLastElement - headerLength;
+      if (channel.transferTo(headerLength, count, channel) != count) {
+        throw new AssertionError("Copied insufficient number of bytes!");
+      }
+    }
+
+    // Commit the expansion.
+    if (last.position < first.position) {
+      long newLastPosition = fileLength + last.position - headerLength;
+      writeHeader(newLength, elementCount, first.position, newLastPosition);
+      last = new Element(newLastPosition, last.length);
+    } else {
+      writeHeader(newLength, elementCount, first.position, last.position);
+    }
+
+    fileLength = newLength;
+
+    if (zero) {
+      ringErase(headerLength, count);
+    }
+  }
+
+  /** Sets the length of the file. */
+  private void setLength(long newLength) throws IOException {
+    // Set new file length (considered metadata) and sync it to storage.
+    raf.setLength(newLength);
+    raf.getChannel().force(true);
+  }
+
+  /** Reads the eldest element. Returns null if the queue is empty. */
+  public byte[] peek() throws IOException {
+    if (closed) throw new IOException("closed");
+    if (isEmpty()) return null;
+    int length = first.length;
+    byte[] data = new byte[length];
+    ringRead(first.position + Element.HEADER_LENGTH, data, 0, length);
+    return data;
+  }
+
+  /**
+   * Returns an iterator over elements in this QueueFile.
+   *
+   * <p>The iterator disallows modifications to be made to the QueueFile during iteration. Removing
+   * elements from the head of the QueueFile is permitted during iteration using
+   * {@link Iterator#remove()}.
+   *
+   * <p>The iterator may throw an unchecked {@link RuntimeException} during {@link Iterator#next()}
+   * or {@link Iterator#remove()}.
+   */
+  @Override public Iterator<byte[]> iterator() {
+    return new ElementIterator();
+  }
+
+  private final class ElementIterator implements Iterator<byte[]> {
+    /** Index of element to be returned by subsequent call to next. */
+    int nextElementIndex = 0;
+
+    /** Position of element to be returned by subsequent call to next. */
+    private long nextElementPosition = first.position;
+
+    /**
+     * The {@link #modCount} value that the iterator believes that the backing QueueFile should
+     * have. If this expectation is violated, the iterator has detected concurrent modification.
+     */
+    int expectedModCount = modCount;
+
+    @Private ElementIterator() {
+    }
+
+    private void checkForComodification() {
+      if (modCount != expectedModCount) throw new ConcurrentModificationException();
+    }
+
+    @Override public boolean hasNext() {
+      if (closed) throw new IllegalStateException("closed");
+      checkForComodification();
+      return nextElementIndex != elementCount;
+    }
+
+    @Override public byte[] next() {
+      if (closed) throw new IllegalStateException("closed");
+      checkForComodification();
+      if (isEmpty()) throw new NoSuchElementException();
+      if (nextElementIndex >= elementCount) throw new NoSuchElementException();
+
+      try {
+        // Read the current element.
+        Element current = readElement(nextElementPosition);
+        byte[] buffer = new byte[current.length];
+        nextElementPosition = wrapPosition(current.position + Element.HEADER_LENGTH);
+        ringRead(nextElementPosition, buffer, 0, current.length);
+
+        // Update the pointer to the next element.
+        nextElementPosition =
+            wrapPosition(current.position + Element.HEADER_LENGTH + current.length);
+        nextElementIndex++;
+
+        // Return the read element.
+        return buffer;
+      } catch (IOException e) {
+        throw new RuntimeException("todo: throw a proper error", e);
+      }
+    }
+
+    @Override public void remove() {
+      checkForComodification();
+
+      if (isEmpty()) throw new NoSuchElementException();
+      if (nextElementIndex != 1) {
+        throw new UnsupportedOperationException("Removal is only permitted from the head.");
+      }
+
+      try {
+        QueueFile.this.remove();
+      } catch (IOException e) {
+        throw new RuntimeException("todo: throw a proper error", e);
+      }
+
+      expectedModCount = modCount;
+      nextElementIndex--;
+    }
+  }
+
+  /** Returns the number of elements in this queue. */
+  public int size() {
+    return elementCount;
+  }
+
+  /**
+   * Removes the eldest element.
+   *
+   * @throws NoSuchElementException if the queue is empty
+   */
+  public void remove() throws IOException {
+    remove(1);
+  }
+
+  /**
+   * Removes the eldest {@code n} elements.
+   *
+   * @throws NoSuchElementException if the queue is empty
+   */
+  public void remove(int n) throws IOException {
+    if (n < 0) {
+      throw new IllegalArgumentException("Cannot remove negative (" + n + ") number of elements.");
+    }
+    if (n == 0) {
+      return;
+    }
+    if (n == elementCount) {
+      clear();
+      return;
+    }
+    if (isEmpty()) {
+      throw new NoSuchElementException();
+    }
+    if (n > elementCount) {
+      throw new IllegalArgumentException(
+          "Cannot remove more elements (" + n + ") than present in queue (" + elementCount + ").");
+    }
+
+    long eraseStartPosition = first.position;
+    long eraseTotalLength = 0;
+
+    // Read the position and length of the new first element.
+    long newFirstPosition = first.position;
+    int newFirstLength = first.length;
+    for (int i = 0; i < n; i++) {
+      eraseTotalLength += Element.HEADER_LENGTH + newFirstLength;
+      newFirstPosition = wrapPosition(newFirstPosition + Element.HEADER_LENGTH + newFirstLength);
+      ringRead(newFirstPosition, buffer, 0, Element.HEADER_LENGTH);
+      newFirstLength = readInt(buffer, 0);
+    }
+
+    // Commit the header.
+    writeHeader(fileLength, elementCount - n, newFirstPosition, last.position);
+    elementCount -= n;
+    modCount++;
+    first = new Element(newFirstPosition, newFirstLength);
+
+    if (zero) {
+      ringErase(eraseStartPosition, eraseTotalLength);
+    }
+  }
+
+  /** Clears this queue. Truncates the file to the initial size. */
+  public void clear() throws IOException {
+    if (closed) throw new IOException("closed");
+
+    // Commit the header.
+    writeHeader(INITIAL_LENGTH, 0, 0, 0);
+
+    if (zero) {
+      // Zero out data.
+      raf.seek(headerLength);
+      raf.write(ZEROES, 0, INITIAL_LENGTH - headerLength);
+    }
+
+    elementCount = 0;
+    first = Element.NULL;
+    last = Element.NULL;
+    if (fileLength > INITIAL_LENGTH) setLength(INITIAL_LENGTH);
+    fileLength = INITIAL_LENGTH;
+    modCount++;
+  }
+
+  /** The underlying {@link File} backing this queue. */
+  public File file() {
+    return file;
+  }
+
+  @Override public void close() throws IOException {
+    closed = true;
+    raf.close();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName()
+        + "[length=" + fileLength
+        + ", size=" + elementCount
+        + ", first=" + first
+        + ", last=" + last
+        + "]";
+  }
+
+  /** A pointer to an element. */
+  static class Element {
+    static final Element NULL = new Element(0, 0);
+
+    /** Length of element header in bytes. */
+    static final int HEADER_LENGTH = 4;
+
+    /** Position in file. */
+    final long position;
+
+    /** The length of the data. */
+    final int length;
+
+    /**
+     * Constructs a new element.
+     *
+     * @param position within file
+     * @param length of data
+     */
+    Element(long position, int length) {
+      this.position = position;
+      this.length = length;
+    }
+
+    @Override public String toString() {
+      return getClass().getSimpleName()
+          + "[position=" + position
+          + ", length=" + length
+          + "]";
+    }
+  }
+
+  /** Fluent API for creating {@link QueueFile} instances. */
+  public static final class Builder {
+    final File file;
+    boolean zero = true;
+    boolean forceLegacy = false;
+
+    /** Start constructing a new queue backed by the given file. */
+    public Builder(File file) {
+      if (file == null) {
+        throw new NullPointerException("file == null");
+      }
+      this.file = file;
+    }
+
+    /** When true, removing an element will also overwrite data with zero bytes. */
+    public Builder zero(boolean zero) {
+      this.zero = zero;
+      return this;
+    }
+
+    /** When true, only the legacy (Tape 1.x) format will be used. */
+    public Builder forceLegacy(boolean forceLegacy) {
+      this.forceLegacy = forceLegacy;
+      return this;
+    }
+
+    /**
+     * Constructs a new queue backed by the given builder. Only one instance should access a given
+     * file at a time.
+     */
+    public QueueFile build() throws IOException {
+      RandomAccessFile raf = initializeFromFile(file, forceLegacy);
+      return new QueueFile(file, raf, zero, forceLegacy);
+    }
+  }
+}
diff --git a/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java b/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java
deleted file mode 100644
index 980b1a0..0000000
--- a/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2014 Square, Inc.
-package com.squareup.tape;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-public class FileObjectQueueTest {
-  @Rule public TemporaryFolder folder = new TemporaryFolder();
-  private FileObjectQueue<String> queue;
-
-  @Before public void setUp() throws IOException {
-    File parent = folder.getRoot();
-    File file = new File(parent, "queue-file");
-    queue = new FileObjectQueue<String>(file, new SerializedConverter<String>());
-    queue.add("one");
-    queue.add("two");
-    queue.add("three");
-  }
-
-  @Test public void peekMultiple() {
-    List<String> peek = queue.peek(3);
-    assertThat(peek).containsExactly("one", "two", "three");
-  }
-
-  @Test public void getsAllAsList() {
-    List<String> peek = queue.asList();
-    assertThat(peek).containsExactly("one", "two", "three");
-  }
-
-  @Test public void peekMaxCanExceedQueueDepth() {
-    List<String> peek = queue.peek(6);
-    assertThat(peek).hasSize(3);
-  }
-
-  @Test public void peekMaxCanBeSmallerThanQueueDepth() {
-    List<String> peek = queue.peek(2);
-    assertThat(peek).containsExactly("one", "two");
-  }
-}
diff --git a/tape/src/test/java/com/squareup/tape/TaskQueueTest.java b/tape/src/test/java/com/squareup/tape/TaskQueueTest.java
deleted file mode 100644
index c9f817a..0000000
--- a/tape/src/test/java/com/squareup/tape/TaskQueueTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.squareup.tape;
-
-import org.junit.Test;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-public class TaskQueueTest {
-  private TaskQueue<Task<String>> taskQueue =
-      new TaskQueue<Task<String>>(new InMemoryObjectQueue<Task<String>>());
-
-  @SuppressWarnings("unchecked")
-  private final Task<String> task = mock(Task.class);
-
-  @SuppressWarnings("unchecked")
-  @Test
-  public void correctTaskQueueInstanceIsPassedToTheListener() {
-    ObjectQueue.Listener<Task<String>> mockListener = mock(ObjectQueue.Listener.class);
-
-    // Register a listener on the taskQueue instance.
-    taskQueue.setListener(mockListener);
-    taskQueue.add(task);
-
-    // Expect the first argument to be the same instance we registered with.
-    verify(mockListener).onAdd(taskQueue, task);
-
-    taskQueue.remove();
-
-    // Same story with remove; the taskQueue should be the one we registered with.
-    verify(mockListener).onRemove(taskQueue);
-  }
-}
diff --git a/tape/src/test/java/com/squareup/tape2/ObjectQueueTest.java b/tape/src/test/java/com/squareup/tape2/ObjectQueueTest.java
new file mode 100644
index 0000000..bd6b97e
--- /dev/null
+++ b/tape/src/test/java/com/squareup/tape2/ObjectQueueTest.java
@@ -0,0 +1,206 @@
+package com.squareup.tape2;
+
+import com.squareup.burst.BurstJUnit4;
+import com.squareup.burst.annotation.Burst;
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(BurstJUnit4.class)
+public class ObjectQueueTest {
+  public enum QueueFactory {
+    FILE() {
+      @Override
+      public <T> ObjectQueue<T> create(QueueFile queueFile, FileObjectQueue.Converter<T> converter)
+          throws IOException {
+        return ObjectQueue.create(queueFile, converter);
+      }
+    },
+    MEMORY() {
+      @Override
+      public <T> ObjectQueue<T> create(QueueFile file, FileObjectQueue.Converter<T> converter) {
+        return ObjectQueue.createInMemory();
+      }
+    };
+
+    public abstract <T> ObjectQueue<T> create(QueueFile queueFile,
+        FileObjectQueue.Converter<T> converter) throws IOException;
+  }
+
+  @Rule public TemporaryFolder folder = new TemporaryFolder();
+  @Burst QueueFactory factory;
+  ObjectQueue<String> queue;
+
+  @Before public void setUp() throws IOException {
+    File parent = folder.getRoot();
+    File file = new File(parent, "object-queue");
+    QueueFile queueFile = new QueueFile.Builder(file).build();
+
+    queue = factory.create(queueFile, new StringConverter());
+    queue.add("one");
+    queue.add("two");
+    queue.add("three");
+  }
+
+  @Test public void size() throws IOException {
+    assertThat(queue.size()).isEqualTo(3);
+  }
+
+  @Test public void peek() throws IOException {
+    assertThat(queue.peek()).isEqualTo("one");
+  }
+
+  @Test public void peekMultiple() throws IOException {
+    assertThat(queue.peek(2)).containsExactly("one", "two");
+  }
+
+  @Test public void peekMaxCanExceedQueueDepth() throws IOException {
+    assertThat(queue.peek(6)).containsExactly("one", "two", "three");
+  }
+
+  @Test public void asList() throws IOException {
+    assertThat(queue.asList()).containsExactly("one", "two", "three");
+  }
+
+  @Test public void remove() throws IOException {
+    queue.remove();
+
+    assertThat(queue.asList()).containsExactly("two", "three");
+  }
+
+  @Test public void removeMultiple() throws IOException {
+    queue.remove(2);
+
+    assertThat(queue.asList()).containsExactly("three");
+  }
+
+  @Test public void clear() throws IOException {
+    queue.clear();
+
+    assertThat(queue.size()).isEqualTo(0);
+  }
+
+  @Test public void isEmpty() throws IOException {
+    assertThat(queue.isEmpty()).isFalse();
+
+    queue.clear();
+
+    assertThat(queue.isEmpty()).isTrue();
+  }
+
+  @Test public void testIterator() throws IOException {
+    final List<String> saw = new ArrayList<>();
+    for (String pojo : queue) {
+      saw.add(pojo);
+    }
+    assertThat(saw).containsExactly("one", "two", "three");
+  }
+
+  @Test public void testIteratorNextThrowsWhenEmpty() throws IOException {
+    queue.clear();
+    Iterator<String> iterator = queue.iterator();
+
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException ignored) {
+    }
+  }
+
+  @Test public void testIteratorNextThrowsWhenExhausted() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+    iterator.next();
+    iterator.next();
+    iterator.next();
+
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException ignored) {
+    }
+  }
+
+  @Test public void testIteratorRemove() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+
+    iterator.next();
+    iterator.remove();
+    assertThat(queue.asList()).containsExactly("two", "three");
+
+    iterator.next();
+    iterator.remove();
+    assertThat(queue.asList()).containsExactly("three");
+  }
+
+  @Test public void testIteratorRemoveDisallowsConcurrentModification() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+    iterator.next();
+    queue.remove();
+
+    try {
+      iterator.remove();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorHasNextDisallowsConcurrentModification() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+    iterator.next();
+    queue.remove();
+
+    try {
+      iterator.hasNext();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorDisallowsConcurrentModificationWithClear() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+    iterator.next();
+    queue.clear();
+
+    try {
+      iterator.hasNext();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorOnlyRemovesFromHead() throws IOException {
+    Iterator<String> iterator = queue.iterator();
+    iterator.next();
+    iterator.next();
+
+    try {
+      iterator.remove();
+      fail();
+    } catch (UnsupportedOperationException ex) {
+      assertThat(ex).hasMessageThat().isEqualTo("Removal is only permitted from the head.");
+    }
+  }
+
+  static class StringConverter implements FileObjectQueue.Converter<String> {
+    @Override public String from(byte[] bytes) throws IOException {
+      return new String(bytes, "UTF-8");
+    }
+
+    @Override public void toStream(String s, OutputStream os) throws IOException {
+      os.write(s.getBytes("UTF-8"));
+    }
+  }
+}
diff --git a/tape/src/test/java/com/squareup/tape/SerializedConverterTest.java b/tape/src/test/java/com/squareup/tape2/QueueFileLoadingTest.java
similarity index 51%
rename from tape/src/test/java/com/squareup/tape/SerializedConverterTest.java
rename to tape/src/test/java/com/squareup/tape2/QueueFileLoadingTest.java
index a778e69..96d10dc 100644
--- a/tape/src/test/java/com/squareup/tape/SerializedConverterTest.java
+++ b/tape/src/test/java/com/squareup/tape2/QueueFileLoadingTest.java
@@ -1,5 +1,5 @@
 // Copyright 2012 Square, Inc.
-package com.squareup.tape;
+package com.squareup.tape2;
 
 import org.junit.After;
 import org.junit.Test;
@@ -7,20 +7,19 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.Serializable;
-
-import static com.squareup.tape.QueueTestUtils.EMPTY_SERIALIZED_QUEUE;
-import static com.squareup.tape.QueueTestUtils.FRESH_SERIALIZED_QUEUE;
-import static com.squareup.tape.QueueTestUtils.ONE_ENTRY_SERIALIZED_QUEUE;
-import static com.squareup.tape.QueueTestUtils.TRUNCATED_EMPTY_SERIALIZED_QUEUE;
-import static com.squareup.tape.QueueTestUtils.TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE;
-import static com.squareup.tape.QueueTestUtils.UndeletableFile;
-import static com.squareup.tape.QueueTestUtils.copyTestFile;
+
+import static com.squareup.tape2.QueueTestUtils.EMPTY_SERIALIZED_QUEUE;
+import static com.squareup.tape2.QueueTestUtils.FRESH_SERIALIZED_QUEUE;
+import static com.squareup.tape2.QueueTestUtils.ONE_ENTRY_SERIALIZED_QUEUE;
+import static com.squareup.tape2.QueueTestUtils.TRUNCATED_EMPTY_SERIALIZED_QUEUE;
+import static com.squareup.tape2.QueueTestUtils.TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE;
+import static com.squareup.tape2.QueueTestUtils.UndeletableFile;
+import static com.squareup.tape2.QueueTestUtils.copyTestFile;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-public class SerializedConverterTest {
+public class QueueFileLoadingTest {
 
   private File testFile;
 
@@ -30,65 +29,66 @@
 
   @Test public void testMissingFileInitializes() throws Exception {
     testFile = File.createTempFile(FRESH_SERIALIZED_QUEUE, "test");
-    testFile.delete();
+    assertTrue(testFile.delete());
     assertFalse(testFile.exists());
-    ObjectQueue<String> stringQFile = createQueue(testFile);
-    assertEquals(0, stringQFile.size());
+    QueueFile queue = new QueueFile.Builder(testFile).build();
+    assertEquals(0, queue.size());
     assertTrue(testFile.exists());
   }
 
   @Test public void testEmptyFileInitializes() throws Exception {
     testFile = copyTestFile(EMPTY_SERIALIZED_QUEUE);
-    ObjectQueue<String> stringQFile = createQueue(testFile);
-    assertEquals(0, stringQFile.size());
+    QueueFile queue = new QueueFile.Builder(testFile).build();
+    assertEquals(0, queue.size());
   }
 
   @Test public void testSingleEntryFileInitializes() throws Exception {
     testFile = copyTestFile(ONE_ENTRY_SERIALIZED_QUEUE);
-    ObjectQueue<String> stringQFile = createQueue(testFile);
-    assertEquals(1, stringQFile.size());
+    QueueFile queue = new QueueFile.Builder(testFile).build();
+    assertEquals(1, queue.size());
   }
 
   @Test(expected = IOException.class)
   public void testTruncatedEmptyFileThrows() throws Exception {
     testFile = copyTestFile(TRUNCATED_EMPTY_SERIALIZED_QUEUE);
-    createQueue(testFile);
+    new QueueFile.Builder(testFile).build();
   }
 
   @Test(expected = IOException.class)
   public void testTruncatedOneEntryFileThrows() throws Exception {
     testFile = copyTestFile(TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE);
-    createQueue(testFile);
+    new QueueFile.Builder(testFile).build();
   }
 
   @Test(expected = IOException.class)
   public void testCreateWithReadOnlyFile_throwsException() throws Exception {
     testFile = copyTestFile(TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE);
-    testFile.setWritable(false);
+    assertTrue(testFile.setWritable(false));
 
     File tmp = new UndeletableFile(testFile.getAbsolutePath());
     // Should throw an exception.
-    createQueue(tmp);
+    new QueueFile.Builder(testFile).build();
   }
 
-  @Test(expected = FileException.class)
+  @Test(expected = IOException.class)
   public void testAddWithReadOnlyFile_missesMonitor() throws Exception {
     testFile = copyTestFile(EMPTY_SERIALIZED_QUEUE);
 
+    QueueFile qf = new QueueFile.Builder(testFile).build();
+
     // Should throw an exception.
-    FileObjectQueue<String> qf = new FileObjectQueue<String>(testFile, new SerializedConverter<String>() {
-      @Override public void toStream(String o, OutputStream bytes) throws IOException {
-        throw new IOException("fake Permission denied");
-      }
-    });
-    // Should throw an exception.
-    qf.add("trouble");
-  }
+    FileObjectQueue<String> queue =
+        new FileObjectQueue<String>(qf, new FileObjectQueue.Converter<String>() {
+          @Override public String from(byte[] bytes) throws IOException {
+            return null;
+          }
 
-  ///////////////////////////////
+          @Override public void toStream(String o, OutputStream bytes) throws IOException {
+            throw new IOException("fake Permission denied");
+          }
+        });
 
-  private static <T extends Serializable> ObjectQueue<T> createQueue(File file) throws IOException {
-    SerializedConverter<T> converter = new SerializedConverter<T>();
-    return new FileObjectQueue<T>(file, converter);
+    // Should throw an exception.
+    queue.add("trouble");
   }
 }
diff --git a/tape/src/test/java/com/squareup/tape/QueueFileTest.java b/tape/src/test/java/com/squareup/tape2/QueueFileTest.java
similarity index 54%
rename from tape/src/test/java/com/squareup/tape/QueueFileTest.java
rename to tape/src/test/java/com/squareup/tape2/QueueFileTest.java
index 24d03f5..2df0faf 100644
--- a/tape/src/test/java/com/squareup/tape/QueueFileTest.java
+++ b/tape/src/test/java/com/squareup/tape2/QueueFileTest.java
@@ -1,41 +1,55 @@
 // Copyright 2010 Square, Inc.
-package com.squareup.tape;
+package com.squareup.tape2;
 
-import com.squareup.tape.QueueFile.Element;
-import java.io.ByteArrayOutputStream;
+import com.squareup.tape2.QueueFile.Element;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.RandomAccessFile;
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Queue;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
-import org.fest.assertions.Assertions;
+import okio.BufferedSource;
+import okio.Okio;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-import static com.squareup.tape.QueueFile.HEADER_LENGTH;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.fest.assertions.Fail.fail;
+import static com.google.common.truth.Truth.assertThat;
+import static com.squareup.tape2.QueueFile.INITIAL_LENGTH;
+import static org.junit.Assert.fail;
 
 /**
  * Tests for QueueFile.
  *
  * @author Bob Lee (bob@squareup.com)
  */
-@SuppressWarnings({ "ResultOfMethodCallIgnored" }) public class QueueFileTest {
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(Parameterized.class)
+public class QueueFileTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] {"Legacy"   , true , 16},
+        new Object[] {"Versioned", false, 32}
+    );
+  }
+
   private static final Logger logger = Logger.getLogger(QueueFileTest.class.getName());
 
   /**
    * Takes up 33401 bytes in the queue (N*(N+1)/2+4*N). Picked 254 instead of 255 so that the number
    * of bytes isn't a multiple of 4.
    */
-  private static int N = 254;
+  private static final int N = 254;
   private static byte[][] values = new byte[N][];
 
   static {
@@ -48,9 +62,29 @@
     }
   }
 
+  private final boolean forceLegacy;
+  private final int headerLength;
+
   @Rule public TemporaryFolder folder = new TemporaryFolder();
   private File file;
 
+  public QueueFileTest(String name, boolean forceLegacy, int headerLength) {
+    this.forceLegacy = forceLegacy;
+    this.headerLength = headerLength;
+  }
+
+  private QueueFile newQueueFile() throws IOException {
+    return newQueueFile(true);
+  }
+
+  private QueueFile newQueueFile(RandomAccessFile raf) throws IOException {
+    return new QueueFile(this.file, raf, true, forceLegacy);
+  }
+
+  private QueueFile newQueueFile(boolean zero) throws IOException {
+    return new QueueFile.Builder(file).zero(zero).forceLegacy(forceLegacy).build();
+  }
+
   @Before public void setUp() throws Exception {
     File parent = folder.getRoot();
     file = new File(parent, "queue-file");
@@ -58,41 +92,41 @@
 
   @Test public void testAddOneElement() throws IOException {
     // This test ensures that we update 'first' correctly.
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     byte[] expected = values[253];
     queue.add(expected);
     assertThat(queue.peek()).isEqualTo(expected);
     queue.close();
-    queue = new QueueFile(file);
+    queue = newQueueFile();
     assertThat(queue.peek()).isEqualTo(expected);
   }
 
   @Test public void testClearErases() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     byte[] expected = values[253];
     queue.add(expected);
 
     // Confirm that the data was in the file before we cleared.
     byte[] data = new byte[expected.length];
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, expected.length);
     assertThat(data).isEqualTo(expected);
 
     queue.clear();
 
     // Should have been erased.
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, expected.length);
     assertThat(data).isEqualTo(new byte[expected.length]);
   }
 
   @Test public void testClearDoesNotCorrupt() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     byte[] stuff = values[253];
     queue.add(stuff);
     queue.clear();
 
-    queue = new QueueFile(file);
+    queue = newQueueFile();
     assertThat(queue.isEmpty()).isTrue();
     assertThat(queue.peek()).isNull();
 
@@ -101,7 +135,7 @@
   }
 
   @Test public void removeErasesEagerly() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     byte[] firstStuff = values[127];
     queue.add(firstStuff);
@@ -111,7 +145,7 @@
 
     // Confirm that first stuff was in the file before we remove.
     byte[] data = new byte[firstStuff.length];
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, firstStuff.length);
     assertThat(data).isEqualTo(firstStuff);
 
@@ -121,22 +155,45 @@
     assertThat(queue.peek()).isEqualTo(secondStuff);
 
     // First should have been erased.
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, firstStuff.length);
     assertThat(data).isEqualTo(new byte[firstStuff.length]);
   }
 
   @Test public void testZeroSizeInHeaderThrows() throws IOException {
     RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd");
-    emptyFile.setLength(4096);
+    emptyFile.setLength(INITIAL_LENGTH);
     emptyFile.getChannel().force(true);
     emptyFile.close();
 
     try {
-      new QueueFile(file);
+      newQueueFile();
       fail("Should have thrown about bad header length");
     } catch (IOException ex) {
-      assertThat(ex).hasMessage("File is corrupt; length stored in header (0) is invalid.");
+      assertThat(ex).hasMessageThat()
+          .isEqualTo("File is corrupt; length stored in header (0) is invalid.");
+    }
+  }
+
+  @Test public void testSizeLessThanHeaderThrows() throws IOException {
+    RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd");
+    emptyFile.setLength(INITIAL_LENGTH);
+    if (forceLegacy) {
+      emptyFile.writeInt(headerLength - 1);
+    } else {
+      emptyFile.writeInt(0x80000001);
+      emptyFile.writeLong(headerLength - 1);
+    }
+    emptyFile.getChannel().force(true);
+    emptyFile.close();
+
+    try {
+      newQueueFile();
+      fail();
+    } catch (IOException ex) {
+      assertThat(ex.getMessage()).isIn(
+          Arrays.asList("File is corrupt; length stored in header (15) is invalid.",
+              "File is corrupt; length stored in header (31) is invalid."));
     }
   }
 
@@ -144,22 +201,23 @@
     RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd");
     emptyFile.seek(0);
     emptyFile.writeInt(-2147483648);
-    emptyFile.setLength(4096);
+    emptyFile.setLength(INITIAL_LENGTH);
     emptyFile.getChannel().force(true);
     emptyFile.close();
 
     try {
-      new QueueFile(file);
+      newQueueFile();
       fail("Should have thrown about bad header length");
     } catch (IOException ex) {
-      assertThat(ex) //
-          .hasMessage("File is corrupt; length stored in header (-2147483648) is invalid.");
+      assertThat(ex.getMessage()).isIn(
+          Arrays.asList("File is corrupt; length stored in header (-2147483648) is invalid.",
+              "Unable to read version 0 format. Supported versions are 1 and legacy."));
     }
   }
 
   @Test public void removeMultipleDoesNotCorrupt() throws IOException {
-    QueueFile queue = new QueueFile(file);
-    for (int i = 0; i < 10; i ++) {
+    QueueFile queue = newQueueFile();
+    for (int i = 0; i < 10; i++) {
       queue.add(values[i]);
     }
 
@@ -168,7 +226,7 @@
     assertThat(queue.peek()).isEqualTo(values[1]);
 
     queue.remove(3);
-    queue = new QueueFile(file);
+    queue = newQueueFile();
     assertThat(queue.size()).isEqualTo(6);
     assertThat(queue.peek()).isEqualTo(values[4]);
 
@@ -178,19 +236,19 @@
   }
 
   @Test public void removeDoesNotCorrupt() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     queue.add(values[127]);
     byte[] secondStuff = values[253];
     queue.add(secondStuff);
     queue.remove();
 
-    queue = new QueueFile(file);
+    queue = newQueueFile();
     assertThat(queue.peek()).isEqualTo(secondStuff);
   }
 
   @Test public void removeFromEmptyFileThrows() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     try {
       queue.remove();
@@ -199,8 +257,14 @@
     }
   }
 
+  @Test public void removeZeroFromEmptyFileDoesNothing() throws IOException {
+    QueueFile queue = newQueueFile();
+    queue.remove(0);
+    assertThat(queue.isEmpty()).isTrue();
+  }
+
   @Test public void removeNegativeNumberOfElementsThrows() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     queue.add(values[127]);
 
     try {
@@ -208,12 +272,12 @@
       fail("Should have thrown about removing negative number of elements.");
     } catch (IllegalArgumentException ex) {
       assertThat(ex) //
-          .hasMessage("Cannot remove negative (-1) number of elements.");
+          .hasMessageThat().isEqualTo("Cannot remove negative (-1) number of elements.");
     }
   }
 
   @Test public void removeZeroElementsDoesNothing() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     queue.add(values[127]);
 
     queue.remove(0);
@@ -221,7 +285,7 @@
   }
 
   @Test public void removeBeyondQueueSizeElementsThrows() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     queue.add(values[127]);
 
     try {
@@ -229,7 +293,8 @@
       fail("Should have thrown about removing too many elements.");
     } catch (IllegalArgumentException ex) {
       assertThat(ex) //
-          .hasMessage("Cannot remove more elements (10) than present in queue (1).");
+          .hasMessageThat()
+          .isEqualTo("Cannot remove more elements (10) than present in queue (1).");
     }
   }
 
@@ -239,7 +304,7 @@
       System.arraycopy(values[100], 0, bigBoy, i, values[100].length);
     }
 
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     queue.add(bigBoy);
     byte[] secondStuff = values[123];
@@ -247,7 +312,7 @@
 
     // Confirm that bigBoy was in the file before we remove.
     byte[] data = new byte[bigBoy.length];
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, bigBoy.length);
     assertThat(data).isEqualTo(bigBoy);
 
@@ -257,7 +322,7 @@
     assertThat(queue.peek()).isEqualTo(secondStuff);
 
     // First should have been erased.
-    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.seek(headerLength + Element.HEADER_LENGTH);
     queue.raf.readFully(data, 0, bigBoy.length);
     assertThat(data).isEqualTo(new byte[bigBoy.length]);
   }
@@ -265,10 +330,10 @@
   @Test public void testAddAndRemoveElements() throws IOException {
     long start = System.nanoTime();
 
-    Queue<byte[]> expected = new LinkedList<byte[]>();
+    Queue<byte[]> expected = new LinkedList<>();
 
     for (int round = 0; round < 5; round++) {
-      QueueFile queue = new QueueFile(file);
+      QueueFile queue = newQueueFile();
       for (int i = 0; i < N; i++) {
         queue.add(values[i]);
         expected.add(values[i]);
@@ -284,7 +349,7 @@
     }
 
     // Remove and validate remaining 15 elements.
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
     assertThat(queue.size()).isEqualTo(15);
     assertThat(queue.size()).isEqualTo(expected.size());
     while (!expected.isEmpty()) {
@@ -304,8 +369,8 @@
     // This should result in 3560 bytes.
     int max = 80;
 
-    Queue<byte[]> expected = new LinkedList<byte[]>();
-    QueueFile queue = new QueueFile(file);
+    Queue<byte[]> expected = new LinkedList<>();
+    QueueFile queue = newQueueFile();
 
     for (int i = 0; i < max; i++) {
       expected.add(values[i]);
@@ -332,13 +397,55 @@
     queue.close();
   }
 
+  /** Tests failed queue expansion when the data crosses EOF. */
+  @Test public void testFailedSplitExpansion() throws IOException {
+    // This should results in a full file, but doesn't trigger an expansion (yet)
+    int max = 86;
+
+    Queue<byte[]> expected = new LinkedList<>();
+    QueueFile queue = newQueueFile();
+
+    for (int i = 0; i < max; i++) {
+      expected.add(values[i]);
+      queue.add(values[i]);
+    }
+
+    // Remove all but 1 value and add back
+    // This should wrap around before expanding.
+    for (int i = 0; i < max - 1; i++) {
+      assertThat(queue.peek()).isEqualTo(expected.remove());
+      queue.remove();
+
+      expected.add(values[i]);
+      queue.add(values[i]);
+    }
+
+    //Try to insert element that causes file expansion, but fail
+    long fileLengthBeforeExpansion = file.length();
+    BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
+    queue = newQueueFile(braf);
+    try {
+      queue.add(values[max]);
+      fail();
+    } catch (IOException e) { /* expected */ }
+
+    //Check that the queue continues valid
+    braf.rejectCommit = false;
+    while (!expected.isEmpty()) {
+      assertThat(queue.peek()).isEqualTo(expected.remove());
+      queue.remove();
+    }
+
+    queue.close();
+  }
+
   @Test public void testFailedAdd() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
+    QueueFile queueFile = newQueueFile();
     queueFile.add(values[253]);
     queueFile.close();
 
-    final BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
-    queueFile = new QueueFile(braf);
+    BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
+    queueFile = newQueueFile(braf);
 
     try {
       queueFile.add(values[252]);
@@ -352,20 +459,20 @@
 
     queueFile.close();
 
-    queueFile = new QueueFile(file);
-    Assertions.assertThat(queueFile.size()).isEqualTo(2);
+    queueFile = newQueueFile();
+    assertThat(queueFile.size()).isEqualTo(2);
     assertThat(queueFile.peek()).isEqualTo(values[253]);
     queueFile.remove();
     assertThat(queueFile.peek()).isEqualTo(values[251]);
   }
 
   @Test public void testFailedRemoval() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
+    QueueFile queueFile = newQueueFile();
     queueFile.add(values[253]);
     queueFile.close();
 
-    final BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
-    queueFile = new QueueFile(braf);
+    BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
+    queueFile = newQueueFile(braf);
 
     try {
       queueFile.remove();
@@ -374,7 +481,7 @@
 
     queueFile.close();
 
-    queueFile = new QueueFile(file);
+    queueFile = newQueueFile();
     assertThat(queueFile.size()).isEqualTo(1);
     assertThat(queueFile.peek()).isEqualTo(values[253]);
 
@@ -384,12 +491,12 @@
   }
 
   @Test public void testFailedExpansion() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
+    QueueFile queueFile = newQueueFile();
     queueFile.add(values[253]);
     queueFile.close();
 
-    final BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
-    queueFile = new QueueFile(braf);
+    BrokenRandomAccessFile braf = new BrokenRandomAccessFile(file, "rwd");
+    queueFile = newQueueFile(braf);
 
     try {
       // This should trigger an expansion which should fail.
@@ -399,8 +506,7 @@
 
     queueFile.close();
 
-    queueFile = new QueueFile(file);
-
+    queueFile = newQueueFile();
     assertThat(queueFile.size()).isEqualTo(1);
     assertThat(queueFile.peek()).isEqualTo(values[253]);
     assertThat(queueFile.fileLength).isEqualTo(4096);
@@ -410,319 +516,6 @@
     assertThat(queueFile.peek()).isEqualTo(values[99]);
   }
 
-  @SuppressWarnings("deprecation") @Test
-  public void testPeekWithElementReader() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-    final byte[] a = {1, 2};
-    queueFile.add(a);
-    final byte[] b = {3, 4, 5};
-    queueFile.add(b);
-
-    final AtomicInteger peeks = new AtomicInteger(0);
-
-    queueFile.peek(new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(2);
-        byte[] actual = new byte[length];
-        in.read(actual);
-        assertThat(actual).isEqualTo(a);
-      }
-    });
-
-    queueFile.peek(new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(2);
-        assertThat(in.read()).isEqualTo(1);
-        assertThat(in.read()).isEqualTo(2);
-        assertThat(in.read()).isEqualTo(-1);
-      }
-    });
-
-    queueFile.remove();
-
-    queueFile.peek(new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(3);
-        byte[] actual = new byte[length];
-        in.read(actual);
-        assertThat(actual).isEqualTo(b);
-      }
-    });
-
-    assertThat(peeks.get()).isEqualTo(3);
-    assertThat(queueFile.peek()).isEqualTo(b);
-    assertThat(queueFile.size()).isEqualTo(1);
-  }
-
-  @Test public void testPeekWithElementVisitor() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-    final byte[] a = { 1, 2 };
-    queueFile.add(a);
-    final byte[] b = { 3, 4, 5 };
-    queueFile.add(b);
-
-    final AtomicInteger peeks = new AtomicInteger(0);
-
-    queueFile.peek(new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(2);
-        byte[] actual = new byte[length];
-        in.read(actual);
-        assertThat(actual).isEqualTo(a);
-        return true;
-      }
-    });
-
-    queueFile.peek(new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(2);
-        assertThat(in.read()).isEqualTo(1);
-        assertThat(in.read()).isEqualTo(2);
-        assertThat(in.read()).isEqualTo(-1);
-        return true;
-      }
-    });
-
-    queueFile.remove();
-
-    queueFile.peek(new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        peeks.incrementAndGet();
-
-        assertThat(length).isEqualTo(3);
-        byte[] actual = new byte[length];
-        in.read(actual);
-        assertThat(actual).isEqualTo(b);
-        return true;
-      }
-    });
-
-    assertThat(peeks.get()).isEqualTo(3);
-    assertThat(queueFile.peek()).isEqualTo(b);
-    assertThat(queueFile.size()).isEqualTo(1);
-  }
-
-  @SuppressWarnings("deprecation") @Test public void testForEach() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-
-    final byte[] a = {1, 2};
-    queueFile.add(a);
-    final byte[] b = {3, 4, 5};
-    queueFile.add(b);
-
-    final int[] iteration = new int[]{0};
-    QueueFile.ElementReader elementReader = new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        if (iteration[0] == 0) {
-          assertThat(length).isEqualTo(2);
-          byte[] actual = new byte[length];
-          in.read(actual);
-          assertThat(actual).isEqualTo(a);
-        } else if (iteration[0] == 1) {
-          assertThat(length).isEqualTo(3);
-          byte[] actual = new byte[length];
-          in.read(actual);
-          assertThat(actual).isEqualTo(b);
-        } else {
-          fail();
-        }
-        iteration[0]++;
-      }
-    };
-
-    queueFile.forEach(elementReader);
-
-    assertThat(queueFile.peek()).isEqualTo(a);
-    assertThat(iteration[0]).isEqualTo(2);
-  }
-
-  @SuppressWarnings("deprecation") @Test
-  public void testForEachReadWithOffset() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-
-    queueFile.add(new byte[] { 1, 2 });
-    queueFile.add(new byte[] { 3, 4, 5 });
-
-    final byte[] actual = new byte[5];
-    final int[] offset = new int[] { 0 };
-
-    QueueFile.ElementReader elementReader = new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        in.read(actual, offset[0], length);
-        offset[0] += length;
-      }
-    };
-
-    queueFile.forEach(elementReader);
-
-    assertThat(actual).isEqualTo(new byte[] { 1, 2, 3, 4, 5 });
-  }
-
-  @SuppressWarnings("deprecation") @Test public void testForEachStreamCopy() throws IOException {
-    final QueueFile queueFile = new QueueFile(file);
-    queueFile.add(new byte[] {1, 2});
-    queueFile.add(new byte[] {3, 4, 5});
-
-    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    final byte[] buffer = new byte[8];
-
-    final QueueFile.ElementReader elementReader = new QueueFile.ElementReader() {
-      @Override public void read(InputStream in, int length) throws IOException {
-        // A common idiom for copying data between two streams, but it depends on the
-        // InputStream correctly returning -1 when no more data is available
-        int count;
-        while ((count = in.read(buffer)) != -1) {
-          if (count == 0) {
-            // In the past, the ElementInputStream.read(byte[], int, int) method would return 0
-            // when no more bytes were available for reading. This test detects that error.
-            //
-            // Note: 0 is a valid return value for InputStream.read(byte[], int, int), which happens
-            // when the passed length is zero. We could trigger that through InputStream.read(byte[])
-            // by passing a zero-length buffer. However, since we won't do that during this test,
-            // we can safely assume that a return value of 0 indicates the past error in logic.
-            fail("This test should never receive a result of 0 from InputStream.read(byte[])");
-          }
-          baos.write(buffer, 0, count);
-        }
-      }
-    };
-
-    queueFile.forEach(elementReader);
-    assertThat(baos.toByteArray()).isEqualTo(new byte[] {1, 2, 3, 4, 5});
-  }
-
-  @Test public void testForEachVisitor() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-
-    final byte[] a = { 1, 2 };
-    queueFile.add(a);
-    final byte[] b = { 3, 4, 5 };
-    queueFile.add(b);
-
-    final int[] iteration = new int[] { 0 };
-    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        if (iteration[0] == 0) {
-          assertThat(length).isEqualTo(2);
-          byte[] actual = new byte[length];
-          in.read(actual);
-          assertThat(actual).isEqualTo(a);
-        } else if (iteration[0] == 1) {
-          assertThat(length).isEqualTo(3);
-          byte[] actual = new byte[length];
-          in.read(actual);
-          assertThat(actual).isEqualTo(b);
-        } else {
-          fail();
-        }
-        iteration[0]++;
-        return true;
-      }
-    };
-
-    int saw = queueFile.forEach(elementVisitor);
-    assertThat(saw).isEqualTo(2);
-    assertThat(queueFile.peek()).isEqualTo(a);
-    assertThat(iteration[0]).isEqualTo(2);
-  }
-
-  @Test public void testForEachVisitorReadWithOffset() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-
-    queueFile.add(new byte[] { 1, 2 });
-    queueFile.add(new byte[] { 3, 4, 5 });
-
-    final byte[] actual = new byte[5];
-    final int[] offset = new int[] { 0 };
-
-    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        in.read(actual, offset[0], length);
-        offset[0] += length;
-        return true;
-      }
-    };
-
-    int saw = queueFile.forEach(elementVisitor);
-    assertThat(saw).isEqualTo(2);
-    assertThat(actual).isEqualTo(new byte[] { 1, 2, 3, 4, 5 });
-  }
-
-  @Test public void testForEachVisitorStreamCopy() throws IOException {
-    final QueueFile queueFile = new QueueFile(file);
-    queueFile.add(new byte[] {1, 2});
-    queueFile.add(new byte[] {3, 4, 5});
-
-    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    final byte[] buffer = new byte[8];
-
-    final QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        // A common idiom for copying data between two streams, but it depends on the
-        // InputStream correctly returning -1 when no more data is available
-        int count;
-        while ((count = in.read(buffer)) != -1) {
-          if (count == 0) {
-            // In the past, the ElementInputStream.read(byte[], int, int) method would return 0
-            // when no more bytes were available for reading. This test detects that error.
-            //
-            // Note: 0 is a valid return value for InputStream.read(byte[], int, int), which happens
-            // when the passed length is zero. We could trigger that through InputStream.read(byte[])
-            // by passing a zero-length buffer. However, since we won't do that during this test,
-            // we can safely assume that a return value of 0 indicates the past error in logic.
-            fail("This test should never receive a result of 0 from InputStream.read(byte[])");
-          }
-          baos.write(buffer, 0, count);
-        }
-        return true;
-      }
-    };
-
-    int saw = queueFile.forEach(elementVisitor);
-    assertThat(saw).isEqualTo(2);
-    assertThat(baos.toByteArray()).isEqualTo(new byte[] {1, 2, 3, 4, 5});
-  }
-
-  @Test public void testForEachCanAbortEarly() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
-
-    final byte[] a = {1, 2};
-    queueFile.add(a);
-    final byte[] b = {3, 4, 5};
-    queueFile.add(b);
-
-    final AtomicInteger iteration = new AtomicInteger();
-    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
-      @Override public boolean read(InputStream in, int length) throws IOException {
-        if (iteration.get() == 0) {
-          assertThat(length).isEqualTo(2);
-          byte[] actual = new byte[length];
-          in.read(actual);
-          assertThat(actual).isEqualTo(a);
-        } else {
-          fail();
-        }
-        iteration.incrementAndGet();
-        return false;
-      }
-    };
-
-    int saw = queueFile.forEach(elementVisitor);
-    assertThat(saw).isEqualTo(1);
-    assertThat(queueFile.peek()).isEqualTo(a);
-    assertThat(iteration.get()).isEqualTo(1);
-  }
-
   /**
    * Exercise a bug where wrapped elements were getting corrupted when the
    * QueueFile was forced to expand in size and a portion of the final Element
@@ -730,7 +523,7 @@ public void testForEachReadWithOffset() throws IOException {
    */
   @Test public void testFileExpansionDoesntCorruptWrappedElements()
       throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
     byte[][] values = new byte[5][];
@@ -763,8 +556,8 @@ public void testForEachReadWithOffset() throws IOException {
       queue.remove();
 
       for (int i = 0; i < value.length; i++) {
-        assertThat(value[i]).isEqualTo((byte) (blockNum + 1))
-            .as("Block " + (blockNum + 1) + " corrupted at byte index " + i);
+        assertThat(value[i]).named("Block %1$d corrupted at byte index %2$d.", blockNum + 1, i)
+            .isEqualTo((byte) (blockNum + 1));
       }
     }
 
@@ -779,7 +572,7 @@ public void testForEachReadWithOffset() throws IOException {
    * expansion correctly update all their positions?
    */
   @Test public void testFileExpansionCorrectlyMovesElements() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
     byte[][] values = new byte[5][];
@@ -830,21 +623,47 @@ public void testForEachReadWithOffset() throws IOException {
       queue.remove();
 
       for (int i = 0; i < value.length; i++) {
-        assertThat(value[i]).isEqualTo(expectedBlockNumber)
-            .as("Block " + expectedBlockNumber + " corrupted at byte index " + i);
+        assertThat(value[i]).named("Block %1$d corrupted at byte index %2$d.", expectedBlockNumber,
+            i).isEqualTo(expectedBlockNumber);
       }
     }
 
     queue.close();
   }
 
+  @Test public void removingElementZeroesData() throws IOException {
+    QueueFile queueFile = newQueueFile(true);
+    queueFile.add(values[4]);
+    queueFile.remove();
+    queueFile.close();
+
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    source.skip(headerLength);
+    source.skip(Element.HEADER_LENGTH);
+    assertThat(source.readByteString(4).hex()).isEqualTo("00000000");
+  }
+
+  @Test public void removingElementDoesNotZeroData() throws IOException {
+    QueueFile queueFile = newQueueFile(false);
+    queueFile.add(values[4]);
+    queueFile.remove();
+    queueFile.close();
+
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    source.skip(headerLength);
+    source.skip(Element.HEADER_LENGTH);
+    assertThat(source.readByteString(4).hex()).isEqualTo("04030201");
+
+    source.close();
+  }
+
   /**
    * Exercise a bug where file expansion would leave garbage at the start of the header
    * and after the last element.
    */
   @Test public void testFileExpansionCorrectlyZeroesData()
       throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
     byte[][] values = new byte[5][];
@@ -873,19 +692,19 @@ public void testForEachReadWithOffset() throws IOException {
     queue.add(values[4]);
 
     // Read from header to first element and make sure it's zeroed.
-    int firstElementPadding = 1028;
+    int firstElementPadding = Element.HEADER_LENGTH + 1024;
     byte[] data = new byte[firstElementPadding];
-    queue.raf.seek(HEADER_LENGTH);
+    queue.raf.seek(headerLength);
     queue.raf.readFully(data, 0, firstElementPadding);
-    assertThat(data).containsOnly((byte) 0x00);
+    assertThat(data).isEqualTo(new byte[firstElementPadding]);
 
     // Read from the last element to the end and make sure it's zeroed.
-    int endOfLastElement = HEADER_LENGTH + firstElementPadding + 4 * (Element.HEADER_LENGTH + 1024);
+    int endOfLastElement = headerLength + firstElementPadding + 4 * (Element.HEADER_LENGTH + 1024);
     int readLength = (int) (queue.raf.length() - endOfLastElement);
     data = new byte[readLength];
     queue.raf.seek(endOfLastElement);
     queue.raf.readFully(data, 0, readLength);
-    assertThat(data).containsOnly((byte) 0x00);
+    assertThat(data).isEqualTo(new byte[readLength]);
   }
 
   /**
@@ -893,17 +712,17 @@ public void testForEachReadWithOffset() throws IOException {
    * are the same causes corruption.
    */
   @Test public void testSaturatedFileExpansionMovesElements() throws IOException {
-    QueueFile queue = new QueueFile(file);
+    QueueFile queue = newQueueFile();
 
     // Create test data - 1016-byte blocks marked consecutively 1, 2, 3, 4, 5 and 6,
     // four of which perfectly fill the queue file, taking into account the file header
     // and the item headers.
     // Each item is of length
-    // (QueueFile.INITIAL_LENGTH - QueueFile.HEADER_LENGTH) / 4 - element_header_length
+    // (QueueFile.INITIAL_LENGTH - headerLength) / 4 - element_header_length
     // = 1016 bytes
     byte[][] values = new byte[6][];
     for (int blockNum = 0; blockNum < values.length; blockNum++) {
-      values[blockNum] = new byte[1016];
+      values[blockNum] = new byte[(INITIAL_LENGTH - headerLength) / 4 - Element.HEADER_LENGTH];
       for (int i = 0; i < values[blockNum].length; i++) {
         values[blockNum][i] = (byte) (blockNum + 1);
       }
@@ -937,7 +756,7 @@ public void testForEachReadWithOffset() throws IOException {
    * was non contiguous throws an {@link java.io.EOFException}.
    */
   @Test public void testReadHeadersFromNonContiguousQueueWorks() throws IOException {
-    QueueFile queueFile = new QueueFile(file);
+    QueueFile queueFile = newQueueFile();
 
     // Fill the queue up to `length - 2` (i.e. remainingBytes() == 2).
     for (int i = 0; i < 15; i++) {
@@ -954,15 +773,154 @@ public void testForEachReadWithOffset() throws IOException {
     queueFile.close();
 
     // File should not be corrupted.
-    QueueFile queueFile2 = new QueueFile(file);
+    QueueFile queueFile2 = newQueueFile();
     assertThat(queueFile2.size()).isEqualTo(queueSize);
   }
 
+  @Test public void testIterator() throws IOException {
+    byte[] data = values[10];
+
+    for (int i = 0; i < 10; i++) {
+      QueueFile queueFile = newQueueFile();
+      for (int j = 0; j < i; j++) {
+        queueFile.add(data);
+      }
+
+      int saw = 0;
+      for (byte[] element : queueFile) {
+        assertThat(element).isEqualTo(data);
+        saw++;
+      }
+      assertThat(saw).isEqualTo(i);
+      file.delete();
+    }
+  }
+
+  @Test public void testIteratorNextThrowsWhenEmpty() throws IOException {
+    QueueFile queueFile = newQueueFile();
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException ignored) {
+    }
+  }
+
+  @Test public void testIteratorNextThrowsWhenExhausted() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    queueFile.add(values[0]);
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    iterator.next();
+
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException ignored) {
+    }
+  }
+
+  @Test public void testIteratorRemove() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    while (iterator.hasNext()) {
+      iterator.next();
+      iterator.remove();
+    }
+
+    assertThat(queueFile).isEmpty();
+  }
+
+  @Test public void testIteratorRemoveDisallowsConcurrentModification() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    iterator.next();
+    queueFile.remove();
+    try {
+      iterator.remove();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorHasNextDisallowsConcurrentModification() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    iterator.next();
+    queueFile.remove();
+    try {
+      iterator.hasNext();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorDisallowsConcurrentModificationWithClear() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    iterator.next();
+    queueFile.clear();
+    try {
+      iterator.hasNext();
+      fail();
+    } catch (ConcurrentModificationException ignored) {
+    }
+  }
+
+  @Test public void testIteratorOnlyRemovesFromHead() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    Iterator<byte[]> iterator = queueFile.iterator();
+    iterator.next();
+    iterator.next();
+
+    try {
+      iterator.remove();
+      fail();
+    } catch (UnsupportedOperationException ex) {
+      assertThat(ex).hasMessageThat().isEqualTo("Removal is only permitted from the head.");
+    }
+  }
+
+  @Test public void queueToString() throws IOException {
+    QueueFile queueFile = newQueueFile();
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[i]);
+    }
+
+    assertThat(queueFile.toString()).isIn(Arrays.asList("QueueFile[length=4096, size=15, "
+        + "first=Element[position=16, length=0], "
+        + "last=Element[position=163, length=14]]", "QueueFile[length=4096, size=15, "
+        + "first=Element[position=32, length=0], "
+        + "last=Element[position=179, length=14]]"));
+  }
+
   /**
    * A RandomAccessFile that can break when you go to write the COMMITTED
    * status.
    */
-  static class BrokenRandomAccessFile extends RandomAccessFile {
+  static final class BrokenRandomAccessFile extends RandomAccessFile {
     boolean rejectCommit = true;
 
     BrokenRandomAccessFile(File file, String mode)
@@ -970,11 +928,11 @@ public void testForEachReadWithOffset() throws IOException {
       super(file, mode);
     }
 
-    @Override public void write(byte[] buffer) throws IOException {
+    @Override public void write(byte[] b, int off, int len) throws IOException {
       if (rejectCommit && getFilePointer() == 0) {
         throw new IOException("No commit for you!");
       }
-      super.write(buffer);
+      super.write(b, off, len);
     }
   }
 }
diff --git a/tape/src/test/java/com/squareup/tape/QueueTestUtils.java b/tape/src/test/java/com/squareup/tape2/QueueTestUtils.java
similarity index 78%
rename from tape/src/test/java/com/squareup/tape/QueueTestUtils.java
rename to tape/src/test/java/com/squareup/tape2/QueueTestUtils.java
index b6408cc..98781f0 100644
--- a/tape/src/test/java/com/squareup/tape/QueueTestUtils.java
+++ b/tape/src/test/java/com/squareup/tape2/QueueTestUtils.java
@@ -1,16 +1,17 @@
 // Copyright 2012 Square, Inc.
-package com.squareup.tape;
-
-import org.apache.commons.io.FileUtils;
+package com.squareup.tape2;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import okio.BufferedSink;
+import okio.Okio;
 
 import static org.junit.Assert.assertTrue;
 
 public class QueueTestUtils {
-  static final String TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE = "/truncated-one-entry-serialized-queue";
+  static final String TRUNCATED_ONE_ENTRY_SERIALIZED_QUEUE =
+      "/truncated-one-entry-serialized-queue";
   static final String TRUNCATED_EMPTY_SERIALIZED_QUEUE = "/truncated-empty-serialized-queue";
   static final String ONE_ENTRY_SERIALIZED_QUEUE = "/one-entry-serialized-queue";
   static final String EMPTY_SERIALIZED_QUEUE = "/empty-serialized-queue";
@@ -19,7 +20,9 @@
   static File copyTestFile(String file) throws IOException {
     File newFile = File.createTempFile(file, "test");
     InputStream in = QueueTestUtils.class.getResourceAsStream(file);
-    FileUtils.copyInputStreamToFile(in, newFile);
+    try (BufferedSink sink = Okio.buffer(Okio.sink(newFile))) {
+      sink.writeAll(Okio.source(in));
+    }
     assertTrue(newFile.exists());
     return newFile;
   }
diff --git a/website/index.html b/website/index.html
index a0a2c84..ed41a53 100644
--- a/website/index.html
+++ b/website/index.html
@@ -26,98 +26,19 @@ <h2 id="about">About</h2>
           <p>Tape is a collection of queue-related classes for Android and Java by Square, Inc.</p>
           <p><code>QueueFile</code> is a lightning-fast, transactional, file-based FIFO. Addition and removal from an instance is an O(1) operation and is atomic. Writes are synchronous; data will be written to disk before an operation returns. The underlying file is structured to survive process and even system crashes and if an I/O exception is thrown during a mutating change, the change is aborted.</p>
           <p>An <code>ObjectQueue</code> represents an ordering of arbitrary objects which can be backed either by the filesystem (via <code>QueueFile</code>) or in memory only.</p>
-          <p><code>TaskQueue</code> is a special object queue which holds <code>Task</code>s, objects which have a notion of being executed. Instances are managed by an external executor which prepares and executes enqueued tasks.</p>
         </div>
         <div class="span5 offset1">
           <h2 id="download">Download</h2>
           <p>Available via Maven or as a downloadable <code>.jar</code>.</p>
-          <p><a href="https://search.maven.org/remote_content?g=com.squareup&a=tape&v=LATEST" class="btn btn-inverse btn-large" id="download-btn">Download Latest</a></p>
+          <p><a href="https://search.maven.org/remote_content?g=com.squareup.tape2&a=tape&v=LATEST" class="btn btn-inverse btn-large" id="download-btn">Download Latest</a></p>
           <p><a href="http://github.com/square/tape" id="ribbon">Fork Tape on GitHub</a></p>
           <pre class="maven">&lt;dependency>
-    &lt;groupId>com.squareup&lt;/groupId>
+    &lt;groupId>com.squareup.tape2&lt;/groupId>
     &lt;artifactId>tape&lt;/artifactId>
     &lt;version><span id="mvn-version"><em>(insert latest)</em></span>&lt;/version>
 &lt;/dependency></pre>
         </div>
       </div>
-      <div class="row">
-        <div class="span12">
-          <h2 id="examples">Examples</h2>
-          <p>For a more complete example of a background image uploader which expands on both of the following examples see the <a href="https://github.com/square/tape/tree/master/tape-sample">sample Android application</a> in the repository.</p>
-          <h3 id="example-image-queue">Android Task Queue Service</h3>
-          <p>When used on Android, a service is the perfect companion to a <code>TaskQueue</code> since it allows actions to be completed in the background. If the user is uploading new photos to their favorite sharing site, the service will iterate through the queue until all of the upload tasks completes successfully.</p>
-          <pre class="prettyprint">/** Listener for starting the upload service when the queue has tasks. */
-public class ImageQueueServiceListener implements ObjectQueue.Listener&lt;ImageUploadTask> {
-  private final Context context;
-
-  public ImageQueueServiceStarter(Context context) {
-    this.context = context;
-  }
-
-  @Override public void onAdd(ObjectQueue&lt;ImageUploadTask> queue, ImageUploadTask task) {
-    context.startService(new Intent(context, ImageQueueService.class));
-  }
-
-  @Override public void onRemove(ObjectQueue&lt;ImageUploadTask> queue) {}
-}
-
-/** Service which iterates through pending upload tasks one-by-one. */
-public class ImageQueueService extends Service implements ImageUploadTask.Callback {
-  private TaskQueue&lt;ImageUploadTask> queue;
-  private boolean running;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    // Obtain TaskQueue here (e.g., through injection)
-  }
-
-  @Override public int onStartCommand(Intent intent, int flags, int startId) {
-    executeNext();
-    return START_STICKY;
-  }
-
-  public void executeNext() {
-    if (running) return; // Only one task at a time.
-    ImageUploadTask task = queue.peek();
-    if (task != null) {
-      task.execute(this);
-      running = true;
-      return;
-    }
-    stopSelf(); // We're done for now.
-  }
-
-  @Override public void imageUploadComplete() {
-    running = false;
-    queue.remove();
-    executeNext();
-  }
-}</pre>
-          <h3 id="example-gson">GSON Object Converter</h3>
-          <p>As an alternative to traditional object serialization, GSON makes it really easy to convert objects to and from a format that can be written to disk by the <code>FileObjectQueue</code>. This allows for much more flexibility in modifying classes moving forward as well as providing a human-readable storage format.</p>
-          <pre class="prettyprint">/** Converter which uses GSON to serialize instances of class T to disk. */
-public class GsonConverter&lt;T> implements FileObjectQueue.Converter&lt;T> {
-  private final Gson gson;
-  private final Class&lt;T> type;
-
-  public GsonConverter(Gson gson, Class&lt;T> type) {
-    this.gson = gson;
-    this.type = type;
-  }
-
-  @Override public T from(byte[] bytes) {
-    Reader reader = new InputStreamReader(new ByteArrayInputStream(bytes));
-    return gson.fromJson(reader, type);
-  }
-
-  @Override public void toStream(T object, OutputStream bytes) throws IOException {
-    Writer writer = new OutputStreamWriter(bytes);
-    gson.toJson(object, writer);
-    writer.close();
-  }
-}</pre>
-        </div>
-      </div>
       <div class="row">
         <div class="span6">
           <h2 id="contribute">Contribute</h2>
@@ -142,7 +63,7 @@ <h2 id="license">License</h2>
     <script> prettyPrint(); </script>
     <script>
         // Look up the latest version of the library.
-        $.fn.artifactVersion('com.squareup', 'tape', function(version, url) {
+        $.fn.artifactVersion('com.squareup.tape2', 'tape', function(version, url) {
           $('#mvn-version').text(version);
           $('#download-btn').text('Download v' + version).attr('href', url);
         });
