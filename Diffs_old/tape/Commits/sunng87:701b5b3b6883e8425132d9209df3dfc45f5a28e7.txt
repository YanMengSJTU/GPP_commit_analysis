diff --git a/tape/src/main/java/com/squareup/tape/InfQueue.java b/tape/src/main/java/com/squareup/tape/InfQueue.java
new file mode 100644
index 0000000..c769eb7
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape/InfQueue.java
@@ -0,0 +1,170 @@
+package com.squareup.tape;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * Created by nsun on 16-4-22.
+ */
+public class InfQueue<E> extends LinkedBlockingQueue<E> implements BlockingQueue<E> {
+
+    int memoryQueueSize;
+    FileObjectQueue<E> backendQueue;
+    ReentrantLock backendQueueLock = new ReentrantLock();
+
+    public InfQueue(int inMemorySize, FileObjectQueue.Converter<E> converter, File queueFile) throws IOException {
+        super(inMemorySize);
+        this.memoryQueueSize = inMemorySize;
+        backendQueue = new FileObjectQueue<E>(queueFile, converter);
+    }
+
+    @Override
+    public int size() {
+        return super.size() + backendQueue.size();
+    }
+
+    @Override
+    public void put(E e) throws InterruptedException {
+        if (this.size() < this.memoryQueueSize) {
+            super.put(e);
+        } else {
+            try{
+                backendQueueLock.lock();
+                backendQueue.add(e);
+            } finally {
+                backendQueueLock.unlock();
+            }
+        }
+    }
+
+    @Override
+    public boolean offer(E e, long l, TimeUnit timeUnit) throws InterruptedException {
+        boolean offered = super.offer(e, l, timeUnit);
+        if (! offered) {
+            try {
+                backendQueueLock.lock();
+                backendQueue.add(e);
+            } finally {
+                backendQueueLock.unlock();
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public boolean offer(E e) {
+        try {
+            this.put(e);
+        } catch (InterruptedException e1) {
+        }
+        return true;
+    }
+
+    @Override
+    public E poll(long l, TimeUnit timeUnit) throws InterruptedException {
+        try {
+            backendQueueLock.lock();
+            if (this.backendQueue.size() > 0) {
+                E obj = this.backendQueue.peek();
+                this.backendQueue.remove();
+                return obj;
+            } else {
+                return super.poll(l, timeUnit);
+            }
+        } finally {
+            backendQueueLock.unlock();
+        }
+
+    }
+
+    @Override
+    public E poll() {
+        try {
+            backendQueueLock.lock();
+            if (this.backendQueue.size() > 0) {
+                E obj = this.backendQueue.peek();
+                this.backendQueue.remove();
+                return obj;
+            } else {
+                return super.poll();
+            }
+        } finally {
+            backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public E peek() {
+        try {
+            backendQueueLock.lock();
+            if (this.backendQueue.size() > 0) {
+                E obj = this.backendQueue.peek();
+                return obj;
+            } else {
+                return super.peek();
+            }
+        } finally {
+            backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public E take() throws InterruptedException {
+        try {
+            backendQueueLock.lock();
+            if (this.backendQueue.size() > 0) {
+                E obj = this.backendQueue.peek();
+                this.backendQueue.remove();
+                return obj;
+            } else {
+                return super.take();
+            }
+        } finally {
+            backendQueueLock.unlock();
+        }
+    }
+
+    E peekFromMemoryQueue() {
+        return super.peek();
+    }
+
+    E takeFromMemoryQueue() throws InterruptedException {
+        return super.take();
+    }
+
+    E pollFromMemoryQueue() {
+        return super.poll();
+    }
+
+    E pollFromMemoryQueue(long l, TimeUnit timeUnit) throws InterruptedException {
+        return super.poll(l, timeUnit);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        throw new UnsupportedOperationException("Not work for now");
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        throw new UnsupportedOperationException("Not work for now");
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.backendQueue.size() == 0 && super.isEmpty();
+    }
+
+    public void close() {
+        this.backendQueue.close();
+    }
+}
diff --git a/tape/src/main/java/com/squareup/tape/StrictInfQueue.java b/tape/src/main/java/com/squareup/tape/StrictInfQueue.java
new file mode 100644
index 0000000..7b70eca
--- /dev/null
+++ b/tape/src/main/java/com/squareup/tape/StrictInfQueue.java
@@ -0,0 +1,284 @@
+package com.squareup.tape;
+
+import java.io.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Created by nsun on 16-4-25.
+ */
+public class StrictInfQueue<E> implements BlockingQueue<E> {
+
+    private AtomicLong orderCounter = new AtomicLong();
+    private InfQueue<StrictInfQueue.OrderedWrapper<E>> innerQueue;
+
+    public StrictInfQueue(int inMemorySize, FileObjectQueue.Converter<E> converter, File queueFile) throws IOException {
+        innerQueue = new InfQueue<StrictInfQueue.OrderedWrapper<E>>(inMemorySize, new OrderedWrapperConverter(converter), queueFile);
+    }
+
+    OrderedWrapper<E> wrappedValue(E e) {
+        OrderedWrapper<E> wrappedValue = new OrderedWrapper<E>();
+        wrappedValue.id = orderCounter.getAndIncrement();
+        wrappedValue.value = e;
+        return wrappedValue;
+    }
+
+    @Override
+    public void put(E e) throws InterruptedException {
+        OrderedWrapper<E> wv = wrappedValue(e);
+        innerQueue.put(wv);
+    }
+
+    @Override
+    public boolean offer(E e, long l, TimeUnit timeUnit) throws InterruptedException {
+        OrderedWrapper<E> wv = wrappedValue(e);
+        return innerQueue.offer(wv, l, timeUnit);
+    }
+
+    @Override
+    public boolean offer(E e) {
+        OrderedWrapper<E> wv = wrappedValue(e);
+        return innerQueue.offer(wv);
+    }
+
+    @Override
+    public E poll(long l, TimeUnit timeUnit) throws InterruptedException {
+        try {
+            innerQueue.backendQueueLock.lock();
+            if (innerQueue.backendQueue.size() > 0) {
+                OrderedWrapper<E> objFromFile = innerQueue.backendQueue.peek();
+                OrderedWrapper<E> objFromMem = innerQueue.peekFromMemoryQueue();
+                if (objFromMem == null || objFromFile.id < objFromMem.id) {
+                    innerQueue.backendQueue.remove();
+                    return objFromFile.value;
+                } else {
+                    innerQueue.takeFromMemoryQueue();
+                    return objFromMem.value;
+                }
+            } else {
+                OrderedWrapper<E> vw = innerQueue.pollFromMemoryQueue(l, timeUnit);
+                if (vw != null) {
+                    return vw.value;
+                } else {
+                    return null;
+                }
+            }
+        } finally {
+            innerQueue.backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public E poll() {
+        try {
+            innerQueue.backendQueueLock.lock();
+            if (innerQueue.backendQueue.size() > 0) {
+                OrderedWrapper<E> objFromFile = innerQueue.backendQueue.peek();
+                OrderedWrapper<E> objFromMem = innerQueue.peekFromMemoryQueue();
+                if (objFromMem == null || objFromFile.id < objFromMem.id) {
+                    innerQueue.backendQueue.remove();
+                    return objFromFile.value;
+                } else {
+                    innerQueue.takeFromMemoryQueue();
+                    return objFromMem.value;
+                }
+            } else {
+                OrderedWrapper<E> vw = innerQueue.pollFromMemoryQueue();
+                if (vw != null) {
+                    return vw.value;
+                } else {
+                    return null;
+                }
+            }
+        } catch (InterruptedException e) {
+            return null;
+        } finally {
+            innerQueue.backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public E element() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public E peek() {
+        try {
+            innerQueue.backendQueueLock.lock();
+            if (innerQueue.backendQueue.size() > 0) {
+                OrderedWrapper<E> objFromFile = innerQueue.backendQueue.peek();
+                OrderedWrapper<E> objFromMem = innerQueue.peekFromMemoryQueue();
+                if (objFromMem == null || objFromFile.id < objFromMem.id) {
+                    return objFromFile.value;
+                } else {
+                    return objFromMem.value;
+                }
+            } else {
+                OrderedWrapper<E> vw = innerQueue.peekFromMemoryQueue();
+                if (vw != null) {
+                    return vw.value;
+                } else {
+                    return null;
+                }
+            }
+        } finally {
+            innerQueue.backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public E take() throws InterruptedException {
+
+        try {
+            innerQueue.backendQueueLock.lock();
+            if (innerQueue.backendQueue.size() > 0) {
+                OrderedWrapper<E> objFromFile = innerQueue.backendQueue.peek();
+                OrderedWrapper<E> objFromMem = innerQueue.peekFromMemoryQueue();
+                if (objFromMem == null || objFromFile.id < objFromMem.id) {
+                    innerQueue.backendQueue.remove();
+                    return objFromFile.value;
+                } else {
+                    innerQueue.takeFromMemoryQueue();
+                    return objFromMem.value;
+                }
+            } else {
+                OrderedWrapper<E> ev = innerQueue.takeFromMemoryQueue();
+                if (ev != null) {
+                    return ev.value;
+                } else {
+                    return null;
+                }
+            }
+        } catch (InterruptedException e) {
+            return null;
+        } finally {
+            innerQueue.backendQueueLock.unlock();
+        }
+    }
+
+    @Override
+    public boolean add(E e) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> collection) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> collection) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> collection) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public void clear() {
+        innerQueue.clear();
+    }
+
+    @Override
+    public E remove() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public int remainingCapacity() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> collection) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public int size() {
+        return innerQueue.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return innerQueue.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public Object[] toArray() {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public <T> T[] toArray(T[] ts) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public int drainTo(Collection<? super E> collection) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    @Override
+    public int drainTo(Collection<? super E> collection, int i) {
+        throw new UnsupportedOperationException("Not work for now.");
+    }
+
+    static class OrderedWrapper<E> {
+        E value;
+        long id;
+    }
+
+    static class OrderedWrapperConverter<E> implements FileObjectQueue.Converter<OrderedWrapper<E>> {
+        private FileObjectQueue.Converter<E> origConverter;
+
+        public OrderedWrapperConverter(FileObjectQueue.Converter<E> converter) {
+            this.origConverter = converter;
+        }
+
+        @Override
+        public OrderedWrapper<E> from(byte[] bytes) throws IOException {
+            byte[] idBytes = Arrays.copyOfRange(bytes, 0, 8);
+            byte[] dataBytes = Arrays.copyOfRange(bytes, 8, bytes.length);
+
+            DataInputStream dis = new DataInputStream(new ByteArrayInputStream(idBytes));
+            long id = dis.readLong();
+
+            OrderedWrapper<E> ow = new OrderedWrapper<E>();
+            ow.id = id;
+            ow.value = this.origConverter.from(dataBytes);
+
+            return ow;
+        }
+
+        @Override
+        public void toStream(OrderedWrapper<E> o, OutputStream bytes) throws IOException {
+            DataOutputStream dos = new DataOutputStream(bytes);
+            dos.writeLong(o.id);
+
+            this.origConverter.toStream(o.value, bytes);
+        }
+    }
+}
diff --git a/tape/src/test/java/com/squareup/tape/InfQueueTest.java b/tape/src/test/java/com/squareup/tape/InfQueueTest.java
new file mode 100644
index 0000000..4d1e887
--- /dev/null
+++ b/tape/src/test/java/com/squareup/tape/InfQueueTest.java
@@ -0,0 +1,79 @@
+package com.squareup.tape;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Created by nsun on 16-4-25.
+ */
+public class InfQueueTest {
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+    InfQueue<String> q;
+
+    @Before
+    public void setUp() throws IOException {
+        File parent = folder.getRoot();
+        File file = new File(parent, "infqueue-file");
+        q = new InfQueue<String>(1, new SerializedConverter<String>(), file);
+    }
+
+    @Test
+    public void testPut() throws IOException, InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.size()).isEqualTo(2);
+        q.close();
+    }
+
+    @Test
+    public void testOffer() throws IOException {
+        assertThat(q.offer("hello")).isTrue();
+        assertThat(q.offer("world")).isTrue();
+        assertThat(q.size()).isEqualTo(2);
+    }
+
+    @Test
+    public void testOfferWithTimeout() throws InterruptedException {
+        assertThat(q.offer("hello", 100, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(q.offer("world", 100, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(q.size()).isEqualTo(2);
+    }
+
+    @Test
+    public void testTake() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.take()).isEqualTo("world");
+        assertThat(q.take()).isEqualTo("hello");
+    }
+
+    @Test
+    public void testPoll() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+        assertThat(q.poll()).isEqualTo("world");
+        assertThat(q.poll()).isEqualTo("hello");
+        assertThat(q.poll()).isNull();
+    }
+
+    @Test
+    public void testPollWithTimeout() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isEqualTo("world");
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isEqualTo("hello");
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isNull();
+    }
+}
diff --git a/tape/src/test/java/com/squareup/tape/StrictInfQueueTest.java b/tape/src/test/java/com/squareup/tape/StrictInfQueueTest.java
new file mode 100644
index 0000000..a14e430
--- /dev/null
+++ b/tape/src/test/java/com/squareup/tape/StrictInfQueueTest.java
@@ -0,0 +1,78 @@
+package com.squareup.tape;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * Created by nsun on 16-4-25.
+ */
+public class StrictInfQueueTest {
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+    StrictInfQueue<String> q;
+
+    @Before
+    public void setUp() throws IOException {
+        File parent = folder.getRoot();
+        File file = new File(parent, "infqueue-file");
+        q = new StrictInfQueue<String>(1, new SerializedConverter<String>(), file);
+    }
+
+    @Test
+    public void testPut() throws IOException, InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.size()).isEqualTo(2);
+    }
+
+    @Test
+    public void testOffer() throws IOException {
+        assertThat(q.offer("hello")).isTrue();
+        assertThat(q.offer("world")).isTrue();
+        assertThat(q.size()).isEqualTo(2);
+    }
+
+    @Test
+    public void testOfferWithTimeout() throws InterruptedException {
+        assertThat(q.offer("hello", 100, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(q.offer("world", 100, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(q.size()).isEqualTo(2);
+    }
+
+    @Test
+    public void testTake() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.take()).isEqualTo("hello");
+        assertThat(q.take()).isEqualTo("world");
+    }
+
+    @Test
+    public void testPoll() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+        assertThat(q.poll()).isEqualTo("hello");
+        assertThat(q.poll()).isEqualTo("world");
+        assertThat(q.poll()).isNull();
+    }
+
+    @Test
+    public void testPollWithTimeout() throws InterruptedException {
+        q.put("hello");
+        q.put("world");
+
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isEqualTo("hello");
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isEqualTo("world");
+        assertThat(q.poll(100, TimeUnit.MILLISECONDS)).isNull();
+    }
+}
