diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 0000000..a96fb32
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/tape"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 0000000..91f444b
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.travis.yml b/.travis.yml
index 477aa3a..ce88ca8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,4 +1,23 @@
-language: java
+language: android
+
+android:
+  components:
+    - build-tools-20.0.0
+    - android-16
+  licenses:
+    - android-sdk-license-5be876d5
+
+jdk:
+  - oraclejdk7
+  - oraclejdk8
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "gPnO4rMnW2zFPsx5ROwM1+8+r+fsm2z0n477RMcN+2xWu5QrmfKcdPBj7QFBfWDkwIi/EdASEcID6MzFXPwcU21io18NKt9OMgpuzGyUf2W5oVJN/jYIlC5vPXFeGfsH2Eh3ZMhztSH2ADN9lPAxvThY//FhEMj+MH/z8zVljHA="
+    - secure: "A4Lps6F7ZcHHQT1zWbdrzp58uho2NcMYsAxB9D/Bbmxwm1uHJ/N8BN2rQilmsu46PzSN9WngKpK04mPn8hTXQPMcnymmM0p4aWQqmwfRDe4QLn1baXkjXUDrdAprRwVEJ2RF2cZXBn64zCtHVRD+TA36FSAx+on/JYDVceKu03Y="
 
 branches:
   except:
@@ -7,12 +26,8 @@ branches:
 notifications:
   email: false
 
-before_install:
-  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
-  - tar -zxf android-sdk_r21.0.1-linux.tgz
-  - export ANDROID_HOME=~/builds/square/tape/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  - TOOLS=$(android list sdk --no-ui | grep "Android SDK Platform-tools" | cut -d"-" -f1)
-  - android update sdk --filter "$TOOLS" --no-ui --force
-  - SDK=$(android list sdk --no-ui | grep ", API 16," | cut -d"-" -f1)
-  - android update sdk --filter "$SDK" --no-ui --force
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index ade6847..5139469 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,47 @@
 Change Log
 ==========
 
+Version 1.3.0 *(In Development)*
+--------------------------------
+
+ * New: `remove(int)` allows atomic removal of multiple elements.
+ * New: `forEach(ElementVisitor)` allows iterating queue items and stopping iteration early.
+ * `QueueFile` now implements the `Closeable` interface.
+ * Fix: Do not erase data before updating the header when calling `clear()` or `remove()`.
+
+
+Version 1.2.3 *(2014-10-07)*
+----------------------------
+
+ * `close()` method on `FileObjectQueue` now closes underlying `QueueFile`.
+ * Fix: Properly move and zero out bytes during copy opertaions.
+
+
+Version 1.2.2 *(2014-03-18)*
+----------------------------
+
+ * Fix: Prevent corruption when expanding a perfectly saturated queue.
+
+
+Version 1.2.1 *(2014-03-06)*
+----------------------------
+
+ * New: `QueueFile` instances throw an `IOException` on creation if a corrupt header is found.
+
+
+Version 1.2.0 *(2014-01-16)*
+----------------------------
+
+ * New: Zero out old records in `clear()` and `remove()`.
+
+
+Version 1.1.1 *(2013-10-21)*
+----------------------------
+
+ * Fix: Ensure -1 is returned when no more bytes are available.
+ * Fix: Correct read to use position offset in certain cases where it would otherwise use 0.
+
+
 Version 1.1.0 *(2012-11-08)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 10a3402..79797f9 100644
--- a/README.md
+++ b/README.md
@@ -23,17 +23,20 @@ prepares and executes enqueued tasks.
 Download
 --------
 
-Downloadable .jars can be found on the [GitHub download page][2].
-
-You can also depend on the .jar through Maven:
-
+Download [the latest JAR][2] or grab via Maven:
 ```xml
 <dependency>
-    <groupId>com.squareup</groupId>
-    <artifactId>tape</artifactId>
-    <version>(insert latest version)</version>
+  <groupId>com.squareup</groupId>
+  <artifactId>tape</artifactId>
+  <version>1.2.3</version>
 </dependency>
 ```
+or Gradle:
+```groovy
+compile 'com.squareup:tape:1.2.3'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
@@ -57,4 +60,5 @@ License
 
 
  [1]: http://square.github.com/tape/
- [2]: http://github.com/square/tape/downloads
+ [2]: https://search.maven.org/remote_content?g=com.squareup&a=tape&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/deploy_website.sh b/deploy_website.sh
new file mode 100755
index 0000000..6664c71
--- /dev/null
+++ b/deploy_website.sh
@@ -0,0 +1,45 @@
+#!/bin/bash
+
+set -ex
+
+REPO="git@github.com:square/tape.git"
+GROUP_ID="com.squareup"
+ARTIFACT_ID="tape"
+
+DIR=temp-clone
+
+# Delete any existing temporary website clone
+rm -rf $DIR
+
+# Clone the current repo into temp folder
+git clone $REPO $DIR
+
+# Move working directory into temp folder
+cd $DIR
+
+# Checkout and track the gh-pages branch
+git checkout -t origin/gh-pages
+
+# Delete everything
+rm -rf *
+
+# Copy website files from real repo
+cp -R ../website/* .
+
+# Download the latest javadoc
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+mkdir javadoc
+unzip javadoc.zip -d javadoc
+rm javadoc.zip
+
+# Stage all files in git and create a commit
+git add .
+git add -u
+git commit -m "Website at $(date)"
+
+# Push the new files up to GitHub
+git push origin gh-pages
+
+# Delete our temp folder
+cd ..
+rm -rf $DIR
diff --git a/pom.xml b/pom.xml
index f774b4f..c231aa3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup</groupId>
   <artifactId>tape-parent</artifactId>
-  <version>1.1.1-SNAPSHOT</version>
+  <version>1.2.4-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Tape (Parent)</name>
@@ -55,7 +55,7 @@
   <scm>
     <url>http://github.com/square/tape</url>
     <connection>scm:git:git://github.com/square/tape.git</connection>
-    <developerConnection>scg:git:git@github.com:square/tape.git</developerConnection>
+    <developerConnection>scm:git:git@github.com:square/tape.git</developerConnection>
     <tag>HEAD</tag>
   </scm>
 
@@ -133,7 +133,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>2.5</version>
+          <version>3.1</version>
           <configuration>
             <source>1.6</source>
             <target>1.6</target>
@@ -162,7 +162,7 @@
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.3.2</version>
+          <version>3.8.2</version>
           <configuration>
             <sdk>
               <platform>${android.platform}</platform>
@@ -176,7 +176,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.3.2</version>
+        <version>2.5</version>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
diff --git a/tape-sample/pom.xml b/tape-sample/pom.xml
index 4a68d05..5cd5501 100644
--- a/tape-sample/pom.xml
+++ b/tape-sample/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>tape-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.4-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java b/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java
index f8fd8af..bb4b93e 100644
--- a/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java
+++ b/tape-sample/src/main/java/com/squareup/tape/sample/GsonConverter.java
@@ -14,7 +14,7 @@
 
 /**
  * Use GSON to serialize classes to a bytes.
- * <p/>
+ * <p>
  * Note: This will only work when concrete classes are specified for {@code T}. If you want to specify an interface for
  * {@code T} then you need to also include the concrete class name in the serialized byte array so that you can
  * deserialize to the appropriate type.
@@ -38,4 +38,4 @@ public GsonConverter(Gson gson, Class<T> type) {
     gson.toJson(object, writer);
     writer.close();
   }
-}
\ No newline at end of file
+}
diff --git a/tape/pom.xml b/tape/pom.xml
index d306da4..df806d6 100644
--- a/tape/pom.xml
+++ b/tape/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>tape-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.4-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/tape/src/main/java/com/squareup/tape/FileObjectQueue.java b/tape/src/main/java/com/squareup/tape/FileObjectQueue.java
index 672ce84..2c70b48 100644
--- a/tape/src/main/java/com/squareup/tape/FileObjectQueue.java
+++ b/tape/src/main/java/com/squareup/tape/FileObjectQueue.java
@@ -6,6 +6,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import static java.util.Collections.unmodifiableList;
 
 /**
  * Base queue class, implements common functionality for a QueueFile-backed
@@ -60,6 +64,34 @@ public FileObjectQueue(File file, Converter<T> converter) throws IOException {
     }
   }
 
+  /**
+   * Reads up to {@code max} entries from the head of the queue without removing the entries.
+   * If the queue's {@link #size()} is less than {@code max} then only {@link #size()} entries
+   * are read.
+   */
+  public List<T> peek(final int max) {
+    try {
+      final List<T> entries = new ArrayList<T>(max);
+      queueFile.forEach(new QueueFile.ElementVisitor() {
+        int count;
+        @Override public boolean read(InputStream in, int length) throws IOException {
+          byte[] data = new byte[length];
+          in.read(data, 0, length);
+
+          entries.add(converter.from(data));
+          return ++count < max;
+        }
+      });
+      return unmodifiableList(entries);
+    } catch (IOException e) {
+      throw new FileException("Failed to peek.", e, file);
+    }
+  }
+
+  public List<T> asList() {
+    return peek(size());
+  }
+
   @Override public final void remove() {
     try {
       queueFile.remove();
@@ -69,16 +101,37 @@ public FileObjectQueue(File file, Converter<T> converter) throws IOException {
     }
   }
 
+  public final void remove(int n) throws IOException {
+    try {
+      queueFile.remove(n);
+      if (listener != null) {
+        for (int i = 0; i < n; i++) {
+          listener.onRemove(this);
+        }
+      }
+    } catch (IOException e) {
+      throw new FileException("Failed to remove.", e, file);
+    }
+  }
+
+  public final void close() {
+    try {
+      queueFile.close();
+    } catch (IOException e) {
+      throw new FileException("Failed to close.", e, file);
+    }
+  }
+
   @Override public void setListener(final Listener<T> listener) {
     if (listener != null) {
       try {
-        queueFile.forEach(new QueueFile.ElementReader() {
-          @Override
-          public void read(InputStream in, int length) throws IOException {
+        queueFile.forEach(new QueueFile.ElementVisitor() {
+          @Override public boolean read(InputStream in, int length) throws IOException {
             byte[] data = new byte[length];
             in.read(data, 0, length);
 
             listener.onAdd(FileObjectQueue.this, converter.from(data));
+            return true;
           }
         });
       } catch (IOException e) {
diff --git a/tape/src/main/java/com/squareup/tape/QueueFile.java b/tape/src/main/java/com/squareup/tape/QueueFile.java
index 1fe4252..d991b98 100644
--- a/tape/src/main/java/com/squareup/tape/QueueFile.java
+++ b/tape/src/main/java/com/squareup/tape/QueueFile.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.tape;
 
+import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -25,47 +26,46 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import static java.lang.Math.min;
+
 /**
- * A reliable, efficient, file-based, FIFO queue. Additions and removals are
- * O(1). All operations are atomic. Writes are synchronous; data will be written
- * to disk before an operation returns. The underlying file is structured to
- * survive process and even system crashes. If an I/O exception is thrown during
- * a mutating change, the change is aborted. It is safe to continue to use a
- * {@code QueueFile} instance after an exception.
- * <p/>
- * <p>All operations are synchronized. In a traditional queue, the remove
- * operation returns an element. In this queue, {@link #peek} and {@link
- * #remove} are used in conjunction. Use {@code peek} to retrieve the first
- * element, and then {@code remove} to remove it after successful processing. If
- * the system crashes after {@code peek} and during processing, the element will
- * remain in the queue, to be processed when the system restarts.
- * <p/>
- * <p><strong>NOTE:</strong> The current implementation is built
- * for file systems that support atomic segment writes (like YAFFS). Most
- * conventional file systems don't support this; if the power goes out while
- * writing a segment, the segment will contain garbage and the file will be
- * corrupt. We'll add journaling support so this class can be used with more
- * file systems later.
+ * A reliable, efficient, file-based, FIFO queue. Additions and removals are O(1). All operations
+ * are atomic. Writes are synchronous; data will be written to disk before an operation returns.
+ * The underlying file is structured to survive process and even system crashes. If an I/O
+ * exception is thrown during a mutating change, the change is aborted. It is safe to continue to
+ * use a {@code QueueFile} instance after an exception.
+ *
+ * <p>All operations are synchronized. In a traditional queue, the remove operation returns an
+ * element. In this queue, {@link #peek} and {@link #remove} are used in conjunction. Use
+ * {@code peek} to retrieve the first element, and then {@code remove} to remove it after
+ * successful processing. If the system crashes after {@code peek} and during processing, the
+ * element will remain in the queue, to be processed when the system restarts.
+ *
+ * <p><strong>NOTE:</strong> The current implementation is built for file systems that support
+ * atomic segment writes (like YAFFS). Most conventional file systems don't support this; if the
+ * power goes out while writing a segment, the segment will contain garbage and the file will be
+ * corrupt. We'll add journaling support so this class can be used with more file systems later.
  *
  * @author Bob Lee (bob@squareup.com)
  */
-public class QueueFile {
+public class QueueFile implements Closeable {
   private static final Logger LOGGER = Logger.getLogger(QueueFile.class.getName());
 
   /** Initial file size in bytes. */
   private static final int INITIAL_LENGTH = 4096; // one file system block
 
+  /** A block of nothing to write over old data. */
+  private static final byte[] ZEROES = new byte[INITIAL_LENGTH];
+
   /** Length of header in bytes. */
   static final int HEADER_LENGTH = 16;
 
   /**
-   * The underlying file. Uses a ring buffer to store entries. Designed so that
-   * a modification isn't committed or visible until we write the header. The
-   * header is much smaller than a segment. So long as the underlying file
-   * system supports atomic segment writes, changes to the queue are atomic.
-   * Storing the file length ensures we can recover from a failed expansion
-   * (i.e. if setting the file length succeeds but the process dies before the
-   * data can be copied).
+   * The underlying file. Uses a ring buffer to store entries. Designed so that a modification
+   * isn't committed or visible until we write the header. The header is much smaller than a
+   * segment. So long as the underlying file system supports atomic segment writes, changes to the
+   * queue are atomic. Storing the file length ensures we can recover from a failed expansion
+   * (i.e. if setting the file length succeeds but the process dies before the data can be copied).
    * <p/>
    * <pre>
    *   Format:
@@ -82,8 +82,10 @@
    *     Length (4 bytes)
    *     Data   (Length bytes)
    * </pre>
+   *
+   * Visible for testing.
    */
-  private final RandomAccessFile raf;
+  final RandomAccessFile raf;
 
   /** Cached file length. Always a power of 2. */
   int fileLength;
@@ -101,24 +103,25 @@
   private final byte[] buffer = new byte[16];
 
   /**
-   * Constructs a new queue backed by the given file. Only one {@code QueueFile}
-   * instance should access a given file at a time.
+   * Constructs a new queue backed by the given file. Only one instance should access a given file
+   * at a time.
    */
   public QueueFile(File file) throws IOException {
-    if (!file.exists()) initialize(file);
+    if (!file.exists()) {
+      initialize(file);
+    }
     raf = open(file);
     readHeader();
   }
 
-  /** For testing. */
   QueueFile(RandomAccessFile raf) throws IOException {
     this.raf = raf;
     readHeader();
   }
 
   /**
-   * Stores int in buffer. The behavior is equivalent to calling {@link
-   * java.io.RandomAccessFile#writeInt}.
+   * Stores an {@code int} in the {@code byte[]}. The behavior is equivalent to calling
+   * {@link RandomAccessFile#writeInt}.
    */
   private static void writeInt(byte[] buffer, int offset, int value) {
     buffer[offset] = (byte) (value >> 24);
@@ -127,19 +130,7 @@ private static void writeInt(byte[] buffer, int offset, int value) {
     buffer[offset + 3] = (byte) value;
   }
 
-  /**
-   * Stores int values in buffer. The behavior is equivalent to calling {@link
-   * java.io.RandomAccessFile#writeInt} for each value.
-   */
-  private static void writeInts(byte[] buffer, int... values) {
-    int offset = 0;
-    for (int value : values) {
-      writeInt(buffer, offset, value);
-      offset += 4;
-    }
-  }
-
-  /** Reads an int from a byte[]. */
+  /** Reads an {@code int} from the {@code byte[]}. */
   private static int readInt(byte[] buffer, int offset) {
     return ((buffer[offset] & 0xff) << 24)
         + ((buffer[offset + 1] & 0xff) << 16)
@@ -147,13 +138,15 @@ private static int readInt(byte[] buffer, int offset) {
         + (buffer[offset + 3] & 0xff);
   }
 
-  /** Reads the header. */
   private void readHeader() throws IOException {
     raf.seek(0);
     raf.readFully(buffer);
     fileLength = readInt(buffer, 0);
     if (fileLength > raf.length()) {
-      throw new IOException("File is truncated. Expected length: " + fileLength + ", Actual length: " + raf.length());
+      throw new IOException(
+          "File is truncated. Expected length: " + fileLength + ", Actual length: " + raf.length());
+    } else if (fileLength == 0) {
+      throw new IOException("File is corrupt; length stored in header is 0.");
     }
     elementCount = readInt(buffer, 4);
     int firstOffset = readInt(buffer, 8);
@@ -163,26 +156,28 @@ private void readHeader() throws IOException {
   }
 
   /**
-   * Writes header atomically. The arguments contain the updated values. The
-   * class member fields should not have changed yet. This only updates the
-   * state in the file. It's up to the caller to update the class member
-   * variables *after* this call succeeds. Assumes segment writes are atomic in
-   * the underlying file system.
+   * Writes header atomically. The arguments contain the updated values. The class member fields
+   * should not have changed yet. This only updates the state in the file. It's up to the caller to
+   * update the class member variables *after* this call succeeds. Assumes segment writes are
+   * atomic in the underlying file system.
    */
-  private void writeHeader(int fileLength, int elementCount, int firstPosition, int lastPosition) throws IOException {
-    writeInts(buffer, fileLength, elementCount, firstPosition, lastPosition);
+  private void writeHeader(int fileLength, int elementCount, int firstPosition, int lastPosition)
+      throws IOException {
+    writeInt(buffer, 0, fileLength);
+    writeInt(buffer, 4, elementCount);
+    writeInt(buffer, 8, firstPosition);
+    writeInt(buffer, 12, lastPosition);
     raf.seek(0);
     raf.write(buffer);
   }
 
-  /** Returns the Element for the given offset. */
   private Element readElement(int position) throws IOException {
     if (position == 0) return Element.NULL;
-    raf.seek(position);
-    return new Element(position, raf.readInt());
+    ringRead(position, buffer, 0, Element.HEADER_LENGTH);
+    int length = readInt(buffer, 0);
+    return new Element(position, length);
   }
 
-  /** Atomically initializes a new file. */
   private static void initialize(File file) throws IOException {
     // Use a temp file so we don't leave a partially-initialized file.
     File tempFile = new File(file.getPath() + ".tmp");
@@ -191,14 +186,16 @@ private static void initialize(File file) throws IOException {
       raf.setLength(INITIAL_LENGTH);
       raf.seek(0);
       byte[] headerBuffer = new byte[16];
-      writeInts(headerBuffer, INITIAL_LENGTH, 0, 0, 0);
+      writeInt(headerBuffer, 0, INITIAL_LENGTH);
       raf.write(headerBuffer);
     } finally {
       raf.close();
     }
 
     // A rename is atomic.
-    if (!tempFile.renameTo(file)) throw new IOException("Rename failed!");
+    if (!tempFile.renameTo(file)) {
+      throw new IOException("Rename failed!");
+    }
   }
 
   /** Opens a random access file that writes synchronously. */
@@ -213,12 +210,12 @@ private int wrapPosition(int position) {
   }
 
   /**
-   * Writes count bytes from buffer to position in file. Automatically wraps
-   * write if position is past the end of the file or if buffer overlaps it.
+   * Writes count bytes from buffer to position in file. Automatically wraps write if position is
+   * past the end of the file or if buffer overlaps it.
    *
    * @param position in file to write to
-   * @param buffer   to write from
-   * @param count    # of bytes to write
+   * @param buffer to write from
+   * @param count # of bytes to write
    */
   private void ringWrite(int position, byte[] buffer, int offset, int count) throws IOException {
     position = wrapPosition(position);
@@ -236,18 +233,27 @@ private void ringWrite(int position, byte[] buffer, int offset, int count) throw
     }
   }
 
+  private void ringErase(int position, int length) throws IOException {
+    while (length > 0) {
+      int chunk = min(length, ZEROES.length);
+      ringWrite(position, ZEROES, 0, chunk);
+      length -= chunk;
+      position += chunk;
+    }
+  }
+
   /**
    * Reads count bytes into buffer from file. Wraps if necessary.
    *
    * @param position in file to read from
-   * @param buffer   to read into
-   * @param count    # of bytes to read
+   * @param buffer to read into
+   * @param count # of bytes to read
    */
   private void ringRead(int position, byte[] buffer, int offset, int count) throws IOException {
     position = wrapPosition(position);
     if (position + count <= fileLength) {
       raf.seek(position);
-      raf.readFully(buffer, 0, count);
+      raf.readFully(buffer, offset, count);
     } else {
       // The read overlaps the EOF.
       // # of bytes to read before the EOF.
@@ -271,14 +277,16 @@ public void add(byte[] data) throws IOException {
   /**
    * Adds an element to the end of the queue.
    *
-   * @param data   to copy bytes from
+   * @param data to copy bytes from
    * @param offset to start from in buffer
-   * @param count  number of bytes to copy
-   * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code count < 0}, or if {@code offset + count} is
-   *                                   bigger than the length of {@code buffer}.
+   * @param count number of bytes to copy
+   * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code count < 0}, or if {@code
+   * offset + count} is bigger than the length of {@code buffer}.
    */
   public synchronized void add(byte[] data, int offset, int count) throws IOException {
-    nonNull(data, "buffer");
+    if (data == null) {
+      throw new NullPointerException("data == null");
+    }
     if ((offset | count) < 0 || count > data.length - offset) {
       throw new IndexOutOfBoundsException();
     }
@@ -287,7 +295,8 @@ public synchronized void add(byte[] data, int offset, int count) throws IOExcept
 
     // Insert a new element after the current last element.
     boolean wasEmpty = isEmpty();
-    int position = wasEmpty ? HEADER_LENGTH : wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
+    int position = wasEmpty ? HEADER_LENGTH
+        : wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
     Element newLast = new Element(position, count);
 
     // Write length.
@@ -305,7 +314,6 @@ public synchronized void add(byte[] data, int offset, int count) throws IOExcept
     if (wasEmpty) first = last; // first element
   }
 
-  /** Returns the number of used bytes. */
   private int usedBytes() {
     if (elementCount == 0) return HEADER_LENGTH;
 
@@ -322,7 +330,6 @@ private int usedBytes() {
     }
   }
 
-  /** Returns number of unused bytes. */
   private int remainingBytes() {
     return fileLength - usedBytes();
   }
@@ -333,8 +340,7 @@ public synchronized boolean isEmpty() {
   }
 
   /**
-   * If necessary, expands the file to accommodate an additional element of the
-   * given length.
+   * If necessary, expands the file to accommodate an additional element of the given length.
    *
    * @param dataLength length of data being added
    */
@@ -359,13 +365,14 @@ private void expandIfNecessary(int dataLength) throws IOException {
     int endOfLastElement = wrapPosition(last.position + Element.HEADER_LENGTH + last.length);
 
     // If the buffer is split, we need to make it contiguous
-    if (endOfLastElement < first.position) {
+    if (endOfLastElement <= first.position) {
       FileChannel channel = raf.getChannel();
       channel.position(fileLength); // destination position
-      int count = endOfLastElement - Element.HEADER_LENGTH;
+      int count = endOfLastElement - HEADER_LENGTH;
       if (channel.transferTo(HEADER_LENGTH, count, channel) != count) {
         throw new AssertionError("Copied insufficient number of bytes!");
       }
+      ringErase(HEADER_LENGTH, count);
     }
 
     // Commit the expansion.
@@ -396,37 +403,59 @@ private void setLength(int newLength) throws IOException {
     return data;
   }
 
-  /** Invokes reader with the eldest element, if an element is available. */
-  public synchronized void peek(ElementReader reader) throws IOException {
+  /**
+   * Invokes reader with the eldest element, if an element is available.
+   *
+   * @deprecated use {@link #peek(ElementVisitor)}
+   */
+  @Deprecated public synchronized void peek(ElementReader reader) throws IOException {
     if (elementCount > 0) {
       reader.read(new ElementInputStream(first), first.length);
     }
   }
 
+  /** Invokes {@code visitor} with the eldest element, if an element is available. */
+  public synchronized void peek(ElementVisitor visitor) throws IOException {
+    if (elementCount > 0) {
+      visitor.read(new ElementInputStream(first), first.length);
+    }
+  }
+
   /**
    * Invokes the given reader once for each element in the queue, from eldest to
    * most recently added.
+   *
+   * @deprecated use {@link #forEach(ElementVisitor)}
    */
-  public synchronized void forEach(ElementReader reader) throws IOException {
-    int position = first.position;
-    for (int i = 0; i < elementCount; i++) {
-      Element current = readElement(position);
-      reader.read(new ElementInputStream(current), current.length);
-      position = wrapPosition(current.position + Element.HEADER_LENGTH + current.length);
-    }
+  @Deprecated public synchronized void forEach(final ElementReader reader) throws IOException {
+    forEach(new ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        reader.read(in, length);
+        return true;
+      }
+    });
   }
 
   /**
-   * Returns t unless it's null.
+   * Invokes the given reader once for each element in the queue, from eldest to most recently
+   * added. Continues until all elements are read or {@link ElementVisitor#read reader.read()}
+   * returns {@code false}.
    *
-   * @throws NullPointerException if t is null
+   * @return number of elements visited
    */
-  private static <T> T nonNull(T t, String name) {
-    if (t == null) throw new NullPointerException(name);
-    return t;
+  public synchronized int forEach(ElementVisitor reader) throws IOException {
+    int position = first.position;
+    for (int i = 0; i < elementCount; i++) {
+      Element current = readElement(position);
+      boolean shouldContinue = reader.read(new ElementInputStream(current), current.length);
+      if (!shouldContinue) {
+        return i + 1;
+      }
+      position = wrapPosition(current.position + Element.HEADER_LENGTH + current.length);
+    }
+    return elementCount;
   }
 
-  /** Reads a single element. */
   private final class ElementInputStream extends InputStream {
     private int position;
     private int remaining;
@@ -437,10 +466,12 @@ private ElementInputStream(Element element) {
     }
 
     @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      nonNull(buffer, "buffer");
       if ((offset | length) < 0 || length > buffer.length - offset) {
         throw new ArrayIndexOutOfBoundsException();
       }
+      if (remaining == 0) {
+        return -1;
+      }
       if (length > remaining) length = remaining;
       ringRead(position, buffer, offset, length);
       position = wrapPosition(position + length);
@@ -466,26 +497,59 @@ public synchronized int size() {
   /**
    * Removes the eldest element.
    *
-   * @throws java.util.NoSuchElementException if the queue is empty
+   * @throws NoSuchElementException if the queue is empty
    */
   public synchronized void remove() throws IOException {
+    remove(1);
+  }
+
+  /**
+   * Removes the eldest {@code n} elements.
+   *
+   * @throws NoSuchElementException if the queue is empty
+   */
+  public synchronized void remove(int n) throws IOException {
     if (isEmpty()) throw new NoSuchElementException();
-    if (elementCount == 1) {
+    if (n > elementCount) {
+      throw new IllegalArgumentException(
+          "Cannot remove more elements (" + n + ") than present in queue (" + elementCount + ").");
+    }
+    if (n == elementCount) {
       clear();
-    } else {
-      // assert elementCount > 1
-      int newFirstPosition = wrapPosition(first.position + Element.HEADER_LENGTH + first.length);
+      return;
+    }
+
+    final int eraseStartPosition = first.position;
+    int eraseTotalLength = 0;
+
+    // Read the position and length of the new first element.
+    int newFirstPosition = first.position;
+    int newFirstLength = first.length;
+    for (int i = 0; i < n; i++) {
+      eraseTotalLength += Element.HEADER_LENGTH + newFirstLength;
+      newFirstPosition = wrapPosition(newFirstPosition + Element.HEADER_LENGTH + newFirstLength);
       ringRead(newFirstPosition, buffer, 0, Element.HEADER_LENGTH);
-      int length = readInt(buffer, 0);
-      writeHeader(fileLength, elementCount - 1, newFirstPosition, last.position);
-      elementCount--;
-      first = new Element(newFirstPosition, length);
+      newFirstLength = readInt(buffer, 0);
     }
+
+    // Commit the header.
+    writeHeader(fileLength, elementCount - n, newFirstPosition, last.position);
+    elementCount -= n;
+    first = new Element(newFirstPosition, newFirstLength);
+
+    // Commit the erase.
+    ringErase(eraseStartPosition, eraseTotalLength);
   }
 
   /** Clears this queue. Truncates the file to the initial size. */
   public synchronized void clear() throws IOException {
+    // Commit the header.
     writeHeader(INITIAL_LENGTH, 0, 0, 0);
+
+    // Zero out data.
+    raf.seek(HEADER_LENGTH);
+    raf.write(ZEROES, 0, INITIAL_LENGTH - HEADER_LENGTH);
+
     elementCount = 0;
     first = Element.NULL;
     last = Element.NULL;
@@ -494,7 +558,7 @@ public synchronized void clear() throws IOException {
   }
 
   /** Closes the underlying file. */
-  public synchronized void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
     raf.close();
   }
 
@@ -528,13 +592,11 @@ public synchronized void close() throws IOException {
 
   /** A pointer to an element. */
   static class Element {
+    static final Element NULL = new Element(0, 0);
 
     /** Length of element header in bytes. */
     static final int HEADER_LENGTH = 4;
 
-    /** Null element. */
-    static final Element NULL = new Element(0, 0);
-
     /** Position in file. */
     final int position;
 
@@ -545,7 +607,7 @@ public synchronized void close() throws IOException {
      * Constructs a new element.
      *
      * @param position within file
-     * @param length   of data
+     * @param length of data
      */
     Element(int position, int length) {
       this.position = position;
@@ -560,10 +622,12 @@ public synchronized void close() throws IOException {
   }
 
   /**
-   * Reads queue elements. Enables partial reads as opposed to reading all of
-   * the bytes into a byte[].
+   * Reads queue elements. Enables partial reads as opposed to reading all of the bytes into a
+   * {@code byte[]}.
+   *
+   * @deprecated use {@link ElementVisitor} instead.
    */
-  public interface ElementReader {
+  @Deprecated public interface ElementReader {
 
     /*
      * TODO: Support remove() call from read().
@@ -572,11 +636,29 @@ public synchronized void close() throws IOException {
     /**
      * Called once per element.
      *
-     * @param in     stream of element data. Reads as many bytes as requested,
-     *               unless fewer than the request number of bytes remains, in
-     *               which case it reads all the remaining bytes. Not buffered.
+     * @param in stream of element data. Reads as many bytes as requested, unless fewer than the
+     * request number of bytes remains, in which case it reads all the remaining bytes. Not
+     * buffered.
      * @param length of element data in bytes
      */
     void read(InputStream in, int length) throws IOException;
   }
+
+  /**
+   * Reads queue elements. Enables partial reads as opposed to reading all of
+   * the bytes into a byte[].  Can opt to skip remaining elements.
+   */
+  public interface ElementVisitor {
+    /**
+     * Called once per element.
+     *
+     * @param in stream of element data. Reads as many bytes as requested, unless fewer than the
+     * request number of bytes remains, in which case it reads all the remaining bytes. Not
+     * buffered.
+     * @param length of element data in bytes
+     * @return an indication whether the {@link #forEach} operation should continue; If
+     * {@code true}, continue, otherwise halt.
+     */
+    boolean read(InputStream in, int length) throws IOException;
+  }
 }
diff --git a/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java b/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java
new file mode 100644
index 0000000..980b1a0
--- /dev/null
+++ b/tape/src/test/java/com/squareup/tape/FileObjectQueueTest.java
@@ -0,0 +1,46 @@
+// Copyright 2014 Square, Inc.
+package com.squareup.tape;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public class FileObjectQueueTest {
+  @Rule public TemporaryFolder folder = new TemporaryFolder();
+  private FileObjectQueue<String> queue;
+
+  @Before public void setUp() throws IOException {
+    File parent = folder.getRoot();
+    File file = new File(parent, "queue-file");
+    queue = new FileObjectQueue<String>(file, new SerializedConverter<String>());
+    queue.add("one");
+    queue.add("two");
+    queue.add("three");
+  }
+
+  @Test public void peekMultiple() {
+    List<String> peek = queue.peek(3);
+    assertThat(peek).containsExactly("one", "two", "three");
+  }
+
+  @Test public void getsAllAsList() {
+    List<String> peek = queue.asList();
+    assertThat(peek).containsExactly("one", "two", "three");
+  }
+
+  @Test public void peekMaxCanExceedQueueDepth() {
+    List<String> peek = queue.peek(6);
+    assertThat(peek).hasSize(3);
+  }
+
+  @Test public void peekMaxCanBeSmallerThanQueueDepth() {
+    List<String> peek = queue.peek(2);
+    assertThat(peek).containsExactly("one", "two");
+  }
+}
diff --git a/tape/src/test/java/com/squareup/tape/QueueFileTest.java b/tape/src/test/java/com/squareup/tape/QueueFileTest.java
index 3a811b7..7b47655 100644
--- a/tape/src/test/java/com/squareup/tape/QueueFileTest.java
+++ b/tape/src/test/java/com/squareup/tape/QueueFileTest.java
@@ -1,11 +1,8 @@
 // Copyright 2010 Square, Inc.
 package com.squareup.tape;
 
-import org.fest.assertions.Assertions;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
+import com.squareup.tape.QueueFile.Element;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -15,7 +12,13 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
+import org.fest.assertions.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
+import static com.squareup.tape.QueueFile.HEADER_LENGTH;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.fest.assertions.Fail.fail;
 
@@ -24,14 +27,12 @@
  *
  * @author Bob Lee (bob@squareup.com)
  */
-@SuppressWarnings({"ResultOfMethodCallIgnored"})
-public class QueueFileTest {
-  private static final Logger logger =
-      Logger.getLogger(QueueFileTest.class.getName());
+@SuppressWarnings({ "ResultOfMethodCallIgnored" }) public class QueueFileTest {
+  private static final Logger logger = Logger.getLogger(QueueFileTest.class.getName());
 
   /**
-   * Takes up 33401 bytes in the queue (N*(N+1)/2+4*N). Picked 254 instead of
-   * 255 so that the number of bytes isn't a multiple of 4.
+   * Takes up 33401 bytes in the queue (N*(N+1)/2+4*N). Picked 254 instead of 255 so that the number
+   * of bytes isn't a multiple of 4.
    */
   private static int N = 254;
   private static byte[][] values = new byte[N][];
@@ -40,20 +41,18 @@
     for (int i = 0; i < N; i++) {
       byte[] value = new byte[i];
       // Example: values[3] = { 3, 2, 1 }
-      for (int ii = 0; ii < i; ii++) value[ii] = (byte) (i - ii);
+      for (int ii = 0; ii < i; ii++)
+        value[ii] = (byte) (i - ii);
       values[i] = value;
     }
   }
 
+  @Rule public TemporaryFolder folder = new TemporaryFolder();
   private File file;
 
   @Before public void setUp() throws Exception {
-    file = File.createTempFile("test.queue", null);
-    file.delete();
-  }
-
-  @After public void tearDown() throws Exception {
-    file.delete();
+    File parent = folder.getRoot();
+    file = new File(parent, "queue-file");
   }
 
   @Test public void testAddOneElement() throws IOException {
@@ -67,6 +66,140 @@
     assertThat(queue.peek()).isEqualTo(expected);
   }
 
+  @Test public void testClearErases() throws IOException {
+    QueueFile queue = new QueueFile(file);
+    byte[] expected = values[253];
+    queue.add(expected);
+
+    // Confirm that the data was in the file before we cleared.
+    byte[] data = new byte[expected.length];
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, expected.length);
+    assertThat(data).isEqualTo(expected);
+
+    queue.clear();
+
+    // Should have been erased.
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, expected.length);
+    assertThat(data).isEqualTo(new byte[expected.length]);
+  }
+
+  @Test public void testClearDoesNotCorrupt() throws IOException {
+    QueueFile queue = new QueueFile(file);
+    byte[] stuff = values[253];
+    queue.add(stuff);
+    queue.clear();
+
+    queue = new QueueFile(file);
+    assertThat(queue.isEmpty()).isTrue();
+    assertThat(queue.peek()).isNull();
+
+    queue.add(values[25]);
+    assertThat(queue.peek()).isEqualTo(values[25]);
+  }
+
+  @Test public void removeErasesEagerly() throws IOException {
+    QueueFile queue = new QueueFile(file);
+
+    byte[] firstStuff = values[127];
+    queue.add(firstStuff);
+
+    byte[] secondStuff = values[253];
+    queue.add(secondStuff);
+
+    // Confirm that first stuff was in the file before we remove.
+    byte[] data = new byte[firstStuff.length];
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, firstStuff.length);
+    assertThat(data).isEqualTo(firstStuff);
+
+    queue.remove();
+
+    // Next record is intact
+    assertThat(queue.peek()).isEqualTo(secondStuff);
+
+    // First should have been erased.
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, firstStuff.length);
+    assertThat(data).isEqualTo(new byte[firstStuff.length]);
+  }
+
+  @Test public void testZeroSizeInHeaderComplains() throws IOException {
+    RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd");
+    emptyFile.setLength(4096);
+    emptyFile.getChannel().force(true);
+    emptyFile.close();
+
+    try {
+      new QueueFile(file);
+      fail("Should have complained about bad header length");
+    } catch (IOException ex) {
+      assertThat(ex).hasMessage("File is corrupt; length stored in header is 0.");
+    }
+  }
+
+  @Test public void removeMultipleDoesNotCorrupt() throws IOException {
+    QueueFile queue = new QueueFile(file);
+    for (int i = 0; i < 10; i ++) {
+      queue.add(values[i]);
+    }
+
+    queue.remove(1);
+    assertThat(queue.size()).isEqualTo(9);
+    assertThat(queue.peek()).isEqualTo(values[1]);
+
+    queue.remove(3);
+    queue = new QueueFile(file);
+    assertThat(queue.size()).isEqualTo(6);
+    assertThat(queue.peek()).isEqualTo(values[4]);
+
+    queue.remove(6);
+    assertThat(queue.isEmpty()).isTrue();
+    assertThat(queue.peek()).isNull();
+  }
+
+  @Test public void removeDoesNotCorrupt() throws IOException {
+    QueueFile queue = new QueueFile(file);
+
+    queue.add(values[127]);
+    byte[] secondStuff = values[253];
+    queue.add(secondStuff);
+    queue.remove();
+
+    queue = new QueueFile(file);
+    assertThat(queue.peek()).isEqualTo(secondStuff);
+  }
+
+  @Test public void removingBigDamnBlocksErasesEffectively() throws IOException {
+    byte[] bigBoy = new byte[7000];
+    for (int i = 0; i < 7000; i += 100) {
+      System.arraycopy(values[100], 0, bigBoy, i, values[100].length);
+    }
+
+    QueueFile queue = new QueueFile(file);
+
+    queue.add(bigBoy);
+    byte[] secondStuff = values[123];
+    queue.add(secondStuff);
+
+    // Confirm that bigBoy was in the file before we remove.
+    byte[] data = new byte[bigBoy.length];
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, bigBoy.length);
+    assertThat(data).isEqualTo(bigBoy);
+
+    queue.remove();
+
+    // Next record is intact
+    assertThat(queue.peek()).isEqualTo(secondStuff);
+
+    // First should have been erased.
+    queue.raf.seek(HEADER_LENGTH + Element.HEADER_LENGTH);
+    queue.raf.readFully(data, 0, bigBoy.length);
+    assertThat(data).isEqualTo(new byte[bigBoy.length]);
+  }
+
   @Test public void testAddAndRemoveElements() throws IOException {
     long start = System.nanoTime();
 
@@ -215,7 +348,8 @@
     assertThat(queueFile.peek()).isEqualTo(values[99]);
   }
 
-  @Test public void testPeekWithElementReader() throws IOException {
+  @SuppressWarnings("deprecation") @Test
+  public void testPeekWithElementReader() throws IOException {
     QueueFile queueFile = new QueueFile(file);
     final byte[] a = {1, 2};
     queueFile.add(a);
@@ -264,7 +398,59 @@
     assertThat(queueFile.size()).isEqualTo(1);
   }
 
-  @Test public void testForEach() throws IOException {
+  @Test public void testPeekWithElementVisitor() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+    final byte[] a = { 1, 2 };
+    queueFile.add(a);
+    final byte[] b = { 3, 4, 5 };
+    queueFile.add(b);
+
+    final AtomicInteger peeks = new AtomicInteger(0);
+
+    queueFile.peek(new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        peeks.incrementAndGet();
+
+        assertThat(length).isEqualTo(2);
+        byte[] actual = new byte[length];
+        in.read(actual);
+        assertThat(actual).isEqualTo(a);
+        return true;
+      }
+    });
+
+    queueFile.peek(new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        peeks.incrementAndGet();
+
+        assertThat(length).isEqualTo(2);
+        assertThat(in.read()).isEqualTo(1);
+        assertThat(in.read()).isEqualTo(2);
+        assertThat(in.read()).isEqualTo(-1);
+        return true;
+      }
+    });
+
+    queueFile.remove();
+
+    queueFile.peek(new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        peeks.incrementAndGet();
+
+        assertThat(length).isEqualTo(3);
+        byte[] actual = new byte[length];
+        in.read(actual);
+        assertThat(actual).isEqualTo(b);
+        return true;
+      }
+    });
+
+    assertThat(peeks.get()).isEqualTo(3);
+    assertThat(queueFile.peek()).isEqualTo(b);
+    assertThat(queueFile.size()).isEqualTo(1);
+  }
+
+  @SuppressWarnings("deprecation") @Test public void testForEach() throws IOException {
     QueueFile queueFile = new QueueFile(file);
 
     final byte[] a = {1, 2};
@@ -298,6 +484,183 @@
     assertThat(iteration[0]).isEqualTo(2);
   }
 
+  @SuppressWarnings("deprecation") @Test
+  public void testForEachReadWithOffset() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+
+    queueFile.add(new byte[] { 1, 2 });
+    queueFile.add(new byte[] { 3, 4, 5 });
+
+    final byte[] actual = new byte[5];
+    final int[] offset = new int[] { 0 };
+
+    QueueFile.ElementReader elementReader = new QueueFile.ElementReader() {
+      @Override public void read(InputStream in, int length) throws IOException {
+        in.read(actual, offset[0], length);
+        offset[0] += length;
+      }
+    };
+
+    queueFile.forEach(elementReader);
+
+    assertThat(actual).isEqualTo(new byte[] { 1, 2, 3, 4, 5 });
+  }
+
+  @SuppressWarnings("deprecation") @Test public void testForEachStreamCopy() throws IOException {
+    final QueueFile queueFile = new QueueFile(file);
+    queueFile.add(new byte[] {1, 2});
+    queueFile.add(new byte[] {3, 4, 5});
+
+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    final byte[] buffer = new byte[8];
+
+    final QueueFile.ElementReader elementReader = new QueueFile.ElementReader() {
+      @Override public void read(InputStream in, int length) throws IOException {
+        // A common idiom for copying data between two streams, but it depends on the
+        // InputStream correctly returning -1 when no more data is available
+        int count;
+        while ((count = in.read(buffer)) != -1) {
+          if (count == 0) {
+            // In the past, the ElementInputStream.read(byte[], int, int) method would return 0
+            // when no more bytes were available for reading. This test detects that error.
+            //
+            // Note: 0 is a valid return value for InputStream.read(byte[], int, int), which happens
+            // when the passed length is zero. We could trigger that through InputStream.read(byte[])
+            // by passing a zero-length buffer. However, since we won't do that during this test,
+            // we can safely assume that a return value of 0 indicates the past error in logic.
+            fail("This test should never receive a result of 0 from InputStream.read(byte[])");
+          }
+          baos.write(buffer, 0, count);
+        }
+      }
+    };
+
+    queueFile.forEach(elementReader);
+    assertThat(baos.toByteArray()).isEqualTo(new byte[] {1, 2, 3, 4, 5});
+  }
+
+  @Test public void testForEachVisitor() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+
+    final byte[] a = { 1, 2 };
+    queueFile.add(a);
+    final byte[] b = { 3, 4, 5 };
+    queueFile.add(b);
+
+    final int[] iteration = new int[] { 0 };
+    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        if (iteration[0] == 0) {
+          assertThat(length).isEqualTo(2);
+          byte[] actual = new byte[length];
+          in.read(actual);
+          assertThat(actual).isEqualTo(a);
+        } else if (iteration[0] == 1) {
+          assertThat(length).isEqualTo(3);
+          byte[] actual = new byte[length];
+          in.read(actual);
+          assertThat(actual).isEqualTo(b);
+        } else {
+          fail();
+        }
+        iteration[0]++;
+        return true;
+      }
+    };
+
+    int saw = queueFile.forEach(elementVisitor);
+    assertThat(saw).isEqualTo(2);
+    assertThat(queueFile.peek()).isEqualTo(a);
+    assertThat(iteration[0]).isEqualTo(2);
+  }
+
+  @Test public void testForEachVisitorReadWithOffset() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+
+    queueFile.add(new byte[] { 1, 2 });
+    queueFile.add(new byte[] { 3, 4, 5 });
+
+    final byte[] actual = new byte[5];
+    final int[] offset = new int[] { 0 };
+
+    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        in.read(actual, offset[0], length);
+        offset[0] += length;
+        return true;
+      }
+    };
+
+    int saw = queueFile.forEach(elementVisitor);
+    assertThat(saw).isEqualTo(2);
+    assertThat(actual).isEqualTo(new byte[] { 1, 2, 3, 4, 5 });
+  }
+
+  @Test public void testForEachVisitorStreamCopy() throws IOException {
+    final QueueFile queueFile = new QueueFile(file);
+    queueFile.add(new byte[] {1, 2});
+    queueFile.add(new byte[] {3, 4, 5});
+
+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    final byte[] buffer = new byte[8];
+
+    final QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        // A common idiom for copying data between two streams, but it depends on the
+        // InputStream correctly returning -1 when no more data is available
+        int count;
+        while ((count = in.read(buffer)) != -1) {
+          if (count == 0) {
+            // In the past, the ElementInputStream.read(byte[], int, int) method would return 0
+            // when no more bytes were available for reading. This test detects that error.
+            //
+            // Note: 0 is a valid return value for InputStream.read(byte[], int, int), which happens
+            // when the passed length is zero. We could trigger that through InputStream.read(byte[])
+            // by passing a zero-length buffer. However, since we won't do that during this test,
+            // we can safely assume that a return value of 0 indicates the past error in logic.
+            fail("This test should never receive a result of 0 from InputStream.read(byte[])");
+          }
+          baos.write(buffer, 0, count);
+        }
+        return true;
+      }
+    };
+
+    int saw = queueFile.forEach(elementVisitor);
+    assertThat(saw).isEqualTo(2);
+    assertThat(baos.toByteArray()).isEqualTo(new byte[] {1, 2, 3, 4, 5});
+  }
+
+  @Test public void testForEachCanAbortEarly() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+
+    final byte[] a = {1, 2};
+    queueFile.add(a);
+    final byte[] b = {3, 4, 5};
+    queueFile.add(b);
+
+    final AtomicInteger iteration = new AtomicInteger();
+    QueueFile.ElementVisitor elementVisitor = new QueueFile.ElementVisitor() {
+      @Override public boolean read(InputStream in, int length) throws IOException {
+        if (iteration.get() == 0) {
+          assertThat(length).isEqualTo(2);
+          byte[] actual = new byte[length];
+          in.read(actual);
+          assertThat(actual).isEqualTo(a);
+        } else {
+          fail();
+        }
+        iteration.incrementAndGet();
+        return false;
+      }
+    };
+
+    int saw = queueFile.forEach(elementVisitor);
+    assertThat(saw).isEqualTo(1);
+    assertThat(queueFile.peek()).isEqualTo(a);
+    assertThat(iteration.get()).isEqualTo(1);
+  }
+
   /**
    * Exercise a bug where wrapped elements were getting corrupted when the
    * QueueFile was forced to expand in size and a portion of the final Element
@@ -413,6 +776,126 @@
     queue.close();
   }
 
+  /**
+   * Exercise a bug where file expansion would leave garbage at the start of the header
+   * and after the last element.
+   */
+  @Test public void testFileExpansionCorrectlyZeroesData()
+      throws IOException {
+    QueueFile queue = new QueueFile(file);
+
+    // Create test data - 1k blocks marked consecutively 1, 2, 3, 4 and 5.
+    byte[][] values = new byte[5][];
+    for (int blockNum = 0; blockNum < values.length; blockNum++) {
+      values[blockNum] = new byte[1024];
+      for (int i = 0; i < values[blockNum].length; i++) {
+        values[blockNum][i] = (byte) (blockNum + 1);
+      }
+    }
+
+    // First, add the first two blocks to the queue, remove one leaving a
+    // 1K space at the beginning of the buffer.
+    queue.add(values[0]);
+    queue.add(values[1]);
+    queue.remove();
+
+    // The trailing end of block "4" will be wrapped to the start of the buffer.
+    queue.add(values[2]);
+    queue.add(values[3]);
+
+    // Cause buffer to expand as there isn't space between the end of block "4"
+    // and the start of block "2". Internally the queue will cause block "4"
+    // to be contiguous. There was a bug where the start of the buffer still
+    // contained the tail end of block "4", and garbage was copied after the tail
+    // end of the last element.
+    queue.add(values[4]);
+
+    // Read from header to first element and make sure it's zeroed.
+    int firstElementPadding = 1028;
+    byte[] data = new byte[firstElementPadding];
+    queue.raf.seek(HEADER_LENGTH);
+    queue.raf.readFully(data, 0, firstElementPadding);
+    assertThat(data).containsOnly((byte) 0x00);
+
+    // Read from the last element to the end and make sure it's zeroed.
+    int endOfLastElement = HEADER_LENGTH + firstElementPadding + 4 * (Element.HEADER_LENGTH + 1024);
+    int readLength = (int) (queue.raf.length() - endOfLastElement);
+    data = new byte[readLength];
+    queue.raf.seek(endOfLastElement);
+    queue.raf.readFully(data, 0, readLength);
+    assertThat(data).containsOnly((byte) 0x00);
+  }
+
+  /**
+   * Exercise a bug where an expanding queue file where the start and end positions
+   * are the same causes corruption.
+   */
+  @Test public void testSaturatedFileExpansionMovesElements() throws IOException {
+    QueueFile queue = new QueueFile(file);
+
+    // Create test data - 1016-byte blocks marked consecutively 1, 2, 3, 4, 5 and 6,
+    // four of which perfectly fill the queue file, taking into account the file header
+    // and the item headers.
+    // Each item is of length
+    // (QueueFile.INITIAL_LENGTH - QueueFile.HEADER_LENGTH) / 4 - element_header_length
+    // = 1016 bytes
+    byte[][] values = new byte[6][];
+    for (int blockNum = 0; blockNum < values.length; blockNum++) {
+      values[blockNum] = new byte[1016];
+      for (int i = 0; i < values[blockNum].length; i++) {
+        values[blockNum][i] = (byte) (blockNum + 1);
+      }
+    }
+
+    // Saturate the queue file
+    queue.add(values[0]);
+    queue.add(values[1]);
+    queue.add(values[2]);
+    queue.add(values[3]);
+
+    // Remove an element and add a new one so that the position of the start and
+    // end of the queue are equal
+    queue.remove();
+    queue.add(values[4]);
+
+    // Cause the queue file to expand
+    queue.add(values[5]);
+
+    // Make sure values are not corrupted
+    for (int i = 1; i < 6; i++) {
+      assertThat(queue.peek()).isEqualTo(values[i]);
+      queue.remove();
+    }
+
+    queue.close();
+  }
+
+  /**
+   * Exercise a bug where opening a queue whose first or last element's header
+   * was non contiguous throws an {@link java.io.EOFException}.
+   */
+  @Test public void testReadHeadersFromNonContiguousQueueWorks() throws IOException {
+    QueueFile queueFile = new QueueFile(file);
+
+    // Fill the queue up to `length - 2` (i.e. remainingBytes() == 2).
+    for (int i = 0; i < 15; i++) {
+      queueFile.add(values[N - 1]);
+    }
+    queueFile.add(values[219]);
+
+    // Remove first item so we have room to add another one without growing the file.
+    queueFile.remove();
+
+    // Add any element element and close the queue.
+    queueFile.add(values[6]);
+    int queueSize = queueFile.size();
+    queueFile.close();
+
+    // File should not be corrupted.
+    QueueFile queueFile2 = new QueueFile(file);
+    assertThat(queueFile2.size()).isEqualTo(queueSize);
+  }
+
   /**
    * A RandomAccessFile that can break when you go to write the COMMITTED
    * status.
diff --git a/website/index.html b/website/index.html
index ed8bf6c..a0a2c84 100644
--- a/website/index.html
+++ b/website/index.html
@@ -11,6 +11,7 @@
     <link href="prettify.css" rel="stylesheet">
     <link href="app.css" rel="stylesheet">
     <script src="http://code.jquery.com/jquery-latest.js"></script>
+    <script src="jquery-maven-artifact.min.js"></script>
   </head>
   <body>
     <div class="container content">
@@ -30,7 +31,7 @@ <h2 id="about">About</h2>
         <div class="span5 offset1">
           <h2 id="download">Download</h2>
           <p>Available via Maven or as a downloadable <code>.jar</code>.</p>
-          <p><a href="http://github.com/square/tape/downloads" class="btn btn-inverse btn-large" id="download-btn">Download</a></p>
+          <p><a href="https://search.maven.org/remote_content?g=com.squareup&a=tape&v=LATEST" class="btn btn-inverse btn-large" id="download-btn">Download Latest</a></p>
           <p><a href="http://github.com/square/tape" id="ribbon">Fork Tape on GitHub</a></p>
           <pre class="maven">&lt;dependency>
     &lt;groupId>com.squareup&lt;/groupId>
@@ -53,11 +54,11 @@ <h3 id="example-image-queue">Android Task Queue Service</h3>
     this.context = context;
   }
 
-  @Override public void onAdd(ObjectQueue&lt;ImageUploadTask>, ImageUploadTask task) {
+  @Override public void onAdd(ObjectQueue&lt;ImageUploadTask> queue, ImageUploadTask task) {
     context.startService(new Intent(context, ImageQueueService.class));
   }
 
-  @Override public void onRemove(ObjectQueue&lt;ImageUploadTask>) {}
+  @Override public void onRemove(ObjectQueue&lt;ImageUploadTask> queue) {}
 }
 
 /** Service which iterates through pending upload tasks one-by-one. */
@@ -140,20 +141,11 @@ <h2 id="license">License</h2>
     <script src="prettify.js"></script>
     <script> prettyPrint(); </script>
     <script>
-      $.getJSON('https://api.github.com/repos/square/tape/tags?callback=?', function(response) {
-          var meta = response.meta
-            , data = response.data
-            ;
-
-          data.sort(function(o1, o2) {
-              return (o1.name > o2.name) ? -1 : 1;
-          });
-
-          // Replace in Maven <dependency>
-          $('#mvn-version').text(data[0].name);
-          // Replace in download button
-          $('#download-btn').text('Download v' + data[0].name);
-      });
+        // Look up the latest version of the library.
+        $.fn.artifactVersion('com.squareup', 'tape', function(version, url) {
+          $('#mvn-version').text(version);
+          $('#download-btn').text('Download v' + version).attr('href', url);
+        });
     </script>
   </body>
 </html>
diff --git a/website/jquery-maven-artifact.min.js b/website/jquery-maven-artifact.min.js
new file mode 100644
index 0000000..08a0304
--- /dev/null
+++ b/website/jquery-maven-artifact.min.js
@@ -0,0 +1,8 @@
+/**
+ * jQuery Maven Artifact Plugin
+ *
+ * Version: 1.0.1
+ * Author: Jake Wharton
+ * License: Apache 2.0
+ */
+(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"http://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
\ No newline at end of file
