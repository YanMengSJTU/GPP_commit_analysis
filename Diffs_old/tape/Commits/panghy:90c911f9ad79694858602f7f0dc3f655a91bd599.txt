diff --git a/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java b/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
index c77561e..8247445 100644
--- a/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
+++ b/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
@@ -215,7 +215,7 @@ protected abstract void writeHeader(RandomAccessFile raf, long fileLength, long
   /**
    * Returns the number of used bytes.
    */
-  private long usedBytes() {
+  long usedBytes() {
     if (elementCount == 0) return headerLength;
 
     if (last.position >= first.position) {
diff --git a/tape/src/test/java/com/squareup/tape/BigQueueFileImplTest.java b/tape/src/test/java/com/squareup/tape/BigQueueFileImplTest.java
index d5fc07a..9b63d20 100644
--- a/tape/src/test/java/com/squareup/tape/BigQueueFileImplTest.java
+++ b/tape/src/test/java/com/squareup/tape/BigQueueFileImplTest.java
@@ -7,6 +7,7 @@
 import java.io.RandomAccessFile;
 
 import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 
 /**
  * Tests for BigQueueFileImpl.
@@ -31,6 +32,38 @@ protected int getHeaderLength() throws IOException {
     return BigQueueFileImpl.HEADER_LENGTH;
   }
 
+  /**
+   * This is unfortunately going to be a pretty slow test.
+   *
+   * @throws IOException
+   */
+  @Test
+  public void testLargerThan2G() throws IOException {
+    BigQueueFileImpl impl = new BigQueueFileImpl(file);
+    byte[] expected = new byte[1048576]; // 1M
+    long added = 0;
+    for (long i = 0; i < Integer.MAX_VALUE; i += 1048576) {
+      impl.add(expected);
+      added++;
+    }
+    // exceed the 2G boundary.
+    impl.add(expected);
+    impl.add(expected);
+    added += 2;
+    assertTrue(impl.usedBytes() > Integer.MAX_VALUE);
+    assertTrue(file.length() > Integer.MAX_VALUE);
+
+    impl = new BigQueueFileImpl(file);
+    // now drain the queue.
+    long removed = 0;
+    while (!impl.isEmpty()) {
+      assertThat(impl.peek()).isEqualTo(expected);
+      impl.remove();
+      removed++;
+    }
+    assertTrue(removed == added);
+  }
+
   /**
    * Exercise a bug where an expanding queue file where the start and end positions
    * are the same causes corruption.
