diff --git a/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java b/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
index 8247445..7a99a4d 100644
--- a/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
+++ b/tape/src/main/java/com/squareup/tape/AbstractQueueFile.java
@@ -212,6 +212,8 @@ private RandomAccessFile initialize(File file) throws IOException {
   protected abstract void writeHeader(RandomAccessFile raf, long fileLength, long elementCount, long firstPosition,
                                       long lastPosition) throws IOException;
 
+  protected abstract long getMaxFileSize();
+
   /**
    * Returns the number of used bytes.
    */
@@ -337,7 +339,10 @@ private void expandIfNecessary(long dataLength) throws IOException {
     // Double the length until we can fit the new data.
     do {
       remainingBytes += previousLength;
-      newLength = previousLength << 1;
+      newLength = Math.min(getMaxFileSize(), previousLength << 1);
+      if (newLength == previousLength) {
+        throw new IOException("cannot expand file anymore");
+      }
       previousLength = newLength;
     } while (remainingBytes < elementLength);
 
diff --git a/tape/src/main/java/com/squareup/tape/BigQueueFileImpl.java b/tape/src/main/java/com/squareup/tape/BigQueueFileImpl.java
index 84d0c7e..60acf9f 100644
--- a/tape/src/main/java/com/squareup/tape/BigQueueFileImpl.java
+++ b/tape/src/main/java/com/squareup/tape/BigQueueFileImpl.java
@@ -87,4 +87,9 @@ protected void writeHeader(RandomAccessFile raf, long fileLength, long elementCo
     raf.seek(0);
     raf.write(buffer);
   }
+
+  @Override
+  protected long getMaxFileSize() {
+    return Long.MAX_VALUE;
+  }
 }
diff --git a/tape/src/main/java/com/squareup/tape/QueueFileImpl.java b/tape/src/main/java/com/squareup/tape/QueueFileImpl.java
index 4527d38..9d5881b 100644
--- a/tape/src/main/java/com/squareup/tape/QueueFileImpl.java
+++ b/tape/src/main/java/com/squareup/tape/QueueFileImpl.java
@@ -115,4 +115,9 @@ protected void writeHeader(RandomAccessFile raf, long fileLength, long elementCo
     raf.seek(0);
     raf.write(buffer);
   }
+
+  @Override
+  protected long getMaxFileSize() {
+    return Integer.MAX_VALUE;
+  }
 }
diff --git a/tape/src/test/java/com/squareup/tape/QueueFileImplTest.java b/tape/src/test/java/com/squareup/tape/QueueFileImplTest.java
index 5556fa5..d31b1ae 100644
--- a/tape/src/test/java/com/squareup/tape/QueueFileImplTest.java
+++ b/tape/src/test/java/com/squareup/tape/QueueFileImplTest.java
@@ -8,6 +8,8 @@
 import java.io.RandomAccessFile;
 
 import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * Tests for QueueFile.
@@ -31,6 +33,40 @@ protected int getHeaderLength() throws IOException {
     return QueueFileImpl.HEADER_LENGTH;
   }
 
+  /**
+   * This is unfortunately going to be a pretty slow test.
+   *
+   * @throws IOException
+   */
+  @Test
+  public void testLargerThan2GFails() throws IOException {
+    QueueFileImpl impl = new QueueFileImpl(file);
+    byte[] expected = new byte[1048576]; // 1M
+    long added = 0;
+    for (long i = 0; i < Integer.MAX_VALUE - 1048576; i += 1048576) {
+      impl.add(expected);
+      added++;
+    }
+    // exceed the 2G boundary.
+    try {
+      impl.add(expected);
+      fail("should not be able to add an element");
+    } catch (IOException ex) {
+      // expected
+    }
+    assertTrue(impl.usedBytes() < Integer.MAX_VALUE);
+
+    impl = new QueueFileImpl(file);
+    // now drain the queue to make sure it still works.
+    long removed = 0;
+    while (!impl.isEmpty()) {
+      assertThat(impl.peek()).isEqualTo(expected);
+      impl.remove();
+      removed++;
+    }
+    assertTrue(removed == added);
+  }
+
   /**
    * Exercise a bug where an expanding queue file where the start and end positions
    * are the same causes corruption.
