diff --git a/facebook/src/com/facebook/AppEventsLogger.java b/facebook/src/com/facebook/AppEventsLogger.java
index 0081ec8a8..7fe715cd2 100644
--- a/facebook/src/com/facebook/AppEventsLogger.java
+++ b/facebook/src/com/facebook/AppEventsLogger.java
@@ -704,9 +704,10 @@ private static SessionEventsState getSessionEventsState(Context context, AccessT
             SessionEventsState state = stateMap.get(accessTokenAppId);
             if (state == null) {
                 // Retrieve attributionId, but we will only send it if attribution is supported for the app.
-                String attributionId = Settings.getAttributionId(context.getContentResolver());
+                AttributionIdentifiers attributionIdentifiers =
+                    AttributionIdentifiers.getAttributionIdentifiers(context);
 
-                state = new SessionEventsState(attributionId, context.getPackageName(), hashedDeviceAndAppId);
+                state = new SessionEventsState(attributionIdentifiers, context.getPackageName(), hashedDeviceAndAppId);
                 stateMap.put(accessTokenAppId, state);
             }
             return state;
@@ -929,7 +930,7 @@ private static void notifyDeveloperError(String message) {
         private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
         private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
         private int numSkippedEventsDueToFullBuffer;
-        private String attributionId;
+        private AttributionIdentifiers attributionIdentifiers;
         private String packageName;
         private String hashedDeviceAndAppId;
 
@@ -939,8 +940,8 @@ private static void notifyDeveloperError(String message) {
 
         private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;
 
-        public SessionEventsState(String attributionId, String packageName, String hashedDeviceAndAppId) {
-            this.attributionId = attributionId;
+        public SessionEventsState(AttributionIdentifiers identifiers, String packageName, String hashedDeviceAndAppId) {
+            this.attributionIdentifiers = identifiers;
             this.packageName = packageName;
             this.hashedDeviceAndAppId = hashedDeviceAndAppId;
         }
@@ -1020,7 +1021,7 @@ private void populateRequest(Request request, int numSkipped, JSONArray events,
             }
 
             if (includeAttribution) {
-                Utility.setAppEventAttributionParameters(publishParams, attributionId,
+                Utility.setAppEventAttributionParameters(publishParams, attributionIdentifiers,
                         hashedDeviceAndAppId, limitEventUsage);
             }
 
diff --git a/facebook/src/com/facebook/AppLinkData.java b/facebook/src/com/facebook/AppLinkData.java
index 2c68b04cc..5309337c1 100644
--- a/facebook/src/com/facebook/AppLinkData.java
+++ b/facebook/src/com/facebook/AppLinkData.java
@@ -24,10 +24,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.util.Log;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.PlatformServiceClient;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
+import com.facebook.internal.*;
+import com.facebook.model.GraphObject;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -48,12 +46,30 @@
      */
     public static final String ARGUMENTS_REFERER_DATA_KEY = "referer_data";
 
+    /**
+     * Key that should be used to pull out the native class that would have been used if the applink was deferred.
+     */
+    public static final String ARGUMENTS_NATIVE_CLASS_KEY = "com.facebook.platform.APPLINK_NATIVE_CLASS";
+
+    /**
+     * Key that should be used to pull out the native url that would have been used if the applink was deferred.
+     */
+    public static final String ARGUMENTS_NATIVE_URL = "com.facebook.platform.APPLINK_NATIVE_URL";
+
     static final String BUNDLE_APPLINK_ARGS_KEY = "com.facebook.platform.APPLINK_ARGS";
     private static final String BUNDLE_AL_APPLINK_DATA_KEY = "al_applink_data";
     private static final String APPLINK_BRIDGE_ARGS_KEY = "bridge_args";
     private static final String APPLINK_METHOD_ARGS_KEY = "method_args";
     private static final String APPLINK_VERSION_KEY = "version";
     private static final String BRIDGE_ARGS_METHOD_KEY = "method";
+    private static final String DEFERRED_APP_LINK_EVENT = "DEFERRED_APP_LINK";
+    private static final String DEFERRED_APP_LINK_PATH = "%s/activities";
+
+    private static final String DEFERRED_APP_LINK_ARGS_FIELD = "applink_args";
+    private static final String DEFERRED_APP_LINK_CLASS_FIELD = "applink_class";
+    private static final String DEFERRED_APP_LINK_CLICK_TIME_FIELD = "click_time";
+    private static final String DEFERRED_APP_LINK_URL_FIELD = "applink_url";
+
     private static final String METHOD_ARGS_TARGET_URL_KEY = "target_url";
     private static final String METHOD_ARGS_REF_KEY = "ref";
     private static final String REFERER_DATA_REF_KEY = "fb_ref";
@@ -96,17 +112,47 @@ public static void fetchDeferredAppLinkData(
 
         Validate.notNull(applicationId, "applicationId");
 
-        DeferredAppLinkDataClient client = new DeferredAppLinkDataClient(context, applicationId);
-        DeferredAppLinkDataClient.CompletedListener callback = new DeferredAppLinkDataClient.CompletedListener() {
+        final Context applicationContext = context.getApplicationContext();
+        final String applicationIdCopy = applicationId;
+        Settings.getExecutor().execute(new Runnable() {
             @Override
-            public void completed(Bundle result) {
-                AppLinkData appLinkData = null;
-                if (result != null) {
-                    final String appLinkArgsJsonString = result.getString(BUNDLE_APPLINK_ARGS_KEY);
-                    final long tapTimeUtc = result.getLong(ARGUMENTS_TAPTIME_KEY, -1);
+            public void run() {
+                fetchDeferredAppLinkFromServer(applicationContext, applicationIdCopy, completionHandler);
+            }
+        });
+    }
 
-                    // Now create the app link
+    private static void fetchDeferredAppLinkFromServer(
+            Context context,
+            String applicationId,
+            final CompletionHandler completionHandler) {
+
+        GraphObject deferredApplinkParams = GraphObject.Factory.create();
+        deferredApplinkParams.setProperty("event", DEFERRED_APP_LINK_EVENT);
+        Utility.setAppEventAttributionParameters(deferredApplinkParams,
+                AttributionIdentifiers.getAttributionIdentifiers(context),
+                Utility.getHashedDeviceAndAppID(context, applicationId),
+                Settings.getLimitEventAndDataUsage(context));
+        deferredApplinkParams.setProperty("application_package_name", context.getPackageName());
+
+        String deferredApplinkUrlPath = String.format(DEFERRED_APP_LINK_PATH, applicationId);
+        AppLinkData appLinkData = null;
+
+        try {
+            Request deferredApplinkRequest = Request.newPostRequest(
+                    null, deferredApplinkUrlPath, deferredApplinkParams, null);
+            Response deferredApplinkResponse = deferredApplinkRequest.executeAndWait();
+            GraphObject wireResponse = deferredApplinkResponse.getGraphObject();
+            JSONObject jsonResponse = wireResponse != null ? wireResponse.getInnerJSONObject() : null;
+            if (jsonResponse != null) {
+                final String appLinkArgsJsonString = jsonResponse.optString(DEFERRED_APP_LINK_ARGS_FIELD);
+                final long tapTimeUtc = jsonResponse.optLong(DEFERRED_APP_LINK_CLICK_TIME_FIELD, -1);
+                final String appLinkClassName = jsonResponse.optString(DEFERRED_APP_LINK_CLASS_FIELD);
+                final String appLinkUrl = jsonResponse.optString(DEFERRED_APP_LINK_URL_FIELD);
+
+                if (appLinkArgsJsonString != null && appLinkArgsJsonString != "") {
                     appLinkData = createFromJson(appLinkArgsJsonString);
+
                     if (tapTimeUtc != -1) {
                         try {
                             if (appLinkData.arguments != null) {
@@ -119,23 +165,39 @@ public void completed(Bundle result) {
                             Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
                         }
                     }
+
+                    if (appLinkClassName != null) {
+                        try {
+                            if (appLinkData.arguments != null) {
+                                appLinkData.arguments.put(ARGUMENTS_NATIVE_CLASS_KEY, appLinkClassName);
+                            }
+                            if (appLinkData.argumentBundle != null) {
+                                appLinkData.argumentBundle.putString(ARGUMENTS_NATIVE_CLASS_KEY, appLinkClassName);
+                            }
+                        } catch (JSONException e) {
+                            Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
+                        }
+                    }
+
+                    if (appLinkUrl != null) {
+                        try {
+                            if (appLinkData.arguments != null) {
+                                appLinkData.arguments.put(ARGUMENTS_NATIVE_URL, appLinkUrl);
+                            }
+                            if (appLinkData.argumentBundle != null) {
+                                appLinkData.argumentBundle.putString(ARGUMENTS_NATIVE_URL, appLinkUrl);
+                            }
+                        } catch (JSONException e) {
+                            Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
+                        }
+                    }
                 }
-                completionHandler.onDeferredAppLinkDataFetched(appLinkData);
             }
-        };
-        client.setCompletedListener(callback);
-
-        if (!client.start()) {
-            // there is not a sufficient version of fb4a present to return a deferred app link, so kick off
-            // a call to the completion handler.
-            Handler handler = new Handler(Looper.getMainLooper());
-            handler.post(new Runnable() {
-                @Override
-                public void run() {
-                    completionHandler.onDeferredAppLinkDataFetched(null);
-                }
-            });
+        } catch (Exception e) {
+            Utility.logd(TAG, "Unable to fetch deferred applink from server");
         }
+
+        completionHandler.onDeferredAppLinkDataFetched(appLinkData);
     }
 
     /**
@@ -344,18 +406,4 @@ public Bundle getRefererData() {
          */
         void onDeferredAppLinkDataFetched(AppLinkData appLinkData);
     }
-
-    final static class DeferredAppLinkDataClient extends PlatformServiceClient {
-
-        DeferredAppLinkDataClient(Context context, String applicationId) {
-            super(context, NativeProtocol.MESSAGE_GET_INSTALL_DATA_REQUEST, NativeProtocol.MESSAGE_GET_INSTALL_DATA_REPLY,
-                    NativeProtocol.PROTOCOL_VERSION_20130618, applicationId);
-        }
-
-        @Override
-        protected void populateRequestBundle(Bundle data) {
-            String packageName = getContext().getPackageName();
-            data.putString(NativeProtocol.EXTRA_GET_INSTALL_DATA_PACKAGE, packageName);
-        }
-    }
 }
diff --git a/facebook/src/com/facebook/FacebookBroadcastReceiver.java b/facebook/src/com/facebook/FacebookBroadcastReceiver.java
new file mode 100644
index 000000000..ec2556c9b
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookBroadcastReceiver.java
@@ -0,0 +1,42 @@
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * This class implements a simple BroadcastReceiver designed to listen for broadcast notifications from the
+ * Facebook app. At present, these notifications consistent of success/failure notifications for photo upload
+ * operations that happen in the background.
+ *
+ * Applications may subclass this class and register it in their AndroidManifest.xml, listening on the
+ * com.facebook.platform.AppCallResultBroadcast action.
+ */
+public class FacebookBroadcastReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String appCallId = intent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID);
+        String action = intent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_ACTION);
+        if (appCallId != null && action != null) {
+            Bundle extras = intent.getExtras();
+
+            if (NativeProtocol.isErrorResult(intent)) {
+                onFailedAppCall(appCallId, action, extras);
+            } else {
+                onSuccessfulAppCall(appCallId, action, extras);
+            }
+        }
+    }
+
+    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
+        // Default does nothing.
+    }
+
+    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
+        // Default does nothing.
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
index 8973962d3..92ad5c99d 100644
--- a/facebook/src/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -17,6 +17,6 @@
 package com.facebook;
 
 final class FacebookSdkVersion {
-    public static final String BUILD = "3.7.0";
+    public static final String BUILD = "3.8.0";
     public static final String MIGRATION_BUNDLE = "fbsdk:20131203";
 }
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
index e7660f6c0..b69d6b8fa 100644
--- a/facebook/src/com/facebook/Request.java
+++ b/facebook/src/com/facebook/Request.java
@@ -23,11 +23,8 @@
 import android.os.*;
 import android.text.TextUtils;
 import android.util.Pair;
-import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.*;
 import com.facebook.model.*;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -585,20 +582,23 @@ public static Request newCustomAudienceThirdPartyIdRequest(Session session,
         }
 
         String endpoint = applicationId + "/custom_audience_third_party_id";
-
+        AttributionIdentifiers attributionIdentifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
         Bundle parameters = new Bundle();
+
         if (session == null) {
             // Only use the attributionID if we don't have an open session.  If we do have an open session, then
             // the user token will be used to identify the user, and is more reliable than the attributionID.
-            String attributionId = Settings.getAttributionId(context.getContentResolver());
-            if (attributionId != null) {
-                parameters.putString("udid", attributionId);
+            String udid = attributionIdentifiers.getAttributionId() != null
+                ? attributionIdentifiers.getAttributionId()
+                : attributionIdentifiers.getAndroidAdvertiserId();
+            if (attributionIdentifiers.getAttributionId() != null) {
+                parameters.putString("udid", udid);
             }
         }
 
         // Server will choose to not provide the App User ID in the event that event usage has been limited for
         // this user for this app.
-        if (Settings.getLimitEventAndDataUsage(context)) {
+        if (Settings.getLimitEventAndDataUsage(context) || attributionIdentifiers.isTrackingLimited()) {
             parameters.putString("limit_event_usage", "1");
         }
 
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
index fe1ee6558..a07e31639 100644
--- a/facebook/src/com/facebook/Settings.java
+++ b/facebook/src/com/facebook/Settings.java
@@ -26,6 +26,7 @@
 import android.os.Looper;
 import android.util.Log;
 import com.facebook.android.BuildConfig;
+import com.facebook.internal.AttributionIdentifiers;
 import com.facebook.internal.Utility;
 import com.facebook.model.GraphObject;
 import com.facebook.internal.Validate;
@@ -344,7 +345,7 @@ static Response publishInstallAndWaitForResponse(
             if (context == null || applicationId == null) {
                 throw new IllegalArgumentException("Both context and applicationId must be non-null");
             }
-            String attributionId = Settings.getAttributionId(context.getContentResolver());
+            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
             SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
             String pingKey = applicationId+"ping";
             String jsonKey = applicationId+"json";
@@ -360,9 +361,9 @@ static Response publishInstallAndWaitForResponse(
             publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
 
             Utility.setAppEventAttributionParameters(publishParams,
-                    attributionId,
+                    identifiers,
                     Utility.getHashedDeviceAndAppID(context, applicationId),
-                    !getLimitEventAndDataUsage(context));
+                    getLimitEventAndDataUsage(context));
             publishParams.setProperty(AUTO_PUBLISH, isAutoPublish);
             publishParams.setProperty("application_package_name", context.getPackageName());
 
@@ -384,10 +385,9 @@ static Response publishInstallAndWaitForResponse(
                 } else {
                     return new Response(null, null, graphObject, true);
                 }
-            } else if (attributionId == null) {
-                throw new FacebookException("No attribution id returned from the Facebook application");
+            } else if (identifiers.getAndroidAdvertiserId() == null && identifiers.getAttributionId() == null) {
+                throw new FacebookException("No attribution id available to send to server.");
             } else {
-
                 if (!Utility.queryAppSettings(applicationId, false).supportsAttribution()) {
                     throw new FacebookException("Install attribution has been disabled on the server.");
                 }
diff --git a/facebook/src/com/facebook/internal/AttributionIdentifiers.java b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
new file mode 100644
index 000000000..1c8f63018
--- /dev/null
+++ b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
@@ -0,0 +1,144 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.util.Log;
+
+import java.lang.reflect.Method;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class AttributionIdentifiers {
+    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
+    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
+            Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
+    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";
+
+    // com.google.android.gms.common.ConnectionResult.SUCCESS
+    private static final int CONNECTION_RESULT_SUCCESS = 0;
+
+    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;
+
+    private String attributionId;
+    private String androidAdvertiserId;
+    private boolean limitTracking;
+    private long fetchTime;
+
+    private static AttributionIdentifiers recentlyFetchedIdentifiers;
+
+    private static AttributionIdentifiers getAndroidId(Context context) {
+        AttributionIdentifiers identifiers = new AttributionIdentifiers();
+        try {
+            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
+                    "com.google.android.gms.common.GooglePlayServicesUtil",
+                    "isGooglePlayServicesAvailable",
+                    Context.class
+            );
+
+            if (isGooglePlayServicesAvailable == null) {
+                return identifiers;
+            }
+
+            Object connectionResult = Utility.invokeMethodQuietly(null, isGooglePlayServicesAvailable, context);
+            if (!(connectionResult instanceof Integer) || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
+                return identifiers;
+            }
+
+            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
+                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
+                    "getAdvertisingIdInfo",
+                    Context.class
+            );
+            if (getAdvertisingIdInfo == null) {
+                return identifiers;
+            }
+            Object advertisingInfo = Utility.invokeMethodQuietly(null, getAdvertisingIdInfo, context);
+            if (advertisingInfo == null) {
+                return identifiers;
+            }
+
+            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
+            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(advertisingInfo.getClass(), "isLimitAdTrackingEnabled");
+            if (getId == null || isLimitAdTrackingEnabled == null) {
+                return identifiers;
+            }
+
+            identifiers.androidAdvertiserId = (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
+            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(advertisingInfo, isLimitAdTrackingEnabled);
+        } catch (Exception e) {
+            Utility.logd("android_id", e);
+        }
+        return identifiers;
+    }
+
+    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
+        if (recentlyFetchedIdentifiers != null &&
+            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime < IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
+            return recentlyFetchedIdentifiers;
+        }
+
+        AttributionIdentifiers identifiers = getAndroidId(context);
+
+        try {
+            String [] projection = {ATTRIBUTION_ID_COLUMN_NAME, ANDROID_ID_COLUMN_NAME, LIMIT_TRACKING_COLUMN_NAME};
+            Cursor c = context.getContentResolver().query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
+            if (c == null || !c.moveToFirst()) {
+                return null;
+            }
+            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
+            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
+            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);
+
+            identifiers.attributionId = c.getString(attributionColumnIndex);
+
+            // if we failed to call Google's APIs directly (due to improper integration by the client), it may be
+            // possible for the local facebook application to relay it to us.
+            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 && identifiers.getAndroidAdvertiserId() == null) {
+                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
+                identifiers.limitTracking = Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
+            }
+            c.close();
+        } catch (Exception e) {
+            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
+            return null;
+        }
+
+        identifiers.fetchTime = System.currentTimeMillis();
+        recentlyFetchedIdentifiers = identifiers;
+        return identifiers;
+    }
+
+    public String getAttributionId() {
+        return attributionId;
+    }
+
+    public String getAndroidAdvertiserId() {
+        return androidAdvertiserId;
+    }
+
+    public boolean isTrackingLimited() {
+        return limitTracking;
+    }
+}
\ No newline at end of file
diff --git a/facebook/src/com/facebook/internal/NativeProtocol.java b/facebook/src/com/facebook/internal/NativeProtocol.java
index 98417dcdc..c322f4419 100644
--- a/facebook/src/com/facebook/internal/NativeProtocol.java
+++ b/facebook/src/com/facebook/internal/NativeProtocol.java
@@ -57,6 +57,8 @@
     public static final int PROTOCOL_VERSION_20130502 = 20130502;
     public static final int PROTOCOL_VERSION_20130618 = 20130618;
     public static final int PROTOCOL_VERSION_20131107 = 20131107;
+    public static final int PROTOCOL_VERSION_20140204 = 20140204;
+
     public static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
     public static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
     public static final String EXTRA_PROTOCOL_CALL_ID = "com.facebook.platform.protocol.CALL_ID";
@@ -120,6 +122,7 @@
     public static final String EXTRA_DESCRIPTION = "com.facebook.platform.extra.DESCRIPTION";
     public static final String EXTRA_REF = "com.facebook.platform.extra.REF";
     public static final String EXTRA_DATA_FAILURES_FATAL = "com.facebook.platform.extra.DATA_FAILURES_FATAL";
+    public static final String EXTRA_PHOTOS = "com.facebook.platform.extra.PHOTOS";
 
     // Extras supported for ACTION_OGACTIONPUBLISH_DIALOG:
     public static final String EXTRA_ACTION = "com.facebook.platform.extra.ACTION";
@@ -165,6 +168,9 @@
     // Columns returned by PlatformProvider
     private static final String PLATFORM_PROVIDER_VERSION_COLUMN = "version";
 
+    // Broadcast action for asynchronously-executing AppCalls
+    private static final String PLATFORM_ASYNC_APPCALL_ACTION = "com.facebook.platform.AppCallResultBroadcast";
+
     private static abstract class NativeAppInfo {
         abstract protected String getPackage();
         abstract protected String getSignature();
@@ -336,6 +342,7 @@ public static Intent createTokenRefreshIntent(Context context) {
     // Note: be sure this stays sorted in descending order; add new versions at the beginning
     private static final List<Integer> KNOWN_PROTOCOL_VERSIONS =
             Arrays.asList(
+                    PROTOCOL_VERSION_20140204,
                     PROTOCOL_VERSION_20131107,
                     PROTOCOL_VERSION_20130618,
                     PROTOCOL_VERSION_20130502,
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
index 28afbf84f..3704d2fcb 100644
--- a/facebook/src/com/facebook/internal/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -36,6 +36,8 @@
 import org.json.JSONTokener;
 
 import java.io.*;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.HttpURLConnection;
 import java.net.URLConnection;
 import java.security.MessageDigest;
@@ -419,14 +421,46 @@ public static String getHashedDeviceAndAppID(Context context, String application
     }
 
     public static void setAppEventAttributionParameters(GraphObject params,
-            String attributionId, String hashedDeviceAndAppId, boolean limitEventUsage) {
+            AttributionIdentifiers attributionIdentifiers, String hashedDeviceAndAppId, boolean limitEventUsage) {
         // Send attributionID if it exists, otherwise send a hashed device+appid specific value as the advertiser_id.
-        if (attributionId != null) {
-            params.setProperty("attribution", attributionId);
+        if (attributionIdentifiers.getAttributionId() != null) {
+            params.setProperty("attribution", attributionIdentifiers.getAttributionId());
+        }
+
+        if (attributionIdentifiers.getAndroidAdvertiserId() != null) {
+            params.setProperty("advertiser_id", attributionIdentifiers.getAndroidAdvertiserId());
+            params.setProperty("advertiser_tracking_enabled", !attributionIdentifiers.isTrackingLimited());
         } else if (hashedDeviceAndAppId != null) {
             params.setProperty("advertiser_id", hashedDeviceAndAppId);
         }
 
         params.setProperty("application_tracking_enabled", !limitEventUsage);
     }
+
+    public static Method getMethodQuietly(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
+        try {
+            return clazz.getMethod(methodName, parameterTypes);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        }
+    }
+
+    public static Method getMethodQuietly(String className, String methodName, Class<?>... parameterTypes) {
+        try {
+            Class<?> clazz = Class.forName(className);
+            return getMethodQuietly(clazz, methodName, parameterTypes);
+        } catch (ClassNotFoundException ex) {
+            return null;
+        }
+    }
+
+    public static Object invokeMethodQuietly(Object receiver, Method method, Object... args) {
+        try {
+            return method.invoke(receiver, args);
+        } catch (IllegalAccessException ex) {
+            return null;
+        } catch (InvocationTargetException ex) {
+            return null;
+        }
+    }
 }
diff --git a/facebook/src/com/facebook/widget/FacebookDialog.java b/facebook/src/com/facebook/widget/FacebookDialog.java
index 77457b457..cb5c8a56a 100644
--- a/facebook/src/com/facebook/widget/FacebookDialog.java
+++ b/facebook/src/com/facebook/widget/FacebookDialog.java
@@ -95,7 +95,12 @@
          * Indicates whether the native Share dialog itself is supported by the installed version of the
          * Facebook application.
          */
-        SHARE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618);
+        SHARE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618),
+        /**
+         * Indicates whether the native Share dialog supports sharing of photo images.
+         */
+        PHOTOS(NativeProtocol.PROTOCOL_VERSION_20140204),
+        ;
 
         private int minVersion;
 
@@ -327,12 +332,14 @@ private static String getActionForFeatures(Iterable<? extends DialogFeature> fea
         return action;
     }
 
-    private abstract static class Builder<CONCRETE extends Builder<?>> {
+    abstract static class Builder<CONCRETE extends Builder<?>> {
         final protected Activity activity;
         final protected String applicationId;
         final protected PendingCall appCall;
         protected Fragment fragment;
         protected String applicationName;
+        protected HashMap<String, Bitmap> imageAttachments = new HashMap<String, Bitmap>();
+        protected HashMap<String, File> imageAttachmentFiles = new HashMap<String, File>();
 
         Builder(Activity activity) {
             Validate.notNull(activity, "activity");
@@ -428,7 +435,53 @@ void validate() {
         }
 
         OnPresentCallback getOnPresentCallback() {
-            return null;
+            return new OnPresentCallback() {
+                @Override
+                public void onPresent(Context context) throws Exception {
+                    // We're actually being presented, so put our attachments in the content provider.
+                    if (imageAttachments != null && imageAttachments.size() > 0) {
+                        getAttachmentStore().addAttachmentsForCall(context, appCall.getCallId(), imageAttachments);
+                    }
+                    if (imageAttachmentFiles != null && imageAttachmentFiles.size() > 0) {
+                        getAttachmentStore().addAttachmentFilesForCall(context, appCall.getCallId(),
+                                imageAttachmentFiles);
+                    }
+                }
+            };
+        }
+
+        protected List<String> addImageAttachments(Collection<Bitmap> bitmaps) {
+            ArrayList<String> attachmentUrls = new ArrayList<String>();
+            for (Bitmap bitmap : bitmaps) {
+                String attachmentName = UUID.randomUUID().toString();
+
+                addImageAttachment(attachmentName, bitmap);
+
+                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
+                        attachmentName);
+                attachmentUrls.add(url);
+            }
+
+            return attachmentUrls;
+        }
+
+        protected List<String> addImageAttachmentFiles(Collection<File> bitmapFiles) {
+            ArrayList<String> attachmentUrls = new ArrayList<String>();
+            for (File bitmapFile : bitmapFiles) {
+                String attachmentName = UUID.randomUUID().toString();
+
+                addImageAttachment(attachmentName, bitmapFile);
+
+                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
+                        attachmentName);
+                attachmentUrls.add(url);
+            }
+
+            return attachmentUrls;
+        }
+
+        List<String> getImageAttachmentNames() {
+            return new ArrayList<String>(imageAttachments.keySet());
         }
 
         abstract Bundle setBundleExtras(Bundle extras);
@@ -440,13 +493,27 @@ void putExtra(Bundle extras, String key, String value) {
         }
 
         abstract EnumSet<? extends DialogFeature> getDialogFeatures();
+
+        protected CONCRETE addImageAttachment(String imageName, Bitmap bitmap) {
+            imageAttachments.put(imageName, bitmap);
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        protected CONCRETE addImageAttachment(String imageName, File attachment) {
+            imageAttachmentFiles.put(imageName, attachment);
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
     }
 
     private abstract static class ShareDialogBuilderBase<CONCRETE extends ShareDialogBuilderBase<?>> extends Builder<CONCRETE> {
         private String name;
         private String caption;
         private String description;
-        private String link;
+        protected String link;
         private String picture;
         private String place;
         private ArrayList<String> friends;
@@ -624,14 +691,133 @@ public ShareDialogBuilder(Activity activity) {
         }
     }
 
+    private static abstract class PhotoDialogBuilderBase<CONCRETE extends PhotoDialogBuilderBase<?>>
+            extends Builder<CONCRETE> {
+        private String place;
+        private ArrayList<String> friends;
+        private ArrayList<String> imageAttachmentUrls = new ArrayList<String>();
+
+        /**
+         * Constructor.
+         *
+         * @param activity the Activity which is presenting the native Share dialog; must not be null
+         */
+        public PhotoDialogBuilderBase(Activity activity) {
+            super(activity);
+        }
+
+        /**
+         * Sets the place for the item to be shared.
+         *
+         * @param place the Facebook ID of the place
+         * @return this instance of the builder
+         */
+        public CONCRETE setPlace(String place) {
+            this.place = place;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Sets the tagged friends for the item to be shared.
+         *
+         * @param friends a list of Facebook IDs of the friends to be tagged in the shared item
+         * @return this instance of the builder
+         */
+        public CONCRETE setFriends(List<String> friends) {
+            this.friends = new ArrayList<String>(friends);
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * <p></p>Adds one or more photos to the list of photos to display in the native Share dialog, by providing
+         * an in-memory representation of the photos. The dialog's callback will be called once the user has
+         * shared the photos, but the photos themselves may be uploaded in the background by the Facebook app;
+         * apps wishing to be notified when the photo upload has succeeded or failed should extend the
+         * FacebookBroadcastReceiver class and register it in their AndroidManifest.xml.</p>
+         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
+         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
+         * @param photos a collection of Files representing photos to be uploaded
+         * @return this instance of the builder
+         */
+        public CONCRETE addPhotos(Collection<Bitmap> photos) {
+            imageAttachmentUrls.addAll(addImageAttachments(photos));
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Adds one or more photos to the list of photos to display in the native Share dialog, by specifying
+         * their location in the file system. The dialog's callback will be called once the user has
+         * shared the photos, but the photos themselves may be uploaded in the background by the Facebook app;
+         * apps wishing to be notified when the photo upload has succeeded or failed should extend the
+         * FacebookBroadcastReceiver class and register it in their AndroidManifest.xml.
+         * @param photos a collection of Files representing photos to be uploaded
+         * @return this instance of the builder
+         */
+        public CONCRETE addPhotoFiles(Collection<File> photos) {
+            imageAttachmentUrls.addAll(addImageAttachmentFiles(photos));
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        @Override
+        void validate() {
+            super.validate();
+
+            if (imageAttachmentUrls.isEmpty()) {
+                throw new FacebookException("Must specify at least one photo.");
+            }
+        }
+
+        @Override
+        Bundle setBundleExtras(Bundle extras) {
+            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
+            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_NAME, applicationName);
+            putExtra(extras, NativeProtocol.EXTRA_PLACE_TAG, place);
+            extras.putStringArrayList(NativeProtocol.EXTRA_PHOTOS, imageAttachmentUrls);
+
+            if (!Utility.isNullOrEmpty(friends)) {
+                extras.putStringArrayList(NativeProtocol.EXTRA_FRIEND_TAGS, friends);
+            }
+            return extras;
+        }
+    }
+
+    /**
+     * Provides a builder which can construct a FacebookDialog instance suitable for presenting the native
+     * Share dialog for sharing photos. This builder will throw an exception if the Facebook application is not
+     * installed, so it should only be used if {@link FacebookDialog#canPresentShareDialog(android.content.Context,
+     * com.facebook.widget.FacebookDialog.ShareDialogFeature...)}  indicates the capability is available.
+     */
+    public static class PhotoShareDialogBuilder extends PhotoDialogBuilderBase<PhotoShareDialogBuilder> {
+        /**
+         * Constructor.
+         *
+         * @param activity the Activity which is presenting the native Share dialog; must not be null
+         */
+        public PhotoShareDialogBuilder(Activity activity) {
+            super(activity);
+        }
+
+        @Override
+        EnumSet<? extends DialogFeature> getDialogFeatures() {
+            return EnumSet.of(ShareDialogFeature.SHARE_DIALOG, ShareDialogFeature.PHOTOS);
+        }
+
+    }
+
     private static abstract class OpenGraphDialogBuilderBase<CONCRETE extends OpenGraphDialogBuilderBase<?>>
             extends Builder<CONCRETE> {
 
         private String previewPropertyName;
         private OpenGraphAction action;
         private String actionType;
-        private HashMap<String, Bitmap> imageAttachments;
-        private HashMap<String, File> imageAttachmentFiles;
         private boolean dataErrorsFatal;
 
         /**
@@ -996,40 +1182,6 @@ void updateObjectAttachmentUrls(String objectProperty, List<String> attachmentUr
             object.setImage(attachments);
         }
 
-        private List<String> addImageAttachments(List<Bitmap> bitmaps) {
-            ArrayList<String> attachmentUrls = new ArrayList<String>();
-            for (Bitmap bitmap : bitmaps) {
-                String attachmentName = UUID.randomUUID().toString();
-
-                addImageAttachment(attachmentName, bitmap);
-
-                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
-                        attachmentName);
-                attachmentUrls.add(url);
-            }
-
-            return attachmentUrls;
-        }
-
-        private List<String> addImageAttachmentFiles(List<File> bitmapFiles) {
-            ArrayList<String> attachmentUrls = new ArrayList<String>();
-            for (File bitmapFile : bitmapFiles) {
-                String attachmentName = UUID.randomUUID().toString();
-
-                addImageAttachment(attachmentName, bitmapFile);
-
-                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
-                        attachmentName);
-                attachmentUrls.add(url);
-            }
-
-            return attachmentUrls;
-        }
-
-        List<String> getImageAttachmentNames() {
-            return new ArrayList<String>(imageAttachments.keySet());
-        }
-
         @Override
         Bundle setBundleExtras(Bundle extras) {
             putExtra(extras, NativeProtocol.EXTRA_PREVIEW_PROPERTY_NAME, previewPropertyName);
@@ -1045,43 +1197,6 @@ Bundle setBundleExtras(Bundle extras) {
             return extras;
         }
 
-        @Override
-        OnPresentCallback getOnPresentCallback() {
-            return new OnPresentCallback() {
-                @Override
-                public void onPresent(Context context) throws Exception {
-                    // We're actually being presented, so put our attachments in the content provider.
-                    if (imageAttachments != null && imageAttachments.size() > 0) {
-                        getAttachmentStore().addAttachmentsForCall(context, appCall.getCallId(), imageAttachments);
-                    }
-                    if (imageAttachmentFiles != null && imageAttachmentFiles.size() > 0) {
-                        getAttachmentStore().addAttachmentFilesForCall(context, appCall.getCallId(),
-                                imageAttachmentFiles);
-                    }
-                }
-            };
-        }
-
-        private CONCRETE addImageAttachment(String imageName, Bitmap bitmap) {
-            if (imageAttachments == null) {
-                imageAttachments = new HashMap<String, Bitmap>();
-            }
-            imageAttachments.put(imageName, bitmap);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        private CONCRETE addImageAttachment(String imageName, File attachment) {
-            if (imageAttachmentFiles == null) {
-                imageAttachmentFiles = new HashMap<String, File>();
-            }
-            imageAttachmentFiles.put(imageName, attachment);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
         private JSONObject flattenChildrenOfGraphObject(JSONObject graphObject) {
             try {
                 // Clone the existing object to avoid modifying it from under the caller.
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/widget/WebDialog.java
index aaced5ccd..0066d3490 100644
--- a/facebook/src/com/facebook/widget/WebDialog.java
+++ b/facebook/src/com/facebook/widget/WebDialog.java
@@ -346,6 +346,7 @@ private void setUpWebView(int margin) {
                 ViewGroup.LayoutParams.MATCH_PARENT));
         webView.setVisibility(View.INVISIBLE);
         webView.getSettings().setSavePassword(false);
+        webView.getSettings().setSaveFormData(false);
 
         webViewContainer.setPadding(margin, margin, margin, margin);
         webViewContainer.addView(webView);
diff --git a/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java b/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
index a00e90083..444d48836 100644
--- a/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
+++ b/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
@@ -17,6 +17,7 @@
 package com.facebook.widget;
 
 import android.graphics.Bitmap;
+import com.facebook.FacebookException;
 import com.facebook.FacebookTestCase;
 import com.facebook.model.GraphObject;
 import com.facebook.model.OpenGraphAction;
@@ -24,6 +25,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -254,6 +256,5 @@ public void testOpenGraphDialogBuilderDeprecatedConstructorRequiresActionTypeMat
             fail("expected exception");
         } catch (IllegalArgumentException exception) {
         }
-
     }
 }
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
index 246d0de24..04809d609 100644
--- a/samples/HelloFacebookSample/AndroidManifest.xml
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -22,5 +22,13 @@
                   android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+        <provider android:authorities="com.facebook.app.NativeAppCallContentProvider355198514515820"
+                  android:name="com.facebook.NativeAppCallContentProvider"
+                  android:exported="true"/>
+        <receiver android:name="com.facebook.samples.hellofacebook.HelloFacebookBroadcastReceiver">
+            <intent-filter>
+                <action android:name="com.facebook.platform.AppCallResultBroadcast" />
+            </intent-filter>
+        </receiver>
     </application>
 </manifest>
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java
new file mode 100644
index 000000000..a1328155e
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java
@@ -0,0 +1,40 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.os.Bundle;
+import android.util.Log;
+import com.facebook.FacebookBroadcastReceiver;
+
+/**
+ * This is a simple example to demonstrate how an app could extend FacebookBroadcastReceiver to handle
+ * notifications that long-running operations such as photo uploads have finished.
+ */
+public class HelloFacebookBroadcastReceiver extends FacebookBroadcastReceiver {
+
+    @Override
+    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
+        // A real app could update UI or notify the user that their photo was uploaded.
+        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " succeeded."));
+    }
+
+    @Override
+    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
+        // A real app could update UI or notify the user that their photo was not uploaded.
+        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " failed."));
+    }
+}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
index bf374a95c..33485efb4 100644
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
@@ -65,6 +65,7 @@
     private GraphPlace place;
     private List<GraphUser> tags;
     private boolean canPresentShareDialog;
+    private boolean canPresentShareDialogWithPhotos;
 
     private enum PendingAction {
         NONE,
@@ -175,8 +176,12 @@ public void onBackStackChanged() {
             }
         });
 
+        // Can we present the share dialog for regular links?
         canPresentShareDialog = FacebookDialog.canPresentShareDialog(this,
                 FacebookDialog.ShareDialogFeature.SHARE_DIALOG);
+        // Can we present the share dialog for photos?
+        canPresentShareDialogWithPhotos = FacebookDialog.canPresentShareDialog(this,
+                FacebookDialog.ShareDialogFeature.PHOTOS);
     }
 
     @Override
@@ -238,7 +243,7 @@ private void updateUI() {
         boolean enableButtons = (session != null && session.isOpened());
 
         postStatusUpdateButton.setEnabled(enableButtons || canPresentShareDialog);
-        postPhotoButton.setEnabled(enableButtons);
+        postPhotoButton.setEnabled(enableButtons || canPresentShareDialogWithPhotos);
         pickFriendsButton.setEnabled(enableButtons);
         pickPlaceButton.setEnabled(enableButtons);
 
@@ -295,7 +300,7 @@ private void onClickPostStatusUpdate() {
         performPublish(PendingAction.POST_STATUS_UPDATE, canPresentShareDialog);
     }
 
-    private FacebookDialog.ShareDialogBuilder createShareDialogBuilder() {
+    private FacebookDialog.ShareDialogBuilder createShareDialogBuilderForLink() {
         return new FacebookDialog.ShareDialogBuilder(this)
                 .setName("Hello Facebook")
                 .setDescription("The 'Hello Facebook' sample application showcases simple Facebook integration")
@@ -304,7 +309,7 @@ private void onClickPostStatusUpdate() {
 
     private void postStatusUpdate() {
         if (canPresentShareDialog) {
-            FacebookDialog shareDialog = createShareDialogBuilder().build();
+            FacebookDialog shareDialog = createShareDialogBuilderForLink().build();
             uiHelper.trackPendingDialogCall(shareDialog.present());
         } else if (user != null && hasPublishPermission()) {
             final String message = getString(R.string.status_update, user.getFirstName(), (new Date().toString()));
@@ -322,12 +327,20 @@ public void onCompleted(Response response) {
     }
 
     private void onClickPostPhoto() {
-        performPublish(PendingAction.POST_PHOTO, false);
+        performPublish(PendingAction.POST_PHOTO, canPresentShareDialogWithPhotos);
+    }
+
+    private FacebookDialog.PhotoShareDialogBuilder createShareDialogBuilderForPhoto(Bitmap... photos) {
+        return new FacebookDialog.PhotoShareDialogBuilder(this)
+                .addPhotos(Arrays.asList(photos));
     }
 
     private void postPhoto() {
-        if (hasPublishPermission()) {
-            Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+        if (canPresentShareDialogWithPhotos) {
+            FacebookDialog shareDialog = createShareDialogBuilderForPhoto(image).build();
+            uiHelper.trackPendingDialogCall(shareDialog.present());
+        } else if (hasPublishPermission()) {
             Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
                 @Override
                 public void onCompleted(Response response) {
