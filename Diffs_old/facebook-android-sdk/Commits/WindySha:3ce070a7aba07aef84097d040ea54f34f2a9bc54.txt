diff --git a/CHANGELOG.md b/CHANGELOG.md
index 29852d287..36e4228ff 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,6 +10,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 ### Changed
 - Log Subscribe/StartTrial events going through GooglePlay store, which was logged as fb_mobile_purchase
 
+### Removed
+
+- Deprecate several activateApp and deactivateApp functions in AppEventsLogger.java
+
 ## [4.41.0] - 2019-03-08
 
 ### Removed
diff --git a/facebook-core/src/main/java/com/facebook/FacebookSdk.java b/facebook-core/src/main/java/com/facebook/FacebookSdk.java
index e5c9344f5..3db378411 100644
--- a/facebook-core/src/main/java/com/facebook/FacebookSdk.java
+++ b/facebook-core/src/main/java/com/facebook/FacebookSdk.java
@@ -90,6 +90,7 @@
     private static final int MAX_REQUEST_CODE_RANGE = 100;
 
     private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
+    private static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";
     private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
 
     private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
@@ -671,7 +672,7 @@ public static String getSdkVersion() {
     public static boolean getLimitEventAndDataUsage(Context context) {
         Validate.sdkInitialized();
         SharedPreferences preferences = context.getSharedPreferences(
-                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
+                APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
         return preferences.getBoolean("limitEventUsage", false);
     }
 
@@ -685,7 +686,7 @@ public static boolean getLimitEventAndDataUsage(Context context) {
      * @param context Used to persist this value across app runs.
      */
     public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
-        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
+        context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
             .edit()
             .putBoolean("limitEventUsage", limitEventUsage)
             .apply();
diff --git a/facebook-core/src/main/java/com/facebook/appevents/AppEventsLogger.java b/facebook-core/src/main/java/com/facebook/appevents/AppEventsLogger.java
index 30d950a9f..31cabcf2e 100644
--- a/facebook-core/src/main/java/com/facebook/appevents/AppEventsLogger.java
+++ b/facebook-core/src/main/java/com/facebook/appevents/AppEventsLogger.java
@@ -30,9 +30,7 @@
 import com.facebook.AccessToken;
 import com.facebook.FacebookSdk;
 import com.facebook.GraphRequest;
-import com.facebook.appevents.internal.ActivityLifecycleTracker;
 import com.facebook.appevents.internal.AutomaticAnalyticsLogger;
-import com.facebook.internal.Utility;
 
 import java.math.BigDecimal;
 import java.util.Currency;
@@ -169,9 +167,6 @@
     // Constants
     private static final String TAG = AppEventsLogger.class.getCanonicalName();
 
-    // TODO: T41629092 remove these constants after migration
-    public static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";
-
     private AppEventsLoggerImpl loggerImpl;
 
     /**
@@ -205,69 +200,40 @@ public static void activateApp(Application application, String applicationId) {
     }
 
     /**
-     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be
-     * called whenever your app becomes active, typically in the onResume() method of each
-     * long-running Activity of your app.
-     * <p/>
-     * Use this method if your application ID is stored in application metadata, otherwise see
-     * {@link AppEventsLogger#activateApp(android.content.Context, String)}.
-     *
-     * @param context Used to access the applicationId and the attributionId for non-authenticated
-     *                users.
      * @deprecated Use {@link AppEventsLogger#activateApp(Application)}
      */
     @Deprecated
     @SuppressWarnings("deprecation")
-    public static void activateApp(Context context) {
-        AppEventsLoggerImpl.activateApp(context);
+    public static void activateApp(Context _context) {
+        activateApp(null, null);
     }
 
     /**
-     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be
-     * called whenever your app becomes active, typically in the onResume() method of each
-     * long-running Activity of your app.
-     *
-     * @param context       Used to access the attributionId for non-authenticated users.
-     * @param applicationId The specific applicationId to report the activation for.
      * @deprecated Use {@link AppEventsLogger#activateApp(Application)}
      */
     @Deprecated
-    public static void activateApp(Context context, String applicationId) {
-        AppEventsLoggerImpl.activateApp(context, applicationId);
+    public static void activateApp(Context context, String _str) {
+        AppEventsLoggerImpl.functionDEPRECATED("Please use activateApp(Application) " +
+                        "or activateApp(Application, String)");
     }
 
     /**
-     * Notifies the events system that the app has been deactivated (put in the background) and
-     * tracks the application session information. Should be called whenever your app becomes
-     * inactive, typically in the onPause() method of each long-running Activity of your app.
-     *
-     * Use this method if your application ID is stored in application metadata, otherwise see
-     * {@link AppEventsLogger#deactivateApp(android.content.Context, String)}.
-     *
-     * @param context Used to access the applicationId and the attributionId for non-authenticated
-     *                users.
      * @deprecated When using {@link AppEventsLogger#activateApp(Application)} deactivate app will
      * be logged automatically.
      */
     @Deprecated
     @SuppressWarnings("deprecation")
-    public static void deactivateApp(Context context) {
-        AppEventsLoggerImpl.deactivateApp(context);
+    public static void deactivateApp(Context _context) {
+        deactivateApp(null, null);
     }
 
     /**
-     * Notifies the events system that the app has been deactivated (put in the background) and
-     * tracks the application session information. Should be called whenever your app becomes
-     * inactive, typically in the onPause() method of each long-running Activity of your app.
-     *
-     * @param context       Used to access the attributionId for non-authenticated users.
-     * @param applicationId The specific applicationId to track session information for.
      * @deprecated When using {@link AppEventsLogger#activateApp(Application)} deactivate app will
      * be logged automatically.
      */
     @Deprecated
-    public static void deactivateApp(Context context, String applicationId) {
-        AppEventsLoggerImpl.deactivateApp(context, applicationId);
+    public static void deactivateApp(Context _context, String _str) {
+        AppEventsLoggerImpl.functionDEPRECATED("deactivate app will be logged automatically");
     }
 
     /**
@@ -759,9 +725,9 @@ public static void updateUserProperties(
                 parameters,
                 applicationID,
                 callback);
-    }
+     }
 
-    /**
+     /**
      * This method is only for internal and use by the Facebook SDK account kit
      * for legacy reason. Other usage is not allowed.
      */
diff --git a/facebook-core/src/main/java/com/facebook/appevents/AppEventsLoggerImpl.java b/facebook-core/src/main/java/com/facebook/appevents/AppEventsLoggerImpl.java
index 010da88dd..c89bb621b 100644
--- a/facebook-core/src/main/java/com/facebook/appevents/AppEventsLoggerImpl.java
+++ b/facebook-core/src/main/java/com/facebook/appevents/AppEventsLoggerImpl.java
@@ -57,16 +57,10 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.BufferedOutputStream;
-import java.io.FileNotFoundException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
 import java.math.BigDecimal;
 import java.util.Currency;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Locale;
-import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
@@ -80,10 +74,6 @@
     private static final String TAG = AppEventsLoggerImpl.class.getCanonicalName();
 
     private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
-    private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;
-
-    private static final String SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT =
-            "_fbSourceApplicationHasBeenSet";
 
     private static final String PUSH_PAYLOAD_KEY = "fb_push_payload";
     private static final String PUSH_PAYLOAD_CAMPAIGN_KEY = "campaign";
@@ -102,11 +92,11 @@
     private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
     private static Object staticLock = new Object();
     private static String anonymousAppDeviceGUID;
-    private static String sourceApplication;
-    private static boolean isOpenedByAppLink;
     private static boolean isActivateAppEventRequested;
     private static String pushNotificationsRegistrationId;
 
+    private static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";
+
     static void activateApp(Application application, String applicationId) {
         if (!FacebookSdk.isInitialized()) {
             throw new FacebookException("The Facebook sdk must be initialized before calling " +
@@ -130,106 +120,8 @@ static void activateApp(Application application, String applicationId) {
         ActivityLifecycleTracker.startTracking(application, applicationId);
     }
 
-    static void activateApp(Context context) {
-        if (ActivityLifecycleTracker.isTracking()) {
-            Log.w(TAG, "activateApp events are being logged automatically. " +
-                    "There's no need to call activateApp explicitly, this is safe to remove.");
-            return;
-        }
-
-        FacebookSdk.sdkInitialize(context);
-        activateApp(context, Utility.getMetadataApplicationId(context));
-    }
-
-    static void activateApp(Context context, String applicationId) {
-        if (ActivityLifecycleTracker.isTracking()) {
-            Log.w(TAG, "activateApp events are being logged automatically. " +
-                    "There's no need to call activateApp explicitly, this is safe to remove.");
-            return;
-        }
-
-        if (context == null || applicationId == null) {
-            throw new IllegalArgumentException("Both context and applicationId must be non-null");
-        }
-
-        AnalyticsUserIDStore.initStore();
-        UserDataStore.initStore();
-
-        if ((context instanceof Activity)) {
-            setSourceApplication((Activity) context);
-        } else {
-            // If context is not an Activity, we cannot get intent nor calling activity.
-            resetSourceApplication();
-            Utility.logd(TAG,
-                    "To set source application the context of activateApp must be an instance of" +
-                            " Activity");
-        }
-
-        // activateApp supersedes publishInstall in the public API, so we need to explicitly invoke
-        // it, since the server can't reliably infer install state for all conditions of an app
-        // activate.
-        FacebookSdk.publishInstallAsync(context, applicationId);
-
-        final AppEventsLoggerImpl logger = new AppEventsLoggerImpl(context, applicationId, null);
-        final long eventTime = System.currentTimeMillis();
-        final String sourceApplicationInfo = getSourceApplication();
-        backgroundExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                logger.logAppSessionResumeEvent(eventTime, sourceApplicationInfo);
-            }
-        });
-    }
-
-    static void deactivateApp(Context context) {
-        if (ActivityLifecycleTracker.isTracking()) {
-            Log.w(TAG, "deactivateApp events are being logged automatically. " +
-                    "There's no need to call deactivateApp, this is safe to remove.");
-            return;
-        }
-
-        deactivateApp(context, Utility.getMetadataApplicationId(context));
-    }
-
-    @Deprecated
-    static void deactivateApp(Context context, String applicationId) {
-        if (ActivityLifecycleTracker.isTracking()) {
-            Log.w(TAG, "deactivateApp events are being logged automatically. " +
-                    "There's no need to call deactivateApp, this is safe to remove.");
-            return;
-        }
-
-        if (context == null || applicationId == null) {
-            throw new IllegalArgumentException("Both context and applicationId must be non-null");
-        }
-
-        resetSourceApplication();
-
-        final AppEventsLoggerImpl logger = new AppEventsLoggerImpl(context, applicationId, null);
-        final long eventTime = System.currentTimeMillis();
-        backgroundExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                logger.logAppSessionSuspendEvent(eventTime);
-            }
-        });
-    }
-
-    private void logAppSessionResumeEvent(long eventTime, String sourceApplicationInfo) {
-        PersistedAppSessionInfo.onResume(
-                FacebookSdk.getApplicationContext(),
-                accessTokenAppId,
-                this,
-                eventTime,
-                sourceApplicationInfo);
-    }
-
-    private void logAppSessionSuspendEvent(long eventTime) {
-        PersistedAppSessionInfo.onSuspend(
-                FacebookSdk.getApplicationContext(),
-                accessTokenAppId,
-                this,
-                eventTime);
+    static void functionDEPRECATED(String extraMsg) {
+        Log.w(TAG, "This function is deprecated. " + extraMsg);
     }
 
     static void initializeLib(Context context, String applicationId) {
@@ -777,78 +669,6 @@ private static void notifyDeveloperError(String message) {
         Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "AppEvents", message);
     }
 
-    /**
-     * Source Application setters and getters
-     */
-    private static void setSourceApplication(Activity activity) {
-
-        ComponentName callingApplication = activity.getCallingActivity();
-        if (callingApplication != null) {
-            String callingApplicationPackage = callingApplication.getPackageName();
-            if (callingApplicationPackage.equals(activity.getPackageName())) {
-                // open by own app.
-                resetSourceApplication();
-                return;
-            }
-            sourceApplication = callingApplicationPackage;
-        }
-
-        // Tap icon to open an app will still get the old intent if the activity was opened by an
-        // intent before. Introduce an extra field in the intent to force clear the
-        // sourceApplication.
-        Intent openIntent = activity.getIntent();
-        if (openIntent == null ||
-                openIntent.getBooleanExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, false)) {
-            resetSourceApplication();
-            return;
-        }
-
-        Bundle appLinkData = AppLinks.getAppLinkData(openIntent);
-
-        if (appLinkData == null) {
-            resetSourceApplication();
-            return;
-        }
-
-        isOpenedByAppLink = true;
-
-        Bundle appLinkReferrerData = appLinkData.getBundle("referer_app_link");
-
-        if (appLinkReferrerData == null) {
-            sourceApplication = null;
-            return;
-        }
-
-        String appLinkReferrerPackage = appLinkReferrerData.getString("package");
-        sourceApplication = appLinkReferrerPackage;
-
-        // Mark this intent has been used to avoid use this intent again and again.
-        openIntent.putExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, true);
-
-        return;
-    }
-
-    static void setSourceApplication(String applicationPackage, boolean openByAppLink) {
-        sourceApplication = applicationPackage;
-        isOpenedByAppLink = openByAppLink;
-    }
-
-    static String getSourceApplication() {
-        String openType = "Unclassified";
-        if (isOpenedByAppLink) {
-            openType = "Applink";
-        }
-        if (sourceApplication != null) {
-            return openType + "(" + sourceApplication + ")";
-        }
-        return openType;
-    }
-
-    static void resetSourceApplication() {
-        sourceApplication = null;
-        isOpenedByAppLink = false;
-    }
-
     static Executor getAnalyticsExecutor() {
         if (backgroundExecutor == null) {
             initializeTimersIfNeeded();
@@ -863,14 +683,14 @@ static String getAnonymousAppDeviceGUID(Context context) {
                 if (anonymousAppDeviceGUID == null) {
 
                     SharedPreferences preferences = context.getSharedPreferences(
-                            AppEventsLogger.APP_EVENT_PREFERENCES,
+                            APP_EVENT_PREFERENCES,
                             Context.MODE_PRIVATE);
                     anonymousAppDeviceGUID = preferences.getString("anonymousAppDeviceGUID", null);
                     if (anonymousAppDeviceGUID == null) {
                         // Arbitrarily prepend XZ to distinguish from device supplied identifiers.
                         anonymousAppDeviceGUID = "XZ" + UUID.randomUUID().toString();
 
-                        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
+                        context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
                                 .edit()
                                 .putString("anonymousAppDeviceGUID", anonymousAppDeviceGUID)
                                 .apply();
@@ -881,153 +701,4 @@ static String getAnonymousAppDeviceGUID(Context context) {
 
         return anonymousAppDeviceGUID;
     }
-
-    //
-    // Deprecated Stuff
-    //
-
-    // Since we moved some private classes to internal classes outside the AppEventsLogger class
-    // for backwards compatibility we can override the classDescriptor to resolve to the correct
-    // class
-
-
-    static class PersistedAppSessionInfo {
-        private static final String PERSISTED_SESSION_INFO_FILENAME =
-                "AppEventsLogger.persistedsessioninfo";
-
-        private static final Object staticLock = new Object();
-        private static boolean hasChanges = false;
-        private static boolean isLoaded = false;
-        private static Map<AccessTokenAppIdPair, FacebookTimeSpentData> appSessionInfoMap;
-
-        private static final Runnable appSessionInfoFlushRunnable = new Runnable() {
-            @Override
-            public void run() {
-                PersistedAppSessionInfo.saveAppSessionInformation(
-                        FacebookSdk.getApplicationContext());
-            }
-        };
-
-        @SuppressWarnings("unchecked")
-        private static void restoreAppSessionInformation(Context context) {
-            ObjectInputStream ois = null;
-
-            synchronized (staticLock) {
-                if (!isLoaded) {
-                    try {
-                        ois = new ObjectInputStream(
-                                context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
-                        appSessionInfoMap = (HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>)
-                                ois.readObject();
-                        Logger.log(
-                                LoggingBehavior.APP_EVENTS,
-                                "AppEvents",
-                                "App session info loaded");
-                    } catch (FileNotFoundException fex) {
-                    } catch (Exception e) {
-                        Log.w(
-                                TAG,
-                                "Got unexpected exception restoring app session info: "
-                                        + e.toString());
-                    } finally {
-                        Utility.closeQuietly(ois);
-                        context.deleteFile(PERSISTED_SESSION_INFO_FILENAME);
-                        if (appSessionInfoMap == null) {
-                            appSessionInfoMap =
-                                    new HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>();
-                        }
-                        // Regardless of the outcome of the load, the session information cache
-                        // is always deleted. Therefore, always treat the session information cache
-                        // as loaded
-                        isLoaded = true;
-                        hasChanges = false;
-                    }
-                }
-            }
-        }
-
-        static void saveAppSessionInformation(Context context) {
-            ObjectOutputStream oos = null;
-
-            synchronized (staticLock) {
-                if (hasChanges) {
-                    try {
-                        oos = new ObjectOutputStream(
-                                new BufferedOutputStream(
-                                        context.openFileOutput(
-                                                PERSISTED_SESSION_INFO_FILENAME,
-                                                Context.MODE_PRIVATE)
-                                )
-                        );
-                        oos.writeObject(appSessionInfoMap);
-                        hasChanges = false;
-                        Logger.log(
-                                LoggingBehavior.APP_EVENTS,
-                                "AppEvents",
-                                "App session info saved");
-                    } catch (Exception e) {
-                        Log.w(
-                                TAG,
-                                "Got unexpected exception while writing app session info: "
-                                        + e.toString());
-                    } finally {
-                        Utility.closeQuietly(oos);
-                    }
-                }
-            }
-        }
-
-        static void onResume(
-                Context context,
-                AccessTokenAppIdPair accessTokenAppId,
-                AppEventsLoggerImpl logger,
-                long eventTime,
-                String sourceApplicationInfo
-        ) {
-            synchronized (staticLock) {
-                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
-                timeSpentData.onResume(logger, eventTime, sourceApplicationInfo);
-                onTimeSpentDataUpdate();
-            }
-        }
-
-        static void onSuspend(
-                Context context,
-                AccessTokenAppIdPair accessTokenAppId,
-                AppEventsLoggerImpl logger,
-                long eventTime
-        ) {
-            synchronized (staticLock) {
-                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
-                timeSpentData.onSuspend(logger, eventTime);
-                onTimeSpentDataUpdate();
-            }
-        }
-
-        private static FacebookTimeSpentData getTimeSpentData(
-                Context context,
-                AccessTokenAppIdPair accessTokenAppId
-        ) {
-            restoreAppSessionInformation(context);
-            FacebookTimeSpentData result = null;
-
-            result = appSessionInfoMap.get(accessTokenAppId);
-            if (result == null) {
-                result = new FacebookTimeSpentData();
-                appSessionInfoMap.put(accessTokenAppId, result);
-            }
-
-            return result;
-        }
-
-        private static void onTimeSpentDataUpdate() {
-            if (!hasChanges) {
-                hasChanges = true;
-                backgroundExecutor.schedule(
-                        appSessionInfoFlushRunnable,
-                        FLUSH_APP_SESSION_INFO_IN_SECONDS,
-                        TimeUnit.SECONDS);
-            }
-        }
-    }
 }
diff --git a/facebook-core/src/main/java/com/facebook/appevents/FacebookTimeSpentData.java b/facebook-core/src/main/java/com/facebook/appevents/FacebookTimeSpentData.java
deleted file mode 100644
index 359c41975..000000000
--- a/facebook-core/src/main/java/com/facebook/appevents/FacebookTimeSpentData.java
+++ /dev/null
@@ -1,332 +0,0 @@
-/**
- * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
- *
- * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
- * copy, modify, and distribute this software in source code or binary form for use
- * in connection with the web services and APIs provided by Facebook.
- *
- * As with any software that integrates with the Facebook platform, your use of
- * this software is subject to the Facebook Developer Principles and Policies
- * [http://developers.facebook.com/policy/]. This copyright notice shall be
- * included in all copies or substantial portions of the software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-package com.facebook.appevents;
-
-import android.os.Bundle;
-import android.text.format.DateUtils;
-
-import com.facebook.LoggingBehavior;
-import com.facebook.internal.Logger;
-
-import java.util.Locale;
-import java.io.Serializable;
-
-class FacebookTimeSpentData implements Serializable {
-    // Constants
-    private static final long serialVersionUID = 1L;
-    private static final String TAG = FacebookTimeSpentData.class.getCanonicalName();
-    private static final long FIRST_TIME_LOAD_RESUME_TIME = -1;
-    private static final long INTERRUPTION_THRESHOLD_MILLISECONDS = 1000;
-    private static final long NUM_MILLISECONDS_IDLE_TO_BE_NEW_SESSION =
-            60 * DateUtils.SECOND_IN_MILLIS;
-    private static final long APP_ACTIVATE_SUPPRESSION_PERIOD_IN_MILLISECONDS =
-            5 * DateUtils.MINUTE_IN_MILLIS;
-
-    // Should be kept in sync with the iOS sdk
-    private static final long[] INACTIVE_SECONDS_QUANTA =
-        new long[] {
-            5 * DateUtils.MINUTE_IN_MILLIS,
-            15 * DateUtils.MINUTE_IN_MILLIS,
-            30 * DateUtils.MINUTE_IN_MILLIS,
-            1 * DateUtils.HOUR_IN_MILLIS,
-            6 * DateUtils.HOUR_IN_MILLIS,
-            12 * DateUtils.HOUR_IN_MILLIS,
-            1 * DateUtils.DAY_IN_MILLIS,
-            2 * DateUtils.DAY_IN_MILLIS,
-            3 * DateUtils.DAY_IN_MILLIS,
-            7 * DateUtils.DAY_IN_MILLIS,
-            14 * DateUtils.DAY_IN_MILLIS,
-            21 * DateUtils.DAY_IN_MILLIS,
-            28 * DateUtils.DAY_IN_MILLIS,
-            60 * DateUtils.DAY_IN_MILLIS,
-            90 * DateUtils.DAY_IN_MILLIS,
-            120 * DateUtils.DAY_IN_MILLIS,
-            150 * DateUtils.DAY_IN_MILLIS,
-            180 * DateUtils.DAY_IN_MILLIS,
-            365 * DateUtils.DAY_IN_MILLIS,
-        };
-
-    private boolean isWarmLaunch;
-    private boolean isAppActive;
-    private long lastActivateEventLoggedTime;
-
-    // Member data that's persisted to disk
-    private long lastResumeTime;
-    private long lastSuspendTime;
-    private long millisecondsSpentInSession;
-    private int interruptionCount;
-    private String firstOpenSourceApplication;
-
-    /**
-     * Serialization proxy for the FacebookTimeSpentData class. This is version 1 of
-     * serialization. Future serializations may differ in format. This
-     * class should not be modified. If serializations formats change,
-     * create a new class SerializationProxyVx.
-     */
-    private static class SerializationProxyV1 implements Serializable {
-        private static final long serialVersionUID = 6L;
-
-        private final long lastResumeTime;
-        private final long lastSuspendTime;
-        private final long millisecondsSpentInSession;
-        private final int interruptionCount;
-
-        SerializationProxyV1(
-            long lastResumeTime,
-            long lastSuspendTime,
-            long millisecondsSpentInSession,
-            int interruptionCount
-        ) {
-            this.lastResumeTime = lastResumeTime;
-            this.lastSuspendTime = lastSuspendTime;
-            this.millisecondsSpentInSession = millisecondsSpentInSession;
-            this.interruptionCount = interruptionCount;
-        }
-
-        private Object readResolve() {
-            return new FacebookTimeSpentData(
-                lastResumeTime,
-                lastSuspendTime,
-                millisecondsSpentInSession,
-                interruptionCount);
-        }
-    }
-
-
-    /**
-     * Constructor to be used for V1 serialization only, DO NOT CHANGE.
-     */
-    private FacebookTimeSpentData(
-            long lastResumeTime,
-            long lastSuspendTime,
-            long millisecondsSpentInSession,
-            int interruptionCount
-
-    ) {
-        resetSession();
-        this.lastResumeTime = lastResumeTime;
-        this.lastSuspendTime = lastSuspendTime;
-        this.millisecondsSpentInSession = millisecondsSpentInSession;
-        this.interruptionCount = interruptionCount;
-    }
-
-    /**
-     * Serialization proxy for the FacebookTimeSpentData class. This is version 2 of
-     * serialization. Future serializations may differ in format. This
-     * class should not be modified. If serializations formats change,
-     * create a new class SerializationProxyVx.
-     */
-    private static class SerializationProxyV2 implements Serializable {
-        private static final long serialVersionUID = 6L;
-
-        private final long lastResumeTime;
-        private final long lastSuspendTime;
-        private final long millisecondsSpentInSession;
-        private final int interruptionCount;
-        private final String firstOpenSourceApplication;
-
-        SerializationProxyV2(
-                long lastResumeTime,
-                long lastSuspendTime,
-                long millisecondsSpentInSession,
-                int interruptionCount,
-                String firstOpenSourceApplication
-
-        ) {
-            this.lastResumeTime = lastResumeTime;
-            this.lastSuspendTime = lastSuspendTime;
-            this.millisecondsSpentInSession = millisecondsSpentInSession;
-            this.interruptionCount = interruptionCount;
-            this.firstOpenSourceApplication = firstOpenSourceApplication;
-        }
-
-        private Object readResolve() {
-            return new FacebookTimeSpentData(
-                    lastResumeTime,
-                    lastSuspendTime,
-                    millisecondsSpentInSession,
-                    interruptionCount,
-                    firstOpenSourceApplication);
-        }
-    }
-
-    FacebookTimeSpentData() {
-        resetSession();
-    }
-
-    /**
-     * Constructor to be used for V2 serialization only, DO NOT CHANGE.
-     */
-    private FacebookTimeSpentData(
-        long lastResumeTime,
-        long lastSuspendTime,
-        long millisecondsSpentInSession,
-        int interruptionCount,
-        String firstOpenSourceApplication
-    ) {
-        resetSession();
-        this.lastResumeTime = lastResumeTime;
-        this.lastSuspendTime = lastSuspendTime;
-        this.millisecondsSpentInSession = millisecondsSpentInSession;
-        this.interruptionCount = interruptionCount;
-        this.firstOpenSourceApplication = firstOpenSourceApplication;
-    }
-
-    private Object writeReplace() {
-        return new SerializationProxyV2(
-                lastResumeTime,
-                lastSuspendTime,
-                millisecondsSpentInSession,
-                interruptionCount,
-                firstOpenSourceApplication
-        );
-    }
-
-    // TODO (T41629092) use InternalAppEventsLogger after migration
-    void onSuspend(AppEventsLoggerImpl logger, long eventTime) {
-        if (!isAppActive) {
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Suspend for inactive app");
-            return;
-        }
-
-        long now = eventTime;
-        long delta = (now - lastResumeTime);
-        if (delta < 0) {
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Clock skew detected");
-            delta = 0;
-        }
-        millisecondsSpentInSession += delta;
-        lastSuspendTime = now;
-        isAppActive = false;
-    }
-
-    // TODO (T41629092) use InternalAppEventsLogger after migration
-    void onResume(AppEventsLoggerImpl logger, long eventTime, String sourceApplicationInfo) {
-        long now = eventTime;
-
-        // Retain old behavior for activated app event - log the event if the event hasn't
-        // been logged in the previous suppression interval or this is a cold launch.
-        // If this is a cold launch, always log the event. Otherwise, use the last
-        // event log time to determine if the app activate should be suppressed or not.
-        if (isColdLaunch() || ((now - lastActivateEventLoggedTime) >
-                APP_ACTIVATE_SUPPRESSION_PERIOD_IN_MILLISECONDS)) {
-            Bundle eventParams = new Bundle();
-            eventParams.putString(
-                    AppEventsConstants.EVENT_PARAM_SOURCE_APPLICATION,
-                    sourceApplicationInfo);
-            logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP, eventParams);
-            lastActivateEventLoggedTime = now;
-            if (logger.getFlushBehavior() != AppEventsLogger.FlushBehavior.EXPLICIT_ONLY) {
-              logger.flush();
-            }
-        }
-
-        // If this is an application that's not calling onSuspend yet, log and return. We can't
-        // track time spent for this application as there are no calls to onSuspend.
-        if (isAppActive) {
-          Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Resume for active app");
-          return;
-        }
-
-        long interruptionDurationMillis = wasSuspendedEver() ? now - lastSuspendTime : 0;
-        if (interruptionDurationMillis < 0) {
-          Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Clock skew detected");
-          interruptionDurationMillis = 0;
-        }
-
-        // If interruption duration is > new session threshold, then log old session
-        // event and start a new session.
-        if (interruptionDurationMillis > NUM_MILLISECONDS_IDLE_TO_BE_NEW_SESSION) {
-            logAppDeactivatedEvent(logger, interruptionDurationMillis);
-        } else {
-            // We're not logging this resume event - check to see if this should count
-            // as an interruption
-            if (interruptionDurationMillis > INTERRUPTION_THRESHOLD_MILLISECONDS) {
-                interruptionCount++;
-            }
-        }
-
-        // Set source application only for the first resume of the timespent session.
-        if (interruptionCount == 0) {
-            firstOpenSourceApplication = sourceApplicationInfo;
-        }
-
-        lastResumeTime = now;
-        isAppActive = true;
-    }
-
-    // TODO (T41629092) use InternalAppEventsLogger after migration
-    private void logAppDeactivatedEvent(AppEventsLoggerImpl logger,
-                                        long interruptionDurationMillis) {
-        // Log the old session information and clear the data
-        Bundle eventParams = new Bundle();
-        eventParams.putInt(
-                AppEventsConstants.EVENT_NAME_SESSION_INTERRUPTIONS,
-                interruptionCount);
-        eventParams.putString(
-                AppEventsConstants.EVENT_NAME_TIME_BETWEEN_SESSIONS,
-                String.format(
-                        Locale.ROOT,
-                        "session_quanta_%d",
-                        getQuantaIndex(interruptionDurationMillis)));
-        eventParams.putString(
-                AppEventsConstants.EVENT_PARAM_SOURCE_APPLICATION,
-                firstOpenSourceApplication);
-        logger.logEvent(
-                AppEventsConstants.EVENT_NAME_DEACTIVATED_APP,
-                (millisecondsSpentInSession/DateUtils.SECOND_IN_MILLIS),
-                eventParams);
-        resetSession();
-    }
-
-    private static int getQuantaIndex(long timeBetweenSessions) {
-        int quantaIndex = 0;
-
-        while (
-            quantaIndex < INACTIVE_SECONDS_QUANTA.length &&
-            INACTIVE_SECONDS_QUANTA[quantaIndex] < timeBetweenSessions
-        ) {
-            ++quantaIndex;
-        }
-
-        return quantaIndex;
-    }
-
-    private void resetSession() {
-        isAppActive = false;
-        lastResumeTime = FIRST_TIME_LOAD_RESUME_TIME;
-        lastSuspendTime = FIRST_TIME_LOAD_RESUME_TIME;
-        interruptionCount = 0;
-        millisecondsSpentInSession = 0;
-    }
-
-    private boolean wasSuspendedEver() {
-        return lastSuspendTime != FIRST_TIME_LOAD_RESUME_TIME;
-    }
-
-    private boolean isColdLaunch() {
-        // On the very first call in the process lifecycle, this will always
-        // return true. After that, it will always return false.
-        boolean result = !isWarmLaunch;
-        isWarmLaunch = true;
-        return result;
-    }
-}
diff --git a/facebook-core/src/main/java/com/facebook/appevents/InternalAppEventsLogger.java b/facebook-core/src/main/java/com/facebook/appevents/InternalAppEventsLogger.java
index 3ab5d3d07..1150349f5 100644
--- a/facebook-core/src/main/java/com/facebook/appevents/InternalAppEventsLogger.java
+++ b/facebook-core/src/main/java/com/facebook/appevents/InternalAppEventsLogger.java
@@ -120,10 +120,6 @@ public void flush() {
         loggerImpl.flush();
     }
 
-    static String getSourceApplication() {
-        return AppEventsLoggerImpl.getSourceApplication();
-    }
-
     static Executor getAnalyticsExecutor() {
         return AppEventsLoggerImpl.getAnalyticsExecutor();
     }
