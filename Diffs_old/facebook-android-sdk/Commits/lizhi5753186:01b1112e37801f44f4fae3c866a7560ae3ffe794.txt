diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
index 9b9671ece..20d25d7ef 100644
--- a/facebook/src/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -17,5 +17,5 @@
 package com.facebook;
 
 final class FacebookSdkVersion {
-    public static final String BUILD = "3.19.1";
+    public static final String BUILD = "3.20.0";
 }
diff --git a/facebook/src/com/facebook/internal/AttributionIdentifiers.java b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
index b4e5eb4ed..57db65c67 100644
--- a/facebook/src/com/facebook/internal/AttributionIdentifiers.java
+++ b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
@@ -120,7 +120,7 @@ public static AttributionIdentifiers getAttributionIdentifiers(Context context)
             String [] projection = {ATTRIBUTION_ID_COLUMN_NAME, ANDROID_ID_COLUMN_NAME, LIMIT_TRACKING_COLUMN_NAME};
             c = context.getContentResolver().query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
             if (c == null || !c.moveToFirst()) {
-                return null;
+                return identifiers;
             }
             int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
             int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
@@ -159,4 +159,4 @@ public String getAndroidAdvertiserId() {
     public boolean isTrackingLimited() {
         return limitTracking;
     }
-}
\ No newline at end of file
+}
diff --git a/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
index 5333187dc..2a2f4b603 100644
--- a/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
+++ b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
@@ -20,6 +20,9 @@
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.webkit.WebView;
 import com.facebook.FacebookException;
 import com.facebook.android.Util;
 import com.facebook.widget.FacebookDialog;
@@ -39,6 +42,9 @@
  */
 public class FacebookWebFallbackDialog extends WebDialog {
     private static final String TAG = FacebookWebFallbackDialog.class.getName();
+    private static final int OS_BACK_BUTTON_RESPONSE_TIMEOUT_MILLISECONDS = 1500;
+
+    private boolean waitingForDialogToClose;
 
     public static boolean presentWebFallback(final Context context,
                                              String dialogUrl,
@@ -121,4 +127,48 @@ protected Bundle parseResponseUri(String url) {
 
         return queryParams;
     }
+
+    @Override
+    public void dismiss() {
+        WebView webView = getWebView();
+
+        if (isListenerCalled() || webView == null || !webView.isShown()) {
+            // If the listener has been called, or if the WebView isn't visible, we cannot give the dialog a chance
+            // to respond. So defer to the parent implementation.
+            super.dismiss();
+            return;
+        }
+
+        // If we have already notified the dialog to close, then ignore this request to dismiss. The timer will
+        // honor the request.
+        if (waitingForDialogToClose) {
+            return;
+        }
+        waitingForDialogToClose = true;
+
+        // Now fire off the event that will tell the dialog to wind down.
+        String eventJS =
+                "(function() {" +
+                "  var event = document.createEvent('Event');" +
+                "  event.initEvent('fbPlatformDialogMustClose',true,true);" +
+                "  document.dispatchEvent(event);" +
+                "})();";
+        webView.loadUrl("javascript:" + eventJS);
+
+        // Set up a timeout for the dialog to respond. If the timer expires, we need to honor the user's desire to
+        // dismiss the dialog.
+        Handler handler = new Handler(Looper.getMainLooper());
+        handler.postDelayed(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        if (!isListenerCalled()) {
+                            // If we get here, then the dialog did not close quickly enough. So we need to honor the user's
+                            // wish to cancel.
+                            sendCancelToListener();
+                        }
+                    }
+                },
+                OS_BACK_BUTTON_RESPONSE_TIMEOUT_MILLISECONDS);
+    }
 }
diff --git a/facebook/src/com/facebook/internal/ImageDownloader.java b/facebook/src/com/facebook/internal/ImageDownloader.java
index 4c801404f..058c55bc8 100644
--- a/facebook/src/com/facebook/internal/ImageDownloader.java
+++ b/facebook/src/com/facebook/internal/ImageDownloader.java
@@ -22,6 +22,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import com.facebook.FacebookException;
+import com.facebook.android.R;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -246,22 +247,19 @@ private static void download(RequestKey key, Context context) {
 
                 default:
                     stream = connection.getErrorStream();
-                    
-                    // Android 2.1 - When request timeout stream return null and cause NullPointerException
                     StringBuilder errorMessageBuilder = new StringBuilder();
-                    if (stream != null){
+                    if (stream != null) {
                         InputStreamReader reader = new InputStreamReader(stream);
                         char[] buffer = new char[128];
                         int bufferLength;
-                        
                         while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
                             errorMessageBuilder.append(buffer, 0, bufferLength);
                         }
                         Utility.closeQuietly(reader);
                     } else {
-                        errorMessageBuilder.append(R.string.com_facebook_image_download_unknown_error);
+                        errorMessageBuilder.append(
+                            context.getString(R.string.com_facebook_image_download_unknown_error));
                     }
-
                     error = new FacebookException(errorMessageBuilder.toString());
                     break;
             }
diff --git a/facebook/src/com/facebook/internal/NativeProtocol.java b/facebook/src/com/facebook/internal/NativeProtocol.java
index 50ca6f88a..aae17e894 100644
--- a/facebook/src/com/facebook/internal/NativeProtocol.java
+++ b/facebook/src/com/facebook/internal/NativeProtocol.java
@@ -634,6 +634,15 @@ private static int getLatestAvailableProtocolVersionForAppInfo(
             Context context,
             NativeAppInfo appInfo,
             int[] versionSpec) {
+        TreeSet<Integer> fbAppVersions = getAllAvailableProtocolVersionsForAppInfo(context, appInfo);
+        return computeLatestAvailableVersionFromVersionSpec(fbAppVersions, getLatestKnownVersion(), versionSpec);
+    }
+
+    private static TreeSet<Integer> getAllAvailableProtocolVersionsForAppInfo(
+            Context context,
+            NativeAppInfo appInfo) {
+        TreeSet<Integer> allAvailableVersions = new TreeSet<Integer>();
+
         ContentResolver contentResolver = context.getContentResolver();
 
         String [] projection = new String[]{ PLATFORM_PROVIDER_VERSION_COLUMN };
@@ -641,50 +650,62 @@ private static int getLatestAvailableProtocolVersionForAppInfo(
         Cursor c = null;
         try {
             c = contentResolver.query(uri, projection, null, null, null);
-            if (c == null) {
-                return NO_PROTOCOL_AVAILABLE;
+            if (c != null) {
+                while (c.moveToNext()) {
+                    int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
+                    allAvailableVersions.add(version);
+                }
             }
-
-            TreeSet<Integer> fbAppVersions = new TreeSet<Integer>();
-            while (c.moveToNext()) {
-                int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
-                fbAppVersions.add(version);
+        } finally {
+            if (c != null) {
+                c.close();
             }
+        }
 
-            // Remember that these ranges are sorted in ascending order and can be unbounded. So we are starting
-            // from the end of the version-spec array and working backwards, to try get the newest possible version
-            int versionSpecIndex = versionSpec.length - 1;
-            Iterator<Integer> fbAppVersionsIterator = fbAppVersions.descendingIterator();
-            int latestAllowedVersion = getLatestKnownVersion();
-            while (fbAppVersionsIterator.hasNext()) {
-                int fbAppVersion = fbAppVersionsIterator.next();
-
-                // If there is a newer version in the versionSpec, throw it away, we don't have it
-                while (versionSpecIndex >= 0 && versionSpec[versionSpecIndex] > fbAppVersion) {
-                    versionSpecIndex--;
-                }
+        return allAvailableVersions;
+    }
 
-                if (versionSpecIndex < 0) {
-                    // There was no fb app version that fell into any range in the versionSpec - or - the
-                    // versionSpec was empty, which means that this action is not supported.
-                    return NO_PROTOCOL_AVAILABLE;
-                }
+    /**
+     * This is public to allow for testing. Developers are discouraged from using this method, since it may change without
+     * notice.
+     */
+    public static int computeLatestAvailableVersionFromVersionSpec(
+            TreeSet<Integer> allAvailableFacebookAppVersions,
+            int latestSdkVersion,
+            int[] versionSpec) {
+        // Remember that these ranges are sorted in ascending order and can be unbounded. So we are starting
+        // from the end of the version-spec array and working backwards, to try get the newest possible version
+        int versionSpecIndex = versionSpec.length - 1;
+        Iterator<Integer> fbAppVersionsIterator = allAvailableFacebookAppVersions.descendingIterator();
+        int latestFacebookAppVersion = -1;
 
-                // If we are here, we know we are within a range specified in the versionSpec. We should see if it is
-                // a disabled or enabled range.
+        while (fbAppVersionsIterator.hasNext()) {
+            int fbAppVersion = fbAppVersionsIterator.next();
 
-                if (versionSpec[versionSpecIndex] == fbAppVersion) {
-                    // if the versionSpecIndex is even, it is enabled; if odd, disabled
-                    return (
-                            versionSpecIndex % 2 == 0 ?
-                                    Math.min(fbAppVersion, latestAllowedVersion) :
-                                    NO_PROTOCOL_AVAILABLE
-                    );
-                }
+            // We're holding on to the greatest fb-app version available.
+            latestFacebookAppVersion = Math.max(latestFacebookAppVersion, fbAppVersion);
+
+            // If there is a newer version in the versionSpec, throw it away, we don't have it
+            while (versionSpecIndex >= 0 && versionSpec[versionSpecIndex] > fbAppVersion) {
+                versionSpecIndex--;
             }
-        } finally {
-            if (c != null) {
-                c.close();
+
+            if (versionSpecIndex < 0) {
+                // There was no fb app version that fell into any range in the versionSpec - or - the
+                // versionSpec was empty, which means that this action is not supported.
+                return NO_PROTOCOL_AVAILABLE;
+            }
+
+            // If we are here, we know we are within a range specified in the versionSpec. We should see if it is
+            // a disabled or enabled range.
+
+            if (versionSpec[versionSpecIndex] == fbAppVersion) {
+                // if the versionSpecIndex is even, it is enabled; if odd, disabled
+                return (
+                        versionSpecIndex % 2 == 0 ?
+                                Math.min(latestFacebookAppVersion, latestSdkVersion) :
+                                NO_PROTOCOL_AVAILABLE
+                );
             }
         }
 
diff --git a/facebook/src/com/facebook/internal/PlatformServiceClient.java b/facebook/src/com/facebook/internal/PlatformServiceClient.java
index 16d619c3b..df75fc5e5 100644
--- a/facebook/src/com/facebook/internal/PlatformServiceClient.java
+++ b/facebook/src/com/facebook/internal/PlatformServiceClient.java
@@ -96,7 +96,11 @@ public void onServiceConnected(ComponentName name, IBinder service) {
 
     public void onServiceDisconnected(ComponentName name) {
         sender = null;
-        context.unbindService(this);
+        try {
+            context.unbindService(this);
+        } catch (IllegalArgumentException ex) {
+            // Do nothing, the connection was already unbound
+        }
         callback(null);
     }
 
diff --git a/facebook/src/com/facebook/internal/ServerProtocol.java b/facebook/src/com/facebook/internal/ServerProtocol.java
index 46931353d..7583f015d 100644
--- a/facebook/src/com/facebook/internal/ServerProtocol.java
+++ b/facebook/src/com/facebook/internal/ServerProtocol.java
@@ -64,7 +64,7 @@
     // URL components
     private static final String GRAPH_VIDEO_URL_FORMAT = "https://graph-video.%s";
     private static final String GRAPH_URL_FORMAT = "https://graph.%s";
-    public static final String GRAPH_API_VERSION = "v2.1";
+    public static final String GRAPH_API_VERSION = "v2.2";
 
     private static final String LEGACY_API_VERSION = "v1.0";
 
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
index 91f627b02..3735e0cce 100644
--- a/facebook/src/com/facebook/internal/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -639,7 +639,9 @@ protected void onPostExecute(GraphObject result) {
                     SharedPreferences sharedPrefs = context.getSharedPreferences(
                             APP_SETTINGS_PREFS_STORE,
                             Context.MODE_PRIVATE);
-                    sharedPrefs.edit().putString(settingsKey, resultJSON.toString()).apply();
+                    sharedPrefs.edit()
+                        .putString(settingsKey, resultJSON.toString())
+                        .apply();
                 }
 
                 initialAppSettingsLoadTask = null;
diff --git a/facebook/tests/src/com/facebook/internal/NativeProtocolVersionTests.java b/facebook/tests/src/com/facebook/internal/NativeProtocolVersionTests.java
new file mode 100644
index 000000000..e08245ab3
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/NativeProtocolVersionTests.java
@@ -0,0 +1,157 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.TreeSet;
+
+public class NativeProtocolVersionTests extends AndroidTestCase {
+    @SmallTest
+    public void testSdkOlderThanApp_versionSpecOpen() {
+        // Base case where a feature was enabled a while ago and the SDK and Native app have been updated
+        // since then.
+        int[] versionSpec = new int[] {3};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @SmallTest
+    public void testSdkNewerThanApp_versionSpecOpen() {
+        // Base case where a feature was enabled a while ago and the SDK and Native app have been updated
+        // since then.
+        int[] versionSpec = new int[] {3};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @SmallTest
+    public void testSdkOlderThanApp_versionSpecDisabled() {
+        // Case where a feature was enabled AND disabled a while ago and the SDK and Native app have been
+        // updated since then.
+        int[] versionSpec = new int[] {1,3,7,8};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @SmallTest
+    public void testSdkNewerThanApp_versionSpecDisabled() {
+        // Case where a feature was enabled AND disabled a while ago and the SDK and Native app have been
+        // updated since then.
+        int[] versionSpec = new int[] {1,3,6,7};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @SmallTest
+    public void testSdkOlderThanApp_versionSpecNewerAndEnabled() {
+        // Case where the sdk and app are older, but the app is still enabled
+        int[] versionSpec = new int[] {1,3,7,9,10,11,12,13};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @SmallTest
+    public void testSdkNewerThanApp_versionSpecNewerAndEnabled() {
+        // Case where the sdk and app are older, but the app is still enabled
+        int[] versionSpec = new int[] {1,3,7,9,10,11,12,13};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @SmallTest
+    public void testSdkOlderThanApp_versionSpecNewerAndDisabled() {
+        // Case where the sdk and app are older, and the app is a disabled version
+        int[] versionSpec = new int[] {1,3,7,8,10,11,12,13};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @SmallTest
+    public void testSdkNewerThanApp_versionSpecNewerAndDisabled() {
+        // Case where the sdk and app are older, and the app is a disabled version
+        int[] versionSpec = new int[] {1,3,6,7,10,11,12,13};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    private TreeSet<Integer> getTreeSetFromIntArray(int[] array) {
+        TreeSet<Integer> treeSet = new TreeSet<Integer>();
+        for (int a : array) {
+            treeSet.add(a);
+        }
+
+        return treeSet;
+    }
+}
